<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="0033b7a240e13680051cb4a1ca7579ca1bea08a8.h"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>jscntxt_h___</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>jscntxt_h___</name></cpp:macro></cpp:define>
<comment type="block">/*
 * JS execution context.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarena.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsclist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslong.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdtoa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jshashtable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspropertycache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspropertytree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprvtd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspubtd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsregexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsvector.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(push)</cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(disable:4100)</cpp:pragma> <comment type="block">/* Silence unreferenced formal parameter warnings */</comment>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(push)</cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(disable:4355)</cpp:pragma> <comment type="block">/* Silence warning about "this" used in base member initializer list */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * js_GetSrcNote cache to avoid O(n^2) growth in finding a source note for a
 * given pc in a script. We use the script-&gt;code pointer to tag the cache,
 * instead of the script address itself, so that source notes are always found
 * by offset from the bytecode with which they were generated.
 */</comment>
<typedef>typedef <type><struct>struct <name>JSGSNCache</name> <block>{
    <decl_stmt><decl><type><name>jsbytecode</name>      *</type><name>code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSDHashTable</name></type>    <name>table</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GSNMETER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>hits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>misses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>fills</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>purges</name></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GSN_CACHE_METER</name><parameter_list>(<param><type><name>cache</name></type></param>,<param><type><name>cnt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(++(cache)-&gt;cnt)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GSN_CACHE_METER</name><parameter_list>(<param><type><name>cache</name></type></param>,<param><type><name>cnt</name></type></param>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>JSGSNCache</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_FinishGSNCache</name><parameter_list>(<param><type><name>cache</name></type></param>)</parameter_list></cpp:macro> <cpp:value>js_PurgeGSNCache(cache)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_PurgeGSNCache</name><parameter_list>(<param><decl><type><name>JSGSNCache</name> *</type><name>cache</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* These helper macros take a cx as parameter and operate on its GSN cache. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PURGE_GSN_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>js_PurgeGSNCache(&amp;JS_GSN_CACHE(cx))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_METER_GSN_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>cnt</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>GSN_CACHE_METER(&amp;JS_GSN_CACHE(cx), cnt)</cpp:value></cpp:define>

<comment type="block">/* Forward declarations of nanojit types. */</comment>
<decl_stmt><decl><type><name>namespace</name></type> <name>nanojit</name> <block>{

<decl_stmt><decl><type><name>class</name></type> <name>Assembler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeAlloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Fragment</name></decl>;</decl_stmt>
<expr_stmt><expr><name>template</name>&lt;<name>typename</name> <name>K</name>&gt; struct <name>DefaultHash</name></expr>;</expr_stmt>
<expr_stmt><expr><name>template</name>&lt;<name>typename</name> <name>K</name></expr>, <expr><name>typename</name> <name>V</name></expr>, <expr><name>typename</name> <name>H</name>&gt; <name>class</name> <name>HashMap</name></expr>;</expr_stmt>
<expr_stmt><expr><name>template</name>&lt;<name>typename</name> <name>T</name>&gt; <name>class</name> <name>Seq</name></expr>;</expr_stmt>

}</block></decl></decl_stmt>  <comment type="block">/* namespace nanojit */</comment>

<decl_stmt><decl><type><name>namespace</name></type> <name>js</name> <block>{

<comment type="block">/* Tracer constants. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>MONITOR_N_GLOBAL_STATES</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>FRAGMENT_TABLE_SIZE</name> <init>= <expr>512</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>MAX_NATIVE_STACK_SLOTS</name> <init>= <expr>4096</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>MAX_CALL_STACK_ENTRIES</name> <init>= <expr>500</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>MAX_GLOBAL_SLOTS</name> <init>= <expr>4096</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>GLOBAL_SLOTS_BUFFER_SIZE</name> <init>= <expr><name>MAX_GLOBAL_SLOTS</name> + 1</expr></init></decl>;</decl_stmt>

<comment type="block">/* Forward declarations of tracer types. */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>VMAllocator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FrameInfoCache</name></decl>;</decl_stmt>
<struct_decl>struct <name>REHashFn</name>;</struct_decl>
<struct_decl>struct <name>REHashKey</name>;</struct_decl>
<struct_decl>struct <name>FrameInfo</name>;</struct_decl>
<struct_decl>struct <name>VMSideExit</name>;</struct_decl>
<struct_decl>struct <name>TreeFragment</name>;</struct_decl>
<struct_decl>struct <name>InterpState</name>;</struct_decl>
<expr_stmt><expr><name>template</name>&lt;<name>typename</name> <name>T</name>&gt; <name>class</name> <name>Queue</name></expr>;</expr_stmt>
<typedef>typedef <expr_stmt><expr><name>Queue</name>&lt;<name>uint16</name>&gt; <name>SlotList</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>class</name></type> <name>TypeMap</name></decl>;</decl_stmt>
<struct_decl>struct <name>REFragment</name>;</struct_decl>
<typedef>typedef <expr_stmt><expr><name>nanojit</name>::<name>HashMap</name>&lt;<name>REHashKey</name></expr>, <expr><name>REFragment</name>*</expr>, <expr><name>REHashFn</name>&gt; <name>REHashMap</name></expr>;</expr_stmt></typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JS_JIT_SPEW</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct_decl>struct <name>FragPI</name>;</struct_decl>
<typedef>typedef <expr_stmt><expr><name>nanojit</name>::<name>HashMap</name>&lt;<name>uint32</name></expr>, <expr><name>FragPI</name></expr>, <expr><name>nanojit</name>::<name>DefaultHash</name>&lt;<name>uint32</name>&gt; &gt; <name>FragStatsMap</name></expr>;</expr_stmt></typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Allocation policy that calls JSContext memory functions and reports errors
 * to the context. Since the JSContext given on construction is stored for
 * the lifetime of the container, this policy may only be used for containers
 * whose lifetime is a shorter than the given JSContext.
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>ContextAllocPolicy</name>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>

  <label><name>public</name>:</label>
    <expr_stmt><expr><call><name>ContextAllocPolicy</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call> : <macro><name>cx</name><argument_list>(<argument>cx</argument>)</argument_list></macro> <block>{}</block>
    <name>JSContext</name> *<macro><name>context</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>cx</name></expr>;</return> }</block></expr></expr_stmt>

    <comment type="block">/* Inline definitions below. */</comment>
    <function_decl><type><name>void</name> *</type><name>malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>free</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name> *</type><name>realloc</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>void</name> <macro><name>reportAllocOverflow</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/* Holds the execution state during trace execution. */</comment>
<struct>struct <name>InterpState</name>
<block>{
    <decl_stmt><decl><type><name>JSContext</name>*</type>     <name>cx</name></decl>;</decl_stmt>                  <comment type="line">// current VM context handle</comment>
    <decl_stmt><decl><type><name>double</name>*</type>        <name>stackBase</name></decl>;</decl_stmt>           <comment type="line">// native stack base</comment>
    <decl_stmt><decl><type><name>double</name>*</type>        <name>sp</name></decl>;</decl_stmt>                  <comment type="line">// native stack pointer, stack[0] is spbase[0]</comment>
    <decl_stmt><decl><type><name>double</name>*</type>        <name>eos</name></decl>;</decl_stmt>                 <comment type="line">// first unusable word after the native stack / begin of globals</comment>
    <decl_stmt><decl><type><name>FrameInfo</name>**</type>    <name>callstackBase</name></decl>;</decl_stmt>       <comment type="line">// call stack base</comment>
    <decl_stmt><decl><type><name>void</name>*</type>          <name>sor</name></decl>;</decl_stmt>                 <comment type="line">// start of rp stack</comment>
    <decl_stmt><decl><type><name>FrameInfo</name>**</type>    <name>rp</name></decl>;</decl_stmt>                  <comment type="line">// call stack pointer</comment>
    <decl_stmt><decl><type><name>void</name>*</type>          <name>eor</name></decl>;</decl_stmt>                 <comment type="line">// first unusable word after the call stack</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type>    <name>lastTreeExitGuard</name></decl>;</decl_stmt>   <comment type="line">// guard we exited on during a tree call</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type>    <name>lastTreeCallGuard</name></decl>;</decl_stmt>   <comment type="line">// guard we want to grow from if the tree</comment>
                                        <comment type="line">// call exit guard mismatched</comment>
    <decl_stmt><decl><type><name>void</name>*</type>          <name>rpAtLastTreeCall</name></decl>;</decl_stmt>    <comment type="line">// value of rp at innermost tree call guard</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type>    <name>outermostTreeExitGuard</name></decl>;</decl_stmt> <comment type="line">// the last side exit returned by js_CallTree</comment>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type>  <name>outermostTree</name></decl>;</decl_stmt>       <comment type="line">// the outermost tree we initially invoked</comment>
    <decl_stmt><decl><type><name>uintN</name>*</type>         <name>inlineCallCountp</name></decl>;</decl_stmt>    <comment type="line">// inline call count counter</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>**</type>   <name>innermostNestedGuardp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type>    <name>innermost</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>         <name>startTime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>InterpState</name>*</type>   <name>prev</name></decl>;</decl_stmt>

    <comment type="line">// Used by _FAIL builtins; see jsbuiltins.h. The builtin sets the</comment>
    <comment type="line">// JSBUILTIN_BAILED bit if it bails off trace and the JSBUILTIN_ERROR bit</comment>
    <comment type="line">// if an error or exception occurred.</comment>
    <decl_stmt><decl><type><name>uint32</name></type>         <name>builtinStatus</name></decl>;</decl_stmt>

    <comment type="line">// Used to communicate the location of the return value in case of a deep bail.</comment>
    <decl_stmt><decl><type><name>double</name>*</type>        <name>deepBailSp</name></decl>;</decl_stmt>

    <comment type="line">// Used when calling natives from trace to root the vp vector.</comment>
    <decl_stmt><decl><type><name>uintN</name></type>          <name>nativeVpLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>*</type>         <name>nativeVp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>InterpState</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>TraceMonitor</name> *<name>tm</name></expr></argument>, <argument><expr><name>TreeFragment</name> *<name>ti</name></expr></argument>,
                <argument><expr><name>uintN</name> &amp;<name>inlineCallCountp</name></expr></argument>, <argument><expr><name>VMSideExit</name>** <name>innermostNestedGuardp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>~<call><name>InterpState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block>;</struct>

<comment type="block">/*
 * Storage for the execution state and store during trace execution. Generated
 * code depends on the fact that the globals begin |MAX_NATIVE_STACK_SLOTS|
 * doubles after the stack begins. Thus, on trace, |InterpState::eos| holds a
 * pointer to the first global.
 */</comment>
<struct>struct <name>TraceNativeStorage</name>
<block>{
    <decl_stmt><decl><type><name>double</name></type> <name><name>stack_global_buf</name><index>[<expr><name>MAX_NATIVE_STACK_SLOTS</name> + <name>GLOBAL_SLOTS_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FrameInfo</name> *</type><name><name>callstack_buf</name><index>[<expr><name>MAX_CALL_STACK_ENTRIES</name></expr>]</index></name></decl>;</decl_stmt>

    <function><type><name>double</name> *</type><name>stack</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>stack_global_buf</name></expr>;</return> }</block></function>
    <function><type><name>double</name> *</type><name>global</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>stack_global_buf</name> + <name>MAX_NATIVE_STACK_SLOTS</name></expr>;</return> }</block></function>
    <function><type><name>FrameInfo</name> **</type><name>callstack</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>callstack_buf</name></expr>;</return> }</block></function>
}</block>;</struct>

<comment type="block">/* Holds data to track a single globa. */</comment>
<struct>struct <name>GlobalState</name> <block>{
    <decl_stmt><decl><type><name>JSObject</name>*</type>               <name>globalObj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>                  <name>globalShape</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SlotList</name>*</type>               <name>globalSlots</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * A callstack contains a set of stack frames linked by fp-&gt;down. A callstack
 * is a member of a JSContext and all of a JSContext's callstacks are kept in a
 * list starting at cx-&gt;currentCallStack. A callstack may be active or
 * suspended. There are zero or one active callstacks for a context and any
 * number of suspended contexts. If there is an active context, it is the first
 * in the currentCallStack list, |cx-&gt;fp != NULL| and the callstack's newest
 * (top) stack frame is |cx-&gt;fp|. For all other (suspended) callstacks, the
 * newest frame is pointed to by suspendedFrame.
 *
 * While all frames in a callstack are down-linked, not all down-linked frames
 * are in the same callstack (e.g., calling js_Execute with |down != cx-&gt;fp|
 * will create a new frame in a new active callstack).
 */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>CallStack</name>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/* The context to which this callstack belongs. */</comment>
    <decl_stmt><decl><type><name>JSContext</name>           *</type><name>cx</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If this callstack is suspended, the top of the callstack. */</comment>
    <decl_stmt><decl><type><name>JSStackFrame</name>        *</type><name>suspendedFrame</name></decl>;</decl_stmt>

    <comment type="block">/* This callstack was suspended by JS_SaveFrameChain. */</comment>
    <decl_stmt><decl><type><name>bool</name></type>                <name>saved</name></decl>;</decl_stmt>

    <comment type="block">/* Links members of the JSContext::currentCallStack list. */</comment>
    <decl_stmt><decl><type><name>CallStack</name>           *</type><name>previous</name></decl>;</decl_stmt>

    <comment type="block">/* The varobj on entry to initialFrame. */</comment>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>initialVarObj</name></decl>;</decl_stmt>

    <comment type="block">/* The first frame executed in this callstack. */</comment>
    <decl_stmt><decl><type><name>JSStackFrame</name>        *</type><name>initialFrame</name></decl>;</decl_stmt>

  <label><name>public</name>:</label>
    <expr_stmt><expr><call><name>CallStack</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list></call>
      :
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <call><name>cx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr><call><name>suspendedFrame</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>saved</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>previous</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>initialVarObj</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <macro><name>initialFrame</name><argument_list>(<argument>NULL</argument>)</argument_list></macro>
    <expr><block>{}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <name>bool</name> <call><name>contains</name><argument_list>(<argument><expr><name>JSStackFrame</name> *<name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><name>void</name></type> <name>suspend</name><parameter_list>(<param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>fp</name> &amp;&amp; !<call><name>isSuspended</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>contains</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>suspendedFrame</name> = <name>fp</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>resume</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>suspendedFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>suspendedFrame</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></function>

    <expr_stmt><expr><name>JSStackFrame</name> *<macro><name>getSuspendedFrame</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>suspendedFrame</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>suspendedFrame</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>bool</name> <macro><name>isSuspended</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr>!!<name>suspendedFrame</name></expr>;</return> }</block></expr></expr_stmt>

    <function><type><name>void</name></type> <name>setPrevious</name><parameter_list>(<param><decl><type><name>CallStack</name> *</type><name>cs</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>previous</name> = <name>cs</name></expr>;</expr_stmt> }</block></function>
    <expr_stmt><expr><name>CallStack</name> *<macro><name>getPrevious</name><argument_list>()</argument_list></macro> const  <block>{ <return>return <expr><name>previous</name></expr>;</return> }</block></expr></expr_stmt>

    <function><type><name>void</name></type> <name>setInitialVarObj</name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>o</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>initialVarObj</name> = <name>o</name></expr>;</expr_stmt> }</block></function>
    <expr_stmt><expr><name>JSObject</name> *<macro><name>getInitialVarObj</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>initialVarObj</name></expr>;</return> }</block></expr></expr_stmt>

    <function><type><name>void</name></type> <name>setInitialFrame</name><parameter_list>(<param><decl><type><name>JSStackFrame</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>initialFrame</name> = <name>f</name></expr>;</expr_stmt> }</block></function>
    <expr_stmt><expr><name>JSStackFrame</name> *<macro><name>getInitialFrame</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>initialFrame</name></expr>;</return> }</block></expr></expr_stmt>

    <comment type="block">/*
     * Saving and restoring is a special case of suspending and resuming
     * whereby the active callstack becomes suspended without pushing a new
     * active callstack. This means that if a callstack c1 is pushed on top of a
     * saved callstack c2, when c1 is popped, c2 must not be made active. In
     * the normal case, where c2 is not saved, when c1 is popped, c2 is made
     * active. This distinction is indicated by the |saved| flag.
     */</comment>

    <function><type><name>void</name></type> <name>save</name><parameter_list>(<param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>suspend</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>saved</name> = <name>true</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>restore</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><name>saved</name> = <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>resume</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <expr_stmt><expr><name>bool</name> <macro><name>isSaved</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>saved</name></expr></argument>, <argument><expr><call><name>isSuspended</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>saved</name></expr>;</return>
    }</block></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<comment type="block">/* Holds the number of recording attemps for an address. */</comment>
<typedef>typedef <expr_stmt><expr><name>HashMap</name>&lt;<name>jsbytecode</name>*</expr>,
                <expr><name>size_t</name></expr>,
                <expr><name>DefaultHasher</name>&lt;<name>jsbytecode</name>*&gt;</expr>,
                <expr><name>SystemAllocPolicy</name>&gt; <name>RecordAttemptMap</name></expr>;</expr_stmt></typedef>

<comment type="block">/*
 * Trace monitor. Every JSThread (if JS_THREADSAFE) or JSRuntime (if not
 * JS_THREADSAFE) has an associated trace monitor that keeps track of loop
 * frequencies for all JavaScript code loaded into that runtime.
 */</comment>
<struct>struct <name>TraceMonitor</name> <block>{
    <comment type="block">/*
     * The context currently executing JIT-compiled code on this thread, or
     * NULL if none. Among other things, this can in certain cases prevent
     * last-ditch GC and suppress calls to JS_ReportOutOfMemory.
     *
     * !tracecx &amp;&amp; !recorder: not on trace
     * !tracecx &amp;&amp; recorder: recording
     * tracecx &amp;&amp; !recorder: executing a trace
     * tracecx &amp;&amp; recorder: executing inner loop, recording outer loop
     */</comment>
    <decl_stmt><decl><type><name>JSContext</name>               *</type><name>tracecx</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Cached storage to use when executing on trace. While we may enter nested
     * traces, we always reuse the outer trace's storage, so never need more
     * than of these.
     */</comment>
    <decl_stmt><decl><type><name>TraceNativeStorage</name>      *</type><name>storage</name></decl>;</decl_stmt>

    <comment type="block">/*
     * There are 5 allocators here.  This might seem like overkill, but they
     * have different lifecycles, and by keeping them separate we keep the
     * amount of retained memory down significantly.  They are flushed (ie.
     * all the allocated memory is freed) periodically.
     *
     * - dataAlloc has the lifecycle of the monitor.  It's flushed only when
     *   the monitor is flushed.  It's used for fragments.
     *
     * - traceAlloc has the same flush lifecycle as the dataAlloc, but it is
     *   also *marked* when a recording starts and rewinds to the mark point
     *   if recording aborts.  So you can put things in it that are only
     *   reachable on a successful record/compile cycle like GuardRecords and
     *   SideExits.
     *
     * - tempAlloc is flushed after each recording, successful or not.  It's
     *   used to store LIR code and for all other elements in the LIR
     *   pipeline.
     *
     * - reTempAlloc is just like tempAlloc, but is used for regexp
     *   compilation in RegExpNativeCompiler rather than normal compilation in
     *   TraceRecorder.
     *
     * - codeAlloc has the same lifetime as dataAlloc, but its API is
     *   different (CodeAlloc vs. VMAllocator).  It's used for native code.
     *   It's also a good idea to keep code and data separate to avoid I-cache
     *   vs. D-cache issues.
     */</comment>
    <decl_stmt><decl><type><name>VMAllocator</name>*</type>            <name>dataAlloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMAllocator</name>*</type>            <name>traceAlloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMAllocator</name>*</type>            <name>tempAlloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMAllocator</name>*</type>            <name>reTempAlloc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nanojit</name>::<name>CodeAlloc</name>*     <name>codeAlloc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nanojit</name>::<name>Assembler</name>*     <name>assembler</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>FrameInfoCache</name>*</type>         <name>frameCache</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TraceRecorder</name>*</type>          <name>recorder</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>GlobalState</name></type>             <name><name>globalStates</name><index>[<expr><name>MONITOR_N_GLOBAL_STATES</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type>           <name><name>vmfragments</name><index>[<expr><name>FRAGMENT_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RecordAttemptMap</name>*</type>       <name>recordAttempts</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Maximum size of the code cache before we start flushing. 1/16 of this
     * size is used as threshold for the regular expression code cache.
     */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>                  <name>maxCodeCacheBytes</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If nonzero, do not flush the JIT cache after a deep bail. That would
     * free JITted code pages that we will later return to. Instead, set the
     * needFlush flag so that it can be flushed later.
     */</comment>
    <decl_stmt><decl><type><name>JSBool</name></type>                  <name>needFlush</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Fragment map for the regular expression compiler.
     */</comment>
    <decl_stmt><decl><type><name>REHashMap</name>*</type>              <name>reFragments</name></decl>;</decl_stmt>

    <comment type="line">// Cached temporary typemap to avoid realloc'ing every time we create one.</comment>
    <comment type="line">// This must be used in only one place at a given time. It must be cleared</comment>
    <comment type="line">// before use.</comment>
    <decl_stmt><decl><type><name>TypeMap</name>*</type>                <name>cachedTempTypeMap</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/* Fields needed for fragment/guard profiling. */</comment>
    <expr_stmt><expr><name>nanojit</name>::<name>Seq</name>&lt;<name>nanojit</name>::<name>Fragment</name>*&gt;* <name>branches</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>                  <name>lastFragID</name></decl>;</decl_stmt>
    <comment type="block">/*
     * profAlloc has a lifetime which spans exactly from js_InitJIT to
     * js_FinishJIT.
     */</comment>
    <decl_stmt><decl><type><name>VMAllocator</name>*</type>            <name>profAlloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FragStatsMap</name>*</type>           <name>profTab</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Flush the JIT cache. */</comment>
    <function_decl><type><name>void</name></type> <name>flush</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block">/* Mark all objects baked into native code in the code cache. */</comment>
    <function_decl><type><name>void</name></type> <name>mark</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name>bool</name> <macro><name>outOfMemory</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
}</block>;</struct>

}</block></decl></decl_stmt> <comment type="block">/* namespace js */</comment>

<comment type="block">/*
 * N.B. JS_ON_TRACE(cx) is true if JIT code is on the stack in the current
 * thread, regardless of whether cx is the context in which that trace is
 * executing.  cx must be a context on the current thread.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_ON_TRACE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>(JS_TRACE_MONITOR(cx).tracecx != NULL)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_ON_TRACE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>JS_FALSE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendan</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_EVAL_CACHE_METERING</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_FUNCTION_METERING</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Number of potentially reusable scriptsToGC to search for the eval cache. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JS_EVAL_CACHE_SHIFT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_EVAL_CACHE_SHIFT</name></cpp:macro>        <cpp:value>6</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_EVAL_CACHE_SIZE</name></cpp:macro>          <cpp:value>JS_BIT(JS_EVAL_CACHE_SHIFT)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_EVAL_CACHE_METERING</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EVAL_CACHE_METER_LIST</name><parameter_list>(<param><type><name>_</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>_(probe), _(hit), _(step), _(noscope)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>identity</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>                <cpp:value>x</cpp:value></cpp:define>

<struct>struct <name>JSEvalCacheMeter</name> <block>{
    <function_decl><type><name>uint64</name></type> <name>EVAL_CACHE_METER_LIST</name><parameter_list>(<param><decl><type><name>identity</name></type></decl></param>)</parameter_list>;</function_decl>
}</block>;</struct>

<cpp:undef># <cpp:directive>undef</cpp:directive> <name>identity</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_FUNCTION_METERING</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCTION_KIND_METER_LIST</name><parameter_list>(<param><type><name>_</name></type></param>)</parameter_list></cpp:macro>                                          \
                        <cpp:value>_(allfun), _(heavy), _(nofreeupvar), _(onlyfreevar),  \
                        _(display), _(flat), _(setupvar), _(badfunarg)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>identity</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>x</cpp:value></cpp:define>

<struct>struct <name>JSFunctionMeter</name> <block>{
    <function_decl><type><name>int32</name></type> <name>FUNCTION_KIND_METER_LIST</name><parameter_list>(<param><decl><type><name>identity</name></type></decl></param>)</parameter_list>;</function_decl>
}</block>;</struct>

<cpp:undef># <cpp:directive>undef</cpp:directive> <name>identity</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct_decl>struct <name>JSLocalRootChunk</name>;</struct_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSLRS_CHUNK_SHIFT</name></cpp:macro>       <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSLRS_CHUNK_SIZE</name></cpp:macro>        <cpp:value>JS_BIT(JSLRS_CHUNK_SHIFT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSLRS_CHUNK_MASK</name></cpp:macro>        <cpp:value>JS_BITMASK(JSLRS_CHUNK_SHIFT)</cpp:value></cpp:define>

<struct>struct <name>JSLocalRootChunk</name> <block>{
    <decl_stmt><decl><type><name>jsval</name></type>               <name><name>roots</name><index>[<expr><name>JSLRS_CHUNK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSLocalRootChunk</name>    *</type><name>down</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>JSLocalRootStack</name> <block>{
    <decl_stmt><decl><type><name>uint32</name></type>              <name>scopeMark</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>rootCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSLocalRootChunk</name>    *</type><name>topChunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSLocalRootChunk</name></type>    <name>firstChunk</name></decl>;</decl_stmt>

    <comment type="block">/* See comments in js_NewFinalizableGCThing. */</comment>
    <decl_stmt><decl><type><name>JSGCFreeLists</name></type>       <name>gcFreeLists</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint32</name></type> <name>JSLRS_NULL_MARK</name> <init>= <expr><call><name>uint32</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<struct>struct <name>JSThreadData</name> <block>{
    <decl_stmt><decl><type><name>JSGCFreeLists</name></type>       <name>gcFreeLists</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Flag indicating that we are waiving any soft limits on the GC heap
     * because we want allocations to be infallible (except when we hit
     * a hard quota).
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type>                <name>waiveGCQuota</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The GSN cache is per thread since even multi-cx-per-thread embeddings
     * do not interleave js_GetSrcNote calls.
     */</comment>
    <decl_stmt><decl><type><name>JSGSNCache</name></type>          <name>gsnCache</name></decl>;</decl_stmt>

    <comment type="block">/* Property cache for faster call/get/set invocation. */</comment>
    <expr_stmt><expr><name>js</name>::<name>PropertyCache</name>   <name>propertyCache</name></expr>;</expr_stmt>

    <comment type="block">/* Optional stack of heap-allocated scoped local GC roots. */</comment>
    <decl_stmt><decl><type><name>JSLocalRootStack</name>    *</type><name>localRootStack</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <comment type="block">/* Trace-tree JIT recorder/interpreter state. */</comment>
    <expr_stmt><expr><name>js</name>::<name>TraceMonitor</name>    <name>traceMonitor</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Lock-free hashed lists of scripts created by eval to garbage-collect. */</comment>
    <decl_stmt><decl><type><name>JSScript</name>            *</type><name><name>scriptsToGC</name><index>[<expr><name>JS_EVAL_CACHE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_EVAL_CACHE_METERING</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSEvalCacheMeter</name></type>    <name>evalCacheMeter</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* State used by dtoa.c. */</comment>
    <decl_stmt><decl><type><name>DtoaState</name>           *</type><name>dtoaState</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Cache of reusable JSNativeEnumerators mapped by shape identifiers (as
     * stored in scope-&gt;shape). This cache is nulled by the GC and protected
     * by gcLock.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NATIVE_ENUM_CACHE_LOG2</name></cpp:macro>  <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NATIVE_ENUM_CACHE_MASK</name></cpp:macro>  <cpp:value>JS_BITMASK(NATIVE_ENUM_CACHE_LOG2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NATIVE_ENUM_CACHE_SIZE</name></cpp:macro>  <cpp:value>JS_BIT(NATIVE_ENUM_CACHE_LOG2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NATIVE_ENUM_CACHE_HASH</name><parameter_list>(<param><type><name>shape</name></type></param>)</parameter_list></cpp:macro>                                         \
    <cpp:value>((((shape) &gt;&gt; NATIVE_ENUM_CACHE_LOG2) ^ (shape)) &amp; NATIVE_ENUM_CACHE_MASK)</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>jsuword</name></type>             <name><name>nativeEnumCache</name><index>[<expr><name>NATIVE_ENUM_CACHE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * One-entry deep cache of iterator objects. We deposit here the last
     * iterator that was freed in JSOP_ENDITER.
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name>           *</type><name>cachedIteratorObject</name></decl>;</decl_stmt>

    <function_decl><type><name>bool</name></type> <name>init</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>finish</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>mark</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>purge</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>purgeGCFreeLists</name><parameter_list>()</parameter_list>;</function_decl>
}</block>;</struct>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>

<comment type="block">/*
 * Structure uniquely representing a thread.  It holds thread-private data
 * that can be accessed without a global lock.
 */</comment>
<struct>struct <name>JSThread</name> <block>{
    <comment type="block">/* Linked list of all contexts in use on this thread. */</comment>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>contextList</name></decl>;</decl_stmt>

    <comment type="block">/* Opaque thread-id, from NSPR's PR_GetCurrentThread(). */</comment>
    <decl_stmt><decl><type><name>jsword</name></type>              <name>id</name></decl>;</decl_stmt>

    <comment type="block">/* Indicates that the thread is waiting in ClaimTitle from jslock.cpp. */</comment>
    <decl_stmt><decl><type><name>JSTitle</name>             *</type><name>titleToShare</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Thread-local version of JSRuntime.gcMallocBytes to avoid taking
     * locks on each JS_malloc.
     */</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>           <name>gcThreadMallocBytes</name></decl>;</decl_stmt>

    <comment type="block">/*
     * This thread is inside js_GC, either waiting until it can start GC, or
     * waiting for GC to finish on another thread. This thread holds no locks;
     * other threads may steal titles from it.
     *
     * Protected by rt-&gt;gcLock.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type>                <name>gcWaiting</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Deallocator task for this thread.
     */</comment>
    <decl_stmt><decl><type><name>JSFreePointerListTask</name> *</type><name>deallocatorTask</name></decl>;</decl_stmt>

    <comment type="block">/* Factored out of JSThread for !JS_THREADSAFE embedding in JSRuntime. */</comment>
    <decl_stmt><decl><type><name>JSThreadData</name></type>        <name>data</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Only when JSThread::gcThreadMallocBytes exhausts the following limit we
 * update JSRuntime::gcMallocBytes.
 * .
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>JS_GC_THREAD_MALLOC_LIMIT</name> <init>= <expr>1 &lt;&lt; 19</expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_THREAD_DATA</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>(&amp;(cx)-&gt;thread-&gt;data)</cpp:value></cpp:define>

<struct>struct <name>JSThreadsHashEntry</name> <block>{
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type>     <name>base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSThread</name>            *</type><name>thread</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <name>JSThread</name> *</type>
<name>js_CurrentThread</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * The function takes the GC lock and does not release in successful return.
 * On error (out of memory) the function releases the lock but delegates
 * the error reporting to the caller.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_InitContextThread</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * On entrance the GC lock must be held and it will be held on exit.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ClearContextThread</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_THREADSAFE */</comment>

<typedef>typedef <type><enum>enum <name>JSDestroyContextMode</name> <block>{
    <decl><name>JSDCM_NO_GC</name></decl>,
    <decl><name>JSDCM_MAYBE_GC</name></decl>,
    <decl><name>JSDCM_FORCE_GC</name></decl>,
    <decl><name>JSDCM_NEW_FAILED</name></decl>
}</block></enum></type> <name>JSDestroyContextMode</name>;</typedef>

<typedef>typedef <type><enum>enum <name>JSRuntimeState</name> <block>{
    <decl><name>JSRTS_DOWN</name></decl>,
    <decl><name>JSRTS_LAUNCHING</name></decl>,
    <decl><name>JSRTS_UP</name></decl>,
    <decl><name>JSRTS_LANDING</name></decl>
}</block></enum></type> <name>JSRuntimeState</name>;</typedef>

<typedef>typedef <type><enum>enum <name>JSBuiltinFunctionId</name> <block>{
    <decl><name>JSBUILTIN_ObjectToIterator</name></decl>,
    <decl><name>JSBUILTIN_CallIteratorNext</name></decl>,
    <decl><name>JSBUILTIN_LIMIT</name></decl>
}</block></enum></type> <name>JSBuiltinFunctionId</name>;</typedef>

<typedef>typedef <type><struct>struct <name>JSPropertyTreeEntry</name> <block>{
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type>     <name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScopeProperty</name>     *</type><name>child</name></decl>;</decl_stmt>
}</block></struct></type> <name>JSPropertyTreeEntry</name>;</typedef>

<typedef>typedef <type>struct <name>JSSetSlotRequest</name></type> <name>JSSetSlotRequest</name>;</typedef>

<struct>struct <name>JSSetSlotRequest</name> <block>{
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>obj</name></decl>;</decl_stmt>           <comment type="block">/* object containing slot to set */</comment>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>pobj</name></decl>;</decl_stmt>          <comment type="block">/* new proto or parent reference */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>              <name>slot</name></decl>;</decl_stmt>           <comment type="block">/* which to set, proto or parent */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>cycle</name></decl>;</decl_stmt>          <comment type="block">/* true if a cycle was detected */</comment>
    <decl_stmt><decl><type><name>JSSetSlotRequest</name>    *</type><name>next</name></decl>;</decl_stmt>          <comment type="block">/* next request in GC worklist */</comment>
}</block>;</struct>

<comment type="block">/* Caching Class.prototype lookups for the standard classes. */</comment>
<struct>struct <name>JSClassProtoCache</name> <block>{
    <function><type><name>void</name></type> <name>purge</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>js</name>::<call><name>PodArrayZero</name><argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_PROTO_CACHE_METERING</name></cpp:ifdef>
    <struct>struct <name>Stats</name> <block>{
        <decl_stmt><decl><type><name>int32</name></type>       <name>probe</name></decl>, <decl><type ref="prev"/><name>hit</name></decl>;</decl_stmt>
    }</block>;</struct>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PROTO_CACHE_METER</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>x</name></type></param>)</parameter_list></cpp:macro>                                             \
    <cpp:value>((void) (JS_ATOMIC_INCREMENT(&amp;(cx)-&gt;runtime-&gt;classProtoCacheStats.x)))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>PROTO_CACHE_METER</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>x</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <label><name>private</name>:</label>
    <struct>struct <name>GlobalAndProto</name> <block>{
        <decl_stmt><decl><type><name>JSObject</name>    *</type><name>global</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSObject</name>    *</type><name>proto</name></decl>;</decl_stmt>
    }</block>;</struct>

    <decl_stmt><decl><type><name>GlobalAndProto</name></type>  <name><name>entries</name><index>[<expr><name>JSProto_LIMIT</name> - <name>JSProto_Object</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:pragma># <cpp:directive>pragma</cpp:directive> GCC visibility push(default)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <function_decl><type><name>friend</name> <name>JSBool</name></type> <name>js_GetClassPrototype</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>scope</name></decl></param>,
                                       <param><decl><type><name>JSProtoKey</name></type> <name>protoKey</name></decl></param>, <param><decl><type><name>JSObject</name> **</type><name>protop</name></decl></param>,
                                       <param><decl><type><name>JSClass</name> *</type><name>clasp</name></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:pragma># <cpp:directive>pragma</cpp:directive> GCC visibility pop</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<struct>struct <name>JSRuntime</name> <block>{
    <comment type="block">/* Runtime state, synchronized by the stateChange/gcLock condvar/lock. */</comment>
    <decl_stmt><decl><type><name>JSRuntimeState</name></type>      <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* Context create/destroy callback. */</comment>
    <decl_stmt><decl><type><name>JSContextCallback</name></type>   <name>cxCallback</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Shape regenerated whenever a prototype implicated by an "add property"
     * property cache fill and induced trace guard has a readonly property or a
     * setter defined on it. This number proxies for the shapes of all objects
     * along the prototype chain of all objects in the runtime on which such an
     * add-property result has been cached/traced.
     *
     * See bug 492355 for more details.
     *
     * This comes early in JSRuntime to minimize the immediate format used by
     * trace-JITted code that reads it.
     */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>protoHazardShape</name></decl>;</decl_stmt>

    <comment type="block">/* Garbage collector state, used by jsgc.c. */</comment>
    <decl_stmt><decl><type><name>JSGCChunkInfo</name>       *</type><name>gcChunkList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaList</name></type>       <name><name>gcArenaList</name><index>[<expr><name>FINALIZE_LIMIT</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCDoubleArenaList</name></type> <name>gcDoubleArenaList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSDHashTable</name></type>        <name>gcRootsHash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSDHashTable</name></type>        <name>gcLocksHash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>gcKeepAtoms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>gcBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>gcLastBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>gcMaxBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>gcMaxMallocBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcEmptyArenaPoolLifespan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcLevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcNumber</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTracer</name>            *</type><name>gcMarkingTracer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcTriggerFactor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>gcTriggerBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>JSBool</name></type>     <name>gcIsNeeded</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>JSBool</name></type>     <name>gcFlushCodeCaches</name></decl>;</decl_stmt>

    <comment type="block">/*
     * NB: do not pack another flag here by claiming gcPadding unless the new
     * flag is written only by the GC thread.  Atomic updates to packed bytes
     * are not guaranteed, so stores issued by one thread may be lost due to
     * unsynchronized read-modify-write cycles on other threads.
     */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>gcPoke</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>gcRunning</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>gcRegenShapes</name></decl>;</decl_stmt>

    <comment type="block">/*
     * During gc, if rt-&gt;gcRegenShapes &amp;&amp;
     *   (scope-&gt;flags &amp; JSScope::SHAPE_REGEN) == rt-&gt;gcRegenShapesScopeFlag,
     * then the scope's shape has already been regenerated during this GC.
     * To avoid having to sweep JSScopes, the bit's meaning toggles with each
     * shape-regenerating GC.
     *
     * FIXME Once scopes are GC'd (bug 505004), this will be obsolete.
     */</comment>
    <decl_stmt><decl><type><name>uint8</name></type>               <name>gcRegenShapesScopeFlag</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GC_ZEAL</name></cpp:ifdef>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>gcZeal</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>JSGCCallback</name></type>        <name>gcCallback</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Malloc counter to measure memory pressure for GC scheduling. It runs
     * from gcMaxMallocBytes down to zero.
     */</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>           <name>gcMallocBytes</name></decl>;</decl_stmt>

    <comment type="block">/* See comments before DelayMarkingChildren is jsgc.cpp. */</comment>
    <decl_stmt><decl><type><name>JSGCArena</name>           *</type><name>gcUnmarkedArenaStackTop</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>gcMarkLaterCount</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * The trace operation and its data argument to trace embedding-specific
     * GC roots.
     */</comment>
    <decl_stmt><decl><type><name>JSTraceDataOp</name></type>       <name>gcExtraRootsTraceOp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>                *</type><name>gcExtraRootsData</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Used to serialize cycle checks when setting __proto__ or __parent__ by
     * requesting the GC handle the required cycle detection. If the GC hasn't
     * been poked, it won't scan for garbage. This member is protected by
     * rt-&gt;gcLock.
     */</comment>
    <decl_stmt><decl><type><name>JSSetSlotRequest</name>    *</type><name>setSlotRequests</name></decl>;</decl_stmt>

    <comment type="block">/* Well-known numbers held for use by this runtime's contexts. */</comment>
    <decl_stmt><decl><type><name>jsval</name></type>               <name>NaNValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type>               <name>negativeInfinityValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type>               <name>positiveInfinityValue</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>js</name>::<name>DeflatedStringCache</name> *<name>deflatedStringCache</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSString</name>            *</type><name>emptyString</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Builtin functions, lazily created and held for use by the trace recorder.
     *
     * This field would be #ifdef JS_TRACER, but XPConnect is compiled without
     * -DJS_TRACER and includes this header.
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name><name>builtinFunctions</name><index>[<expr><name>JSBUILTIN_LIMIT</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* List of active contexts sharing this runtime; protected by gcLock. */</comment>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>contextList</name></decl>;</decl_stmt>

    <comment type="block">/* Per runtime debug hooks -- see jsprvtd.h and jsdbgapi.h. */</comment>
    <decl_stmt><decl><type><name>JSDebugHooks</name></type>        <name>globalDebugHooks</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <comment type="block">/* True if any debug hooks not supported by the JIT are enabled. */</comment>
    <expr_stmt><expr><name>bool</name> <macro><name>debuggerInhibitsJIT</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr>(<name><name>globalDebugHooks</name>.<name>interruptHandler</name></name> ||
                <name><name>globalDebugHooks</name>.<name>callHook</name></name> ||
                <name><name>globalDebugHooks</name>.<name>objectHook</name></name>)</expr>;</return>
    }</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* More debugging state, see jsdbgapi.c. */</comment>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>trapList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>watchPointList</name></decl>;</decl_stmt>

    <comment type="block">/* Client opaque pointers */</comment>
    <decl_stmt><decl><type><name>void</name>                *</type><name>data</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/* These combine to interlock the GC and new requests. */</comment>
    <decl_stmt><decl><type><name>PRLock</name>              *</type><name>gcLock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRCondVar</name>           *</type><name>gcDone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRCondVar</name>           *</type><name>requestDone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>requestCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSThread</name>            *</type><name>gcThread</name></decl>;</decl_stmt>

    <comment type="block">/* Lock and owning thread pointer for JS_LOCK_RUNTIME. */</comment>
    <decl_stmt><decl><type><name>PRLock</name>              *</type><name>rtLock</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>jsword</name></type>              <name>rtLockOwner</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Used to synchronize down/up state change; protected by gcLock. */</comment>
    <decl_stmt><decl><type><name>PRCondVar</name>           *</type><name>stateChange</name></decl>;</decl_stmt>

    <comment type="block">/*
     * State for sharing single-threaded titles, once a second thread tries to
     * lock a title.  The titleSharingDone condvar is protected by rt-&gt;gcLock
     * to minimize number of locks taken in JS_EndRequest.
     *
     * The titleSharingTodo linked list is likewise "global" per runtime, not
     * one-list-per-context, to conserve space over all contexts, optimizing
     * for the likely case that titles become shared rarely, and among a very
     * small set of threads (contexts).
     */</comment>
    <decl_stmt><decl><type><name>PRCondVar</name>           *</type><name>titleSharingDone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTitle</name>             *</type><name>titleSharingTodo</name></decl>;</decl_stmt>

<comment type="block">/*
 * Magic terminator for the rt-&gt;titleSharingTodo linked list, threaded through
 * title-&gt;u.link.  This hack allows us to test whether a title is on the list
 * by asking whether title-&gt;u.link is non-null.  We use a large, likely bogus
 * pointer here to distinguish this value from any valid u.count (small int)
 * value.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_TITLE_SHARING_TODO</name></cpp:macro>   <cpp:value>((JSTitle *) 0xfeedbeef)</cpp:value></cpp:define>

    <comment type="block">/*
     * Lock serializing trapList and watchPointList accesses, and count of all
     * mutations to trapList and watchPointList made by debugger threads.  To
     * keep the code simple, we define debuggerMutations for the thread-unsafe
     * case too.
     */</comment>
    <decl_stmt><decl><type><name>PRLock</name>              *</type><name>debuggerLock</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSDHashTable</name></type>        <name>threads</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_THREADSAFE */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>debuggerMutations</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Security callbacks set on the runtime are used by each context unless
     * an override is set on the context.
     */</comment>
    <decl_stmt><decl><type><name>JSSecurityCallbacks</name> *</type><name>securityCallbacks</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Shared scope property tree, and arena-pool for allocating its nodes.
     * This really should be free of all locking overhead and allocated in
     * thread-local storage, hence the JS_PROPERTY_TREE(cx) macro.
     */</comment>
    <expr_stmt><expr><name>js</name>::<name>PropertyTree</name>    <name>propertyTree</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PROPERTY_TREE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((cx)-&gt;runtime-&gt;propertyTree)</cpp:value></cpp:define>

    <comment type="block">/*
     * The propertyRemovals counter is incremented for every JSScope::clear,
     * and for each JSScope::remove method call that frees a slot in an object.
     * See js_NativeGet and js_NativeSet in jsobj.cpp.
     */</comment>
    <decl_stmt><decl><type><name>int32</name></type>               <name>propertyRemovals</name></decl>;</decl_stmt>

    <comment type="block">/* Script filename table. */</comment>
    <decl_stmt><decl><type>struct <name>JSHashTable</name>  *</type><name>scriptFilenameTable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>scriptFilenamePrefixes</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>PRLock</name>              *</type><name>scriptFilenameTableLock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Number localization, used by jsnum.c */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>          *</type><name>thousandsSeparator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>          *</type><name>decimalSeparator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>          *</type><name>numGrouping</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Weak references to lazily-created, well-known XML singletons.
     *
     * NB: Singleton objects must be carefully disconnected from the rest of
     * the object graph usually associated with a JSContext's global object,
     * including the set of standard class objects.  See jsxml.c for details.
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>anynameObject</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>functionNamespaceObject</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifndef>
    <decl_stmt><decl><type><name>JSThreadData</name></type>        <name>threadData</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_THREAD_DATA</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>(&amp;(cx)-&gt;runtime-&gt;threadData)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Object shape (property cache structural type) identifier generator.
     *
     * Type 0 stands for the empty scope, and must not be regenerated due to
     * uint32 wrap-around. Since js_GenerateShape (in jsinterp.cpp) uses
     * atomic pre-increment, the initial value for the first typed non-empty
     * scope will be 1.
     *
     * If this counter overflows into SHAPE_OVERFLOW_BIT (in jsinterp.h), the
     * cache is disabled, to avoid aliasing two different types. It stays
     * disabled until a triggered GC at some later moment compresses live
     * types, minimizing rt-&gt;shapeGen in the process.
     */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>uint32</name></type>     <name>shapeGen</name></decl>;</decl_stmt>

    <comment type="block">/* Literal table maintained by jsatom.c functions. */</comment>
    <decl_stmt><decl><type><name>JSAtomState</name></type>         <name>atomState</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSBackgroundThread</name>    *</type><name>deallocatorThread</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>JSEmptyScope</name>          *</type><name>emptyArgumentsScope</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSEmptyScope</name>          *</type><name>emptyBlockScope</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Various metering fields are defined at the end of JSRuntime. In this
     * way there is no need to recompile all the code that refers to other
     * fields of JSRuntime after enabling the corresponding metering macro.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_DUMP_ENUM_CACHE_STATS</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int32</name></type>               <name>nativeEnumProbes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>               <name>nativeEnumMisses</name></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ENUM_CACHE_METER</name><parameter_list>(<param><type><name>name</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>JS_ATOMIC_INCREMENT(&amp;cx-&gt;runtime-&gt;name)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ENUM_CACHE_METER</name><parameter_list>(<param><type><name>name</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_DUMP_LOOP_STATS</name></cpp:ifdef>
    <comment type="block">/* Loop statistics, to trigger trace recording and compiling. */</comment>
    <decl_stmt><decl><type><name>JSBasicStats</name></type>        <name>loopStats</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/* Function invocation metering. */</comment>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>inlineCalls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>nativeCalls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>nonInlineCalls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>constructs</name></decl>;</decl_stmt>

    <comment type="block">/* Title lock and scope property metering. */</comment>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>claimAttempts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>claimedTitles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>deadContexts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>deadlocksAvoided</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveScopes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>sharedTitles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalScopes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveScopeProps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveScopePropsPreSweep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalScopeProps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>livePropTreeNodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>duplicatePropTreeNodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalPropTreeNodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>propTreeKidsChunks</name></decl>;</decl_stmt>

    <comment type="block">/* String instrumentation. */</comment>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveStrings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalStrings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveDependentStrings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalDependentStrings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>badUndependStrings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>              <name>lengthSum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>              <name>lengthSquaredSum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>              <name>strdepLengthSum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>              <name>strdepLengthSquaredSum</name></decl>;</decl_stmt>

    <comment type="block">/* Script instrumentation. */</comment>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveScripts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalScripts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveEmptyScripts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalEmptyScripts</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_SCOPE_DEPTH_METER</name></cpp:ifdef>
    <comment type="block">/*
     * Stats on runtime prototype chain lookups and scope chain depths, i.e.,
     * counts of objects traversed on a chain until the wanted id is found.
     */</comment>
    <decl_stmt><decl><type><name>JSBasicStats</name></type>        <name>protoLookupDepthStats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBasicStats</name></type>        <name>scopeSearchDepthStats</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Stats on compile-time host environment and lexical scope chain lengths
     * (maximum depths).
     */</comment>
    <decl_stmt><decl><type><name>JSBasicStats</name></type>        <name>hostenvScopeDepthStats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBasicStats</name></type>        <name>lexicalScopeDepthStats</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GCMETER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSGCStats</name></type>           <name>gcStats</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_FUNCTION_METERING</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSFunctionMeter</name></type>     <name>functionMeter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>                <name><name>lastScriptFilename</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_PROTO_CACHE_METERING</name></cpp:ifdef>
    <expr_stmt><expr><name>JSClassProtoCache</name>::<name>Stats</name> <name>classProtoCacheStats</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>JSRuntime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>~<call><name>JSRuntime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>bool</name></type> <name>init</name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>maxbytes</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>setGCTriggerFactor</name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>factor</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>setGCLastBytes</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>lastBytes</name></decl></param>)</parameter_list>;</function_decl>

    <function><type><name>void</name>*</type> <name>malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{ <return>return <expr>::<call><name>js_malloc</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

    <function><type><name>void</name>*</type> <name>calloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{ <return>return <expr>::<call><name>js_calloc</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

    <function><type><name>void</name>*</type> <name>realloc</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{ <return>return <expr>::<call><name>js_realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

    <function><type><name>void</name></type> <name>free</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr>::<call><name>js_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

    <expr_stmt><expr><name>bool</name> <macro><name>isGCMallocLimitReached</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>gcMallocBytes</name> &lt;= 0</expr>;</return> }</block></expr></expr_stmt>

    <function><type><name>void</name></type> <name>resetGCMallocBytes</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>gcMallocBytes</name> = <call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>gcMaxMallocBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

    <function><type><name>void</name></type> <name>setGCMaxMallocBytes</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
        <comment type="block">/*
         * For compatibility treat any value that exceeds PTRDIFF_T_MAX to
         * mean that value.
         */</comment>
        <expr_stmt><expr><name>gcMaxMallocBytes</name> = (<call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> &gt;= 0) ? <name>value</name> : <call><name>size_t</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call> &gt;&gt; 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>resetGCMallocBytes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>
}</block>;</struct>

<comment type="block">/* Common macros to access thread-local caches in JSThread or JSRuntime. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GSN_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>(JS_THREAD_DATA(cx)-&gt;gsnCache)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PROPERTY_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>(JS_THREAD_DATA(cx)-&gt;propertyCache)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_TRACE_MONITOR</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>(JS_THREAD_DATA(cx)-&gt;traceMonitor)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_SCRIPTS_TO_GC</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>(JS_THREAD_DATA(cx)-&gt;scriptsToGC)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_EVAL_CACHE_METERING</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EVAL_CACHE_METER</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>(JS_THREAD_DATA(cx)-&gt;evalCacheMeter.x++)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EVAL_CACHE_METER</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_METER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>JS_ATOMIC_INCREMENT(&amp;(rt)-&gt;which)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_UNMETER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>JS_ATOMIC_DECREMENT(&amp;(rt)-&gt;which)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_METER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro></cpp:define>    <comment type="block">/* nothing */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_UNMETER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro></cpp:define>  <comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_KEEP_ATOMS</name><parameter_list>(<param><type><name>rt</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>JS_ATOMIC_INCREMENT(&amp;(rt)-&gt;gcKeepAtoms);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_UNKEEP_ATOMS</name><parameter_list>(<param><type><name>rt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>JS_ATOMIC_DECREMENT(&amp;(rt)-&gt;gcKeepAtoms);</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_ARGUMENT_FORMATTER_DEFINED</name></cpp:ifdef>
<comment type="block">/*
 * Linked list mapping format strings for JS_{Convert,Push}Arguments{,VA} to
 * formatter functions.  Elements are sorted in non-increasing format string
 * length order.
 */</comment>
<struct>struct <name>JSArgumentFormatMap</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>          *</type><name>format</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSArgumentFormatter</name></type> <name>formatter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSArgumentFormatMap</name> *</type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>JSStackHeader</name> <block>{
    <decl_stmt><decl><type><name>uintN</name></type>               <name>nslots</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackHeader</name>       *</type><name>down</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_STACK_SEGMENT</name><parameter_list>(<param><type><name>sh</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>((jsval *)(sh) + 2)</cpp:value></cpp:define>

<comment type="block">/*
 * Key and entry types for the JSContext.resolvingTable hash table, typedef'd
 * here because all consumers need to see these declarations (and not just the
 * typedef names, as would be the case for an opaque pointer-to-typedef'd-type
 * declaration), along with cx-&gt;resolvingTable.
 */</comment>
<typedef>typedef <type><struct>struct <name>JSResolvingKey</name> <block>{
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsid</name></type>                <name>id</name></decl>;</decl_stmt>
}</block></struct></type> <name>JSResolvingKey</name>;</typedef>

<typedef>typedef <type><struct>struct <name>JSResolvingEntry</name> <block>{
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type>     <name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSResolvingKey</name></type>      <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>JSResolvingEntry</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSRESFLAG_LOOKUP</name></cpp:macro>        <cpp:value>0x1</cpp:value></cpp:define>     <comment type="block">/* resolving id from lookup */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSRESFLAG_WATCH</name></cpp:macro>         <cpp:value>0x2</cpp:value></cpp:define>     <comment type="block">/* resolving id from watch */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSRESOLVE_INFER</name></cpp:macro>         <cpp:value>0xffff</cpp:value></cpp:define>  <comment type="block">/* infer bits from current bytecode */</comment>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>JSDebugHooks</name></type> <name>js_NullDebugHooks</name></decl>;</decl_stmt>  <comment type="block">/* defined in jsdbgapi.cpp */</comment>

<decl_stmt><decl><type><name>namespace</name></type> <name>js</name> <block>{
<decl_stmt><decl><type><name>class</name></type> <name>AutoGCRooter</name></decl>;</decl_stmt>
}</block></decl></decl_stmt>

<struct>struct <name>JSContext</name>
<block>{
    <macro><name>explicit</name></macro> <expr_stmt><expr><call><name>JSContext</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call> : <call><name>runtime</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>, <macro><name>busyArrays</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>

    <comment type="block">/*
     * If this flag is set, we were asked to call back the operation callback
     * as soon as possible.
     */</comment>
    volatile <name>jsint</name>      <name>operationCallbackFlag</name></expr>;</expr_stmt>

    <comment type="block">/* JSRuntime contextList linkage. */</comment>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>link</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
    <comment type="block">/*
     * Bit-set formed from binary exponentials of the XML_* tiny-ids defined
     * for boolean settings in jsxml.c, plus an XSF_CACHE_VALID bit.  Together
     * these act as a cache of the boolean XML.ignore* and XML.prettyPrinting
     * property values associated with this context's global object.
     */</comment>
    <decl_stmt><decl><type><name>uint8</name></type>               <name>xmlSettingFlags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type>               <name>padding</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>uint16</name></type>              <name>padding</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Classic Algol "display" static link optimization.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_DISPLAY_SIZE</name></cpp:macro> <cpp:value>16U</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>JSStackFrame</name>        *</type><name><name>display</name><index>[<expr><name>JS_DISPLAY_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Runtime version control identifier. */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>              <name>version</name></decl>;</decl_stmt>

    <comment type="block">/* Per-context options. */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>options</name></decl>;</decl_stmt>            <comment type="block">/* see jsapi.h for JSOPTION_* */</comment>

    <comment type="block">/* Locale specific callbacks for string conversion. */</comment>
    <decl_stmt><decl><type><name>JSLocaleCallbacks</name>   *</type><name>localeCallbacks</name></decl>;</decl_stmt>

    <comment type="block">/*
     * cx-&gt;resolvingTable is non-null and non-empty if we are initializing
     * standard classes lazily, or if we are otherwise recursing indirectly
     * from js_LookupProperty through a JSClass.resolve hook.  It is used to
     * limit runaway recursion (see jsapi.c and jsobj.c).
     */</comment>
    <decl_stmt><decl><type><name>JSDHashTable</name>        *</type><name>resolvingTable</name></decl>;</decl_stmt>

    <comment type="block">/*
     * True if generating an error, to prevent runaway recursion.
     * NB: generatingError packs with insideGCMarkCallback and throwing below.
     */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>generatingError</name></decl>;</decl_stmt>

    <comment type="block">/* Flag to indicate that we run inside gcCallback(cx, JSGC_MARK_END). */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>insideGCMarkCallback</name></decl>;</decl_stmt>

    <comment type="block">/* Exception state -- the exception member is a GC root by definition. */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>throwing</name></decl>;</decl_stmt>           <comment type="block">/* is there a pending exception? */</comment>
    <decl_stmt><decl><type><name>jsval</name></type>               <name>exception</name></decl>;</decl_stmt>          <comment type="block">/* most-recently-thrown exception */</comment>

    <comment type="block">/* Limit pointer for checking native stack consumption during recursion. */</comment>
    <decl_stmt><decl><type><name>jsuword</name></type>             <name>stackLimit</name></decl>;</decl_stmt>

    <comment type="block">/* Quota on the size of arenas used to compile and execute scripts. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>scriptStackQuota</name></decl>;</decl_stmt>

    <comment type="block">/* Data shared by threads in an address space. */</comment>
    <decl_stmt><decl><type><name>JSRuntime</name> * <specifier>const</specifier></type>   <name>runtime</name></decl>;</decl_stmt>

    <comment type="block">/* Stack arena pool and frame pointer register. */</comment>
    <decl_stmt><decl><type><name>JS_REQUIRES_STACK</name>
    <name>JSArenaPool</name></type>         <name>stackPool</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JS_REQUIRES_STACK</name>
    <name>JSStackFrame</name>        *</type><name>fp</name></decl>;</decl_stmt>

    <comment type="block">/* Temporary arena pool used while compiling and decompiling. */</comment>
    <decl_stmt><decl><type><name>JSArenaPool</name></type>         <name>tempPool</name></decl>;</decl_stmt>

    <comment type="block">/* Top-level object and pointer to top stack frame's scope chain. */</comment>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>globalObject</name></decl>;</decl_stmt>

    <comment type="block">/* Storage to root recently allocated GC things and script result. */</comment>
    <decl_stmt><decl><type><name>JSWeakRoots</name></type>         <name>weakRoots</name></decl>;</decl_stmt>

    <comment type="block">/* Regular expression class statics (XXX not shared globally). */</comment>
    <decl_stmt><decl><type><name>JSRegExpStatics</name></type>     <name>regExpStatics</name></decl>;</decl_stmt>

    <comment type="block">/* State for object and array toSource conversion. */</comment>
    <decl_stmt><decl><type><name>JSSharpObjectMap</name></type>    <name>sharpObjectMap</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>js</name>::<name>HashSet</name>&lt;<name>JSObject</name> *&gt; <name>busyArrays</name></expr>;</expr_stmt>

    <comment type="block">/* Argument formatter support for JS_{Convert,Push}Arguments{,VA}. */</comment>
    <decl_stmt><decl><type><name>JSArgumentFormatMap</name> *</type><name>argumentFormatMap</name></decl>;</decl_stmt>

    <comment type="block">/* Last message string and trace file for debugging. */</comment>
    <decl_stmt><decl><type><name>char</name>                *</type><name>lastMessage</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>void</name>                *</type><name>tracefp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name>          *</type><name>tracePrevPc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Per-context optional error reporter. */</comment>
    <decl_stmt><decl><type><name>JSErrorReporter</name></type>     <name>errorReporter</name></decl>;</decl_stmt>

    <comment type="block">/* Branch callback. */</comment>
    <decl_stmt><decl><type><name>JSOperationCallback</name></type> <name>operationCallback</name></decl>;</decl_stmt>

    <comment type="block">/* Interpreter activation count. */</comment>
    <decl_stmt><decl><type><name>uintN</name></type>               <name>interpLevel</name></decl>;</decl_stmt>

    <comment type="block">/* Client opaque pointers. */</comment>
    <decl_stmt><decl><type><name>void</name>                *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>                *</type><name>data2</name></decl>;</decl_stmt>

  <label><name>private</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:pragma># <cpp:directive>pragma</cpp:directive> GCC visibility push(default)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <function_decl><type><name>friend</name> <name>void</name></type> <name>js_TraceContext</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type></decl></param>, <param><decl><type><name>JSContext</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:pragma># <cpp:directive>pragma</cpp:directive> GCC visibility pop</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Linked list of callstacks. See CallStack. */</comment>
    <expr_stmt><expr><name>js</name>::<name>CallStack</name>       *<name>currentCallStack</name></expr>;</expr_stmt>

  <label><name>public</name>:</label>
    <comment type="block">/* Assuming there is an active callstack, return it. */</comment>
    <expr_stmt><expr><name>js</name>::<name>CallStack</name> *<macro><name>activeCallStack</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>currentCallStack</name> &amp;&amp; !<call><name><name>currentCallStack</name>-&gt;<name>isSaved</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>currentCallStack</name></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="block">/* Add the given callstack to the list as the new active callstack. */</comment>
    <decl_stmt><decl><type><name>void</name></type> <name>pushCallStack</name><argument_list>(<argument><expr><name>js</name>::<name>CallStack</name> *<name>newcs</name></expr></argument>)</argument_list> <block>{
        <if>if <condition>(<expr><name>fp</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>currentCallStack</name>-&gt;<name>suspend</name></name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>currentCallStack</name></expr></argument>, <argument><expr><call><name><name>currentCallStack</name>-&gt;<name>isSaved</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <expr_stmt><expr><call><name><name>newcs</name>-&gt;<name>setPrevious</name></name><argument_list>(<argument><expr><name>currentCallStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentCallStack</name> = <name>newcs</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>newcs</name>-&gt;<name>isSuspended</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>newcs</name>-&gt;<name>isSaved</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></decl></decl_stmt>

    <comment type="block">/* Remove the active callstack and make the next callstack active. */</comment>
    <function><type><name>void</name></type> <name>popCallStack</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>currentCallStack</name>-&gt;<name>isSuspended</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>currentCallStack</name>-&gt;<name>isSaved</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentCallStack</name> = <call><name><name>currentCallStack</name>-&gt;<name>getPrevious</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>currentCallStack</name> &amp;&amp; !<call><name><name>currentCallStack</name>-&gt;<name>isSaved</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>currentCallStack</name>-&gt;<name>resume</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="block">/* Mark the top callstack as suspended, without pushing a new one. */</comment>
    <function><type><name>void</name></type> <name>saveActiveCallStack</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>fp</name> &amp;&amp; <name>currentCallStack</name> &amp;&amp; !<call><name><name>currentCallStack</name>-&gt;<name>isSuspended</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>currentCallStack</name>-&gt;<name>save</name></name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fp</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/* Undoes calls to suspendTopCallStack. */</comment>
    <function><type><name>void</name></type> <name>restoreCallStack</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>fp</name> &amp;&amp; <name>currentCallStack</name> &amp;&amp; <call><name><name>currentCallStack</name>-&gt;<name>isSuspended</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fp</name> = <call><name><name>currentCallStack</name>-&gt;<name>getSuspendedFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>currentCallStack</name>-&gt;<name>restore</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * Perform a linear search of all frames in all callstacks in the given context
     * for the given frame, returning the callstack, if found, and null otherwise.
     */</comment>
    <expr_stmt><expr><name>js</name>::<name>CallStack</name> *<call><name>containingCallStack</name><argument_list>(<argument><expr><name>JSStackFrame</name> *<name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSThread</name>            *</type><name>thread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>requestDepth</name></decl>;</decl_stmt>
    <comment type="block">/* Same as requestDepth but ignoring JS_SuspendRequest/JS_ResumeRequest */</comment>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>outstandingRequests</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTitle</name>             *</type><name>lockedSealedTitle</name></decl>;</decl_stmt> <comment type="block">/* weak ref, for low-cost sealed
                                               title locking */</comment>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>threadLinks</name></decl>;</decl_stmt>        <comment type="block">/* JSThread contextList linkage */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CX_FROM_THREAD_LINKS</name><parameter_list>(<param><type><name>tl</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((JSContext *)((char *)(tl) - offsetof(JSContext, threadLinks)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* PDL of stack headers describing stack slots not rooted by argv, etc. */</comment>
    <decl_stmt><decl><type><name>JSStackHeader</name>       *</type><name>stackHeaders</name></decl>;</decl_stmt>

    <comment type="block">/* Stack of thread-stack-allocated GC roots. */</comment>
    <expr_stmt><expr><name>js</name>::<name>AutoGCRooter</name>   *<name>autoGCRooters</name></expr>;</expr_stmt>

    <comment type="block">/* Debug hooks associated with the current context. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSDebugHooks</name>  *</type><name>debugHooks</name></decl>;</decl_stmt>

    <comment type="block">/* Security callbacks that override any defined on the runtime. */</comment>
    <decl_stmt><decl><type><name>JSSecurityCallbacks</name> *</type><name>securityCallbacks</name></decl>;</decl_stmt>

    <comment type="block">/* Pinned regexp pool used for regular expressions. */</comment>
    <decl_stmt><decl><type><name>JSArenaPool</name></type>         <name>regexpPool</name></decl>;</decl_stmt>

    <comment type="block">/* Stored here to avoid passing it around as a parameter. */</comment>
    <decl_stmt><decl><type><name>uintN</name></type>               <name>resolveFlags</name></decl>;</decl_stmt>

    <comment type="block">/* Random number generator state, used by jsmath.cpp. */</comment>
    <decl_stmt><decl><type><name>int64</name></type>               <name>rngSeed</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <comment type="block">/*
     * State for the current tree execution.  bailExit is valid if the tree has
     * called back into native code via a _FAIL builtin and has not yet bailed,
     * else garbage (NULL in debug builds).
     */</comment>
    <expr_stmt><expr><name>js</name>::<name>InterpState</name>     *<name>interpState</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>js</name>::<name>VMSideExit</name>      *<name>bailExit</name></expr>;</expr_stmt>

    <comment type="block">/*
     * True if traces may be executed. Invariant: The value of jitEnabled is
     * always equal to the expression in updateJITEnabled below.
     *
     * This flag and the fields accessed by updateJITEnabled are written only
     * in runtime-&gt;gcLock, to avoid race conditions that would leave the wrong
     * value in jitEnabled. (But the interpreter reads this without
     * locking. That can race against another thread setting debug hooks, but
     * we always read cx-&gt;debugHooks without locking anyway.)
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type>                 <name>jitEnabled</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>JSClassProtoCache</name></type>    <name>classProtoCache</name></decl>;</decl_stmt>

    <comment type="block">/* Caller must be holding runtime-&gt;gcLock. */</comment>
    <function><type><name>void</name></type> <name>updateJITEnabled</name><parameter_list>()</parameter_list> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
        <expr_stmt><expr><name>jitEnabled</name> = ((<name>options</name> &amp; <name>JSOPTION_JIT</name>) &amp;&amp;
                      (<name>debugHooks</name> == &amp;<name>js_NullDebugHooks</name> ||
                       (<name>debugHooks</name> == &amp;<name><name>runtime</name>-&gt;<name>globalDebugHooks</name></name> &amp;&amp;
                        !<call><name><name>runtime</name>-&gt;<name>debuggerInhibitsJIT</name></name><argument_list>()</argument_list></call>)))</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>createDeallocatorTask</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>thread</name>-&gt;<name>deallocatorTask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>runtime</name>-&gt;<name>deallocatorThread</name></name> &amp;&amp; !<call><name><name>runtime</name>-&gt;<name>deallocatorThread</name>-&gt;<name>busy</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name><name>thread</name>-&gt;<name>deallocatorTask</name></name> = <name>new</name> <call><name>JSFreePointerListTask</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>inline</specifier> <name>void</name></type> <name>submitDeallocatorTask</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><name><name>thread</name>-&gt;<name>deallocatorTask</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>runtime</name>-&gt;<name>deallocatorThread</name>-&gt;<name>schedule</name></name><argument_list>(<argument><expr><name><name>thread</name>-&gt;<name>deallocatorTask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>thread</name>-&gt;<name>deallocatorTask</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><name>ptrdiff_t</name> &amp;</type><name>getMallocCounter</name><parameter_list>()</parameter_list> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <return>return <expr><name><name>thread</name>-&gt;<name>gcThreadMallocBytes</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><name><name>runtime</name>-&gt;<name>gcMallocBytes</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></function>

    <comment type="block">/*
     * Call this after allocating memory held by GC things, to update memory
     * pressure counters or report the OOM error if necessary.
     */</comment>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>updateMallocCounter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>ptrdiff_t</name> &amp;</type><name>counter</name> <init>= <expr><call><name>getMallocCounter</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>counter</name> -= <call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>p</name> || <name>counter</name> &lt;= 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>checkMallocGCPressure</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <comment type="block">/*
     * Call this after successfully allocating memory held by GC things, to
     * update memory pressure counters.
     */</comment>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>updateMallocCounter</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>ptrdiff_t</name> &amp;</type><name>counter</name> <init>= <expr><call><name>getMallocCounter</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>counter</name> -= <call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>counter</name> &lt;= 0</expr>)</condition><then> <block>{
            <comment type="block">/*
             * Use 1 as an arbitrary non-null pointer indicating successful
             * allocation.
             */</comment>
            <expr_stmt><expr><call><name>checkMallocGCPressure</name><argument_list>(<argument><expr><name>reinterpret_cast</name>&lt;<name>void</name> *&gt;(<call><name>jsuword</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>inline</specifier> <name>void</name>*</type> <name>malloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>bytes</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><call><name><name>runtime</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>updateMallocCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>p</name></expr>;</return>
    }</block></function>

    <function><type><specifier>inline</specifier> <name>void</name>*</type> <name>mallocNoReport</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>bytes</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><call><name><name>runtime</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>updateMallocCounter</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>p</name></expr>;</return>
    }</block></function>

    <function><type><specifier>inline</specifier> <name>void</name>*</type> <name>calloc</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>bytes</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><call><name><name>runtime</name>-&gt;<name>calloc</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>updateMallocCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>p</name></expr>;</return>
    }</block></function>

    <function><type><specifier>inline</specifier> <name>void</name>*</type> <name>realloc</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>void</name> *</type><name>orig</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>p</name> = <call><name><name>runtime</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * For compatibility we do not account for realloc that increases
         * previously allocated memory.
         */</comment>
        <expr_stmt><expr><call><name>updateMallocCounter</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>orig</name> ? 0 : <name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>p</name></expr>;</return>
    }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>free</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then>
            <return>return;</return></then></if>
        <if>if <condition>(<expr><name>thread</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSFreePointerListTask</name>*</type> <name>task</name> <init>= <expr><name><name>thread</name>-&gt;<name>deallocatorTask</name></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>task</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>task</name>-&gt;<name>add</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>runtime</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <function><type><specifier>inline</specifier> <name>void</name></type> <name>free</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>p</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then>
            <return>return;</return></then></if>
        <expr_stmt><expr><call><name><name>runtime</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * In the common case that we'd like to allocate the memory for an object
     * with cx-&gt;malloc/free, we cannot use overloaded C++ operators (no
     * placement delete).  Factor the common workaround into one place.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREATE_BODY</name><parameter_list>(<param><type><name>parms</name></type></param>)</parameter_list></cpp:macro>                                                    \
    <cpp:value>void *memory = this-&gt;malloc(sizeof(T));                                   \
    if (!memory)                                                              \
        return NULL;                                                          \
    return new(memory) T parms;</cpp:value></cpp:define>

    <expr_stmt><expr><name>template</name> &lt;<name>class</name> <name>T</name>&gt;
    <name>JS_ALWAYS_INLINE</name> <name>T</name> *<macro><name>create</name><argument_list>()</argument_list></macro> <block>{
        <macro><name>CREATE_BODY</name><argument_list>(<argument>()</argument>)</argument_list></macro>
    }</block>

    <name>template</name> &lt;<name>class</name> <name>T</name></expr>, <expr><name>class</name> <name>P1</name>&gt;
    <name>JS_ALWAYS_INLINE</name> <name>T</name> *<macro><name>create</name><argument_list>(<argument>const P1 &amp;p1</argument>)</argument_list></macro> <block>{
        <macro><name>CREATE_BODY</name><argument_list>(<argument>(p1)</argument>)</argument_list></macro>
    }</block>

    <name>template</name> &lt;<name>class</name> <name>T</name></expr>, <expr><name>class</name> <name>P1</name></expr>, <expr><name>class</name> <name>P2</name>&gt;
    <name>JS_ALWAYS_INLINE</name> <name>T</name> *<macro><name>create</name><argument_list>(<argument>const P1 &amp;p1</argument>, <argument>const P2 &amp;p2</argument>)</argument_list></macro> <block>{
        <macro><name>CREATE_BODY</name><argument_list>(<argument>(p1, p2)</argument>)</argument_list></macro>
    }</block>

    <name>template</name> &lt;<name>class</name> <name>T</name></expr>, <expr><name>class</name> <name>P1</name></expr>, <expr><name>class</name> <name>P2</name></expr>, <expr><name>class</name> <name>P3</name>&gt;
    <name>JS_ALWAYS_INLINE</name> <name>T</name> *<macro><name>create</name><argument_list>(<argument>const P1 &amp;p1</argument>, <argument>const P2 &amp;p2</argument>, <argument>const P3 &amp;p3</argument>)</argument_list></macro> <block>{
        <macro><name>CREATE_BODY</name><argument_list>(<argument>(p1, p2, p3)</argument>)</argument_list></macro>
    }</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CREATE_BODY</name></cpp:undef>

    <name>template</name> &lt;<name>class</name> <name>T</name>&gt;
    <name>JS_ALWAYS_INLINE</name> <name>void</name> <macro><name>destroy</name><argument_list>(<argument>T *p</argument>)</argument_list></macro> <block>{
        <expr><name><name>p</name>-&gt;<name/></name>~<call><name>T</name><argument_list>()</argument_list></call></expr>;
        <expr><call><name><name>this</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>bool</name> <call><name>isConstructing</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>void</name></type> <name>purge</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>

    <comment type="block">/*
     * The allocation code calls the function to indicate either OOM failure
     * when p is null or that a memory pressure counter has reached some
     * threshold when p is not null. The function takes the pointer and not
     * a boolean flag to minimize the amount of code in its inlined callers.
     */</comment>
    <function_decl><type><name>void</name></type> <name>checkMallocGCPressure</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
}</block>;</struct>

<expr_stmt><expr><name>JS_ALWAYS_INLINE</name> <name>JSObject</name> *
<name>JSStackFrame</name>::<macro><name>varobj</name><argument_list>(<argument>js::CallStack *cs</argument>)</argument_list></macro>
<block>{
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>cs</name>-&gt;<name>contains</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <return>return <expr><name>fun</name> ? <name>callobj</name> : <call><name><name>cs</name>-&gt;<name>getInitialVarObj</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>JS_ALWAYS_INLINE</name> <name>JSObject</name> *
<name>JSStackFrame</name>::<macro><name>varobj</name><argument_list>(<argument>JSContext *cx</argument>)</argument_list></macro>
<block>{
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>activeCallStack</name></name><argument_list>()</argument_list></call>-&gt;<call><name>contains</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    <return>return <expr><name>fun</name> ? <name>callobj</name> : <call><name><name>cx</name>-&gt;<name>activeCallStack</name></name><argument_list>()</argument_list></call>-&gt;<call><name>getInitialVarObj</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_THREAD_ID</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>((cx)-&gt;thread ? (cx)-&gt;thread-&gt;id : 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>JSAtom</name> **</type>
<name>FrameAtomBase</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name><name>fp</name>-&gt;<name>imacpc</name></name>
           ? <call><name>COMMON_ATOMS_START</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name></name></expr></argument>)</argument_list></call>
           : <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>atomMap</name>.<name>vector</name></name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>namespace</name></type> <name>js</name> <block>{

<decl_stmt><decl><type><name>class</name></type> <name>AutoGCRooter</name> <block>{
  <label><name>public</name>:</label>
    <macro><name>AutoGCRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>ptrdiff_t tag</argument>)</argument_list></macro>
      : <expr_stmt><expr><call><name>down</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>autoGCRooters</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>tag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>, <macro><name>context</name><argument_list>(<argument>cx</argument>)</argument_list></macro>
    <expr><block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>this</name> != <name><name>cx</name>-&gt;<name>autoGCRooters</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><name><name>cx</name>-&gt;<name>autoGCRooters</name></name> = <name>this</name></expr>;
    }</block>

    ~<macro><name>AutoGCRooter</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>this</name> == <name><name>context</name>-&gt;<name>autoGCRooters</name></name></expr></argument>)</argument_list></call></expr>;
        <expr><name><name>context</name>-&gt;<name>autoGCRooters</name></name> = <name>down</name></expr>;
    }</block>

    inline <name>void</name> <call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:pragma># <cpp:directive>pragma</cpp:directive> GCC visibility push(default)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>friend</name> <name>void</name> ::<call><name>js_TraceContext</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>, <argument><expr><name>JSContext</name> *<name>acx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<cpp:pragma># <cpp:directive>pragma</cpp:directive> GCC visibility pop</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <label><name>protected</name>:</label>
    <decl_stmt><decl><type><name>AutoGCRooter</name> * <specifier>const</specifier></type> <name>down</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Discriminates actual subclass of this being used.  If non-negative, the
     * subclass roots an array of jsvals of the length stored in this field.
     * If negative, meaning is indicated by the corresponding value in the enum
     * below.  Any other negative value indicates some deeper problem such as
     * memory corruption.
     */</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>tag</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSContext</name> * <specifier>const</specifier></type> <name>context</name></decl>;</decl_stmt>

    <enum>enum <block>{
        <decl><name>JSVAL</name> <init>=        <expr>-1</expr></init></decl>, <comment type="block">/* js::AutoValueRooter */</comment>
        <decl><name>SPROP</name> <init>=        <expr>-2</expr></init></decl>, <comment type="block">/* js::AutoScopePropertyRooter */</comment>
        <decl><name>WEAKROOTS</name> <init>=    <expr>-3</expr></init></decl>, <comment type="block">/* js::AutoSaveWeakRoots */</comment>
        <decl><name>COMPILER</name> <init>=     <expr>-4</expr></init></decl>, <comment type="block">/* JSCompiler */</comment>
        <decl><name>SCRIPT</name> <init>=       <expr>-5</expr></init></decl>, <comment type="block">/* js::AutoScriptRooter */</comment>
        <decl><name>ENUMERATOR</name> <init>=   <expr>-6</expr></init></decl>, <comment type="block">/* js::AutoEnumStateRooter */</comment>
        <decl><name>IDARRAY</name> <init>=      <expr>-7</expr></init></decl>, <comment type="block">/* js::AutoIdArray */</comment>
        <decl><name>DESCRIPTORS</name> <init>=  <expr>-8</expr></init></decl>, <comment type="block">/* js::AutoDescriptorArray */</comment>
        <decl><name>NAMESPACES</name> <init>=   <expr>-9</expr></init></decl>, <comment type="block">/* js::AutoNamespaceArray */</comment>
        <decl><name>XML</name> <init>=         <expr>-10</expr></init></decl>, <comment type="block">/* js::AutoXMLRooter */</comment>
        <decl><name>OBJECT</name> <init>=      <expr>-11</expr></init></decl>, <comment type="block">/* js::AutoObjectRooter */</comment>
        <decl><name>ID</name> <init>=          <expr>-12</expr></init></decl>, <comment type="block">/* js::AutoIdRooter */</comment>
        <decl><name>VECTOR</name> <init>=      <expr>-13</expr></init></decl>  <comment type="block">/* js::AutoValueVector */</comment>
    }</block>;</enum>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>class</name> <name>AutoSaveWeakRoots</name> : <name>private</name> <name>AutoGCRooter</name>
<block>{
  <expr><name>public</name>:
    <name>explicit</name> <macro><name>AutoSaveWeakRoots</name><argument_list>(<argument>JSContext *cx
                               JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>WEAKROOTS</name></expr></argument>)</argument_list></call></expr>, <macro><name>savedRoots</name><argument_list>(<argument>cx-&gt;weakRoots</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSWeakRoots</name> <name>savedRoots</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<comment type="block">/* FIXME(bug 332648): Move this into a public header. */</comment>
<expr_stmt><expr><name>class</name> <name>AutoValueRooter</name> : <name>private</name> <name>AutoGCRooter</name>
<block>{
  <expr><name>public</name>:
    <name>explicit</name> <macro><name>AutoValueRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>jsval v = JSVAL_NULL
                             JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSVAL</name></expr></argument>)</argument_list></call></expr>, <macro><name>val</name><argument_list>(<argument>v</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>
    <macro><name>AutoValueRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSString *str
                    JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSVAL</name></expr></argument>)</argument_list></call></expr>, <macro><name>val</name><argument_list>(<argument>STRING_TO_JSVAL(str)</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>
    <macro><name>AutoValueRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSObject *obj
                    JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSVAL</name></expr></argument>)</argument_list></call></expr>, <macro><name>val</name><argument_list>(<argument>OBJECT_TO_JSVAL(obj)</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>void</name> <macro><name>setObject</name><argument_list>(<argument>JSObject *obj</argument>)</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>val</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>void</name> <macro><name>setString</name><argument_list>(<argument>JSString *str</argument>)</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>val</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>void</name> <macro><name>setDouble</name><argument_list>(<argument>jsdouble *dp</argument>)</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>val</name> = <call><name>DOUBLE_TO_JSVAL</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>jsval</name> <macro><name>value</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>val</name></expr>;</return>
    }</block>

    <name>jsval</name> *<macro><name>addr</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr>&amp;<name>val</name></expr>;</return>
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>jsval</name> <name>val</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoObjectRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoObjectRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSObject *obj = NULL
                     JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>OBJECT</name></expr></argument>)</argument_list></call></expr>, <macro><name>obj</name><argument_list>(<argument>obj</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>void</name> <macro><name>setObject</name><argument_list>(<argument>JSObject *obj</argument>)</argument_list></macro> <block>{
        <expr><name><name>this</name>-&gt;<name>obj</name></name> = <name>obj</name></expr>;
    }</block>

    <name>JSObject</name> * <macro><name>object</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr><name>obj</name></expr>;</return>
    }</block>

    <name>JSObject</name> ** <macro><name>addr</name><argument_list>()</argument_list></macro> <block>{
        <return>return <expr>&amp;<name>obj</name></expr>;</return>
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSObject</name> *<name>obj</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoArrayRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoArrayRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>size_t len</argument>, <argument>jsval *vec
                    JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>, <macro><name>array</name><argument_list>(<argument>vec</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>void</name> <macro><name>changeLength</name><argument_list>(<argument>size_t newLength</argument>)</argument_list></macro> <block>{
        <expr><name>tag</name> = <call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>newLength</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>void</name> <macro><name>changeArray</name><argument_list>(<argument>jsval *newArray</argument>, <argument>size_t newLength</argument>)</argument_list></macro> <block>{
        <expr><call><name>changeLength</name><argument_list>(<argument><expr><name>newLength</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>array</name> = <name>newArray</name></expr>;
    }</block>

    <name>jsval</name> *<name>array</name></expr>;

    <expr><name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoScopePropertyRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoScopePropertyRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSScopeProperty *sprop
                            JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>SPROP</name></expr></argument>)</argument_list></call></expr>, <macro><name>sprop</name><argument_list>(<argument>sprop</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSScopeProperty</name> * const <name>sprop</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoScriptRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoScriptRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSScript *script
                     JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>SCRIPT</name></expr></argument>)</argument_list></call></expr>, <macro><name>script</name><argument_list>(<argument>script</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>void</name> <macro><name>setScript</name><argument_list>(<argument>JSScript *script</argument>)</argument_list></macro> <block>{
        <expr><name><name>this</name>-&gt;<name>script</name></name> = <name>script</name></expr>;
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSScript</name> *<name>script</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoIdRooter</name> : <name>private</name> <name>AutoGCRooter</name>
<block>{
  <expr><name>public</name>:
    <name>explicit</name> <macro><name>AutoIdRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>jsid id = INT_TO_JSID(0)
                          JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>, <macro><name>idval</name><argument_list>(<argument>id</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>jsid</name> <macro><name>id</name><argument_list>()</argument_list></macro> <block>{
        <return>return <expr><name>idval</name></expr>;</return>
    }</block>

    <name>jsid</name> * <macro><name>addr</name><argument_list>()</argument_list></macro> <block>{
        <return>return <expr>&amp;<name>idval</name></expr>;</return>
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>jsid</name> <name>idval</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>class</name> <name>AutoIdArray</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <macro><name>AutoIdArray</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSIdArray *ida
                  JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ida</name> ? <name><name>ida</name>-&gt;<name>length</name></name> : 0</expr></argument>)</argument_list></call></expr>, <macro><name>idArray</name><argument_list>(<argument>ida</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>
    ~<macro><name>AutoIdArray</name><argument_list>()</argument_list></macro> <block>{
        <if>if <condition>(<expr><name>idArray</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_DestroyIdArray</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>idArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block>
    <name>bool</name> <name>operator</name>!() <block>{
        <return>return <expr><name>idArray</name> == <name>NULL</name></expr>;</return>
    }</block>
    <name>jsid</name> <name><name>operator</name><index>[]</index></name>(<name>size_t</name> <name>i</name>) const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>idArray</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>i</name> &lt; <call><name>size_t</name><argument_list>(<argument><expr><name><name>idArray</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name><name>idArray</name>-&gt;<name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
    }</block>
    <name>size_t</name> <macro><name>length</name><argument_list>()</argument_list></macro> const <block>{
         <return>return <expr><name><name>idArray</name>-&gt;<name>length</name></name></expr>;</return>
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>protected</name>:
    inline <name>void</name> <call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSIdArray</name> * const <name>idArray</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name>

    <comment type="block">/* No copy or assignment semantics. */</comment>
    <call><name>AutoIdArray</name><argument_list>(<argument><expr><name>AutoIdArray</name> &amp;<name>ida</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>void</name> <name>operator</name>=(<name>AutoIdArray</name> &amp;<name>ida</name>)</expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/* The auto-root for enumeration object and its state. */</comment>
<expr_stmt><expr><name>class</name> <name>AutoEnumStateRooter</name> : <name>private</name> <name>AutoGCRooter</name>
<block>{
  <expr><name>public</name>:
    <macro><name>AutoEnumStateRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSObject *obj
                        JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ENUMERATOR</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>obj</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>, <macro><name>stateValue</name><argument_list>(<argument>JSVAL_NULL</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    ~<macro><name>AutoEnumStateRooter</name><argument_list>()</argument_list></macro> <block>{
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>stateValue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr><call><name><name>obj</name>-&gt;<name>enumerate</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>JSENUMERATE_DESTROY</name></expr></argument>, <argument><expr>&amp;<name>stateValue</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/>}</block>
    <expr_stmt/></then></if>}</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>jsval</name> <macro><name>state</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>stateValue</name></expr>;</return> }</block>
    <name>jsval</name> * <macro><name>addr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr>&amp;<name>stateValue</name></expr>;</return> }</block>

  <name>protected</name>:
    <name>void</name> <macro><name>trace</name><argument_list>(<argument>JSTracer *trc</argument>)</argument_list></macro> <block>{
        <expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>"js::AutoEnumStateRooter.obj"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>js_MarkEnumeratorState</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>stateValue</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>JSObject</name> * const <name>obj</name></expr>;

  <expr><name>private</name>:
    <name>jsval</name> <name>stateValue</name></expr>;
    <expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr>
}</block></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_HAS_XML_SUPPORT</name></cpp:ifdef>
<expr_stmt><expr><name>class</name> <name>AutoXMLRooter</name> : <name>private</name> <name>AutoGCRooter</name> <block>{
  <expr><name>public</name>:
    <call><name>AutoXMLRooter</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSXML</name> *<name>xml</name></expr></argument>)</argument_list></call>
      : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>XML</name></expr></argument>)</argument_list></call></expr>, <macro><name>xml</name><argument_list>(<argument>xml</argument>)</argument_list></macro>
    <expr><block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>xml</name></expr></argument>)</argument_list></call></expr>;
    }</block>

    <name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>private</name>:
    <name>JSXML</name> * const <name>xml</name></expr>;
}</block></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XML_SUPPORT */</comment>

<decl_stmt><decl><type><name>class</name></type> <name>AutoLockGC</name> <block>{
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
    <macro><name>explicit</name></macro> <expr_stmt><expr><call><name>AutoLockGC</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call> : <macro><name>rt</name><argument_list>(<argument>rt</argument>)</argument_list></macro> <block>{ <expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block>
    ~<macro><name>AutoLockGC</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>AutoUnlockGC</name> <block>{
<label><name>private</name>:</label>
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
    <macro><name>explicit</name></macro> <expr_stmt><expr><call><name>AutoUnlockGC</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call> : <macro><name>rt</name><argument_list>(<argument>rt</argument>)</argument_list></macro> <block>{ <expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block>
    ~<macro><name>AutoUnlockGC</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>AutoKeepAtoms</name> <block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
  <label><name>public</name>:</label>
    <macro><name>explicit</name></macro> <expr_stmt><expr><call><name>AutoKeepAtoms</name><argument_list>(<argument><expr><name>JSRuntime</name> *<name>rt</name></expr></argument>)</argument_list></call> : <macro><name>rt</name><argument_list>(<argument>rt</argument>)</argument_list></macro> <block>{ <expr><call><name>JS_KEEP_ATOMS</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block>
    ~<macro><name>AutoKeepAtoms</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>JS_UNKEEP_ATOMS</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>; }</block></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}</block></decl></decl_stmt> <comment type="block">/* namespace js */</comment>

<decl_stmt><decl><type><name>class</name></type> <name>JSAutoResolveFlags</name>
<block>{
  <label><name>public</name>:</label>
    <macro><name>JSAutoResolveFlags</name><argument_list>(<argument>JSContext *cx</argument>, <argument>uintN flags
                       JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
      : <expr_stmt><expr><call><name>mContext</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>, <macro><name>mSaved</name><argument_list>(<argument>cx-&gt;resolveFlags</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
        <expr><name><name>cx</name>-&gt;<name>resolveFlags</name></name> = <name>flags</name></expr>;
    }</block>

    ~<macro><name>JSAutoResolveFlags</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>mContext</name>-&gt;<name>resolveFlags</name></name> = <name>mSaved</name></expr>; }</block>

  <name>private</name>:
    <name>JSContext</name> *<name>mContext</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>mSaved</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cpluscplus */</comment>

<comment type="block">/*
 * Slightly more readable macros for testing per-context option settings (also
 * to hide bitset implementation detail).
 *
 * JSOPTION_XML must be handled specially in order to propagate from compile-
 * to run-time (from cx-&gt;options to script-&gt;version/cx-&gt;version).  To do that,
 * we copy JSOPTION_XML from cx-&gt;options into cx-&gt;version as JSVERSION_HAS_XML
 * whenever options are set, and preserve this XML flag across version number
 * changes done via the JS_SetVersion API.
 *
 * But when executing a script or scripted function, the interpreter changes
 * cx-&gt;version, including the XML flag, to script-&gt;version.  Thus JSOPTION_XML
 * is a compile-time option that causes a run-time version change during each
 * activation of the compiled script.  That version change has the effect of
 * changing JS_HAS_XML_OPTION, so that any compiling done via eval enables XML
 * support.  If an XML-enabled script or function calls a non-XML function,
 * the flag bit will be cleared during the callee's activation.
 *
 * Note that JS_SetVersion API calls never pass JSVERSION_HAS_XML or'd into
 * that API's version parameter.
 *
 * Note also that script-&gt;version must contain this XML option flag in order
 * for XDR'ed scripts to serialize and deserialize with that option preserved
 * for detection at run-time.  We can't copy other compile-time options into
 * script-&gt;version because that would break backward compatibility (certain
 * other options, e.g. JSOPTION_VAROBJFIX, are analogous to JSOPTION_XML).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>option</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>(((cx)-&gt;options &amp; (option)) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_STRICT_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>JS_HAS_OPTION(cx, JSOPTION_STRICT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_WERROR_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>JS_HAS_OPTION(cx, JSOPTION_WERROR)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_COMPILE_N_GO_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>JS_HAS_OPTION(cx, JSOPTION_COMPILE_N_GO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_ATLINE_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>JS_HAS_OPTION(cx, JSOPTION_ATLINE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSVERSION_MASK</name></cpp:macro>                  <cpp:value>0x0FFF</cpp:value></cpp:define>  <comment type="block">/* see JSVersion in jspubtd.h */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSVERSION_HAS_XML</name></cpp:macro>               <cpp:value>0x1000</cpp:value></cpp:define>  <comment type="block">/* flag induced by XML option */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSVERSION_ANONFUNFIX</name></cpp:macro>            <cpp:value>0x2000</cpp:value></cpp:define>  <comment type="block">/* see jsapi.h, the comments
                                                   for JSOPTION_ANONFUNFIX */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSVERSION_NUMBER</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>((JSVersion)((cx)-&gt;version &amp;          \
                                                     JSVERSION_MASK))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_XML_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>           <cpp:value>((cx)-&gt;version &amp; JSVERSION_HAS_XML || \
                                         JSVERSION_NUMBER(cx) &gt;= JSVERSION_1_6)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>JSThreadData</name> *</type>
<name>js_CurrentThreadData</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_InitThreads</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_FinishThreads</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_PurgeThreads</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_TraceThreads</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Ensures the JSOPTION_XML and JSOPTION_ANONFUNFIX bits of cx-&gt;options are
 * reflected in cx-&gt;version, since each bit must travel with a script that has
 * it set.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_SyncOptionsToVersion</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Common subroutine of JS_SetVersion and js_SetVersion, to update per-context
 * data that depends on version.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_OnVersionChange</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Unlike the JS_SetVersion API, this function stores JSVERSION_HAS_XML and
 * any future non-version-number flags induced by compiler options.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_SetVersion</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSVersion</name></type> <name>version</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Create and destroy functions for JSContext, which is manually allocated
 * and exclusively owned.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSContext</name> *</type>
<name>js_NewContext</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>stackChunkSize</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_DestroyContext</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSDestroyContextMode</name></type> <name>mode</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Return true if cx points to a context in rt-&gt;contextList, else return false.
 * NB: the caller (see jslock.c:ClaimTitle) must hold rt-&gt;gcLock.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ValidContextPointer</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>JSContext</name> *</type>
<name>js_ContextFromLinkField</name><parameter_list>(<param><decl><type><name>JSCList</name> *</type><name>link</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call>(<name>JSContext</name> *) <argument_list>(<argument><expr>(<name>uint8</name> *) <name>link</name> - <call><name>offsetof</name><argument_list>(<argument><expr><name>JSContext</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * If unlocked, acquire and release rt-&gt;gcLock around *iterp update; otherwise
 * the caller must be holding rt-&gt;gcLock.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSContext</name> *</type>
<name>js_ContextIterator</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>unlocked</name></decl></param>, <param><decl><type><name>JSContext</name> **</type><name>iterp</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Iterate through contexts with active requests. The caller must be holding
 * rt-&gt;gcLock in case of a thread-safe build, or otherwise guarantee that the
 * context list is not alternated asynchroniously.
 */</comment>
<extern>extern JS_FRIEND_API(JSContext *</extern>)
<expr_stmt><expr><call><name>js_NextActiveContext</name><argument_list>(<argument><expr><name>JSRuntime</name> *</expr></argument>, <argument><expr><name>JSContext</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>

<comment type="block">/*
 * Count the number of contexts entered requests on the current thread.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>uint32</name></type>
<name>js_CountThreadRequests</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * This is a helper for code at can potentially run outside JS request to
 * ensure that the GC is not running when the function returns.
 *
 * This function must be called with the GC lock held.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_WaitForGC</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !JS_THREADSAFE */</comment>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>js_WaitForGC</name><parameter_list>(<param><type><name>rt</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>((void) 0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * JSClass.resolve and watchpoint recursion damping machinery.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_StartResolving</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSResolvingKey</name> *</type><name>key</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>flag</name></decl></param>,
                  <param><decl><type><name>JSResolvingEntry</name> **</type><name>entryp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_StopResolving</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSResolvingKey</name> *</type><name>key</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>flag</name></decl></param>,
                 <param><decl><type><name>JSResolvingEntry</name> *</type><name>entry</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>generation</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Local root set management.
 *
 * NB: the jsval parameters below may be properly tagged jsvals, or GC-thing
 * pointers cast to (jsval).  This relies on JSObject's tag being zero, but
 * on the up side it lets us push int-jsval-encoded scopeMark values on the
 * local root stack.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_EnterLocalRootScope</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_LeaveLocalRootScope</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>js_LeaveLocalRootScopeWithResult(cx, JSVAL_NULL)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_LeaveLocalRootScopeWithResult</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>rval</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ForgetLocalRoot</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>int</name></type>
<name>js_PushLocalRoot</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSLocalRootStack</name> *</type><name>lrs</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report an exception, which is currently realized as a printf-style format
 * string and its arguments.
 */</comment>
<typedef>typedef <type><enum>enum <name>JSErrNum</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_DEF</name><parameter_list>(<param><type><name>name</name></type></param>, <param><type><name>number</name></type></param>, <param><type><name>count</name></type></param>, <param><type><name>exception</name></type></param>, <param><type><name>format</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>name = number,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"js.msg"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MSG_DEF</name></cpp:undef>
    <decl><name>JSErr_Limit</name></decl>
}</block></enum></type> <name>JSErrNum</name>;</typedef>

<extern>extern JS_FRIEND_API(const JSErrorFormatString *</extern>)
<macro><name>js_GetErrorMessage</name><argument_list>(<argument>void *userRef</argument>, <argument>const char *locale</argument>, <argument>const uintN errorNumber</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>va_start</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportErrorVA</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportErrorNumberVA</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><name>JSErrorCallback</name></type> <name>callback</name></decl></param>,
                       <param><decl><type><name>void</name> *</type><name>userRef</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                       <param><decl><type><name>JSBool</name></type> <name>charArgs</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ExpandErrorArguments</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSErrorCallback</name></type> <name>callback</name></decl></param>,
                        <param><decl><type><name>void</name> *</type><name>userRef</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                        <param><decl><type><name>char</name> **</type><name>message</name></decl></param>, <param><decl><type><name>JSErrorReport</name> *</type><name>reportp</name></decl></param>,
                        <param><decl><type><name>bool</name></type> <name>charArgs</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportOutOfMemory</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report that cx-&gt;scriptStackQuota is exhausted.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportOutOfScriptQuota</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportOverRecursed</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportAllocationOverflow</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CHECK_RECURSION</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>onerror</name></type></param>)</parameter_list></cpp:macro>                                       \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        int stackDummy_;                                                      \
                                                                              \
        if (!JS_CHECK_STACK_SIZE(cx, stackDummy_)) {                          \
            js_ReportOverRecursed(cx);                                        \
            onerror;                                                          \
        }                                                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<comment type="block">/*
 * Report an exception using a previously composed JSErrorReport.
 * XXXbe remove from "friend" API
 */</comment>
<extern>extern JS_FRIEND_API(void</extern>)
<expr_stmt><expr><call><name>js_ReportErrorAgain</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr>const <name>char</name> *<name>message</name></expr></argument>, <argument><expr><name>JSErrorReport</name> *<name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportIsNotDefined</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report an attempt to access the property of a null or undefined value (v).
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportIsNullOrUndefined</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>intN</name></type> <name>spindex</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>,
                           <param><decl><type><name>JSString</name> *</type><name>fallback</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportMissingArg</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>arg</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report error using js_DecompileValueGenerator(cx, spindex, v, fallback) as
 * the first argument for the error message. If the error message has less
 * then 3 arguments, use null for arg1 or arg2.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportValueErrorFlags</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                         <param><decl><type><name>intN</name></type> <name>spindex</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>fallback</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg2</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_ReportValueError</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>errorNumber</name></type></param>,<param><type><name>spindex</name></type></param>,<param><type><name>v</name></type></param>,<param><type><name>fallback</name></type></param>)</parameter_list></cpp:macro>                \
    <cpp:value>((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
                                    spindex, v, fallback, NULL, NULL))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_ReportValueError2</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>errorNumber</name></type></param>,<param><type><name>spindex</name></type></param>,<param><type><name>v</name></type></param>,<param><type><name>fallback</name></type></param>,<param><type><name>arg1</name></type></param>)</parameter_list></cpp:macro>          \
    <cpp:value>((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
                                    spindex, v, fallback, arg1, NULL))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_ReportValueError3</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>errorNumber</name></type></param>,<param><type><name>spindex</name></type></param>,<param><type><name>v</name></type></param>,<param><type><name>fallback</name></type></param>,<param><type><name>arg1</name></type></param>,<param><type><name>arg2</name></type></param>)</parameter_list></cpp:macro>     \
    <cpp:value>((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
                                    spindex, v, fallback, arg1, arg2))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>JSErrorFormatString</name></type> <name><name>js_ErrorFormatString</name><index>[<expr><name>JSErr_Limit</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * See JS_SetThreadStackLimit in jsapi.c, where we check that the stack
 * grows in the expected direction.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_STACK_GROWTH_DIRECTION</name> &gt; 0</expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CHECK_STACK_SIZE</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>lval</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((jsuword)&amp;(lval) &lt; (cx)-&gt;stackLimit)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CHECK_STACK_SIZE</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>lval</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((jsuword)&amp;(lval) &gt; (cx)-&gt;stackLimit)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * If the operation callback flag was set, call the operation callback.
 * This macro can run the full GC. Return true if it is OK to continue and
 * false otherwise.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CHECK_OPERATION_LIMIT</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>(!(cx)-&gt;operationCallbackFlag || js_InvokeOperationCallback(cx))</cpp:value></cpp:define>

<comment type="block">/*
 * Invoke the operation callback and return false if the current execution
 * is to be terminated.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_InvokeOperationCallback</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>js_TriggerAllOperationCallbacks</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>gcLocked</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>js_TriggerAllOperationCallbacks (rt)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>void</name></type>
<name>js_TriggerAllOperationCallbacks</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>gcLocked</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSStackFrame</name> *</type>
<name>js_GetScriptedCaller</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>jsbytecode</name>*</type>
<name>js_GetCurrentBytecodePC</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>bool</name></type>
<name>js_CurrentPCIsInImacro</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>namespace</name></type> <name>js</name> <block>{

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
<comment type="block">/*
 * Reconstruct the JS stack and clear cx-&gt;tracecx. We must be currently in a
 * _FAIL builtin from trace on cx or another context on the same thread. The
 * machine code for the trace remains on the C stack when js_DeepBail returns.
 *
 * Implemented in jstracer.cpp.
 */</comment>
<function_decl><type><name>JS_FORCES_STACK</name></type> <name>JS_FRIEND_API</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
DeepBail<parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>JS_FORCES_STACK</name> <name>JS_INLINE</name> <name>void</name></type>
<name>LeaveTrace</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>DeepBail</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>void</name></type>
<name>LeaveTraceIfGlobalObject</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name><name>obj</name>-&gt;<name>fslots</name><index>[<expr><name>JSSLOT_PARENT</name></expr>]</index></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>LeaveTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>JSBool</name></type>
<name>CanLeaveTrace</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <return>return <expr><name><name>cx</name>-&gt;<name>bailExit</name></name> != <name>NULL</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

}</block></decl></decl_stmt>       <comment type="block">/* namespace js */</comment>

<comment type="block">/*
 * Get the current cx-&gt;fp, first lazily instantiating stack frames if needed.
 * (Do not access cx-&gt;fp directly except in JS_REQUIRES_STACK code.)
 *
 * Defined in jstracer.cpp if JS_TRACER is defined.
 */</comment>
<function><type><specifier>static</specifier> <name>JS_FORCES_STACK</name> <name>JS_INLINE</name> <name>JSStackFrame</name> *</type>
<name>js_GetTopStackFrame</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>js</name>::<call><name>LeaveTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>JSBool</name></type>
<name>js_IsPropertyCacheDisabled</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>shapeGen</name></name> &gt;= <name>js</name>::<name>SHAPE_OVERFLOW_BIT</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>uint32</name></type>
<name>js_RegenerateShapeForGC</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>gcRunning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>gcRegenShapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Under the GC, compared with js_GenerateShape, we don't need to use
     * atomic increments but we still must make sure that after an overflow
     * the shape stays such.
     */</comment>
    <decl_stmt><decl><type><name>uint32</name></type> <name>shape</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>shapeGen</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>shape</name> = (<name>shape</name> + 1) | (<name>shape</name> &amp; <name>js</name>::<name>SHAPE_OVERFLOW_BIT</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>shapeGen</name></name> = <name>shape</name></expr>;</expr_stmt>
    <return>return <expr><name>shape</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>namespace</name></type> <name>js</name> <block>{

<expr_stmt><expr>inline <name>void</name> *
<name>ContextAllocPolicy</name>::<macro><name>malloc</name><argument_list>(<argument>size_t bytes</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr>inline <name>void</name>
<name>ContextAllocPolicy</name>::<macro><name>free</name><argument_list>(<argument>void *p</argument>)</argument_list></macro>
<block>{
    <expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
}</block>

inline <name>void</name> *
<name>ContextAllocPolicy</name>::<macro><name>realloc</name><argument_list>(<argument>void *p</argument>, <argument>size_t bytes</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name><name>cx</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr>inline <name>void</name>
<name>ContextAllocPolicy</name>::<macro><name>reportAllocOverflow</name><argument_list>()</argument_list></macro> const
<block>{
    <expr><call><name>js_ReportAllocationOverflow</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>class</name> <name>AutoValueVector</name> : <name>private</name> <name>AutoGCRooter</name>
<block>{
  <expr><name>public</name>:
    <name>explicit</name> <macro><name>AutoValueVector</name><argument_list>(<argument>JSContext *cx
                             JS_GUARD_OBJECT_NOTIFIER_PARAM</argument>)</argument_list></macro>
        : <call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>VECTOR</name></expr></argument>)</argument_list></call></expr>, <macro><name>vector</name><argument_list>(<argument>cx</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>JS_GUARD_OBJECT_NOTIFIER_INIT</name></expr>;
    }</block>

    <name>size_t</name> <macro><name>length</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>vector</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

    <name>bool</name> <macro><name>push</name><argument_list>(<argument>jsval v</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>vector</name>.<name>append</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
    <name>bool</name> <macro><name>push</name><argument_list>(<argument>JSString *str</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>push</name><argument_list>(<argument><expr><call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
    <name>bool</name> <macro><name>push</name><argument_list>(<argument>JSObject *obj</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>push</name><argument_list>(<argument><expr><call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
    <name>bool</name> <macro><name>push</name><argument_list>(<argument>jsdouble *dp</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>push</name><argument_list>(<argument><expr><call><name>DOUBLE_TO_JSVAL</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

    <name>void</name> <macro><name>pop</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>vector</name>.<name>popBack</name></name><argument_list>()</argument_list></call></expr>; }</block>

    <name>bool</name> <macro><name>resize</name><argument_list>(<argument>size_t newLength</argument>)</argument_list></macro> <block>{
        <if>if <condition>(<expr>!<call><name><name>vector</name>.<name>resize</name></name><argument_list>(<argument><expr><name>newLength</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>false</name></expr>;</return></then></if></block></expr>
        <return>return <expr><name>true</name></expr>;</return>
    }</block></expr></expr_stmt>

    <function><type><name>bool</name></type> <name>reserve</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>newLength</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>vector</name>.<name>reserve</name></name><argument_list>(<argument><expr><name>newLength</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><name>jsval</name> &amp;</type><name>operator</name>[]<parameter_list>(<param><decl><type><name>size_t</name></type> <name>i</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name><name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return> }</block></function>
    <decl_stmt><decl><type><name>jsval</name></type> <name><name>operator</name><index>[]</index></name><argument_list>(<argument><expr><name>size_t</name> <name>i</name></expr></argument>)</argument_list> const <block>{ <return>return <expr><name><name>vector</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return> }</block></decl></decl_stmt>

    <expr_stmt><expr>const <name>jsval</name> *<macro><name>buffer</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name><name>vector</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <function><type><name>jsval</name> *</type><name>buffer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>vector</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>

    <expr_stmt><expr><name>friend</name> <name>void</name> <name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>private</name>:</label>
    <expr_stmt><expr><name>Vector</name>&lt;<name>jsval</name></expr>, <expr>8&gt; <name>vector</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>JS_DECL_USE_GUARD_OBJECT_NOTIFIER</name></expr></expr_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(pop)</cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> warning(pop)</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* jscntxt_h___ */</comment>
</unit>
