<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="003229e2e6592e5b23b3ff212a4f6e5f2dc11de3.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* vim: set ts=2 sw=2 et tw=78: */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Mats Palmgren &lt;matspal@gmail.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * Implementation of selection: nsISelection,nsISelectionPrivate and nsFrameSelection
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWeakReference.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFactory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIEnumerator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsReadableUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameSelection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelection2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelection3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelectionPrivate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelectionListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIComponentManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentCID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRange.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGUIEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMKeyEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsITableLayout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsITableCellLayout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMNodeList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScrollableFrame.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelectionListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContentIterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocumentEncoder.h"</cpp:file></cpp:include>

<comment type="line">// for IBMBIDI</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameTraversal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsILineIterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGkAtoms.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFrameTraversal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutCID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBidiPresUtils.h"</cpp:file></cpp:include>
<expr_stmt><expr>static <call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>kFrameTraversalCID</name></expr></argument>, <argument><expr><name>NS_FRAMETRAVERSAL_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTextFrame.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMText.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsThreadUtils.h"</cpp:file></cpp:include>

<comment type="line">//included for desired x position;</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPresContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPresShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCaret.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDeviceContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsITimer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIServiceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScrollableFrame.h"</cpp:file></cpp:include>
<comment type="line">// notifications</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocument.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelectionController.h"</cpp:file></cpp:include><comment type="line">//for the enums</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoCopyListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCopySupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIClipboard.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIBidiKeyboard.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// IBMBIDI</comment>

<comment type="line">//#define DEBUG_TABLE 1</comment>

<expr_stmt><expr>static <call><name>NS_DEFINE_IID</name><argument_list>(<argument><expr><name>kCContentIteratorCID</name></expr></argument>, <argument><expr><name>NS_CONTENTITERATOR_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>static <call><name>NS_DEFINE_IID</name><argument_list>(<argument><expr><name>kCSubtreeIteratorCID</name></expr></argument>, <argument><expr><name>NS_SUBTREEITERATOR_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="line">//PROTOTYPES</comment>
<class_decl>class <name>nsSelectionIterator</name>;</class_decl>
<class_decl>class <name>nsFrameSelection</name>;</class_decl>
<class_decl>class <name>nsAutoScrollTimer</name>;</class_decl>

<function_decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>IsValidSelectionPoint</name><parameter_list>(<param><decl><type><name>nsFrameSelection</name> *</type><name>aFrameSel</name></decl></param>, <param><decl><type><name>nsINode</name> *</type><name>aNode</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>nsIAtom</name> *</type><name>GetTag</name><parameter_list>(<param><decl><type><name>nsINode</name> *</type><name>aNode</name></decl></param>)</parameter_list>;</function_decl>
<comment type="line">// returns the parent</comment>
<function_decl><type><specifier>static</specifier> <name>nsINode</name>*</type> <name>ParentOffset</name><parameter_list>(<param><decl><type><name>nsINode</name> *</type><name>aNode</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aChildOffset</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>nsINode</name>*</type> <name>GetCellParent</name><parameter_list>(<param><decl><type><name>nsINode</name> *</type><name>aDomNode</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PRINT_RANGE</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printRange</name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aDomRange</name></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_OUT_RANGE</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>printRange(x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_OUT_RANGE</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>  
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//MOZ_DEBUG</comment>



<comment type="line">//#define DEBUG_SELECTION // uncomment for printf describing every collapse and extend.</comment>
<comment type="line">//#define DEBUG_NAVIGATION</comment>


<comment type="line">//#define DEBUG_TABLE_SELECTION 1</comment>

<struct>struct <name>CachedOffsetForFrame</name> <block>{<public type="default">
  <constructor><name>CachedOffsetForFrame</name><parameter_list>()</parameter_list>
  <member_list>: <call><name>mCachedFrameOffset</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> <comment type="line">// nsPoint ctor</comment>
  , <call><name>mLastCaretFrame</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
  , <call><name>mLastContentOffset</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
  , <call><name>mCanCacheFrameOffset</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
  </member_list><block>{}</block></constructor>

  <decl_stmt><decl><type><name>nsPoint</name></type>      <name>mCachedFrameOffset</name></decl>;</decl_stmt>      <comment type="line">// cached frame offset</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type>    <name>mLastCaretFrame</name></decl>;</decl_stmt>         <comment type="line">// store the frame the caret was last drawn in.</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type>      <name>mLastContentOffset</name></decl>;</decl_stmt>      <comment type="line">// store last content offset</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mCanCacheFrameOffset</name></decl>;</decl_stmt>    <comment type="line">// cached frame offset is valid?</comment>
</public>}</block>;</struct>

<struct>struct <name>RangeData</name>
<block>{<public type="default">
  <constructor><name>RangeData</name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>)</parameter_list> <member_list>:
    <call><name>mRange</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>mRange</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTextRangeStyle</name></type> <name>mTextRangeStyle</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>RangeData</name></type> <name>sEmptyData</name><parameter_list>(<param><decl><type><name>nsnull</name></type></decl></param>)</parameter_list>;</function_decl>

<comment type="line">// Note, the ownership of nsTypedSelection depends on which way the object is</comment>
<comment type="line">// created. When nsFrameSelection has created nsTypedSelection,</comment>
<comment type="line">// addreffing/releasing nsTypedSelection object is aggregated to</comment>
<comment type="line">// nsFrameSelection. Otherwise normal addref/release is used.</comment>
<comment type="line">// This ensures that nsFrameSelection is never deleted before its</comment>
<comment type="line">// nsTypedSelections.</comment>

<class>class <name>nsTypedSelection</name> <super>: <specifier>public</specifier> <name>nsISelection2</name>,
                         <specifier>public</specifier> <name>nsISelection3</name>,
                         <specifier>public</specifier> <name>nsISelectionPrivate</name>,
                         <specifier>public</specifier> <name>nsSupportsWeakReference</name></super>
<block>{<private type="default">
</private><public>public:
  <constructor_decl><name>nsTypedSelection</name><parameter_list>()</parameter_list>;</constructor_decl>
  <constructor_decl><name>nsTypedSelection</name><parameter_list>(<param><decl><type><name>nsFrameSelection</name> *</type><name>aList</name></decl></param>)</parameter_list>;</constructor_decl>
  <destructor_decl><specifier>virtual</specifier> <name>~<name>nsTypedSelection</name></name><parameter_list>()</parameter_list>;</destructor_decl>
  
  <decl_stmt><decl><type><name>NS_DECL_CYCLE_COLLECTING_ISUPPORTS</name></type>
  <name>NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS</name><argument_list>(<argument><expr><name>nsTypedSelection</name></expr></argument>, <argument><expr><name>nsISelection</name></expr></argument>)</argument_list>
  <name>NS_DECL_NSISELECTION</name>
  <name>NS_DECL_NSISELECTION2</name>
  <name>NS_DECL_NSISELECTION3</name>
  <name>NS_DECL_NSISELECTIONPRIVATE</name>

  <comment type="line">// utility methods for scrolling the selection into view</comment>
  <name>nsresult</name>      <name>GetPresContext</name><argument_list>(<argument><expr><name>nsPresContext</name> **<name>aPresContext</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <function_decl><type><name>nsresult</name></type>      <name>GetPresShell</name><parameter_list>(<param><decl><type><name>nsIPresShell</name> **</type><name>aPresShell</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="line">// Returns the position of the region, and frame that that position is relative</comment>
  <comment type="line">// to. The 'position' is a zero-width rectangle.</comment>
  <function_decl><type><name>nsIFrame</name>*</type>     <name>GetSelectionAnchorGeometry</name><parameter_list>(<param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>, <param><decl><type><name>nsRect</name> *</type><name>aRect</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type>      <name>PostScrollSelectionIntoViewEvent</name><parameter_list>(<param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="line">// aDoFlush only matters if aIsSynchronous is true.  If not, we'll just flush</comment>
  <comment type="line">// when the scroll event fires so we make sure to scroll to the right place.</comment>
  <function_decl><type><name>nsresult</name></type>      <name>ScrollIntoView</name><parameter_list>(<param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsSynchronous</name></decl></param>,
                               <param><decl><type><name>PRBool</name></type> <name>aDoFlush</name></decl></param>,
                               <param><decl><type><name>PRInt16</name></type> <name>aVPercent</name> <init>= <expr><name>NS_PRESSHELL_SCROLL_ANYWHERE</name></expr></init></decl></param>,
                               <name>PRInt16</name> <name>aHPercent</name> = <name>NS_PRESSHELL_SCROLL_ANYWHERE</name>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>      <name>SubtractRange</name><parameter_list>(<param><decl><type><name>RangeData</name>*</type> <name>aRange</name></decl></param>, <param><decl><type><name>nsIRange</name>*</type> <name>aSubtract</name></decl></param>,
                              <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>RangeData</name></expr></argument>&gt;</argument_list></name>*</type> <name>aOutput</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>      <name>AddItem</name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>, <param><decl><type><name>PRInt32</name>*</type> <name>aOutIndex</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>      <name>RemoveItem</name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>      <name>RemoveCollapsedRanges</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>      <name>Clear</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>      <name>Collapse</name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aParentNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>      <name>Extend</name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aParentNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>      <name>AddRange</name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="line">// The nsIRange version of RemoveRange assumes the caller is holding</comment>
  <comment type="line">// a strong reference to aRange.</comment>
  <function_decl><type><name>nsresult</name></type>      <name>RemoveRange</name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsIRange</name>*</type>     <name>GetRangeAt</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aIndex</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>      <name>GetTableSelectionType</name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>,
                                      <param><decl><type><name>PRInt32</name>*</type> <name>aTableSelectionType</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// methods for convenience. Note, these don't addref</comment>
  <function_decl><type><name>nsINode</name>*</type>     <name>GetAnchorNode</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRInt32</name></type>      <name>GetAnchorOffset</name><parameter_list>()</parameter_list>;</function_decl>

  <function_decl><type><name>nsINode</name>*</type>     <name>GetFocusNode</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRInt32</name></type>      <name>GetFocusOffset</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Get the anchor-to-focus range if we don't care which end is</comment>
  <comment type="line">// anchor and which end is focus.</comment>
  <function><type><specifier>const</specifier> <name>nsIRange</name>*</type> <name>GetAnchorFocusRange</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{
    <return>return <expr><name>mAnchorFocusRange</name></expr>;</return>
  }</block></function>

  <function><type><name>nsDirection</name></type>  <name>GetDirection</name><parameter_list>()</parameter_list><block>{<return>return <expr><name>mDirection</name></expr>;</return>}</block></function>
  <function><type><name>void</name></type>         <name>SetDirection</name><parameter_list>(<param><decl><type><name>nsDirection</name></type> <name>aDir</name></decl></param>)</parameter_list><block>{<expr_stmt><expr><name>mDirection</name> = <name>aDir</name></expr>;</expr_stmt>}</block></function>
  <function_decl><type><name>nsresult</name></type>     <name>CopyRangeToAnchorFocus</name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type>         <name>ReplaceAnchorFocusRange</name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">//  NS_IMETHOD   GetPrimaryFrameForRangeEndpoint(nsIDOMNode *aNode, PRInt32 aOffset, PRBool aIsEndNode, nsIFrame **aResultFrame);</comment>
  <function_decl><type><name>NS_IMETHOD</name></type>   <name>GetPrimaryFrameForAnchorNode</name><parameter_list>(<param><decl><type><name>nsIFrame</name> **</type><name>aResultFrame</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type>   <name>GetPrimaryFrameForFocusNode</name><parameter_list>(<param><decl><type><name>nsIFrame</name> **</type><name>aResultFrame</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aOffset</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aVisual</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type>   <name>LookUpSelection</name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aContentOffset</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aContentLength</name></decl></param>,
                             <param><decl><type><name>SelectionDetails</name> **</type><name>aReturnDetails</name></decl></param>, <param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aSlowCheck</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_IMETHOD</name></type>   <name>Repaint</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Note: StartAutoScrollTimer might destroy arbitrary frames etc.</comment>
  <function_decl><type><name>nsresult</name></type>     <name>StartAutoScrollTimer</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>,
                                    <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>,
                                    <param><decl><type><name>PRUint32</name></type> <name>aDelay</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type>     <name>StopAutoScrollTimer</name><parameter_list>()</parameter_list>;</function_decl>


</public><private>private:
  <class_decl><specifier>friend</specifier> class <name>nsAutoScrollTimer</name>;</class_decl>

  <comment type="line">// Note: DoAutoScroll might destroy arbitrary frames etc.</comment>
  <function_decl><type><name>nsresult</name></type> <name>DoAutoScroll</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>)</parameter_list>;</function_decl>

</private><public>public:
  <function><type><name>SelectionType</name></type> <name>GetType</name><parameter_list>()</parameter_list><block>{<return>return <expr><name>mType</name></expr>;</return>}</block></function>
  <function><type><name>void</name></type>          <name>SetType</name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>)</parameter_list><block>{<expr_stmt><expr><name>mType</name> = <name>aType</name></expr>;</expr_stmt>}</block></function>

  <function_decl><type><name>nsresult</name></type>     <name>NotifySelectionListeners</name><parameter_list>()</parameter_list>;</function_decl>

</public><private>private:
  <class_decl><specifier>friend</specifier> class <name>nsSelectionIterator</name>;</class_decl>

  <class_decl>class <name>ScrollSelectionIntoViewEvent</name>;</class_decl>
  <class_decl><specifier>friend</specifier> class <name>ScrollSelectionIntoViewEvent</name>;</class_decl>

  <class>class <name>ScrollSelectionIntoViewEvent</name> <super>: <specifier>public</specifier> <name>nsRunnable</name></super> <block>{<private type="default">
  </private><public>public:
    <macro><name>NS_DECL_NSIRUNNABLE</name></macro>
    <constructor><name>ScrollSelectionIntoViewEvent</name><parameter_list>(<param><decl><type><name>nsTypedSelection</name> *</type><name>aTypedSelection</name></decl></param>,
                                 <param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>)</parameter_list> 
      <member_list>: <call><name>mTypedSelection</name><argument_list>(<argument><expr><name>aTypedSelection</name></expr></argument>)</argument_list></call>,
        <call><name>mRegion</name><argument_list>(<argument><expr><name>aRegion</name></expr></argument>)</argument_list></call> </member_list><block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aTypedSelection</name></expr></argument>, <argument><expr>"null parameter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>
    <function><type><name>void</name></type> <name>Revoke</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>mTypedSelection</name> = <name>nsnull</name></expr>;</expr_stmt> }</block></function>
  </public><private>private:
    <decl_stmt><decl><type><name>nsTypedSelection</name> *</type><name>mTypedSelection</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SelectionRegion</name></type>   <name>mRegion</name></decl>;</decl_stmt>
  </private>}</block>;</class>

  <function_decl><type><name>void</name></type> <name>setAnchorFocusRange</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aIndex</name></decl></param>)</parameter_list>;</function_decl> <comment type="line">// pass in index into mRanges;</comment>
                                            <comment type="line">// negative value clears</comment>
                                            <comment type="line">// mAnchorFocusRange</comment>
  <function_decl><type><name>nsresult</name></type>     <name>SelectAllFramesForContent</name><parameter_list>(<param><decl><type><name>nsIContentIterator</name> *</type><name>aInnerIter</name></decl></param>,
                               <param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>,
                               <param><decl><type><name>PRBool</name></type> <name>aSelected</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>     <name>selectFrames</name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>, <param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aSelect</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>     <name>getTableCellLocationFromRange</name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aSelectionType</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aRow</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aCol</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type>     <name>addTableCellRange</name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>aDidAddRange</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aOutIndex</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type> <name>FindInsertionPoint</name><parameter_list>(
      <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>RangeData</name></expr></argument>&gt;</argument_list></name>*</type> <name>aElementArray</name></decl></param>,
      <param><decl><type><name>nsINode</name>*</type> <name>aPointNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aPointOffset</name></decl></param>,
      <param><function_decl><type><name>nsresult</name></type> (*<name>aComparator</name>)<parameter_list>(<param><decl><type><name>nsINode</name>*</type></decl></param>,<param><decl><type><name>PRInt32</name></type></decl></param>,<param><decl><type><name>nsIRange</name>*</type></decl></param>,<param><decl><type><name>PRInt32</name>*</type></decl></param>)</parameter_list></function_decl></param>,
      <param><decl><type><name>PRInt32</name>*</type> <name>aPoint</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>EqualsRangeAtPoint</name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aBeginNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aBeginOffset</name></decl></param>,
                            <param><decl><type><name>nsINode</name>*</type> <name>aEndNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aEndOffset</name></decl></param>,
                            <param><decl><type><name>PRInt32</name></type> <name>aRangeIndex</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsresult</name></type> <name>GetRangesForIntervalCOMArray</name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aBeginNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aBeginOffset</name></decl></param>,
                                        <param><decl><type><name>nsINode</name>*</type> <name>aEndNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aEndOffset</name></decl></param>,
                                        <param><decl><type><name>PRBool</name></type> <name>aAllowAdjacent</name></decl></param>,
                                        <param><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name>*</type> <name>aRanges</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>GetIndicesForInterval</name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aBeginNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aBeginOffset</name></decl></param>,
                             <param><decl><type><name>nsINode</name>*</type> <name>aEndNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aEndOffset</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type> <name>aAllowAdjacent</name></decl></param>,
                             <param><decl><type><name>PRInt32</name> *</type><name>aStartIndex</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aEndIndex</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>RangeData</name>*</type> <name>FindRangeData</name><parameter_list>(<param><decl><type><name>nsIDOMRange</name>*</type> <name>aRange</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// These are the ranges inside this selection. They are kept sorted in order</comment>
  <comment type="line">// of DOM start position.</comment>
  <comment type="line">//</comment>
  <comment type="line">// This data structure is sorted by the range beginnings. As the ranges are</comment>
  <comment type="line">// disjoint, it is also implicitly sorted by the range endings. This allows</comment>
  <comment type="line">// us to perform binary searches when searching for existence of a range,</comment>
  <comment type="line">// giving us O(log n) search time.</comment>
  <comment type="line">//</comment>
  <comment type="line">// Inserting a new range requires finding the overlapping interval, requiring</comment>
  <comment type="line">// two binary searches plus up to an additional 6 DOM comparisons. If this</comment>
  <comment type="line">// proves to be a performance concern, then an interval tree may be a</comment>
  <comment type="line">// possible solution, allowing the calculation of the overlap interval in</comment>
  <comment type="line">// O(log n) time, though this would require rebalancing and other overhead.</comment>
  <decl_stmt><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>RangeData</name></expr></argument>&gt;</argument_list></name></type> <name>mRanges</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>mAnchorFocusRange</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsFrameSelection</name></expr></argument>&gt;</argument_list></name></type> <name>mFrameSelection</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsWeakPtr</name></type> <name>mPresShellWeak</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsAutoScrollTimer</name></expr></argument>&gt;</argument_list></name></type> <name>mAutoScrollTimer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsISelectionListener</name></expr></argument>&gt;</argument_list></name></type> <name>mSelectionListeners</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsRevocableEventPtr</name><argument_list>&lt;<argument><expr><name>ScrollSelectionIntoViewEvent</name></expr></argument>&gt;</argument_list></name></type> <name>mScrollEvent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CachedOffsetForFrame</name> *</type><name>mCachedOffsetForFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDirection</name></type> <name>mDirection</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SelectionType</name></type> <name>mType</name></decl>;</decl_stmt>
</private>}</block>;</class>

<comment type="line">// Stack-class to turn on/off selection batching for table selection</comment>
<decl_stmt><decl><type>class <name>NS_STACK_CLASS</name> <name>NS_FINAL_CLASS</name></type> <name>nsSelectionBatcher</name>
<argument_list>{
<argument><expr>private:
  <name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISelectionPrivate</name></expr></argument>&gt;</argument_list></name> <name>mSelection</name></expr></argument>;
<argument><expr>public:
  <call><name>nsSelectionBatcher</name><argument_list>(<argument><expr><name>nsISelectionPrivate</name> *<name>aSelection</name></expr></argument>)</argument_list></call> : <macro><name>mSelection</name><argument_list>(<argument>aSelection</argument>)</argument_list></macro>
  <block>{
    <if>if <condition>(<expr><name>mSelection</name></expr>)</condition><then> <expr_stmt><expr><call><name><name>mSelection</name>-&gt;<name>StartBatchChanges</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block>
  ~<macro><name>nsSelectionBatcher</name><argument_list>()</argument_list></macro> 
  <block>{ 
    <if>if <condition>(<expr><name>mSelection</name></expr>)</condition><then> <expr_stmt><expr><call><name><name>mSelection</name>-&gt;<name>EndBatchChanges</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block>
}</expr></argument>;

<argument><expr>class <name>nsSelectionIterator</name> : public <name>nsIBidirectionalEnumerator</name>
<block>{
<expr>public:
<comment type="block">/*BEGIN nsIEnumerator interfaces
see the nsIEnumerator for more details*/</comment>

  <name>NS_DECL_ISUPPORTS</name>

  <name>NS_DECL_NSIENUMERATOR</name>

  <name>NS_DECL_NSIBIDIRECTIONALENUMERATOR</name>

<comment type="block">/*END nsIEnumerator interfaces*/</comment>
<comment type="block">/*BEGIN Helper Methods*/</comment>
  <name>nsIRange</name>* <call><name>CurrentItem</name><argument_list>()</argument_list></call></expr>;
<comment type="block">/*END Helper Methods*/</comment>
<expr>private:
  friend class <name>nsTypedSelection</name></expr>;

  <comment type="line">//lame lame lame if delete from document goes away then get rid of this unless its debug</comment>
  <expr>friend class <name>nsFrameSelection</name></expr>;

  <expr><call><name>nsSelectionIterator</name><argument_list>(<argument><expr><name>nsTypedSelection</name> *</expr></argument>)</argument_list></call></expr>;
  <expr>virtual <call><name>~<name>nsSelectionIterator</name></name><argument_list>()</argument_list></call></expr>;
  <expr><name>PRInt32</name>     <name>mIndex</name></expr>;
  <expr><name>nsTypedSelection</name> *<name>mDomSelection</name></expr>;
  <expr><name>SelectionType</name> <name>mType</name></expr>;
}</block></expr></argument>;

<argument><expr>class <name>nsAutoScrollTimer</name> : public <name>nsITimerCallback</name>
<block>{
<expr>public:

  <name>NS_DECL_ISUPPORTS</name>

  <call><name>nsAutoScrollTimer</name><argument_list>()</argument_list></call>
  : <call><name>mFrameSelection</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><call><name>mSelection</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><call><name>mPresContext</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><call><name>mPoint</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>, <macro><name>mDelay</name><argument_list>(<argument>30</argument>)</argument_list></macro>
  <expr><block>{
  }</block>

  virtual ~<macro><name>nsAutoScrollTimer</name><argument_list>()</argument_list></macro>
  <block>{
   <if>if <condition>(<expr><name>mTimer</name></expr>)</condition><then>
       <expr_stmt><expr><call><name><name>mTimer</name>-&gt;<name>Cancel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block>

  <comment type="line">// aPoint is relative to aPresContext's root frame</comment>
  <name>nsresult</name> <macro><name>Start</name><argument_list>(<argument>nsPresContext *aPresContext</argument>, <argument>nsPoint &amp;aPoint</argument>)</argument_list></macro>
  <block>{
    <expr><name>mPoint</name> = <name>aPoint</name></expr>;

    <comment type="line">// Store the presentation context. The timer will be</comment>
    <comment type="line">// stopped by the selection if the prescontext is destroyed.</comment>
    <expr><name>mPresContext</name> = <name>aPresContext</name></expr>;

    <expr><name>mContent</name> = <call><name><name>nsIPresShell</name>::<name>GetCapturingContent</name></name><argument_list>()</argument_list></call></expr>;

    <if>if <condition>(<expr>!<name>mTimer</name></expr>)</condition><then>
    <expr_stmt><expr><block>{
      <expr><name>nsresult</name> <name>result</name></expr>;
      <name>mTimer</name> = <call><name>do_CreateInstance</name><argument_list>(<argument><expr>"@mozilla.org/timer;1"</expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt></then></if></block></expr>

      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>result</name></expr>;</return></then></if>
    }</block></expr></argument>

    <return>return <expr><call><name><name>mTimer</name>-&gt;<name>InitWithCallback</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mDelay</name></expr></argument>, <argument><expr><name><name>nsITimer</name>::<name>TYPE_ONE_SHOT</name></name></expr></argument>)</argument_list></call></expr>;</return></argument_list></decl></decl_stmt>
  }

  nsresult <macro><name>Stop</name><argument_list>()</argument_list></macro>
  <block>{
    <if>if <condition>(<expr><name>mTimer</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name><name>mTimer</name>-&gt;<name>Cancel</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mTimer</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>mContent</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block>

  <function><type><name>nsresult</name></type> <name>Init</name><parameter_list>(<param><decl><type><name>nsFrameSelection</name> *</type><name>aFrameSelection</name></decl></param>, <param><decl><type><name>nsTypedSelection</name> *</type><name>aSelection</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><name>mFrameSelection</name> = <name>aFrameSelection</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mSelection</name> = <name>aSelection</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></function>

  <function><type><name>nsresult</name></type> <name>SetDelay</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aDelay</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><name>mDelay</name> = <name>aDelay</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></function>

  <function><type><name>NS_IMETHOD</name></type> <name>Notify</name><parameter_list>(<param><decl><type><name>nsITimer</name> *</type><name>timer</name></decl></param>)</parameter_list>
  <block>{
    <if>if <condition>(<expr><name>mSelection</name> &amp;&amp; <name>mPresContext</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>nsWeakFrame</name></type> <name>frame</name> <init>=
        <expr><name>mContent</name> ? <call><name><name>mPresContext</name>-&gt;<name>GetPrimaryFrameFor</name></name><argument_list>(<argument><expr><name>mContent</name></expr></argument>)</argument_list></call> : <name>nsnull</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>mContent</name> = <name>nsnull</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>HandleDrag</name></name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr><name>mPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<call><name><name>frame</name>.<name>IsAlive</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>frame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call> == <name>mPresContext</name></expr></argument>, <argument><expr>"document mismatch?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsPoint</name></type> <name>pt</name> <init>= <expr><name>mPoint</name> -
        <call><name><name>frame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><call><name><name>mPresContext</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call>-&gt;<call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>mSelection</name>-&gt;<name>DoAutoScroll</name></name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></function>
<private>private:
  <decl_stmt><decl><type><name>nsFrameSelection</name> *</type><name>mFrameSelection</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTypedSelection</name> *</type><name>mSelection</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPresContext</name> *</type><name>mPresContext</name></decl>;</decl_stmt>
  <comment type="line">// relative to mPresContext's root frame</comment>
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>mPoint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsITimer</name></expr></argument>&gt;</argument_list></name></type> <name>mTimer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>mContent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>mDelay</name></decl>;</decl_stmt>
</private>};

<macro><name>NS_IMPL_ISUPPORTS1</name><argument_list>(<argument>nsAutoScrollTimer</argument>, <argument>nsITimerCallback</argument>)</argument_list></macro>

<function><type><name>nsresult</name></type> <name>NS_NewSelection</name><parameter_list>(<param><decl><type><name>nsFrameSelection</name> **</type><name>aFrameSelection</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsFrameSelection</name> *</type><name>rlist</name> <init>= <expr>new <name>nsFrameSelection</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>rlist</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
  <expr_stmt><expr>*<name>aFrameSelection</name> = <name>rlist</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>rlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name>NS_NewDomSelection</name><parameter_list>(<param><decl><type><name>nsISelection</name> **</type><name>aDomSelection</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTypedSelection</name> *</type><name>rlist</name> <init>= <expr>new <name>nsTypedSelection</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>rlist</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
  <expr_stmt><expr>*<name>aDomSelection</name> = (<name>nsISelection</name> *)<name>rlist</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>rlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRInt8</name></type>
<name>GetIndexFromSelectionType</name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>aType</name></expr>)</condition>
    <block>{
    <case>case <expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr>: <return>return <expr>0</expr>;</return> <break>break;</break>
    </case><case>case <expr><name><name>nsISelectionController</name>::<name>SELECTION_SPELLCHECK</name></name></expr>: <return>return <expr>1</expr>;</return> <break>break;</break>
    </case><case>case <expr><name><name>nsISelectionController</name>::<name>SELECTION_IME_RAWINPUT</name></name></expr>: <return>return <expr>2</expr>;</return> <break>break;</break>
    </case><case>case <expr><name><name>nsISelectionController</name>::<name>SELECTION_IME_SELECTEDRAWTEXT</name></name></expr>: <return>return <expr>3</expr>;</return> <break>break;</break>
    </case><case>case <expr><name><name>nsISelectionController</name>::<name>SELECTION_IME_CONVERTEDTEXT</name></name></expr>: <return>return <expr>4</expr>;</return> <break>break;</break>
    </case><case>case <expr><name><name>nsISelectionController</name>::<name>SELECTION_IME_SELECTEDCONVERTEDTEXT</name></name></expr>: <return>return <expr>5</expr>;</return> <break>break;</break>
    </case><case>case <expr><name><name>nsISelectionController</name>::<name>SELECTION_ACCESSIBILITY</name></name></expr>: <return>return <expr>6</expr>;</return> <break>break;</break>
    </case><case>case <expr><name><name>nsISelectionController</name>::<name>SELECTION_FIND</name></name></expr>: <return>return <expr>7</expr>;</return> <break>break;</break>
    </case><default>default:
      <return>return <expr>-1</expr>;</return> <break>break;</break>
    </default>}</block></switch>
    <comment type="block">/* NOTREACHED */</comment>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>SelectionType</name></type> 
<name>GetSelectionTypeFromIndex</name><parameter_list>(<param><decl><type><name>PRInt8</name></type> <name>aIndex</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>aIndex</name></expr>)</condition>
  <block>{
    <case>case <expr>0</expr>: <return>return <expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr>;</return> <break>break;</break>
    </case><case>case <expr>1</expr>: <return>return <expr><name><name>nsISelectionController</name>::<name>SELECTION_SPELLCHECK</name></name></expr>;</return> <break>break;</break>
    </case><case>case <expr>2</expr>: <return>return <expr><name><name>nsISelectionController</name>::<name>SELECTION_IME_RAWINPUT</name></name></expr>;</return> <break>break;</break>
    </case><case>case <expr>3</expr>: <return>return <expr><name><name>nsISelectionController</name>::<name>SELECTION_IME_SELECTEDRAWTEXT</name></name></expr>;</return> <break>break;</break>
    </case><case>case <expr>4</expr>: <return>return <expr><name><name>nsISelectionController</name>::<name>SELECTION_IME_CONVERTEDTEXT</name></name></expr>;</return> <break>break;</break>
    </case><case>case <expr>5</expr>: <return>return <expr><name><name>nsISelectionController</name>::<name>SELECTION_IME_SELECTEDCONVERTEDTEXT</name></name></expr>;</return> <break>break;</break>
    </case><case>case <expr>6</expr>: <return>return <expr><name><name>nsISelectionController</name>::<name>SELECTION_ACCESSIBILITY</name></name></expr>;</return> <break>break;</break>
    </case><case>case <expr>7</expr>: <return>return <expr><name><name>nsISelectionController</name>::<name>SELECTION_FIND</name></name></expr>;</return> <break>break;</break>
    </case><default>default:
      <return>return <expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr>;</return> <break>break;</break>
  </default>}</block></switch>
  <comment type="block">/* NOTREACHED */</comment>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
The limiter is used specifically for the text areas and textfields
In that case it is the DIV tag that is anonymously created for the text
areas/fields.  Text nodes and BR nodes fall beneath it.  In the case of a 
BR node the limiter will be the parent and the offset will point before or
after the BR node.  In the case of the text node the parent content is 
the text node itself and the offset will be the exact character position.
The offset is not important to check for validity.  Simply look at the 
passed in content.  If it equals the limiter then the selection point is valid.
If its parent it the limiter then the point is also valid.  In the case of 
NO limiter all points are valid since you are in a topmost iframe. (browser
or composer)
*/</comment>
<function><type><name>PRBool</name></type>       
<name>IsValidSelectionPoint</name><parameter_list>(<param><decl><type><name>nsFrameSelection</name> *</type><name>aFrameSel</name></decl></param>, <param><decl><type><name>nsINode</name> *</type><name>aNode</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aFrameSel</name> || !<name>aNode</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIContent</name> *</type><name>limiter</name> <init>= <expr><call><name><name>aFrameSel</name>-&gt;<name>GetLimiter</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>limiter</name> &amp;&amp; <name>limiter</name> != <name>aNode</name> &amp;&amp; <name>limiter</name> != <call><name><name>aNode</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">//if newfocus == the limiter. that's ok. but if not there and not parent bad</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return> <comment type="line">//not in the right content. tLimiter said so</comment>
  }</block></then></if>

  <expr_stmt><expr><name>limiter</name> = <call><name><name>aFrameSel</name>-&gt;<name>GetAncestorLimiter</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>!<name>limiter</name> || <call><name><name>nsContentUtils</name>::<name>ContentIsDescendantOf</name></name><argument_list>(<argument><expr><name>aNode</name></expr></argument>, <argument><expr><name>limiter</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<macro><name>NS_IMPL_ADDREF</name><argument_list>(<argument>nsSelectionIterator</argument>)</argument_list></macro>
<macro><name>NS_IMPL_RELEASE</name><argument_list>(<argument>nsSelectionIterator</argument>)</argument_list></macro>

<macro><name>NS_INTERFACE_MAP_BEGIN</name><argument_list>(<argument>nsSelectionIterator</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIEnumerator</argument>)</argument_list></macro>
  <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIBidirectionalEnumerator</argument>)</argument_list></macro>
<macro><name>NS_INTERFACE_MAP_END_AGGREGATED</name><argument_list>(<argument>mDomSelection</argument>)</argument_list></macro>


<comment type="line" format="doxygen">///////////BEGIN nsSelectionIterator methods</comment>

<constructor><name><name>nsSelectionIterator</name>::<name>nsSelectionIterator</name></name><parameter_list>(<param><decl><type><name>nsTypedSelection</name> *</type><name>aList</name></decl></param>)</parameter_list>
<member_list>:<call><name>mIndex</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
</member_list><block>{
  <if>if <condition>(<expr>!<name>aList</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"nsFrameSelection"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><name>mDomSelection</name> = <name>aList</name></expr>;</expr_stmt>
}</block></constructor>



<destructor><name><name>nsSelectionIterator</name>::~<name>nsSelectionIterator</name></name><parameter_list>()</parameter_list>
<block>{
}</block></destructor>



<comment type="line" format="doxygen">////////////END nsSelectionIterator methods</comment>

<comment type="line" format="doxygen">////////////BEGIN nsSelectionIterator methods</comment>



<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsSelectionIterator</name>::<name>Next</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mIndex</name>++</expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cnt</name> <init>= <expr><call><name><name>mDomSelection</name>-&gt;<name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mIndex</name> &lt; <name>cnt</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsSelectionIterator</name>::<name>Prev</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mIndex</name>--</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mIndex</name> &gt;= 0</expr> )</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsSelectionIterator</name>::<name>First</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mDomSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  <expr_stmt><expr><name>mIndex</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsSelectionIterator</name>::<name>Last</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mDomSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  <expr_stmt><expr><name>mIndex</name> = <call><name><name>mDomSelection</name>-&gt;<name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>nsSelectionIterator</name>::<name>CurrentItem</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> **</type><name>aItem</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aItem</name> = <call><name>CurrentItem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!*<name>aItem</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsIRange</name>*</type>
<name><name>nsSelectionIterator</name>::<name>CurrentItem</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><call><name><name>mDomSelection</name>-&gt;<name>mRanges</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>mIndex</name></expr></argument>, <argument><expr><name>sEmptyData</name></expr></argument>)</argument_list></call>.<name>mRange</name></expr>;</return>
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsSelectionIterator</name>::<name>IsDone</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cnt</name> <init>= <expr><call><name><name>mDomSelection</name>-&gt;<name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mIndex</name> &gt;= 0 &amp;&amp; <name>mIndex</name> &lt; <name>cnt</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ENUMERATOR_FALSE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<comment type="line" format="doxygen">////////////END nsSelectionIterator methods</comment>


<comment type="line" format="doxygen">////////////BEGIN nsFrameSelection methods</comment>

<constructor><name><name>nsFrameSelection</name>::<name>nsFrameSelection</name></name><parameter_list>()</parameter_list>
  <member_list>: <call><name>mDelayedMouseEvent</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name><name>nsMouseEvent</name>::<name>eReal</name></name></expr></argument>)</argument_list></call>
</member_list><block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init><condition><expr><name>i</name>&lt;<name><name>nsISelectionController</name>::<name>NUM_SELECTIONTYPES</name></name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>i</name></expr>]</index></name> = new <call><name>nsTypedSelection</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
      <break>break;</break></then></if>
    <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<call><name>SetType</name><argument_list>(<argument><expr><call><name>GetSelectionTypeFromIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>mBatching</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mChangesDuringBatching</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mNotifyFrames</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mLimiter</name> = <name>nsnull</name></expr>;</expr_stmt> <comment type="line">//no default limiter.</comment>
  <expr_stmt><expr><name>mAncestorLimiter</name> = <name>nsnull</name></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>mMouseDoubleDownState</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>mHint</name> = <name>HINTLEFT</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
  <expr_stmt><expr><name>mCaretBidiLevel</name> = <name>BIDI_LEVEL_UNDEFINED</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>mDragSelectingCells</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSelectingTableCellMode</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mSelectedCellIndex</name> = 0</expr>;</expr_stmt>

  <comment type="line">// Check to see if the autocopy pref is enabled</comment>
  <comment type="line">//   and add the autocopy listener if it is</comment>
  <if>if <condition>(<expr><call><name><name>nsContentUtils</name>::<name>GetBoolPref</name></name><argument_list>(<argument><expr>"clipboard.autocopy"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsAutoCopyListener</name> *</type><name>autoCopy</name> <init>= <expr><call><name><name>nsAutoCopyListener</name>::<name>GetInstance</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>autoCopy</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>=
        <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>autoCopy</name>-&gt;<name>Listen</name></name><argument_list>(<argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><name>mDisplaySelection</name> = <name><name>nsISelectionController</name>::<name>SELECTION_OFF</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>mDelayedMouseEventValid</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSelectionChangeReason</name> = <name><name>nsISelectionListener</name>::<name>NO_REASON</name></name></expr>;</expr_stmt>
}</block></constructor>


<macro><name>NS_IMPL_CYCLE_COLLECTION_CLASS</name><argument_list>(<argument>nsFrameSelection</argument>)</argument_list></macro>
<macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN</name><argument_list>(<argument>nsFrameSelection</argument>)</argument_list></macro>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>nsISelectionController</name>::<name>NUM_SELECTIONTYPES</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <expr_stmt><expr><name><name>tmp</name>-&gt;<name>mDomSelections</name><index>[<expr><name>i</name></expr>]</index></name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></for>

  <macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR</name><argument_list>(<argument>mCellParent</argument>)</argument_list></macro>
  <expr_stmt><expr><name><name>tmp</name>-&gt;<name>mSelectingTableCellMode</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp</name>-&gt;<name>mDragSelectingCells</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR</name><argument_list>(<argument>mStartSelectedCell</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR</name><argument_list>(<argument>mEndSelectedCell</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR</name><argument_list>(<argument>mAppendStartSelectedCell</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR</name><argument_list>(<argument>mUnselectCellOnMouseUp</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR</name><argument_list>(<argument>mMaintainRange</argument>)</argument_list></macro>
<function_decl><type><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_END</name></type>
<name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN</name><parameter_list>(<param><decl><type><name>nsFrameSelection</name></type></decl></param>)</parameter_list>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>;</decl_stmt>
  for <parameter_list>(<param><decl><type><name>i</name></type> <init>= <expr>0</expr></init></decl></param></parameter_list>; <name>i</name> &lt; <name>nsISelectionController</name>::<name>NUM_SELECTIONTYPES</name>;</function_decl> <expr_stmt><expr>++<name>i</name></expr></expr_stmt>) <block>{
    <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS</name><argument_list>(<argument>mDomSelections[i]</argument>,
                                                         <argument>nsISelection</argument>)</argument_list></macro>
  }</block>

  <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mCellParent</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mStartSelectedCell</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mEndSelectedCell</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mAppendStartSelectedCell</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mUnselectCellOnMouseUp</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mMaintainRange</argument>)</argument_list></macro>
<decl_stmt><decl><type><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END</name></type>

<name>NS_IMPL_CYCLE_COLLECTING_ADDREF</name><argument_list>(<argument><expr><name>nsFrameSelection</name></expr></argument>)</argument_list>
<name>NS_IMPL_CYCLE_COLLECTING_RELEASE</name><argument_list>(<argument><expr><name>nsFrameSelection</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION</name><argument_list>(<argument><expr><name>nsFrameSelection</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsFrameSelection</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsISupports</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_MAP_END</name>


<name>nsresult</name>
<name><name>nsFrameSelection</name>::<name>FetchDesiredX</name></name><argument_list>(<argument><expr><name>nscoord</name> &amp;<name>aDesiredX</name></expr></argument>)</argument_list> <comment type="line">//the x position requested by the Key Handling for up down</comment>
<argument_list>{
  if <argument><expr>(!<name>mShell</name>)
  <block>{
    <expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"fetch desired X failed"</expr></argument>)</argument_list></call></expr>;
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></expr></argument>
  <if>if <condition>(<expr><name>mDesiredXSet</name></expr>)</condition><then>
  <expr_stmt><expr><block>{
    <expr><name>aDesiredX</name> = <name>mDesiredX</name></expr>;</block></expr></expr_stmt></then></if></argument_list></decl></decl_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }

  nsRefPtr<expr_stmt><expr>&lt;<name>nsCaret</name>&gt; <name>caret</name> = <call><name><name>mShell</name>-&gt;<name>GetCaret</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>caret</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name><name>caret</name>-&gt;<name>SetCaretDOMSelection</name></name><argument_list>(<argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsRect</name></type> <name>coord</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>caretFrame</name> <init>= <expr><call><name><name>caret</name>-&gt;<name>GetGeometry</name></name><argument_list>(<argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>coord</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>caretFrame</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>viewOffset</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIView</name>*</type> <name>view</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>caretFrame</name>-&gt;<name>GetOffsetFromView</name></name><argument_list>(<argument><expr><name>viewOffset</name></expr></argument>, <argument><expr>&amp;<name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>view</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>coord</name>.<name>x</name></name> += <name><name>viewOffset</name>.<name>x</name></name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>aDesiredX</name> = <name><name>coord</name>.<name>x</name></name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}



void
<macro><name>nsFrameSelection</name></macro><expr_stmt><expr><name>::<name>InvalidateDesiredX</name></name>() <comment type="line">//do not listen to mDesiredX you must get another.</comment>
<block>{
  <expr><name>mDesiredXSet</name> = <name>PR_FALSE</name></expr>;
}</block>



<name>void</name>
<macro><name>nsFrameSelection</name></macro><name>::<name>SetDesiredX</name></name>(<name>nscoord</name> <name>aX</name>) <comment type="line">//set the mDesiredX</comment>
<block>{
  <expr><name>mDesiredX</name> = <name>aX</name></expr>;
  <expr><name>mDesiredXSet</name> = <name>PR_TRUE</name></expr>;
}</block>

<name>nsresult</name>
<macro><name>nsFrameSelection</name></macro><name>::<name>ConstrainFrameAndPointToAnchorSubtree</name></name>(<name>nsIFrame</name>  *<name>aFrame</name>,
                                                        <name>nsPoint</name>&amp;   <name>aPoint</name>,
                                                        <name>nsIFrame</name> **<name>aRetFrame</name>,
                                                        <name>nsPoint</name>&amp;   <name>aRetPoint</name>)
<block>{
  <comment type="line">//</comment>
  <comment type="line">// The whole point of this method is to return a frame and point that</comment>
  <comment type="line">// that lie within the same valid subtree as the anchor node's frame,</comment>
  <comment type="line">// for use with the method GetContentAndOffsetsFromPoint().</comment>
  <comment type="line">//</comment>
  <comment type="line">// A valid subtree is defined to be one where all the content nodes in</comment>
  <comment type="line">// the tree have a valid parent-child relationship.</comment>
  <comment type="line">//</comment>
  <comment type="line">// If the anchor frame and aFrame are in the same subtree, aFrame will</comment>
  <comment type="line">// be returned in aRetFrame. If they are in different subtrees, we</comment>
  <comment type="line">// return the frame for the root of the subtree.</comment>
  <comment type="line">//</comment>

  <if>if <condition>(<expr>!<name>aFrame</name> || !<name>aRetFrame</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  *<name>aRetFrame</name> = <name>aFrame</name></block></expr>;</expr_stmt>
  <expr_stmt><expr><name>aRetPoint</name>  = <name>aPoint</name></expr>;</expr_stmt>

  <comment type="line">//</comment>
  <comment type="line">// Get the frame and content for the selection's anchor point!</comment>
  <comment type="line">//</comment>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type> <name>anchorNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>anchorOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr><name>result</name> = <name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetAnchorNode</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>anchorNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>

  <if>if <condition>(<expr>!<name>anchorNode</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <expr_stmt><expr><name>result</name> = <name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetAnchorOffset</name><argument_list>(<argument><expr>&amp;<name>anchorOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>anchorContent</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>anchorNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>anchorContent</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  
  <comment type="line">//</comment>
  <comment type="line">// Now find the root of the subtree containing the anchor's content.</comment>
  <comment type="line">//</comment>

  <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>anchorRoot</name> <init>= <expr><call><name><name>anchorContent</name>-&gt;<name>GetSelectionRootContent</name></name><argument_list>(<argument><expr><name>mShell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>anchorRoot</name></expr></argument>, <argument><expr><name>NS_ERROR_UNEXPECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">//</comment>
  <comment type="line">// Now find the root of the subtree containing aFrame's content.</comment>
  <comment type="line">//</comment>

  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>content</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>content</name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>contentRoot</name> <init>= <expr><call><name><name>content</name>-&gt;<name>GetSelectionRootContent</name></name><argument_list>(<argument><expr><name>mShell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>contentRoot</name></expr></argument>, <argument><expr><name>NS_ERROR_UNEXPECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>anchorRoot</name> == <name>contentRoot</name></expr>)</condition><then>
    <block>{
      <comment type="line">// If the aFrame's content isn't the capturing content, it should be</comment>
      <comment type="line">// a descendant.  At this time, we can return simply.</comment>
      <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>capturedContent</name> <init>= <expr><call><name><name>nsIPresShell</name>::<name>GetCapturingContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>capturedContent</name> != <name>content</name></expr>)</condition><then>
      <block>{
        <return>return <expr><name>NS_OK</name></expr>;</return>
      }</block></then></if>

      <comment type="line">// Find the frame under the mouse cursor with the root frame.</comment>
      <comment type="line">// At this time, don't use the anchor's frame because it may not have</comment>
      <comment type="line">// fixed positioned frames.</comment>
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootFrame</name> <init>= <expr><call><name><name>mShell</name>-&gt;<name>FrameManager</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsPoint</name></type> <name>ptInRoot</name> <init>= <expr><name>aPoint</name> + <call><name><name>aFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>cursorFrame</name> <init>=
        <expr><call><name><name>nsLayoutUtils</name>::<name>GetFrameForPoint</name></name><argument_list>(<argument><expr><name>rootFrame</name></expr></argument>, <argument><expr><name>ptInRoot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="line">// If the mouse cursor in on a frame which is descendant of same</comment>
      <comment type="line">// selection root, we can expand the selection to the frame.</comment>
      <if>if <condition>(<expr><name>cursorFrame</name> &amp;&amp; <call><name><name>cursorFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call> == <name>mShell</name></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>cursorContent</name> <init>= <expr><call><name><name>cursorFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>cursorContent</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>cursorContentRoot</name> <init>=
          <expr><call><name><name>cursorContent</name>-&gt;<name>GetSelectionRootContent</name></name><argument_list>(<argument><expr><name>mShell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>cursorContentRoot</name></expr></argument>, <argument><expr><name>NS_ERROR_UNEXPECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>cursorContentRoot</name> == <name>anchorRoot</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>aRetFrame</name> = <name>cursorFrame</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>aRetPoint</name> = <name>aPoint</name> + <call><name><name>aFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><name>cursorFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
      <comment type="line">// Otherwise, e.g., the cursor isn't on any frames (e.g., the mouse</comment>
      <comment type="line">// cursor is out of the window), we should use the frame of the anchor</comment>
      <comment type="line">// root.</comment>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">//</comment>
  <comment type="line">// When we can't find a frame which is under the mouse cursor and has a same</comment>
  <comment type="line">// selection root as the anchor node's, we should return the selection root</comment>
  <comment type="line">// frame.</comment>
  <comment type="line">//</comment>

  <expr_stmt><expr>*<name>aRetFrame</name> = <call><name><name>anchorRoot</name>-&gt;<name>GetPrimaryFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!*<name>aRetFrame</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <comment type="line">//</comment>
  <comment type="line">// Now make sure that aRetPoint is converted to the same coordinate</comment>
  <comment type="line">// system used by aRetFrame.</comment>
  <comment type="line">//</comment>

  <expr_stmt><expr><name>aRetPoint</name> = <name>aPoint</name> + <call><name><name>aFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr>*<name>aRetFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
void
<macro><name>nsFrameSelection</name></macro><expr_stmt><expr><name>::<name>SetCaretBidiLevel</name></name>(<name>PRUint8</name> <name>aLevel</name>)
<block>{
  <comment type="line">// If the current level is undefined, we have just inserted new text.</comment>
  <comment type="line">// In this case, we don't want to reset the keyboard language</comment>
  <expr><name>PRBool</name> <name>afterInsert</name> = !!(<name>mCaretBidiLevel</name> &amp; <name>BIDI_LEVEL_UNDEFINED</name>)</expr>;
  <expr><name>mCaretBidiLevel</name> = <name>aLevel</name></expr>;
  
  <expr><name>nsIBidiKeyboard</name>* <name>bidiKeyboard</name> = <call><name><name>nsContentUtils</name>::<name>GetBidiKeyboard</name></name><argument_list>()</argument_list></call></expr>;
  <if>if <condition>(<expr><name>bidiKeyboard</name> &amp;&amp; !<name>afterInsert</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>bidiKeyboard</name>-&gt;<name>SetLangFromBidiLevel</name></name><argument_list>(<argument><expr><name>aLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></block></expr></expr_stmt>
  <return>return;</return>
}

PRUint8
<macro><name>nsFrameSelection</name></macro><expr_stmt><expr><name>::<name>GetCaretBidiLevel</name></name>() const
<block>{
  <return>return <expr><name>mCaretBidiLevel</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type>
<name><name>nsFrameSelection</name>::<name>UndefineCaretBidiLevel</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mCaretBidiLevel</name> |= <name>BIDI_LEVEL_UNDEFINED</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PRINT_RANGE</name></cpp:ifdef>
<function><type><name>void</name></type> <name>printRange</name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aDomRange</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aDomRange</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"NULL nsIDOMRange\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>startNode</name> <init>= <expr><call><name><name>aDomRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>endNode</name> <init>= <expr><call><name><name>aDomRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startOffset</name> <init>= <expr><call><name><name>aDomRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>endOffset</name> <init>= <expr><call><name><name>aDomRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"range: 0x%lx\t start: 0x%lx %ld, \t end: 0x%lx,%ld\n"</expr></argument>,
         <argument><expr>(<name>unsigned</name> <name>long</name>)<name>aDomRange</name></expr></argument>,
         <argument><expr>(<name>unsigned</name> <name>long</name>)<name>startNode</name></expr></argument>, <argument><expr>(<name>long</name>)<name>startOffset</name></expr></argument>,
         <argument><expr>(<name>unsigned</name> <name>long</name>)<name>endNode</name></expr></argument>, <argument><expr>(<name>long</name>)<name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PRINT_RANGE */</comment>

<function><type><specifier>static</specifier>
<name>nsIAtom</name> *</type><name>GetTag</name><parameter_list>(<param><decl><type><name>nsINode</name> *</type><name>aNode</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>content</name></expr>)</condition><then> 
  <block>{
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"bad node passed to GetTag()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>
  
  <return>return <expr><call><name><name>content</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Returns the parent</comment>
<function><type><name>nsINode</name>*</type>
<name>ParentOffset</name><parameter_list>(<param><decl><type><name>nsINode</name> *</type><name>aNode</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aChildOffset</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aNode</name> || !<name>aChildOffset</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>parent</name> <init>= <expr><call><name><name>aNode</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>parent</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr>*<name>aChildOffset</name> = <call><name><name>parent</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>parent</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsINode</name>*</type>
<name>GetCellParent</name><parameter_list>(<param><decl><type><name>nsINode</name> *</type><name>aDomNode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>aDomNode</name></expr>)</condition><then>
      <return>return <expr><name>nsnull</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>nsINode</name>*</type> <name>current</name> <init>= <expr><name>aDomNode</name></expr></init></decl>;</decl_stmt>
    <comment type="line">// Start with current node and look for a table cell</comment>
    <while>while <condition>(<expr><name>current</name></expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>tag</name> <init>= <expr><call><name>GetTag</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>tag</name> == <name><name>nsGkAtoms</name>::<name>td</name></name> || <name>tag</name> == <name><name>nsGkAtoms</name>::<name>th</name></name></expr>)</condition><then>
        <return>return <expr><name>current</name></expr>;</return></then></if>
      <expr_stmt><expr><name>current</name> = <call><name><name>current</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name><name>nsFrameSelection</name>::<name>Init</name></name><parameter_list>(<param><decl><type><name>nsIPresShell</name> *</type><name>aShell</name></decl></param>, <param><decl><type><name>nsIContent</name> *</type><name>aLimiter</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mShell</name> = <name>aShell</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mMouseDownState</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mDesiredXSet</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mLimiter</name> = <name>aLimiter</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mCaretMovementStyle</name> = <call><name><name>nsContentUtils</name>::<name>GetIntPref</name></name><argument_list>(<argument><expr>"bidi.edit.caret_movement_style"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>MoveCaret</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type>          <name>aKeycode</name></decl></param>,
                            <param><decl><type><name>PRBool</name></type>            <name>aContinueSelection</name></decl></param>,
                            <param><decl><type><name>nsSelectionAmount</name></type> <name>aAmount</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>visualMovement</name> <init>=
      <expr>(<name>aKeycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_BACK_SPACE</name></name> ||
       <name>aKeycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_DELETE</name></name> ||
       <name>aKeycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_HOME</name></name> ||
       <name>aKeycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_END</name></name>) ?
      <name>PR_FALSE</name> : <comment type="line">// Delete operations and home/end are always logical</comment>
      <name>mCaretMovementStyle</name> == 1 ||
        (<name>mCaretMovementStyle</name> == 2 &amp;&amp; !<name>aContinueSelection</name>)</expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name>aKeycode</name></expr></argument>, <argument><expr><name>aContinueSelection</name></expr></argument>, <argument><expr><name>aAmount</name></expr></argument>, <argument><expr><name>visualMovement</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>MoveCaret</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type>          <name>aKeycode</name></decl></param>,
                            <param><decl><type><name>PRBool</name></type>            <name>aContinueSelection</name></decl></param>,
                            <param><decl><type><name>nsSelectionAmount</name></type> <name>aAmount</name></decl></param>,
                            <param><decl><type><name>PRBool</name></type>            <name>aVisualMovement</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Flush out layout, since we need it to be up to date to do caret</comment>
  <comment type="line">// positioning.</comment>
  <expr_stmt><expr><call><name><name>mShell</name>-&gt;<name>FlushPendingNotifications</name></name><argument_list>(<argument><expr><name>Flush_Layout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>mShell</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsPresContext</name> *</type><name>context</name> <init>= <expr><call><name><name>mShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>context</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>isCollapsed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>desiredX</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">//we must keep this around and revalidate it when its just UP/DOWN</comment>

  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsTypedSelection</name></expr></argument>&gt;</argument_list></name></type> <name>sel</name> <init>= <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>sel</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name><name>sel</name>-&gt;<name>GetIsCollapsed</name></name><argument_list>(<argument><expr>&amp;<name>isCollapsed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>
  <if>if <condition>(<expr><name>aKeycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_UP</name></name> ||
      <name>aKeycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_DOWN</name></name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>result</name> = <call><name>FetchDesiredX</name><argument_list>(<argument><expr><name>desiredX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>result</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>SetDesiredX</name><argument_list>(<argument><expr><name>desiredX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>caretStyle</name> <init>= <expr><call><name><name>nsContentUtils</name>::<name>GetIntPref</name></name><argument_list>(<argument><expr>"layout.selection.caret_style"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_MACOSX</name></cpp:ifdef>
  <if>if <condition>(<expr><name>caretStyle</name> == 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>caretStyle</name> = 2</expr>;</expr_stmt> <comment type="line">// put caret at the selection edge in the |aKeycode| direction</comment>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr>!<name>isCollapsed</name> &amp;&amp; !<name>aContinueSelection</name> &amp;&amp; <name>caretStyle</name> == 2</expr>)</condition><then> <block>{
    <switch>switch <condition>(<expr><name>aKeycode</name></expr>)</condition><block>{
      <case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_LEFT</name></name></expr>  :
      </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_UP</name></name></expr>    :
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>nsIRange</name>*</type> <name>anchorFocusRange</name> <init>= <expr><call><name><name>sel</name>-&gt;<name>GetAnchorFocusRange</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>anchorFocusRange</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>Collapse</name></name><argument_list>(<argument><expr><call><name><name>anchorFocusRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>,
                          <argument><expr><call><name><name>anchorFocusRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>mHint</name> = <name>HINTRIGHT</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>ScrollIntoView</name></name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_FOCUS_REGION</name></name></expr></argument>,
                              <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block>

      </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_RIGHT</name></name></expr> :
      </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_DOWN</name></name></expr>  :
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>nsIRange</name>*</type> <name>anchorFocusRange</name> <init>= <expr><call><name><name>sel</name>-&gt;<name>GetAnchorFocusRange</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>anchorFocusRange</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>Collapse</name></name><argument_list>(<argument><expr><call><name><name>anchorFocusRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></argument>,
                          <argument><expr><call><name><name>anchorFocusRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>mHint</name> = <name>HINTLEFT</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>ScrollIntoView</name></name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_FOCUS_REGION</name></name></expr></argument>,
                              <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block>
    </case>}</block></switch>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>frame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>offsetused</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>result</name> = <call><name><name>sel</name>-&gt;<name>GetPrimaryFrameForFocusNode</name></name><argument_list>(<argument><expr>&amp;<name>frame</name></expr></argument>, <argument><expr>&amp;<name>offsetused</name></expr></argument>,
                                            <argument><expr><name>aVisualMovement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> || !<name>frame</name></expr>)</condition><then>
    <return>return <expr><name>result</name>?<name>result</name>:<name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsPeekOffsetStruct</name></type> <name>pos</name></decl>;</decl_stmt>
  <comment type="line">//set data using mLimiter to stop on scroll views.  If we have a limiter then we stop peeking</comment>
  <comment type="line">//when we hit scrollable views.  If no limiter then just let it go ahead</comment>
  <expr_stmt><expr><call><name><name>pos</name>.<name>SetData</name></name><argument_list>(<argument><expr><name>aAmount</name></expr></argument>, <argument><expr><name>eDirPrevious</name></expr></argument>, <argument><expr><name>offsetused</name></expr></argument>, <argument><expr><name>desiredX</name></expr></argument>, 
              <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>mLimiter</name> != <name>nsnull</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>aVisualMovement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsBidiLevel</name></type> <name>baseLevel</name> <init>= <expr><call><name><name>nsBidiPresUtils</name>::<name>GetFrameBaseLevel</name></name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <function_decl><type><name>HINT</name></type> <name>tHint</name><parameter_list>(<param><decl><type><name>mHint</name></type></decl></param>)</parameter_list>;</function_decl> <comment type="line">//temporary variable so we dont set mHint until it is necessary</comment>
  <switch>switch <condition>(<expr><name>aKeycode</name></expr>)</condition><block>{
    <case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_RIGHT</name></name></expr> : 
        <expr_stmt><expr><call><name>InvalidateDesiredX</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pos</name>.<name>mDirection</name></name> = (<name>baseLevel</name> &amp; 1) ? <name>eDirPrevious</name> : <name>eDirNext</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_LEFT</name></name></expr> :
        <expr_stmt><expr><call><name>InvalidateDesiredX</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pos</name>.<name>mDirection</name></name> = (<name>baseLevel</name> &amp; 1) ? <name>eDirNext</name> : <name>eDirPrevious</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_DELETE</name></name></expr> :
        <expr_stmt><expr><call><name>InvalidateDesiredX</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pos</name>.<name>mDirection</name></name> = <name>eDirNext</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_BACK_SPACE</name></name></expr> : 
        <expr_stmt><expr><call><name>InvalidateDesiredX</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pos</name>.<name>mDirection</name></name> = <name>eDirPrevious</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_DOWN</name></name></expr> : 
        <expr_stmt><expr><name><name>pos</name>.<name>mAmount</name></name> = <name>eSelectLine</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pos</name>.<name>mDirection</name></name> = <name>eDirNext</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_UP</name></name></expr> : 
        <expr_stmt><expr><name><name>pos</name>.<name>mAmount</name></name> = <name>eSelectLine</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pos</name>.<name>mDirection</name></name> = <name>eDirPrevious</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_HOME</name></name></expr> :
        <expr_stmt><expr><call><name>InvalidateDesiredX</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pos</name>.<name>mAmount</name></name> = <name>eSelectBeginLine</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_END</name></name></expr> :
        <expr_stmt><expr><call><name>InvalidateDesiredX</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pos</name>.<name>mAmount</name></name> = <name>eSelectEndLine</name></expr>;</expr_stmt>
      <break>break;</break>
  </case><default>default :<return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  </default>}</block></switch>
  <expr_stmt><expr><call><name>PostReason</name><argument_list>(<argument><expr><name><name>nsISelectionListener</name>::<name>KEYPRESS_REASON</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name> = <call><name><name>frame</name>-&gt;<name>PeekOffset</name></name><argument_list>(<argument><expr>&amp;<name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; <name><name>pos</name>.<name>mResultContent</name></name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>theFrame</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>currentOffset</name></decl>, <decl><type ref="prev"/><name>frameStart</name></decl>, <decl><type ref="prev"/><name>frameEnd</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>aAmount</name> == <name>eSelectCharacter</name> || <name>aAmount</name> == <name>eSelectWord</name></expr>)</condition><then>
    <block>{
      <comment type="line">// For left/right, PeekOffset() sets pos.mResultFrame correctly, but does not set pos.mAttachForward,</comment>
      <comment type="line">// so determine the hint here based on the result frame and offset:</comment>
      <comment type="line">// If we're at the end of a text frame, set the hint to HINTLEFT to indicate that we</comment>
      <comment type="line">// want the caret displayed at the end of this frame, not at the beginning of the next one.</comment>
      <expr_stmt><expr><name>theFrame</name> = <name><name>pos</name>.<name>mResultFrame</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>theFrame</name>-&gt;<name>GetOffsets</name></name><argument_list>(<argument><expr><name>frameStart</name></expr></argument>, <argument><expr><name>frameEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>currentOffset</name> = <name><name>pos</name>.<name>mContentOffset</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>frameEnd</name> == <name>currentOffset</name> &amp;&amp; !(<name>frameStart</name> == 0 &amp;&amp; <name>frameEnd</name> == 0)</expr>)</condition><then>
        <expr_stmt><expr><name>tHint</name> = <name>HINTLEFT</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>tHint</name> = <name>HINTRIGHT</name></expr>;</expr_stmt></else></if>
    }</block></then> <else>else <block>{
      <comment type="line">// For up/down and home/end, pos.mResultFrame might not be set correctly, or not at all.</comment>
      <comment type="line">// In these cases, get the frame based on the content and hint returned by PeekOffset().</comment>
      <expr_stmt><expr><name>tHint</name> = (<name>HINT</name>)<name><name>pos</name>.<name>mAttachForward</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>theFrame</name> = <call><name>GetFrameForNodeOffset</name><argument_list>(<argument><expr><name><name>pos</name>.<name>mResultContent</name></name></expr></argument>, <argument><expr><name><name>pos</name>.<name>mContentOffset</name></name></expr></argument>,
                                       <argument><expr><name>tHint</name></expr></argument>, <argument><expr>&amp;<name>currentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>theFrame</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

      <expr_stmt><expr><call><name><name>theFrame</name>-&gt;<name>GetOffsets</name></name><argument_list>(<argument><expr><name>frameStart</name></expr></argument>, <argument><expr><name>frameEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><call><name><name>context</name>-&gt;<name>BidiEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <block>{
      <switch>switch <condition>(<expr><name>aKeycode</name></expr>)</condition> <block>{
        <case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_HOME</name></name></expr>:
        </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_END</name></name></expr>:
          <comment type="line">// set the caret Bidi level to the paragraph embedding level</comment>
          <expr_stmt><expr><call><name>SetCaretBidiLevel</name><argument_list>(<argument><expr><call><name>NS_GET_BASE_LEVEL</name><argument_list>(<argument><expr><name>theFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

        </case><default>default:
          <comment type="line">// If the current position is not a frame boundary, it's enough just to take the Bidi level of the current frame</comment>
          <if>if <condition>(<expr>(<name><name>pos</name>.<name>mContentOffset</name></name> != <name>frameStart</name> &amp;&amp; <name><name>pos</name>.<name>mContentOffset</name></name> != <name>frameEnd</name>)
              || (<name>eSelectLine</name> == <name>aAmount</name>)</expr>)</condition><then>
          <block>{
            <expr_stmt><expr><call><name>SetCaretBidiLevel</name><argument_list>(<argument><expr><call><name>NS_GET_EMBEDDING_LEVEL</name><argument_list>(<argument><expr><name>theFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then>
          <else>else
            <expr_stmt><expr><call><name>BidiLevelFromMove</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>, <argument><expr><name><name>pos</name>.<name>mResultContent</name></name></expr></argument>, <argument><expr><name><name>pos</name>.<name>mContentOffset</name></name></expr></argument>, <argument><expr><name>aKeycode</name></expr></argument>, <argument><expr><name>tHint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      </default>}</block></switch>
    }</block></then></if>
    <expr_stmt><expr><name>result</name> = <call><name>TakeFocus</name><argument_list>(<argument><expr><name><name>pos</name>.<name>mResultContent</name></name></expr></argument>, <argument><expr><name><name>pos</name>.<name>mContentOffset</name></name></expr></argument>, <argument><expr><name><name>pos</name>.<name>mContentOffset</name></name></expr></argument>,
                       <argument><expr><name>tHint</name></expr></argument>, <argument><expr><name>aContinueSelection</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><name>aKeycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_RIGHT</name></name> &amp;&amp; !<name>aContinueSelection</name></expr>)</condition><then> <block>{
    <comment type="line">// Collapse selection if PeekOffset failed, we either</comment>
    <comment type="line">//  1. bumped into the BRFrame, bug 207623</comment>
    <comment type="line">//  2. had select-all in a text input (DIV range), bug 352759.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>isBRFrame</name> <init>= <expr><call><name><name>frame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>brFrame</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>sel</name>-&gt;<name>Collapse</name></name><argument_list>(<argument><expr><call><name><name>sel</name>-&gt;<name>GetFocusNode</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sel</name>-&gt;<name>GetFocusOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Note: 'frame' might be dead here.</comment>
    <if>if <condition>(<expr>!<name>isBRFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mHint</name> = <name>HINTLEFT</name></expr>;</expr_stmt> <comment type="line">// We're now at the end of the frame to the left.</comment>
    }</block></then></if>
    <expr_stmt><expr><name>result</name> = <name>NS_OK</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>result</name> = <name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;
      <call><name>ScrollIntoView</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_FOCUS_REGION</name></name></expr></argument>,
                     <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="line">//END nsFrameSelection methods</comment>


<comment type="line">//BEGIN nsFrameSelection methods</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>ToString</name></name><parameter_list>(<param><decl><type><name>PRUnichar</name> **</type><name>aReturn</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>ToStringWithFormat</name><argument_list>(<argument><expr>"text/plain"</expr></argument>,
                            <argument><expr><name><name>nsIDocumentEncoder</name>::<name>SkipInvisibleContent</name></name></expr></argument>,
                            <argument><expr>0</expr></argument>, <argument><expr><name>aReturn</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>ToStringWithFormat</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>aFormatType</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>, 
                                   <param><decl><type><name>PRInt32</name></type> <name>aWrapCol</name></decl></param>, <param><decl><type><name>PRUnichar</name> **</type><name>aReturn</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>aReturn</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  
  <function_decl><type><name>nsCAutoString</name></type> <name>formatType</name><parameter_list>( <param><decl><type><name>NS_DOC_ENCODER_CONTRACTID_BASE</name></type></decl></param> )</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>formatType</name>.<name>Append</name></name><argument_list>(<argument><expr><name>aFormatType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocumentEncoder</name></expr></argument>&gt;</argument_list></name></type> <name>encoder</name> <init>=
           <expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><call><name><name>formatType</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>shell</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name>GetPresShell</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> || !<name>shell</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIDocument</name> *</type><name>doc</name> <init>= <expr><call><name><name>shell</name>-&gt;<name>GetDocument</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMDocument</name></expr></argument>&gt;</argument_list></name></type> <name>domDoc</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>domDoc</name></expr></argument>, <argument><expr>"Need a document"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Flags should always include OutputSelectionOnly if we're coming from here:</comment>
  <expr_stmt><expr><name>aFlags</name> |= <name><name>nsIDocumentEncoder</name>::<name>OutputSelectionOnly</name></name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>readstring</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>readstring</name>.<name>AssignASCII</name></name><argument_list>(<argument><expr><name>aFormatType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>encoder</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>domDoc</name></expr></argument>, <argument><expr><name>readstring</name></expr></argument>, <argument><expr><name>aFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>encoder</name>-&gt;<name>SetSelection</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aWrapCol</name> != 0</expr>)</condition><then>
    <expr_stmt><expr><call><name><name>encoder</name>-&gt;<name>SetWrapColumn</name></name><argument_list>(<argument><expr><name>aWrapCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>tmp</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>encoder</name>-&gt;<name>EncodeToString</name></name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aReturn</name> = <call><name>ToNewUnicode</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="line">//get the unicode pointer from it. this is temporary</comment>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>SetInterlinePosition</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aHintRight</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return></then></if> <comment type="line">// Can't do selection</comment>
  <decl_stmt><decl><type><name><name>nsFrameSelection</name>::<name>HINT</name></name></type> <name>hint</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aHintRight</name></expr>)</condition><then>
    <expr_stmt><expr><name>hint</name> = <name><name>nsFrameSelection</name>::<name>HINTRIGHT</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>hint</name> = <name><name>nsFrameSelection</name>::<name>HINTLEFT</name></name></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>SetHint</name></name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetInterlinePosition</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aHintRight</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return></then></if> <comment type="line">// Can't do selection</comment>
  <expr_stmt><expr>*<name>aHintRight</name> = (<call><name><name>mFrameSelection</name>-&gt;<name>GetHint</name></name><argument_list>()</argument_list></call> == <name><name>nsFrameSelection</name>::<name>HINTRIGHT</name></name>)</expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsPrevNextBidiLevels</name></type>
<name><name>nsFrameSelection</name>::<name>GetPrevNextBidiLevels</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aNode</name></decl></param>,
                                        <param><decl><type><name>PRUint32</name></type>    <name>aContentOffset</name></decl></param>,
                                        <param><decl><type><name>PRBool</name></type>      <name>aJumpLines</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><call><name>GetPrevNextBidiLevels</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>, <argument><expr><name>mHint</name></expr></argument>, <argument><expr><name>aJumpLines</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsPrevNextBidiLevels</name></type>
<name><name>nsFrameSelection</name>::<name>GetPrevNextBidiLevels</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aNode</name></decl></param>,
                                        <param><decl><type><name>PRUint32</name></type>    <name>aContentOffset</name></decl></param>,
                                        <param><decl><type><name>HINT</name></type>        <name>aHint</name></decl></param>,
                                        <param><decl><type><name>PRBool</name></type>      <name>aJumpLines</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <comment type="line">// Get the level of the frames on each side</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>    *</type><name>currentFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>     <name>currentOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>     <name>frameStart</name></decl>, <decl><type ref="prev"/><name>frameEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDirection</name></type> <name>direction</name></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>nsPrevNextBidiLevels</name></type> <name>levels</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>levels</name>.<name>SetData</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>currentFrame</name> = <call><name>GetFrameForNodeOffset</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>,
                                       <argument><expr><name>aHint</name></expr></argument>, <argument><expr>&amp;<name>currentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>currentFrame</name></expr>)</condition><then>
    <return>return <expr><name>levels</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name><name>currentFrame</name>-&gt;<name>GetOffsets</name></name><argument_list>(<argument><expr><name>frameStart</name></expr></argument>, <argument><expr><name>frameEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>0 == <name>frameStart</name> &amp;&amp; 0 == <name>frameEnd</name></expr>)</condition><then>
    <expr_stmt><expr><name>direction</name> = <name>eDirPrevious</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>frameStart</name> == <name>currentOffset</name></expr>)</condition><then>
    <expr_stmt><expr><name>direction</name> = <name>eDirPrevious</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>frameEnd</name> == <name>currentOffset</name></expr>)</condition><then>
    <expr_stmt><expr><name>direction</name> = <name>eDirNext</name></expr>;</expr_stmt></then>
  <else>else <block>{
    <comment type="line">// we are neither at the beginning nor at the end of the frame, so we have no worries</comment>
    <expr_stmt><expr><call><name><name>levels</name>.<name>SetData</name></name><argument_list>(<argument><expr><name>currentFrame</name></expr></argument>, <argument><expr><name>currentFrame</name></expr></argument>,
                   <argument><expr><call><name>NS_GET_EMBEDDING_LEVEL</name><argument_list>(<argument><expr><name>currentFrame</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><call><name>NS_GET_EMBEDDING_LEVEL</name><argument_list>(<argument><expr><name>currentFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>levels</name></expr>;</return>
  }</block></else></if></else></if></else></if>

  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>newFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>jumpedLine</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>currentFrame</name>-&gt;<name>GetFrameFromDirection</name></name><argument_list>(<argument><expr><name>direction</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                                    <argument><expr><name>aJumpLines</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>,
                                                    <argument><expr>&amp;<name>newFrame</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr>&amp;<name>jumpedLine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>newFrame</name> = <name>nsnull</name></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>PRUint8</name></type> <name>baseLevel</name> <init>= <expr><call><name>NS_GET_BASE_LEVEL</name><argument_list>(<argument><expr><name>currentFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint8</name></type> <name>currentLevel</name> <init>= <expr><call><name>NS_GET_EMBEDDING_LEVEL</name><argument_list>(<argument><expr><name>currentFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint8</name></type> <name>newLevel</name> <init>= <expr><name>newFrame</name> ? <call><name>NS_GET_EMBEDDING_LEVEL</name><argument_list>(<argument><expr><name>newFrame</name></expr></argument>)</argument_list></call> : <name>baseLevel</name></expr></init></decl>;</decl_stmt>
  
  <comment type="line">// If not jumping lines, disregard br frames, since they might be positioned incorrectly.</comment>
  <comment type="line">// XXX This could be removed once bug 339786 is fixed.</comment>
  <if>if <condition>(<expr>!<name>aJumpLines</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name><name>currentFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>brFrame</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>currentFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>currentLevel</name> = <name>baseLevel</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>newFrame</name> &amp;&amp; <call><name><name>newFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>brFrame</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>newFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>newLevel</name> = <name>baseLevel</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  
  <if>if <condition>(<expr><name>direction</name> == <name>eDirNext</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>levels</name>.<name>SetData</name></name><argument_list>(<argument><expr><name>currentFrame</name></expr></argument>, <argument><expr><name>newFrame</name></expr></argument>, <argument><expr><name>currentLevel</name></expr></argument>, <argument><expr><name>newLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name><name>levels</name>.<name>SetData</name></name><argument_list>(<argument><expr><name>newFrame</name></expr></argument>, <argument><expr><name>currentFrame</name></expr></argument>, <argument><expr><name>newLevel</name></expr></argument>, <argument><expr><name>currentLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr><name>levels</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>GetFrameFromLevel</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>    *</type><name>aFrameIn</name></decl></param>,
                                    <param><decl><type><name>nsDirection</name></type>  <name>aDirection</name></decl></param>,
                                    <param><decl><type><name>PRUint8</name></type>      <name>aBidiLevel</name></decl></param>,
                                    <param><decl><type><name>nsIFrame</name>   **</type><name>aFrameOut</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRUint8</name></type> <name>foundLevel</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>foundFrame</name> <init>= <expr><name>aFrameIn</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIFrameEnumerator</name></expr></argument>&gt;</argument_list></name></type> <name>frameTraversal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIFrameTraversal</name></expr></argument>&gt;</argument_list></name></type> <name>trav</name><argument_list>(<argument><expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>kFrameTraversalCID</name></expr></argument>,<argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>result</name></expr>;</return></then></if>

  <expr_stmt><expr><name>result</name> = <call><name><name>trav</name>-&gt;<name>NewFrameTraversal</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>frameTraversal</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name><name>mShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aFrameIn</name></expr></argument>,
                                   <argument><expr><name>eLeaf</name></expr></argument>,
                                   <argument><expr><name>PR_FALSE</name></expr></argument>, <comment type="line">// aVisual</comment>
                                   <argument><expr><name>PR_FALSE</name></expr></argument>, <comment type="line">// aLockInScrollView</comment>
                                   <argument><expr><name>PR_FALSE</name></expr></argument>  <comment type="line">// aFollowOOFs</comment>
                                   )</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>

  <do>do <block>{
    <expr_stmt><expr>*<name>aFrameOut</name> = <name>foundFrame</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>aDirection</name> == <name>eDirNext</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>frameTraversal</name>-&gt;<name>Next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
    <else>else 
      <expr_stmt><expr><call><name><name>frameTraversal</name>-&gt;<name>Prev</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>

    <expr_stmt><expr><name>foundFrame</name> = <call><name><name>frameTraversal</name>-&gt;<name>CurrentItem</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>foundFrame</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>foundLevel</name> = <call><name>NS_GET_EMBEDDING_LEVEL</name><argument_list>(<argument><expr><name>foundFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  }</block> while <condition>(<expr><name>foundLevel</name> &gt; <name>aBidiLevel</name></expr>)</condition>;</do>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>MaintainSelection</name></name><parameter_list>(<param><decl><type><name>nsSelectionAmount</name></type> <name>aAmount</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr><name>mMaintainedAmount</name> = <name>aAmount</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>nsIRange</name>*</type> <name>anchorFocusRange</name> <init>=
    <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetAnchorFocusRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>anchorFocusRange</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name><name>anchorFocusRange</name>-&gt;<name>CloneRange</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mMaintainRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>mMaintainRange</name> = <name>nsnull</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<comment type="block" format="doxygen">/** After moving the caret, its Bidi level is set according to the following rules:
 *
 *  After moving over a character with left/right arrow, set to the Bidi level of the last moved over character.
 *  After Home and End, set to the paragraph embedding level.
 *  After up/down arrow, PageUp/Down, set to the lower level of the 2 surrounding characters.
 *  After mouse click, set to the level of the current frame.
 *
 *  The following two methods use GetPrevNextBidiLevels to determine the new Bidi level.
 *  BidiLevelFromMove is called when the caret is moved in response to a keyboard event
 *
 * @param aPresShell is the presentation shell
 * @param aNode is the content node
 * @param aContentOffset is the new caret position, as an offset into aNode
 * @param aKeycode is the keyboard event that moved the caret to the new position
 * @param aHint is the hint indicating in what logical direction the caret moved
 */</comment>
<function><type><name>void</name></type> <name><name>nsFrameSelection</name>::<name>BidiLevelFromMove</name></name><parameter_list>(<param><decl><type><name>nsIPresShell</name>*</type> <name>aPresShell</name></decl></param>,
                                         <param><decl><type><name>nsIContent</name>   *</type><name>aNode</name></decl></param>,
                                         <param><decl><type><name>PRUint32</name></type>      <name>aContentOffset</name></decl></param>,
                                         <param><decl><type><name>PRUint32</name></type>      <name>aKeycode</name></decl></param>,
                                         <param><decl><type><name>HINT</name></type>          <name>aHint</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>aKeycode</name></expr>)</condition> <block>{

    <comment type="line">// Right and Left: the new cursor Bidi level is the level of the character moved over</comment>
    <case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_RIGHT</name></name></expr>:
    </case><case>case <expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_LEFT</name></name></expr>:
    <block>{
      <decl_stmt><decl><type><name>nsPrevNextBidiLevels</name></type> <name>levels</name> <init>= <expr><call><name>GetPrevNextBidiLevels</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>,
                                                          <argument><expr><name>aHint</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>HINTLEFT</name> == <name>aHint</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SetCaretBidiLevel</name><argument_list>(<argument><expr><name><name>levels</name>.<name>mLevelBefore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SetCaretBidiLevel</name><argument_list>(<argument><expr><name><name>levels</name>.<name>mLevelAfter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <break>break;</break>
    }</block>
      <comment type="block">/*
    // Up and Down: the new cursor Bidi level is the smaller of the two surrounding characters      
    case nsIDOMKeyEvent::DOM_VK_UP:
    case nsIDOMKeyEvent::DOM_VK_DOWN:
      GetPrevNextBidiLevels(aContext, aNode, aContentOffset, &amp;firstFrame, &amp;secondFrame, &amp;firstLevel, &amp;secondLevel);
      aPresShell-&gt;SetCaretBidiLevel(NS_MIN(firstLevel, secondLevel));
      break;
      */</comment>

    </case><default>default:
      <expr_stmt><expr><call><name>UndefineCaretBidiLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </default>}</block></switch>
}</block></function>

<comment type="block" format="doxygen">/**
 * BidiLevelFromClick is called when the caret is repositioned by clicking the mouse
 *
 * @param aNode is the content node
 * @param aContentOffset is the new caret position, as an offset into aNode
 */</comment>
<function><type><name>void</name></type> <name><name>nsFrameSelection</name>::<name>BidiLevelFromClick</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aNode</name></decl></param>,
                                          <param><decl><type><name>PRUint32</name></type>    <name>aContentOffset</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>clickInFrame</name><init>=<expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>OffsetNotUsed</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>clickInFrame</name> = <call><name>GetFrameForNodeOffset</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>, <argument><expr><name>mHint</name></expr></argument>, <argument><expr>&amp;<name>OffsetNotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>clickInFrame</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <expr_stmt><expr><call><name>SetCaretBidiLevel</name><argument_list>(<argument><expr><call><name>NS_GET_EMBEDDING_LEVEL</name><argument_list>(<argument><expr><name>clickInFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>PRBool</name></type>
<name><name>nsFrameSelection</name>::<name>AdjustForMaintainedSelection</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>,
                                               <param><decl><type><name>PRInt32</name></type>     <name>aOffset</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mMaintainRange</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr>!<name>aContent</name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>rangeStartNode</name> <init>= <expr><call><name><name>mMaintainRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>rangeEndNode</name> <init>= <expr><call><name><name>mMaintainRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rangeStartOffset</name> <init>= <expr><call><name><name>mMaintainRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rangeEndOffset</name> <init>= <expr><call><name><name>mMaintainRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>relToStart</name> <init>=
    <expr><call><name><name>nsContentUtils</name>::<name>ComparePoints</name></name><argument_list>(<argument><expr><name>rangeStartNode</name></expr></argument>, <argument><expr><name>rangeStartOffset</name></expr></argument>,
                                  <argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>relToEnd</name> <init>=
    <expr><call><name><name>nsContentUtils</name>::<name>ComparePoints</name></name><argument_list>(<argument><expr><name>rangeEndNode</name></expr></argument>, <argument><expr><name>rangeEndOffset</name></expr></argument>,
                                  <argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// If aContent/aOffset is inside the maintained selection, or if it is on the</comment>
  <comment type="line">// "anchor" side of the maintained selection, we need to do something.</comment>
  <if>if <condition>(<expr><name><name>relToStart</name> <argument_list>&lt; <argument><expr>0 &amp;&amp; <name>relToEnd</name></expr></argument> &gt;</argument_list></name> 0 ||
      (<name>relToStart</name> &gt; 0 &amp;&amp;
       <name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetDirection</name><argument_list>()</argument_list></call> == <name>eDirNext</name>) ||
      (<name>relToEnd</name> &lt; 0 &amp;&amp;
       <name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetDirection</name><argument_list>()</argument_list></call> == <name>eDirPrevious</name>)</expr>)</condition><then> <block>{
    <comment type="line">// Set the current range to the maintained range. </comment>
    <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>ReplaceAnchorFocusRange</name><argument_list>(<argument><expr><name>mMaintainRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>relToStart</name> <argument_list>&lt; <argument><expr>0 &amp;&amp; <name>relToEnd</name></expr></argument> &gt;</argument_list></name> 0</expr>)</condition><then> <block>{
      <comment type="line">// We're inside the maintained selection, just keep it selected.</comment>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
    <comment type="line">// Reverse the direction of the selection so that the anchor will be on the </comment>
    <comment type="line">// far side of the maintained selection, relative to aContent/aOffset.</comment>
    <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>SetDirection</name><argument_list>(<argument><expr><name>relToStart</name> &gt; 0 ? <name>eDirPrevious</name> : <name>eDirNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>HandleClick</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aNewFocus</name></decl></param>,
                              <param><decl><type><name>PRUint32</name></type>    <name>aContentOffset</name></decl></param>,
                              <param><decl><type><name>PRUint32</name></type>    <name>aContentEndOffset</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type>      <name>aContinueSelection</name></decl></param>, 
                              <param><decl><type><name>PRBool</name></type>      <name>aMultipleSelection</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type>      <name>aHint</name></decl></param>)</parameter_list> 
<block>{
  <if>if <condition>(<expr>!<name>aNewFocus</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>InvalidateDesiredX</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>aContinueSelection</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mMaintainRange</name> = <name>nsnull</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>IsValidSelectionPoint</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aNewFocus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mAncestorLimiter</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Don't take focus when dragging off of a table</comment>
  <if>if <condition>(<expr>!<name>mDragSelectingCells</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>BidiLevelFromClick</name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PostReason</name><argument_list>(<argument><expr><name><name>nsISelectionListener</name>::<name>MOUSEDOWN_REASON</name></name> + <name><name>nsISelectionListener</name>::<name>DRAG_REASON</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>aContinueSelection</name> &amp;&amp;
        <call><name>AdjustForMaintainedSelection</name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_OK</name></expr>;</return></then></if> <comment type="line">//shift clicked to maintained selection. rejected.</comment>

    <return>return <expr><call><name>TakeFocus</name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>, <argument><expr><name>aContentEndOffset</name></expr></argument>, <argument><expr><call><name>HINT</name><argument_list>(<argument><expr><name>aHint</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>aContinueSelection</name></expr></argument>, <argument><expr><name>aMultipleSelection</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsFrameSelection</name>::<name>HandleDrag</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><name>nsPoint</name></type> <name>aPoint</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aFrame</name> || !<name>mShell</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>newFrame</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPoint</name></type>   <name>newPoint</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>result</name> = <call><name>ConstrainFrameAndPointToAnchorSubtree</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aPoint</name></expr></argument>, <argument><expr>&amp;<name>newFrame</name></expr></argument>, <argument><expr><name>newPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>
  <if>if <condition>(<expr>!<name>newFrame</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name><name>nsIFrame</name>::<name>ContentOffsets</name></name></type> <name>offsets</name> <init>=
      <expr><call><name><name>newFrame</name>-&gt;<name>GetContentOffsetsFromPoint</name></name><argument_list>(<argument><expr><name>newPoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>offsets</name>.<name>content</name></name></expr>)</condition><then>
    <return>return;</return></then></if>

  <if>if <condition>(<expr>(<call><name><name>newFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_SELECTED_CONTENT</name>) &amp;&amp;
       <call><name>AdjustForMaintainedSelection</name><argument_list>(<argument><expr><name><name>offsets</name>.<name>content</name></name></expr></argument>, <argument><expr><name><name>offsets</name>.<name>offset</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="line">// Adjust offsets according to maintained amount</comment>
  <if>if <condition>(<expr><name>mMaintainRange</name> &amp;&amp; 
      <name>mMaintainedAmount</name> != <name>eSelectNoAmount</name></expr>)</condition><then> <block>{    
    
    <decl_stmt><decl><type><name>nsINode</name>*</type> <name>rangenode</name> <init>= <expr><call><name><name>mMaintainRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>rangeOffset</name> <init>= <expr><call><name><name>mMaintainRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>relativePosition</name> <init>=
      <expr><call><name><name>nsContentUtils</name>::<name>ComparePoints</name></name><argument_list>(<argument><expr><name>rangenode</name></expr></argument>, <argument><expr><name>rangeOffset</name></expr></argument>,
                                    <argument><expr><name><name>offsets</name>.<name>content</name></name></expr></argument>, <argument><expr><name><name>offsets</name>.<name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsDirection</name></type> <name>direction</name> <init>= <expr><name>relativePosition</name> &gt; 0 ? <name>eDirPrevious</name> : <name>eDirNext</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsSelectionAmount</name></type> <name>amount</name> <init>= <expr><name>mMaintainedAmount</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>amount</name> == <name>eSelectBeginLine</name> &amp;&amp; <name>direction</name> == <name>eDirNext</name></expr>)</condition><then>
      <expr_stmt><expr><name>amount</name> = <name>eSelectEndLine</name></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name>GetFrameForNodeOffset</name><argument_list>(<argument><expr><name><name>offsets</name>.<name>content</name></name></expr></argument>, <argument><expr><name><name>offsets</name>.<name>offset</name></name></expr></argument>, <argument><expr><name>HINTRIGHT</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>frame</name> &amp;&amp; <name>amount</name> == <name>eSelectWord</name> &amp;&amp; <name>direction</name> == <name>eDirPrevious</name></expr>)</condition><then> <block>{
      <comment type="line">// To avoid selecting the previous word when at start of word,</comment>
      <comment type="line">// first move one character forward.</comment>
      <decl_stmt><decl><type><name>nsPeekOffsetStruct</name></type> <name>charPos</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>charPos</name>.<name>SetData</name></name><argument_list>(<argument><expr><name>eSelectCharacter</name></expr></argument>, <argument><expr><name>eDirNext</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr>0</expr></argument>,
                      <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>mLimiter</name> != <name>nsnull</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>frame</name>-&gt;<name>PeekOffset</name></name><argument_list>(<argument><expr>&amp;<name>charPos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>frame</name> = <name><name>charPos</name>.<name>mResultFrame</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> = <name><name>charPos</name>.<name>mContentOffset</name></name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsPeekOffsetStruct</name></type> <name>pos</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pos</name>.<name>SetData</name></name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr>0</expr></argument>,
                <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>mLimiter</name> != <name>nsnull</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>frame</name> &amp;&amp; <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>frame</name>-&gt;<name>PeekOffset</name></name><argument_list>(<argument><expr>&amp;<name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; <name><name>pos</name>.<name>mResultContent</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>offsets</name>.<name>content</name></name> = <name><name>pos</name>.<name>mResultContent</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>offsets</name>.<name>offset</name></name> = <name><name>pos</name>.<name>mContentOffset</name></name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  
  <expr_stmt><expr><call><name>HandleClick</name><argument_list>(<argument><expr><name><name>offsets</name>.<name>content</name></name></expr></argument>, <argument><expr><name><name>offsets</name>.<name>offset</name></name></expr></argument>, <argument><expr><name><name>offsets</name>.<name>offset</name></name></expr></argument>,
              <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name><name>offsets</name>.<name>associateWithNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>StartAutoScrollTimer</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>,
                                       <param><decl><type><name>nsPoint</name></type>   <name>aPoint</name></decl></param>,
                                       <param><decl><type><name>PRUint32</name></type>  <name>aDelay</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <return>return <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>StartAutoScrollTimer</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aPoint</name></expr></argument>, <argument><expr><name>aDelay</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsFrameSelection</name>::<name>StopAutoScrollTimer</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return;</return></then></if>

  <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>StopAutoScrollTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block" format="doxygen">/**
hard to go from nodes to frames, easy the other way!
 */</comment>
<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>TakeFocus</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aNewFocus</name></decl></param>,
                            <param><decl><type><name>PRUint32</name></type>    <name>aContentOffset</name></decl></param>,
                            <param><decl><type><name>PRUint32</name></type>    <name>aContentEndOffset</name></decl></param>,
                            <param><decl><type><name>HINT</name></type>        <name>aHint</name></decl></param>,
                            <param><decl><type><name>PRBool</name></type>      <name>aContinueSelection</name></decl></param>,
                            <param><decl><type><name>PRBool</name></type>      <name>aMultipleSelection</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aNewFocus</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>IsValidSelectionPoint</name><argument_list>(<argument><expr><name>this</name></expr></argument>,<argument><expr><name>aNewFocus</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <comment type="line">// Clear all table selection data</comment>
  <expr_stmt><expr><name>mSelectingTableCellMode</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mDragSelectingCells</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mStartSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mEndSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mAppendStartSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>

  <comment type="line">//HACKHACKHACK</comment>
  <if>if <condition>(<expr>!<call><name><name>aNewFocus</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  <comment type="line">//END HACKHACKHACK /checking for root frames/content</comment>

  <expr_stmt><expr><name>mHint</name> = <name>aHint</name></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <comment type="line">//traverse through document and unselect crap here</comment>
  <if>if <condition>(<expr>!<name>aContinueSelection</name></expr>)</condition><then> <block>{<comment type="line">//single click? setting cursor down</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>batching</name> <init>= <expr><name>mBatching</name></expr></init></decl>;</decl_stmt><comment type="line">//hack to use the collapse code.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>changes</name> <init>= <expr><name>mChangesDuringBatching</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mBatching</name> = 1</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>aMultipleSelection</name></expr>)</condition><then> <block>{
      <comment type="line">// Remove existing collapsed ranges as there's no point in having </comment>
      <comment type="line">// non-anchor/focus collapsed ranges.</comment>
      <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>RemoveCollapsedRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>newRange</name> <init>= <expr>new <call><name>nsRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>newRange</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
      }</block></then></if>

      <expr_stmt><expr><call><name><name>newRange</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>newRange</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>AddRange</name><argument_list>(<argument><expr><name>newRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mBatching</name> = <name>batching</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mChangesDuringBatching</name> = <name>changes</name></expr>;</expr_stmt>
    }</block></then>
    <else>else
    <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>oldDesiredXSet</name> <init>= <expr><name>mDesiredXSet</name></expr></init></decl>;</decl_stmt> <comment type="line">//need to keep old desired X if it was set.</comment>
      <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>Collapse</name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mDesiredXSet</name> = <name>oldDesiredXSet</name></expr>;</expr_stmt> <comment type="line">//now reset desired X back.</comment>
      <expr_stmt><expr><name>mBatching</name> = <name>batching</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mChangesDuringBatching</name> = <name>changes</name></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr><name>aContentEndOffset</name> != <name>aContentOffset</name></expr>)</condition><then>
      <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>Extend</name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>, <argument><expr><name>aContentEndOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">//find out if we are inside a table. if so, find out which one and which cell</comment>
    <comment type="line">//once we do that, the next time we get a takefocus, check the parent tree. </comment>
    <comment type="line">//if we are no longer inside same table ,cell then switch to table selection mode.</comment>
    <comment type="line">// BUT only do this in an editor</comment>

    <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRInt16</name></type> <name>displaySelection</name> <init>= <expr><call><name><name>mShell</name>-&gt;<name>GetSelectionFlags</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Editor has DISPLAY_ALL selection type</comment>
    <if>if <condition>(<expr><name>displaySelection</name> == <name><name>nsISelectionDisplay</name>::<name>DISPLAY_ALL</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>mCellParent</name> = <call><name>GetCellParent</name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
      <if>if <condition>(<expr><name>mCellParent</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" * TakeFocus - Collapsing into new cell\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <comment type="line">// Now update the range list:</comment>
    <if>if <condition>(<expr><name>aContinueSelection</name> &amp;&amp; <name>aNewFocus</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>offset</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsINode</name> *</type><name>cellparent</name> <init>= <expr><call><name>GetCellParent</name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>mCellParent</name> &amp;&amp; <name>cellparent</name> &amp;&amp; <name>cellparent</name> != <name>mCellParent</name></expr>)</condition><then> <comment type="line">//switch to cell selection mode</comment>
      <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" * TakeFocus - moving into new cell\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <decl_stmt><decl><type><name>nsMouseEvent</name></type> <name>event</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name><name>nsMouseEvent</name>::<name>eReal</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>

        <comment type="line">// Start selecting in the cell we were in before</comment>
        <decl_stmt><decl><type><name>nsINode</name>*</type> <name>parent</name> <init>= <expr><call><name>ParentOffset</name><argument_list>(<argument><expr><name>mCellParent</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>parent</name></expr>)</condition><then>
          <expr_stmt><expr><call><name>HandleTableSelection</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
                               <argument><expr><name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_CELL</name></name></expr></argument>, <argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// Find the parent of this new cell and extend selection to it</comment>
        <expr_stmt><expr><name>parent</name> = <call><name>ParentOffset</name><argument_list>(<argument><expr><name>cellparent</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// XXXX We need to REALLY get the current key shift state</comment>
        <comment type="line">//  (we'd need to add event listener -- let's not bother for now)</comment>
        <expr_stmt><expr><name><name>event</name>.<name>isShift</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt> <comment type="line">//aContinueSelection;</comment>
        <if>if <condition>(<expr><name>parent</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>mCellParent</name> = <name>cellparent</name></expr>;</expr_stmt>
          <comment type="line">// Continue selection into next cell</comment>
          <expr_stmt><expr><call><name>HandleTableSelection</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
                               <argument><expr><name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_CELL</name></name></expr></argument>, <argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then>
      <else>else
      <block>{
        <comment type="line">// XXXX Problem: Shift+click in browser is appending text selection to selected table!!!</comment>
        <comment type="line">//   is this the place to erase seleced cells ?????</comment>
        <if>if <condition>(<expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetDirection</name><argument_list>()</argument_list></call> == <name>eDirNext</name> &amp;&amp; <name>aContentEndOffset</name> &gt; <name>aContentOffset</name></expr>)</condition><then> <comment type="line">//didn't go far enough </comment>
        <block>{
          <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>Extend</name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>, <argument><expr><name>aContentEndOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="line">//this will only redraw the diff </comment>
        }</block></then>
        <else>else
          <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>Extend</name><argument_list>(<argument><expr><name>aNewFocus</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      }</block></else></if>
    }</block></then></if>
  }</block></else></if>

  <comment type="line">// Don't notify selection listeners if batching is on:</comment>
  <if>if <condition>(<expr><call><name>GetBatching</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  <return>return <expr><call><name>NotifySelectionListeners</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<function><type><name>SelectionDetails</name>*</type>
<name><name>nsFrameSelection</name>::<name>LookUpSelection</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>,
                                  <param><decl><type><name>PRInt32</name></type> <name>aContentOffset</name></decl></param>,
                                  <param><decl><type><name>PRInt32</name></type> <name>aContentLength</name></decl></param>,
                                  <param><decl><type><name>PRBool</name></type> <name>aSlowCheck</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr>!<name>aContent</name> || !<name>mShell</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>SelectionDetails</name>*</type> <name>details</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

  <for>for (<init><decl><type><name>PRInt32</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name><name>nsISelectionController</name>::<name>NUM_SELECTIONTYPES</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
    <if>if <condition>(<expr><name><name>mDomSelections</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>j</name></expr>]</index></name>-&gt;<call><name>LookUpSelection</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>,
          <argument><expr><name>aContentLength</name></expr></argument>, <argument><expr>&amp;<name>details</name></expr></argument>, <argument><expr><call>(<name>SelectionType</name>)<argument_list>(<argument><expr>1&lt;&lt;<name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aSlowCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <return>return <expr><name>details</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsFrameSelection</name>::<name>SetMouseDownState</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aState</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mMouseDownState</name> == <name>aState</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <expr_stmt><expr><name>mMouseDownState</name> = <name>aState</name></expr>;</expr_stmt>
    
  <if>if <condition>(<expr>!<name>mMouseDownState</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>mDragSelectingCells</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PostReason</name><argument_list>(<argument><expr><name><name>nsISelectionListener</name>::<name>MOUSEUP_REASON</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NotifySelectionListeners</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//notify that reason is mouse up please.</comment>
  }</block></then></if>
}</block></function>

<function><type><name>nsISelection</name>*</type>
<name><name>nsFrameSelection</name>::<name>GetSelection</name></name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsISelection</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>ScrollSelectionIntoView</name></name><parameter_list>(<param><decl><type><name>SelectionType</name></type>   <name>aType</name></decl></param>,
                                          <param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>,
                                          <param><decl><type><name>PRBool</name></type>          <name>aIsSynchronous</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>

  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <comment type="line">// After ScrollSelectionIntoView(), the pending notifications might be</comment>
  <comment type="line">// flushed and PresShell/PresContext/Frames may be dead. See bug 418470.</comment>
  <return>return <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>ScrollIntoView</name><argument_list>(<argument><expr><name>aRegion</name></expr></argument>, <argument><expr><name>aIsSynchronous</name></expr></argument>,
                                               <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>RepaintSelection</name></name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>Repaint</name><argument_list>(<argument><expr><call><name><name>mShell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
 
<function><type><name>nsIFrame</name>*</type>
<name><name>nsFrameSelection</name>::<name>GetFrameForNodeOffset</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aNode</name></decl></param>,
                                        <param><decl><type><name>PRInt32</name></type>     <name>aOffset</name></decl></param>,
                                        <param><decl><type><name>HINT</name></type>        <name>aHint</name></decl></param>,
                                        <param><decl><type><name>PRInt32</name>    *</type><name>aReturnOffset</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr>!<name>aNode</name> || !<name>aReturnOffset</name> || !<name>mShell</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>aOffset</name> &lt; 0</expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <expr_stmt><expr>*<name>aReturnOffset</name> = <name>aOffset</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>theNode</name> <init>= <expr><name>aNode</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name><name>aNode</name>-&gt;<name>IsElement</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>childIndex</name>  <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>numChildren</name> <init>= <expr><call><name><name>theNode</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>aHint</name> == <name>HINTLEFT</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>aOffset</name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>childIndex</name> = <name>aOffset</name> - 1</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>childIndex</name> = <name>aOffset</name></expr>;</expr_stmt></else></if>
    }</block></then>
    <else>else <comment type="line">// HINTRIGHT</comment>
    <block>{
      <if>if <condition>(<expr><name>aOffset</name> &gt;= <name>numChildren</name></expr>)</condition><then>
      <block>{
        <if>if <condition>(<expr><name>numChildren</name> &gt; 0</expr>)</condition><then>
          <expr_stmt><expr><name>childIndex</name> = <name>numChildren</name> - 1</expr>;</expr_stmt></then>
        <else>else
          <expr_stmt><expr><name>childIndex</name> = 0</expr>;</expr_stmt></else></if>
      }</block></then>
      <else>else
        <expr_stmt><expr><name>childIndex</name> = <name>aOffset</name></expr>;</expr_stmt></else></if>
    }</block></else></if>
    
    <if>if <condition>(<expr><name>childIndex</name> &gt; 0 || <name>numChildren</name> &gt; 0</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>childNode</name> <init>= <expr><call><name><name>theNode</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>childIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>!<name>childNode</name></expr>)</condition><then>
        <return>return <expr><name>nsnull</name></expr>;</return></then></if>

      <expr_stmt><expr><name>theNode</name> = <name>childNode</name></expr>;</expr_stmt>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DONT_DO_THIS_YET</name></cpp:ifdef>
    <comment type="line">// XXX: We can't use this code yet because the hinting</comment>
    <comment type="line">//      can cause us to attach to the wrong line frame.</comment>

    <comment type="line">// Now that we have the child node, check if it too</comment>
    <comment type="line">// can contain children. If so, call this method again!</comment>

    <if>if <condition>(<expr><call><name><name>theNode</name>-&gt;<name>IsElement</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>newOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>aOffset</name> &gt; <name>childIndex</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>numChildren</name> = <call><name><name>theNode</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>newOffset</name> = <name>numChildren</name></expr>;</expr_stmt>
      }</block></then></if>

      <return>return <expr><call><name>GetFrameForNodeOffset</name><argument_list>(<argument><expr><name>theNode</name></expr></argument>, <argument><expr><name>newOffset</name></expr></argument>, <argument><expr><name>aHint</name></expr></argument>, <argument><expr><name>aReturnOffset</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// DONT_DO_THIS_YET</comment>
    <block>{
      <comment type="line">// Check to see if theNode is a text node. If it is, translate</comment>
      <comment type="line">// aOffset into an offset into the text node.</comment>

      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMText</name></expr></argument>&gt;</argument_list></name></type> <name>textNode</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>theNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>textNode</name></expr>)</condition><then>
      <block>{
        <if>if <condition>(<expr><name>aOffset</name> &gt; <name>childIndex</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>PRUint32</name></type> <name>textLength</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

          <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>textNode</name>-&gt;<name>GetLength</name></name><argument_list>(<argument><expr>&amp;<name>textLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>nsnull</name></expr>;</return></then></if>

          <expr_stmt><expr>*<name>aReturnOffset</name> = (<name>PRInt32</name>)<name>textLength</name></expr>;</expr_stmt>
        }</block></then>
        <else>else
          <expr_stmt><expr>*<name>aReturnOffset</name> = 0</expr>;</expr_stmt></else></if>
      }</block></then></if>
    }</block></else></if>
  }</block></then></if>
  
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>returnFrame</name> <init>= <expr><call><name><name>theNode</name>-&gt;<name>GetPrimaryFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>returnFrame</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <comment type="line">// find the child frame containing the offset we want</comment>
  <expr_stmt><expr><call><name><name>returnFrame</name>-&gt;<name>GetChildFrameContainingOffset</name></name><argument_list>(<argument><expr>*<name>aReturnOffset</name></expr></argument>, <argument><expr><name>aHint</name></expr></argument>,
                                             <argument><expr>&amp;<name>aOffset</name></expr></argument>, <argument><expr>&amp;<name>returnFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>returnFrame</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsFrameSelection</name>::<name>CommonPageMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>,
                                 <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>,
                                 <param><decl><type><name>nsIScrollableFrame</name>*</type> <name>aScrollableFrame</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// expected behavior for PageMove is to scroll AND move the caret</comment>
  <comment type="line">// and remain relative position of the caret in view. see Bug 4302.</comment>

  <comment type="line">//get the frame from the scrollable view</comment>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>scrolledFrame</name> <init>= <expr><call><name><name>aScrollableFrame</name>-&gt;<name>GetScrolledFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>scrolledFrame</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="line">// find out where the caret is.</comment>
  <comment type="line">// we should know mDesiredX value of nsFrameSelection, but I havent seen that behavior in other windows applications yet.</comment>
  <decl_stmt><decl><type><name>nsISelection</name>*</type> <name>domSel</name> <init>= <expr><call><name>GetSelection</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>domSel</name></expr>)</condition><then> 
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCaret</name></expr></argument>&gt;</argument_list></name></type> <name>caret</name> <init>= <expr><call><name><name>mShell</name>-&gt;<name>GetCaret</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsRect</name></type> <name>caretPos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>caretFrame</name> <init>= <expr><call><name><name>caret</name>-&gt;<name>GetGeometry</name></name><argument_list>(<argument><expr><name>domSel</name></expr></argument>, <argument><expr>&amp;<name>caretPos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>caretFrame</name></expr>)</condition><then> 
    <return>return;</return></then></if>
  
  <comment type="line">//need to adjust caret jump by percentage scroll</comment>
  <decl_stmt><decl><type><name>nsSize</name></type> <name>scrollDelta</name> <init>= <expr><call><name><name>aScrollableFrame</name>-&gt;<name>GetPageScrollAmount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>aForward</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>caretPos</name>.<name>y</name></name> += <name><name>scrollDelta</name>.<name>height</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>caretPos</name>.<name>y</name></name> -= <name><name>scrollDelta</name>.<name>height</name></name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>caretPos</name> += <call><name><name>caretFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><name>scrolledFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="line">// get a content at desired location</comment>
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>desiredPoint</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>desiredPoint</name>.<name>x</name></name> = <name><name>caretPos</name>.<name>x</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>desiredPoint</name>.<name>y</name></name> = <name><name>caretPos</name>.<name>y</name></name> + <name><name>caretPos</name>.<name>height</name></name>/2</expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsIFrame</name>::<name>ContentOffsets</name></name></type> <name>offsets</name> <init>=
      <expr><call><name><name>scrolledFrame</name>-&gt;<name>GetContentOffsetsFromPoint</name></name><argument_list>(<argument><expr><name>desiredPoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name><name>offsets</name>.<name>content</name></name></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="line">// scroll one page</comment>
  <expr_stmt><expr><call><name><name>aScrollableFrame</name>-&gt;<name>ScrollBy</name></name><argument_list>(<argument><expr><call><name>nsIntPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>aForward</name> ? 1 : -1</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>nsIScrollableFrame</name>::<name>PAGES</name></name></expr></argument>,
                             <argument><expr><name><name>nsIScrollableFrame</name>::<name>SMOOTH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// place the caret</comment>
  <expr_stmt><expr><call><name>HandleClick</name><argument_list>(<argument><expr><name><name>offsets</name>.<name>content</name></name></expr></argument>, <argument><expr><name><name>offsets</name>.<name>offset</name></name></expr></argument>,
              <argument><expr><name><name>offsets</name>.<name>offset</name></name></expr></argument>, <argument><expr><name>aExtend</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>CharacterMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aForward</name></expr>)</condition><then>
    <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_RIGHT</name></name></expr></argument>,<argument><expr><name>aExtend</name></expr></argument>,<argument><expr><name>eSelectCharacter</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_LEFT</name></name></expr></argument>,<argument><expr><name>aExtend</name></expr></argument>,<argument><expr><name>eSelectCharacter</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>CharacterExtendForDelete</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_DELETE</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>eSelectCharacter</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>CharacterExtendForBackspace</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_BACK_SPACE</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>eSelectCharacter</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>WordMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aForward</name></expr>)</condition><then>
    <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_RIGHT</name></name></expr></argument>,<argument><expr><name>aExtend</name></expr></argument>,<argument><expr><name>eSelectWord</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_LEFT</name></name></expr></argument>,<argument><expr><name>aExtend</name></expr></argument>,<argument><expr><name>eSelectWord</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>WordExtendForDelete</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aForward</name></expr>)</condition><then>
    <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_DELETE</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>eSelectWord</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_BACK_SPACE</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>eSelectWord</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>LineMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aForward</name></expr>)</condition><then>
    <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_DOWN</name></name></expr></argument>,<argument><expr><name>aExtend</name></expr></argument>,<argument><expr><name>eSelectLine</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_UP</name></name></expr></argument>,<argument><expr><name>aExtend</name></expr></argument>,<argument><expr><name>eSelectLine</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>IntraLineMove</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForward</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aExtend</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aForward</name></expr>)</condition><then>
    <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_END</name></name></expr></argument>,<argument><expr><name>aExtend</name></expr></argument>,<argument><expr><name>eSelectLine</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>MoveCaret</name><argument_list>(<argument><expr><name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_HOME</name></name></expr></argument>,<argument><expr><name>aExtend</name></expr></argument>,<argument><expr><name>eSelectLine</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>SelectAll</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>rootContent</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mLimiter</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>rootContent</name> = <name>mLimiter</name></expr>;</expr_stmt><comment type="line">//addrefit</comment>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>mAncestorLimiter</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rootContent</name> = <name>mAncestorLimiter</name></expr>;</expr_stmt>
  }</block></then>
  <else>else
  <block>{
    <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsIDocument</name> *</type><name>doc</name> <init>= <expr><call><name><name>mShell</name>-&gt;<name>GetDocument</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>doc</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>rootContent</name> = <call><name><name>doc</name>-&gt;<name>GetRootElement</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>rootContent</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  }</block></else></if></else></if>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numChildren</name> <init>= <expr><call><name><name>rootContent</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PostReason</name><argument_list>(<argument><expr><name><name>nsISelectionListener</name>::<name>NO_REASON</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>TakeFocus</name><argument_list>(<argument><expr><name>rootContent</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>numChildren</name></expr></argument>, <argument><expr><name>HINTLEFT</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line" format="doxygen">//////////END FRAMESELECTION</comment>

<function><type><name>void</name></type>
<name><name>nsFrameSelection</name>::<name>StartBatchChanges</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mBatching</name>++</expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsFrameSelection</name>::<name>EndBatchChanges</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mBatching</name>--</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mBatching</name> &gt;=0</expr></argument>,<argument><expr>"Bad mBatching"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mBatching</name> == 0 &amp;&amp; <name>mChangesDuringBatching</name></expr>)</condition><then><block>{
    <expr_stmt><expr><name>mChangesDuringBatching</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NotifySelectionListeners</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>NotifySelectionListeners</name></name><parameter_list>(<param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>index</name> &gt;=0 &amp;&amp; <name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
  <block>{
    <return>return <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>NotifySelectionListeners</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
}</block></function>

<comment type="line">// Start of Table Selection methods</comment>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>IsCell</name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>((<call><name><name>aContent</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>td</name></name> ||
           <call><name><name>aContent</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>th</name></name>) &amp;&amp;
          <call><name><name>aContent</name>-&gt;<name>IsHTML</name></name><argument_list>()</argument_list></call>)</expr>;</return>
}</block></function>

<function><type><name>nsITableCellLayout</name>*</type> 
<name><name>nsFrameSelection</name>::<name>GetCellLayout</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aCellContent</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsITableCellLayout</name> *</type><name>cellLayoutObject</name> <init>=
    <expr><call><name>do_QueryFrame</name><argument_list>(<argument><expr><call><name><name>aCellContent</name>-&gt;<name>GetPrimaryFrame</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>cellLayoutObject</name></expr>;</return>
}</block></function>

<function><type><name>nsITableLayout</name>*</type> 
<name><name>nsFrameSelection</name>::<name>GetTableLayout</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aTableContent</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mShell</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsITableLayout</name> *</type><name>tableLayoutObject</name> <init>=
    <expr><call><name>do_QueryFrame</name><argument_list>(<argument><expr><call><name><name>aTableContent</name>-&gt;<name>GetPrimaryFrame</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>tableLayoutObject</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>ClearNormalSelection</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <return>return <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>RemoveAllRanges</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsIContent</name>*</type>
<name>GetFirstSelectedContent</name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aRange</name></expr>)</condition><then> <block>{
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Must have start parent!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call>-&gt;<call><name>IsElement</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"Unexpected parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetChildAt</name><argument_list>(<argument><expr><call><name><name>aRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Table selection support.</comment>
<comment type="line">// TODO: Separate table methods into a separate nsITableSelection interface</comment>
<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>HandleTableSelection</name></name><parameter_list>(<param><decl><type><name>nsINode</name> *</type><name>aParentContent</name></decl></param>,
                                       <param><decl><type><name>PRInt32</name></type> <name>aContentOffset</name></decl></param>,
                                       <param><decl><type><name>PRInt32</name></type> <name>aTarget</name></decl></param>,
                                       <param><decl><type><name>nsMouseEvent</name> *</type><name>aMouseEvent</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aParentContent</name></expr></argument>, <argument><expr><name>NS_ERROR_NULL_POINTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aMouseEvent</name></expr></argument>, <argument><expr><name>NS_ERROR_NULL_POINTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mMouseDownState</name> &amp;&amp; <name>mDragSelectingCells</name> &amp;&amp; (<name>aTarget</name> &amp; <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_TABLE</name></name>)</expr>)</condition><then>
  <block>{
    <comment type="line">// We were selecting cells and user drags mouse in table border or inbetween cells,</comment>
    <comment type="line">//  just do nothing</comment>
      <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIContent</name> *</type><name>childContent</name> <init>= <expr><call><name><name>aParentContent</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>aContentOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// When doing table selection, always set the direction to next so</comment>
  <comment type="line">// we can be sure that anchorNode's offset always points to the</comment>
  <comment type="line">// selected cell</comment>
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>SetDirection</name><argument_list>(<argument><expr><name>eDirNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Stack-class to wrap all table selection changes in </comment>
  <comment type="line">//  BeginBatchChanges() / EndBatchChanges()</comment>
  <function_decl><type><name>nsSelectionBatcher</name></type> <name>selectionBatcher</name><parameter_list>(<param><decl><type><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></type></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startRowIndex</name></decl>, <decl><type ref="prev"/><name>startColIndex</name></decl>, <decl><type ref="prev"/><name>curRowIndex</name></decl>, <decl><type ref="prev"/><name>curColIndex</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mMouseDownState</name> &amp;&amp; <name>mDragSelectingCells</name></expr>)</condition><then>
  <block>{
    <comment type="line">// We are drag-selecting</comment>
    <if>if <condition>(<expr><name>aTarget</name> != <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_TABLE</name></name></expr>)</condition><then>
    <block>{
      <comment type="line">// If dragging in the same cell as last event, do nothing</comment>
      <if>if <condition>(<expr><name>mEndSelectedCell</name> == <name>childContent</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" mStartSelectedCell = %x, mEndSelectedCell = %x, childContent = %x \n"</expr></argument>, <argument><expr><name>mStartSelectedCell</name></expr></argument>, <argument><expr><name>mEndSelectedCell</name></expr></argument>, <argument><expr><name>childContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="line">// aTarget can be any "cell mode",</comment>
      <comment type="line">//  so we can easily drag-select rows and columns </comment>
      <comment type="line">// Once we are in row or column mode,</comment>
      <comment type="line">//  we can drift into any cell to stay in that mode</comment>
      <comment type="line">//  even if aTarget = TABLESELECTION_CELL</comment>

      <if>if <condition>(<expr><name>mSelectingTableCellMode</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_ROW</name></name> ||
          <name>mSelectingTableCellMode</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_COLUMN</name></name></expr>)</condition><then>
      <block>{
        <if>if <condition>(<expr><name>mEndSelectedCell</name></expr>)</condition><then>
        <block>{
          <comment type="line">// Also check if cell is in same row/col</comment>
          <expr_stmt><expr><name>result</name> = <call><name>GetCellIndexes</name><argument_list>(<argument><expr><name>mEndSelectedCell</name></expr></argument>, <argument><expr><name>startRowIndex</name></expr></argument>, <argument><expr><name>startColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
          <expr_stmt><expr><name>result</name> = <call><name>GetCellIndexes</name><argument_list>(<argument><expr><name>childContent</name></expr></argument>, <argument><expr><name>curRowIndex</name></expr></argument>, <argument><expr><name>curColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" curRowIndex = %d, startRowIndex = %d, curColIndex = %d, startColIndex = %d\n"</expr></argument>, <argument><expr><name>curRowIndex</name></expr></argument>, <argument><expr><name>startRowIndex</name></expr></argument>, <argument><expr><name>curColIndex</name></expr></argument>, <argument><expr><name>startColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <if>if <condition>(<expr>(<name>mSelectingTableCellMode</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_ROW</name></name> &amp;&amp; <name>startRowIndex</name> == <name>curRowIndex</name>) ||
              (<name>mSelectingTableCellMode</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_COLUMN</name></name> &amp;&amp; <name>startColIndex</name> == <name>curColIndex</name>)</expr>)</condition><then> 
            <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
        }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" Dragged into a new column or row\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="line">// Continue dragging row or column selection</comment>
        <return>return <expr><call><name>SelectRowOrColumn</name><argument_list>(<argument><expr><name>childContent</name></expr></argument>, <argument><expr><name>mSelectingTableCellMode</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block></then>
      <else>else <if>if <condition>(<expr><name>mSelectingTableCellMode</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_CELL</name></name></expr>)</condition><then>
      <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"HandleTableSelection: Dragged into a new cell\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="line">// Trick for quick selection of rows and columns</comment>
        <comment type="line">// Hold down shift, then start selecting in one direction</comment>
        <comment type="line">// If next cell dragged into is in same row, select entire row,</comment>
        <comment type="line">//   if next cell is in same column, select entire column</comment>
        <if>if <condition>(<expr><name>mStartSelectedCell</name> &amp;&amp; <name><name>aMouseEvent</name>-&gt;<name>isShift</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>result</name> = <call><name>GetCellIndexes</name><argument_list>(<argument><expr><name>mStartSelectedCell</name></expr></argument>, <argument><expr><name>startRowIndex</name></expr></argument>, <argument><expr><name>startColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
          <expr_stmt><expr><name>result</name> = <call><name>GetCellIndexes</name><argument_list>(<argument><expr><name>childContent</name></expr></argument>, <argument><expr><name>curRowIndex</name></expr></argument>, <argument><expr><name>curColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
          
          <if>if <condition>(<expr><name>startRowIndex</name> == <name>curRowIndex</name> || 
              <name>startColIndex</name> == <name>curColIndex</name></expr>)</condition><then>
          <block>{
            <comment type="line">// Force new selection block</comment>
            <expr_stmt><expr><name>mStartSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>RemoveAllRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>startRowIndex</name> == <name>curRowIndex</name></expr>)</condition><then>
              <expr_stmt><expr><name>mSelectingTableCellMode</name> = <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_ROW</name></name></expr>;</expr_stmt></then>
            <else>else
              <expr_stmt><expr><name>mSelectingTableCellMode</name> = <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_COLUMN</name></name></expr>;</expr_stmt></else></if>

            <return>return <expr><call><name>SelectRowOrColumn</name><argument_list>(<argument><expr><name>childContent</name></expr></argument>, <argument><expr><name>mSelectingTableCellMode</name></expr></argument>)</argument_list></call></expr>;</return>
          }</block></then></if>
        }</block></then></if>
        
        <comment type="line">// Reselect block of cells to new end location</comment>
        <return>return <expr><call><name>SelectBlockOfCells</name><argument_list>(<argument><expr><name>mStartSelectedCell</name></expr></argument>, <argument><expr><name>childContent</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block></then></if></else></if>
    }</block></then></if>
    <comment type="line">// Do nothing if dragging in table, but outside a cell</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then>
  <else>else 
  <block>{
    <comment type="line">// Not dragging  -- mouse event is down or up</comment>
    <if>if <condition>(<expr><name>mMouseDownState</name></expr>)</condition><then>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"HandleTableSelection: Mouse down event\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="line">// Clear cell we stored in mouse-down</comment>
      <expr_stmt><expr><name>mUnselectCellOnMouseUp</name> = <name>nsnull</name></expr>;</expr_stmt>
      
      <if>if <condition>(<expr><name>aTarget</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_CELL</name></name></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>isSelected</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Check if we have other selected cells</comment>
        <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>previousCellNode</name> <init>=
          <expr><call><name>GetFirstSelectedContent</name><argument_list>(<argument><expr><call><name>GetFirstCellRange</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>previousCellNode</name></expr>)</condition><then>
        <block>{
          <comment type="line">// We have at least 1 other selected cell</comment>

          <comment type="line">// Check if new cell is already selected</comment>
          <decl_stmt><decl><type><name>nsIFrame</name>  *</type><name>cellFrame</name> <init>= <expr><call><name><name>childContent</name>-&gt;<name>GetPrimaryFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>!<name>cellFrame</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
          <expr_stmt><expr><name>result</name> = <call><name><name>cellFrame</name>-&gt;<name>GetSelected</name></name><argument_list>(<argument><expr>&amp;<name>isSelected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
        }</block></then>
        <else>else
        <block>{
          <comment type="line">// No cells selected -- remove non-cell selection</comment>
          <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>RemoveAllRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>mDragSelectingCells</name> = <name>PR_TRUE</name></expr>;</expr_stmt>    <comment type="line">// Signal to start drag-cell-selection</comment>
        <expr_stmt><expr><name>mSelectingTableCellMode</name> = <name>aTarget</name></expr>;</expr_stmt>
        <comment type="line">// Set start for new drag-selection block (not appended)</comment>
        <expr_stmt><expr><name>mStartSelectedCell</name> = <name>childContent</name></expr>;</expr_stmt>
        <comment type="line">// The initial block end is same as the start</comment>
        <expr_stmt><expr><name>mEndSelectedCell</name> = <name>childContent</name></expr>;</expr_stmt>
        
        <if>if <condition>(<expr><name>isSelected</name></expr>)</condition><then>
        <block>{
          <comment type="line">// Remember this cell to (possibly) unselect it on mouseup</comment>
          <expr_stmt><expr><name>mUnselectCellOnMouseUp</name> = <name>childContent</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"HandleTableSelection: Saving mUnselectCellOnMouseUp\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then>
        <else>else
        <block>{
          <comment type="line">// Select an unselected cell</comment>
          <comment type="line">// but first remove existing selection if not in same table</comment>
          <if>if <condition>(<expr><name>previousCellNode</name> &amp;&amp;
              !<call><name>IsInSameTable</name><argument_list>(<argument><expr><name>previousCellNode</name></expr></argument>, <argument><expr><name>childContent</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <block>{
            <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>RemoveAllRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Reset selection mode that is cleared in RemoveAllRanges</comment>
            <expr_stmt><expr><name>mSelectingTableCellMode</name> = <name>aTarget</name></expr>;</expr_stmt>
          }</block></then></if>

          <return>return <expr><call><name>SelectCellElement</name><argument_list>(<argument><expr><name>childContent</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>

        <return>return <expr><name>NS_OK</name></expr>;</return>
      }</block></then>
      <else>else <if>if <condition>(<expr><name>aTarget</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_TABLE</name></name></expr>)</condition><then>
      <block>{
        <comment type="line">//TODO: We currently select entire table when clicked between cells,</comment>
        <comment type="line">//  should we restrict to only around border?</comment>
        <comment type="line">//  *** How do we get location data for cell and click?</comment>
        <expr_stmt><expr><name>mDragSelectingCells</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mStartSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mEndSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>

        <comment type="line">// Remove existing selection and select the table</comment>
        <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>RemoveAllRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>CreateAndAddRange</name><argument_list>(<argument><expr><name>aParentContent</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block></then>
      <else>else <if>if <condition>(<expr><name>aTarget</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_ROW</name></name> || <name>aTarget</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_COLUMN</name></name></expr>)</condition><then>
      <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"aTarget == %d\n"</expr></argument>, <argument><expr><name>aTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="line">// Start drag-selecting mode so multiple rows/cols can be selected</comment>
        <comment type="line">// Note: Currently, nsFrame::GetDataForTableSelection</comment>
        <comment type="line">//       will never call us for row or column selection on mouse down</comment>
        <expr_stmt><expr><name>mDragSelectingCells</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      
        <comment type="line">// Force new selection block</comment>
        <expr_stmt><expr><name>mStartSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>RemoveAllRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Always do this AFTER RemoveAllRanges</comment>
        <expr_stmt><expr><name>mSelectingTableCellMode</name> = <name>aTarget</name></expr>;</expr_stmt>
        <return>return <expr><call><name>SelectRowOrColumn</name><argument_list>(<argument><expr><name>childContent</name></expr></argument>, <argument><expr><name>aTarget</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block></then></if></else></if></else></if>
    }</block></then>
    <else>else
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"HandleTableSelection: Mouse UP event. mDragSelectingCells=%d, mStartSelectedCell=%d\n"</expr></argument>, <argument><expr><name>mDragSelectingCells</name></expr></argument>, <argument><expr><name>mStartSelectedCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="line">// First check if we are extending a block selection</comment>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>rangeCount</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>result</name> = <name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetRangeCount</name><argument_list>(<argument><expr>&amp;<name>rangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
        <return>return <expr><name>result</name></expr>;</return></then></if>

      <if>if <condition>(<expr><name>rangeCount</name> &gt; 0 &amp;&amp; <name><name>aMouseEvent</name>-&gt;<name>isShift</name></name> &amp;&amp; 
          <name>mAppendStartSelectedCell</name> &amp;&amp; <name>mAppendStartSelectedCell</name> != <name>childContent</name></expr>)</condition><then>
      <block>{
        <comment type="line">// Shift key is down: append a block selection</comment>
        <expr_stmt><expr><name>mDragSelectingCells</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        <return>return <expr><call><name>SelectBlockOfCells</name><argument_list>(<argument><expr><name>mAppendStartSelectedCell</name></expr></argument>, <argument><expr><name>childContent</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block></then></if>

      <if>if <condition>(<expr><name>mDragSelectingCells</name></expr>)</condition><then>
        <expr_stmt><expr><name>mAppendStartSelectedCell</name> = <name>mStartSelectedCell</name></expr>;</expr_stmt></then></if>
        
      <expr_stmt><expr><name>mDragSelectingCells</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mStartSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mEndSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>

      <comment type="line">// Any other mouseup actions require that Ctrl or Cmd key is pressed</comment>
      <comment type="line">//  else stop table selection mode</comment>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>doMouseUpAction</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_MACOSX</name></cpp:ifdef>
      <expr_stmt><expr><name>doMouseUpAction</name> = <name><name>aMouseEvent</name>-&gt;<name>isMeta</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>doMouseUpAction</name> = <name><name>aMouseEvent</name>-&gt;<name>isControl</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if <condition>(<expr>!<name>doMouseUpAction</name></expr>)</condition><then>
      <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"HandleTableSelection: Ending cell selection on mouseup: mAppendStartSelectedCell=%d\n"</expr></argument>, <argument><expr><name>mAppendStartSelectedCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>NS_OK</name></expr>;</return>
      }</block></then></if>
      <comment type="line">// Unselect a cell only if it wasn't</comment>
      <comment type="line">//  just selected on mousedown</comment>
      <if>if<condition>( <expr><name>childContent</name> == <name>mUnselectCellOnMouseUp</name></expr>)</condition><then>
      <block>{
        <comment type="line">// Scan ranges to find the cell to unselect (the selection range to remove)</comment>
        <comment type="line">// XXXbz it's really weird that this lives outside the loop, so once we</comment>
        <comment type="line">// find one we keep looking at it even if we find no more cells...</comment>
        <decl_stmt><decl><type><name>nsINode</name>*</type> <name>previousCellParent</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"HandleTableSelection: Unselecting mUnselectCellOnMouseUp; rangeCount=%d\n"</expr></argument>, <argument><expr><name>rangeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <for>for( <init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>rangeCount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <comment type="line">// Strong reference, because sometimes we want to remove</comment>
          <comment type="line">// this range, and then we might be the only owner.</comment>
          <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetRangeAt</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>!<name>range</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

          <decl_stmt><decl><type><name>nsINode</name>*</type> <name>parent</name> <init>= <expr><call><name><name>range</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>!<name>parent</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

          <decl_stmt><decl><type><name>PRInt32</name></type> <name>offset</name> <init>= <expr><call><name><name>range</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <comment type="line">// Be sure previous selection is a table cell</comment>
          <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>child</name> <init>= <expr><call><name><name>parent</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>child</name> &amp;&amp; <call><name>IsCell</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>previousCellParent</name> = <name>parent</name></expr>;</expr_stmt></then></if>

          <comment type="line">// We're done if we didn't find parent of a previously-selected cell</comment>
          <if>if <condition>(<expr>!<name>previousCellParent</name></expr>)</condition><then> <break>break;</break></then></if>
        
          <if>if <condition>(<expr><name>previousCellParent</name> == <name>aParentContent</name> &amp;&amp; <name>offset</name> == <name>aContentOffset</name></expr>)</condition><then>
          <block>{
            <comment type="line">// Cell is already selected</comment>
            <if>if <condition>(<expr><name>rangeCount</name> == 1</expr>)</condition><then>
            <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"HandleTableSelection: Unselecting single selected cell\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <comment type="line">// This was the only cell selected.</comment>
              <comment type="line">// Collapse to "normal" selection inside the cell</comment>
              <expr_stmt><expr><name>mStartSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>mEndSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>mAppendStartSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt>
              <comment type="line">//TODO: We need a "Collapse to just before deepest child" routine</comment>
              <comment type="line">// Even better, should we collapse to just after the LAST deepest child</comment>
              <comment type="line">//  (i.e., at the end of the cell's contents)?</comment>
              <return>return <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>Collapse</name><argument_list>(<argument><expr><name>childContent</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"HandleTableSelection: Removing cell from multi-cell selection\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="line">// Unselecting the start of previous block </comment>
            <comment type="line">// XXX What do we use now!</comment>
            <if>if <condition>(<expr><name>childContent</name> == <name>mAppendStartSelectedCell</name></expr>)</condition><then>
               <expr_stmt><expr><name>mAppendStartSelectedCell</name> = <name>nsnull</name></expr>;</expr_stmt></then></if>

            <comment type="line">// Deselect cell by removing its range from selection</comment>
            <return>return <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>RemoveRange</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</return>
          }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name>mUnselectCellOnMouseUp</name> = <name>nsnull</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
  }</block></else></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>SelectBlockOfCells</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aStartCell</name></decl></param>, <param><decl><type><name>nsIContent</name> *</type><name>aEndCell</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aStartCell</name></expr></argument>, <argument><expr><name>NS_ERROR_NULL_POINTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aEndCell</name></expr></argument>, <argument><expr><name>NS_ERROR_NULL_POINTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mEndSelectedCell</name> = <name>aEndCell</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>startCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// If new end cell is in a different table, do nothing</comment>
  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>table</name> <init>= <expr><call><name>IsInSameTable</name><argument_list>(<argument><expr><name>aStartCell</name></expr></argument>, <argument><expr><name>aEndCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>table</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Get starting and ending cells' location in the cellmap</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startRowIndex</name></decl>, <decl><type ref="prev"/><name>startColIndex</name></decl>, <decl><type ref="prev"/><name>endRowIndex</name></decl>, <decl><type ref="prev"/><name>endColIndex</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>result</name> = <call><name>GetCellIndexes</name><argument_list>(<argument><expr><name>aStartCell</name></expr></argument>, <argument><expr><name>startRowIndex</name></expr></argument>, <argument><expr><name>startColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
  <expr_stmt><expr><name>result</name> = <call><name>GetCellIndexes</name><argument_list>(<argument><expr><name>aEndCell</name></expr></argument>, <argument><expr><name>endRowIndex</name></expr></argument>, <argument><expr><name>endColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>mDragSelectingCells</name></expr>)</condition><then>
  <block>{
    <comment type="line">// Drag selecting: remove selected cells outside of new block limits</comment>
    <expr_stmt><expr><call><name>UnselectCells</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>startRowIndex</name></expr></argument>, <argument><expr><name>startColIndex</name></expr></argument>, <argument><expr><name>endRowIndex</name></expr></argument>, <argument><expr><name>endColIndex</name></expr></argument>,
                  <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Note that we select block in the direction of user's mouse dragging,</comment>
  <comment type="line">//  which means start cell may be after the end cell in either row or column</comment>
  <return>return <expr><call><name>AddCellsToSelection</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>startRowIndex</name></expr></argument>, <argument><expr><name>startColIndex</name></expr></argument>,
                             <argument><expr><name>endRowIndex</name></expr></argument>, <argument><expr><name>endColIndex</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>UnselectCells</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aTableContent</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aStartRowIndex</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aStartColumnIndex</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aEndRowIndex</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aEndColumnIndex</name></decl></param>,
                                <param><decl><type><name>PRBool</name></type> <name>aRemoveOutsideOfCellRange</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>=
    <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsITableLayout</name> *</type><name>tableLayout</name> <init>= <expr><call><name>GetTableLayout</name><argument_list>(<argument><expr><name>aTableContent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>tableLayout</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>minRowIndex</name> <init>= <expr><call><name>NS_MIN</name><argument_list>(<argument><expr><name>aStartRowIndex</name></expr></argument>, <argument><expr><name>aEndRowIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>maxRowIndex</name> <init>= <expr><call><name>NS_MAX</name><argument_list>(<argument><expr><name>aStartRowIndex</name></expr></argument>, <argument><expr><name>aEndRowIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>minColIndex</name> <init>= <expr><call><name>NS_MIN</name><argument_list>(<argument><expr><name>aStartColumnIndex</name></expr></argument>, <argument><expr><name>aEndColumnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>maxColIndex</name> <init>= <expr><call><name>NS_MAX</name><argument_list>(<argument><expr><name>aStartColumnIndex</name></expr></argument>, <argument><expr><name>aEndColumnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Strong reference because we sometimes remove the range</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name>GetFirstCellRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>cellNode</name> <init>= <expr><call><name>GetFirstSelectedContent</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>range</name> || <name>cellNode</name></expr></argument>, <argument><expr>"Must have cellNode if had a range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>curRowIndex</name></decl>, <decl><type ref="prev"/><name>curColIndex</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>cellNode</name></expr>)</condition>
  <block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name>GetCellIndexes</name><argument_list>(<argument><expr><name>cellNode</name></expr></argument>, <argument><expr><name>curRowIndex</name></expr></argument>, <argument><expr><name>curColIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>result</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_SELECTION</name></cpp:ifdef>
    <if>if <condition>(<expr>!<name>range</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"RemoveCellsToSelection -- range is null\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>range</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>aRemoveOutsideOfCellRange</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>curRowIndex</name> <argument_list>&lt; <argument><expr><name>minRowIndex</name> || <name>curRowIndex</name></expr></argument> &gt;</argument_list></name> <name>maxRowIndex</name> || 
            <name><name>curColIndex</name> <argument_list>&lt; <argument><expr><name>minColIndex</name> || <name>curColIndex</name></expr></argument> &gt;</argument_list></name> <name>maxColIndex</name></expr>)</condition><then> <block>{

          <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>RemoveRange</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// Since we've removed the range, decrement pointer to next range</comment>
          <expr_stmt><expr><name>mSelectedCellIndex</name>--</expr>;</expr_stmt>
        }</block></then></if>

      }</block></then> <else>else <block>{
        <comment type="line">// Remove cell from selection if it belongs to the given cells range or</comment>
        <comment type="line">// it is spanned onto the cells range.</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMElement</name></expr></argument>&gt;</argument_list></name></type> <name>cellElement</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>origRowIndex</name></decl>, <decl><type ref="prev"/><name>origColIndex</name></decl>, <decl><type ref="prev"/><name>rowSpan</name></decl>, <decl><type ref="prev"/><name>colSpan</name></decl>,
          <decl><type ref="prev"/><name>actualRowSpan</name></decl>, <decl><type ref="prev"/><name>actualColSpan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>isSelected</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> = <call><name><name>tableLayout</name>-&gt;<name>GetCellDataAt</name></name><argument_list>(<argument><expr><name>curRowIndex</name></expr></argument>, <argument><expr><name>curColIndex</name></expr></argument>,
                                            <argument><expr>*<call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>cellElement</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>origRowIndex</name></expr></argument>, <argument><expr><name>origColIndex</name></expr></argument>,
                                            <argument><expr><name>rowSpan</name></expr></argument>, <argument><expr><name>colSpan</name></expr></argument>, 
                                            <argument><expr><name>actualRowSpan</name></expr></argument>, <argument><expr><name>actualColSpan</name></expr></argument>,
                                            <argument><expr><name>isSelected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <return>return <expr><name>result</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name>origRowIndex</name> &lt;= <name>maxRowIndex</name> &amp;&amp;
            <name>origRowIndex</name> + <name>actualRowSpan</name> - 1 &gt;= <name>minRowIndex</name> &amp;&amp;
            <name>origColIndex</name> &lt;= <name>maxColIndex</name> &amp;&amp;
            <name>origColIndex</name> + <name>actualColSpan</name> - 1 &gt;= <name>minColIndex</name></expr>)</condition><then> <block>{

          <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>RemoveRange</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// Since we've removed the range, decrement pointer to next range</comment>
          <expr_stmt><expr><name>mSelectedCellIndex</name>--</expr>;</expr_stmt>
        }</block></then></if>
      }</block></else></if>
    }</block></then></if>

    <expr_stmt><expr><name>range</name> = <call><name>GetNextCellRange</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cellNode</name> = <call><name>GetFirstSelectedContent</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>range</name> || <name>cellNode</name></expr></argument>, <argument><expr>"Must have cellNode if had a range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>AddCellsToSelection</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aTableContent</name></decl></param>,
                                      <param><decl><type><name>PRInt32</name></type> <name>aStartRowIndex</name></decl></param>,
                                      <param><decl><type><name>PRInt32</name></type> <name>aStartColumnIndex</name></decl></param>,
                                      <param><decl><type><name>PRInt32</name></type> <name>aEndRowIndex</name></decl></param>,
                                      <param><decl><type><name>PRInt32</name></type> <name>aEndColumnIndex</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <comment type="line">// Get TableLayout interface to access cell data based on cellmap location</comment>
  <comment type="line">// frames are not ref counted, so don't use an nsCOMPtr</comment>
  <decl_stmt><decl><type><name>nsITableLayout</name> *</type><name>tableLayoutObject</name> <init>= <expr><call><name>GetTableLayout</name><argument_list>(<argument><expr><name>aTableContent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>tableLayoutObject</name></expr>)</condition><then> <comment type="line">// Check that |table| is a table.</comment>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMElement</name></expr></argument>&gt;</argument_list></name></type> <name>cellElement</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowSpan</name></decl>, <decl><type ref="prev"/><name>colSpan</name></decl>, <decl><type ref="prev"/><name>actualRowSpan</name></decl>, <decl><type ref="prev"/><name>actualColSpan</name></decl>,
    <decl><type ref="prev"/><name>curRowIndex</name></decl>, <decl><type ref="prev"/><name>curColIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isSelected</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>row</name> <init>= <expr><name>aStartRowIndex</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>(<expr><name>PR_TRUE</name></expr>)</condition>
  <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>col</name> <init>= <expr><name>aStartColumnIndex</name></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>PR_TRUE</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><name>result</name> = <call><name><name>tableLayoutObject</name>-&gt;<name>GetCellDataAt</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr>*<call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>cellElement</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><name>curRowIndex</name></expr></argument>, <argument><expr><name>curColIndex</name></expr></argument>, <argument><expr><name>rowSpan</name></expr></argument>, <argument><expr><name>colSpan</name></expr></argument>, 
                                                <argument><expr><name>actualRowSpan</name></expr></argument>, <argument><expr><name>actualColSpan</name></expr></argument>, <argument><expr><name>isSelected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>

      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>actualColSpan</name></expr></argument>, <argument><expr>"!actualColSpan is 0!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// Skip cells that are spanned from previous locations or are already selected</comment>
      <if>if <condition>(<expr>!<name>isSelected</name> &amp;&amp; <name>cellElement</name> &amp;&amp; <name>row</name> == <name>curRowIndex</name> &amp;&amp; <name>col</name> == <name>curColIndex</name></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>cellContent</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>cellElement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>result</name> = <call><name>SelectCellElement</name><argument_list>(<argument><expr><name>cellContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
      }</block></then></if>
      <comment type="line">// Done when we reach end column</comment>
      <if>if <condition>(<expr><name>col</name> == <name>aEndColumnIndex</name></expr>)</condition><then> <break>break;</break></then></if>

      <if>if <condition>(<expr><name>aStartColumnIndex</name> &lt; <name>aEndColumnIndex</name></expr>)</condition><then>
        <expr_stmt><expr><name>col</name> ++</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>col</name>--</expr>;</expr_stmt></else></if>
    }</block></while><empty_stmt>;</empty_stmt>
    <if>if <condition>(<expr><name>row</name> == <name>aEndRowIndex</name></expr>)</condition><then> <break>break;</break></then></if>

    <if>if <condition>(<expr><name>aStartRowIndex</name> &lt; <name>aEndRowIndex</name></expr>)</condition><then>
      <expr_stmt><expr><name>row</name>++</expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><name>row</name>--</expr>;</expr_stmt></else></if>
  }</block></while><empty_stmt>;</empty_stmt>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>RemoveCellsFromSelection</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aTable</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name></type> <name>aStartRowIndex</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name></type> <name>aStartColumnIndex</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name></type> <name>aEndRowIndex</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name></type> <name>aEndColumnIndex</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>UnselectCells</name><argument_list>(<argument><expr><name>aTable</name></expr></argument>, <argument><expr><name>aStartRowIndex</name></expr></argument>, <argument><expr><name>aStartColumnIndex</name></expr></argument>,
                       <argument><expr><name>aEndRowIndex</name></expr></argument>, <argument><expr><name>aEndColumnIndex</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>RestrictCellsToSelection</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aTable</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name></type> <name>aStartRowIndex</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name></type> <name>aStartColumnIndex</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name></type> <name>aEndRowIndex</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name></type> <name>aEndColumnIndex</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>UnselectCells</name><argument_list>(<argument><expr><name>aTable</name></expr></argument>, <argument><expr><name>aStartRowIndex</name></expr></argument>, <argument><expr><name>aStartColumnIndex</name></expr></argument>,
                       <argument><expr><name>aEndRowIndex</name></expr></argument>, <argument><expr><name>aEndColumnIndex</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>SelectRowOrColumn</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aCellContent</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aTarget</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aCellContent</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>table</name> <init>= <expr><call><name>GetParentTable</name><argument_list>(<argument><expr><name>aCellContent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>table</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <comment type="line">// Get table and cell layout interfaces to access </comment>
  <comment type="line">//   cell data based on cellmap location</comment>
  <comment type="line">// Frames are not ref counted, so don't use an nsCOMPtr</comment>
  <decl_stmt><decl><type><name>nsITableLayout</name> *</type><name>tableLayout</name> <init>= <expr><call><name>GetTableLayout</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>tableLayout</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsITableCellLayout</name> *</type><name>cellLayout</name> <init>= <expr><call><name>GetCellLayout</name><argument_list>(<argument><expr><name>aCellContent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>cellLayout</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <comment type="line">// Get location of target cell:      </comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowIndex</name></decl>, <decl><type ref="prev"/><name>colIndex</name></decl>, <decl><type ref="prev"/><name>curRowIndex</name></decl>, <decl><type ref="prev"/><name>curColIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name><name>cellLayout</name>-&gt;<name>GetCellIndexes</name></name><argument_list>(<argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>

  <comment type="line">// Be sure we start at proper beginning</comment>
  <comment type="line">// (This allows us to select row or col given ANY cell!)</comment>
  <if>if <condition>(<expr><name>aTarget</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_ROW</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>colIndex</name> = 0</expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>aTarget</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_COLUMN</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>rowIndex</name> = 0</expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMElement</name></expr></argument>&gt;</argument_list></name></type> <name>cellElement</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>firstCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMElement</name></expr></argument>&gt;</argument_list></name></type> <name>lastCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowSpan</name></decl>, <decl><type ref="prev"/><name>colSpan</name></decl>, <decl><type ref="prev"/><name>actualRowSpan</name></decl>, <decl><type ref="prev"/><name>actualColSpan</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isSelected</name></decl>;</decl_stmt>

  <do>do <block>{
    <comment type="line">// Loop through all cells in column or row to find first and last</comment>
    <expr_stmt><expr><name>result</name> = <call><name><name>tableLayout</name>-&gt;<name>GetCellDataAt</name></name><argument_list>(<argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>, <argument><expr>*<call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>cellElement</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>curRowIndex</name></expr></argument>, <argument><expr><name>curColIndex</name></expr></argument>, <argument><expr><name>rowSpan</name></expr></argument>, <argument><expr><name>colSpan</name></expr></argument>, 
                                        <argument><expr><name>actualRowSpan</name></expr></argument>, <argument><expr><name>actualColSpan</name></expr></argument>, <argument><expr><name>isSelected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>cellElement</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>actualRowSpan</name> &gt; 0 &amp;&amp; <name>actualColSpan</name>&gt; 0</expr></argument>, <argument><expr>"SelectRowOrColumn: Bad rowspan or colspan\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>firstCell</name></expr>)</condition><then>
        <expr_stmt><expr><name>firstCell</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>cellElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><name>lastCell</name> = <name>cellElement</name></expr>;</expr_stmt>

      <comment type="line">// Move to next cell in cellmap, skipping spanned locations</comment>
      <if>if <condition>(<expr><name>aTarget</name> == <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_ROW</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>colIndex</name> += <name>actualColSpan</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>rowIndex</name> += <name>actualRowSpan</name></expr>;</expr_stmt></else></if>
    }</block></then></if>
  }</block>
  while <condition>(<expr><name>cellElement</name></expr>)</condition>;</do>

  <comment type="line">// Use SelectBlockOfCells:</comment>
  <comment type="line">// This will replace existing selection,</comment>
  <comment type="line">//  but allow unselecting by dragging out of selected region</comment>
  <if>if <condition>(<expr><name>firstCell</name> &amp;&amp; <name>lastCell</name></expr>)</condition><then>
  <block>{
    <if>if <condition>(<expr>!<name>mStartSelectedCell</name></expr>)</condition><then>
    <block>{
      <comment type="line">// We are starting a new block, so select the first cell</comment>
      <expr_stmt><expr><name>result</name> = <call><name>SelectCellElement</name><argument_list>(<argument><expr><name>firstCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
      <expr_stmt><expr><name>mStartSelectedCell</name> = <name>firstCell</name></expr>;</expr_stmt>
    }</block></then></if>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>lastCellContent</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>lastCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>result</name> = <call><name>SelectBlockOfCells</name><argument_list>(<argument><expr><name>mStartSelectedCell</name></expr></argument>, <argument><expr><name>lastCellContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// This gets set to the cell at end of row/col, </comment>
    <comment type="line">//   but we need it to be the cell under cursor</comment>
    <expr_stmt><expr><name>mEndSelectedCell</name> = <name>aCellContent</name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<comment type="line">// This is a more efficient strategy that appends row to current selection,</comment>
<comment type="line">//  but doesn't allow dragging OFF of an existing selection to unselect!</comment>
  do {
    <comment type="line">// Loop through all cells in column or row</comment>
    result = tableLayout-&gt;GetCellDataAt(rowIndex, colIndex,
                                        getter_AddRefs(cellElement),
                                        curRowIndex, curColIndex,
                                        rowSpan, colSpan,
                                        actualRowSpan, actualColSpan,
                                        isSelected);
    if (NS_FAILED(result)) return result;
    <comment type="line">// We're done when cell is not found</comment>
    if (!cellElement) break;


    <comment type="line">// Check spans else we infinitely loop</comment>
    NS_ASSERTION(actualColSpan, "actualColSpan is 0!");
    NS_ASSERTION(actualRowSpan, "actualRowSpan is 0!");
    
    <comment type="line">// Skip cells that are already selected or span from outside our region</comment>
    if (!isSelected &amp;&amp; rowIndex == curRowIndex &amp;&amp; colIndex == curColIndex)
    {
      result = SelectCellElement(cellElement);
      if (NS_FAILED(result)) return result;
    }
    <comment type="line">// Move to next row or column in cellmap, skipping spanned locations</comment>
    if (aTarget == nsISelectionPrivate::TABLESELECTION_ROW)
      colIndex += actualColSpan;
    else
      rowIndex += actualRowSpan;
  }
  while (cellElement);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsIContent</name>*</type>
<name><name>nsFrameSelection</name>::<name>GetFirstCellNodeInRange</name></name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr>!<name>aRange</name></expr>)</condition><then> <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>startParent</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>startParent</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>offset</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>childContent</name> <init>= <expr><call><name><name>startParent</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>childContent</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>
  <comment type="line">// Don't return node if not a cell</comment>
  <if>if <condition>(<expr>!<call><name>IsCell</name><argument_list>(<argument><expr><name>childContent</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <return>return <expr><name>childContent</name></expr>;</return>
}</block></function>

<function><type><name>nsIRange</name>*</type>
<name><name>nsFrameSelection</name>::<name>GetFirstCellRange</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>firstRange</name> <init>= <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetRangeAt</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>GetFirstCellNodeInRange</name><argument_list>(<argument><expr><name>firstRange</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Setup for next cell</comment>
  <expr_stmt><expr><name>mSelectedCellIndex</name> = 1</expr>;</expr_stmt>

  <return>return <expr><name>firstRange</name></expr>;</return>
}</block></function>

<function><type><name>nsIRange</name>*</type>
<name><name>nsFrameSelection</name>::<name>GetNextCellRange</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>range</name> <init>= <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetRangeAt</name><argument_list>(<argument><expr><name>mSelectedCellIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Get first node in next range of selection - test if it's a cell</comment>
  <if>if <condition>(<expr>!<call><name>GetFirstCellNodeInRange</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Setup for next cell</comment>
  <expr_stmt><expr><name>mSelectedCellIndex</name>++</expr>;</expr_stmt>

  <return>return <expr><name>range</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>GetCellIndexes</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aCell</name></decl></param>,
                                 <param><decl><type><name>PRInt32</name>    &amp;</type><name>aRowIndex</name></decl></param>,
                                 <param><decl><type><name>PRInt32</name>    &amp;</type><name>aColIndex</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aCell</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr><name>aColIndex</name>=0</expr>;</expr_stmt> <comment type="line">// initialize out params</comment>
  <expr_stmt><expr><name>aRowIndex</name>=0</expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsITableCellLayout</name> *</type><name>cellLayoutObject</name> <init>= <expr><call><name>GetCellLayout</name><argument_list>(<argument><expr><name>aCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>cellLayoutObject</name></expr>)</condition><then>  <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  <return>return <expr><call><name><name>cellLayoutObject</name>-&gt;<name>GetCellIndexes</name></name><argument_list>(<argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsIContent</name>*</type>
<name><name>nsFrameSelection</name>::<name>IsInSameTable</name></name><parameter_list>(<param><decl><type><name>nsIContent</name>  *</type><name>aContent1</name></decl></param>,
                                <param><decl><type><name>nsIContent</name>  *</type><name>aContent2</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr>!<name>aContent1</name> || !<name>aContent2</name></expr>)</condition><then> <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  
  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>tableNode1</name> <init>= <expr><call><name>GetParentTable</name><argument_list>(<argument><expr><name>aContent1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>tableNode2</name> <init>= <expr><call><name>GetParentTable</name><argument_list>(<argument><expr><name>aContent2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Must be in the same table.  Note that we want to return false for</comment>
  <comment type="line">// the test if both tables are null.</comment>
  <return>return <expr>(<name>tableNode1</name> == <name>tableNode2</name>) ? <name>tableNode1</name> : <name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>nsIContent</name>*</type>
<name><name>nsFrameSelection</name>::<name>GetParentTable</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aCell</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr>!<name>aCell</name></expr>)</condition><then> <block>{
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>

  <for>for (<init><decl><type><name>nsIContent</name>*</type> <name>parent</name> <init>= <expr><call><name><name>aCell</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>parent</name></expr>;</condition>
       <incr><expr><name>parent</name> = <call><name><name>parent</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <if>if <condition>(<expr><call><name><name>parent</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>table</name></name> &amp;&amp;
        <call><name><name>parent</name>-&gt;<name>IsHTML</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>parent</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>SelectCellElement</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aCellElement</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIContent</name> *</type><name>parent</name> <init>= <expr><call><name><name>aCellElement</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Get child offset</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>offset</name> <init>= <expr><call><name><name>parent</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>aCellElement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>CreateAndAddRange</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>getTableCellLocationFromRange</name></name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aSelectionType</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aRow</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aCol</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aRange</name> || !<name>aSelectionType</name> || !<name>aRow</name> || !<name>aCol</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr>*<name>aSelectionType</name> = <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_NONE</name></name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aRow</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aCol</name> = 0</expr>;</expr_stmt>

  <comment type="line">// Must have access to frame selection to get cell info</comment>
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then> <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name>GetTableSelectionType</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>, <argument><expr><name>aSelectionType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
  
  <comment type="line">// Don't fail if range does not point to a single table cell,</comment>
  <comment type="line">//  let aSelectionType tell user if we don't have a cell</comment>
  <if>if <condition>(<expr>*<name>aSelectionType</name>  != <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_CELL</name></name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <comment type="line">// Get the child content (the cell) pointed to by starting node of range</comment>
  <comment type="line">// We do minimal checking since GetTableSelectionType assures</comment>
  <comment type="line">//   us that this really is a table cell</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>content</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIContent</name> *</type><name>child</name> <init>= <expr><call><name><name>content</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><call><name><name>aRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>child</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <comment type="line">//Note: This is a non-ref-counted pointer to the frame</comment>
  <decl_stmt><decl><type><name>nsITableCellLayout</name> *</type><name>cellLayout</name> <init>= <expr><call><name><name>mFrameSelection</name>-&gt;<name>GetCellLayout</name></name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>
  <if>if <condition>(<expr>!<name>cellLayout</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <return>return <expr><call><name><name>cellLayout</name>-&gt;<name>GetCellIndexes</name></name><argument_list>(<argument><expr>*<name>aRow</name></expr></argument>, <argument><expr>*<name>aCol</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>addTableCellRange</name></name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>aDidAddRange</name></decl></param>,
                                    <param><decl><type><name>PRInt32</name> *</type><name>aOutIndex</name></decl></param>)</parameter_list>
<block>{  
  <if>if <condition>(<expr>!<name>aDidAddRange</name> || !<name>aOutIndex</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr>*<name>aDidAddRange</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aOutIndex</name> = -1</expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <if>if <condition>(<expr>!<name>aRange</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>

  <comment type="line">// Get if we are adding a cell selection and the row, col of cell if we are</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>newRow</name></decl>, <decl><type ref="prev"/><name>newCol</name></decl>, <decl><type ref="prev"/><name>tableMode</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>result</name> = <call><name>getTableCellLocationFromRange</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>, <argument><expr>&amp;<name>tableMode</name></expr></argument>, <argument><expr>&amp;<name>newRow</name></expr></argument>, <argument><expr>&amp;<name>newCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
  
  <comment type="line">// If not adding a cell range, we are done here</comment>
  <if>if <condition>(<expr><name>tableMode</name> != <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_CELL</name></name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name><name>mFrameSelection</name>-&gt;<name>mSelectingTableCellMode</name></name> = <name>tableMode</name></expr>;</expr_stmt>
    <comment type="line">// Don't fail if range isn't a selected cell, aDidAddRange tells caller if we didn't proceed</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  
  <comment type="line">// Set frame selection mode only if not already set to a table mode</comment>
  <comment type="line">//  so we don't lose the select row and column flags (not detected by getTableCellLocation)</comment>
  <if>if <condition>(<expr><name><name>mFrameSelection</name>-&gt;<name>mSelectingTableCellMode</name></name> == <name>TABLESELECTION_NONE</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>mFrameSelection</name>-&gt;<name>mSelectingTableCellMode</name></name> = <name>tableMode</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr>*<name>aDidAddRange</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  <return>return <expr><call><name>AddItem</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>, <argument><expr><name>aOutIndex</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//TODO: Figure out TABLESELECTION_COLUMN and TABLESELECTION_ALLCELLS</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetTableSelectionType</name></name><parameter_list>(<param><decl><type><name>nsIDOMRange</name>*</type> <name>aRange</name></decl></param>,
                                        <param><decl><type><name>PRInt32</name>*</type> <name>aTableSelectionType</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>GetTableSelectionType</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>aTableSelectionType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>GetTableSelectionType</name></name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>,
                                        <param><decl><type><name>PRInt32</name>*</type> <name>aTableSelectionType</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aRange</name> || !<name>aTableSelectionType</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  
  <expr_stmt><expr>*<name>aTableSelectionType</name> = <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_NONE</name></name></expr>;</expr_stmt>
 
  <comment type="line">// Must have access to frame selection to get cell info</comment>
  <if>if<condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then> <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>startNode</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>startNode</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>endNode</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>endNode</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <comment type="line">// Not a single selected node</comment>
  <if>if <condition>(<expr><name>startNode</name> != <name>endNode</name></expr>)</condition><then> <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startOffset</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>endOffset</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Not a single selected node</comment>
  <if>if <condition>(<expr>(<name>endOffset</name> - <name>startOffset</name>) != 1</expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>startContent</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIContent</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>startNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!(<call><name><name>startNode</name>-&gt;<name>IsElement</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>startContent</name>-&gt;<name>IsHTML</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
    <comment type="line">// Implies a check for being an element; if we ever make this work</comment>
    <comment type="line">// for non-HTML, need to keep checking for elements.</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIAtom</name> *</type><name>tag</name> <init>= <expr><call><name><name>startContent</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>tag</name> == <name><name>nsGkAtoms</name>::<name>tr</name></name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr>*<name>aTableSelectionType</name> = <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_CELL</name></name></expr>;</expr_stmt>
  }</block></then>
  <else>else <comment type="line">//check to see if we are selecting a table or row (column and all cells not done yet)</comment>
  <block>{
    <decl_stmt><decl><type><name>nsIContent</name> *</type><name>child</name> <init>= <expr><call><name><name>startNode</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>child</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>tag</name> = <call><name><name>child</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>tag</name> == <name><name>nsGkAtoms</name>::<name>table</name></name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aTableSelectionType</name> = <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_TABLE</name></name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>tag</name> == <name><name>nsGkAtoms</name>::<name>tr</name></name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aTableSelectionType</name> = <name><name>nsISelectionPrivate</name>::<name>TABLESELECTION_ROW</name></name></expr>;</expr_stmt></then></if></else></if>
  }</block></else></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>CreateAndAddRange</name></name><parameter_list>(<param><decl><type><name>nsINode</name> *</type><name>aParentNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aParentNode</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr>new <call><name>nsRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>range</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

  <comment type="line">// Set range around child at given offset</comment>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name><name>range</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
  <expr_stmt><expr><name>result</name> = <call><name><name>range</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
  
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <return>return <expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>AddRange</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// End of Table Selection</comment>

<function><type><name>void</name></type>
<name><name>nsFrameSelection</name>::<name>SetAncestorLimiter</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aLimiter</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mAncestorLimiter</name> != <name>aLimiter</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mAncestorLimiter</name> = <name>aLimiter</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>=
      <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
      <return>return;</return></then></if>

    <if>if <condition>(<expr>!<call><name>IsValidSelectionPoint</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetFocusNode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>ClearNormalSelection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mAncestorLimiter</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PostReason</name><argument_list>(<argument><expr><name><name>nsISelectionListener</name>::<name>NO_REASON</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TakeFocus</name><argument_list>(<argument><expr><name>mAncestorLimiter</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>HINTLEFT</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="line">//END nsFrameSelection methods</comment>


<comment type="line">//BEGIN nsISelection interface implementations</comment>



<function><type><name>nsresult</name></type>
<name><name>nsFrameSelection</name>::<name>DeleteFromDocument</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>res</name></decl>;</decl_stmt>

  <comment type="line">// If we're already collapsed, then set ourselves to include the</comment>
  <comment type="line">// last item BEFORE the current range, rather than the range itself,</comment>
  <comment type="line">// before we do the delete.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isCollapsed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt8</name></type> <name>index</name> <init>= <expr><call><name>GetIndexFromSelectionType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetIsCollapsed</name><argument_list>( <argument><expr>&amp;<name>isCollapsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>isCollapsed</name></expr>)</condition><then>
  <block>{
    <comment type="line">// If the offset is positive, then it's easy:</comment>
    <if>if <condition>(<expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetFocusOffset</name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>Extend</name><argument_list>(<argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetFocusNode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetFocusOffset</name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
    <block>{
      <comment type="line">// Otherwise it's harder, have to find the previous node</comment>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Sorry, don't know how to delete across frame boundaries yet\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
    }</block></else></if>
  }</block></then></if>

  <comment type="line">// Get an iterator</comment>
  <function_decl><type><name>nsSelectionIterator</name></type> <name>iter</name><parameter_list>(<param><decl><type><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><name>res</name> = <call><name><name>iter</name>.<name>First</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>res</name></expr>;</return></then></if>

  <while>while <condition>(<expr><call><name><name>iter</name>.<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition>
  <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name><name>iter</name>.<name>CurrentItem</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>res</name> = <call><name><name>range</name>-&gt;<name>DeleteContents</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>iter</name>.<name>Next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>

  <comment type="line">// Collapse to the new location.</comment>
  <comment type="line">// If we deleted one character, then we move back one element.</comment>
  <comment type="line">// FIXME  We don't know how to do this past frame boundaries yet.</comment>
  <if>if <condition>(<expr><name>isCollapsed</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>Collapse</name><argument_list>(<argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetAnchorNode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetAnchorOffset</name><argument_list>()</argument_list></call>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetAnchorOffset</name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
    <expr_stmt><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>Collapse</name><argument_list>(<argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetAnchorNode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>mDomSelections</name><index>[<expr><name>index</name></expr>]</index></name>-&gt;<call><name>GetAnchorOffset</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <else>else
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Don't know how to set selection back past frame boundary\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsFrameSelection</name>::<name>SetDelayedCaretData</name></name><parameter_list>(<param><decl><type><name>nsMouseEvent</name> *</type><name>aMouseEvent</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aMouseEvent</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>mDelayedMouseEventValid</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mDelayedMouseEvent</name>      = *<name>aMouseEvent</name></expr>;</expr_stmt>

    <comment type="line">// Don't cache the widget.  We don't need it and it could go away.</comment>
    <expr_stmt><expr><name><name>mDelayedMouseEvent</name>.<name>widget</name></name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then>
  <else>else
    <expr_stmt><expr><name>mDelayedMouseEventValid</name> = <name>PR_FALSE</name></expr>;</expr_stmt></else></if>
}</block></function>

<function><type><name>nsMouseEvent</name>*</type>
<name><name>nsFrameSelection</name>::<name>GetDelayedCaretData</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mDelayedMouseEventValid</name></expr>)</condition><then>
    <return>return <expr>&amp;<name>mDelayedMouseEvent</name></expr>;</return></then></if>
  
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<comment type="line">//END nsISelection interface implementations</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> mark -</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// nsTypedSelection implementation</comment>

<comment type="line">// note: this can return a nil anchor node</comment>

<constructor><name><name>nsTypedSelection</name>::<name>nsTypedSelection</name></name><parameter_list>()</parameter_list>
  <member_list>: <call><name>mCachedOffsetForFrame</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
  , <call><name>mDirection</name><argument_list>(<argument><expr><name>eDirNext</name></expr></argument>)</argument_list></call>
  , <call><name>mType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call>
</member_list><block>{
}</block></constructor>

<constructor><name><name>nsTypedSelection</name>::<name>nsTypedSelection</name></name><parameter_list>(<param><decl><type><name>nsFrameSelection</name> *</type><name>aList</name></decl></param>)</parameter_list>
  <member_list>: <call><name>mFrameSelection</name><argument_list>(<argument><expr><name>aList</name></expr></argument>)</argument_list></call>
  , <call><name>mCachedOffsetForFrame</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
  , <call><name>mDirection</name><argument_list>(<argument><expr><name>eDirNext</name></expr></argument>)</argument_list></call>
  , <call><name>mType</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>)</argument_list></call>
</member_list><block>{
}</block></constructor>

<destructor><name><name>nsTypedSelection</name>::~<name>nsTypedSelection</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>setAnchorFocusRange</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mAutoScrollTimer</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mAutoScrollTimer</name>-&gt;<name>Stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mAutoScrollTimer</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mScrollEvent</name>.<name>Revoke</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mCachedOffsetForFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>delete <name>mCachedOffsetForFrame</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCachedOffsetForFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></destructor>


<macro><name>NS_IMPL_CYCLE_COLLECTION_CLASS</name><argument_list>(<argument>nsTypedSelection</argument>)</argument_list></macro>
<macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN</name><argument_list>(<argument>nsTypedSelection</argument>)</argument_list></macro>
  <comment type="line">// Unlink the selection listeners *before* we do RemoveAllRanges since</comment>
  <comment type="line">// we don't want to notify the listeners during JS GC (they could be</comment>
  <comment type="line">// in JS!).</comment>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY</name><argument_list>(<argument>mSelectionListeners</argument>)</argument_list></macro>
  <expr_stmt><expr><call><name><name>tmp</name>-&gt;<name>RemoveAllRanges</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR</name><argument_list>(<argument>mFrameSelection</argument>)</argument_list></macro>
<function><type><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_END</name></type>
<name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN</name><parameter_list>(<param><decl><type><name>nsTypedSelection</name></type></decl></param>)</parameter_list>
  <block>{
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><call><name><name>tmp</name>-&gt;<name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
      <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mRanges[i].mRange</argument>)</argument_list></macro>
    }</block></for>
  }</block></function>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mAnchorFocusRange</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR</name><argument_list>(<argument>mFrameSelection</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY</name><argument_list>(<argument>mSelectionListeners</argument>)</argument_list></macro>
<decl_stmt><decl><type><name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END</name></type>

<name>DOMCI_DATA</name><argument_list>(<argument><expr><name>Selection</name></expr></argument>, <argument><expr><name>nsTypedSelection</name></expr></argument>)</argument_list>

<comment type="line">// QueryInterface implementation for nsTypedSelection</comment>
<name>NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION</name><argument_list>(<argument><expr><name>nsTypedSelection</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsISelection</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsISelection2</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsISelection3</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsISelectionPrivate</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument><expr><name>nsISupportsWeakReference</name></expr></argument>)</argument_list>
  <name>NS_INTERFACE_MAP_ENTRY_AMBIGUOUS</name><argument_list>(<argument><expr><name>nsISupports</name></expr></argument>, <argument><expr><name>nsISelection</name></expr></argument>)</argument_list>
  <name>NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO</name><argument_list>(<argument><expr><name>Selection</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_MAP_END</name>

<name>NS_IMPL_CYCLE_COLLECTING_ADDREF</name><argument_list>(<argument><expr><name>nsTypedSelection</name></expr></argument>)</argument_list>
<name>NS_IMPL_CYCLE_COLLECTING_RELEASE</name><argument_list>(<argument><expr><name>nsTypedSelection</name></expr></argument>)</argument_list>

<name>NS_IMETHODIMP</name>
<name><name>nsTypedSelection</name>::<name>SetPresShell</name></name><argument_list>(<argument><expr><name>nsIPresShell</name> *<name>aPresShell</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><name>mPresShellWeak</name> = <call><name>do_GetWeakReference</name><argument_list>(<argument><expr><name>aPresShell</name></expr></argument>)</argument_list></call></expr></argument>;
  return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>



<name>NS_IMETHODIMP</name>
<name><name>nsTypedSelection</name>::<name>GetAnchorNode</name></name><argument_list>(<argument><expr><name>nsIDOMNode</name>** <name>aAnchorNode</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><name>nsINode</name>* <name>anchorNode</name> = <call><name>GetAnchorNode</name><argument_list>()</argument_list></call></expr></argument>;
  if <argument><expr>(<name>anchorNode</name>) <block>{
    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>anchorNode</name></expr></argument>, <argument><expr><name>aAnchorNode</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>

  *<name>aAnchorNode</name> = <name>nsnull</name></expr></argument>;
  return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsINode</name>*
<name><name>nsTypedSelection</name>::<name>GetAnchorNode</name></name><argument_list>()</argument_list>
<argument_list>{
  if <argument><expr>(!<name>mAnchorFocusRange</name>)</expr></argument>
    <return>return <expr><name>nsnull</name></expr>;</return></argument_list></decl></decl_stmt>
   
  <if>if <condition>(<expr><call><name>GetDirection</name><argument_list>()</argument_list></call> == <name>eDirNext</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>

  <return>return <expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsTypedSelection</name></macro><expr_stmt><expr><name>::<name>GetAnchorOffset</name></name>(<name>PRInt32</name>* <name>aAnchorOffset</name>)
<block>{
  <expr>*<name>aAnchorOffset</name> = <call><name>GetAnchorOffset</name><argument_list>()</argument_list></call></expr>;
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></expr></expr_stmt>

<comment type="line">// note: this can return a nil focus node</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetFocusNode</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>**</type> <name>aFocusNode</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>focusNode</name> <init>= <expr><call><name>GetFocusNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>focusNode</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>aFocusNode</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>aFocusNode</name> = <name>nsnull</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsINode</name>*</type>
<name><name>nsTypedSelection</name>::<name>GetFocusNode</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mAnchorFocusRange</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>GetDirection</name><argument_list>()</argument_list></call> == <name>eDirNext</name></expr>)</condition><then><block>{
    <return>return <expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>

  <return>return <expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsTypedSelection</name>::<name>GetFocusOffset</name></name><parameter_list>(<param><decl><type><name>PRInt32</name>*</type> <name>aFocusOffset</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aFocusOffset</name> = <call><name>GetFocusOffset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsTypedSelection</name>::<name>setAnchorFocusRange</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>indx</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>indx</name> &gt;= (<name>PRInt32</name>)<call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>
  <if>if <condition>(<expr><name>indx</name> &lt; 0</expr>)</condition><then> <comment type="line">//release all</comment>
  <block>{
    <expr_stmt><expr><name>mAnchorFocusRange</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then>
  <else>else<block>{
    <expr_stmt><expr><name>mAnchorFocusRange</name> = <name><name>mRanges</name><index>[<expr><name>indx</name></expr>]</index></name>.<name>mRange</name></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>nsTypedSelection</name>::<name>GetAnchorOffset</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mAnchorFocusRange</name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>GetDirection</name><argument_list>()</argument_list></call> == <name>eDirNext</name></expr>)</condition><then><block>{
    <return>return <expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>

  <return>return <expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>nsTypedSelection</name>::<name>GetFocusOffset</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mAnchorFocusRange</name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>GetDirection</name><argument_list>()</argument_list></call> == <name>eDirNext</name></expr>)</condition><then><block>{
    <return>return <expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>

  <return>return <expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>CompareToRangeStart</name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aCompareNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aCompareOffset</name></decl></param>,
                    <param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>, <param><decl><type><name>PRInt32</name>*</type> <name>aCmp</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>start</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>aCompareNode</name> &amp;&amp; <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aCmp</name> = <call><name><name>nsContentUtils</name>::<name>ComparePoints</name></name><argument_list>(<argument><expr><name>aCompareNode</name></expr></argument>, <argument><expr><name>aCompareOffset</name></expr></argument>,
                                        <argument><expr><name>start</name></expr></argument>, <argument><expr><call><name><name>aRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>CompareToRangeEnd</name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aCompareNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aCompareOffset</name></decl></param>,
                  <param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>, <param><decl><type><name>PRInt32</name>*</type> <name>aCmp</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>end</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>aCompareNode</name> &amp;&amp; <name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aCmp</name> = <call><name><name>nsContentUtils</name>::<name>ComparePoints</name></name><argument_list>(<argument><expr><name>aCompareNode</name></expr></argument>, <argument><expr><name>aCompareOffset</name></expr></argument>,
                                        <argument><expr><name>end</name></expr></argument>, <argument><expr><call><name><name>aRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// nsTypedSelection::FindInsertionPoint</comment>
<comment type="line">//</comment>
<comment type="line">//    Binary searches the given sorted array of ranges for the insertion point</comment>
<comment type="line">//    for the given node/offset. The given comparator is used, and the index</comment>
<comment type="line">//    where the point should appear in the array is placed in *aInsertionPoint.</comment>
<comment type="line">//</comment>
<comment type="line">//    If there is an item in the array equal to the input point, we will return</comment>
<comment type="line">//    the index of this item.</comment>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>FindInsertionPoint</name></name><parameter_list>(
    <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>RangeData</name></expr></argument>&gt;</argument_list></name>*</type> <name>aElementArray</name></decl></param>,
    <param><decl><type><name>nsINode</name>*</type> <name>aPointNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aPointOffset</name></decl></param>,
    <param><function_decl><type><name>nsresult</name></type> (*<name>aComparator</name>)<parameter_list>(<param><decl><type><name>nsINode</name>*</type></decl></param>,<param><decl><type><name>PRInt32</name></type></decl></param>,<param><decl><type><name>nsIRange</name>*</type></decl></param>,<param><decl><type><name>PRInt32</name>*</type></decl></param>)</parameter_list></function_decl></param>,
    <param><decl><type><name>PRInt32</name>*</type> <name>aPoint</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aPoint</name> = 0</expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>beginSearch</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>endSearch</name> <init>= <expr><call><name><name>aElementArray</name>-&gt;<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// one beyond what to check</comment>
  <while>while <condition>(<expr><name>endSearch</name> - <name>beginSearch</name> &gt; 0</expr>)</condition> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>center</name> <init>= <expr>(<name>endSearch</name> - <name>beginSearch</name>) / 2 + <name>beginSearch</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>range</name> <init>= <expr>(*<name>aElementArray</name>)<index>[<expr><name>center</name></expr>]</index>.<name>mRange</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>cmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>aComparator</name><argument_list>(<argument><expr><name>aPointNode</name></expr></argument>, <argument><expr><name>aPointOffset</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr>&amp;<name>cmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then> <block>{        <comment type="line">// point &lt; cur</comment>
      <expr_stmt><expr><name>endSearch</name> = <name>center</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then> <block>{ <comment type="line">// point &gt; cur</comment>
      <expr_stmt><expr><name>beginSearch</name> = <name>center</name> + 1</expr>;</expr_stmt>
    }</block></then> <else>else <block>{              <comment type="line">// found match, done</comment>
      <expr_stmt><expr><name>beginSearch</name> = <name>center</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block></else></if></else></if>
  }</block></while>
  <expr_stmt><expr>*<name>aPoint</name> = <name>beginSearch</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// nsTypedSelection::SubtractRange</comment>
<comment type="line">//</comment>
<comment type="line">//    A helper function that subtracts aSubtract from aRange, and adds</comment>
<comment type="line">//    1 or 2 RangeData objects representing the remaining non-overlapping</comment>
<comment type="line">//    difference to aOutput. It is assumed that the caller has checked that</comment>
<comment type="line">//    aRange and aSubtract do indeed overlap</comment>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>SubtractRange</name></name><parameter_list>(<param><decl><type><name>RangeData</name>*</type> <name>aRange</name></decl></param>, <param><decl><type><name>nsIRange</name>*</type> <name>aSubtract</name></decl></param>,
                                <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>RangeData</name></expr></argument>&gt;</argument_list></name>*</type> <name>aOutput</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>range</name> <init>= <expr><name><name>aRange</name>-&gt;<name>mRange</name></name></expr></init></decl>;</decl_stmt>

  <comment type="line">// First we want to compare to the range start</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>CompareToRangeStart</name><argument_list>(<argument><expr><call><name><name>range</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>range</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><name>aSubtract</name></expr></argument>, <argument><expr>&amp;<name>cmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Also, make a comparison to the range end</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cmp2</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name>CompareToRangeEnd</name><argument_list>(<argument><expr><call><name><name>range</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>range</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><name>aSubtract</name></expr></argument>, <argument><expr>&amp;<name>cmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// If the existing range left overlaps the new range (aSubtract) then</comment>
  <comment type="line">// cmp &lt; 0, and cmp2 &lt; 0</comment>
  <comment type="line">// If it right overlaps the new range then cmp &gt; 0 and cmp2 &gt; 0</comment>
  <comment type="line">// If it fully contains the new range, then cmp &lt; 0 and cmp2 &gt; 0</comment>

  <if>if <condition>(<expr><name>cmp2</name> &gt; 0</expr>)</condition><then> <block>{
    <comment type="line">// We need to add a new RangeData to the output, running from</comment>
    <comment type="line">// the end of aSubtract to the end of range</comment>
    <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>postOverlap</name> <init>= <expr>new <call><name>nsRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>postOverlap</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    
    <expr_stmt><expr><name>rv</name> =
      <call><name><name>postOverlap</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><call><name><name>aSubtract</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aSubtract</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> =
     <call><name><name>postOverlap</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><call><name><name>range</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>range</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>postOverlap</name>-&gt;<name>Collapsed</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name><name>aOutput</name>-&gt;<name>InsertElementAt</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>RangeData</name><argument_list>(<argument><expr><name>postOverlap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
      <expr_stmt><expr>(*<name>aOutput</name>)<index>[<expr>0</expr>]</index>.<name>mTextRangeStyle</name> = <name><name>aRange</name>-&gt;<name>mTextRangeStyle</name></name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>cmp</name> &lt; 0</expr>)</condition><then> <block>{
    <comment type="line">// We need to add a new RangeData to the output, running from</comment>
    <comment type="line">// the start of the range to the start of aSubtract</comment>
    <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>preOverlap</name> <init>= <expr>new <call><name>nsRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>preOverlap</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>=
     <expr><call><name><name>preOverlap</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><call><name><name>range</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>range</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> =
     <call><name><name>preOverlap</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><call><name><name>aSubtract</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aSubtract</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr>!<call><name><name>preOverlap</name>-&gt;<name>Collapsed</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name><name>aOutput</name>-&gt;<name>InsertElementAt</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>RangeData</name><argument_list>(<argument><expr><name>preOverlap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
      <expr_stmt><expr>(*<name>aOutput</name>)<index>[<expr>0</expr>]</index>.<name>mTextRangeStyle</name> = <name><name>aRange</name>-&gt;<name>mTextRangeStyle</name></name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>AddItem</name></name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aItem</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aOutIndex</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aItem</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  <if>if <condition>(<expr>!<call><name><name>aItem</name>-&gt;<name>IsPositioned</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>
  <if>if <condition>(<expr><name>aOutIndex</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>aOutIndex</name> = -1</expr>;</expr_stmt></then></if>

  <comment type="line">// a common case is that we have no ranges yet</comment>
  <if>if <condition>(<expr><call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name><name>mRanges</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><call><name>RangeData</name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>aOutIndex</name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aOutIndex</name> = 0</expr>;</expr_stmt></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startIndex</name></decl>, <decl><type ref="prev"/><name>endIndex</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetIndicesForInterval</name><argument_list>(<argument><expr><call><name><name>aItem</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aItem</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><call><name><name>aItem</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aItem</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>&amp;<name>startIndex</name></expr></argument>, <argument><expr>&amp;<name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>endIndex</name> == -1</expr>)</condition><then> <block>{
    <comment type="line">// All ranges start after the given range. We can insert our range at</comment>
    <comment type="line">// position 0, knowing there are no overlaps (handled below)</comment>
    <expr_stmt><expr><name>startIndex</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>endIndex</name> = 0</expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><name>startIndex</name> == -1</expr>)</condition><then> <block>{
    <comment type="line">// All ranges end before the given range. We can insert our range at</comment>
    <comment type="line">// the end of the array, knowing there are no overlaps (handled below)</comment>
    <expr_stmt><expr><name>startIndex</name> = <call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>endIndex</name> = <name>startIndex</name></expr>;</expr_stmt>
  }</block></then></if></else></if>

  <comment type="line">// If the range is already contained in mRanges, silently succeed</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>sameRange</name> <init>= <expr><call><name>EqualsRangeAtPoint</name><argument_list>(<argument><expr><call><name><name>aItem</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><call><name><name>aItem</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><call><name><name>aItem</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><call><name><name>aItem</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>sameRange</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>aOutIndex</name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aOutIndex</name> = <name>startIndex</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>startIndex</name> == <name>endIndex</name></expr>)</condition><then> <block>{
    <comment type="line">// The new range doesn't overlap any existing ranges</comment>
    <if>if <condition>(<expr>!<call><name><name>mRanges</name>.<name>InsertElementAt</name></name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><call><name>RangeData</name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>aOutIndex</name></expr>)</condition><then>
      <expr_stmt><expr>*<name>aOutIndex</name> = <name>startIndex</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// We now know that at least 1 existing range overlaps with the range that</comment>
  <comment type="line">// we are trying to add. In fact, the only ranges of interest are those at</comment>
  <comment type="line">// the two end points, startIndex and endIndex - 1 (which may point to the</comment>
  <comment type="line">// same range) as these may partially overlap the new range. Any ranges</comment>
  <comment type="line">// between these indices are fully overlapped by the new range, and so can be</comment>
  <comment type="line">// removed</comment>
  <decl_stmt><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>RangeData</name></expr></argument>&gt;</argument_list></name></type> <name>overlaps</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>overlaps</name>.<name>InsertElementAt</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name><name>mRanges</name><index>[<expr><name>startIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>endIndex</name> - 1 != <name>startIndex</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name><name>overlaps</name>.<name>InsertElementAt</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>mRanges</name><index>[<expr><name>endIndex</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
  }</block></then></if>

  <comment type="line">// Remove all the overlapping ranges</comment>
  <expr_stmt><expr><call><name><name>mRanges</name>.<name>RemoveElementsAt</name></name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>endIndex</name> - <name>startIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>RangeData</name></expr></argument>&gt;</argument_list></name></type> <name>temp</name></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr><call><name><name>overlaps</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>SubtractRange</name><argument_list>(<argument><expr>&amp;<name><name>overlaps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>aItem</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// Insert the new element into our "leftovers" array</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>insertionPoint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>FindInsertionPoint</name><argument_list>(<argument><expr>&amp;<name>temp</name></expr></argument>, <argument><expr><call><name><name>aItem</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><call><name><name>aItem</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><name>CompareToRangeStart</name></expr></argument>,
                                   <argument><expr>&amp;<name>insertionPoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name><name>temp</name>.<name>InsertElementAt</name></name><argument_list>(<argument><expr><name>insertionPoint</name></expr></argument>, <argument><expr><call><name>RangeData</name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

  <comment type="line">// Merge the leftovers back in to mRanges</comment>
  <if>if <condition>(<expr>!<call><name><name>mRanges</name>.<name>InsertElementsAt</name></name><argument_list>(<argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

  <expr_stmt><expr>*<name>aOutIndex</name> = <name>startIndex</name> + <name>insertionPoint</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>RemoveItem</name></name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aItem</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aItem</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <comment type="line">// Find the range's index &amp; remove it. We could use FindInsertionPoint to</comment>
  <comment type="line">// get O(log n) time, but that requires many expensive DOM comparisons.</comment>
  <comment type="line">// For even several thousand items, this is probably faster because the</comment>
  <comment type="line">// comparisons are so fast.</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>idx</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name> ++</expr></incr>) <block>{
    <if>if <condition>(<expr><name><name>mRanges</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mRange</name> == <name>aItem</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>idx</name> = (<name>PRInt32</name>)<name>i</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
  <if>if <condition>(<expr><name>idx</name> &lt; 0</expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name><name>mRanges</name>.<name>RemoveElementAt</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>RemoveCollapsedRanges</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>i</name> &lt; <call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
    <if>if <condition>(<expr><name><name>mRanges</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name><name>mRange</name>-&gt;<name>Collapsed</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>RemoveItem</name><argument_list>(<argument><expr><name><name>mRanges</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mRange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></while>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>Clear</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>setAnchorFocusRange</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; (<name>PRInt32</name>)<call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name> ++</expr></incr>) <block>{
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name><name>mRanges</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mRange</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name><name>mRanges</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Reset direction so for more dependable table selection range handling</comment>
  <expr_stmt><expr><call><name>SetDirection</name><argument_list>(<argument><expr><name>eDirNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// If this was an ATTENTION selection, change it back to normal now</comment>
  <if>if <condition>(<expr><name>mFrameSelection</name> &amp;&amp;
      <call><name><name>mFrameSelection</name>-&gt;<name>GetDisplaySelection</name></name><argument_list>()</argument_list></call> ==
      <name><name>nsISelectionController</name>::<name>SELECTION_ATTENTION</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>SetDisplaySelection</name></name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_ON</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetType</name></name><parameter_list>(<param><decl><type><name>PRInt16</name> *</type><name>aType</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aType</name> = <name>mType</name></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// RangeMatches*Point</comment>
<comment type="line">//</comment>
<comment type="line">//    Compares the range beginning or ending point, and returns true if it</comment>
<comment type="line">//    exactly matches the given DOM point.</comment>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>PRBool</name></type>
<name>RangeMatchesBeginPoint</name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>, <param><decl><type><name>nsINode</name>*</type> <name>aNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call> == <name>aNode</name> &amp;&amp; <call><name><name>aRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call> == <name>aOffset</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>PRBool</name></type>
<name>RangeMatchesEndPoint</name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>, <param><decl><type><name>nsINode</name>*</type> <name>aNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>aRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call> == <name>aNode</name> &amp;&amp; <call><name><name>aRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call> == <name>aOffset</name></expr>;</return>
}</block></function>

<comment type="line">// nsTypedSelection::EqualsRangeAtPoint</comment>
<comment type="line">//</comment>
<comment type="line">//    Utility method for checking equivalence of two ranges.</comment>

<function><type><name>PRBool</name></type>
<name><name>nsTypedSelection</name>::<name>EqualsRangeAtPoint</name></name><parameter_list>(
    <param><decl><type><name>nsINode</name>*</type> <name>aBeginNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aBeginOffset</name></decl></param>,
    <param><decl><type><name>nsINode</name>*</type> <name>aEndNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aEndOffset</name></decl></param>,
    <param><decl><type><name>PRInt32</name></type> <name>aRangeIndex</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aRangeIndex</name> &gt;=0 &amp;&amp; <name>aRangeIndex</name> &lt; (<name>PRInt32</name>) <call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>range</name> <init>= <expr><name><name>mRanges</name><index>[<expr><name>aRangeIndex</name></expr>]</index></name>.<name>mRange</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>RangeMatchesBeginPoint</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>aBeginNode</name></expr></argument>, <argument><expr><name>aBeginOffset</name></expr></argument>)</argument_list></call> &amp;&amp;
        <call><name>RangeMatchesEndPoint</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>aEndNode</name></expr></argument>, <argument><expr><name>aEndOffset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// nsTypedSelection::GetRangesForInterval</comment>
<comment type="line">//</comment>
<comment type="line">//    XPCOM wrapper for the COMArray version</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetRangesForInterval</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aBeginNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aBeginOffset</name></decl></param>,
                                       <param><decl><type><name>nsIDOMNode</name>*</type> <name>aEndNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aEndOffset</name></decl></param>,
                                       <param><decl><type><name>PRBool</name></type> <name>aAllowAdjacent</name></decl></param>,
                                       <param><decl><type><name>PRUint32</name> *</type><name>aResultCount</name></decl></param>,
                                       <param><decl><type><name>nsIDOMRange</name> ***</type><name>aResults</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aBeginNode</name> || ! <name>aEndNode</name> || ! <name>aResultCount</name> || ! <name>aResults</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr>*<name>aResultCount</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aResults</name> = <name>nsnull</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIDOMRange</name></expr></argument>&gt;</argument_list></name></type> <name>results</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetRangesForIntervalCOMArray</name><argument_list>(<argument><expr><name>aBeginNode</name></expr></argument>, <argument><expr><name>aBeginOffset</name></expr></argument>,
                                             <argument><expr><name>aEndNode</name></expr></argument>, <argument><expr><name>aEndOffset</name></expr></argument>,
                                             <argument><expr><name>aAllowAdjacent</name></expr></argument>,
                                             <argument><expr>&amp;<name>results</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name><name>results</name>.<name>Count</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <expr_stmt><expr>*<name>aResults</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIDOMRange</name>**</expr></argument>&gt;</argument_list></name>
                         <argument_list>(<argument><expr><call><name><name>nsMemory</name>::<name>Alloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsIDOMRange</name>*</expr></argument>)</argument_list></sizeof> * <call><name><name>results</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>*<name>aResults</name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>aResultCount</name> = <call><name><name>results</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>results</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name> ++</expr></incr>)
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>(*<name>aResults</name>)<index>[<expr><name>i</name></expr>]</index> = <name><name>results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// nsTypedSelection::GetRangesForIntervalCOMArray</comment>
<comment type="line">//</comment>
<comment type="line">//    Fills a COM array with the ranges overlapping the range specified by</comment>
<comment type="line">//    the given endpoints. Ranges in the selection exactly adjacent to the</comment>
<comment type="line">//    input range are not returned unless aAllowAdjacent is set.</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetRangesForIntervalCOMArray</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aBeginNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aBeginOffset</name></decl></param>,
                                               <param><decl><type><name>nsIDOMNode</name>*</type> <name>aEndNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aEndOffset</name></decl></param>,
                                               <param><decl><type><name>PRBool</name></type> <name>aAllowAdjacent</name></decl></param>,
                                               <param><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIDOMRange</name></expr></argument>&gt;</argument_list></name>*</type> <name>aRanges</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsINode</name></expr></argument>&gt;</argument_list></name></type> <name>begin</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aBeginNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsINode</name></expr></argument>&gt;</argument_list></name></type> <name>end</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aEndNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>ranges</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetRangesForIntervalCOMArray</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>aBeginOffset</name></expr></argument>,
                                             <argument><expr><name>end</name></expr></argument>, <argument><expr><name>aEndOffset</name></expr></argument>,
                                             <argument><expr><name>aAllowAdjacent</name></expr></argument>, <argument><expr>&amp;<name>ranges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>ranges</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMRange</name></expr></argument>&gt;</argument_list></name></type> <name>r</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name><name>ranges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>aRanges</name>-&gt;<name>AppendObject</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// nsTypedSelection::GetRangesForIntervalCOMArray</comment>
<comment type="line">//</comment>
<comment type="line">//    Fills a COM array with the ranges overlapping the range specified by</comment>
<comment type="line">//    the given endpoints. Ranges in the selection exactly adjacent to the</comment>
<comment type="line">//    input range are not returned unless aAllowAdjacent is set.</comment>
<comment type="line">//</comment>
<comment type="line">//    For example, if the following ranges were in the selection</comment>
<comment type="line">//    (assume everything is within the same node)</comment>
<comment type="line">//</comment>
<comment type="line">//    Start Offset: 0 2 7 9</comment>
<comment type="line">//      End Offset: 2 5 9 10</comment>
<comment type="line">//</comment>
<comment type="line">//    and passed aBeginOffset of 2 and aEndOffset of 9, then with</comment>
<comment type="line">//    aAllowAdjacent set, all the ranges should be returned. If</comment>
<comment type="line">//    aAllowAdjacent was false, the ranges [2, 5] and [7, 9] only</comment>
<comment type="line">//    should be returned</comment>
<comment type="line">//</comment>
<comment type="line">//    Now that overlapping ranges are disallowed, there can be a maximum of</comment>
<comment type="line">//    2 adjacent ranges</comment>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>GetRangesForIntervalCOMArray</name></name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aBeginNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aBeginOffset</name></decl></param>,
                                               <param><decl><type><name>nsINode</name>*</type> <name>aEndNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aEndOffset</name></decl></param>,
                                               <param><decl><type><name>PRBool</name></type> <name>aAllowAdjacent</name></decl></param>,
                                               <param><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name>*</type> <name>aRanges</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aRanges</name>-&gt;<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startIndex</name></decl>, <decl><type ref="prev"/><name>endIndex</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetIndicesForInterval</name><argument_list>(<argument><expr><name>aBeginNode</name></expr></argument>, <argument><expr><name>aBeginOffset</name></expr></argument>, <argument><expr><name>aEndNode</name></expr></argument>, <argument><expr><name>aEndOffset</name></expr></argument>,
                        <argument><expr><name>aAllowAdjacent</name></expr></argument>, <argument><expr>&amp;<name>startIndex</name></expr></argument>, <argument><expr>&amp;<name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>startIndex</name> == -1 || <name>endIndex</name> == -1</expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <if>if <condition>(<expr>!<call><name><name>aRanges</name>-&gt;<name>AppendObject</name></name><argument_list>(<argument><expr><name><name>mRanges</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mRange</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
  }</block></for>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// nsTypedSelection::GetIndicesForInterval</comment>
<comment type="line">//</comment>
<comment type="line">//    Works on the same principle as GetRangesForIntervalCOMArray above, however</comment>
<comment type="line">//    instead this returns the indices into mRanges between which the</comment>
<comment type="line">//    overlapping ranges lie.</comment>

<function><type><name>void</name></type>
<name><name>nsTypedSelection</name>::<name>GetIndicesForInterval</name></name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aBeginNode</name></decl></param>,
                                        <param><decl><type><name>PRInt32</name></type> <name>aBeginOffset</name></decl></param>,
                                        <param><decl><type><name>nsINode</name>*</type> <name>aEndNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aEndOffset</name></decl></param>,
                                        <param><decl><type><name>PRBool</name></type> <name>aAllowAdjacent</name></decl></param>,
                                        <param><decl><type><name>PRInt32</name> *</type><name>aStartIndex</name></decl></param>,
                                        <param><decl><type><name>PRInt32</name> *</type><name>aEndIndex</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aStartIndex</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>aStartIndex</name> = -1</expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>aEndIndex</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>aEndIndex</name> = -1</expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>intervalIsCollapsed</name> <init>= <expr><name>aBeginNode</name> == <name>aEndNode</name> &amp;&amp;
    <name>aBeginOffset</name> == <name>aEndOffset</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Ranges that end before the given interval and begin after the given</comment>
  <comment type="line">// interval can be discarded</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>endsBeforeIndex</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name>FindInsertionPoint</name><argument_list>(<argument><expr>&amp;<name>mRanges</name></expr></argument>, <argument><expr><name>aEndNode</name></expr></argument>, <argument><expr><name>aEndOffset</name></expr></argument>,
                                   <argument><expr>&amp;<name>CompareToRangeStart</name></expr></argument>,
                                   <argument><expr>&amp;<name>endsBeforeIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>endsBeforeIndex</name> == 0</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>endRange</name> <init>= <expr><name><name>mRanges</name><index>[<expr><name>endsBeforeIndex</name></expr>]</index></name>.<name>mRange</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If the interval is strictly before the range at index 0, we can optimize</comment>
    <comment type="line">// by returning now - all ranges start after the given interval</comment>
    <if>if <condition>(<expr>!<call><name>RangeMatchesBeginPoint</name><argument_list>(<argument><expr><name>endRange</name></expr></argument>, <argument><expr><name>aEndNode</name></expr></argument>, <argument><expr><name>aEndOffset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return;</return></then></if>

    <comment type="line">// We now know that the start point of mRanges[0].mRange equals the end of</comment>
    <comment type="line">// the interval. Thus, when aAllowadjacent is true, the caller is always</comment>
    <comment type="line">// interested in this range. However, when excluding adjacencies, we must</comment>
    <comment type="line">// remember to include the range when both it and the given interval are</comment>
    <comment type="line">// collapsed to the same point</comment>
    <if>if <condition>(<expr>!<name>aAllowAdjacent</name> &amp;&amp; !(<call><name><name>endRange</name>-&gt;<name>Collapsed</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>intervalIsCollapsed</name>)</expr>)</condition><then>
      <return>return;</return></then></if>
  }</block></then></if>
  <expr_stmt><expr>*<name>aEndIndex</name> = <name>endsBeforeIndex</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>beginsAfterIndex</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name>FindInsertionPoint</name><argument_list>(<argument><expr>&amp;<name>mRanges</name></expr></argument>, <argument><expr><name>aBeginNode</name></expr></argument>, <argument><expr><name>aBeginOffset</name></expr></argument>,
                                   <argument><expr>&amp;<name>CompareToRangeEnd</name></expr></argument>,
                                   <argument><expr>&amp;<name>beginsAfterIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>beginsAfterIndex</name> == (<name>PRInt32</name>) <call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if> <comment type="line">// optimization: all ranges are strictly before us</comment>

  <if>if <condition>(<expr><name>aAllowAdjacent</name></expr>)</condition><then> <block>{
    <comment type="line">// At this point, one of the following holds:</comment>
    <comment type="line">//   endsBeforeIndex == mRanges.Length(),</comment>
    <comment type="line">//   endsBeforeIndex points to a range whose start point does not equal the</comment>
    <comment type="line">//     given interval's start point</comment>
    <comment type="line">//   endsBeforeIndex points to a range whose start point equals the given</comment>
    <comment type="line">//     interval's start point</comment>
    <comment type="line">// In the final case, there can be two such ranges, a collapsed range, and</comment>
    <comment type="line">// an adjacent range (they will appear in mRanges in that order). For this</comment>
    <comment type="line">// final case, we need to increment endsBeforeIndex, until one of the</comment>
    <comment type="line">// first two possibilites hold</comment>
    <while>while <condition>(<expr><name>endsBeforeIndex</name> &lt; (<name>PRInt32</name>) <call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
      <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>endRange</name> <init>= <expr><name><name>mRanges</name><index>[<expr><name>endsBeforeIndex</name></expr>]</index></name>.<name>mRange</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<call><name>RangeMatchesBeginPoint</name><argument_list>(<argument><expr><name>endRange</name></expr></argument>, <argument><expr><name>aEndNode</name></expr></argument>, <argument><expr><name>aEndOffset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then></if>
      <expr_stmt><expr><name>endsBeforeIndex</name>++</expr>;</expr_stmt>
    }</block></while>

    <comment type="line">// Likewise, one of the following holds:</comment>
    <comment type="line">//   beginsAfterIndex == 0,</comment>
    <comment type="line">//   beginsAfterIndex points to a range whose end point does not equal</comment>
    <comment type="line">//     the given interval's end point</comment>
    <comment type="line">//   beginsOnOrAfter points to a range whose end point equals the given</comment>
    <comment type="line">//     interval's end point</comment>
    <comment type="line">// In the final case, there can be two such ranges, an adjacent range, and</comment>
    <comment type="line">// a collapsed range (they will appear in mRanges in that order). For this</comment>
    <comment type="line">// final case, we only need to take action if both those ranges exist, and</comment>
    <comment type="line">// we are pointing to the collapsed range - we need to point to the</comment>
    <comment type="line">// adjacent range</comment>
    <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>beginRange</name> <init>= <expr><name><name>mRanges</name><index>[<expr><name>beginsAfterIndex</name></expr>]</index></name>.<name>mRange</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>beginsAfterIndex</name> &gt; 0 &amp;&amp; <call><name><name>beginRange</name>-&gt;<name>Collapsed</name></name><argument_list>()</argument_list></call> &amp;&amp;
        <call><name>RangeMatchesEndPoint</name><argument_list>(<argument><expr><name>beginRange</name></expr></argument>, <argument><expr><name>aBeginNode</name></expr></argument>, <argument><expr><name>aBeginOffset</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>beginRange</name> = <name><name>mRanges</name><index>[<expr><name>beginsAfterIndex</name> - 1</expr>]</index></name>.<name>mRange</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>RangeMatchesEndPoint</name><argument_list>(<argument><expr><name>beginRange</name></expr></argument>, <argument><expr><name>aBeginNode</name></expr></argument>, <argument><expr><name>aBeginOffset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>beginsAfterIndex</name>--</expr>;</expr_stmt></then></if>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <comment type="line">// See above for the possibilities at this point. The only case where we</comment>
    <comment type="line">// need to take action is when the range at beginsAfterIndex ends on</comment>
    <comment type="line">// the given interval's start point, but that range isn't collapsed (a</comment>
    <comment type="line">// collapsed range should be included in the returned results).</comment>
    <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>beginRange</name> <init>= <expr><name><name>mRanges</name><index>[<expr><name>beginsAfterIndex</name></expr>]</index></name>.<name>mRange</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>RangeMatchesEndPoint</name><argument_list>(<argument><expr><name>beginRange</name></expr></argument>, <argument><expr><name>aBeginNode</name></expr></argument>, <argument><expr><name>aBeginOffset</name></expr></argument>)</argument_list></call> &amp;&amp;
        !<call><name><name>beginRange</name>-&gt;<name>Collapsed</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
      <expr_stmt><expr><name>beginsAfterIndex</name>++</expr>;</expr_stmt></then></if>

    <comment type="line">// Again, see above for the meaning of endsBeforeIndex at this point.</comment>
    <comment type="line">// In particular, endsBeforeIndex may point to a collaped range which</comment>
    <comment type="line">// represents the point at the end of the interval - this range should be</comment>
    <comment type="line">// included</comment>
    <if>if <condition>(<expr><name>endsBeforeIndex</name> &lt; (<name>PRInt32</name>) <call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>endRange</name> <init>= <expr><name><name>mRanges</name><index>[<expr><name>endsBeforeIndex</name></expr>]</index></name>.<name>mRange</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>RangeMatchesBeginPoint</name><argument_list>(<argument><expr><name>endRange</name></expr></argument>, <argument><expr><name>aEndNode</name></expr></argument>, <argument><expr><name>aEndOffset</name></expr></argument>)</argument_list></call> &amp;&amp;
          <call><name><name>endRange</name>-&gt;<name>Collapsed</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>endsBeforeIndex</name>++</expr>;</expr_stmt></then></if>
     }</block></then></if>
  }</block></else></if>

  <expr_stmt><expr>*<name>aStartIndex</name> = <name>beginsAfterIndex</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aEndIndex</name> = <name>endsBeforeIndex</name></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>

<comment type="line">//utility method to get the primary frame of node or use the offset to get frame of child node</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
NS_IMETHODIMP
nsTypedSelection::GetPrimaryFrameForRangeEndpoint(nsIDOMNode *aNode, PRInt32 aOffset, PRBool aIsEndNode, nsIFrame **aReturnFrame)
{
  if (!aNode || !aReturnFrame || !mFrameSelection)
    return NS_ERROR_NULL_POINTER;
  
  if (aOffset &lt; 0)
    return NS_ERROR_FAILURE;

  *aReturnFrame = 0;
  
  nsresult  result = NS_OK;
  
  nsCOMPtr&lt;nsIDOMNode&gt; node = aNode;

  if (!node)
    return NS_ERROR_NULL_POINTER;
  
  nsCOMPtr&lt;nsIContent&gt; content = do_QueryInterface(node, &amp;result);

  if (NS_FAILED(result))
    return result;

  if (!content)
    return NS_ERROR_NULL_POINTER;
  
  if (content-&gt;IsElement())
  {
    if (aIsEndNode)
      aOffset--;

    if (aOffset &gt;= 0)
    {
      nsIContent *child = content-&gt;GetChildAt(aOffset);
      if (!child) <comment type="line">//out of bounds?</comment>
        return NS_ERROR_FAILURE;

      content = child; <comment type="line">// releases the focusnode</comment>
    }
  }
  *aReturnFrame = content-&gt;GetPrimaryFrame();
  return NS_OK;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetPrimaryFrameForAnchorNode</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name> **</type><name>aReturnFrame</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aReturnFrame</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>frameOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>aReturnFrame</name> = 0</expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name>GetAnchorNode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>content</name> &amp;&amp; <name>mFrameSelection</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr>*<name>aReturnFrame</name> = <call><name><name>mFrameSelection</name>-&gt;
      <name>GetFrameForNodeOffset</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><call><name>GetAnchorOffset</name><argument_list>()</argument_list></call></expr></argument>,
                            <argument><expr><call><name><name>mFrameSelection</name>-&gt;<name>GetHint</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>frameOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>aReturnFrame</name></expr>)</condition><then>
      <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  }</block></then></if>
  <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetPrimaryFrameForFocusNode</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name> **</type><name>aReturnFrame</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aOffsetUsed</name></decl></param>,
                                              <param><decl><type><name>PRBool</name></type> <name>aVisual</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aReturnFrame</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name>GetFocusNode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>content</name> || !<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  
  <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>presShell</name> <init>= <expr><call><name><name>mFrameSelection</name>-&gt;<name>GetShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>frameOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>aReturnFrame</name> = 0</expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>aOffsetUsed</name></expr>)</condition><then>
    <expr_stmt><expr><name>aOffsetUsed</name> = &amp;<name>frameOffset</name></expr>;</expr_stmt></then></if>
    
  <decl_stmt><decl><type><name><name>nsFrameSelection</name>::<name>HINT</name></name></type> <name>hint</name> <init>= <expr><call><name><name>mFrameSelection</name>-&gt;<name>GetHint</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>aVisual</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCaret</name></expr></argument>&gt;</argument_list></name></type> <name>caret</name> <init>= <expr><call><name><name>presShell</name>-&gt;<name>GetCaret</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>caret</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    
    <decl_stmt><decl><type><name>PRUint8</name></type> <name>caretBidiLevel</name> <init>= <expr><call><name><name>mFrameSelection</name>-&gt;<name>GetCaretBidiLevel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name><name>caret</name>-&gt;<name>GetCaretFrameForNodeOffset</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><call><name>GetFocusOffset</name><argument_list>()</argument_list></call></expr></argument>,
      <argument><expr><name>hint</name></expr></argument>, <argument><expr><name>caretBidiLevel</name></expr></argument>, <argument><expr><name>aReturnFrame</name></expr></argument>, <argument><expr><name>aOffsetUsed</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  
  <expr_stmt><expr>*<name>aReturnFrame</name> = <call><name><name>mFrameSelection</name>-&gt;
    <name>GetFrameForNodeOffset</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><call><name>GetFocusOffset</name><argument_list>()</argument_list></call></expr></argument>,
                          <argument><expr><name>hint</name></expr></argument>, <argument><expr><name>aOffsetUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!*<name>aReturnFrame</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//select all content children of aContent</comment>
<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>SelectAllFramesForContent</name></name><parameter_list>(<param><decl><type><name>nsIContentIterator</name> *</type><name>aInnerIter</name></decl></param>,
                                  <param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>,
                                  <param><decl><type><name>PRBool</name></type> <name>aSelected</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if> <comment type="line">// nothing to do</comment>
  <decl_stmt><decl><type><name>nsIPresShell</name>*</type> <name>shell</name> <init>= <expr><call><name><name>mFrameSelection</name>-&gt;<name>GetShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>shell</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>aInnerIter</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  <expr_stmt><expr><name>result</name> = <call><name><name>aInnerIter</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>frame</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <comment type="line">// First select frame of content passed in</comment>
    <expr_stmt><expr><name>frame</name> = <call><name><name>aContent</name>-&gt;<name>GetPrimaryFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>frame</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name><name>frame</name>-&gt;<name>SetSelected</name></name><argument_list>(<argument><expr><name>aSelected</name></expr></argument>, <argument><expr><name>mType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name><name>mFrameSelection</name>-&gt;<name>GetTableCellSelection</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>nsITableCellLayout</name> *</type><name>tcl</name> <init>= <expr><call><name>do_QueryFrame</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>tcl</name></expr>)</condition><then>
        <block>{
          <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
    <comment type="line">// Now iterated through the child frames and set them</comment>
    <while>while <condition>(<expr>!<call><name><name>aInnerIter</name>-&gt;<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>innercontent</name> <init>=
        <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name><name>aInnerIter</name>-&gt;<name>GetCurrentNode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>frame</name> = <call><name><name>innercontent</name>-&gt;<name>GetPrimaryFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>frame</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><call><name><name>frame</name>-&gt;<name>SetSelected</name></name><argument_list>(<argument><expr><name>aSelected</name></expr></argument>, <argument><expr><name>mType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <expr_stmt><expr><call><name><name>aInnerIter</name>-&gt;<name>Next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
}</block></function>



<comment type="line">//the idea of this helper method is to select, deselect "top to bottom" traversing through the frames</comment>
<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>selectFrames</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>, <param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aFlags</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mFrameSelection</name> || !<name>aPresContext</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if> <comment type="line">// nothing to do</comment>
  <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>presShell</name> <init>= <expr><call><name><name>aPresContext</name>-&gt;<name>GetPresShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>presShell</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <comment type="line">// Re-get shell because the flush might have destroyed it </comment>
  <expr_stmt><expr><name>presShell</name> = <call><name><name>aPresContext</name>-&gt;<name>GetPresShell</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>presShell</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMRange</name></expr></argument>&gt;</argument_list></name></type> <name>domRange</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>domRange</name> || !<name>aPresContext</name></expr>)</condition><then> 
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContentIterator</name></expr></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name>do_CreateInstance</name><argument_list>(
                                              <argument><expr><name>kCSubtreeIteratorCID</name></expr></argument>,
                                              <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContentIterator</name></expr></argument>&gt;</argument_list></name></type> <name>inneriter</name> <init>= <expr><call><name>do_CreateInstance</name><argument_list>(
                                              <argument><expr><name>kCContentIteratorCID</name></expr></argument>,
                                              <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>(<call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>) &amp;&amp; <name>iter</name> &amp;&amp; <name>inneriter</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>result</name> = <call><name><name>iter</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// loop through the content iterator for each content node</comment>
    <comment type="line">// for each text node, call SetSelected on it:</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// we must call first one explicitly</comment>
    <if>if <condition>(<expr>!<name>content</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name><name>content</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eTEXT</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name><name>content</name>-&gt;<name>GetPrimaryFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// The frame could be an SVG text frame, in which case we'll ignore</comment>
      <comment type="line">// it.</comment>
      <if>if <condition>(<expr><name>frame</name> &amp;&amp; <call><name><name>frame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>textFrame</name></name></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>nsTextFrame</name>*</type> <name>textFrame</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTextFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>startOffset</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>endOffset</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>aRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call> == <name>content</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>endOffset</name> = <call><name><name>aRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><name>endOffset</name> = <call><name><name>content</name>-&gt;<name>GetText</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetLength</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name><name>textFrame</name>-&gt;<name>SetSelectedRange</name></name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>, <argument><expr><name>endOffset</name></expr></argument>, <argument><expr><name>aFlags</name></expr></argument>, <argument><expr><name>mType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>iter</name>-&gt;<name>First</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr>!<call><name><name>iter</name>-&gt;<name>IsDone</name></name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{
      <expr_stmt><expr><name>content</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name><name>iter</name>-&gt;<name>GetCurrentNode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SelectAllFramesForContent</name><argument_list>(<argument><expr><name>inneriter</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>aFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name><name>iter</name>-&gt;<name>Next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <comment type="line">//we must now do the last one  if it is not the same as the first</comment>
    <if>if <condition>(<expr><call><name><name>aRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call> != <call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>content</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name><name>aRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> || !<name>content</name></expr>)</condition><then>
        <return>return <expr><name>result</name></expr>;</return></then></if>

      <if>if <condition>(<expr><call><name><name>content</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eTEXT</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name><name>content</name>-&gt;<name>GetPrimaryFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// The frame could be an SVG text frame, in which case we'll</comment>
        <comment type="line">// ignore it.</comment>
        <if>if <condition>(<expr><name>frame</name> &amp;&amp; <call><name><name>frame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>textFrame</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>nsTextFrame</name>*</type> <name>textFrame</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTextFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>textFrame</name>-&gt;<name>SetSelectedRange</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>aRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aFlags</name></expr></argument>, <argument><expr><name>mType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="line">// nsTypedSelection::LookUpSelection</comment>
<comment type="line">//</comment>
<comment type="line">//    This function is called when a node wants to know where the selection is</comment>
<comment type="line">//    over itself.</comment>
<comment type="line">//</comment>
<comment type="line">//    Usually, this is called when we already know there is a selection over</comment>
<comment type="line">//    the node in question, and we only need to find the boundaries of it on</comment>
<comment type="line">//    that node. This is when slowCheck is false--a strict test is not needed.</comment>
<comment type="line">//    Other times, the caller has no idea, and wants us to test everything,</comment>
<comment type="line">//    so we are supposed to determine whether there is a selection over the</comment>
<comment type="line">//    node at all.</comment>
<comment type="line">//</comment>
<comment type="line">//    A previous version of this code used this flag to do less work when</comment>
<comment type="line">//    inclusion was already known (slowCheck=false). However, our tree</comment>
<comment type="line">//    structure allows us to quickly determine ranges overlapping the node,</comment>
<comment type="line">//    so we just ignore the slowCheck flag and do the full test every time.</comment>
<comment type="line">//</comment>
<comment type="line">//    PERFORMANCE: a common case is that we are doing a fast check with exactly</comment>
<comment type="line">//    one range in the selection. In this case, this function is slower than</comment>
<comment type="line">//    brute force because of the overhead of checking the tree. We can optimize</comment>
<comment type="line">//    this case to make it faster by doing the same thing the previous version</comment>
<comment type="line">//    of this function did in the case of 1 range. This would also mean that</comment>
<comment type="line">//    the aSlowCheck flag would have meaning again.</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>LookUpSelection</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aContentOffset</name></decl></param>,
                                  <param><decl><type><name>PRInt32</name></type> <name>aContentLength</name></decl></param>,
                                  <param><decl><type><name>SelectionDetails</name> **</type><name>aReturnDetails</name></decl></param>,
                                  <param><decl><type><name>SelectionType</name></type> <name>aType</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aSlowCheck</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>aContent</name> || ! <name>aReturnDetails</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <comment type="line">// it is common to have no ranges, to optimize that</comment>
  <if>if <condition>(<expr><call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>overlappingRanges</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name>GetRangesForIntervalCOMArray</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>aContentOffset</name></expr></argument>,
                                    <argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>aContentOffset</name> + <name>aContentLength</name></expr></argument>,
                                    <argument><expr><name>PR_FALSE</name></expr></argument>,
                                    <argument><expr>&amp;<name>overlappingRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name><name>overlappingRanges</name>.<name>Count</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>overlappingRanges</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name> ++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>range</name> <init>= <expr><name><name>overlappingRanges</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsINode</name>*</type> <name>startNode</name> <init>= <expr><call><name><name>range</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsINode</name>*</type> <name>endNode</name> <init>= <expr><call><name><name>range</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>startOffset</name> <init>= <expr><call><name><name>range</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>endOffset</name> <init>= <expr><call><name><name>range</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>start</name> <init>= <expr>-1</expr></init>, <name>end</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>startNode</name> == <name>aContent</name> &amp;&amp; <name>endNode</name> == <name>aContent</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name><name>startOffset</name> <argument_list>&lt; <argument><expr>(<name>aContentOffset</name> + <name>aContentLength</name>)  &amp;&amp;
          <name>endOffset</name></expr></argument> &gt;</argument_list></name> <name>aContentOffset</name></expr>)</condition><then> <block>{
        <comment type="line">// this range is totally inside the requested content range</comment>
        <expr_stmt><expr><name>start</name> = <call><name>NS_MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>startOffset</name> - <name>aContentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>end</name> = <call><name>NS_MIN</name><argument_list>(<argument><expr><name>aContentLength</name></expr></argument>, <argument><expr><name>endOffset</name> - <name>aContentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <comment type="line">// otherwise, range is inside the requested node, but does not intersect</comment>
      <comment type="line">// the requested content range, so ignore it</comment>
    }</block></then> <else>else <if>if <condition>(<expr><name>startNode</name> == <name>aContent</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>startOffset</name> &lt; (<name>aContentOffset</name> + <name>aContentLength</name>)</expr>)</condition><then> <block>{
        <comment type="line">// the beginning of the range is inside the requested node, but the</comment>
        <comment type="line">// end is outside, select everything from there to the end</comment>
        <expr_stmt><expr><name>start</name> = <call><name>NS_MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>startOffset</name> - <name>aContentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>end</name> = <name>aContentLength</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>endNode</name> == <name>aContent</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>endOffset</name> &gt; <name>aContentOffset</name></expr>)</condition><then> <block>{
        <comment type="line">// the end of the range is inside the requested node, but the beginning</comment>
        <comment type="line">// is outside, select everything from the beginning to there</comment>
        <expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>end</name> = <call><name>NS_MIN</name><argument_list>(<argument><expr><name>aContentLength</name></expr></argument>, <argument><expr><name>endOffset</name> - <name>aContentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then> <else>else <block>{
      <comment type="line">// this range does not begin or end in the requested node, but since</comment>
      <comment type="line">// GetRangesForInterval returned this range, we know it overlaps.</comment>
      <comment type="line">// Therefore, this node is enclosed in the range, and we select all</comment>
      <comment type="line">// of it.</comment>
      <expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>end</name> = <name>aContentLength</name></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>
    <if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
      <continue>continue;</continue></then></if> <comment type="line">// the ranges do not overlap the input range</comment>

    <decl_stmt><decl><type><name>SelectionDetails</name>*</type> <name>details</name> <init>= <expr>new <name>SelectionDetails</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>details</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>details</name>-&gt;<name>mNext</name></name> = *<name>aReturnDetails</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>details</name>-&gt;<name>mStart</name></name> = <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>details</name>-&gt;<name>mEnd</name></name> = <name>end</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>details</name>-&gt;<name>mType</name></name> = <name>aType</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>RangeData</name> *</type><name>rd</name> <init>= <expr><call><name>FindRangeData</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rd</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>details</name>-&gt;<name>mTextRangeStyle</name></name> = <name><name>rd</name>-&gt;<name>mTextRangeStyle</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>aReturnDetails</name> = <name>details</name></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>Repaint</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>arrCount</name> <init>= <expr>(<name>PRInt32</name>)<call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>arrCount</name> &lt; 1</expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>;</decl_stmt>
  
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>arrCount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
  <block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name><name>mRanges</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mRange</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetCanCacheFrameOffset</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aCanCacheFrameOffset</name></decl></param>)</parameter_list>
<block>{ 
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aCanCacheFrameOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mCachedOffsetForFrame</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>aCanCacheFrameOffset</name> = <name><name>mCachedOffsetForFrame</name>-&gt;<name>mCanCacheFrameOffset</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>aCanCacheFrameOffset</name> = <name>PR_FALSE</name></expr>;</expr_stmt></else></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>    
<name><name>nsTypedSelection</name>::<name>SetCanCacheFrameOffset</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCanCacheFrameOffset</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mCachedOffsetForFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCachedOffsetForFrame</name> = new <name>CachedOffsetForFrame</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name><name>mCachedOffsetForFrame</name>-&gt;<name>mCanCacheFrameOffset</name></name> = <name>aCanCacheFrameOffset</name></expr>;</expr_stmt>

  <comment type="line">// clean up cached frame when turn off cache</comment>
  <comment type="line">// fix bug 207936</comment>
  <if>if <condition>(<expr>!<name>aCanCacheFrameOffset</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>mCachedOffsetForFrame</name>-&gt;<name>mLastCaretFrame</name></name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>    
<name><name>nsTypedSelection</name>::<name>GetCachedFrameOffset</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>inOffset</name></decl></param>, <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mCachedOffsetForFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCachedOffsetForFrame</name> = new <name>CachedOffsetForFrame</name></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>mCachedOffsetForFrame</name>-&gt;<name>mCanCacheFrameOffset</name></name> &amp;&amp;
      <name><name>mCachedOffsetForFrame</name>-&gt;<name>mLastCaretFrame</name></name> &amp;&amp;
      (<name>aFrame</name> == <name><name>mCachedOffsetForFrame</name>-&gt;<name>mLastCaretFrame</name></name>) &amp;&amp;
      (<name>inOffset</name> == <name><name>mCachedOffsetForFrame</name>-&gt;<name>mLastContentOffset</name></name>)</expr>)</condition><then>
  <block>{
     <comment type="line">// get cached frame offset</comment>
     <expr_stmt><expr><name>aPoint</name> = <name><name>mCachedOffsetForFrame</name>-&gt;<name>mCachedFrameOffset</name></name></expr>;</expr_stmt>
  }</block></then> 
  <else>else
  <block>{
     <comment type="line">// Recalculate frame offset and cache it. Don't cache a frame offset if</comment>
     <comment type="line">// GetPointFromOffset fails, though.</comment>
     <expr_stmt><expr><name>rv</name> = <call><name><name>aFrame</name>-&gt;<name>GetPointFromOffset</name></name><argument_list>(<argument><expr><name>inOffset</name></expr></argument>, <argument><expr>&amp;<name>aPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>mCachedOffsetForFrame</name>-&gt;<name>mCanCacheFrameOffset</name></name></expr>)</condition><then> <block>{
       <expr_stmt><expr><name><name>mCachedOffsetForFrame</name>-&gt;<name>mCachedFrameOffset</name></name> = <name>aPoint</name></expr>;</expr_stmt>
       <expr_stmt><expr><name><name>mCachedOffsetForFrame</name>-&gt;<name>mLastCaretFrame</name></name> = <name>aFrame</name></expr>;</expr_stmt>
       <expr_stmt><expr><name><name>mCachedOffsetForFrame</name>-&gt;<name>mLastContentOffset</name></name> = <name>inOffset</name></expr>;</expr_stmt> 
     }</block></then></if>
  }</block></else></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetFrameSelection</name></name><parameter_list>(<param><decl><type><name>nsFrameSelection</name> **</type><name>aFrameSelection</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aFrameSelection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aFrameSelection</name> = <name>mFrameSelection</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aFrameSelection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>SetAncestorLimiter</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mFrameSelection</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>SetAncestorLimiter</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>RangeData</name>*</type>
<name><name>nsTypedSelection</name>::<name>FindRangeData</name></name><parameter_list>(<param><decl><type><name>nsIDOMRange</name>*</type> <name>aRange</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <if>if <condition>(<expr><name><name>mRanges</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mRange</name> == <name>aRange</name></expr>)</condition><then>
      <return>return <expr>&amp;<name><name>mRanges</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></then></if>
  }</block></for>
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>SetTextRangeStyle</name></name><parameter_list>(<param><decl><type><name>nsIDOMRange</name> *</type><name>aRange</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>nsTextRangeStyle</name> &amp;</type><name>aTextRangeStyle</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>RangeData</name> *</type><name>rd</name> <init>= <expr><call><name>FindRangeData</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>rd</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>rd</name>-&gt;<name>mTextRangeStyle</name></name> = <name>aTextRangeStyle</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>StartAutoScrollTimer</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>,
                                       <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>,
                                       <param><decl><type><name>PRUint32</name></type> <name>aDelay</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>"Need a frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if><comment type="line">//nothing to do</comment>

  <if>if <condition>(<expr>!<name>mAutoScrollTimer</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>mAutoScrollTimer</name> = new <call><name>nsAutoScrollTimer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>mAutoScrollTimer</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><name>result</name> = <call><name><name>mAutoScrollTimer</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>mFrameSelection</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>result</name></expr>;</return></then></if>
  }</block></then></if>

  <expr_stmt><expr><name>result</name> = <call><name><name>mAutoScrollTimer</name>-&gt;<name>SetDelay</name></name><argument_list>(<argument><expr><name>aDelay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>

  <return>return <expr><call><name>DoAutoScroll</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aPoint</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>StopAutoScrollTimer</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mAutoScrollTimer</name></expr>)</condition><then>
    <return>return <expr><call><name><name>mAutoScrollTimer</name>-&gt;<name>Stop</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return> 
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>DoAutoScroll</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>, <param><decl><type><name>nsPoint</name>&amp;</type> <name>aPoint</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>"Need a frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>mAutoScrollTimer</name></expr>)</condition><then>
    <expr_stmt><expr><name>result</name> = <call><name><name>mAutoScrollTimer</name>-&gt;<name>Stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRootPresContext</name>*</type> <name>rootPC</name> <init>= <expr><call><name><name>presContext</name>-&gt;<name>GetRootPresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>rootPC</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootmostFrame</name> <init>= <expr><call><name><name>rootPC</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call>-&gt;<call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// Get the point relative to the root most frame because the scroll we are</comment>
  <comment type="line">// about to do will change the coordinates of aFrame.</comment>
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>globalPoint</name> <init>= <expr><name>aPoint</name> + <call><name><name>aFrame</name>-&gt;<name>GetOffsetToCrossDoc</name></name><argument_list>(<argument><expr><name>rootmostFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>didScroll</name> <init>= <expr><call><name><name>presContext</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call>-&gt;
    <call><name>ScrollFrameRectIntoView</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><name>aPoint</name></expr></argument>, <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>NS_PRESSHELL_SCROLL_ANYWHERE</name></expr></argument>,
                            <argument><expr><name>NS_PRESSHELL_SCROLL_ANYWHERE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">//</comment>
  <comment type="line">// Start the AutoScroll timer if necessary.</comment>
  <comment type="line">//</comment>

  <if>if <condition>(<expr><name>didScroll</name> &amp;&amp; <name>mAutoScrollTimer</name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>nsPoint</name></type> <name>presContextPoint</name> <init>= <expr><name>globalPoint</name> -
      <call><name><name>presContext</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call>-&gt;<call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call>-&gt;<call><name>GetOffsetToCrossDoc</name><argument_list>(<argument><expr><name>rootmostFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mAutoScrollTimer</name>-&gt;<name>Start</name></name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>presContextPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetEnumerator</name></name><parameter_list>(<param><decl><type><name>nsIEnumerator</name> **</type><name>aIterator</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>status</name> <init>= <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsSelectionIterator</name> *</type><name>iterator</name> <init>=  <expr>new <call><name>nsSelectionIterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>iterator</name> &amp;&amp; <call><name>NS_FAILED</name><argument_list>(<argument><expr><name>status</name> = <call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>, <argument><expr><name>aIterator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><then>
    <expr_stmt><expr>delete <name>iterator</name></expr>;</expr_stmt></then></if>
  <return>return <expr><name>status</name></expr>;</return>
}</block></function>



<comment type="block" format="doxygen">/** RemoveAllRanges zeroes the selection
 */</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>RemoveAllRanges</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if><comment type="line">//nothing to do</comment>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsPresContext</name></expr></argument>&gt;</argument_list></name></type>  <name>presContext</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetPresContext</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <decl_stmt><decl><type><name>nsresult</name></type>  <name>result</name> <init>= <expr><call><name>Clear</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>
  
  <comment type="line">// Turn off signal for table selection</comment>
  <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>ClearTableCellSelection</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>mFrameSelection</name>-&gt;<name>NotifySelectionListeners</name></name><argument_list>(<argument><expr><call><name>GetType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  <comment type="line">// Also need to notify the frames!</comment>
  <comment type="line">// PresShell::CharacterDataChanged should do that on DocumentChanged</comment>
}</block></function>

<comment type="block" format="doxygen">/** AddRange adds the specified range to the selection
 *  @param aRange is the range to be added
 */</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>AddRange</name></name><parameter_list>(<param><decl><type><name>nsIDOMRange</name>*</type> <name>aRange</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>AddRange</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>AddRange</name></name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aRange</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <comment type="line">// This inserts a table cell range in proper document order</comment>
  <comment type="line">// and returns NS_OK if range doesn't contain just one table cell</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>didAddRange</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rangeIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name>addTableCellRange</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>, <argument><expr>&amp;<name>didAddRange</name></expr></argument>, <argument><expr>&amp;<name>rangeIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>

  <if>if <condition>(<expr>!<name>didAddRange</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>result</name> = <call><name>AddItem</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>, <argument><expr>&amp;<name>rangeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>rangeIndex</name> &gt;= 0</expr></argument>, <argument><expr>"Range index not returned"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setAnchorFocusRange</name><argument_list>(<argument><expr><name>rangeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// Make sure the caret appears on the next line, if at a newline</comment>
  <if>if <condition>(<expr><name>mType</name> == <name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SetInterlinePosition</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsPresContext</name></expr></argument>&gt;</argument_list></name></type>  <name>presContext</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetPresContext</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>aRange</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        

  <comment type="line">//ScrollIntoView(); this should not happen automatically</comment>
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if><comment type="line">//nothing to do</comment>

  <return>return <expr><call><name><name>mFrameSelection</name>-&gt;<name>NotifySelectionListeners</name></name><argument_list>(<argument><expr><call><name>GetType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// nsTypedSelection::RemoveRange</comment>
<comment type="line">//</comment>
<comment type="line">//    Removes the given range from the selection. The tricky part is updating</comment>
<comment type="line">//    the flags on the frames that indicate whether they have a selection or</comment>
<comment type="line">//    not. There could be several selection ranges on the frame, and clearing</comment>
<comment type="line">//    the bit would cause the selection to not be drawn, even when there is</comment>
<comment type="line">//    another range on the frame (bug 346185).</comment>
<comment type="line">//</comment>
<comment type="line">//    We therefore find any ranges that intersect the same nodes as the range</comment>
<comment type="line">//    being removed, and cause them to set the selected bits back on their</comment>
<comment type="line">//    selected frames after we've cleared the bit from ours.</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>RemoveRange</name></name><parameter_list>(<param><decl><type><name>nsIDOMRange</name>*</type> <name>aRange</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>RemoveRange</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>RemoveRange</name></name><parameter_list>(<param><decl><type><name>nsIRange</name>*</type> <name>aRange</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aRange</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>RemoveItem</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>rv</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>beginNode</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>endNode</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <comment type="line">// find out the length of the end node, so we can select all of it</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>beginOffset</name></decl>, <decl><type ref="prev"/><name>endOffset</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>endNode</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eTEXT</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Get the length of the text. We can't just use the offset because</comment>
    <comment type="line">// another range could be touching this text node but not intersect our</comment>
    <comment type="line">// range.</comment>
    <expr_stmt><expr><name>beginOffset</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>endOffset</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIContent</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>endNode</name></expr></argument>)</argument_list></call>-&gt;<call><name>TextLength</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// For non-text nodes, the given offsets should be sufficient.</comment>
    <expr_stmt><expr><name>beginOffset</name> = <call><name><name>aRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>endOffset</name> = <call><name><name>aRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="line">// clear the selected bit from the removed range's frames</comment>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsPresContext</name></expr></argument>&gt;</argument_list></name></type>  <name>presContext</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetPresContext</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>aRange</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// add back the selected bit for each range touching our nodes</comment>
  <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>affectedRanges</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name>GetRangesForIntervalCOMArray</name><argument_list>(<argument><expr><name>beginNode</name></expr></argument>, <argument><expr><name>beginOffset</name></expr></argument>,
                                    <argument><expr><name>endNode</name></expr></argument>, <argument><expr><name>endOffset</name></expr></argument>,
                                    <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr>&amp;<name>affectedRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>affectedRanges</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name> ++</expr></incr>) <block>{
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name><name>affectedRanges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cnt</name> <init>= <expr><call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aRange</name> == <name>mAnchorFocusRange</name></expr>)</condition><then> <block>{
    <comment type="line">// Reset anchor to LAST range or clear it if there are no ranges.</comment>
    <expr_stmt><expr><call><name>setAnchorFocusRange</name><argument_list>(<argument><expr><name>cnt</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// When the selection is user-created it makes sense to scroll the range</comment>
    <comment type="line">// into view. The spell-check selection, however, is created and destroyed</comment>
    <comment type="line">// in the background. We don't want to scroll in this case or the view</comment>
    <comment type="line">// might appear to be moving randomly (bug 337871).</comment>
    <if>if <condition>(<expr><name>mType</name> != <name><name>nsISelectionController</name>::<name>SELECTION_SPELLCHECK</name></name> &amp;&amp; <name>cnt</name> &gt; 0</expr>)</condition><then>
      <expr_stmt><expr><call><name>ScrollIntoView</name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_FOCUS_REGION</name></name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                     <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if><comment type="line">//nothing to do</comment>
  <return>return <expr><call><name><name>mFrameSelection</name>-&gt;<name>NotifySelectionListeners</name></name><argument_list>(<argument><expr><call><name>GetType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<comment type="block">/*
 * Collapse sets the whole selection to be one point.
 */</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>Collapse</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aParentNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsINode</name></expr></argument>&gt;</argument_list></name></type> <name>parentNode</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>Collapse</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>Collapse</name></name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aParentNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aParentNode</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return></then></if> <comment type="line">// Can't do selection</comment>
  <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>InvalidateDesiredX</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name>IsValidSelectionPoint</name><argument_list>(<argument><expr><name>mFrameSelection</name></expr></argument>, <argument><expr><name>aParentNode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>
  <comment type="line">// Delete all of the current ranges</comment>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsPresContext</name></expr></argument>&gt;</argument_list></name></type>  <name>presContext</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetPresContext</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Clear</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Turn off signal for table selection</comment>
  <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>ClearTableCellSelection</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr>new <call><name>nsRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>range</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>,<argument><expr>"Couldn't make a range - nsFrameSelection::Collapse"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>result</name> = <call><name><name>range</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>
  <expr_stmt><expr><name>result</name> = <call><name><name>range</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SELECTION</name></cpp:ifdef>
  <if>if <condition>(<expr><name>aParentNode</name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type><name>content</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>content</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>content</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr>"Sel. Collapse to %p %s %d\n"</expr></argument>, <argument><expr><call><name><name>content</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><call><name>nsAtomCString</name><argument_list>(<argument><expr><call><name><name>content</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr>"Sel. Collapse set to null parent.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


  <expr_stmt><expr><name>result</name> = <call><name>AddItem</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setAnchorFocusRange</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>
  <return>return <expr><call><name><name>mFrameSelection</name>-&gt;<name>NotifySelectionListeners</name></name><argument_list>(<argument><expr><call><name>GetType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Sets the whole selection to be one point
 * at the start of the current selection
 */</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>CollapseToStart</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cnt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetRangeCount</name><argument_list>(<argument><expr>&amp;<name>cnt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> || <name>cnt</name> &lt;= 0</expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <comment type="line">// Get the first range</comment>
  <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>firstRange</name> <init>= <expr><name><name>mRanges</name><index>[<expr>0</expr>]</index></name>.<name>mRange</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>firstRange</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <return>return <expr><call><name>Collapse</name><argument_list>(<argument><expr><call><name><name>firstRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>firstRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Sets the whole selection to be one point
 * at the end of the current selection
 */</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>CollapseToEnd</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cnt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetRangeCount</name><argument_list>(<argument><expr>&amp;<name>cnt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> || <name>cnt</name> &lt;= 0</expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <comment type="line">// Get the last range</comment>
  <decl_stmt><decl><type><name>nsIRange</name>*</type> <name>lastRange</name> <init>= <expr><name><name>mRanges</name><index>[<expr><name>cnt</name>-1</expr>]</index></name>.<name>mRange</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>lastRange</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <return>return <expr><call><name>Collapse</name><argument_list>(<argument><expr><call><name><name>lastRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>lastRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * IsCollapsed -- is the whole selection just one point, or unset?
 */</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetIsCollapsed</name></name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>aIsCollapsed</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aIsCollapsed</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cnt</name> <init>= <expr>(<name>PRInt32</name>)<call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>
  <if>if <condition>(<expr><name>cnt</name> == 0</expr>)</condition><then>
  <block>{
    <expr_stmt><expr>*<name>aIsCollapsed</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  
  <if>if <condition>(<expr><name>cnt</name> != 1</expr>)</condition><then>
  <block>{
    <expr_stmt><expr>*<name>aIsCollapsed</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  
  <expr_stmt><expr>*<name>aIsCollapsed</name> = <name><name>mRanges</name><index>[<expr>0</expr>]</index></name>.<call><name><name>mRange</name>-&gt;<name>Collapsed</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetRangeCount</name></name><parameter_list>(<param><decl><type><name>PRInt32</name>*</type> <name>aRangeCount</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aRangeCount</name> = (<name>PRInt32</name>)<call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>GetRangeAt</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aIndex</name></decl></param>, <param><decl><type><name>nsIDOMRange</name>**</type> <name>aReturn</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aReturn</name> = <call><name><name>mRanges</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>, <argument><expr><name>sEmptyData</name></expr></argument>)</argument_list></call>.<name>mRange</name></expr>;</expr_stmt>
  <if>if <condition>(<expr>!*<name>aReturn</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aReturn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsIRange</name>*</type>
<name><name>nsTypedSelection</name>::<name>GetRangeAt</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aIndex</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mRanges</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>, <argument><expr><name>sEmptyData</name></expr></argument>)</argument_list></call>.<name>mRange</name></expr>;</return>
}</block></function>

<comment type="block">/*
utility function
*/</comment>
<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>CopyRangeToAnchorFocus</name></name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// XXXbz could we just clone into mAnchorFocusRange, or do consumers</comment>
  <comment type="line">// expect that pointer to not change across this call?</comment>
  <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>mAnchorFocusRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>startNode</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>endNode</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startOffset</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>endOffset</name> <init>= <expr><call><name><name>aRange</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>startNode</name></expr></argument>,<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <comment type="line">// XXXbz what is this doing exactly?</comment>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>endNode</name></expr></argument>,<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if><comment type="line">//???</comment>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>startNode</name></expr></argument>,<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if><comment type="line">//???</comment>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name><name>mAnchorFocusRange</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>endNode</name></expr></argument>,<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
          <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if></else></if><comment type="line">//???</comment>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTypedSelection</name>::<name>ReplaceAnchorFocusRange</name></name><parameter_list>(<param><decl><type><name>nsIRange</name> *</type><name>aRange</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsPresContext</name></expr></argument>&gt;</argument_list></name></type> <name>presContext</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetPresContext</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>presContext</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>mAnchorFocusRange</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CopyRangeToAnchorFocus</name><argument_list>(<argument><expr><name>aRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>mAnchorFocusRange</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
Notes which might come in handy for extend:

We can tell the direction of the selection by asking for the anchors selection
if the begin is less than the end then we know the selection is to the "right".
else it is a backwards selection.
a = anchor
1 = old cursor
2 = new cursor

  if (a &lt;= 1 &amp;&amp; 1 &lt;=2)    a,1,2  or (a1,2)
  if (a &lt; 2 &amp;&amp; 1 &gt; 2)     a,2,1
  if (1 &lt; a &amp;&amp; a &lt;2)      1,a,2
  if (a &gt; 2 &amp;&amp; 2 &gt;1)      1,2,a
  if (2 &lt; a &amp;&amp; a &lt;1)      2,a,1
  if (a &gt; 1 &amp;&amp; 1 &gt;2)      2,1,a
then execute
a  1  2 select from 1 to 2
a  2  1 deselect from 2 to 1
1  a  2 deselect from 1 to a select from a to 2
1  2  a deselect from 1 to 2
2  1  a = continue selection from 2 to 1
*/</comment>


<comment type="block">/*
 * Extend extends the selection away from the anchor.
 * We don't need to know the direction, because we always change the focus.
 */</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>Extend</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aParentNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsINode</name></expr></argument>&gt;</argument_list></name></type> <name>parentNode</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>Extend</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>Extend</name></name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aParentNode</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aOffset</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aParentNode</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>

  <comment type="line">// First, find the range containing the old focus point:</comment>
  <if>if <condition>(<expr>!<name>mAnchorFocusRange</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return></then></if>

  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return></then></if> <comment type="line">// Can't do selection</comment>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>res</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>IsValidSelectionPoint</name><argument_list>(<argument><expr><name>mFrameSelection</name></expr></argument>, <argument><expr><name>aParentNode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <comment type="line">//mFrameSelection-&gt;InvalidateDesiredX();</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>difRange</name> <init>= <expr>new <call><name>nsRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>range</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>anchorNode</name> <init>= <expr><call><name>GetAnchorNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>focusNode</name> <init>= <expr><call><name>GetFocusNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>anchorOffset</name> <init>= <expr><call><name>GetAnchorOffset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>focusOffset</name> <init>= <expr><call><name>GetFocusOffset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>focusNode</name> == <name>aParentNode</name> &amp;&amp; <name>focusOffset</name> == <name>aOffset</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if> <comment type="line">//same node nothing to do!</comment>

  <expr_stmt><expr><name>res</name> = <call><name><name>mAnchorFocusRange</name>-&gt;<name>CloneRange</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>res</name></expr>;</return></then></if>
  <comment type="line">//range = mAnchorFocusRange;</comment>

  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>startNode</name> <init>= <expr><call><name><name>range</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsINode</name>*</type> <name>endNode</name> <init>= <expr><call><name><name>range</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startOffset</name> <init>= <expr><call><name><name>range</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>endOffset</name> <init>= <expr><call><name><name>range</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>

  <decl_stmt><decl><type><name>nsDirection</name></type> <name>dir</name> <init>= <expr><call><name>GetDirection</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">//compare anchor to old cursor.</comment>

  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>res</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>result1</name> <init>= <expr><call><name><name>nsContentUtils</name>::<name>ComparePoints</name></name><argument_list>(<argument><expr><name>anchorNode</name></expr></argument>, <argument><expr><name>anchorOffset</name></expr></argument>,
                                                  <argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>focusOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">//compare old cursor to new cursor</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>result2</name> <init>= <expr><call><name><name>nsContentUtils</name>::<name>ComparePoints</name></name><argument_list>(<argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>focusOffset</name></expr></argument>,
                                                  <argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">//compare anchor to new cursor</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>result3</name> <init>= <expr><call><name><name>nsContentUtils</name>::<name>ComparePoints</name></name><argument_list>(<argument><expr><name>anchorNode</name></expr></argument>, <argument><expr><name>anchorOffset</name></expr></argument>,
                                                  <argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>result2</name> == 0</expr>)</condition><then> <comment type="line">//not selecting anywhere</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsPresContext</name></expr></argument>&gt;</argument_list></name></type>  <name>presContext</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetPresContext</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name>result1</name> == 0 &amp;&amp; <name>result3</name> &lt; 0) || (<name>result1</name> &lt;= 0 &amp;&amp; <name>result2</name> &lt; 0)</expr>)</condition><then><block>{<comment type="line">//a1,2  a,1,2</comment>
    <comment type="line">//select from 1 to 2 unless they are collapsed</comment>
    <expr_stmt><expr><name>res</name> = <call><name><name>range</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><name>dir</name> = <name>eDirNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name><name>difRange</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><call><name><name>range</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>range</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> |= <call><name><name>difRange</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>focusOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>difRange</name></expr></argument> , <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>CopyRangeToAnchorFocus</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>result1</name> == 0 &amp;&amp; <name>result3</name> &gt; 0</expr>)</condition><then><block>{<comment type="line">//2, a1</comment>
    <comment type="line">//select from 2 to 1a</comment>
    <expr_stmt><expr><name>dir</name> = <name>eDirPrevious</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name><name>range</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>CopyRangeToAnchorFocus</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>result3</name> &lt;= 0 &amp;&amp; <name>result2</name> &gt;= 0</expr>)</condition><then> <block>{<comment type="line">//a,2,1 or a2,1 or a,21 or a21</comment>
    <comment type="line">//deselect from 2 to 1</comment>
    <expr_stmt><expr><name>res</name> = <call><name><name>difRange</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>focusOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> |= <call><name><name>difRange</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>

    <expr_stmt><expr><name>res</name> = <call><name><name>range</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><name>res</name> = <call><name>CopyRangeToAnchorFocus</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>difRange</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// deselect now</comment>
    <expr_stmt><expr><call><name><name>difRange</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><call><name><name>range</name>-&gt;<name>GetEndParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>range</name>-&gt;<name>EndOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>difRange</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// must reselect last node maybe more</comment>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>result1</name> &gt;= 0 &amp;&amp; <name>result3</name> &lt;= 0</expr>)</condition><then> <block>{<comment type="line">//1,a,2 or 1a,2 or 1,a2 or 1a2</comment>
    <if>if <condition>(<expr><call><name>GetDirection</name><argument_list>()</argument_list></call> == <name>eDirPrevious</name></expr>)</condition><then><block>{
      <expr_stmt><expr><name>res</name> = <call><name><name>range</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>endNode</name></expr></argument>, <argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>res</name></expr>;</return></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>dir</name> = <name>eDirNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name><name>range</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>focusNode</name> != <name>anchorNode</name> || <name>focusOffset</name> != <name>anchorOffset</name></expr>)</condition><then> <block>{<comment type="line">//if collapsed diff dont do anything</comment>
      <expr_stmt><expr><name>res</name> = <call><name><name>difRange</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>focusOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name> |= <call><name><name>difRange</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>anchorNode</name></expr></argument>, <argument><expr><name>anchorOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>res</name></expr>;</return></then></if>
      <expr_stmt><expr><name>res</name> = <call><name>CopyRangeToAnchorFocus</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>res</name></expr>;</return></then></if>
      <comment type="line">//deselect from 1 to a</comment>
      <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>difRange</name></expr></argument> , <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
    <block>{
      <expr_stmt><expr><name>res</name> = <call><name>CopyRangeToAnchorFocus</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>res</name></expr>;</return></then></if>
    }</block></else></if>
    <comment type="line">//select from a to 2</comment>
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>range</name></expr></argument> , <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>result2</name> &lt;= 0 &amp;&amp; <name>result3</name> &gt;= 0</expr>)</condition><then> <block>{<comment type="line">//1,2,a or 12,a or 1,2a or 12a</comment>
    <comment type="line">//deselect from 1 to 2</comment>
    <expr_stmt><expr><name>res</name> = <call><name><name>difRange</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> |= <call><name><name>difRange</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>focusOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><name>dir</name> = <name>eDirPrevious</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name><name>range</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>

    <expr_stmt><expr><name>res</name> = <call><name>CopyRangeToAnchorFocus</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>difRange</name></expr></argument> , <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>difRange</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><call><name><name>range</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>range</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>difRange</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="line">//must reselect last node</comment>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>result3</name> &gt;= 0 &amp;&amp; <name>result1</name> &lt;= 0</expr>)</condition><then> <block>{<comment type="line">//2,a,1 or 2a,1 or 2,a1 or 2a1</comment>
    <if>if <condition>(<expr><call><name>GetDirection</name><argument_list>()</argument_list></call> == <name>eDirNext</name></expr>)</condition><then><block>{
      <expr_stmt><expr><call><name><name>range</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>startNode</name></expr></argument>, <argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>dir</name> = <name>eDirPrevious</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name><name>range</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <comment type="line">//deselect from a to 1</comment>
    <if>if <condition>(<expr><name>focusNode</name> != <name>anchorNode</name> || <name>focusOffset</name>!= <name>anchorOffset</name></expr>)</condition><then> <block>{<comment type="line">//if collapsed diff dont do anything</comment>
      <expr_stmt><expr><name>res</name> = <call><name><name>difRange</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>anchorNode</name></expr></argument>, <argument><expr><name>anchorOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name> |= <call><name><name>difRange</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>focusOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name> |= <call><name>CopyRangeToAnchorFocus</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>res</name></expr>;</return></then></if>
      <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>difRange</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
    <block>{
      <expr_stmt><expr><name>res</name> = <call><name>CopyRangeToAnchorFocus</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>res</name></expr>;</return></then></if>
    }</block></else></if>
    <comment type="line">//select from 2 to a</comment>
    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>range</name></expr></argument> , <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>result2</name> &gt;= 0 &amp;&amp; <name>result1</name> &gt;= 0</expr>)</condition><then> <block>{<comment type="line">//2,1,a or 21,a or 2,1a or 21a</comment>
    <comment type="line">//select from 2 to 1</comment>
    <expr_stmt><expr><name>res</name> = <call><name><name>range</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
    <expr_stmt><expr><name>dir</name> = <name>eDirPrevious</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name><name>difRange</name>-&gt;<name>SetEnd</name></name><argument_list>(<argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>focusOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> |= <call><name><name>difRange</name>-&gt;<name>SetStart</name></name><argument_list>(<argument><expr><call><name><name>range</name>-&gt;<name>GetStartParent</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>range</name>-&gt;<name>StartOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>selectFrames</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>difRange</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>CopyRangeToAnchorFocus</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>res</name></expr>;</return></then></if>
  }</block></then></if></else></if></else></if></else></if></else></if></else></if></else></if>

  <expr_stmt><expr><call><name>DEBUG_OUT_RANGE</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SELECTION</name></cpp:ifdef>
  <if>if <condition>(<expr><name>eDirNext</name> == <name>mDirection</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"    direction = 1  LEFT TO RIGHT\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"    direction = 0  RIGHT TO LEFT\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>SetDirection</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SELECTION</name></cpp:ifdef>
  <if>if <condition>(<expr><name>aParentNode</name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type><name>content</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>content</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr>"Sel. Extend to %p %s %d\n"</expr></argument>, <argument><expr><call><name><name>content</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><call><name>nsAtomCString</name><argument_list>(<argument><expr><call><name><name>content</name>-&gt;<name>Tag</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr>"Sel. Extend set to null parent.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name><name>mFrameSelection</name>-&gt;<name>NotifySelectionListeners</name></name><argument_list>(<argument><expr><call><name>GetType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>GetChildOffset</name><parameter_list>(<param><decl><type><name>nsIDOMNode</name> *</type><name>aChild</name></decl></param>, <param><decl><type><name>nsIDOMNode</name> *</type><name>aParent</name></decl></param>, <param><decl><type><name>PRInt32</name> &amp;</type><name>aOffset</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>aChild</name> &amp;&amp; <name>aParent</name>)</expr></argument>, <argument><expr>"bad args"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aParent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>cChild</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>cChild</name> || !<name>content</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr><name>aOffset</name> = <call><name><name>content</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>cChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>SelectAllChildren</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aParentNode</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if>if <condition>(<expr><name>mFrameSelection</name></expr>)</condition><then> 
  <block>{
    <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>PostReason</name></name><argument_list>(<argument><expr><name><name>nsISelectionListener</name>::<name>SELECTALL_REASON</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name>Collapse</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMNode</name></expr></argument>&gt;</argument_list></name></type><name>lastChild</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>result</name> = <call><name><name>aParentNode</name>-&gt;<name>GetLastChild</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>lastChild</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>) &amp;&amp; <name>lastChild</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>numBodyChildren</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>GetChildOffset</name><argument_list>(<argument><expr><name>lastChild</name></expr></argument>, <argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>numBodyChildren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mFrameSelection</name></expr>)</condition><then> 
      <block>{
        <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>PostReason</name></name><argument_list>(<argument><expr><name><name>nsISelectionListener</name>::<name>SELECTALL_REASON</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>result</name> = <call><name>Extend</name><argument_list>(<argument><expr><name>aParentNode</name></expr></argument>, <argument><expr><name>numBodyChildren</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>ContainsNode</name></name><parameter_list>(<param><decl><type><name>nsIDOMNode</name>*</type> <name>aNode</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aAllowPartial</name></decl></param>,
                               <param><decl><type><name>PRBool</name>*</type> <name>aYes</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>aYes</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  <expr_stmt><expr>*<name>aYes</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsINode</name></expr></argument>&gt;</argument_list></name></type> <name>node</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>mRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call> == 0 || !<name>node</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <comment type="line">// XXXbz this duplicates the GetNodeLength code in nsRange.cpp</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>nodeLength</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isData</name> <init>= <expr><call><name><name>node</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eDATA_NODE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>isData</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>nodeLength</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIContent</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>node</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>-&gt;<call><name>TextLength</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>nodeLength</name> = <call><name><name>node</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIRange</name></expr></argument>&gt;</argument_list></name></type> <name>overlappingRanges</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name>GetRangesForIntervalCOMArray</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>nodeLength</name></expr></argument>,
                                    <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>&amp;<name>overlappingRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name><name>overlappingRanges</name>.<name>Count</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if> <comment type="line">// no ranges overlap</comment>
  
  <comment type="line">// if the caller said partial intersections are OK, we're done</comment>
  <if>if <condition>(<expr><name>aAllowPartial</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aYes</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// text nodes always count as inside</comment>
  <if>if <condition>(<expr><name>isData</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aYes</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// The caller wants to know if the node is entirely within the given range,</comment>
  <comment type="line">// so we have to check all intersecting ranges.</comment>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>overlappingRanges</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name> ++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>nodeStartsBeforeRange</name></decl>, <decl><type ref="prev"/><name>nodeEndsAfterRange</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>nsRange</name>::<name>CompareNodeToRange</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>overlappingRanges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                 <argument><expr>&amp;<name>nodeStartsBeforeRange</name></expr></argument>,
                                                 <argument><expr>&amp;<name>nodeEndsAfterRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<name>nodeStartsBeforeRange</name> &amp;&amp; !<name>nodeEndsAfterRange</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>aYes</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>GetPresContext</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name> **</type><name>aPresContext</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if><comment type="line">//nothing to do</comment>
  <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>shell</name> <init>= <expr><call><name><name>mFrameSelection</name>-&gt;<name>GetShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>shell</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aPresContext</name> = <call><name><name>shell</name>-&gt;<name>GetPresContext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>GetPresShell</name></name><parameter_list>(<param><decl><type><name>nsIPresShell</name> **</type><name>aPresShell</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mPresShellWeak</name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>presShell</name> <init>= <expr><call><name>do_QueryReferent</name><argument_list>(<argument><expr><name>mPresShellWeak</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>presShell</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aPresShell</name> = <name>presShell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if><comment type="line">//nothing to do</comment>

  <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>shell</name> <init>= <expr><call><name><name>mFrameSelection</name>-&gt;<name>GetShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>mPresShellWeak</name> = <call><name>do_GetWeakReference</name><argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="line">// the presshell owns us, so no addref</comment>
  <if>if <condition>(<expr><name>mPresShellWeak</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aPresShell</name> = <name>shell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsIFrame</name> *</type>
<name><name>nsTypedSelection</name>::<name>GetSelectionAnchorGeometry</name></name><parameter_list>(<param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>,
                                             <param><decl><type><name>nsRect</name> *</type><name>aRect</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>  <comment type="line">// nothing to do</comment>

  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aRect</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>aRect</name>-&gt;<name>SetRect</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsINode</name>    *</type><name>node</name>       <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>     <name>nodeOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>   *</type><name>frame</name>      <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>aRegion</name></expr>)</condition> <block>{
    <case>case <expr><name><name>nsISelectionController</name>::<name>SELECTION_ANCHOR_REGION</name></name></expr>:
      <expr_stmt><expr><name>node</name>       = <call><name>GetAnchorNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nodeOffset</name> = <call><name>GetAnchorOffset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsISelectionController</name>::<name>SELECTION_FOCUS_REGION</name></name></expr>:
      <expr_stmt><expr><name>node</name>       = <call><name>GetFocusNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nodeOffset</name> = <call><name>GetFocusOffset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><default>default:
      <return>return <expr><name>nsnull</name></expr>;</return>
  </default>}</block></switch>

  <if>if <condition>(<expr>!<name>node</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>content</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><call><name><name>content</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>frameOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>frame</name> = <call><name><name>mFrameSelection</name>-&gt;<name>GetFrameForNodeOffset</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>nodeOffset</name></expr></argument>,
                                                 <argument><expr><call><name><name>mFrameSelection</name>-&gt;<name>GetHint</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                 <argument><expr>&amp;<name>frameOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>frame</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <comment type="line">// Figure out what node type we have, then get the</comment>
  <comment type="line">// appropriate rect for it's nodeOffset.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isText</name> <init>= <expr><call><name><name>node</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eTEXT</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsPoint</name></type> <name>pt</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>isText</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>childFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>frameOffset</name> = 0</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>=
      <expr><call><name><name>frame</name>-&gt;<name>GetChildFrameContainingOffset</name></name><argument_list>(<argument><expr><name>nodeOffset</name></expr></argument>,
                                           <argument><expr><call><name><name>mFrameSelection</name>-&gt;<name>GetHint</name></name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr>&amp;<name>frameOffset</name></expr></argument>, <argument><expr>&amp;<name>childFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>nsnull</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<name>childFrame</name></expr>)</condition><then>
      <return>return <expr><name>nsnull</name></expr>;</return></then></if>

    <expr_stmt><expr><name>frame</name> = <name>childFrame</name></expr>;</expr_stmt>

    <comment type="line">// Get the x coordinate of the offset into the text frame.</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>GetCachedFrameOffset</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr><name>nodeOffset</name></expr></argument>, <argument><expr><name>pt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>nsnull</name></expr>;</return></then></if>
  }</block></then></if>

  <comment type="line">// Return the rect relative to the frame, with zero width.</comment>
  <if>if <condition>(<expr><name>isText</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>aRect</name>-&gt;<name>x</name></name> = <name><name>pt</name>.<name>x</name></name></expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mFrameSelection</name>-&gt;<name>GetHint</name></name><argument_list>()</argument_list></call> == <name><name>nsFrameSelection</name>::<name>HINTLEFT</name></name></expr>)</condition><then> <block>{
    <comment type="line">// It's the frame's right edge we're interested in.</comment>
    <expr_stmt><expr><name><name>aRect</name>-&gt;<name>x</name></name> = <call><name><name>frame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call>.<name>width</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <expr_stmt><expr><name><name>aRect</name>-&gt;<name>height</name></name> = <call><name><name>frame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call>.<name>height</name></expr>;</expr_stmt>

  <return>return <expr><name>frame</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>ScrollSelectionIntoViewEvent</name>::<name>Run</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mTypedSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>  <comment type="line">// event revoked</comment>

  <expr_stmt><expr><call><name><name>mTypedSelection</name>-&gt;<name>mScrollEvent</name>.<name>Forget</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mTypedSelection</name>-&gt;<name>ScrollIntoView</name></name><argument_list>(<argument><expr><name>mRegion</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>PostScrollSelectionIntoViewEvent</name></name><parameter_list>(<param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// If we've already posted an event, revoke it and place a new one at the</comment>
  <comment type="line">// end of the queue to make sure that any new pending reflow events are</comment>
  <comment type="line">// processed before we scroll. This will insure that we scroll to the</comment>
  <comment type="line">// correct place on screen.</comment>
  <expr_stmt><expr><call><name><name>mScrollEvent</name>.<name>Revoke</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>ScrollSelectionIntoViewEvent</name></expr></argument>&gt;</argument_list></name></type> <name>ev</name> <init>=
      <expr>new <call><name>ScrollSelectionIntoViewEvent</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aRegion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>NS_DispatchToCurrentThread</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mScrollEvent</name> = <name>ev</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>ScrollIntoView</name></name><parameter_list>(<param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsSynchronous</name></decl></param>,
                                 <param><decl><type><name>PRInt16</name></type> <name>aVPercent</name></decl></param>, <param><decl><type><name>PRInt16</name></type> <name>aHPercent</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>ScrollIntoView</name><argument_list>(<argument><expr><name>aRegion</name></expr></argument>, <argument><expr><name>aIsSynchronous</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                        <argument><expr><name>aVPercent</name></expr></argument>, <argument><expr><name>aHPercent</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>ScrollIntoView</name></name><parameter_list>(<param><decl><type><name>SelectionRegion</name></type> <name>aRegion</name></decl></param>,
                                 <param><decl><type><name>PRBool</name></type> <name>aIsSynchronous</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aDoFlush</name></decl></param>,
                                 <param><decl><type><name>PRInt16</name></type> <name>aVPercent</name></decl></param>, <param><decl><type><name>PRInt16</name></type> <name>aHPercent</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if><comment type="line">//nothing to do</comment>

  <if>if <condition>(<expr><call><name><name>mFrameSelection</name>-&gt;<name>GetBatching</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <if>if <condition>(<expr>!<name>aIsSynchronous</name></expr>)</condition><then>
    <return>return <expr><call><name>PostScrollSelectionIntoViewEvent</name><argument_list>(<argument><expr><name>aRegion</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="line">//</comment>
  <comment type="line">// Shut the caret off before scrolling to avoid</comment>
  <comment type="line">// leaving caret turds on the screen!</comment>
  <comment type="line">//</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>presShell</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>result</name> = <call><name>GetPresShell</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>presShell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> || !<name>presShell</name></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCaret</name></expr></argument>&gt;</argument_list></name></type> <name>caret</name> <init>= <expr><call><name><name>presShell</name>-&gt;<name>GetCaret</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>caret</name></expr>)</condition><then>
  <block>{
    <comment type="line">// Now that text frame character offsets are always valid (though not</comment>
    <comment type="line">// necessarily correct), the worst that will happen if we don't flush here</comment>
    <comment type="line">// is that some callers might scroll to the wrong place.  Those should</comment>
    <comment type="line">// either manually flush if they're in a safe position for it or use the</comment>
    <comment type="line">// async version of this method.</comment>
    <if>if <condition>(<expr><name>aDoFlush</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>presShell</name>-&gt;<name>FlushPendingNotifications</name></name><argument_list>(<argument><expr><name>Flush_Layout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// Reget the presshell, since it might have gone away.</comment>
      <expr_stmt><expr><name>result</name> = <call><name>GetPresShell</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>presShell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> || !<name>presShell</name></expr>)</condition><then>
        <return>return <expr><name>result</name></expr>;</return></then></if>
    }</block></then></if>

    <function_decl><type><name>StCaretHider</name></type>  <name>caretHider</name><parameter_list>(<param><decl><type><name>caret</name></type></decl></param>)</parameter_list>;</function_decl>      <comment type="line">// stack-based class hides and shows the caret</comment>

    <comment type="line">//</comment>
    <comment type="line">// Scroll the selection region into view.</comment>
    <comment type="line">//</comment>

    <decl_stmt><decl><type><name>nsRect</name></type> <name>rect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><call><name>GetSelectionAnchorGeometry</name><argument_list>(<argument><expr><name>aRegion</name></expr></argument>, <argument><expr>&amp;<name>rect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>frame</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>presShell</name>-&gt;<name>ScrollFrameRectIntoView</name></name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr><name>rect</name></expr></argument>, <argument><expr><name>aVPercent</name></expr></argument>, <argument><expr><name>aHPercent</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>AddSelectionListener</name></name><parameter_list>(<param><decl><type><name>nsISelectionListener</name>*</type> <name>aNewListener</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aNewListener</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  <return>return <expr><call><name><name>mSelectionListeners</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><name>aNewListener</name></expr></argument>)</argument_list></call> ? <name>NS_OK</name> : <name>NS_ERROR_FAILURE</name></expr>;</return>      <comment type="line">// addrefs</comment>
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>RemoveSelectionListener</name></name><parameter_list>(<param><decl><type><name>nsISelectionListener</name>*</type> <name>aListenerToRemove</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aListenerToRemove</name></expr> )</condition><then>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return></then></if>
  <return>return <expr><call><name><name>mSelectionListeners</name>.<name>RemoveObject</name></name><argument_list>(<argument><expr><name>aListenerToRemove</name></expr></argument>)</argument_list></call> ? <name>NS_OK</name> : <name>NS_ERROR_FAILURE</name></expr>;</return> <comment type="line">// releases</comment>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsTypedSelection</name>::<name>NotifySelectionListeners</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if><comment type="line">//nothing to do</comment>
 
  <if>if <condition>(<expr><call><name><name>mFrameSelection</name>-&gt;<name>GetBatching</name></name><argument_list>()</argument_list></call></expr>)</condition><then><block>{
    <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>SetDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cnt</name> <init>= <expr><call><name><name>mSelectionListeners</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <function_decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsISelectionListener</name></expr></argument>&gt;</argument_list></name></type> <name>selectionListeners</name><parameter_list>(<param><decl><type><name>mSelectionListeners</name></type></decl></param>)</parameter_list>;</function_decl>
  
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDOMDocument</name></expr></argument>&gt;</argument_list></name></type> <name>domdoc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPresShell</name></expr></argument>&gt;</argument_list></name></type> <name>shell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>GetPresShell</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>shell</name></expr>)</condition><then>
    <expr_stmt><expr><name>domdoc</name> = <call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name><name>shell</name>-&gt;<name>GetDocument</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <decl_stmt><decl><type><name>short</name></type> <name>reason</name> <init>= <expr><call><name><name>mFrameSelection</name>-&gt;<name>PopReason</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>cnt</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
  <block>{
    <decl_stmt><decl><type><name>nsISelectionListener</name>*</type> <name>thisListener</name> <init>= <expr><name><name>selectionListeners</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>thisListener</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>thisListener</name>-&gt;<name>NotifySelectionChanged</name></name><argument_list>(<argument><expr><name>domdoc</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></for>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>StartBatchChanges</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mFrameSelection</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>StartBatchChanges</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>EndBatchChanges</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mFrameSelection</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>EndBatchChanges</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>



<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>DeleteFromDocument</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if><comment type="line">//nothing to do</comment>
  <return>return <expr><call><name><name>mFrameSelection</name>-&gt;<name>DeleteFromDocument</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>Modify</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aAlter</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aDirection</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aGranularity</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Silently exit if there's no selection or no focus node.</comment>
  <if>if <condition>(<expr>!<name>mFrameSelection</name> || !<call><name>GetAnchorFocusRange</name><argument_list>()</argument_list></call> || !<call><name>GetFocusNode</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name><name>aAlter</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"move"</expr></argument>)</argument_list></call> &amp;&amp;
      !<call><name><name>aAlter</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"extend"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name><name>aDirection</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"forward"</expr></argument>)</argument_list></call> &amp;&amp;
      !<call><name><name>aDirection</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"backward"</expr></argument>)</argument_list></call> &amp;&amp;
      !<call><name><name>aDirection</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"left"</expr></argument>)</argument_list></call> &amp;&amp;
      !<call><name><name>aDirection</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"right"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Line moves are always visual.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>visual</name>  <init>= <expr><call><name><name>aDirection</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"left"</expr></argument>)</argument_list></call> ||
                   <call><name><name>aDirection</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"right"</expr></argument>)</argument_list></call> ||
                   <call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"line"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>forward</name> <init>= <expr><call><name><name>aDirection</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"forward"</expr></argument>)</argument_list></call> ||
                   <call><name><name>aDirection</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"right"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>extend</name>  <init>= <expr><call><name><name>aAlter</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"extend"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// The PRUint32 casts below prevent an enum mismatch warning.</comment>
  <decl_stmt><decl><type><name>nsSelectionAmount</name></type> <name>amount</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>keycode</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"character"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>amount</name> = <name>eSelectCharacter</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>keycode</name> = <name>forward</name> ? (<name>PRUint32</name>) <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_RIGHT</name></name> :
                        (<name>PRUint32</name>) <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_LEFT</name></name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"word"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>amount</name> = <name>eSelectWord</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>keycode</name> = <name>forward</name> ? (<name>PRUint32</name>) <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_RIGHT</name></name> :
                        (<name>PRUint32</name>) <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_LEFT</name></name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"line"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>amount</name> = <name>eSelectLine</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>keycode</name> = <name>forward</name> ? (<name>PRUint32</name>) <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_DOWN</name></name> :
                        (<name>PRUint32</name>) <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_UP</name></name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"lineboundary"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>amount</name> = <name>eSelectLine</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>keycode</name> = <name>forward</name> ? (<name>PRUint32</name>) <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_END</name></name> :
                        (<name>PRUint32</name>) <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_HOME</name></name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"sentence"</expr></argument>)</argument_list></call> ||
           <call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"sentenceboundary"</expr></argument>)</argument_list></call> ||
           <call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"paragraph"</expr></argument>)</argument_list></call> ||
           <call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"paragraphboundary"</expr></argument>)</argument_list></call> ||
           <call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"documentboundary"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
  }</block></then>
  <else>else <block>{
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return>
  }</block></else></if></else></if></else></if></else></if></else></if>

  <comment type="line">// If the anchor doesn't equal the focus and we try to move without first</comment>
  <comment type="line">// collapsing the selection, MoveCaret will collapse the selection and quit.</comment>
  <comment type="line">// To avoid this, we need to collapse the selection first.</comment>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>extend</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsINode</name>*</type> <name>focusNode</name> <init>= <expr><call><name>GetFocusNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// We should have checked earlier that there was a focus node.</comment>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>NS_ERROR_UNEXPECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>focusOffset</name> <init>= <expr><call><name>GetFocusOffset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Collapse</name><argument_list>(<argument><expr><name>focusNode</name></expr></argument>, <argument><expr><name>focusOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// If the base level of the focused frame is odd, we may have to swap the</comment>
  <comment type="line">// direction of the keycode.</comment>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>frame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>offset</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name>GetPrimaryFrameForFocusNode</name><argument_list>(<argument><expr>&amp;<name>frame</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>visual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>frame</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsBidiLevel</name></type> <name>baseLevel</name> <init>= <expr><call><name><name>nsBidiPresUtils</name>::<name>GetFrameBaseLevel</name></name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>baseLevel</name> &amp; 1</expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<name>visual</name> &amp;&amp; <name>keycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_RIGHT</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>keycode</name> = <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_LEFT</name></name></expr>;</expr_stmt>
      }</block></then>
      <else>else <if>if <condition>(<expr>!<name>visual</name> &amp;&amp; <name>keycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_LEFT</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>keycode</name> = <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_RIGHT</name></name></expr>;</expr_stmt>
      }</block></then>
      <else>else <if>if <condition>(<expr><name>visual</name> &amp;&amp; <name>keycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_HOME</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>keycode</name> = <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_END</name></name></expr>;</expr_stmt>
      }</block></then>
      <else>else <if>if <condition>(<expr><name>visual</name> &amp;&amp; <name>keycode</name> == <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_END</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>keycode</name> = <name><name>nsIDOMKeyEvent</name>::<name>DOM_VK_HOME</name></name></expr>;</expr_stmt>
      }</block></then></if></else></if></else></if></else></if>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// MoveCaret will return an error if it can't move in the specified</comment>
  <comment type="line">// direction, but we just ignore this error unless it's a line move, in which</comment>
  <comment type="line">// case we call nsISelectionController::CompleteMove to move the cursor to</comment>
  <comment type="line">// the beginning/end of the line.</comment>
  <expr_stmt><expr><name>rv</name> = <call><name><name>mFrameSelection</name>-&gt;<name>MoveCaret</name></name><argument_list>(<argument><expr><name>keycode</name></expr></argument>, <argument><expr><name>extend</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>visual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name><name>aGranularity</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"line"</expr></argument>)</argument_list></call> &amp;&amp; <call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISelectionController</name></expr></argument>&gt;</argument_list></name></type> <name>shell</name> <init>=
      <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name><name>mFrameSelection</name>-&gt;<name>GetShell</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>shell</name></expr>)</condition><then>
      <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>shell</name>-&gt;<name>CompleteMove</name></name><argument_list>(<argument><expr><name>forward</name></expr></argument>, <argument><expr><name>extend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/** SelectionLanguageChange modifies the cursor Bidi level after a change in keyboard direction
 *  @param aLangRTL is PR_TRUE if the new language is right-to-left or PR_FALSE if the new language is left-to-right
 */</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTypedSelection</name>::<name>SelectionLanguageChange</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aLangRTL</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mFrameSelection</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return></then></if> <comment type="line">// Can't do selection</comment>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>focusFrame</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>result</name> = <call><name>GetPrimaryFrameForFocusNode</name><argument_list>(<argument><expr>&amp;<name>focusFrame</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>!<name>focusFrame</name></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>frameStart</name></decl>, <decl><type ref="prev"/><name>frameEnd</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>focusFrame</name>-&gt;<name>GetOffsets</name></name><argument_list>(<argument><expr><name>frameStart</name></expr></argument>, <argument><expr><name>frameEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsPresContext</name></expr></argument>&gt;</argument_list></name></type> <name>context</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint8</name></type> <name>levelBefore</name></decl>, <decl><type ref="prev"/><name>levelAfter</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>result</name> = <call><name>GetPresContext</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> || !<name>context</name></expr>)</condition><then>
    <return>return <expr><name>result</name>?<name>result</name>:<name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRUint8</name></type> <name>level</name> <init>= <expr><call><name>NS_GET_EMBEDDING_LEVEL</name><argument_list>(<argument><expr><name>focusFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>focusOffset</name> <init>= <expr><call><name>GetFocusOffset</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>focusOffset</name> != <name>frameStart</name>) &amp;&amp; (<name>focusOffset</name> != <name>frameEnd</name>)</expr>)</condition><then>
    <comment type="line">// the cursor is not at a frame boundary, so the level of both the characters (logically) before and after the cursor</comment>
    <comment type="line">//  is equal to the frame level</comment>
    <expr_stmt><expr><name>levelBefore</name> = <name>levelAfter</name> = <name>level</name></expr>;</expr_stmt></then>
  <else>else <block>{
    <comment type="line">// the cursor is at a frame boundary, so use GetPrevNextBidiLevels to find the level of the characters</comment>
    <comment type="line">//  before and after the cursor</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>focusContent</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><call><name>GetFocusNode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/*
    nsFrameSelection::HINT hint;

    if ((focusOffset == frameStart &amp;&amp; level)        // beginning of an RTL frame
        || (focusOffset == frameEnd &amp;&amp; !level)) {   // end of an LTR frame
      hint = nsFrameSelection::HINTRIGHT;
    }
    else {                                          // end of an RTL frame or beginning of an LTR frame
      hint = nsFrameSelection::HINTLEFT;
    }
    mFrameSelection-&gt;SetHint(hint);
    */</comment>
    <decl_stmt><decl><type><name>nsPrevNextBidiLevels</name></type> <name>levels</name> <init>= <expr><call><name><name>mFrameSelection</name>-&gt;
      <name>GetPrevNextBidiLevels</name></name><argument_list>(<argument><expr><name>focusContent</name></expr></argument>, <argument><expr><name>focusOffset</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      
    <expr_stmt><expr><name>levelBefore</name> = <name><name>levels</name>.<name>mLevelBefore</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>levelAfter</name> = <name><name>levels</name>.<name>mLevelAfter</name></name></expr>;</expr_stmt>
  }</block></else></if>

  <if>if <condition>(<expr>(<name>levelBefore</name> &amp; 1) == (<name>levelAfter</name> &amp; 1)</expr>)</condition><then> <block>{
    <comment type="line">// if cursor is between two characters with the same orientation, changing the keyboard language</comment>
    <comment type="line">//  must toggle the cursor level between the level of the character with the lowest level</comment>
    <comment type="line">//  (if the new language corresponds to the orientation of that character) and this level plus 1</comment>
    <comment type="line">//  (if the new language corresponds to the opposite orientation)</comment>
    <if>if <condition>(<expr>(<name>level</name> != <name>levelBefore</name>) &amp;&amp; (<name>level</name> != <name>levelAfter</name>)</expr>)</condition><then>
      <expr_stmt><expr><name>level</name> = <call><name>NS_MIN</name><argument_list>(<argument><expr><name>levelBefore</name></expr></argument>, <argument><expr><name>levelAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>(<name>level</name> &amp; 1) == <name>aLangRTL</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>SetCaretBidiLevel</name></name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>SetCaretBidiLevel</name></name><argument_list>(<argument><expr><name>level</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  }</block></then>
  <else>else <block>{
    <comment type="line">// if cursor is between characters with opposite orientations, changing the keyboard language must change</comment>
    <comment type="line">//  the cursor level to that of the adjacent character with the orientation corresponding to the new language.</comment>
    <if>if <condition>(<expr>(<name>levelBefore</name> &amp; 1) == <name>aLangRTL</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>SetCaretBidiLevel</name></name><argument_list>(<argument><expr><name>levelBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>SetCaretBidiLevel</name></name><argument_list>(<argument><expr><name>levelAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  }</block></else></if>
  
  <comment type="line">// The caret might have moved, so invalidate the desired X position</comment>
  <comment type="line">// for future usages of up-arrow or down-arrow</comment>
  <expr_stmt><expr><call><name><name>mFrameSelection</name>-&gt;<name>InvalidateDesiredX</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<comment type="line">// nsAutoCopyListener</comment>

<decl_stmt><decl><type><name>nsAutoCopyListener</name>*</type> <name><name>nsAutoCopyListener</name>::<name>sInstance</name></name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

<macro><name>NS_IMPL_ISUPPORTS1</name><argument_list>(<argument>nsAutoCopyListener</argument>, <argument>nsISelectionListener</argument>)</argument_list></macro>

<comment type="block">/*
 * What we do now:
 * On every selection change, we copy to the clipboard anew, creating a
 * HTML buffer, a transferable, an nsISupportsString and
 * a huge mess every time.  This is basically what nsPresShell::DoCopy does
 * to move the selection into the clipboard for Edit-&gt;Copy.
 * 
 * What we should do, to make our end of the deal faster:
 * Create a singleton transferable with our own magic converter.  When selection
 * changes (use a quick cache to detect ``real'' changes), we put the new
 * nsISelection in the transferable.  Our magic converter will take care of
 * transferable-&gt;whatever-other-format when the time comes to actually
 * hand over the clipboard contents.
 *
 * Other issues:
 * - which X clipboard should we populate?
 * - should we use a different one than Edit-&gt;Copy, so that inadvertant
 *   selections (or simple clicks, which currently cause a selection
 *   notification, regardless of if they're in the document which currently has
 *   selection!) don't lose the contents of the ``application''?  Or should we
 *   just put some intelligence in the ``is this a real selection?'' code to
 *   protect our selection against clicks in other documents that don't create
 *   selections?
 * - maybe we should just never clear the X clipboard?  That would make this 
 *   problem just go away, which is very tempting.
 */</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsAutoCopyListener</name>::<name>NotifySelectionChanged</name></name><parameter_list>(<param><decl><type><name>nsIDOMDocument</name> *</type><name>aDoc</name></decl></param>,
                                           <param><decl><type><name>nsISelection</name> *</type><name>aSel</name></decl></param>, <param><decl><type><name>PRInt16</name></type> <name>aReason</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!(<name>aReason</name> &amp; <name><name>nsISelectionListener</name>::<name>MOUSEUP_REASON</name></name>   || 
        <name>aReason</name> &amp; <name><name>nsISelectionListener</name>::<name>SELECTALL_REASON</name></name> ||
        <name>aReason</name> &amp; <name><name>nsISelectionListener</name>::<name>KEYPRESS_REASON</name></name>)</expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if> <comment type="line">//dont care if we are still dragging</comment>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>collapsed</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>aDoc</name> || !<name>aSel</name> ||
      <call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name><name>aSel</name>-&gt;<name>GetIsCollapsed</name></name><argument_list>(<argument><expr>&amp;<name>collapsed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> || <name>collapsed</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CLIPBOARD</name></cpp:ifdef>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"CLIPBOARD: no selection/collapsed selection\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* clear X clipboard? */</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocument</name></expr></argument>&gt;</argument_list></name></type> <name>doc</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>aDoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>doc</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// call the copy code</comment>
  <return>return <expr><call><name><name>nsCopySupport</name>::<name>HTMLCopy</name></name><argument_list>(<argument><expr><name>aSel</name></expr></argument>, <argument><expr><name>doc</name></expr></argument>, <argument><expr><name><name>nsIClipboard</name>::<name>kSelectionClipboard</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
