<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="001f1a9dcfa5484423917c370b41271e103b1200.h"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developers of the Original Code are
 * Sun Microsystems and IBM Corporation
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Ginn Chen (ginn.chen@sun.com)
 *   Aaron Leventhal (aleventh@us.ibm.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_nsHyperTextAccessible_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_nsHyperTextAccessible_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAccessibleWrap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAccessibleText.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAccessibleHyperText.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAccessibleEditableText.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAccessibleEventData.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTextUtils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameSelection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelectionController.h"</cpp:file></cpp:include>

<enum>enum <name>EGetTextType</name> <block>{ <decl><name>eGetBefore</name><init>=<expr>-1</expr></init></decl>, <decl><name>eGetAt</name><init>=<expr>0</expr></init></decl>, <decl><name>eGetAfter</name><init>=<expr>1</expr></init></decl> }</block>;</enum>

<comment type="line">// This character marks where in the text returned via nsIAccessibleText(),</comment>
<comment type="line">// that embedded object characters exist</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type> <name>kEmbeddedObjectChar</name> <init>= <expr>0xfffc</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type> <name>kImaginaryEmbeddedObjectChar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type> <name>kForcedNewLineChar</name> <init>= <expr>'\n'</expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_HYPERTEXTACCESSIBLE_IMPL_CID</name></cpp:macro>                 \
<cpp:value>{  <comment type="block">/* 245f3bc9-224f-4839-a92e-95239705f30b */</comment>           \
  0x245f3bc9,                                           \
  0x224f,                                               \
  0x4839,                                               \
  { 0xa9, 0x2e, 0x95, 0x23, 0x97, 0x05, 0xf3, 0x0b }    \
}</cpp:value></cpp:define>

<comment type="block">/**
  * Special Accessible that knows how contain both text and embedded objects
  */</comment>
<expr_stmt><expr><name>class</name> <name>nsHyperTextAccessible</name> : <name>public</name> <name>nsAccessibleWrap</name></expr>,
                              <expr><name>public</name> <name>nsIAccessibleText</name></expr>,
                              <expr><name>public</name> <name>nsIAccessibleHyperText</name></expr>,
                              <expr><name>public</name> <name>nsIAccessibleEditableText</name>
<block>{
<expr><name>public</name>:
  <call><name>nsHyperTextAccessible</name><argument_list>(<argument><expr><name>nsIDOMNode</name>* <name>aNode</name></expr></argument>, <argument><expr><name>nsIWeakReference</name>* <name>aShell</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>NS_DECL_ISUPPORTS_INHERITED</name>
  <name>NS_DECL_NSIACCESSIBLETEXT</name>
  <name>NS_DECL_NSIACCESSIBLEHYPERTEXT</name>
  <name>NS_DECL_NSIACCESSIBLEEDITABLETEXT</name>
  <macro><name>NS_DECLARE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>NS_HYPERTEXTACCESSIBLE_IMPL_CID</argument>)</argument_list></macro>

  <comment type="line">// nsIAccessible</comment>
  <name>NS_IMETHOD</name> <call><name>GetRole</name><argument_list>(<argument><expr><name>PRUint32</name> *<name>aRole</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>NS_IMETHOD</name> <call><name>GetState</name><argument_list>(<argument><expr><name>PRUint32</name> *<name>aState</name></expr></argument>, <argument><expr><name>PRUint32</name> *<name>aExtraState</name></expr></argument>)</argument_list></call></expr>;

  <comment type="line">// nsAccessible</comment>
  <expr><name>virtual</name> <name>nsresult</name> <call><name>GetAttributesInternal</name><argument_list>(<argument><expr><name>nsIPersistentProperties</name> *<name>aAttributes</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>void</name> <call><name>CacheChildren</name><argument_list>()</argument_list></call></expr>;

  <comment type="line">// Convert content offset to rendered text offset  </comment>
  <expr>static <name>nsresult</name> <macro><name>ContentToRenderedOffset</name><argument_list>(<argument>nsIFrame *aFrame</argument>, <argument>PRInt32 aContentOffset</argument>,
                                          <argument>PRUint32 *aRenderedOffset</argument>)</argument_list></macro></expr>;
  
  <comment type="line">// Convert rendered text offset to content offset</comment>
  <expr>static <name>nsresult</name> <macro><name>RenderedToContentOffset</name><argument_list>(<argument>nsIFrame *aFrame</argument>, <argument>PRUint32 aRenderedOffset</argument>,
                                          <argument>PRInt32 *aContentOffset</argument>)</argument_list></macro></expr>;

  <comment type="block">/**
    * Turn a DOM Node and offset into a character offset into this hypertext.
    * Will look for closest match when the DOM node does not have an accessible
    * object associated with it. Will return an offset for the end of
    * the string if the node is not found.
    *
    * @param aNode - the node to look for
    * @param aNodeOffset - the offset to look for
    *                      if -1 just look directly for the node
    *                      if &gt;=0 and aNode is text, this represents a char offset
    *                      if &gt;=0 and aNode is not text, this represents a child node offset
    * @param aResultOffset - the character offset into the current
    *                        nsHyperTextAccessible
    * @param aFinalAccessible [optional] - returns the accessible child which
    *                                      contained the offset, if it is within
    *                                      the current nsHyperTextAccessible,
    *                                      otherwise it is set to nsnull.
    * @param aIsEndOffset - if PR_TRUE, then then this offset is not inclusive. The character
    *                       indicated by the offset returned is at [offset - 1]. This means
    *                       if the passed-in offset is really in a descendant, then the offset returned
    *                       will come just after the relevant embedded object characer.
    *                       If PR_FALSE, then the offset is inclusive. The character indicated
    *                       by the offset returned is at [offset]. If the passed-in offset in inside a
    *                       descendant, then the returned offset will be on the relevant embedded object char.
    */</comment>
  <expr><name>nsresult</name> <macro><name>DOMPointToHypertextOffset</name><argument_list>(<argument>nsIDOMNode* aNode</argument>, <argument>PRInt32 aNodeOffset</argument>,
                                     <argument>PRInt32 *aHypertextOffset</argument>,
                                     <argument>nsIAccessible **aFinalAccessible = nsnull</argument>,
                                     <argument>PRBool aIsEndOffset = PR_FALSE</argument>)</argument_list></macro></expr>;

  <comment type="block">/**
   * Turn a hypertext offsets into DOM point.
   *
   * @param  aHTOffset  [in] the given start hypertext offset
   * @param  aNode      [out] start node
   * @param  aOffset    [out] offset inside the start node
   */</comment>
  <expr><name>nsresult</name> <macro><name>HypertextOffsetToDOMPoint</name><argument_list>(<argument>PRInt32 aHTOffset</argument>,
                                     <argument>nsIDOMNode **aNode</argument>,
                                     <argument>PRInt32 *aOffset</argument>)</argument_list></macro></expr>;

  <comment type="block">/**
   * Turn a start and end hypertext offsets into DOM range.
   *
   * @param  aStartHTOffset  [in] the given start hypertext offset
   * @param  aEndHTOffset    [in] the given end hypertext offset
   * @param  aStartNode      [out] start node of the range
   * @param  aStartOffset    [out] start offset of the range
   * @param  aEndNode        [out] end node of the range
   * @param  aEndOffset      [out] end offset of the range
   */</comment>
  <expr><name>nsresult</name> <macro><name>HypertextOffsetsToDOMRange</name><argument_list>(<argument>PRInt32 aStartHTOffset</argument>,
                                      <argument>PRInt32 aEndHTOffset</argument>,
                                      <argument>nsIDOMNode **aStartNode</argument>,
                                      <argument>PRInt32 *aStartOffset</argument>,
                                      <argument>nsIDOMNode **aEndNode</argument>,
                                      <argument>PRInt32 *aEndOffset</argument>)</argument_list></macro></expr>;

<expr><name>protected</name>:
  <comment type="block">/*
   * This does the work for nsIAccessibleText::GetText[At|Before|After]Offset
   * @param aType, eGetBefore, eGetAt, eGetAfter
   * @param aBoundaryType, char/word-start/word-end/line-start/line-end/paragraph/attribute
   * @param aOffset, offset into the hypertext to start from
   * @param *aStartOffset, the resulting start offset for the returned substring
   * @param *aEndOffset, the resulting end offset for the returned substring
   * @param aText, the resulting substring
   * @return success/failure code
   */</comment>
  <name>nsresult</name> <macro><name>GetTextHelper</name><argument_list>(<argument>EGetTextType aType</argument>, <argument>nsAccessibleTextBoundary aBoundaryType</argument>,
                         <argument>PRInt32 aOffset</argument>, <argument>PRInt32 *aStartOffset</argument>, <argument>PRInt32 *aEndOffset</argument>,
                         <argument>nsAString &amp; aText</argument>)</argument_list></macro></expr>;

  <comment type="block">/**
    * Used by GetTextHelper() to move backward/forward from a given point
    * by word/line/etc.
    *
    * @param  aPresShell       the current presshell we're moving in
    * @param  aFromFrame       the starting frame we're moving from
    * @param  aFromOffset      the starting offset we're moving from
    * @param  aFromAccessible  the starting accessible we're moving from
    * @param  aAmount          how much are we moving (word/line/etc.) ?
    * @param  aDirection       forward or backward?
    * @param  aNeedsStart      for word and line cases, are we basing this on
    *                          the start or end?
    * @return                  the resulting offset into this hypertext
    */</comment>
  <expr><name>PRInt32</name> <macro><name>GetRelativeOffset</name><argument_list>(<argument>nsIPresShell *aPresShell</argument>, <argument>nsIFrame *aFromFrame</argument>,
                            <argument>PRInt32 aFromOffset</argument>, <argument>nsIAccessible *aFromAccessible</argument>,
                            <argument>nsSelectionAmount aAmount</argument>, <argument>nsDirection aDirection</argument>,
                            <argument>PRBool aNeedsStart</argument>)</argument_list></macro></expr>;

  <comment type="block">/**
    * Provides information for substring that is defined by the given start
    * and end offsets for this hyper text.
    *
    * @param  aStartOffset  [inout] the start offset into the hyper text. This
    *                       is also an out parameter used to return the offset
    *                       into the start frame's rendered text content
    *                       (start frame is the @return)
    *
    * @param  aEndOffset    [inout] the end offset into the hyper text. This is
    *                       also an out parameter used to return
    *                       the offset into the end frame's rendered
    *                       text content.
    *
    * @param  aText         [out, optional] return the substring's text
    * @param  aEndFrame     [out, optional] return the end frame for this
    *                       substring
    * @param  aBoundsRect   [out, optional] return the bounds rectangle for this
    *                       substring
    * @param  aStartAcc     [out, optional] return the start accessible for this
    *                       substring
    * @param  aEndAcc       [out, optional] return the end accessible for this
    *                       substring
    * @return               the start frame for this substring
    */</comment>
  <expr><name>nsIFrame</name>* <call><name>GetPosAndText</name><argument_list>(<argument><expr><name>PRInt32</name>&amp; <name>aStartOffset</name></expr></argument>, <argument><expr><name>PRInt32</name>&amp; <name>aEndOffset</name></expr></argument>,
                          <argument><expr><name>nsAString</name> *<name>aText</name> = <name>nsnull</name></expr></argument>,
                          <argument><expr><name>nsIFrame</name> **<name>aEndFrame</name> = <name>nsnull</name></expr></argument>,
                          <argument><expr><name>nsIntRect</name> *<name>aBoundsRect</name> = <name>nsnull</name></expr></argument>,
                          <argument><expr><name>nsIAccessible</name> **<name>aStartAcc</name> = <name>nsnull</name></expr></argument>,
                          <argument><expr><name>nsIAccessible</name> **<name>aEndAcc</name> = <name>nsnull</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>nsIntRect</name> <macro><name>GetBoundsForString</name><argument_list>(<argument>nsIFrame *aFrame</argument>, <argument>PRUint32 aStartRenderedOffset</argument>, <argument>PRUint32 aEndRenderedOffset</argument>)</argument_list></macro></expr>;

  <comment type="line">// Selection helpers</comment>

    <comment type="block">/**
   * Get the relevant selection interfaces and ranges for the current hyper
   * text.
   *
   * @param aType    [in] the selection type
   * @param aSelCon  [out, optional] the selection controller for the current
   *                 hyper text
   * @param aDomSel  [out, optional] the selection interface for the current
   *                 hyper text
   * @param aRanges  [out, optional] the selected ranges within the current
   *                 subtree
   */</comment>
  <expr><name>nsresult</name> <macro><name>GetSelections</name><argument_list>(<argument>PRInt16 aType</argument>,
                         <argument>nsISelectionController **aSelCon</argument>,
                         <argument>nsISelection **aDomSel = nsnull</argument>,
                         <argument>nsCOMArray&lt;nsIDOMRange&gt;* aRanges = nsnull</argument>)</argument_list></macro></expr>;

  <expr><name>nsresult</name> <macro><name>SetSelectionRange</name><argument_list>(<argument>PRInt32 aStartPos</argument>, <argument>PRInt32 aEndPos</argument>)</argument_list></macro></expr>;

  <comment type="block">/**
   * Provide the line number for the caret, relative to the
   * current DOM node.
   * @return 1-based index for the line number with the caret
   */</comment>
  <expr><name>PRInt32</name> <call><name>GetCaretLineNumber</name><argument_list>()</argument_list></call></expr>;

  <comment type="line">// Helpers</comment>
  <expr><name>nsresult</name> <macro><name>GetDOMPointByFrameOffset</name><argument_list>(<argument>nsIFrame *aFrame</argument>, <argument>PRInt32 aOffset</argument>,
                                    <argument>nsIAccessible *aAccessible</argument>,
                                    <argument>nsIDOMNode **aNode</argument>, <argument>PRInt32 *aNodeOffset</argument>)</argument_list></macro></expr>;

  
  <comment type="block">/**
   * Return hyper text offset for the specified bound of the given DOM range.
   * If the bound is outside of the hyper text then offset value is either
   * 0 or number of characters of hyper text, it depends on type of requested
   * offset. The method is a wrapper for DOMPointToHypertextOffset.
   *
   * @param aRange          [in] the given range
   * @param aIsStartBound   [in] specifies whether the required range bound is
   *                        start bound
   * @param aIsStartOffset  [in] the offset type, used when the range bound is
   *                        outside of hyper text
   * @param aHTOffset       [out] the result offset
   */</comment>
  <expr><name>nsresult</name> <macro><name>DOMRangeBoundToHypertextOffset</name><argument_list>(<argument>nsIDOMRange *aRange</argument>,
                                          <argument>PRBool aIsStartBound</argument>,
                                          <argument>PRBool aIsStartOffset</argument>,
                                          <argument>PRInt32 *aHTOffset</argument>)</argument_list></macro></expr>;

  <comment type="block">/**
   * Set 'misspelled' text attribute and return range offsets where the
   * attibute is stretched. If the text is not misspelled at the given offset
   * then we expose only range offsets where text is not misspelled. The method
   * is used by GetTextAttributes() method.
   *
   * @param aIncludeDefAttrs  [in] points whether text attributes having default
   *                          values of attributes should be included
   * @param aSourceNode       [in] the node we start to traverse from
   * @param aStartOffset      [in, out] the start offset
   * @param aEndOffset        [in, out] the end offset
   * @param aAttributes       [out, optional] result attributes
   */</comment>
  <expr><name>nsresult</name> <macro><name>GetSpellTextAttribute</name><argument_list>(<argument>nsIDOMNode *aNode</argument>, <argument>PRInt32 aNodeOffset</argument>,
                                 <argument>PRInt32 *aStartOffset</argument>,
                                 <argument>PRInt32 *aEndOffset</argument>,
                                 <argument>nsIPersistentProperties *aAttributes</argument>)</argument_list></macro></expr>;

  <comment type="block">/**
   * Set 'lang' text attribute and return range offsets where attibute is
   * stretched. The method is used by GetTextAttributes() method.
   *
   * @param aIncludeDefAttrs  [in] points whether text attributes having default
   *                          values of attributes should be included
   * @param aSourceNode       [in] the node we start to traverse from
   * @param aStartOffset      [in, out] the start offset
   * @param aEndOffset        [in, out] the end offset
   * @param aAttributes       [out, optional] result attributes
   */</comment>
  <expr><name>nsresult</name> <macro><name>GetLangTextAttributes</name><argument_list>(<argument>PRBool aIncludeDefAttrs</argument>,
                                 <argument>nsIDOMNode *aSourceNode</argument>,
                                 <argument>PRInt32 *aStartOffset</argument>,
                                 <argument>PRInt32 *aEndOffset</argument>,
                                 <argument>nsIPersistentProperties *aAttributes</argument>)</argument_list></macro></expr>;

  <comment type="block">/**
   * Set CSS based text attribute and return range offsets where attibutes are
   * stretched. The method is used by GetTextAttributes() method.
   *
   * @param aIncludeDefAttrs  [in] points whether text attributes having default
   *                          values of attributes should be included
   * @param aSourceNode       [in] the node we start to traverse from
   * @param aStartOffset      [in, out] the start offset
   * @param aEndOffset        [in, out] the end offset
   * @param aAttributes       [out, optional] result attributes
   */</comment>
  <expr><name>nsresult</name> <macro><name>GetCSSTextAttributes</name><argument_list>(<argument>PRBool aIncludeDefAttrs</argument>,
                                <argument>nsIDOMNode *aSourceNode</argument>,
                                <argument>PRInt32 *aStartOffset</argument>,
                                <argument>PRInt32 *aEndOffset</argument>,
                                <argument>nsIPersistentProperties *aAttributes</argument>)</argument_list></macro></expr>;

  <comment type="block">/**
   * Calculates range (start and end offsets) of text where the text attribute
   * (pointed by nsTextAttr object) is stretched. New offsets may be smaller if
   * the given text attribute changes its value before or after the given
   * offsets.
   *
   * @param aNode          [in] the node we start to traverse from
   * @param aComparer      [in] object used to describe the text attribute
   * @param aStartHTOffset [in, out] the start offset
   * @param aEndHTOffset   [in, out] the end offset
   */</comment>
  <expr><name>nsresult</name> <call><name>GetRangeForTextAttr</name><argument_list>(<argument><expr><name>nsIDOMNode</name> *<name>aNode</name></expr></argument>,
                               <argument><expr><name>nsTextAttr</name> *<name>aComparer</name></expr></argument>,
                               <argument><expr><name>PRInt32</name> *<name>aStartHTOffset</name></expr></argument>,
                               <argument><expr><name>PRInt32</name> *<name>aEndHTOffset</name></expr></argument>)</argument_list></call></expr>;

  <comment type="block">/**
   * Find new end offset for text attributes navigating through the tree. New
   * end offset may be smaller if the given text attribute (pointed by
   * nsTextAttr object) changes its value before the given end offset.
   *
   * @param  aCurrNode  [in] the first node of the tree
   * @param  aComparer  [in] object used to describe the text attribute
   * @param  aHTOffset  [in, out] the end offset
   * @return            true if the end offset has been changed
   */</comment>
  <expr><name>PRBool</name> <call><name>FindEndOffsetInSubtree</name><argument_list>(<argument><expr><name>nsIDOMNode</name> *<name>aCurrNode</name></expr></argument>,
                                <argument><expr><name>nsTextAttr</name> *<name>aComparer</name></expr></argument>,
                                <argument><expr><name>PRInt32</name> *<name>aHTOffset</name></expr></argument>)</argument_list></call></expr>;

  <comment type="block">/**
   * Find the start offset for text attributes navigating through the tree. New
   * start offset may be bigger if the given text attribute (pointed by
   * nsTextAttr object) changes its value after the given start offset.
   *
   * @param  aCurrNode  [in] the node navigating through thee thee is started
   *                    from
   * @param  aPrevNode  [in] the previous node placed before the start node
   * @param  aComparer  [in] object used to describe the text attribute
   * @param  aHTOffset  [in, out] the start offset
   * @return            true if the start offset has been changed
   */</comment>
  <expr><name>PRBool</name> <call><name>FindStartOffsetInSubtree</name><argument_list>(<argument><expr><name>nsIDOMNode</name> *<name>aCurrNode</name></expr></argument>,
                                  <argument><expr><name>nsIDOMNode</name> *<name>aPrevNode</name></expr></argument>,
                                  <argument><expr><name>nsTextAttr</name> *<name>aComparer</name></expr></argument>,
                                  <argument><expr><name>PRInt32</name> *<name>aHTOffset</name></expr></argument>)</argument_list></call></expr>;

}</block></expr>;</expr_stmt>

<macro><name>NS_DEFINE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>nsHyperTextAccessible</argument>,
                              <argument>NS_HYPERTEXTACCESSIBLE_IMPL_CID</argument>)</argument_list></macro>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// _nsHyperTextAccessible_H_</comment>

</unit>
