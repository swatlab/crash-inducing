<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0011d9d088db2240914d8dc04785ca8ea4a1762f.cc"><comment type="line">// Copyright (c) 2006, Google Inc.</comment>
<comment type="line">// All rights reserved.</comment>
<comment type="line">//</comment>
<comment type="line">// Redistribution and use in source and binary forms, with or without</comment>
<comment type="line">// modification, are permitted provided that the following conditions are</comment>
<comment type="line">// met:</comment>
<comment type="line">//</comment>
<comment type="line">//     * Redistributions of source code must retain the above copyright</comment>
<comment type="line">// notice, this list of conditions and the following disclaimer.</comment>
<comment type="line">//     * Redistributions in binary form must reproduce the above</comment>
<comment type="line">// copyright notice, this list of conditions and the following disclaimer</comment>
<comment type="line">// in the documentation and/or other materials provided with the</comment>
<comment type="line">// distribution.</comment>
<comment type="line">//     * Neither the name of Google Inc. nor the names of its</comment>
<comment type="line">// contributors may be used to endorse or promote products derived from</comment>
<comment type="line">// this software without specific prior written permission.</comment>
<comment type="line">//</comment>
<comment type="line">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</comment>
<comment type="line">// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</comment>
<comment type="line">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</comment>
<comment type="line">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</comment>
<comment type="line">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</comment>
<comment type="line">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</comment>
<comment type="line">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</comment>
<comment type="line">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</comment>
<comment type="line">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</comment>
<comment type="line">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</comment>
<comment type="line">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdio&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/host_info.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/vm_statistics.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/dyld.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/loader.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;CoreFoundation/CoreFoundation.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"client/mac/handler/minidump_generator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"client/minidump_file_writer-inl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/mac/file_id.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/mac/string_utilities.h"</cpp:file></cpp:include>

<using>using <name><name>MacStringUtils</name>::<name>ConvertToString</name></name>;</using>
<using>using <name><name>MacStringUtils</name>::<name>IntegerValueAtIndex</name></name>;</using>

<namespace>namespace <name>google_breakpad</name> <block>{
  
<constructor><name><name>MinidumpGenerator</name>::<name>MinidumpGenerator</name></name><parameter_list>()</parameter_list>
    <member_list>: <call><name>exception_type_</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
      <call><name>exception_code_</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
      <call><name>exception_thread_</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
      <call><name>crashing_task_</name><argument_list>(<argument><expr><call><name>mach_task_self</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>,
      <call><name>handler_thread_</name><argument_list>(<argument><expr><call><name>mach_thread_self</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> </member_list><block>{
  <expr_stmt><expr><name>dynamic_images_</name> = new <call><name>DynamicImages</name><argument_list>(<argument><expr><call><name>mach_task_self</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GatherSystemInformation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<constructor><name><name>MinidumpGenerator</name>::<name>MinidumpGenerator</name></name><parameter_list>(<param><decl><type><name>mach_port_t</name></type> <name>crashing_task</name></decl></param>, <param><decl><type><name>mach_port_t</name></type> <name>handler_thread</name></decl></param>)</parameter_list>
    <member_list>: <call><name>exception_type_</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
      <call><name>exception_code_</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
      <call><name>exception_thread_</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
      <call><name>crashing_task_</name><argument_list>(<argument><expr><name>crashing_task</name></expr></argument>)</argument_list></call>,
      <call><name>handler_thread_</name><argument_list>(<argument><expr><name>handler_thread</name></expr></argument>)</argument_list></call> </member_list><block>{
  <expr_stmt><expr><name>dynamic_images_</name> = new <call><name>DynamicImages</name><argument_list>(<argument><expr><name>crashing_task_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GatherSystemInformation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>MinidumpGenerator</name>::~<name>MinidumpGenerator</name></name><parameter_list>()</parameter_list> <block>{
}</block></destructor>

<decl_stmt><decl><type><name>char</name></type> <name><name>MinidumpGenerator</name>::<name>build_string_</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>MinidumpGenerator</name>::<name>os_major_version_</name></name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>MinidumpGenerator</name>::<name>os_minor_version_</name></name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>MinidumpGenerator</name>::<name>os_build_number_</name></name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<comment type="line">// static</comment>
<function><type><name>void</name></type> <name><name>MinidumpGenerator</name>::<name>GatherSystemInformation</name></name><parameter_list>()</parameter_list> <block>{
  <comment type="line">// If this is non-zero, then we've already gathered the information</comment>
  <if>if <condition>(<expr><name>os_major_version_</name></expr>)</condition><then>
    <return>return;</return></then></if>
  
  <comment type="line">// This code extracts the version and build information from the OS</comment>
  <decl_stmt><decl><type><name>CFStringRef</name></type> <name>vers_path</name> <init>=
    <expr><call><name>CFSTR</name><argument_list>(<argument><expr>"/System/Library/CoreServices/SystemVersion.plist"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CFURLRef</name></type> <name>sys_vers</name> <init>=
    <expr><call><name>CFURLCreateWithFileSystemPath</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vers_path</name></expr></argument>, <argument><expr><name>kCFURLPOSIXPathStyle</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CFDataRef</name></type> <name>data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SInt32</name></type> <name>error</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>CFURLCreateDataAndPropertiesFromResource</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sys_vers</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr>&amp;<name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if>if <condition>(<expr>!<name>data</name></expr>)</condition><then>
    <return>return;</return></then></if>
  
  <decl_stmt><decl><type><name>CFDictionaryRef</name></type> <name>list</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CFDictionaryRef</name></expr></argument>&gt;</argument_list></name>
    <argument_list>(<argument><expr><call><name>CFPropertyListCreateFromXMLData</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>kCFPropertyListImmutable</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
    <return>return;</return></then></if>
  
  <decl_stmt><decl><type><name>CFStringRef</name></type> <name>build_version</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CFStringRef</name></expr></argument>&gt;</argument_list></name>
    <argument_list>(<argument><expr><call><name>CFDictionaryGetValue</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>CFSTR</name><argument_list>(<argument><expr>"ProductBuildVersion"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CFStringRef</name></type> <name>product_version</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CFStringRef</name></expr></argument>&gt;</argument_list></name>
    <argument_list>(<argument><expr><call><name>CFDictionaryGetValue</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>CFSTR</name><argument_list>(<argument><expr>"ProductVersion"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>string</name></type> <name>build_str</name> <init>= <expr><call><name>ConvertToString</name><argument_list>(<argument><expr><name>build_version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>string</name></type> <name>product_str</name> <init>= <expr><call><name>ConvertToString</name><argument_list>(<argument><expr><name>product_version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>CFRelease</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CFRelease</name><argument_list>(<argument><expr><name>sys_vers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CFRelease</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>build_string_</name></expr></argument>, <argument><expr><call><name><name>build_str</name>.<name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>build_string_</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Parse the string that looks like "10.4.8"</comment>
  <expr_stmt><expr><name>os_major_version_</name> = <call><name>IntegerValueAtIndex</name><argument_list>(<argument><expr><name>product_str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>os_minor_version_</name> = <call><name>IntegerValueAtIndex</name><argument_list>(<argument><expr><name>product_str</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>os_build_number_</name> = <call><name>IntegerValueAtIndex</name><argument_list>(<argument><expr><name>product_str</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>string</name></type> <name><name>MinidumpGenerator</name>::<name>UniqueNameInDirectory</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>string</name> &amp;</type><name>dir</name></decl></param>,
                                                <param><decl><type><name>string</name> *</type><name>unique_name</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>CFUUIDRef</name></type> <name>uuid</name> <init>= <expr><call><name>CFUUIDCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CFStringRef</name></type> <name>uuid_cfstr</name> <init>= <expr><call><name>CFUUIDCreateString</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>CFRelease</name><argument_list>(<argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>string</name></type> <name>file_name</name><argument_list>(<argument><expr><call><name>ConvertToString</name><argument_list>(<argument><expr><name>uuid_cfstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>CFRelease</name><argument_list>(<argument><expr><name>uuid_cfstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <function_decl><type><name>string</name></type> <name>path</name><parameter_list>(<param><decl><type><name>dir</name></type></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Ensure that the directory (if non-empty) has a trailing slash so that</comment>
  <comment type="line">// we can append the file name and have a valid pathname.</comment>
  <if>if <condition>(<expr>!<call><name><name>dir</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name><name>dir</name>.<name>at</name></name><argument_list>(<argument><expr><call><name><name>dir</name>.<name>size</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call> != '/'</expr>)</condition><then>
      <expr_stmt><expr><call><name><name>path</name>.<name>append</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>path</name>.<name>append</name></name><argument_list>(<argument><expr><name>file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>path</name>.<name>append</name></name><argument_list>(<argument><expr>".dmp"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>unique_name</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>unique_name</name> = <name>file_name</name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>path</name></expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>Write</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>WriteStreamFN</name></type> <name><name>writers</name><index>[]</index></name> <init>= <expr><block>{
    <expr>&amp;<name><name>MinidumpGenerator</name>::<name>WriteThreadListStream</name></name></expr>,
    <expr>&amp;<name><name>MinidumpGenerator</name>::<name>WriteSystemInfoStream</name></name></expr>,
    <expr>&amp;<name><name>MinidumpGenerator</name>::<name>WriteModuleListStream</name></name></expr>,
    <expr>&amp;<name><name>MinidumpGenerator</name>::<name>WriteMiscInfoStream</name></name></expr>,
    <expr>&amp;<name><name>MinidumpGenerator</name>::<name>WriteBreakpadInfoStream</name></name></expr>,
    <comment type="line">// Exception stream needs to be the last entry in this array as it may</comment>
    <comment type="line">// be omitted in the case where the minidump is written without an</comment>
    <comment type="line">// exception.</comment>
    <expr>&amp;<name><name>MinidumpGenerator</name>::<name>WriteExceptionStream</name></name></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>

  <comment type="line">// If opening was successful, create the header, directory, and call each</comment>
  <comment type="line">// writer.  The destructor for the TypedMDRVAs will cause the data to be</comment>
  <comment type="line">// flushed.  The destructor for the MinidumpFileWriter will close the file.</comment>
  <if>if <condition>(<expr><call><name><name>writer_</name>.<name>Open</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDRawHeader</name></expr></argument>&gt;</argument_list></name></type> <name>header</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDRawDirectory</name></expr></argument>&gt;</argument_list></name></type> <name>dir</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name><name>header</name>.<name>Allocate</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
      <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>int</name></type> <name>writer_count</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>writers</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>writers</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <comment type="line">// If we don't have exception information, don't write out the</comment>
    <comment type="line">// exception stream</comment>
    <if>if <condition>(<expr>!<name>exception_thread_</name> &amp;&amp; !<name>exception_type_</name></expr>)</condition><then>
      <expr_stmt><expr>--<name>writer_count</name></expr>;</expr_stmt></then></if>

    <comment type="line">// Add space for all writers</comment>
    <if>if <condition>(<expr>!<call><name><name>dir</name>.<name>AllocateArray</name></name><argument_list>(<argument><expr><name>writer_count</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>MDRawHeader</name> *</type><name>header_ptr</name> <init>= <expr><call><name><name>header</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>header_ptr</name>-&gt;<name>signature</name></name> = <name>MD_HEADER_SIGNATURE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>header_ptr</name>-&gt;<name>version</name></name> = <name>MD_HEADER_VERSION</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>time_t</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr>&amp;(<name><name>header_ptr</name>-&gt;<name>time_date_stamp</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>header_ptr</name>-&gt;<name>stream_count</name></name> = <name>writer_count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>header_ptr</name>-&gt;<name>stream_directory_rva</name></name> = <call><name><name>dir</name>.<name>position</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>MDRawDirectory</name></type> <name>local_dir</name></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr>(<name>result</name>) &amp;&amp; (<name>i</name> &lt; <name>writer_count</name>)</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
      <expr_stmt><expr><name>result</name> = (<name><name>this</name>-&gt;*<name>writers</name><index>[<expr><name>i</name></expr>]</index></name>)(&amp;<name>local_dir</name>)</expr>;</expr_stmt>

      <if>if <condition>(<expr><name>result</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>dir</name>.<name>CopyIndex</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>local_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
  }</block></then></if>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>size_t</name></type> <name><name>MinidumpGenerator</name>::<name>CalculateStackSize</name></name><parameter_list>(<param><decl><type><name>vm_address_t</name></type> <name>start_addr</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>vm_address_t</name></type> <name>stack_region_base</name> <init>= <expr><name>start_addr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>vm_size_t</name></type> <name>stack_region_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>natural_t</name></type> <name>nesting_level</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>vm_region_submap_info</name></type> <name>submap_info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>info_count</name> <init>= <expr><name>VM_REGION_SUBMAP_INFO_COUNT</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>kern_return_t</name></type> <name>result</name> <init>= 
    <expr><call><name>vm_region_recurse</name><argument_list>(<argument><expr><name>crashing_task_</name></expr></argument>, <argument><expr>&amp;<name>stack_region_base</name></expr></argument>, <argument><expr>&amp;<name>stack_region_size</name></expr></argument>,
                      <argument><expr>&amp;<name>nesting_level</name></expr></argument>, 
                      <argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>vm_region_recurse_info_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr>&amp;<name>submap_info</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr>&amp;<name>info_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>(<name>stack_region_base</name> + <name>stack_region_size</name>) == 0xbffff000</expr>)</condition><then> <block>{
    <comment type="line">// The stack for thread 0 needs to extend all the way to 0xc0000000</comment>
    <comment type="line">// For many processes the stack is first created in one page</comment>
    <comment type="line">// from 0xbffff000 - 0xc0000000 and is then later extended to</comment>
    <comment type="line">// a much larger size by creating a new VM region immediately below</comment>
    <comment type="line">// the initial page</comment>

    <comment type="line">// include the original stack frame page (0xbffff000 - 0xc0000000)</comment>
    <expr_stmt><expr><name>stack_region_size</name> += 0x1000</expr>;</expr_stmt>  
  }</block></then></if>

  <return>return <expr><name>result</name> == <name>KERN_SUCCESS</name> ? 
    <name>stack_region_base</name> + <name>stack_region_size</name> - <name>start_addr</name> : 0</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteStackFromStartAddress</name></name><parameter_list>(
    <param><decl><type><name>vm_address_t</name></type> <name>start_addr</name></decl></param>,
    <param><decl><type><name>MDMemoryDescriptor</name> *</type><name>stack_location</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>UntypedMDRVA</name></type> <name>memory</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>CalculateStackSize</name><argument_list>(<argument><expr><name>start_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// If there's an error in the calculation, return at least the current</comment>
  <comment type="line">// stack information</comment>
  <if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
    <expr_stmt><expr><name>size</name> = 16</expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr>!<call><name><name>memory</name>.<name>Allocate</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <decl_stmt><decl><type><name>void</name> *</type><name>stack_memory</name> <init>= <expr><call><name>ReadTaskMemory</name><argument_list>(<argument><expr><name>crashing_task_</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>start_addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><call><name><name>memory</name>.<name>Copy</name></name><argument_list>(<argument><expr><name>stack_memory</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>stack_memory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  
  <expr_stmt><expr><name><name>stack_location</name>-&gt;<name>start_of_memory_range</name></name> = <name>start_addr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_location</name>-&gt;<name>memory</name></name> = <call><name><name>memory</name>.<name>location</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TARGET_CPU_PPC</name></expr></cpp:if>
<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteStack</name></name><parameter_list>(<param><decl><type><name>breakpad_thread_state_data_t</name></type> <name>state</name></decl></param>,
                                   <param><decl><type><name>MDMemoryDescriptor</name> *</type><name>stack_location</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>ppc_thread_state_t</name> *</type><name>machine_state</name> <init>=
    <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>ppc_thread_state_t</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>vm_address_t</name></type> <name>start_addr</name> <init>= <expr><name><name>machine_state</name>-&gt;<name>r1</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>WriteStackFromStartAddress</name><argument_list>(<argument><expr><name>start_addr</name></expr></argument>, <argument><expr><name>stack_location</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>u_int64_t</name></type> <name><name>MinidumpGenerator</name>::<name>CurrentPCForStack</name></name><parameter_list>(<param><decl><type><name>breakpad_thread_state_data_t</name></type> <name>state</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>ppc_thread_state_t</name> *</type><name>machine_state</name> <init>=
    <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>ppc_thread_state_t</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><name><name>machine_state</name>-&gt;<name>srr0</name></name></expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteContext</name></name><parameter_list>(<param><decl><type><name>breakpad_thread_state_data_t</name></type> <name>state</name></decl></param>,
                                     <param><decl><type><name>MDLocationDescriptor</name> *</type><name>register_location</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDRawContextPPC</name></expr></argument>&gt;</argument_list></name></type> <name>context</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ppc_thread_state_t</name> *</type><name>machine_state</name> <init>=
    <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>ppc_thread_state_t</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name><name>context</name>.<name>Allocate</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr>*<name>register_location</name> = <call><name><name>context</name>.<name>location</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>MDRawContextPPC</name> *</type><name>context_ptr</name> <init>= <expr><call><name><name>context</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>context_ptr</name>-&gt;<name>context_flags</name></name> = <name>MD_CONTEXT_PPC_BASE</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AddReg</name><parameter_list>(<param><type><name>a</name></type></param>)</parameter_list></cpp:macro> <cpp:value>context_ptr-&gt;a = machine_state-&gt;a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AddGPR</name><parameter_list>(<param><type><name>a</name></type></param>)</parameter_list></cpp:macro> <cpp:value>context_ptr-&gt;gpr[a] = machine_state-&gt;r ## a</cpp:value></cpp:define>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>srr0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>xer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>ctr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>vrsave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>11</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>13</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>14</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>15</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>17</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>18</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>19</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>20</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>21</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>22</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>23</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>25</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>26</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>27</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>28</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>29</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>30</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddGPR</name><argument_list>(<argument><expr>31</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>true</expr>;</return>
}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>TARGET_CPU_X86</name></expr></cpp:elif>
<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteStack</name></name><parameter_list>(<param><decl><type><name>breakpad_thread_state_data_t</name></type> <name>state</name></decl></param>,
                                   <param><decl><type><name>MDMemoryDescriptor</name> *</type><name>stack_location</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>x86_thread_state_t</name> *</type><name>machine_state</name> <init>=
    <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>x86_thread_state_t</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>vm_address_t</name></type> <name>start_addr</name> <init>= <expr><name><name>machine_state</name>-&gt;<name>uts</name>.<name>ts32</name>.<name>esp</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>WriteStackFromStartAddress</name><argument_list>(<argument><expr><name>start_addr</name></expr></argument>, <argument><expr><name>stack_location</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>u_int64_t</name></type> <name><name>MinidumpGenerator</name>::<name>CurrentPCForStack</name></name><parameter_list>(<param><decl><type><name>breakpad_thread_state_data_t</name></type> <name>state</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>x86_thread_state_t</name> *</type><name>machine_state</name> <init>=
    <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>x86_thread_state_t</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><name><name>machine_state</name>-&gt;<name>uts</name>.<name>ts32</name>.<name>eip</name></name></expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteContext</name></name><parameter_list>(<param><decl><type><name>breakpad_thread_state_data_t</name></type> <name>state</name></decl></param>,
                                     <param><decl><type><name>MDLocationDescriptor</name> *</type><name>register_location</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDRawContextX86</name></expr></argument>&gt;</argument_list></name></type> <name>context</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>x86_thread_state_t</name> *</type><name>machine_state</name> <init>=
    <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>x86_thread_state_t</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name><name>context</name>.<name>Allocate</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr>*<name>register_location</name> = <call><name><name>context</name>.<name>location</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>MDRawContextX86</name> *</type><name>context_ptr</name> <init>= <expr><call><name><name>context</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>context_ptr</name>-&gt;<name>context_flags</name></name> = <name>MD_CONTEXT_X86</name></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AddReg</name><parameter_list>(<param><type><name>a</name></type></param>)</parameter_list></cpp:macro> <cpp:value>context_ptr-&gt;a = machine_state-&gt;uts.ts32.a</cpp:value></cpp:define>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>eip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>eax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>ebx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>ecx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>edx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>esi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>edi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>ebp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AddReg</name><argument_list>(<argument><expr><name>esp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>true</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteThreadStream</name></name><parameter_list>(<param><decl><type><name>mach_port_t</name></type> <name>thread_id</name></decl></param>,
                                          <param><decl><type><name>MDRawThread</name> *</type><name>thread</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>breakpad_thread_state_data_t</name></type> <name>state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>state_count</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>thread_get_state</name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>, <argument><expr><name>MACHINE_THREAD_STATE</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr>&amp;<name>state_count</name></expr></argument>)</argument_list></call> ==
      <name>KERN_SUCCESS</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>WriteStack</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr>&amp;<name><name>thread</name>-&gt;<name>stack</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr>false</expr>;</return></then></if>

    <if>if <condition>(<expr>!<call><name>WriteContext</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr>&amp;<name><name>thread</name>-&gt;<name>thread_context</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><name><name>thread</name>-&gt;<name>thread_id</name></name> = <name>thread_id</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <return>return <expr>false</expr>;</return>
  }</block></else></if>

  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteThreadListStream</name></name><parameter_list>(
    <param><decl><type><name>MDRawDirectory</name> *</type><name>thread_list_stream</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDRawThreadList</name></expr></argument>&gt;</argument_list></name></type> <name>list</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>thread_act_port_array_t</name></type> <name>threads_for_task</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>thread_count</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>non_generator_thread_count</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>task_threads</name><argument_list>(<argument><expr><name>crashing_task_</name></expr></argument>, <argument><expr>&amp;<name>threads_for_task</name></expr></argument>, <argument><expr>&amp;<name>thread_count</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <comment type="line">// Don't include the generator thread</comment>
  <expr_stmt><expr><name>non_generator_thread_count</name> = <name>thread_count</name> - 1</expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name><name>list</name>.<name>AllocateObjectAndArray</name></name><argument_list>(<argument><expr><name>non_generator_thread_count</name></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MDRawThread</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><name><name>thread_list_stream</name>-&gt;<name>stream_type</name></name> = <name>MD_THREAD_LIST_STREAM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>thread_list_stream</name>-&gt;<name>location</name></name> = <call><name><name>list</name>.<name>location</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>list</name>.<name>get</name></name><argument_list>()</argument_list></call>-&gt;<name>number_of_threads</name> = <name>non_generator_thread_count</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>MDRawThread</name></type> <name>thread</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>thread_idx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <for>for (<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>thread_count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>thread</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MDRawThread</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>threads_for_task</name><index>[<expr><name>i</name></expr>]</index></name> != <name>handler_thread_</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>WriteThreadStream</name><argument_list>(<argument><expr><name><name>threads_for_task</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>thread</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

      <expr_stmt><expr><call><name><name>list</name>.<name>CopyIndexAfterObject</name></name><argument_list>(<argument><expr><name>thread_idx</name>++</expr></argument>, <argument><expr>&amp;<name>thread</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MDRawThread</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteExceptionStream</name></name><parameter_list>(<param><decl><type><name>MDRawDirectory</name> *</type><name>exception_stream</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDRawExceptionStream</name></expr></argument>&gt;</argument_list></name></type> <name>exception</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name><name>exception</name>.<name>Allocate</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><name><name>exception_stream</name>-&gt;<name>stream_type</name></name> = <name>MD_EXCEPTION_STREAM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exception_stream</name>-&gt;<name>location</name></name> = <call><name><name>exception</name>.<name>location</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>MDRawExceptionStream</name> *</type><name>exception_ptr</name> <init>= <expr><call><name><name>exception</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>exception_ptr</name>-&gt;<name>thread_id</name></name> = <name>exception_thread_</name></expr>;</expr_stmt>

  <comment type="line">// This naming is confusing, but it is the proper translation from</comment>
  <comment type="line">// mach naming to minidump naming.</comment>
  <expr_stmt><expr><name><name>exception_ptr</name>-&gt;<name>exception_record</name>.<name>exception_code</name></name> = <name>exception_type_</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exception_ptr</name>-&gt;<name>exception_record</name>.<name>exception_flags</name></name> = <name>exception_code_</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>breakpad_thread_state_data_t</name></type> <name>state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>mach_msg_type_number_t</name></type> <name>stateCount</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>thread_get_state</name><argument_list>(<argument><expr><name>exception_thread_</name></expr></argument>, <argument><expr><name>MACHINE_THREAD_STATE</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                       <argument><expr>&amp;<name>stateCount</name></expr></argument>)</argument_list></call> != <name>KERN_SUCCESS</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <if>if <condition>(<expr>!<call><name>WriteContext</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr>&amp;<name><name>exception_ptr</name>-&gt;<name>thread_context</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><name><name>exception_ptr</name>-&gt;<name>exception_record</name>.<name>exception_address</name></name> = <call><name>CurrentPCForStack</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteSystemInfoStream</name></name><parameter_list>(
    <param><decl><type><name>MDRawDirectory</name> *</type><name>system_info_stream</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDRawSystemInfo</name></expr></argument>&gt;</argument_list></name></type> <name>info</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name><name>info</name>.<name>Allocate</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><name><name>system_info_stream</name>-&gt;<name>stream_type</name></name> = <name>MD_SYSTEM_INFO_STREAM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>system_info_stream</name>-&gt;<name>location</name></name> = <call><name><name>info</name>.<name>location</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// CPU Information</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>cpu_type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>cpu_type</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sysctlbyname</name><argument_list>(<argument><expr>"hw.cputype"</expr></argument>, <argument><expr>&amp;<name>cpu_type</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>number_of_processors</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>number_of_processors</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sysctlbyname</name><argument_list>(<argument><expr>"hw.ncpu"</expr></argument>, <argument><expr>&amp;<name>number_of_processors</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>MDRawSystemInfo</name> *</type><name>info_ptr</name> <init>= <expr><call><name><name>info</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>cpu_type</name></expr>)</condition> <block>{
    <case>case <expr><name>CPU_TYPE_POWERPC</name></expr>:
      <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>processor_architecture</name></name> = <name>MD_CPU_ARCHITECTURE_PPC</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>CPU_TYPE_I386</name></expr>:
      <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>processor_architecture</name></name> = <name>MD_CPU_ARCHITECTURE_X86</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><default>default:
      <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>processor_architecture</name></name> = <name>MD_CPU_ARCHITECTURE_UNKNOWN</name></expr>;</expr_stmt>
      <break>break;</break>
  </default>}</block></switch>

  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>number_of_processors</name></name> = <name>number_of_processors</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>platform_id</name></name> = <name>MD_OS_MAC_OS_X</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>MDLocationDescriptor</name></type> <name>build_string_loc</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name><name>writer_</name>.<name>WriteString</name></name><argument_list>(<argument><expr><name>build_string_</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr>&amp;<name>build_string_loc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>csd_version_rva</name></name> = <name><name>build_string_loc</name>.<name>rva</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>major_version</name></name> = <name>os_major_version_</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>minor_version</name></name> = <name>os_minor_version_</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>build_number</name></name> = <name>os_build_number_</name></expr>;</expr_stmt>

  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteModuleStream</name></name><parameter_list>(<param><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl></param>,
                                          <param><decl><type><name>MDRawModule</name> *</type><name>module</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>DynamicImage</name> *</type><name>image</name> <init>= <expr><call><name><name>dynamic_images_</name>-&gt;<name>GetImage</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>image</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <decl_stmt><decl><type><specifier>const</specifier> <name>mach_header</name> *</type><name>header</name> <init>= <expr><call><name><name>image</name>-&gt;<name>GetMachHeader</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>header</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <decl_stmt><decl><type><name>int</name></type> <name>cpu_type</name> <init>= <expr><name><name>header</name>-&gt;<name>cputype</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MDRawModule</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>MDLocationDescriptor</name></type> <name>string_location</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>name</name> <init>= <expr><call><name><name>image</name>-&gt;<name>GetFilePath</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>writer_</name>.<name>WriteString</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>string_location</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><name><name>module</name>-&gt;<name>base_of_image</name></name> = <call><name><name>image</name>-&gt;<name>GetVMAddr</name></name><argument_list>()</argument_list></call> + <call><name><name>image</name>-&gt;<name>GetVMAddrSlide</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>module</name>-&gt;<name>size_of_image</name></name> = <call><name><name>image</name>-&gt;<name>GetVMSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>module</name>-&gt;<name>module_name_rva</name></name> = <name><name>string_location</name>.<name>rva</name></name></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>WriteCVRecord</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>cpu_type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr>false</expr>;</return>
  }</block></then></if>

  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>MinidumpGenerator</name>::<name>FindExecutableModule</name></name><parameter_list>()</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name><name>dynamic_images_</name>-&gt;<name>GetExecutableImageIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>index</name> &gt;= 0</expr>)</condition><then> <block>{
    <return>return <expr><name>index</name></expr>;</return>
  }</block></then></if>
  
  <comment type="line">// failed - just use the first image</comment>
  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteCVRecord</name></name><parameter_list>(<param><decl><type><name>MDRawModule</name> *</type><name>module</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpu_type</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>module_path</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDCVInfoPDB70</name></expr></argument>&gt;</argument_list></name></type> <name>cv</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <comment type="line">// Only return the last path component of the full module path</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>module_name</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>module_path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Increment past the slash</comment>
  <if>if <condition>(<expr><name>module_name</name></expr>)</condition><then>
    <expr_stmt><expr>++<name>module_name</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>module_name</name> = "&lt;Unknown&gt;"</expr>;</expr_stmt></else></if>

  <decl_stmt><decl><type><name>size_t</name></type> <name>module_name_length</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>module_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name><name>cv</name>.<name>AllocateObjectAndArray</name></name><argument_list>(<argument><expr><name>module_name_length</name> + 1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u_int8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <if>if <condition>(<expr>!<call><name><name>cv</name>.<name>CopyIndexAfterObject</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>module_name</name></expr></argument>, <argument><expr><name>module_name_length</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><name><name>module</name>-&gt;<name>cv_record</name></name> = <call><name><name>cv</name>.<name>location</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>MDCVInfoPDB70</name> *</type><name>cv_ptr</name> <init>= <expr><call><name><name>cv</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>cv_signature</name></name> = <name>MD_CVINFOPDB70_SIGNATURE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>age</name></name> = 0</expr>;</expr_stmt>

  <comment type="line">// Get the module identifier</comment>
  <function_decl><type><name>FileID</name></type> <name>file_id</name><parameter_list>(<param><decl><type><name>module_path</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>identifier</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
  
  <if>if <condition>(<expr><call><name><name>file_id</name>.<name>MachoIdentifier</name></name><argument_list>(<argument><expr><name>cpu_type</name></expr></argument>, <argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data1</name></name> = (<name>uint32_t</name>)<name><name>identifier</name><index>[<expr>0</expr>]</index></name> &lt;&lt; 24 | 
      (<name>uint32_t</name>)<name><name>identifier</name><index>[<expr>1</expr>]</index></name> &lt;&lt; 16 | (<name>uint32_t</name>)<name><name>identifier</name><index>[<expr>2</expr>]</index></name> &lt;&lt; 8 |
      (<name>uint32_t</name>)<name><name>identifier</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data2</name></name> = (<name>uint32_t</name>)<name><name>identifier</name><index>[<expr>4</expr>]</index></name> &lt;&lt; 8 | <name><name>identifier</name><index>[<expr>5</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data3</name></name> = (<name>uint32_t</name>)<name><name>identifier</name><index>[<expr>6</expr>]</index></name> &lt;&lt; 8 | <name><name>identifier</name><index>[<expr>7</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data4</name><index>[<expr>0</expr>]</index></name> = <name><name>identifier</name><index>[<expr>8</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data4</name><index>[<expr>1</expr>]</index></name> = <name><name>identifier</name><index>[<expr>9</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data4</name><index>[<expr>2</expr>]</index></name> = <name><name>identifier</name><index>[<expr>10</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data4</name><index>[<expr>3</expr>]</index></name> = <name><name>identifier</name><index>[<expr>11</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data4</name><index>[<expr>4</expr>]</index></name> = <name><name>identifier</name><index>[<expr>12</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data4</name><index>[<expr>5</expr>]</index></name> = <name><name>identifier</name><index>[<expr>13</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data4</name><index>[<expr>6</expr>]</index></name> = <name><name>identifier</name><index>[<expr>14</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cv_ptr</name>-&gt;<name>signature</name>.<name>data4</name><index>[<expr>7</expr>]</index></name> = <name><name>identifier</name><index>[<expr>15</expr>]</index></name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteModuleListStream</name></name><parameter_list>(
    <param><decl><type><name>MDRawDirectory</name> *</type><name>module_list_stream</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDRawModuleList</name></expr></argument>&gt;</argument_list></name></type> <name>list</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name>_dyld_present</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <decl_stmt><decl><type><name>int</name></type> <name>image_count</name> <init>= <expr><call><name><name>dynamic_images_</name>-&gt;<name>GetImageCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name><name>list</name>.<name>AllocateObjectAndArray</name></name><argument_list>(<argument><expr><name>image_count</name></expr></argument>, <argument><expr><name>MD_MODULE_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><name><name>module_list_stream</name>-&gt;<name>stream_type</name></name> = <name>MD_MODULE_LIST_STREAM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>module_list_stream</name>-&gt;<name>location</name></name> = <call><name><name>list</name>.<name>location</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>list</name>.<name>get</name></name><argument_list>()</argument_list></call>-&gt;<name>number_of_modules</name> = <name>image_count</name></expr>;</expr_stmt>

  <comment type="line">// Write out the executable module as the first one</comment>
  <decl_stmt><decl><type><name>MDRawModule</name></type> <name>module</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>executableIndex</name> <init>= <expr><call><name>FindExecutableModule</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name>WriteModuleStream</name><argument_list>(<argument><expr><name>executableIndex</name></expr></argument>, <argument><expr>&amp;<name>module</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr>false</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>list</name>.<name>CopyIndexAfterObject</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>&amp;<name>module</name></expr></argument>, <argument><expr><name>MD_MODULE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>destinationIndex</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>  <comment type="line">// Write all other modules after this one</comment>

  <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>image_count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <if>if <condition>(<expr><name>i</name> != <name>executableIndex</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>WriteModuleStream</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>module</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>false</expr>;</return>
      }</block></then></if>

      <expr_stmt><expr><call><name><name>list</name>.<name>CopyIndexAfterObject</name></name><argument_list>(<argument><expr><name>destinationIndex</name>++</expr></argument>, <argument><expr>&amp;<name>module</name></expr></argument>, <argument><expr><name>MD_MODULE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteMiscInfoStream</name></name><parameter_list>(<param><decl><type><name>MDRawDirectory</name> *</type><name>misc_info_stream</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDRawMiscInfo</name></expr></argument>&gt;</argument_list></name></type> <name>info</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name><name>info</name>.<name>Allocate</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><name><name>misc_info_stream</name>-&gt;<name>stream_type</name></name> = <name>MD_MISC_INFO_STREAM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>misc_info_stream</name>-&gt;<name>location</name></name> = <call><name><name>info</name>.<name>location</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>MDRawMiscInfo</name> *</type><name>info_ptr</name> <init>= <expr><call><name><name>info</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>size_of_info</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>MDRawMiscInfo</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>flags1</name></name> = <name>MD_MISCINFO_FLAGS1_PROCESS_ID</name> |
    <name>MD_MISCINFO_FLAGS1_PROCESS_TIMES</name> |
    <name>MD_MISCINFO_FLAGS1_PROCESSOR_POWER_INFO</name></expr>;</expr_stmt>

  <comment type="line">// Process ID</comment>
  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>process_id</name></name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Times</comment>
  <decl_stmt><decl><type>struct <name>rusage</name></type> <name>usage</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr>&amp;<name>usage</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
    <comment type="line">// Omit the fractional time since the MDRawMiscInfo only wants seconds</comment>
    <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>process_user_time</name></name> = <name><name>usage</name>.<name>ru_utime</name>.<name>tv_sec</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>process_kernel_time</name></name> = <name><name>usage</name>.<name>ru_stime</name>.<name>tv_sec</name></name></expr>;</expr_stmt>
  }</block></then></if>
  <decl_stmt><decl><type><name>int</name></type> <name><name>mib</name><index>[<expr>4</expr>]</index></name> <init>= <expr><block>{ <expr><name>CTL_KERN</name></expr>, <expr><name>KERN_PROC</name></expr>, <expr><name>KERN_PROC_PID</name></expr>, <expr><name><name>info_ptr</name>-&gt;<name>process_id</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>sysctl</name><argument_list>(<argument><expr><name>mib</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mib</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>mib</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>vm_address_t</name></type> <name>addr</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>vm_allocate</name><argument_list>(<argument><expr><call><name>mach_task_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call> == <name>KERN_SUCCESS</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type>struct <name>kinfo_proc</name> *</type><name>proc</name> <init>= <expr>(struct <name>kinfo_proc</name> *)<name>addr</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<call><name>sysctl</name><argument_list>(<argument><expr><name>mib</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mib</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>mib</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>process_create_time</name></name> = <name><name>proc</name>-&gt;<name>kp_proc</name>.<name>p_starttime</name>.<name>tv_sec</name></name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>vm_deallocate</name><argument_list>(<argument><expr><call><name>mach_task_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Speed</comment>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>speed</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>size</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>speed</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sysctlbyname</name><argument_list>(<argument><expr>"hw.cpufrequency_max"</expr></argument>, <argument><expr>&amp;<name>speed</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>processor_max_mhz</name></name> = <name>speed</name> / (1000 * 1000)</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>processor_mhz_limit</name></name> = <name>speed</name> / (1000 * 1000)</expr>;</expr_stmt>
  <expr_stmt><expr><name>size</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>speed</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sysctlbyname</name><argument_list>(<argument><expr>"hw.cpufrequency"</expr></argument>, <argument><expr>&amp;<name>speed</name></expr></argument>, <argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>processor_current_mhz</name></name> = <name>speed</name> / (1000 * 1000)</expr>;</expr_stmt>

  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name><name>MinidumpGenerator</name>::<name>WriteBreakpadInfoStream</name></name><parameter_list>(
    <param><decl><type><name>MDRawDirectory</name> *</type><name>breakpad_info_stream</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>TypedMDRVA</name><argument_list>&lt;<argument><expr><name>MDRawBreakpadInfo</name></expr></argument>&gt;</argument_list></name></type> <name>info</name><argument_list>(<argument><expr>&amp;<name>writer_</name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name><name>info</name>.<name>Allocate</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><name><name>breakpad_info_stream</name>-&gt;<name>stream_type</name></name> = <name>MD_BREAKPAD_INFO_STREAM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>breakpad_info_stream</name>-&gt;<name>location</name></name> = <call><name><name>info</name>.<name>location</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>MDRawBreakpadInfo</name> *</type><name>info_ptr</name> <init>= <expr><call><name><name>info</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>exception_thread_</name> &amp;&amp; <name>exception_type_</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>validity</name></name> = <name>MD_BREAKPAD_INFO_VALID_DUMP_THREAD_ID</name> |
                         <name>MD_BREAKPAD_INFO_VALID_REQUESTING_THREAD_ID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>dump_thread_id</name></name> = <name>handler_thread_</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>requesting_thread_id</name></name> = <name>exception_thread_</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>validity</name></name> = <name>MD_BREAKPAD_INFO_VALID_DUMP_THREAD_ID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>dump_thread_id</name></name> = <name>handler_thread_</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info_ptr</name>-&gt;<name>requesting_thread_id</name></name> = 0</expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr>true</expr>;</return>
}</block></function>

}</block></namespace>  <comment type="line">// namespace google_breakpad</comment>
</unit>
