<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="006f6e4a0d2d1c77450c782ebd999ed2b18e56b2.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* vim: set ts=2 sw=2 et tw=80: */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Pierre Phaneuf &lt;pp@ludusdesign.com&gt;
 *   Mats Palmgren &lt;mats.palmgren@bredband.net&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsVoidArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTableFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRenderingContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleConsts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCellMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTableCellFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHTMLParts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTableColFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTableColGroupFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTableRowFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTableRowGroupFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTableOuterFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTablePainter.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"BasicTableLayoutStrategy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"FixedTableLayoutStrategy.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPresContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSRendering.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleConsts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGkAtoms.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSAnonBoxes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPresShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLBodyElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScrollableFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSRendering.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutErrors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSFrameConstructor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDisplayList.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/********************************************************************************
 ** nsTableReflowState                                                         **
 ********************************************************************************/</comment>

<struct>struct <name>nsTableReflowState</name> <block>{<public type="default">

  <comment type="line">// the real reflow state</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>reflowState</name></decl>;</decl_stmt>

  <comment type="line">// The table's available size </comment>
  <decl_stmt><decl><type><name>nsSize</name></type> <name>availSize</name></decl>;</decl_stmt>

  <comment type="line">// Stationary x-offset</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>x</name></decl>;</decl_stmt>

  <comment type="line">// Running y-offset</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>y</name></decl>;</decl_stmt>

  <constructor><name>nsTableReflowState</name><parameter_list>(<param><decl><type><name>nsPresContext</name>&amp;</type>          <name>aPresContext</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                     <param><decl><type><name>nsTableFrame</name>&amp;</type>            <name>aTableFrame</name></decl></param>,
                     <param><decl><type><name>nscoord</name></type>                  <name>aAvailWidth</name></decl></param>,
                     <param><decl><type><name>nscoord</name></type>                  <name>aAvailHeight</name></decl></param>)</parameter_list>
    <member_list>: <call><name>reflowState</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>Init</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aTableFrame</name></expr></argument>, <argument><expr><name>aAvailWidth</name></expr></argument>, <argument><expr><name>aAvailHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>

  <function><type><name>void</name></type> <name>Init</name><parameter_list>(<param><decl><type><name>nsPresContext</name>&amp;</type> <name>aPresContext</name></decl></param>,
            <param><decl><type><name>nsTableFrame</name>&amp;</type>   <name>aTableFrame</name></decl></param>,
            <param><decl><type><name>nscoord</name></type>         <name>aAvailWidth</name></decl></param>,
            <param><decl><type><name>nscoord</name></type>         <name>aAvailHeight</name></decl></param>)</parameter_list>
  <block>{
    <decl_stmt><decl><type><name>nsTableFrame</name>*</type> <name>table</name> <init>= <expr>(<name>nsTableFrame</name>*)<call><name><name>aTableFrame</name>.<name>GetFirstInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsMargin</name></type> <name>borderPadding</name> <init>= <expr><call><name><name>table</name>-&gt;<name>GetChildAreaOffset</name></name><argument_list>(<argument><expr>&amp;<name>reflowState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>cellSpacingX</name> <init>= <expr><call><name><name>table</name>-&gt;<name>GetCellSpacingX</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>x</name> = <name><name>borderPadding</name>.<name>left</name></name> + <name>cellSpacingX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> = <name><name>borderPadding</name>.<name>top</name></name></expr>;</expr_stmt> <comment type="line">//cellspacing added during reflow</comment>

    <expr_stmt><expr><name><name>availSize</name>.<name>width</name></name>  = <name>aAvailWidth</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>NS_UNCONSTRAINEDSIZE</name> != <name><name>availSize</name>.<name>width</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>availSize</name>.<name>width</name></name> -= <name><name>borderPadding</name>.<name>left</name></name> + <name><name>borderPadding</name>.<name>right</name></name>
                         + (2 * <name>cellSpacingX</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>availSize</name>.<name>width</name></name> = <call><name>PR_MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name><name>availSize</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>availSize</name>.<name>height</name></name> = <name>aAvailHeight</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>NS_UNCONSTRAINEDSIZE</name> != <name><name>availSize</name>.<name>height</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>availSize</name>.<name>height</name></name> -= <name><name>borderPadding</name>.<name>top</name></name> + <name><name>borderPadding</name>.<name>bottom</name></name>
                          + (2 * <call><name><name>table</name>-&gt;<name>GetCellSpacingY</name></name><argument_list>()</argument_list></call>)</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>availSize</name>.<name>height</name></name> = <call><name>PR_MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name><name>availSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></function>

  <constructor><name>nsTableReflowState</name><parameter_list>(<param><decl><type><name>nsPresContext</name>&amp;</type>          <name>aPresContext</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                     <param><decl><type><name>nsTableFrame</name>&amp;</type>            <name>aTableFrame</name></decl></param>)</parameter_list>
    <member_list>: <call><name>reflowState</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>Init</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aTableFrame</name></expr></argument>, <argument><expr><name><name>aReflowState</name>.<name>availableWidth</name></name></expr></argument>, <argument><expr><name><name>aReflowState</name>.<name>availableHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>

</public>}</block>;</struct>

<comment type="block" format="doxygen">/********************************************************************************
 ** nsTableFrame                                                               **
 ********************************************************************************/</comment>

<struct>struct <name>BCPropertyData</name>
<block>{<public type="default">
  <constructor><name>BCPropertyData</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name><name>mDamageArea</name>.<name>x</name></name> = <name><name>mDamageArea</name>.<name>y</name></name> = <name><name>mDamageArea</name>.<name>width</name></name> = <name><name>mDamageArea</name>.<name>height</name></name> =
                     <name>mTopBorderWidth</name> = <name>mRightBorderWidth</name> = <name>mBottomBorderWidth</name> = <name>mLeftBorderWidth</name> = 0</expr>;</expr_stmt> }</block></constructor>
  <decl_stmt><decl><type><name>nsRect</name></type>  <name>mDamageArea</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>mTopBorderWidth</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>mRightBorderWidth</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>mBottomBorderWidth</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>mLeftBorderWidth</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>nsTableFrame</name>::<name>GetParentStyleContextFrame</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>,
                                         <param><decl><type><name>nsIFrame</name>**</type>      <name>aProviderFrame</name></decl></param>,
                                         <param><decl><type><name>PRBool</name>*</type>         <name>aIsChild</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Since our parent, the table outer frame, returned this frame, we</comment>
  <comment type="line">// must return whatever our parent would normally have returned.</comment>

  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>mParent</name></expr></argument>, <argument><expr>"table constructed without outer table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name><name>mContent</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>GetStyleContext</name><argument_list>()</argument_list></call>-&gt;<call><name>GetPseudoType</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// We're the root.  We have no style context parent.</comment>
    <expr_stmt><expr>*<name>aIsChild</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>aProviderFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
    
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mParent</name></expr></argument>)</argument_list></call>-&gt;
          <call><name>DoGetParentStyleContextFrame</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aProviderFrame</name></expr></argument>, <argument><expr><name>aIsChild</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>nsIAtom</name>*</type>
<name><name>nsTableFrame</name>::<name>GetType</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name><name>nsGkAtoms</name>::<name>tableFrame</name></name></expr>;</return> 
}</block></function>


<constructor><name><name>nsTableFrame</name>::<name>nsTableFrame</name></name><parameter_list>(<param><decl><type><name>nsStyleContext</name>*</type> <name>aContext</name></decl></param>)</parameter_list>
  <member_list>: <call><name>nsHTMLContainerFrame</name><argument_list>(<argument><expr><name>aContext</name></expr></argument>)</argument_list></call>,
    <call><name>mCellMap</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
    <call><name>mTableLayoutStrategy</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><name><name>mBits</name>.<name>mHaveReflowedColGroups</name></name>  = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBits</name>.<name>mCellSpansPctCol</name></name>        = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBits</name>.<name>mNeedToCalcBCBorders</name></name>    = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBits</name>.<name>mIsBorderCollapse</name></name>       = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mBits</name>.<name>mResizedColumns</name></name>         = <name>PR_FALSE</name></expr>;</expr_stmt> <comment type="line">// only really matters if splitting</comment>
  <expr_stmt><expr><name><name>mBits</name>.<name>mGeometryDirty</name></name>          = <name>PR_FALSE</name></expr>;</expr_stmt>
}</block></constructor>

<macro><name>NS_IMPL_ADDREF_INHERITED</name><argument_list>(<argument>nsTableFrame</argument>, <argument>nsHTMLContainerFrame</argument>)</argument_list></macro>
<macro><name>NS_IMPL_RELEASE_INHERITED</name><argument_list>(<argument>nsTableFrame</argument>, <argument>nsHTMLContainerFrame</argument>)</argument_list></macro>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>QueryInterface</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIID</name>&amp;</type> <name>aIID</name></decl></param>, <param><decl><type><name>void</name>**</type> <name>aInstancePtr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aInstancePtr</name></expr></argument>, <argument><expr>"null out param"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name><name>aIID</name>.<name>Equals</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsITableLayout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aInstancePtr</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsITableLayout</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><call><name><name>nsHTMLContainerFrame</name>::<name>QueryInterface</name></name><argument_list>(<argument><expr><name>aIID</name></expr></argument>, <argument><expr><name>aInstancePtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>Init</name></name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type>      <name>aContent</name></decl></param>,
                   <param><decl><type><name>nsIFrame</name>*</type>        <name>aParent</name></decl></param>,
                   <param><decl><type><name>nsIFrame</name>*</type>        <name>aPrevInFlow</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type>  <name>rv</name></decl>;</decl_stmt>

  <comment type="line">// Let the base class do its processing</comment>
  <expr_stmt><expr><name>rv</name> = <call><name><name>nsHTMLContainerFrame</name>::<name>Init</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>aParent</name></expr></argument>, <argument><expr><name>aPrevInFlow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// record that children that are ignorable whitespace should be excluded </comment>
  <expr_stmt><expr><name>mState</name> |= <name>NS_FRAME_EXCLUDE_IGNORABLE_WHITESPACE</name></expr>;</expr_stmt>

  <comment type="line">// see if border collapse is on, if so set it</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleTableBorder</name>*</type> <name>tableStyle</name> <init>= <expr><call><name>GetStyleTableBorder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>borderCollapse</name> <init>= <expr>(<name>NS_STYLE_BORDER_COLLAPSE</name> == <name><name>tableStyle</name>-&gt;<name>mBorderCollapse</name></name>)</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SetBorderCollapse</name><argument_list>(<argument><expr><name>borderCollapse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Create the cell map</comment>
  <if>if <condition>(<expr>!<name>aPrevInFlow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCellMap</name> = new <call><name>nsTableCellMap</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><name>borderCollapse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mCellMap</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>mCellMap</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></else></if>

  <if>if <condition>(<expr><name>aPrevInFlow</name></expr>)</condition><then> <block>{
    <comment type="line">// set my width, because all frames in a table flow are the same width and</comment>
    <comment type="line">// code in nsTableOuterFrame depends on this being set</comment>
    <expr_stmt><expr><name><name>mRect</name>.<name>width</name></name> = <call><name><name>aPrevInFlow</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call>.<name>width</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mTableLayoutStrategy</name></expr></argument>, <argument><expr>"strategy was created before Init was called"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// create the strategy</comment>
    <if>if <condition>(<expr><call><name>IsAutoLayout</name><argument_list>()</argument_list></call></expr>)</condition><then>
      <expr_stmt><expr><name>mTableLayoutStrategy</name> = new <call><name>BasicTableLayoutStrategy</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><name>mTableLayoutStrategy</name> = new <call><name>FixedTableLayoutStrategy</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr>!<name>mTableLayoutStrategy</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
  }</block></else></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>


<destructor><name><name>nsTableFrame</name>::~<name>nsTableFrame</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>nsnull</name>!=<name>mCellMap</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>delete <name>mCellMap</name></expr>;</expr_stmt> 
    <expr_stmt><expr><name>mCellMap</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>nsnull</name>!=<name>mTableLayoutStrategy</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>delete <name>mTableLayoutStrategy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mTableLayoutStrategy</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></destructor>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>Destroy</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mColGroups</name>.<name>DestroyFrames</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>nsHTMLContainerFrame</name>::<name>Destroy</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Make sure any views are positioned properly</comment>
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>RePositionViews</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>nsContainerFrame</name>::<name>PositionFrameView</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>nsContainerFrame</name>::<name>PositionChildViews</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>IsRepeatedFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<call><name><name>kidFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>tableRowFrame</name></name> ||
          <call><name><name>kidFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>nsGkAtoms</name>::<name>tableRowGroupFrame</name></name>) &amp;&amp;
         (<call><name><name>kidFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_REPEATED_ROW_OR_ROWGROUP</name>)</expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsTableFrame</name>::<name>PageBreakAfter</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>&amp;</type> <name>aSourceFrame</name></decl></param>,
                             <param><decl><type><name>nsIFrame</name>*</type> <name>aNextFrame</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>display</name> <init>= <expr><call><name><name>aSourceFrame</name>.<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// don't allow a page break after a repeated element ...</comment>
  <if>if <condition>(<expr><name><name>display</name>-&gt;<name>mBreakAfter</name></name> &amp;&amp; !<call><name>IsRepeatedFrame</name><argument_list>(<argument><expr>&amp;<name>aSourceFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr>!(<name>aNextFrame</name> &amp;&amp; <call><name>IsRepeatedFrame</name><argument_list>(<argument><expr><name>aNextFrame</name></expr></argument>)</argument_list></call>)</expr>;</return> <comment type="line">// or before</comment>
  }</block></then></if>

  <if>if <condition>(<expr><name>aNextFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>display</name> = <call><name><name>aNextFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// don't allow a page break before a repeated element ...</comment>
    <if>if <condition>(<expr><name><name>display</name>-&gt;<name>mBreakBefore</name></name> &amp;&amp; !<call><name>IsRepeatedFrame</name><argument_list>(<argument><expr><name>aNextFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr>!<call><name>IsRepeatedFrame</name><argument_list>(<argument><expr>&amp;<name>aSourceFrame</name></expr></argument>)</argument_list></call></expr>;</return> <comment type="line">// or after</comment>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// XXX this needs to be cleaned up so that the frame constructor breaks out col group</comment>
<comment type="line">// frames into a separate child list, bug 343048.</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>SetInitialChildList</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type>        <name>aListName</name></decl></param>,
                                  <param><decl><type><name>nsIFrame</name>*</type>       <name>aChildList</name></decl></param>)</parameter_list>
<block>{

  <if>if <condition>(<expr>!<call><name><name>mFrames</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> || !<call><name><name>mColGroups</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// We already have child frames which means we've already been</comment>
    <comment type="line">// initialized</comment>
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"unexpected second call to SetInitialChildList"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>aListName</name></expr>)</condition><then> <block>{
    <comment type="line">// All we know about is the unnamed principal child list</comment>
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"unknown frame list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return>
  }</block></then></if> 
  
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>childFrame</name> <init>= <expr><name>aChildList</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>prevMainChild</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>prevColGroupChild</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <for>for ( <init>;</init> <condition><expr><name>nsnull</name>!=<name>childFrame</name></expr>;</condition> <incr/>)
  <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>childDisplay</name> <init>= <expr><call><name><name>childFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// XXX this if should go away</comment>
    <if>if <condition>(<expr><name>PR_TRUE</name>==<call><name>IsRowGroup</name><argument_list>(<argument><expr><name><name>childDisplay</name>-&gt;<name>mDisplay</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name><name>mFrames</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> 
        <expr_stmt><expr><call><name><name>mFrames</name>.<name>SetFrames</name></name><argument_list>(<argument><expr><name>childFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name><name>prevMainChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>childFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><name>prevMainChild</name> = <name>childFrame</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP</name> == <name><name>childDisplay</name>-&gt;<name>mDisplay</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>tableColGroupFrame</name></name> == <call><name><name>childFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr></argument>,
                   <argument><expr>"This is not a colgroup"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name><name>mColGroups</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mColGroups</name>.<name>SetFrames</name></name><argument_list>(<argument><expr><name>childFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name><name>prevColGroupChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>childFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><name>prevColGroupChild</name> = <name>childFrame</name></expr>;</expr_stmt>
    }</block></then>
    <else>else
    <block>{ <comment type="line">// unknown frames go on the main list for now</comment>
      <if>if <condition>(<expr><call><name><name>mFrames</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mFrames</name>.<name>SetFrames</name></name><argument_list>(<argument><expr><name>childFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name><name>prevMainChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>childFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><name>prevMainChild</name> = <name>childFrame</name></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>prevChild</name> <init>= <expr><name>childFrame</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>childFrame</name> = <call><name><name>childFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>prevChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <if>if <condition>(<expr><name>nsnull</name>!=<name>prevMainChild</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>prevMainChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>nsnull</name>!=<name>prevColGroupChild</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>prevColGroupChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// If we have a prev-in-flow, then we're a table that has been split and</comment>
  <comment type="line">// so don't treat this like an append</comment>
  <if>if <condition>(<expr>!<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// process col groups first so that real cols get constructed before</comment>
    <comment type="line">// anonymous ones due to cells in rows.</comment>
    <expr_stmt><expr><call><name>InsertColGroups</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>mColGroups</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AppendRowGroups</name><argument_list>(<argument><expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// calc collapsing borders if this is the default (row group, col group, child list)</comment>
    <if>if <condition>(<expr>!<name>aChildList</name> &amp;&amp; <call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetRowCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SetBCDamageArea</name><argument_list>(<argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>PRBool</name></type>
<name><name>nsTableFrame</name>::<name>IsContainingBlock</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>AttributeChangedFor</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type>       <name>aFrame</name></decl></param>,
                                       <param><decl><type><name>nsIContent</name>*</type>     <name>aContent</name></decl></param>, 
                                       <param><decl><type><name>nsIAtom</name>*</type>        <name>aAttribute</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>IS_TABLE_CELL</name><argument_list>(<argument><expr><call><name><name>aFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>(<name><name>nsGkAtoms</name>::<name>rowspan</name></name> == <name>aAttribute</name>) || 
        (<name><name>nsGkAtoms</name>::<name>colspan</name></name> == <name>aAttribute</name>)</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
        <comment type="line">// for now just remove the cell from the map and reinsert it</comment>
        <decl_stmt><decl><type><name>nsTableCellFrame</name>*</type> <name>cellFrame</name> <init>= <expr>(<name>nsTableCellFrame</name>*)<name>aFrame</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowIndex</name></decl>, <decl><type ref="prev"/><name>colIndex</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cellFrame</name>-&gt;<name>GetRowIndex</name></name><argument_list>(<argument><expr><name>rowIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cellFrame</name>-&gt;<name>GetColIndex</name></name><argument_list>(<argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RemoveCell</name><argument_list>(<argument><expr><name>cellFrame</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsAutoVoidArray</name></type> <name>cells</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cells</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>cellFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>InsertCells</name><argument_list>(<argument><expr><name>cells</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// XXX Should this use eStyleChange?  It currently doesn't need</comment>
        <comment type="line">// to, but it might given more optimization.</comment>
        <expr_stmt><expr><call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call>-&gt;
          <call><name>FrameNeedsReflow</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>nsIPresShell</name>::<name>eTreeChange</name></name></expr></argument>, <argument><expr><name>NS_FRAME_IS_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
}</block></function>


<comment type="block">/* ****** CellMap methods ******* */</comment>

<comment type="block">/* return the effective col count */</comment>
<function><type><name>PRInt32</name></type> <name><name>nsTableFrame</name>::<name>GetEffectiveColCount</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colCount</name> <init>= <expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// don't count cols at the end that don't have originating cells</comment>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>colX</name> <init>= <expr><name>colCount</name> - 1</expr></init></decl>;</init> <condition><expr><name>colX</name> &gt;= 0</expr>;</condition> <incr><expr><name>colX</name>--</expr></incr>) <block>{
    <if>if <condition>(<expr><call><name>GetNumCellsOriginatingInCol</name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call> &lt;= 0</expr>)</condition><then> <block>{ 
      <expr_stmt><expr><name>colCount</name>--</expr>;</expr_stmt>
    }</block></then>
    <else>else <break>break;</break></else></if>
  }</block></for>
  <return>return <expr><name>colCount</name></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type> <name><name>nsTableFrame</name>::<name>GetIndexOfLastRealCol</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numCols</name> <init>= <expr><call><name><name>mColFrames</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>numCols</name> &gt; 0</expr>)</condition><then> <block>{
    <for>for (<init><decl><type><name>PRInt32</name></type> <name>colX</name> <init>= <expr><name>numCols</name> - 1</expr></init></decl>;</init> <condition><expr><name>colX</name> &gt;= 0</expr>;</condition> <incr><expr><name>colX</name>--</expr></incr>) <block>{ 
      <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name>GetColFrame</name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>colFrame</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>eColAnonymousCell</name> != <call><name><name>colFrame</name>-&gt;<name>GetColType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <return>return <expr><name>colX</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
  <return>return <expr>-1</expr>;</return> 
}</block></function>

<function><type><name>nsTableColFrame</name>*</type>
<name><name>nsTableFrame</name>::<name>GetColFrame</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aColIndex</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"GetColFrame called on next in flow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numCols</name> <init>= <expr><call><name><name>mColFrames</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>aColIndex</name> &gt;= 0) &amp;&amp; (<name>aColIndex</name> &lt; <name>numCols</name>)</expr>)</condition><then> <block>{
    <return>return <expr>(<name>nsTableColFrame</name> *)<call><name><name>mColFrames</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"invalid col index"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></else></if>
}</block></function>

<function><type><name>PRInt32</name></type> <name><name>nsTableFrame</name>::<name>GetEffectiveRowSpan</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type>                 <name>aRowIndex</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>nsTableCellFrame</name>&amp;</type> <name>aCell</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name> <argument_list>(<argument><expr><name>nsnull</name> != <name>cellMap</name></expr></argument>, <argument><expr>"bad call, cellMap not yet allocated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colIndex</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aCell</name>.<name>GetColIndex</name></name><argument_list>(<argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>cellMap</name>-&gt;<name>GetEffectiveRowSpan</name></name><argument_list>(<argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type> <name><name>nsTableFrame</name>::<name>GetEffectiveRowSpan</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsTableCellFrame</name>&amp;</type> <name>aCell</name></decl></param>,
                                          <param><decl><type><name>nsCellMap</name>*</type>              <name>aCellMap</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>tableCellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>tableCellMap</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colIndex</name></decl>, <decl><type ref="prev"/><name>rowIndex</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aCell</name>.<name>GetColIndex</name></name><argument_list>(<argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aCell</name>.<name>GetRowIndex</name></name><argument_list>(<argument><expr><name>rowIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>aCellMap</name></expr>)</condition><then> 
    <return>return <expr><call><name><name>aCellMap</name>-&gt;<name>GetRowSpan</name></name><argument_list>(<argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name><name>tableCellMap</name>-&gt;<name>GetEffectiveRowSpan</name></name><argument_list>(<argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name>PRInt32</name></type> <name><name>nsTableFrame</name>::<name>GetEffectiveColSpan</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsTableCellFrame</name>&amp;</type> <name>aCell</name></decl></param>,
                                          <param><decl><type><name>nsCellMap</name>*</type>              <name>aCellMap</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>tableCellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>tableCellMap</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colIndex</name></decl>, <decl><type ref="prev"/><name>rowIndex</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aCell</name>.<name>GetColIndex</name></name><argument_list>(<argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aCell</name>.<name>GetRowIndex</name></name><argument_list>(<argument><expr><name>rowIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>ignore</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>aCellMap</name></expr>)</condition><then> 
    <return>return <expr><call><name><name>aCellMap</name>-&gt;<name>GetEffectiveColSpan</name></name><argument_list>(<argument><expr>*<name>tableCellMap</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>, <argument><expr><name>ignore</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name><name>tableCellMap</name>-&gt;<name>GetEffectiveColSpan</name></name><argument_list>(<argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsTableFrame</name>::<name>HasMoreThanOneCell</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aRowIndex</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>tableCellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>tableCellMap</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><call><name><name>tableCellMap</name>-&gt;<name>HasMoreThanOneCell</name></name><argument_list>(<argument><expr><name>aRowIndex</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type> <name><name>nsTableFrame</name>::<name>GetEffectiveCOLSAttribute</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name> <argument_list>(<argument><expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"null cellMap."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>result</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>result</name> = <call><name>GetStyleTable</name><argument_list>()</argument_list></call>-&gt;<name>mCols</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numCols</name> <init>= <expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>result</name> &gt; <name>numCols</name></expr>)</condition><then>
    <expr_stmt><expr><name>result</name> = <name>numCols</name></expr>;</expr_stmt></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>AdjustRowIndices</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type>         <name>aRowIndex</name></decl></param>,
                                    <param><decl><type><name>PRInt32</name></type>         <name>aAdjustment</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Iterate over the row groups and adjust the row indices of all rows </comment>
  <comment type="line">// whose index is &gt;= aRowIndex.</comment>
  <decl_stmt><decl><type><name>RowGroupArray</name></type> <name>rowGroups</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><decl><type><name>PRUint32</name></type> <name>rgX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rgX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name>-&gt;<call><name>AdjustRowIndices</name><argument_list>(<argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>aAdjustment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>


<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>ResetRowIndices</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFirstRowGroupFrame</name></decl></param>,
                                   <param><decl><type><name>nsIFrame</name>*</type> <name>aLastRowGroupFrame</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Iterate over the row groups and adjust the row indices of all rows</comment>
  <comment type="line">// omit the rowgroups that will be inserted later</comment>
  <decl_stmt><decl><type><name>RowGroupArray</name></type> <name>rowGroups</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>newRgFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>omitRgFrame</name> <init>= <expr><name>aFirstRowGroupFrame</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>omitRgFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>newRgFrame</name> = <call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>omitRgFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>omitRgFrame</name> == <name>aLastRowGroupFrame</name></expr>)</condition><then>
      <expr_stmt><expr><name>omitRgFrame</name> = <name>nsnull</name></expr>;</expr_stmt></then></if>
  }</block></then></if>

  <for>for (<init><decl><type><name>PRUint32</name></type> <name>rgX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rgX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rgFrame</name> == <name>newRgFrame</name></expr>)</condition><then> <block>{
      <comment type="line">// omit the new rowgroup</comment>
      <if>if <condition>(<expr><name>omitRgFrame</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>omitRgFrame</name> = <call><name><name>omitRgFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>omitRgFrame</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>newRgFrame</name>  = <call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>omitRgFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>omitRgFrame</name> == <name>aLastRowGroupFrame</name></expr>)</condition><then>
            <expr_stmt><expr><name>omitRgFrame</name> = <name>nsnull</name></expr>;</expr_stmt></then></if>
        }</block></then></if>
      }</block></then></if>
    }</block></then>
    <else>else <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rowFrame</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <for>for ( <init>;</init> <condition><expr><name>rowFrame</name></expr>;</condition> <incr><expr><name>rowFrame</name> = <call><name><name>rowFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><name>NS_STYLE_DISPLAY_TABLE_ROW</name>==<call><name><name>rowFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call>-&gt;<name>mDisplay</name></expr>)</condition><then> <block>{
          <expr_stmt><expr>((<name>nsTableRowFrame</name> *)<name>rowFrame</name>)-&gt;<call><name>SetRowIndex</name><argument_list>(<argument><expr><name>rowIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rowIndex</name>++</expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
    }</block></else></if>
  }</block></for>
}</block></function>
<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>InsertColGroups</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type>         <name>aStartColIndex</name></decl></param>,
                                   <param><decl><type><name>nsIFrame</name>*</type>       <name>aFirstFrame</name></decl></param>,
                                   <param><decl><type><name>nsIFrame</name>*</type>       <name>aLastFrame</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colIndex</name> <init>= <expr><name>aStartColIndex</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>firstColGroupToReset</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><name>aFirstFrame</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>didLastFrame</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableColGroupFrame</name></name> == <call><name><name>kidFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>didLastFrame</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>firstColGroupToReset</name> = (<name>nsTableColGroupFrame</name>*)<name>kidFrame</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then>
      <else>else <block>{
        <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>cgFrame</name> <init>= <expr>(<name>nsTableColGroupFrame</name>*)<name>kidFrame</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cgFrame</name>-&gt;<name>SetStartColumnIndex</name></name><argument_list>(<argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>firstCol</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cgFrame</name>-&gt;<name>AddColsToTable</name></name><argument_list>(<argument><expr><name>colIndex</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>firstCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>numCols</name> <init>= <expr><call><name><name>cgFrame</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>colIndex</name> += <name>numCols</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>kidFrame</name> == <name>aLastFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>didLastFrame</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>

  <if>if <condition>(<expr><name>firstColGroupToReset</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>nsTableColGroupFrame</name>::<name>ResetColIndices</name></name><argument_list>(<argument><expr><name>firstColGroupToReset</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>InsertCol</name></name><parameter_list>(<param><decl><type><name>nsTableColFrame</name>&amp;</type> <name>aColFrame</name></decl></param>,
                             <param><decl><type><name>PRInt32</name></type>          <name>aColIndex</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mColFrames</name>.<name>InsertElementAt</name></name><argument_list>(<argument><expr>&amp;<name>aColFrame</name></expr></argument>, <argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsTableColType</name></type> <name>insertedColType</name> <init>= <expr><call><name><name>aColFrame</name>.<name>GetColType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numCacheCols</name> <init>= <expr><call><name><name>mColFrames</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>numMapCols</name> <init>= <expr><call><name><name>cellMap</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>numCacheCols</name> &gt; <name>numMapCols</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>removedFromCache</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>eColAnonymousCell</name> != <name>insertedColType</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>lastCol</name> <init>= <expr>(<name>nsTableColFrame</name> *)<call><name><name>mColFrames</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>numCacheCols</name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>lastCol</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>nsTableColType</name></type> <name>lastColType</name> <init>= <expr><call><name><name>lastCol</name>-&gt;<name>GetColType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>eColAnonymousCell</name> == <name>lastColType</name></expr>)</condition><then> <block>{
            <comment type="line">// remove the col from the cache</comment>
            <expr_stmt><expr><call><name><name>mColFrames</name>.<name>RemoveElementAt</name></name><argument_list>(<argument><expr><name>numCacheCols</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// remove the col from the eColGroupAnonymousCell col group</comment>
            <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>lastColGroup</name> <init>= <expr>(<name>nsTableColGroupFrame</name> *)<call><name><name>mColGroups</name>.<name>LastChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>lastColGroup</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name><name>lastColGroup</name>-&gt;<name>RemoveChild</name></name><argument_list>(<argument><expr>*<name>lastCol</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <comment type="line">// remove the col group if it is empty</comment>
            <if>if <condition>(<expr><call><name><name>lastColGroup</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call> &lt;= 0</expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name><name>mColGroups</name>.<name>DestroyFrame</name></name><argument_list>(<argument><expr>(<name>nsIFrame</name>*)<name>lastColGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>removedFromCache</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if>
      <if>if <condition>(<expr>!<name>removedFromCache</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>AddColsAtEnd</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <comment type="line">// for now, just bail and recalc all of the collapsing borders</comment>
  <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>GetRowCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SetBCDamageArea</name><argument_list>(<argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>RemoveCol</name></name><parameter_list>(<param><decl><type><name>nsTableColGroupFrame</name>*</type> <name>aColGroupFrame</name></decl></param>,
                             <param><decl><type><name>PRInt32</name></type>               <name>aColIndex</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type>                <name>aRemoveFromCache</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type>                <name>aRemoveFromCellMap</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aRemoveFromCache</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mColFrames</name>.<name>RemoveElementAt</name></name><argument_list>(<argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>aRemoveFromCellMap</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>CreateAnonymousColFrames</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>eColAnonymousCell</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <comment type="line">// for now, just bail and recalc all of the collapsing borders</comment>
  <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetRowCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SetBCDamageArea</name><argument_list>(<argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block" format="doxygen">/** Get the cell map for this table frame.  It is not always mCellMap.
  * Only the firstInFlow has a legit cell map
  */</comment>
<function><type><name>nsTableCellMap</name>*</type> <name><name>nsTableFrame</name>::<name>GetCellMap</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsTableFrame</name>*</type> <name>firstInFlow</name> <init>= <expr>(<name>nsTableFrame</name> *)<call><name>GetFirstInFlow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>firstInFlow</name>-&gt;<name>mCellMap</name></name></expr>;</return>
}</block></function>

<comment type="line">// XXX this needs to be moved to nsCSSFrameConstructor</comment>
<function><type><name>nsTableColGroupFrame</name>*</type>
<name><name>nsTableFrame</name>::<name>CreateAnonymousColGroupFrame</name></name><parameter_list>(<param><decl><type><name>nsTableColGroupType</name></type> <name>aColGroupType</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>colGroupContent</name> <init>= <expr><call><name>GetContent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>shell</name> <init>= <expr><call><name><name>presContext</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsStyleContext</name></expr></argument>&gt;</argument_list></name></type> <name>colGroupStyle</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>colGroupStyle</name> = <call><name><name>shell</name>-&gt;<name>StyleSet</name></name><argument_list>()</argument_list></call>-&gt;<call><name>ResolvePseudoStyleFor</name><argument_list>(<argument><expr><name>colGroupContent</name></expr></argument>,
                                                           <argument><expr><name><name>nsCSSAnonBoxes</name>::<name>tableColGroup</name></name></expr></argument>,
                                                           <argument><expr><name>mStyleContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Create a col group frame</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>newFrame</name> <init>= <expr><call><name>NS_NewTableColGroupFrame</name><argument_list>(<argument><expr><name>shell</name></expr></argument>, <argument><expr><name>colGroupStyle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>newFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>((<name>nsTableColGroupFrame</name> *)<name>newFrame</name>)-&gt;<call><name>SetColType</name><argument_list>(<argument><expr><name>aColGroupType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>newFrame</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>colGroupContent</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr>(<name>nsTableColGroupFrame</name> *)<name>newFrame</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>CreateAnonymousColFrames</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type>         <name>aNumColsToAdd</name></decl></param>,
                                       <param><decl><type><name>nsTableColType</name></type>  <name>aColType</name></decl></param>,
                                       <param><decl><type><name>PRBool</name></type>          <name>aDoAppend</name></decl></param>,
                                       <param><decl><type><name>nsIFrame</name>*</type>       <name>aPrevColIn</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aColType</name> != <name>eColAnonymousCol</name></expr></argument>, <argument><expr>"Shouldn't happen"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// get the last col group frame</comment>
  <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>colGroupFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>childFrame</name> <init>= <expr><call><name><name>mColGroups</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>childFrame</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableColGroupFrame</name></name> == <call><name><name>childFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>colGroupFrame</name> = (<name>nsTableColGroupFrame</name> *)<name>childFrame</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>childFrame</name> = <call><name><name>childFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>

  <decl_stmt><decl><type><name>nsTableColGroupType</name></type> <name>lastColGroupType</name> <init>= <expr><name>eColGroupContent</name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>nsTableColGroupType</name></type> <name>newColGroupType</name>  <init>= <expr><name>eColGroupContent</name></expr></init></decl>;</decl_stmt> 
  <if>if <condition>(<expr><name>colGroupFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>lastColGroupType</name> = <call><name><name>colGroupFrame</name>-&gt;<name>GetColType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>eColAnonymousCell</name> == <name>aColType</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>eColGroupAnonymousCell</name> != <name>lastColGroupType</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>newColGroupType</name> = <name>eColGroupAnonymousCell</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"CreateAnonymousColFrames called incorrectly"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></else></if>

  <if>if <condition>(<expr><name>eColGroupContent</name> != <name>newColGroupType</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>colIndex</name> <init>= <expr>(<name>colGroupFrame</name>) ? <call><name><name>colGroupFrame</name>-&gt;<name>GetStartColumnIndex</name></name><argument_list>()</argument_list></call> + <call><name><name>colGroupFrame</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call>
                                       : 0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>colGroupFrame</name> = <call><name>CreateAnonymousColGroupFrame</name><argument_list>(<argument><expr><name>newColGroupType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>colGroupFrame</name></expr>)</condition><then> <block>{
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>mColGroups</name>.<name>AppendFrame</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>colGroupFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// add the new frame to the child list</comment>
    <expr_stmt><expr><call><name><name>colGroupFrame</name>-&gt;<name>SetStartColumnIndex</name></name><argument_list>(<argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>prevCol</name> <init>= <expr>(<name>aDoAppend</name>) ? <call><name><name>colGroupFrame</name>-&gt;<name>GetChildList</name></name><argument_list>()</argument_list></call>.<call><name>LastChild</name><argument_list>()</argument_list></call> : <name>aPrevColIn</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>firstNewFrame</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>CreateAnonymousColFrames</name><argument_list>(<argument><expr><name>colGroupFrame</name></expr></argument>, <argument><expr><name>aNumColsToAdd</name></expr></argument>, <argument><expr><name>aColType</name></expr></argument>,
                           <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>prevCol</name></expr></argument>, <argument><expr>&amp;<name>firstNewFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// XXX this needs to be moved to nsCSSFrameConstructor</comment>
<comment type="line">// Right now it only creates the col frames at the end </comment>
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>CreateAnonymousColFrames</name></name><parameter_list>(<param><decl><type><name>nsTableColGroupFrame</name>*</type> <name>aColGroupFrame</name></decl></param>,
                                       <param><decl><type><name>PRInt32</name></type>               <name>aNumColsToAdd</name></decl></param>,
                                       <param><decl><type><name>nsTableColType</name></type>        <name>aColType</name></decl></param>,
                                       <param><decl><type><name>PRBool</name></type>                <name>aAddToColGroupAndTable</name></decl></param>,         
                                       <param><decl><type><name>nsIFrame</name>*</type>             <name>aPrevFrameIn</name></decl></param>,
                                       <param><decl><type><name>nsIFrame</name>**</type>            <name>aFirstNewFrame</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aColGroupFrame</name></expr></argument>, <argument><expr>"null frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aColType</name> != <name>eColAnonymousCol</name></expr></argument>, <argument><expr>"Shouldn't happen"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>aFirstNewFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>lastColFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>shell</name> <init>= <expr><call><name><name>presContext</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Get the last col frame</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>childFrame</name> <init>= <expr><call><name><name>aColGroupFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>childFrame</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableColFrame</name></name> == <call><name><name>childFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>lastColFrame</name> = (<name>nsTableColGroupFrame</name> *)<name>childFrame</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>childFrame</name> = <call><name><name>childFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startIndex</name> <init>= <expr><call><name><name>mColFrames</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>lastIndex</name>  <init>= <expr><name>startIndex</name> + <name>aNumColsToAdd</name> - 1</expr></init></decl>;</decl_stmt> 

  <for>for (<init><decl><type><name>PRInt32</name></type> <name>childX</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>childX</name> &lt;= <name>lastIndex</name></expr>;</condition> <incr><expr><name>childX</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>iContent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsStyleContext</name></expr></argument>&gt;</argument_list></name></type> <name>styleContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsStyleContext</name>*</type> <name>parentStyleContext</name></decl>;</decl_stmt>

    <comment type="line">// all anonymous cols that we create here use a pseudo style context of the</comment>
    <comment type="line">// col group</comment>
    <expr_stmt><expr><name>iContent</name> = <call><name><name>aColGroupFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>parentStyleContext</name> = <call><name><name>aColGroupFrame</name>-&gt;<name>GetStyleContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>styleContext</name> = <call><name><name>shell</name>-&gt;<name>StyleSet</name></name><argument_list>()</argument_list></call>-&gt;<call><name>ResolvePseudoStyleFor</name><argument_list>(<argument><expr><name>iContent</name></expr></argument>,
                                                            <argument><expr><name><name>nsCSSAnonBoxes</name>::<name>tableCol</name></name></expr></argument>,
                                                            <argument><expr><name>parentStyleContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// ASSERTION to check for bug 54454 sneaking back in...</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>iContent</name></expr></argument>, <argument><expr>"null content in CreateAnonymousColFrames"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// create the new col frame</comment>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name>NS_NewTableColFrame</name><argument_list>(<argument><expr><name>shell</name></expr></argument>, <argument><expr><name>styleContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>((<name>nsTableColFrame</name> *) <name>colFrame</name>)-&gt;<call><name>SetColType</name><argument_list>(<argument><expr><name>aColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>colFrame</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>iContent</name></expr></argument>, <argument><expr><name>aColGroupFrame</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>colFrame</name>-&gt;<name>SetInitialChildList</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Add the col to the sibling chain</comment>
    <if>if <condition>(<expr><name>lastColFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>lastColFrame</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>colFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>lastColFrame</name> = <name>colFrame</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>childX</name> == <name>startIndex</name></expr>)</condition><then> <block>{
      <expr_stmt><expr>*<name>aFirstNewFrame</name> = <name>colFrame</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <if>if <condition>(<expr><name>aAddToColGroupAndTable</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsFrameList</name>&amp;</type> <name>cols</name> <init>= <expr><call><name><name>aColGroupFrame</name>-&gt;<name>GetChildList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// the chain already exists, now add it to the col group child list</comment>
    <if>if <condition>(<expr>!<name>aPrevFrameIn</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>cols</name>.<name>AppendFrames</name></name><argument_list>(<argument><expr><name>aColGroupFrame</name></expr></argument>, <argument><expr>*<name>aFirstNewFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// get the starting col index in the cache</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>startColIndex</name> <init>= <expr><call><name><name>aColGroupFrame</name>-&gt;<name>GetStartColumnIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aPrevFrameIn</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= 
        <expr>(<name>nsTableColFrame</name>*)<call><name><name>nsTableFrame</name>::<name>GetFrameAtOrBefore</name></name><argument_list>(<argument><expr>(<name>nsIFrame</name>*) <name>aColGroupFrame</name></expr></argument>, <argument><expr><name>aPrevFrameIn</name></expr></argument>, 
                                                           <argument><expr><name><name>nsGkAtoms</name>::<name>tableColFrame</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>colFrame</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>startColIndex</name> = <call><name><name>colFrame</name>-&gt;<name>GetColIndex</name></name><argument_list>()</argument_list></call> + 1</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>aColGroupFrame</name>-&gt;<name>AddColsToTable</name></name><argument_list>(<argument><expr><name>startColIndex</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, 
                                  <argument><expr>*<name>aFirstNewFrame</name></expr></argument>, <argument><expr><name>lastColFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>MatchCellMapToColCache</name></name><parameter_list>(<param><decl><type><name>nsTableCellMap</name>*</type> <name>aCellMap</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numColsInMap</name>   <init>= <expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numColsInCache</name> <init>= <expr><call><name><name>mColFrames</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numColsToAdd</name> <init>= <expr><name>numColsInMap</name> - <name>numColsInCache</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>numColsToAdd</name> &gt; 0</expr>)</condition><then> <block>{
    <comment type="line">// this sets the child list, updates the col cache and cell map</comment>
    <expr_stmt><expr><call><name>CreateAnonymousColFrames</name><argument_list>(<argument><expr><name>numColsToAdd</name></expr></argument>, <argument><expr><name>eColAnonymousCell</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  }</block></then></if>
  <if>if <condition>(<expr><name>numColsToAdd</name> &lt; 0</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>numColsNotRemoved</name> <init>= <expr><call><name>DestroyAnonymousColFrames</name><argument_list>(<argument><expr>-<name>numColsToAdd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// if the cell map has fewer cols than the cache, correct it</comment>
    <if>if <condition>(<expr><name>numColsNotRemoved</name> &gt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aCellMap</name>-&gt;<name>AddColsAtEnd</name></name><argument_list>(<argument><expr><name>numColsNotRemoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr><name>numColsToAdd</name> &amp;&amp; <call><name>HasZeroColSpans</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SetNeedColSpanExpansion</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><call><name>NeedColSpanExpansion</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// This flag can be set in two ways -- either by changing</comment>
    <comment type="line">// the number of columns (that happens in the block above),</comment>
    <comment type="line">// or by adding a cell with colspan="0" to the cellmap.  To</comment>
    <comment type="line">// handle the latter case we need to explicitly check the</comment>
    <comment type="line">// flag here -- it may be set even if the number of columns</comment>
    <comment type="line">// did not change.</comment>
    <comment type="line">//</comment>
    <comment type="line">// @see nsCellMap::AppendCell</comment>

    <expr_stmt><expr><call><name><name>aCellMap</name>-&gt;<name>ExpandZeroColSpans</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>DidResizeColumns</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"should only be called on first-in-flow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>mBits</name>.<name>mResizedColumns</name></name></expr>)</condition><then>
    <return>return;</return></then></if> <comment type="line">// already marked</comment>

  <for>for (<init><decl><type><name>nsTableFrame</name> *</type><name>f</name> <init>= <expr><name>this</name></expr></init></decl>;</init> <condition><expr><name>f</name></expr>;</condition>
       <incr><expr><name>f</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTableFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></incr>)
    <expr_stmt><expr><name><name>f</name>-&gt;<name>mBits</name>.<name>mResizedColumns</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt></for>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>AppendCell</name></name><parameter_list>(<param><decl><type><name>nsTableCellFrame</name>&amp;</type> <name>aCellFrame</name></decl></param>,
                         <param><decl><type><name>PRInt32</name></type>           <name>aRowIndex</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>AppendCell</name></name><argument_list>(<argument><expr><name>aCellFrame</name></expr></argument>, <argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MatchCellMapToColCache</name><argument_list>(<argument><expr><name>cellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SetBCDamageArea</name><argument_list>(<argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>InsertCells</name></name><parameter_list>(<param><decl><type><name>nsVoidArray</name>&amp;</type>    <name>aCellFrames</name></decl></param>, 
                               <param><decl><type><name>PRInt32</name></type>         <name>aRowIndex</name></decl></param>, 
                               <param><decl><type><name>PRInt32</name></type>         <name>aColIndexBefore</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>InsertCells</name></name><argument_list>(<argument><expr><name>aCellFrames</name></expr></argument>, <argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>aColIndexBefore</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MatchCellMapToColCache</name><argument_list>(<argument><expr><name>cellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SetBCDamageArea</name><argument_list>(<argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="line">// this removes the frames from the col group and table, but not the cell map</comment>
<function><type><name>PRInt32</name></type> 
<name><name>nsTableFrame</name>::<name>DestroyAnonymousColFrames</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNumFrames</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// only remove cols that are of type eTypeAnonymous cell (they are at the end)</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>endIndex</name>   <init>= <expr><call><name><name>mColFrames</name>.<name>Count</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startIndex</name> <init>= <expr>(<name>endIndex</name> - <name>aNumFrames</name>) + 1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numColsRemoved</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>colX</name> <init>= <expr><name>endIndex</name></expr></init></decl>;</init> <condition><expr><name>colX</name> &gt;= <name>startIndex</name></expr>;</condition> <incr><expr><name>colX</name>--</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name>GetColFrame</name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>colFrame</name> &amp;&amp; (<name>eColAnonymousCell</name> == <call><name><name>colFrame</name>-&gt;<name>GetColType</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>cgFrame</name> <init>=
        <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTableColGroupFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>colFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// remove the frame from the colgroup</comment>
      <expr_stmt><expr><call><name><name>cgFrame</name>-&gt;<name>RemoveChild</name></name><argument_list>(<argument><expr>*<name>colFrame</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// remove the frame from the cache, but not the cell map </comment>
      <expr_stmt><expr><call><name>RemoveCol</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>colX</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>numColsRemoved</name>++</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <break>break;</break> 
    }</block></else></if>
  }</block></for>
  <return>return <expr>(<name>aNumFrames</name> - <name>numColsRemoved</name>)</expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>RemoveCell</name></name><parameter_list>(<param><decl><type><name>nsTableCellFrame</name>*</type> <name>aCellFrame</name></decl></param>,
                              <param><decl><type><name>PRInt32</name></type>           <name>aRowIndex</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>RemoveCell</name></name><argument_list>(<argument><expr><name>aCellFrame</name></expr></argument>, <argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MatchCellMapToColCache</name><argument_list>(<argument><expr><name>cellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SetBCDamageArea</name><argument_list>(<argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>nsTableFrame</name>::<name>GetStartRowIndex</name></name><parameter_list>(<param><decl><type><name>nsTableRowGroupFrame</name>&amp;</type> <name>aRowGroupFrame</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>RowGroupArray</name></type> <name>orderedRowGroups</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>orderedRowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>rgIndex</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rgIndex</name> &lt; <call><name><name>orderedRowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgIndex</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>orderedRowGroups</name><index>[<expr><name>rgIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rgFrame</name> == &amp;<name>aRowGroupFrame</name></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>numRows</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rowIndex</name> += <name>numRows</name></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>rowIndex</name></expr>;</return>
}</block></function>

<comment type="line">// this cannot extend beyond a single row group</comment>
<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>AppendRows</name></name><parameter_list>(<param><decl><type><name>nsTableRowGroupFrame</name>&amp;</type> <name>aRowGroupFrame</name></decl></param>,
                              <param><decl><type><name>PRInt32</name></type>               <name>aRowIndex</name></decl></param>,
                              <param><decl><type><name>nsVoidArray</name>&amp;</type>          <name>aRowFrames</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>absRowIndex</name> <init>= <expr><call><name>GetStartRowIndex</name><argument_list>(<argument><expr><name>aRowGroupFrame</name></expr></argument>)</argument_list></call> + <name>aRowIndex</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>InsertRows</name><argument_list>(<argument><expr><name>aRowGroupFrame</name></expr></argument>, <argument><expr><name>aRowFrames</name></expr></argument>, <argument><expr><name>absRowIndex</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>nsTableFrame</name>::<name>InsertRow</name></name><parameter_list>(<param><decl><type><name>nsTableRowGroupFrame</name>&amp;</type> <name>aRowGroupFrame</name></decl></param>,
                        <param><decl><type><name>nsIFrame</name>&amp;</type>             <name>aRowFrame</name></decl></param>,
                        <param><decl><type><name>PRInt32</name></type>               <name>aRowIndex</name></decl></param>,
                        <param><decl><type><name>PRBool</name></type>                <name>aConsiderSpans</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsAutoVoidArray</name></type> <name>rows</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>rows</name>.<name>AppendElement</name></name><argument_list>(<argument><expr>&amp;<name>aRowFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>InsertRows</name><argument_list>(<argument><expr><name>aRowGroupFrame</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>aConsiderSpans</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// this cannot extend beyond a single row group</comment>
<function><type><name>PRInt32</name></type>
<name><name>nsTableFrame</name>::<name>InsertRows</name></name><parameter_list>(<param><decl><type><name>nsTableRowGroupFrame</name>&amp;</type> <name>aRowGroupFrame</name></decl></param>,
                         <param><decl><type><name>nsVoidArray</name>&amp;</type>          <name>aRowFrames</name></decl></param>,
                         <param><decl><type><name>PRInt32</name></type>               <name>aRowIndex</name></decl></param>,
                         <param><decl><type><name>PRBool</name></type>                <name>aConsiderSpans</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_CELLMAP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"=== insertRowsBefore firstRow=%d \n"</expr></argument>, <argument><expr><name>aRowIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Dump</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numColsToAdd</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>origNumRows</name> <init>= <expr><call><name><name>cellMap</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>numNewRows</name> <init>= <expr><call><name><name>aRowFrames</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>InsertRows</name></name><argument_list>(<argument><expr><name>aRowGroupFrame</name></expr></argument>, <argument><expr><name>aRowFrames</name></expr></argument>, <argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>aConsiderSpans</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MatchCellMapToColCache</name><argument_list>(<argument><expr><name>cellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>aRowIndex</name> &lt; <name>origNumRows</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>AdjustRowIndices</name><argument_list>(<argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>numNewRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// assign the correct row indices to the new rows. If they were adjusted above</comment>
    <comment type="line">// it may not have been done correctly because each row is constructed with index 0</comment>
    <for>for (<init><decl><type><name>PRInt32</name></type> <name>rowX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rowX</name> &lt; <name>numNewRows</name></expr>;</condition> <incr><expr><name>rowX</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>rowFrame</name> <init>= <expr>(<name>nsTableRowFrame</name> *) <call><name><name>aRowFrames</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>rowX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>SetRowIndex</name></name><argument_list>(<argument><expr><name>aRowIndex</name> + <name>rowX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SetBCDamageArea</name><argument_list>(<argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_CELLMAP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"=== insertRowsAfter \n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Dump</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>numColsToAdd</name></expr>;</return>
}</block></function>

<comment type="line">// this cannot extend beyond a single row group</comment>
<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>RemoveRows</name></name><parameter_list>(<param><decl><type><name>nsTableRowFrame</name>&amp;</type> <name>aFirstRowFrame</name></decl></param>,
                              <param><decl><type><name>PRInt32</name></type>          <name>aNumRowsToRemove</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type>           <name>aConsiderSpans</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TBD_OPTIMIZATION</name></cpp:ifdef>
  <comment type="line">// decide if we need to rebalance. we have to do this here because the row group </comment>
  <comment type="line">// cannot do it when it gets the dirty reflow corresponding to the frame being destroyed</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>stopTelling</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><call><name><name>aFirstFrame</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr>(<name>kidFrame</name> &amp;&amp; !<name>stopAsking</name>)</expr>;</condition>
       <incr><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <if>if <condition>(<expr><call><name>IS_TABLE_CELL</name><argument_list>(<argument><expr><call><name><name>kidFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableCellFrame</name>*</type> <name>cellFrame</name> <init>= <expr>(<name>nsTableCellFrame</name>*)<name>kidFrame</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>stopTelling</name> = <call><name><name>tableFrame</name>-&gt;<name>CellChangedWidth</name></name><argument_list>(<argument><expr>*<name>cellFrame</name></expr></argument>, <argument><expr><call><name><name>cellFrame</name>-&gt;<name>GetPass1MaxElementWidth</name></name><argument_list>()</argument_list></call></expr></argument>, 
                                                 <argument><expr><call><name><name>cellFrame</name>-&gt;<name>GetMaximumWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <comment type="line">// XXX need to consider what happens if there are cells that have rowspans </comment>
  <comment type="line">// into the deleted row. Need to consider moving rows if a rebalance doesn't happen</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>firstRowIndex</name> <init>= <expr><call><name><name>aFirstRowFrame</name>.<name>GetRowIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_CELLMAP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"=== removeRowsBefore firstRow=%d numRows=%d\n"</expr></argument>, <argument><expr><name>firstRowIndex</name></expr></argument>, <argument><expr><name>aNumRowsToRemove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Dump</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>RemoveRows</name></name><argument_list>(<argument><expr><name>firstRowIndex</name></expr></argument>, <argument><expr><name>aNumRowsToRemove</name></expr></argument>, <argument><expr><name>aConsiderSpans</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MatchCellMapToColCache</name><argument_list>(<argument><expr><name>cellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SetBCDamageArea</name><argument_list>(<argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>AdjustRowIndices</name><argument_list>(<argument><expr><name>firstRowIndex</name></expr></argument>, <argument><expr>-<name>aNumRowsToRemove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_CELLMAP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"=== removeRowsAfter\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Dump</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>AppendRowGroups</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFirstRowGroupFrame</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aFirstRowGroupFrame</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
      <function_decl><type><name>nsFrameList</name></type> <name>newList</name><parameter_list>(<param><decl><type><name>aFirstRowGroupFrame</name></type></decl></param>)</parameter_list>;</function_decl>
      <expr_stmt><expr><call><name>InsertRowGroups</name><argument_list>(<argument><expr><name>aFirstRowGroupFrame</name></expr></argument>, <argument><expr><call><name><name>newList</name>.<name>LastChild</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<function><type><name>nsTableRowGroupFrame</name>*</type>
<name><name>nsTableFrame</name>::<name>GetRowGroupFrame</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                               <param><decl><type><name>nsIAtom</name>*</type>  <name>aFrameTypeIn</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>frameType</name> <init>= <expr><name>aFrameTypeIn</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>aFrameTypeIn</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>frameType</name> = <call><name><name>aFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableRowGroupFrame</name></name> == <name>frameType</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rgFrame</name> = <name>aFrame</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>scrollFrame</name></name> == <name>frameType</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIScrollableFrame</name>*</type> <name>scrollable</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>&amp;<name>scrollable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>scrollable</name>)</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>scrolledFrame</name> <init>= <expr><call><name><name>scrollable</name>-&gt;<name>GetScrolledFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>scrolledFrame</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableRowGroupFrame</name></name> == <call><name><name>scrolledFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>rgFrame</name> = <name>scrolledFrame</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if></else></if>
  <return>return <expr>(<name>nsTableRowGroupFrame</name>*)<name>rgFrame</name></expr>;</return>
}</block></function>

<comment type="line">// collect the rows ancestors of aFrame</comment>
<function><type><name>PRInt32</name></type>
<name><name>nsTableFrame</name>::<name>CollectRows</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type>       <name>aFrame</name></decl></param>,
                          <param><decl><type><name>nsVoidArray</name>&amp;</type>    <name>aCollection</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aFrame</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numRows</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>rgFrame</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>childFrame</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>childFrame</name></expr>)</condition> <block>{
      <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableRowFrame</name></name> == <call><name><name>childFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aCollection</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>childFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>numRows</name>++</expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><name>numRows</name> += <call><name>CollectRows</name><argument_list>(<argument><expr><name>childFrame</name></expr></argument>, <argument><expr><name>aCollection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>childFrame</name> = <call><name><name>childFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>
  <return>return <expr><name>numRows</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>InsertRowGroups</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFirstRowGroupFrame</name></decl></param>,
                              <param><decl><type><name>nsIFrame</name>*</type> <name>aLastRowGroupFrame</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_CELLMAP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"=== insertRowGroupsBefore\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Dump</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>RowGroupArray</name></type> <name>orderedRowGroups</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>orderedRowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsAutoVoidArray</name></type> <name>rows</name></decl>;</decl_stmt>
    <comment type="line">// Loop over the rowgroups and check if some of them are new, if they are</comment>
    <comment type="line">// insert cellmaps in the order that is predefined by OrderRowGroups,</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>rgIndex</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>rgIndex</name> = 0</expr>;</init> <condition><expr><name>rgIndex</name> &lt; <call><name><name>orderedRowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgIndex</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><name>aFirstRowGroupFrame</name></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>orderedRowGroups</name><index>[<expr><name>rgIndex</name></expr>]</index></name> == <name>rgFrame</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>priorRG</name> <init>=
            <expr>(0 == <name>rgIndex</name>) ? <name>nsnull</name> : <name><name>orderedRowGroups</name><index>[<expr><name>rgIndex</name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt> 
          <comment type="line">// create and add the cell map for the row group</comment>
          <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>InsertGroupCellMap</name></name><argument_list>(<argument><expr>*<name>rgFrame</name></expr></argument>, <argument><expr><name>priorRG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
          <break>break;</break>
        }</block></then>
        <else>else <block>{
          <if>if <condition>(<expr><name>kidFrame</name> == <name>aLastRowGroupFrame</name></expr>)</condition><then> <block>{
            <break>break;</break>
          }</block></then></if>
          <expr_stmt><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></while>
    }</block></for>
    <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>Synchronize</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ResetRowIndices</name><argument_list>(<argument><expr><name>aFirstRowGroupFrame</name></expr></argument>, <argument><expr><name>aLastRowGroupFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//now that the cellmaps are reordered too insert the rows</comment>
    <for>for (<init><expr><name>rgIndex</name> = 0</expr>;</init> <condition><expr><name>rgIndex</name> &lt; <call><name><name>orderedRowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgIndex</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><name>aFirstRowGroupFrame</name></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>orderedRowGroups</name><index>[<expr><name>rgIndex</name></expr>]</index></name> == <name>rgFrame</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>priorRG</name> <init>=
            <expr>(0 == <name>rgIndex</name>) ? <name>nsnull</name> : <name><name>orderedRowGroups</name><index>[<expr><name>rgIndex</name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt> 
          <comment type="line">// collect the new row frames in an array and add them to the table</comment>
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>numRows</name> <init>= <expr><call><name>CollectRows</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>numRows</name> &gt; 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>priorRG</name></expr>)</condition><then> <block>{
              <decl_stmt><decl><type><name>PRInt32</name></type> <name>priorNumRows</name> <init>= <expr><call><name><name>priorRG</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>rowIndex</name> = <call><name><name>priorRG</name>-&gt;<name>GetStartRowIndex</name></name><argument_list>()</argument_list></call> + <name>priorNumRows</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>InsertRows</name><argument_list>(<argument><expr>*<name>rgFrame</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>rows</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <break>break;</break>
        }</block></then>
        <else>else <block>{
          <if>if <condition>(<expr><name>kidFrame</name> == <name>aLastRowGroupFrame</name></expr>)</condition><then> <block>{
            <break>break;</break>
          }</block></then></if>
          <expr_stmt><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></while>
    }</block></for>    
    
  }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_CELLMAP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"=== insertRowGroupsAfter\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Dump</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="line" format="doxygen">/////////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Child frame enumeration</comment>

<function><type><name>nsIFrame</name>*</type>
<name><name>nsTableFrame</name>::<name>GetFirstChild</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type> <name>aListName</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr><name>aListName</name> == <name><name>nsGkAtoms</name>::<name>colGroupList</name></name></expr>)</condition><then> <block>{
    <return>return <expr><call><name><name>mColGroups</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>

  <return>return <expr><call><name><name>nsHTMLContainerFrame</name>::<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>aListName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsIAtom</name>*</type>
<name><name>nsTableFrame</name>::<name>GetAdditionalChildListName</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aIndex</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr><name>aIndex</name> == <name>NS_TABLE_FRAME_COLGROUP_LIST_INDEX</name></expr>)</condition><then> <block>{
    <return>return <expr><name><name>nsGkAtoms</name>::<name>colGroupList</name></name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>aIndex</name> == <name>NS_TABLE_FRAME_OVERFLOW_LIST_INDEX</name></expr>)</condition><then> <block>{
    <return>return <expr><name><name>nsGkAtoms</name>::<name>overflowList</name></name></expr>;</return>
  }</block></then></if> 
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<class>class <name>nsDisplayTableBorderBackground</name> <super>: <specifier>public</specifier> <name>nsDisplayItem</name></super> <block>{<private type="default">
</private><public>public:
  <constructor><name>nsDisplayTableBorderBackground</name><parameter_list>(<param><decl><type><name>nsTableFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list> <member_list>: <call><name>nsDisplayItem</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call> </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayTableBorderBackground</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
  <destructor><specifier>virtual</specifier> <name>~<name>nsDisplayTableBorderBackground</name></name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayTableBorderBackground</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>,
     <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="line">// With collapsed borders, parts of the collapsed border can extend outside</comment>
  <comment type="line">// the table frame, so allow this display element to blow out to our</comment>
  <comment type="line">// overflow rect.</comment>
  <function><type><specifier>virtual</specifier> <name>nsRect</name></type> <name>GetBounds</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTableFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call>-&gt;<call><name>GetOverflowRect</name><argument_list>()</argument_list></call> +
      <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>
  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"TableBorderBackground"</argument>)</argument_list></macro>
</public>}</block>;</class>

<function><type><name>void</name></type>
<name><name>nsDisplayTableBorderBackground</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
    <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTableFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>PaintTableBorderBackground</name><argument_list>(<argument><expr>*<name>aCtx</name></expr></argument>, <argument><expr><name>aDirtyRect</name></expr></argument>,
                               <argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>PRInt32</name></type> <name>GetTablePartRank</name><parameter_list>(<param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>type</name> <init>= <expr><call><name><name>aItem</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>type</name> == <name><name>nsGkAtoms</name>::<name>tableFrame</name></name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>
  <if>if <condition>(<expr><name>type</name> == <name><name>nsGkAtoms</name>::<name>tableRowGroupFrame</name></name></expr>)</condition><then>
    <return>return <expr>1</expr>;</return></then></if>
  <if>if <condition>(<expr><name>type</name> == <name><name>nsGkAtoms</name>::<name>tableRowFrame</name></name></expr>)</condition><then>
    <return>return <expr>2</expr>;</return></then></if>
  <return>return <expr>3</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>CompareByTablePartRank</name><parameter_list>(<param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem1</name></decl></param>, <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem2</name></decl></param>,
                                     <param><decl><type><name>void</name>*</type> <name>aClosure</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>GetTablePartRank</name><argument_list>(<argument><expr><name>aItem1</name></expr></argument>)</argument_list></call> &lt;= <call><name>GetTablePartRank</name><argument_list>(<argument><expr><name>aItem2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>nsresult</name></type>
<name><name>nsTableFrame</name>::<name>GenericTraversal</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsFrame</name>*</type> <name>aFrame</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aLists</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// This is similar to what nsContainerFrame::BuildDisplayListForNonBlockChildren</comment>
  <comment type="line">// does, except that we allow the children's background and borders to go</comment>
  <comment type="line">// in our BorderBackground list. This doesn't really affect background</comment>
  <comment type="line">// painting --- the children won't actually draw their own backgrounds</comment>
  <comment type="line">// because the nsTableFrame already drew them, unless a child has its own</comment>
  <comment type="line">// stacking context, in which case the child won't use its passed-in</comment>
  <comment type="line">// BorderBackground list anyway. It does affect cell borders though; this</comment>
  <comment type="line">// lets us get cell borders into the nsTableFrame's BorderBackground list.</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kid</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>kid</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>BuildDisplayListForChild</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>kid</name></expr></argument>, <argument><expr><name>aDirtyRect</name></expr></argument>, <argument><expr><name>aLists</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>kid</name> = <call><name><name>kid</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>nsresult</name></type>
<name><name>nsTableFrame</name>::<name>DisplayGenericTablePart</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                      <param><decl><type><name>nsFrame</name>*</type> <name>aFrame</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aLists</name></decl></param>,
                                      <param><decl><type><name>PRBool</name></type> <name>aIsRoot</name></decl></param>,
                                      <param><decl><type><name>DisplayGenericTablePartTraversal</name></type> <name>aTraversal</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsDisplayList</name></type> <name>eventsBorderBackground</name></decl>;</decl_stmt>
  <comment type="line">// If we need to sort the event backgrounds, then we'll put descendants'</comment>
  <comment type="line">// display items into their own set of lists.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>sortEventBackgrounds</name> <init>= <expr><name>aIsRoot</name> &amp;&amp; <call><name><name>aBuilder</name>-&gt;<name>IsForEventDelivery</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayListCollection</name></type> <name>separatedCollection</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>*</type> <name>lists</name> <init>= <expr><name>sortEventBackgrounds</name> ? &amp;<name>separatedCollection</name> : &amp;<name>aLists</name></expr></init></decl>;</decl_stmt>
  
  <comment type="line">// Create dedicated background display items per-frame when we're</comment>
  <comment type="line">// handling events.</comment>
  <comment type="line">// XXX how to handle collapsed borders?</comment>
  <if>if <condition>(<expr><call><name><name>aBuilder</name>-&gt;<name>IsForEventDelivery</name></name><argument_list>()</argument_list></call> &amp;&amp;
      <call><name><name>aFrame</name>-&gt;<name>IsVisibleForPainting</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>lists</name>-&gt;<name>BorderBackground</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendNewToTop</name><argument_list>(<argument><expr>new (<name>aBuilder</name>)
        <call><name>nsDisplayBackground</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>aTraversal</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aDirtyRect</name></expr></argument>, <argument><expr>*<name>lists</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>sortEventBackgrounds</name></expr>)</condition><then> <block>{
    <comment type="line">// Ensure that the table frame event background goes before the</comment>
    <comment type="line">// table rowgroups event backgrounds, before the table row event backgrounds,</comment>
    <comment type="line">// before everything else (cells and their blocks)</comment>
    <expr_stmt><expr><call><name><name>separatedCollection</name>.<name>BorderBackground</name></name><argument_list>()</argument_list></call>-&gt;<call><name>Sort</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>CompareByTablePartRank</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>separatedCollection</name>.<name>MoveTo</name></name><argument_list>(<argument><expr><name>aLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  
  <return>return <expr><call><name><name>aFrame</name>-&gt;<name>DisplayOutline</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aLists</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// table paint code is concerned primarily with borders and bg color</comment>
<comment type="line">// SEC: TODO: adjust the rect for captions </comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>BuildDisplayList</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type>   <name>aBuilder</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>           <name>aDirtyRect</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aLists</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>IsVisibleInSelection</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>DO_GLOBAL_REFLOW_COUNT_DSP_COLOR</name><argument_list>(<argument><expr>"nsTableFrame"</expr></argument>, <argument><expr><call><name>NS_RGB</name><argument_list>(<argument><expr>255</expr></argument>,<argument><expr>128</expr></argument>,<argument><expr>255</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// This background is created regardless of whether this frame is</comment>
  <comment type="line">// visible or not. Visibility decisions are delegated to the</comment>
  <comment type="line">// table background painter.</comment>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>aLists</name>.<name>BorderBackground</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendNewToTop</name><argument_list>(<argument><expr>new (<name>aBuilder</name>)
      <call><name>nsDisplayTableBorderBackground</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><call><name>DisplayGenericTablePart</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>aDirtyRect</name></expr></argument>, <argument><expr><name>aLists</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// XXX We don't put the borders and backgrounds in tree order like we should.</comment>
<comment type="line">// That requires some major surgery which we aren't going to do right now.</comment>
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>PaintTableBorderBackground</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name>&amp;</type> <name>aRenderingContext</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>,
                                         <param><decl><type><name>nsPoint</name></type> <name>aPt</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>dirtyRect</name> <init>= <expr><name>aDirtyRect</name> - <name>aPt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsIRenderingContext</name>::<name>AutoPushTranslation</name></name></type>
    <name>translate</name><argument_list>(<argument><expr>&amp;<name>aRenderingContext</name></expr></argument>, <argument><expr><name><name>aPt</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aPt</name>.<name>y</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>

  <function_decl><type><name>TableBackgroundPainter</name></type> <name>painter</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>, <param><decl><type><name><name>TableBackgroundPainter</name>::<name>eOrigin_Table</name></name></type></decl></param>,
                                 <param><decl><type><name>presContext</name></type></decl></param>, <param><decl><type><name>aRenderingContext</name></type></decl></param>, <param><decl><type><name>dirtyRect</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  
  <if>if <condition>(<expr><name>eCompatibility_NavQuirks</name> == <call><name><name>presContext</name>-&gt;<name>CompatibilityMode</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsMargin</name></type> <name>deflate</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>p2t</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BCPropertyData</name>*</type> <name>propData</name> <init>=
        <expr>(<name>BCPropertyData</name>*)<call><name><name>nsTableFrame</name>::<name>GetProperty</name></name><argument_list>(<argument><expr>(<name>nsIFrame</name>*)<name>this</name></expr></argument>,
                                                   <argument><expr><name><name>nsGkAtoms</name>::<name>tableBCProperty</name></name></expr></argument>,
                                                   <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>propData</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>deflate</name>.<name>top</name></name>    = <call><name>BC_BORDER_TOP_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mTopBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>deflate</name>.<name>right</name></name>  = <call><name>BC_BORDER_RIGHT_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mRightBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>deflate</name>.<name>bottom</name></name> = <call><name>BC_BORDER_BOTTOM_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mBottomBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>deflate</name>.<name>left</name></name>   = <call><name>BC_BORDER_LEFT_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mLeftBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>rv</name> = <call><name><name>painter</name>.<name>PaintTable</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>&amp;<name>deflate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return;</return></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>rv</name> = <call><name><name>painter</name>.<name>PaintTable</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return;</return></then></if>
  }</block></else></if>

  <if>if <condition>(<expr><call><name>GetStyleVisibility</name><argument_list>()</argument_list></call>-&gt;<call><name>IsVisible</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleBorder</name>*</type> <name>border</name> <init>= <expr><call><name>GetStyleBorder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsRect</name></type>  <name>rect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>mRect</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mRect</name>.<name>height</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRIntn</name></type> <name>skipSides</name> <init>= <expr><call><name>GetSkipSides</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>PaintBorder</name></name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>this</name></expr></argument>,
                                  <argument><expr><name>dirtyRect</name></expr></argument>, <argument><expr><name>rect</name></expr></argument>, <argument><expr>*<name>border</name></expr></argument>, <argument><expr><name>mStyleContext</name></expr></argument>,
                                  <argument><expr><name>skipSides</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>PaintBCBorders</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>dirtyRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>

<comment type="line">//null range means the whole thing</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>SetSelected</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>,
                          <param><decl><type><name>nsIDOMRange</name> *</type><name>aRange</name></decl></param>,
                          <param><decl><type><name>PRBool</name></type> <name>aSelected</name></decl></param>,
                          <param><decl><type><name>nsSpread</name></type> <name>aSpread</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
  <comment type="line">//traverse through children unselect tables</comment>
  if ((aSpread == eSpreadDown)){
    nsIFrame* kid = GetFirstChild(nsnull);
    while (kid) {
      kid-&gt;SetSelected(nsnull, aSelected, eSpreadDown);
      kid = kid-&gt;GetNextSibling();
    }
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="line">// Must call base class to set mSelected state and trigger repaint of frame</comment>
  <comment type="line">// Note that in current version, aRange and aSpread are ignored,</comment>
  <comment type="line">//   only this frame is considered</comment>
  <expr_stmt><expr><call><name><name>nsFrame</name>::<name>SetSelected</name></name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aRange</name></expr></argument>, <argument><expr><name>aSelected</name></expr></argument>, <argument><expr><name>aSpread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return><comment type="line">//return nsFrame::SetSelected(aRange,aSelected,eSpreadNone);</comment>
  
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsTableFrame</name>::<name>ParentDisablesSelection</name></name><parameter_list>()</parameter_list> <specifier>const</specifier> <comment type="line">//override default behavior</comment>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>returnval</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name>GetSelected</name><argument_list>(<argument><expr>&amp;<name>returnval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <if>if <condition>(<expr><name>returnval</name></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
  <return>return <expr><call><name><name>nsFrame</name>::<name>ParentDisablesSelection</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRIntn</name></type>
<name><name>nsTableFrame</name>::<name>GetSkipSides</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>PRIntn</name></type> <name>skip</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <comment type="line">// frame attribute was accounted for in nsHTMLTableElement::MapTableBorderInto</comment>
  <comment type="line">// account for pagination</comment>
  <if>if <condition>(<expr><name>nsnull</name> != <call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>skip</name> |= 1 &lt;&lt; <name>NS_SIDE_TOP</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>nsnull</name> != <call><name>GetNextInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>skip</name> |= 1 &lt;&lt; <name>NS_SIDE_BOTTOM</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>skip</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>SetColumnDimensions</name></name><parameter_list>(<param><decl><type><name>nscoord</name></type>         <name>aHeight</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>nsMargin</name>&amp;</type> <name>aBorderPadding</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>cellSpacingX</name> <init>= <expr><call><name>GetCellSpacingX</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>cellSpacingY</name> <init>= <expr><call><name>GetCellSpacingY</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>colHeight</name> <init>= <expr><name>aHeight</name> -= <name><name>aBorderPadding</name>.<name>top</name></name> + <name><name>aBorderPadding</name>.<name>bottom</name></name> +
                                 2* <name>cellSpacingY</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>colGroupFrame</name> <init>= <expr><call><name><name>mColGroups</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colX</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>colGroupOrigin</name><argument_list>(<argument><expr><name><name>aBorderPadding</name>.<name>left</name></name> + <name>cellSpacingX</name></expr></argument>,
                         <argument><expr><name><name>aBorderPadding</name>.<name>top</name></name> + <name>cellSpacingY</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>nsnull</name> != <name>colGroupFrame</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>nscoord</name></type> <name>colGroupWidth</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name><name>colGroupFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsPoint</name></type> <name>colOrigin</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>nsnull</name> != <name>colFrame</name></expr>)</condition> <block>{
      <if>if <condition>(<expr><name>NS_STYLE_DISPLAY_TABLE_COLUMN</name> ==
          <call><name><name>colFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call>-&gt;<name>mDisplay</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>colX</name> &lt; <call><name>GetColCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"invalid number of columns"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nscoord</name></type> <name>colWidth</name> <init>= <expr><call><name>GetColumnWidth</name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <function_decl><type><name>nsRect</name></type> <name>colRect</name><parameter_list>(<param><decl><type><name><name>colOrigin</name>.<name>x</name></name></type></decl></param>, <param><decl><type><name><name>colOrigin</name>.<name>y</name></name></type></decl></param>, <param><decl><type><name>colWidth</name></type></decl></param>, <param><decl><type><name>colHeight</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><call><name><name>colFrame</name>-&gt;<name>SetRect</name></name><argument_list>(<argument><expr><name>colRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>colOrigin</name>.<name>x</name></name> += <name>colWidth</name> + <name>cellSpacingX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>colGroupWidth</name> += <name>colWidth</name> + <name>cellSpacingX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>colX</name>++</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>colFrame</name> = <call><name><name>colFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr><name>colGroupWidth</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>colGroupWidth</name> -= <name>cellSpacingX</name></expr>;</expr_stmt>
    }</block></then></if>

    <function_decl><type><name>nsRect</name></type> <name>colGroupRect</name><parameter_list>(<param><decl><type><name><name>colGroupOrigin</name>.<name>x</name></name></type></decl></param>, <param><decl><type><name><name>colGroupOrigin</name>.<name>y</name></name></type></decl></param>, <param><decl><type><name>colGroupWidth</name></type></decl></param>, <param><decl><type><name>colHeight</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name><name>colGroupFrame</name>-&gt;<name>SetRect</name></name><argument_list>(<argument><expr><name>colGroupRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>colGroupFrame</name> = <call><name><name>colGroupFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>colGroupOrigin</name>.<name>x</name></name> += <name>colGroupWidth</name> + <name>cellSpacingX</name></expr>;</expr_stmt>
  }</block></while>
}</block></function>

<comment type="line">// SEC: TODO need to worry about continuing frames prev/next in flow for splitting across pages.</comment>

<comment type="line">// XXX this could be made more general to handle row modifications that change the</comment>
<comment type="line">// table height, but first we need to scrutinize every Invalidate</comment>
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>ProcessRowInserted</name></name><parameter_list>(<param><decl><type><name>nscoord</name></type> <name>aNewHeight</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SetRowInserted</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// reset the bit that got us here</comment>
  <decl_stmt><decl><type><name><name>nsTableFrame</name>::<name>RowGroupArray</name></name></type> <name>rowGroups</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// find the row group containing the inserted row</comment>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>rgX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rgX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>rgFrame</name></expr></argument>, <argument><expr>"Must have rgFrame here"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>childFrame</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// find the row that was inserted first</comment>
    <while>while <condition>(<expr><name>childFrame</name></expr>)</condition> <block>{
      <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableRowFrame</name></name> == <call><name><name>childFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>rowFrame</name> <init>= <expr>(<name>nsTableRowFrame</name>*)<name>childFrame</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>rowFrame</name>-&gt;<name>IsFirstInserted</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>SetFirstInserted</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// damage the table from the 1st row inserted to the end of the table</comment>
          <decl_stmt><decl><type><name>nscoord</name></type> <name>damageY</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call>.<name>y</name> + <call><name><name>rowFrame</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call>.<name>y</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nsRect</name></type> <name>damageRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>damageY</name></expr></argument>, <argument><expr><call><name>GetSize</name><argument_list>()</argument_list></call>.<name>width</name></expr></argument>, <argument><expr><name>aNewHeight</name> - <name>damageY</name></expr></argument>)</argument_list></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>damageRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// XXXbz didn't we do this up front?  Why do we need to do it again?</comment>
          <expr_stmt><expr><call><name>SetRowInserted</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return> <comment type="line">// found it, so leave</comment>
        }</block></then></if>
      }</block></then></if>
      <expr_stmt><expr><name>childFrame</name> = <call><name><name>childFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  }</block></for>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>MarkIntrinsicWidthsDirty</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTableFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetFirstInFlow</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>-&gt;
    <call><name><name>mTableLayoutStrategy</name>-&gt;<name>MarkIntrinsicWidthsDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// XXXldb Call SetBCDamageArea?</comment>

  <expr_stmt><expr><call><name><name>nsHTMLContainerFrame</name>::<name>MarkIntrinsicWidthsDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>nscoord</name></type>
<name><name>nsTableFrame</name>::<name>GetMinWidth</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>NeedToCalcBCBorders</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>CalcBCBorders</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>ReflowColGroups</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>LayoutStrategy</name><argument_list>()</argument_list></call>-&gt;<call><name>GetMinWidth</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>nscoord</name></type>
<name><name>nsTableFrame</name>::<name>GetPrefWidth</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>NeedToCalcBCBorders</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>CalcBCBorders</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>ReflowColGroups</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>LayoutStrategy</name><argument_list>()</argument_list></call>-&gt;<call><name>GetPrefWidth</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name><name>nsIFrame</name>::<name>IntrinsicWidthOffsetData</name></name></type>
<name><name>nsTableFrame</name>::<name>IntrinsicWidthOffsets</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name>*</type> <name>aRenderingContext</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>IntrinsicWidthOffsetData</name></type> <name>result</name> <init>=
    <expr><call><name><name>nsHTMLContainerFrame</name>::<name>IntrinsicWidthOffsets</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>result</name>.<name>hPadding</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>.<name>hPctPadding</name></name> = 0</expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsMargin</name></type> <name>outerBC</name> <init>= <expr><call><name>GetIncludedOuterBCBorder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>result</name>.<name>hBorder</name></name> = <call><name><name>outerBC</name>.<name>LeftRight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>nsSize</name></type>
<name><name>nsTableFrame</name>::<name>ComputeSize</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>,
                          <param><decl><type><name>nsSize</name></type> <name>aCBSize</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aAvailableWidth</name></decl></param>,
                          <param><decl><type><name>nsSize</name></type> <name>aMargin</name></decl></param>, <param><decl><type><name>nsSize</name></type> <name>aBorder</name></decl></param>, <param><decl><type><name>nsSize</name></type> <name>aPadding</name></decl></param>,
                          <param><decl><type><name>PRBool</name></type> <name>aShrinkWrap</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsSize</name></type> <name>result</name> <init>=
    <expr><call><name><name>nsHTMLContainerFrame</name>::<name>ComputeSize</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>aCBSize</name></expr></argument>,
                                      <argument><expr><name>aAvailableWidth</name></expr></argument>,
                                      <argument><expr><name>aMargin</name></expr></argument>, <argument><expr><name>aBorder</name></expr></argument>, <argument><expr><name>aPadding</name></expr></argument>, <argument><expr><name>aShrinkWrap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Tables never shrink below their min width.</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>minWidth</name> <init>= <expr><call><name>GetMinWidth</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>minWidth</name> &gt; <name><name>result</name>.<name>width</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>result</name>.<name>width</name></name> = <name>minWidth</name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>nscoord</name></type>
<name><name>nsTableFrame</name>::<name>TableShrinkWidthToFit</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>,
                                    <param><decl><type><name>nscoord</name></type> <name>aWidthInCB</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>minWidth</name> <init>= <expr><call><name>GetMinWidth</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>minWidth</name> &gt; <name>aWidthInCB</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>result</name> = <name>minWidth</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// Tables shrink width to fit with a slightly different algorithm</comment>
    <comment type="line">// from the one they use for their intrinsic widths (the difference</comment>
    <comment type="line">// relates to handling of percentage widths on columns).  So this</comment>
    <comment type="line">// function differs from nsFrame::ShrinkWidthToFit by only the</comment>
    <comment type="line">// following line.</comment>
    <comment type="line">// Since we've already called GetMinWidth, we don't need to do any</comment>
    <comment type="line">// of the other stuff GetPrefWidth does.</comment>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>prefWidth</name> <init>=
      <expr><call><name>LayoutStrategy</name><argument_list>()</argument_list></call>-&gt;<call><name>GetPrefWidth</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>prefWidth</name> &gt; <name>aWidthInCB</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>result</name> = <name>aWidthInCB</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>result</name> = <name>prefWidth</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>nsSize</name></type>
<name><name>nsTableFrame</name>::<name>ComputeAutoSize</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>,
                              <param><decl><type><name>nsSize</name></type> <name>aCBSize</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aAvailableWidth</name></decl></param>,
                              <param><decl><type><name>nsSize</name></type> <name>aMargin</name></decl></param>, <param><decl><type><name>nsSize</name></type> <name>aBorder</name></decl></param>, <param><decl><type><name>nsSize</name></type> <name>aPadding</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type> <name>aShrinkWrap</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Tables always shrink-wrap.</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>cbBased</name> <init>= <expr><name>aAvailableWidth</name> - <name><name>aMargin</name>.<name>width</name></name> - <name><name>aBorder</name>.<name>width</name></name> -
                    <name><name>aPadding</name>.<name>width</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>nsSize</name><argument_list>(<argument><expr><call><name>TableShrinkWidthToFit</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>cbBased</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>NS_UNCONSTRAINEDSIZE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Return true if aParentReflowState.frame or any of its ancestors within</comment>
<comment type="line">// the containing table have non-auto height. (e.g. pct or fixed height)</comment>
<function><type><name>PRBool</name></type>
<name><name>nsTableFrame</name>::<name>AncestorsHaveStyleHeight</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aParentReflowState</name></decl></param>)</parameter_list>
<block>{
  <for>for (<init><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>*</type> <name>rs</name> <init>= <expr>&amp;<name>aParentReflowState</name></expr></init></decl>;</init>
       <condition><expr><name>rs</name> &amp;&amp; <name><name>rs</name>-&gt;<name>frame</name></name></expr>;</condition> <incr><expr><name>rs</name> = <name><name>rs</name>-&gt;<name>parentReflowState</name></name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>frameType</name> <init>= <expr><call><name><name>rs</name>-&gt;<name>frame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>IS_TABLE_CELL</name><argument_list>(<argument><expr><name>frameType</name></expr></argument>)</argument_list></call>                     ||
        (<name><name>nsGkAtoms</name>::<name>tableRowFrame</name></name>      == <name>frameType</name>) ||
        (<name><name>nsGkAtoms</name>::<name>tableRowGroupFrame</name></name> == <name>frameType</name>)</expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name><name>rs</name>-&gt;<name>mStylePosition</name>-&gt;<name>mHeight</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eStyleUnit_Auto</name></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_TRUE</name></expr>;</return>
      }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableFrame</name></name> == <name>frameType</name></expr>)</condition><then> <block>{
      <comment type="line">// we reached the containing table, so always return</comment>
      <if>if <condition>(<expr><call><name><name>rs</name>-&gt;<name>mStylePosition</name>-&gt;<name>mHeight</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eStyleUnit_Auto</name></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_TRUE</name></expr>;</return>
      }</block></then>
      <else>else <return>return <expr><name>PR_FALSE</name></expr>;</return></else></if>
    }</block></then></if></else></if>
  }</block></for>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// See if a special height reflow needs to occur and if so, call RequestSpecialHeightReflow</comment>
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>CheckRequestSpecialHeightReflow</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name><name>aReflowState</name>.<name>frame</name>-&gt;<name>GetPrevInFlow</name></name><argument_list>()</argument_list></call> &amp;&amp;  <comment type="line">// 1st in flow</comment>
      (<name>NS_UNCONSTRAINEDSIZE</name> == <call><name><name>aReflowState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call> ||  <comment type="line">// no computed height</comment>
       0                    == <call><name><name>aReflowState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call>) &amp;&amp; 
      <name>eStyleUnit_Percent</name> == <call><name><name>aReflowState</name>.<name>mStylePosition</name>-&gt;<name>mHeight</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> &amp;&amp; <comment type="line">// pct height</comment>
      <call><name><name>nsTableFrame</name>::<name>AncestorsHaveStyleHeight</name></name><argument_list>(<argument><expr>*<name><name>aReflowState</name>.<name>parentReflowState</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>nsTableFrame</name>::<name>RequestSpecialHeightReflow</name></name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">// Notify the frame and its ancestors (up to the containing table) that a special</comment>
<comment type="line">// height reflow will occur. During a special height reflow, a table, row group,</comment>
<comment type="line">// row, or cell returns the last size it was reflowed at. However, the table may </comment>
<comment type="line">// change the height of row groups, rows, cells in DistributeHeightToRows after. </comment>
<comment type="line">// And the row group can change the height of rows, cells in CalculateRowHeights.</comment>
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>RequestSpecialHeightReflow</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// notify the frame and its ancestors of the special reflow, stopping at the containing table</comment>
  <for>for (<init><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>*</type> <name>rs</name> <init>= <expr>&amp;<name>aReflowState</name></expr></init></decl>;</init> <condition><expr><name>rs</name> &amp;&amp; <name><name>rs</name>-&gt;<name>frame</name></name></expr>;</condition> <incr><expr><name>rs</name> = <name><name>rs</name>-&gt;<name>parentReflowState</name></name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>frameType</name> <init>= <expr><call><name><name>rs</name>-&gt;<name>frame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>IS_TABLE_CELL</name><argument_list>(<argument><expr><name>frameType</name></expr></argument>)</argument_list></call> ||
                 <name><name>nsGkAtoms</name>::<name>tableRowFrame</name></name> == <name>frameType</name> ||
                 <name><name>nsGkAtoms</name>::<name>tableRowGroupFrame</name></name> == <name>frameType</name> ||
                 <name><name>nsGkAtoms</name>::<name>scrollFrame</name></name> == <name>frameType</name> ||
                 <name><name>nsGkAtoms</name>::<name>tableFrame</name></name> == <name>frameType</name></expr></argument>,
                 <argument><expr>"unexpected frame type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 
    <expr_stmt><expr><call><name><name>rs</name>-&gt;<name>frame</name>-&gt;<name>AddStateBits</name></name><argument_list>(<argument><expr><name>NS_FRAME_CONTAINS_RELATIVE_HEIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableFrame</name></name> == <name>frameType</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>rs</name> != &amp;<name>aReflowState</name></expr></argument>,
                   <argument><expr>"should not request special height reflow for table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// always stop when we reach a table</comment>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block" format="doxygen">/******************************************************************************************
 * Before reflow, intrinsic width calculation is done using GetMinWidth
 * and GetPrefWidth.  This used to be known as pass 1 reflow.
 *
 * After the intrinsic width calculation, the table determines the
 * column widths using BalanceColumnWidths() and
 * then reflows each child again with a constrained avail width. This reflow is referred to
 * as the pass 2 reflow. 
 *
 * A special height reflow (pass 3 reflow) can occur during an initial or resize reflow
 * if (a) a row group, row, cell, or a frame inside a cell has a percent height but no computed 
 * height or (b) in paginated mode, a table has a height. (a) supports percent nested tables 
 * contained inside cells whose heights aren't known until after the pass 2 reflow. (b) is 
 * necessary because the table cannot split until after the pass 2 reflow. The mechanics of 
 * the special height reflow (variety a) are as follows: 
 * 
 * 1) Each table related frame (table, row group, row, cell) implements NeedsSpecialReflow()
 *    to indicate that it should get the reflow. It does this when it has a percent height but 
 *    no computed height by calling CheckRequestSpecialHeightReflow(). This method calls
 *    RequestSpecialHeightReflow() which calls SetNeedSpecialReflow() on its ancestors until 
 *    it reaches the containing table and calls SetNeedToInitiateSpecialReflow() on it. For 
 *    percent height frames inside cells, during DidReflow(), the cell's NotifyPercentHeight()
 *    is called (the cell is the reflow state's mPercentHeightObserver in this case). 
 *    NotifyPercentHeight() calls RequestSpecialHeightReflow().
 *
 * 2) After the pass 2 reflow, if the table's NeedToInitiateSpecialReflow(true) was called, it
 *    will do the special height reflow, setting the reflow state's mFlags.mSpecialHeightReflow
 *    to true and mSpecialHeightInitiator to itself. It won't do this if IsPrematureSpecialHeightReflow()
 *    returns true because in that case another special height reflow will be coming along with the
 *    containing table as the mSpecialHeightInitiator. It is only relevant to do the reflow when
 *    the mSpecialHeightInitiator is the containing table, because if it is a remote ancestor, then
 *    appropriate heights will not be known.
 *
 * 3) Since the heights of the table, row groups, rows, and cells was determined during the pass 2
 *    reflow, they return their last desired sizes during the special height reflow. The reflow only
 *    permits percent height frames inside the cells to resize based on the cells height and that height
 *    was determined during the pass 2 reflow.
 *
 * So, in the case of deeply nested tables, all of the tables that were told to initiate a special
 * reflow will do so, but if a table is already in a special reflow, it won't inititate the reflow
 * until the current initiator is its containing table. Since these reflows are only received by
 * frames that need them and they don't cause any rebalancing of tables, the extra overhead is minimal.
 *
 * The type of special reflow that occurs during printing (variety b) follows the same mechanism except
 * that all frames will receive the reflow even if they don't really need them.
 *
 * Open issues with the special height reflow:
 *
 * 1) At some point there should be 2 kinds of special height reflows because (a) and (b) above are 
 *    really quite different. This would avoid unnecessary reflows during printing. 
 * 2) When a cell contains frames whose percent heights &gt; 100%, there is data loss (see bug 115245). 
 *    However, this can also occur if a cell has a fixed height and there is no special height reflow. 
 *
 * XXXldb Special height reflow should really be its own method, not
 * part of nsIFrame::Reflow.  It should then call nsIFrame::Reflow on
 * the contents of the cells to do the necessary vertical resizing.
 *
 ******************************************************************************************/</comment>

<comment type="block">/* Layout the entire inner table. */</comment>
<function><type><name>NS_METHOD</name></type> <name><name>nsTableFrame</name>::<name>Reflow</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type>          <name>aPresContext</name></decl></param>,
                               <param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type>     <name>aDesiredSize</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                               <param><decl><type><name>nsReflowStatus</name>&amp;</type>          <name>aStatus</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>DO_GLOBAL_REFLOW_COUNT</name><argument_list>(<argument><expr>"nsTableFrame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DISPLAY_REFLOW</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aDesiredSize</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isPaginated</name> <init>= <expr><call><name><name>aPresContext</name>-&gt;<name>IsPaginated</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>aStatus</name> = <name>NS_FRAME_COMPLETE</name></expr>;</expr_stmt> 
  <if>if <condition>(<expr>!<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call> &amp;&amp; !<name>mTableLayoutStrategy</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"strategy should have been created in Init"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_NULL_POINTER</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// see if collapsing borders need to be calculated</comment>
  <if>if <condition>(<expr>!<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>IsBorderCollapse</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>NeedToCalcBCBorders</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>CalcBCBorders</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name><name>aDesiredSize</name>.<name>width</name></name> = <name><name>aReflowState</name>.<name>availableWidth</name></name></expr>;</expr_stmt>

  <comment type="line">// Check for an overflow list, and append any row group frames being pushed</comment>
  <expr_stmt><expr><call><name>MoveOverflowToChildList</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>haveDesiredHeight</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>reflowedChildren</name>  <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SetHaveReflowedColGroups</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name><name>aReflowState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call> != <name>NS_UNCONSTRAINEDSIZE</name> ||
      <comment type="line">// Also check mVResize, to handle the first Reflow preceding a</comment>
      <comment type="line">// special height Reflow, when we've already had a special height</comment>
      <comment type="line">// Reflow (where mComputedHeight would not be</comment>
      <comment type="line">// NS_UNCONSTRAINEDSIZE, but without a style change in between).</comment>
      <name><name>aReflowState</name>.<name>mFlags</name>.<name>mVResize</name></name></expr>)</condition><then> <block>{
    <comment type="line">// XXX Eventually, we should modify DistributeHeightToRows to use</comment>
    <comment type="line">// nsTableRowFrame::GetHeight instead of nsIFrame::GetSize().height.</comment>
    <comment type="line">// That way, it will make its calculations based on internal table</comment>
    <comment type="line">// frame heights as they are before they ever had any extra height</comment>
    <comment type="line">// distributed to them.  In the meantime, this reflows all the</comment>
    <comment type="line">// internal table frames, which restores them to their state before</comment>
    <comment type="line">// DistributeHeightToRows was called.</comment>
    <expr_stmt><expr><call><name>SetGeometryDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Reflow the entire table (pass 2 and possibly pass 3). This phase is necessary during a </comment>
  <comment type="line">// constrained initial reflow and other reflows which require either a strategy init or balance. </comment>
  <comment type="line">// This isn't done during an unconstrained reflow, because it will occur later when the parent </comment>
  <comment type="line">// reflows with a constrained width.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>needToInitiateSpecialReflow</name> <init>=
    <expr>!!(<call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_CONTAINS_RELATIVE_HEIGHT</name>)</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_SUBTREE_DIRTY</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> ||
      <call><name><name>aReflowState</name>.<name>ShouldReflowAllKids</name></name><argument_list>()</argument_list></call> ||
      <call><name>IsGeometryDirty</name><argument_list>()</argument_list></call> ||
      <name>needToInitiateSpecialReflow</name></expr>)</condition><then> <block>{
    <comment type="line">// see if an extra reflow will be necessary in pagination mode when there is a specified table height </comment>
    <if>if <condition>(<expr><name>isPaginated</name> &amp;&amp; !<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call> &amp;&amp; (<name>NS_UNCONSTRAINEDSIZE</name> != <name><name>aReflowState</name>.<name>availableHeight</name></name>)</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nscoord</name></type> <name>tableSpecifiedHeight</name> <init>= <expr><call><name>CalcBorderBoxHeight</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>(<name>tableSpecifiedHeight</name> &gt; 0) &amp;&amp; 
          (<name>tableSpecifiedHeight</name> != <name>NS_UNCONSTRAINEDSIZE</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>needToInitiateSpecialReflow</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>lastChildReflowed</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name><name>aReflowState</name>.<name>mFlags</name>.<name>mSpecialHeightReflow</name></name></expr></argument>,
                 <argument><expr>"Shouldn't be in special height reflow here!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// do the pass 2 reflow unless this is a special height reflow and we will be </comment>
    <comment type="line">// initiating a special height reflow</comment>
    <comment type="line">// XXXldb I changed this.  Should I change it back?</comment>

    <comment type="line">// if we need to initiate a special height reflow, then don't constrain the </comment>
    <comment type="line">// height of the reflow before that</comment>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>availHeight</name> <init>= <expr><name>needToInitiateSpecialReflow</name> 
                          ? <name>NS_UNCONSTRAINEDSIZE</name> : <name><name>aReflowState</name>.<name>availableHeight</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ReflowTable</name><argument_list>(<argument><expr><name>aDesiredSize</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>availHeight</name></expr></argument>,
                <argument><expr><name>lastChildReflowed</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reflowedChildren</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <comment type="line">// reevaluate special height reflow conditions</comment>
    <if>if <condition>(<expr><call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_CONTAINS_RELATIVE_HEIGHT</name></expr>)</condition><then>
      <expr_stmt><expr><name>needToInitiateSpecialReflow</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>

    <comment type="line">// XXXldb Are all these conditions correct?</comment>
    <if>if <condition>(<expr><name>needToInitiateSpecialReflow</name> &amp;&amp; <call><name>NS_FRAME_IS_COMPLETE</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// XXXldb Do we need to set the mVResize flag on any reflow states?</comment>

      <decl_stmt><decl><type><name>nsHTMLReflowState</name> &amp;</type><name>mutable_rs</name> <init>=
        <expr><call><name><name>const_cast</name><argument_list>&lt;<argument><expr><name>nsHTMLReflowState</name>&amp;</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="line">// distribute extra vertical space to rows</comment>
      <expr_stmt><expr><call><name>CalcDesiredHeight</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aDesiredSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><name><name>mutable_rs</name>.<name>mFlags</name>.<name>mSpecialHeightReflow</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <comment type="line">// save the previous special height reflow initiator, install us as the new one</comment>
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>specialReflowInitiator</name> <init>= <expr><name><name>aReflowState</name>.<name>mPercentHeightReflowInitiator</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>mutable_rs</name>.<name>mPercentHeightReflowInitiator</name></name> = <name>this</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>ReflowTable</name><argument_list>(<argument><expr><name>aDesiredSize</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name><name>aReflowState</name>.<name>availableHeight</name></name></expr></argument>, 
                  <argument><expr><name>lastChildReflowed</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// restore the previous special height reflow initiator</comment>
      <expr_stmt><expr><name><name>mutable_rs</name>.<name>mPercentHeightReflowInitiator</name></name> = <name>specialReflowInitiator</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>lastChildReflowed</name> &amp;&amp; <call><name>NS_FRAME_IS_NOT_COMPLETE</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// if there is an incomplete child, then set the desired height to include it but not the next one</comment>
        <decl_stmt><decl><type><name>nsMargin</name></type> <name>borderPadding</name> <init>= <expr><call><name>GetChildAreaOffset</name><argument_list>(<argument><expr>&amp;<name>aReflowState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>aDesiredSize</name>.<name>height</name></name> = <name><name>borderPadding</name>.<name>bottom</name></name> + <call><name>GetCellSpacingY</name><argument_list>()</argument_list></call> +
                              <call><name><name>lastChildReflowed</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call>.<call><name>YMost</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>haveDesiredHeight</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reflowedChildren</name>  = <name>PR_TRUE</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>mutable_rs</name>.<name>mFlags</name>.<name>mSpecialHeightReflow</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><name><name>aDesiredSize</name>.<name>width</name></name> = <call><name><name>aReflowState</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call> +
                       <call><name><name>aReflowState</name>.<name>mComputedBorderPadding</name>.<name>LeftRight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>haveDesiredHeight</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>CalcDesiredHeight</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aDesiredSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  }</block></then></if>
  <if>if <condition>(<expr><call><name>IsRowInserted</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ProcessRowInserted</name><argument_list>(<argument><expr><name><name>aDesiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsMargin</name></type> <name>borderPadding</name> <init>= <expr><call><name>GetChildAreaOffset</name><argument_list>(<argument><expr>&amp;<name>aReflowState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SetColumnDimensions</name><argument_list>(<argument><expr><name><name>aDesiredSize</name>.<name>height</name></name></expr></argument>, <argument><expr><name>borderPadding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NeedToCollapse</name><argument_list>()</argument_list></call> &amp;&amp;
      (<name>NS_UNCONSTRAINEDSIZE</name> != <name><name>aReflowState</name>.<name>availableWidth</name></name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>AdjustForCollapsingRowsCols</name><argument_list>(<argument><expr><name>aDesiredSize</name></expr></argument>, <argument><expr><name>borderPadding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// make sure the table overflow area does include the table rect.</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>tableRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>aDesiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aDesiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></decl> ;</decl_stmt>
  
  <if>if <condition>(<expr>!<call><name><name>aReflowState</name>.<name>mStyleDisplay</name>-&gt;<name>IsTableClip</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// collapsed border may leak out</comment>
    <decl_stmt><decl><type><name>nsMargin</name></type> <name>bcMargin</name> <init>= <expr><call><name>GetExcludedOuterBCBorder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>tableRect</name>.<name>Inflate</name></name><argument_list>(<argument><expr><name>bcMargin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>aDesiredSize</name>.<name>mOverflowArea</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name><name>aDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>, <argument><expr><name>tableRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if>if <condition>(<expr>!<name>reflowedChildren</name></expr>)</condition><then> <block>{
    <comment type="line">// use the old overflow area</comment>
     <expr_stmt><expr><call><name><name>aDesiredSize</name>.<name>mOverflowArea</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name><name>aDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>,
                                          <argument><expr><call><name>GetOverflowRect</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_FIRST_REFLOW</name></expr>)</condition><then> <block>{
    <comment type="line">// Fulfill the promise InvalidateFrame makes.</comment>
    <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name><name>aDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>FinishAndStoreOverflow</name><argument_list>(<argument><expr>&amp;<name>aDesiredSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_FRAME_SET_TRUNCATION</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aDesiredSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> 
<name><name>nsTableFrame</name>::<name>ReflowTable</name></name><parameter_list>(<param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type>     <name>aDesiredSize</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                          <param><decl><type><name>nscoord</name></type>                  <name>aAvailHeight</name></decl></param>,
                          <param><decl><type><name>nsIFrame</name>*&amp;</type>               <name>aLastChildReflowed</name></decl></param>,
                          <param><decl><type><name>nsReflowStatus</name>&amp;</type>          <name>aStatus</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>aLastChildReflowed</name> = <name>nsnull</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mTableLayoutStrategy</name>-&gt;<name>ComputeColumnWidths</name></name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <comment type="line">// Constrain our reflow width to the computed table width (of the 1st in flow).</comment>
  <comment type="line">// and our reflow height to our avail height minus border, padding, cellspacing</comment>
  <expr_stmt><expr><name><name>aDesiredSize</name>.<name>width</name></name> = <call><name><name>aReflowState</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call> +
                       <call><name><name>aReflowState</name>.<name>mComputedBorderPadding</name>.<name>LeftRight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsTableReflowState</name></type> <name>reflowState</name><argument_list>(<argument><expr>*<call><name>PresContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr>*<name>this</name></expr></argument>,
                                 <argument><expr><name><name>aDesiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name>aAvailHeight</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ReflowChildren</name><argument_list>(<argument><expr><name>reflowState</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>, <argument><expr><name>aLastChildReflowed</name></expr></argument>,
                 <argument><expr><name><name>aDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ReflowColGroups</name><argument_list>(<argument><expr><name><name>aReflowState</name>.<name>rendContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsIFrame</name>*</type>
<name><name>nsTableFrame</name>::<name>GetFirstBodyRowGroupFrame</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>headerFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>footerFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

  <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>nsnull</name> != <name>kidFrame</name></expr>;</condition> <incr/>) <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>childDisplay</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// We expect the header and footer row group frames to be first, and we only</comment>
    <comment type="line">// allow one header and one footer</comment>
    <if>if <condition>(<expr><name>NS_STYLE_DISPLAY_TABLE_HEADER_GROUP</name> == <name><name>childDisplay</name>-&gt;<name>mDisplay</name></name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>headerFrame</name></expr>)</condition><then> <block>{
        <comment type="line">// We already have a header frame and so this header frame is treated</comment>
        <comment type="line">// like an ordinary body row group frame</comment>
        <return>return <expr><name>kidFrame</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>headerFrame</name> = <name>kidFrame</name></expr>;</expr_stmt>
    
    }</block></then> <else>else <if>if <condition>(<expr><name>NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP</name> == <name><name>childDisplay</name>-&gt;<name>mDisplay</name></name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>footerFrame</name></expr>)</condition><then> <block>{
        <comment type="line">// We already have a footer frame and so this footer frame is treated</comment>
        <comment type="line">// like an ordinary body row group frame</comment>
        <return>return <expr><name>kidFrame</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>footerFrame</name> = <name>kidFrame</name></expr>;</expr_stmt>

    }</block></then> <else>else <if>if <condition>(<expr><name>NS_STYLE_DISPLAY_TABLE_ROW_GROUP</name> == <name><name>childDisplay</name>-&gt;<name>mDisplay</name></name></expr>)</condition><then> <block>{
      <return>return <expr><name>kidFrame</name></expr>;</return>
    }</block></then></if></else></if></else></if>

    <comment type="line">// Get the next child</comment>
    <expr_stmt><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<comment type="line">// Table specific version that takes into account repeated header and footer</comment>
<comment type="line">// frames when continuing table frames</comment>
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>PushChildren</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>FrameArray</name>&amp;</type> <name>aFrames</name></decl></param>,
                           <param><decl><type><name>PRInt32</name></type> <name>aPushFrom</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aPushFrom</name> &gt; 0</expr></argument>, <argument><expr>"pushing first child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// extract the frames from the array into a sibling list</comment>
  <decl_stmt><decl><type><name>nsFrameList</name></type> <name>frames</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>lastFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>childX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>prevSiblingHint</name> <init>= <expr><call><name><name>aFrames</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>aPushFrom</name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for (<init><expr><name>childX</name> = <name>aPushFrom</name></expr>;</init> <condition><expr><name>childX</name> &lt; <call><name><name>aFrames</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>childX</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><name><name>aFrames</name><index>[<expr><name>childX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="line">// Don't push repeatable frames, do push non-rowgroup frames.</comment>
    <comment type="line">// XXXbz Need to push the non-rowgroup frames, even though we don't reflow</comment>
    <comment type="line">// them, so that we don't lose them.  Of course there shouldn't be any</comment>
    <comment type="line">// non-rowgroup frames here...</comment>
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>rgFrame</name></expr></argument>, <argument><expr>"Unexpected non-row-group frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>rgFrame</name> || !<call><name><name>rgFrame</name>-&gt;<name>IsRepeatable</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mFrames</name>.<name>RemoveFrame</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>prevSiblingHint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>frames</name>.<name>InsertFrame</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>lastFrame</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lastFrame</name> = <name>f</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <if>if <condition>(<expr><name>nsnull</name> != <call><name>GetNextInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsTableFrame</name>*</type> <name>nextInFlow</name> <init>= <expr>(<name>nsTableFrame</name>*)<call><name>GetNextInFlow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Insert the frames after any repeated header and footer frames</comment>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>firstBodyFrame</name> <init>= <expr><call><name><name>nextInFlow</name>-&gt;<name>GetFirstBodyRowGroupFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>prevSibling</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>firstBodyFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>prevSibling</name> = <call><name><name>nextInFlow</name>-&gt;<name>mFrames</name>.<name>GetPrevSiblingFor</name></name><argument_list>(<argument><expr><name>firstBodyFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// When pushing and pulling frames we need to check for whether any</comment>
    <comment type="line">// views need to be reparented.</comment>
    <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><call><name><name>frames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> = <call><name><name>f</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
      <expr_stmt><expr><call><name><name>nsHTMLContainerFrame</name>::<name>ReparentFrameView</name></name><argument_list>(<argument><expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>nextInFlow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name><name>nextInFlow</name>-&gt;<name>mFrames</name>.<name>InsertFrames</name></name><argument_list>(<argument><expr><call><name>GetNextInFlow</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>prevSibling</name></expr></argument>, <argument><expr><call><name><name>frames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <comment type="line">// Add the frames to our overflow list</comment>
    <expr_stmt><expr><call><name>SetOverflowFrames</name><argument_list>(<argument><expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>frames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="line">// Table specific version that takes into account header and footer row group</comment>
<comment type="line">// frames that are repeated for continuing table frames</comment>
<comment type="line">//</comment>
<comment type="line">// Appends the overflow frames to the end of the child list, just like the</comment>
<comment type="line">// nsContainerFrame version does, except that there are no assertions that</comment>
<comment type="line">// the child list is empty (it may not be empty, because there may be repeated</comment>
<comment type="line">// header/footer frames)</comment>
<function><type><name>PRBool</name></type>
<name><name>nsTableFrame</name>::<name>MoveOverflowToChildList</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Check for an overflow list with our prev-in-flow</comment>
  <decl_stmt><decl><type><name>nsTableFrame</name>*</type> <name>prevInFlow</name> <init>= <expr>(<name>nsTableFrame</name>*)<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>prevInFlow</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>prevOverflowFrames</name> <init>= <expr><call><name><name>prevInFlow</name>-&gt;<name>GetOverflowFrames</name></name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>prevOverflowFrames</name></expr>)</condition><then> <block>{
      <comment type="line">// When pushing and pulling frames we need to check for whether any</comment>
      <comment type="line">// views need to be reparented.</comment>
      <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><name>prevOverflowFrames</name></expr></init></decl>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> = <call><name><name>f</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <expr_stmt><expr><call><name><name>nsHTMLContainerFrame</name>::<name>ReparentFrameView</name></name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>prevInFlow</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name><name>mFrames</name>.<name>AppendFrames</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>prevOverflowFrames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// It's also possible that we have an overflow list for ourselves</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>overflowFrames</name> <init>= <expr><call><name>GetOverflowFrames</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>overflowFrames</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mFrames</name>.<name>AppendFrames</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>overflowFrames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>



<comment type="line">// collapsing row groups, rows, col groups and cols are accounted for after both passes of</comment>
<comment type="line">// reflow so that it has no effect on the calculations of reflow.</comment>
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>AdjustForCollapsingRowsCols</name></name><parameter_list>(<param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type> <name>aDesiredSize</name></decl></param>,
                                          <param><decl><type><name>nsMargin</name></type>             <name>aBorderPadding</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>yTotalOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">// total offset among all rows in all row groups</comment>

  <comment type="line">// reset the bit, it will be set again if row/rowgroup is collapsed</comment>
  <expr_stmt><expr><call><name>SetNeedToCollapse</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// collapse the rows and/or row groups as necessary</comment>
  <comment type="line">// Get the ordered children</comment>
  <decl_stmt><decl><type><name>RowGroupArray</name></type> <name>rowGroups</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>width</name> <init>= <expr><call><name>GetCollapsedWidth</name><argument_list>(<argument><expr><name>aBorderPadding</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>rgWidth</name> <init>= <expr><name>width</name> - 2 * <call><name>GetCellSpacingX</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>overflowArea</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <comment type="line">// Walk the list of children</comment>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>childX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>childX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>childX</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>childX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>rgFrame</name></expr></argument>, <argument><expr>"Must have row group frame here"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>yTotalOffset</name> += <call><name><name>rgFrame</name>-&gt;<name>CollapseRowGroupIfNecessary</name></name><argument_list>(<argument><expr><name>yTotalOffset</name></expr></argument>, <argument><expr><name>rgWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ConsiderChildOverflow</name><argument_list>(<argument><expr><name>overflowArea</name></expr></argument>, <argument><expr><name>rgFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for> 

  <expr_stmt><expr><name><name>aDesiredSize</name>.<name>height</name></name> -= <name>yTotalOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aDesiredSize</name>.<name>width</name></name>   = <name>width</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>overflowArea</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><call><name>nsRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>aDesiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aDesiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>overflowArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>FinishAndStoreOverflow</name><argument_list>(<argument><expr>&amp;<name>overflowArea</name></expr></argument>,
                         <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name><name>aDesiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aDesiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nscoord</name></type>
<name><name>nsTableFrame</name>::<name>GetCollapsedWidth</name></name><parameter_list>(<param><decl><type><name>nsMargin</name></type> <name>aBorderPadding</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>cellSpacingX</name> <init>= <expr><call><name>GetCellSpacingX</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>width</name> <init>= <expr><name>cellSpacingX</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>width</name> += <name><name>aBorderPadding</name>.<name>left</name></name> + <name><name>aBorderPadding</name>.<name>right</name></name></expr>;</expr_stmt>
  <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>groupFrame</name> <init>= <expr><call><name><name>mColGroups</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>groupFrame</name></expr>;</condition>
         <incr><expr><name>groupFrame</name> = <call><name><name>groupFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleVisibility</name>*</type> <name>groupVis</name> <init>= <expr><call><name><name>groupFrame</name>-&gt;<name>GetStyleVisibility</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>collapseGroup</name> <init>= <expr>(<name>NS_STYLE_VISIBILITY_COLLAPSE</name> == <name><name>groupVis</name>-&gt;<name>mVisible</name></name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>cgFrame</name> <init>= <expr>(<name>nsTableColGroupFrame</name>*)<name>groupFrame</name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name><name>cgFrame</name>-&gt;<name>GetFirstColumn</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>colFrame</name></expr>;</condition>
         <incr><expr><name>colFrame</name> = <call><name><name>colFrame</name>-&gt;<name>GetNextCol</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>colDisplay</name> <init>= <expr><call><name><name>colFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>colX</name> <init>= <expr><call><name><name>colFrame</name>-&gt;<name>GetColIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>NS_STYLE_DISPLAY_TABLE_COLUMN</name> == <name><name>colDisplay</name>-&gt;<name>mDisplay</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleVisibility</name>*</type> <name>colVis</name> <init>= <expr><call><name><name>colFrame</name>-&gt;<name>GetStyleVisibility</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>collapseCol</name> <init>= <expr>(<name>NS_STYLE_VISIBILITY_COLLAPSE</name> == <name><name>colVis</name>-&gt;<name>mVisible</name></name>)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>colWidth</name> <init>= <expr><call><name>GetColumnWidth</name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>collapseGroup</name> &amp;&amp; !<name>collapseCol</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>width</name> += <name>colWidth</name></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>GetNumCellsOriginatingInCol</name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
            <expr_stmt><expr><name>width</name> += <name>cellSpacingX</name></expr>;</expr_stmt></then></if>
        }</block></then></if>
      }</block></then></if>
    }</block></for>
  }</block></for>
  <return>return <expr><name>width</name></expr>;</return>
}</block></function>




<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>AppendFrames</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type>        <name>aListName</name></decl></param>,
                           <param><decl><type><name>nsIFrame</name>*</type>       <name>aFrameList</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aListName</name> || <name>aListName</name> == <name><name>nsGkAtoms</name>::<name>colGroupList</name></name></expr></argument>,
               <argument><expr>"unexpected child list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Because we actually have two child lists, one for col group frames and one</comment>
  <comment type="line">// for everything else, we need to look at each frame individually</comment>
  <comment type="line">// XXX The frame construction code should be separating out child frames</comment>
  <comment type="line">// based on the type, bug 343048.</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><name>aFrameList</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>f</name></expr>)</condition> <block>{
    <comment type="line">// Get the next frame and disconnect this frame from its sibling</comment>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>next</name> <init>= <expr><call><name><name>f</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>f</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// See what kind of frame we have</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>display</name> <init>= <expr><call><name><name>f</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP</name> == <name><name>display</name>-&gt;<name>mDisplay</name></name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>lastColGroup</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>doAppend</name> <init>= <expr><call><name><name>nsTableColGroupFrame</name>::<name>GetLastRealColGroup</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>(<name>nsIFrame</name>**) &amp;<name>lastColGroup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>startColIndex</name> <init>= <expr>(<name>lastColGroup</name>) 
        ? <call><name><name>lastColGroup</name>-&gt;<name>GetStartColumnIndex</name></name><argument_list>()</argument_list></call> + <call><name><name>lastColGroup</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call> : 0</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>doAppend</name></expr>)</condition><then> <block>{
        <comment type="line">// Append the new col group frame</comment>
        <expr_stmt><expr><call><name><name>mColGroups</name>.<name>AppendFrame</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <comment type="line">// there is a colgroup after the last real one</comment>
          <expr_stmt><expr><call><name><name>mColGroups</name>.<name>InsertFrame</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>lastColGroup</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <comment type="line">// Insert the colgroup and its cols into the table</comment>
      <expr_stmt><expr><call><name>InsertColGroups</name><argument_list>(<argument><expr><name>startColIndex</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>IsRowGroup</name><argument_list>(<argument><expr><name><name>display</name>-&gt;<name>mDisplay</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Append the new row group frame to the sibling chain</comment>
      <expr_stmt><expr><call><name><name>mFrames</name>.<name>AppendFrame</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// insert the row group and its rows into the table</comment>
      <expr_stmt><expr><call><name>InsertRowGroups</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <comment type="line">// Nothing special to do, just add the frame to our child list</comment>
      <expr_stmt><expr><call><name><name>mFrames</name>.<name>AppendFrame</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <comment type="line">// Move to the next frame</comment>
    <expr_stmt><expr><name>f</name> = <name>next</name></expr>;</expr_stmt>
  }</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_CELLMAP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"=== TableFrame::AppendFrames\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Dump</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>FrameNeedsReflow</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>nsIPresShell</name>::<name>eTreeChange</name></name></expr></argument>,
                                               <argument><expr><name>NS_FRAME_HAS_DIRTY_CHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SetGeometryDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>InsertFrames</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type>        <name>aListName</name></decl></param>,
                           <param><decl><type><name>nsIFrame</name>*</type>       <name>aPrevFrame</name></decl></param>,
                           <param><decl><type><name>nsIFrame</name>*</type>       <name>aFrameList</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Asssume there's only one frame being inserted. The problem is that</comment>
  <comment type="line">// row group frames and col group frames go in separate child lists and</comment>
  <comment type="line">// so if there's more than one this gets messy...</comment>
  <comment type="line">// XXX The frame construction code should be separating out child frames</comment>
  <comment type="line">// based on the type, bug 343048.</comment>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name><name>aFrameList</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"expected only one child frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aPrevFrame</name> || <call><name><name>aPrevFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call> == <name>this</name></expr></argument>,
               <argument><expr>"inserting after sibling frame with different parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// See what kind of frame we have</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>display</name> <init>= <expr><call><name><name>aFrameList</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aPrevFrame</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>prevDisplay</name> <init>= <expr><call><name><name>aPrevFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// Make sure they belong on the same frame list</comment>
    <if>if <condition>(<expr>(<name><name>display</name>-&gt;<name>mDisplay</name></name> == <name>NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP</name>) !=
        (<name><name>prevDisplay</name>-&gt;<name>mDisplay</name></name> == <name>NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP</name>)</expr>)</condition><then> <block>{
      <comment type="line">// the previous frame is not valid, see comment at ::AppendFrames</comment>
      <comment type="line">// XXXbz Using content indices here means XBL will get screwed</comment>
      <comment type="line">// over...  Oh, well.</comment>
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>pseudoFrame</name> <init>= <expr><name>aFrameList</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>parentContent</name> <init>= <expr><call><name>GetContent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>content</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>aPrevFrame</name> = <name>nsnull</name></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>pseudoFrame</name>  &amp;&amp; (<name>parentContent</name> ==
                              (<name>content</name> = <call><name><name>pseudoFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call>))</expr>)</condition> <block>{
        <expr_stmt><expr><name>pseudoFrame</name> = <call><name><name>pseudoFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>container</name> <init>= <expr><call><name><name>content</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>NS_LIKELY</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// XXX need this null-check, see bug 411823.</comment>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>newIndex</name> <init>= <expr><call><name><name>container</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>isColGroup</name> <init>= <expr>(<name>NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP</name> ==
                             <name><name>display</name>-&gt;<name>mDisplay</name></name>)</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>isColGroup</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>kidFrame</name> = <call><name><name>mColGroups</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><name>kidFrame</name> = <call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <comment type="line">// Important: need to start at a value smaller than all valid indices</comment>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>lastIndex</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
          <if>if <condition>(<expr><name>isColGroup</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsTableColGroupType</name></type> <name>groupType</name> <init>=
              <expr>((<name>nsTableColGroupFrame</name> *)<name>kidFrame</name>)-&gt;<call><name>GetColType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>eColGroupAnonymousCell</name> == <name>groupType</name></expr>)</condition><then> <block>{
              <continue>continue;</continue>
            }</block></then></if>
          }</block></then></if>
          <expr_stmt><expr><name>pseudoFrame</name> = <name>kidFrame</name></expr>;</expr_stmt>
          <while>while <condition>(<expr><name>pseudoFrame</name>  &amp;&amp; (<name>parentContent</name> ==
                                  (<name>content</name> = <call><name><name>pseudoFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call>))</expr>)</condition> <block>{
            <expr_stmt><expr><name>pseudoFrame</name> = <call><name><name>pseudoFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></while>
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>index</name> <init>= <expr><call><name><name>container</name>-&gt;<name>IndexOf</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>index</name> &gt; <name>lastIndex</name> &amp;&amp; <name>index</name> &lt; <name>newIndex</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>lastIndex</name> = <name>index</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>aPrevFrame</name> = <name>kidFrame</name></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr><name>NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP</name> == <name><name>display</name>-&gt;<name>mDisplay</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aListName</name> || <name>aListName</name> == <name><name>nsGkAtoms</name>::<name>colGroupList</name></name></expr></argument>,
                 <argument><expr>"unexpected child list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Insert the column group frame</comment>
    <function_decl><type><name>nsFrameList</name></type> <name>frames</name><parameter_list>(<param><decl><type><name>aFrameList</name></type></decl></param>)</parameter_list>;</function_decl> <comment type="line">// convience for getting last frame</comment>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>lastFrame</name> <init>= <expr><call><name><name>frames</name>.<name>LastChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mColGroups</name>.<name>InsertFrame</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aPrevFrame</name></expr></argument>, <argument><expr><name>aFrameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// find the starting col index for the first new col group</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>startColIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aPrevFrame</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>prevColGroup</name> <init>= 
        <expr>(<name>nsTableColGroupFrame</name>*)<call><name>GetFrameAtOrBefore</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aPrevFrame</name></expr></argument>,
                                                  <argument><expr><name><name>nsGkAtoms</name>::<name>tableColGroupFrame</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>prevColGroup</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>startColIndex</name> = <call><name><name>prevColGroup</name>-&gt;<name>GetStartColumnIndex</name></name><argument_list>()</argument_list></call> + <call><name><name>prevColGroup</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>InsertColGroups</name><argument_list>(<argument><expr><name>startColIndex</name></expr></argument>, <argument><expr><name>aFrameList</name></expr></argument>, <argument><expr><name>lastFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><call><name>IsRowGroup</name><argument_list>(<argument><expr><name><name>display</name>-&gt;<name>mDisplay</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aListName</name></expr></argument>, <argument><expr>"unexpected child list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <function_decl><type><name>nsFrameList</name></type> <name>newList</name><parameter_list>(<param><decl><type><name>aFrameList</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>lastSibling</name> <init>= <expr><call><name><name>newList</name>.<name>LastChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// Insert the frames in the sibling chain</comment>
    <expr_stmt><expr><call><name><name>mFrames</name>.<name>InsertFrame</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aPrevFrame</name></expr></argument>, <argument><expr><name>aFrameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>InsertRowGroups</name><argument_list>(<argument><expr><name>aFrameList</name></expr></argument>, <argument><expr><name>lastSibling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aListName</name></expr></argument>, <argument><expr>"unexpected child list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Just insert the frame and don't worry about reflowing it</comment>
    <expr_stmt><expr><call><name><name>mFrames</name>.<name>InsertFrame</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aPrevFrame</name></expr></argument>, <argument><expr><name>aFrameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></else></if></else></if>

  <expr_stmt><expr><call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>FrameNeedsReflow</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>nsIPresShell</name>::<name>eTreeChange</name></name></expr></argument>,
                                               <argument><expr><name>NS_FRAME_HAS_DIRTY_CHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SetGeometryDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_CELLMAP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"=== TableFrame::InsertFrames\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Dump</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>RemoveFrame</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type>        <name>aListName</name></decl></param>,
                          <param><decl><type><name>nsIFrame</name>*</type>       <name>aOldFrame</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// See what kind of frame we have</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>display</name> <init>= <expr><call><name><name>aOldFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// XXX The frame construction code should be separating out child frames</comment>
  <comment type="line">// based on the type, bug 343048.</comment>
  <if>if <condition>(<expr><name>NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP</name> == <name><name>display</name>-&gt;<name>mDisplay</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aListName</name> || <name>aListName</name> == <name><name>nsGkAtoms</name>::<name>colGroupList</name></name></expr></argument>,
                 <argument><expr>"unexpected child list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>nextColGroupFrame</name> <init>= <expr><call><name><name>aOldFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>colGroup</name> <init>= <expr>(<name>nsTableColGroupFrame</name>*)<name>aOldFrame</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>firstColIndex</name> <init>= <expr><call><name><name>colGroup</name>-&gt;<name>GetStartColumnIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>lastColIndex</name>  <init>= <expr><name>firstColIndex</name> + <call><name><name>colGroup</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mColGroups</name>.<name>DestroyFrame</name></name><argument_list>(<argument><expr><name>aOldFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>nsTableColGroupFrame</name>::<name>ResetColIndices</name></name><argument_list>(<argument><expr><name>nextColGroupFrame</name></expr></argument>, <argument><expr><name>firstColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// remove the cols from the table</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>colX</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>colX</name> = <name>lastColIndex</name></expr>;</init> <condition><expr><name>colX</name> &gt;= <name>firstColIndex</name></expr>;</condition> <incr><expr><name>colX</name>--</expr></incr>) <block>{
      <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr>(<name>nsTableColFrame</name>*)<call><name><name>mColFrames</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>colFrame</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RemoveCol</name><argument_list>(<argument><expr><name>colGroup</name></expr></argument>, <argument><expr><name>colX</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>numAnonymousColsToAdd</name> <init>= <expr><call><name>GetColCount</name><argument_list>()</argument_list></call> - <call><name><name>mColFrames</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>numAnonymousColsToAdd</name> &gt; 0</expr>)</condition><then> <block>{
      <comment type="line">// this sets the child list, updates the col cache and cell map</comment>
      <expr_stmt><expr><call><name>CreateAnonymousColFrames</name><argument_list>(<argument><expr><name>numAnonymousColsToAdd</name></expr></argument>,
                               <argument><expr><name>eColAnonymousCell</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aListName</name></expr></argument>, <argument><expr>"unexpected child list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>aOldFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rgFrame</name></expr>)</condition><then> <block>{
      <comment type="line">// remove the row group from the cell map</comment>
      <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>RemoveGroupCellMap</name></name><argument_list>(<argument><expr><name>rgFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

       <comment type="line">// remove the row group frame from the sibling chain</comment>
      <expr_stmt><expr><call><name><name>mFrames</name>.<name>DestroyFrame</name></name><argument_list>(<argument><expr><name>aOldFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
      <comment type="line">// XXXldb [reflow branch merging 20060830] do we still need this?</comment>
      <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>Synchronize</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ResetRowIndices</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>RebuildConsideringCells</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <expr_stmt><expr><call><name>MatchCellMapToColCache</name><argument_list>(<argument><expr><name>cellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <comment type="line">// Just remove the frame</comment>
      <expr_stmt><expr><call><name><name>mFrames</name>.<name>DestroyFrame</name></name><argument_list>(<argument><expr><name>aOldFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
  <comment type="line">// for now, just bail and recalc all of the collapsing borders</comment>
  <comment type="line">// XXXldb [reflow branch merging 20060830] do we still need this?</comment>
  <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>GetRowCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SetBCDamageArea</name><argument_list>(<argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>FrameNeedsReflow</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>nsIPresShell</name>::<name>eTreeChange</name></name></expr></argument>,
                                               <argument><expr><name>NS_FRAME_HAS_DIRTY_CHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SetGeometryDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_CELLMAP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"=== TableFrame::RemoveFrame\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Dump</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>nsMargin</name></type>
<name><name>nsTableFrame</name>::<name>GetUsedBorder</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr>!<call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name><name>nsHTMLContainerFrame</name>::<name>GetUsedBorder</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
  
  <return>return <expr><call><name>GetIncludedOuterBCBorder</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>nsMargin</name></type>
<name><name>nsTableFrame</name>::<name>GetUsedPadding</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr>!<call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name><name>nsHTMLContainerFrame</name>::<name>GetUsedPadding</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

  <return>return <expr><call><name>nsMargin</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DivideBCBorderSize</name><parameter_list>(<param><decl><type><name>nscoord</name></type>  <name>aPixelSize</name></decl></param>,
                   <param><decl><type><name>nscoord</name>&amp;</type> <name>aSmallHalf</name></decl></param>,
                   <param><decl><type><name>nscoord</name>&amp;</type> <name>aLargeHalf</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>aSmallHalf</name> = <name>aPixelSize</name> / 2</expr>;</expr_stmt>
  <expr_stmt><expr><name>aLargeHalf</name> = <name>aPixelSize</name> - <name>aSmallHalf</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsMargin</name></type>
<name><name>nsTableFrame</name>::<name>GetOuterBCBorder</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr><call><name>NeedToCalcBCBorders</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>const_cast</name><argument_list>&lt;<argument><expr><name>nsTableFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>-&gt;<call><name>CalcBCBorders</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>nsMargin</name></type> <name>border</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>p2t</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCPropertyData</name>*</type> <name>propData</name> <init>= 
    <expr>(<name>BCPropertyData</name>*)<call><name><name>nsTableFrame</name>::<name>GetProperty</name></name><argument_list>(<argument><expr>(<name>nsIFrame</name>*)<name>this</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>tableBCProperty</name></name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>propData</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>border</name>.<name>top</name></name> += <call><name>BC_BORDER_TOP_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mTopBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>border</name>.<name>right</name></name> += <call><name>BC_BORDER_RIGHT_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mRightBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>border</name>.<name>bottom</name></name> += <call><name>BC_BORDER_BOTTOM_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mBottomBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>border</name>.<name>left</name></name> += <call><name>BC_BORDER_LEFT_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mLeftBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>border</name></expr>;</return>
}</block></function>

<function><type><name>nsMargin</name></type>
<name><name>nsTableFrame</name>::<name>GetIncludedOuterBCBorder</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr><name>eCompatibility_NavQuirks</name> == <call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>CompatibilityMode</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><call><name>GetOuterBCBorder</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsMargin</name></type> <name>border</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <return>return <expr><name>border</name></expr>;</return>
}</block></function>

<function><type><name>nsMargin</name></type>
<name><name>nsTableFrame</name>::<name>GetExcludedOuterBCBorder</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr><name>eCompatibility_NavQuirks</name> != <call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>CompatibilityMode</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><call><name>GetOuterBCBorder</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsMargin</name></type> <name>border</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <return>return <expr><name>border</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>void</name></type> <name>GetSeparateModelBorderPadding</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>*</type> <name>aReflowState</name></decl></param>,
                                   <param><decl><type><name>nsStyleContext</name>&amp;</type>          <name>aStyleContext</name></decl></param>,
                                   <param><decl><type><name>nsMargin</name>&amp;</type>                <name>aBorderPadding</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// XXXbz Either we _do_ have a reflow state and then we can use its</comment>
  <comment type="line">// mComputedBorderPadding or we don't and then we get the padding</comment>
  <comment type="line">// wrong!</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleBorder</name>*</type> <name>border</name> <init>= <expr><call><name><name>aStyleContext</name>.<name>GetStyleBorder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>aBorderPadding</name> = <call><name><name>border</name>-&gt;<name>GetBorder</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aReflowState</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aBorderPadding</name> += <name><name>aReflowState</name>-&gt;<name>mComputedPadding</name></name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>nsMargin</name></type> 
<name><name>nsTableFrame</name>::<name>GetChildAreaOffset</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>*</type> <name>aReflowState</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsMargin</name></type> <name>offset</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>eCompatibility_NavQuirks</name> == <call><name><name>presContext</name>-&gt;<name>CompatibilityMode</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableFrame</name>*</type> <name>firstInFlow</name> <init>= <expr>(<name>nsTableFrame</name>*)<call><name>GetFirstInFlow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>firstInFlow</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>p2t</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BCPropertyData</name>*</type> <name>propData</name> <init>= 
        <expr>(<name>BCPropertyData</name>*)<call><name><name>nsTableFrame</name>::<name>GetProperty</name></name><argument_list>(<argument><expr>(<name>nsIFrame</name>*)<name>firstInFlow</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>tableBCProperty</name></name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>propData</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><name><name>offset</name>.<name>top</name></name> += <call><name>BC_BORDER_TOP_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mTopBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>offset</name>.<name>right</name></name> += <call><name>BC_BORDER_RIGHT_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mRightBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>offset</name>.<name>bottom</name></name> += <call><name>BC_BORDER_BOTTOM_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mBottomBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>offset</name>.<name>left</name></name> += <call><name>BC_BORDER_LEFT_HALF_COORD</name><argument_list>(<argument><expr><name>p2t</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mLeftBorderWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>GetSeparateModelBorderPadding</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr>*<name>mStyleContext</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>offset</name></expr>;</return>
}</block></function>

<function><type><name>nsMargin</name></type> 
<name><name>nsTableFrame</name>::<name>GetContentAreaOffset</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>*</type> <name>aReflowState</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsMargin</name></type> <name>offset</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// LDB: This used to unconditionally include the inner half as well,</comment>
    <comment type="line">// but that's pretty clearly wrong per the CSS2.1 spec.</comment>
    <expr_stmt><expr><name>offset</name> = <call><name>GetOuterBCBorder</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>GetSeparateModelBorderPadding</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr>*<name>mStyleContext</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>offset</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>InitChildReflowState</name></name><parameter_list>(<param><decl><type><name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>)</parameter_list>                                    
<block>{
  <decl_stmt><decl><type><name>nsMargin</name></type> <name>collapseBorder</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsMargin</name></type> <name>padding</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsMargin</name>*</type> <name>pCollapseBorder</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name><name>aReflowState</name>.<name>frame</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rgFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>pCollapseBorder</name> = <call><name><name>rgFrame</name>-&gt;<name>GetBCBorderWidth</name></name><argument_list>(<argument><expr><name>collapseBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>aReflowState</name>.<name>Init</name></name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>pCollapseBorder</name></expr></argument>, <argument><expr>&amp;<name>padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name><name>mBits</name>.<name>mResizedColumns</name></name> ||
               !<name><name>aReflowState</name>.<name>parentReflowState</name>-&gt;<name>mFlags</name>.<name>mSpecialHeightReflow</name></name></expr></argument>,
               <argument><expr>"should not resize columns on special height reflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>mBits</name>.<name>mResizedColumns</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>aReflowState</name>.<name>mFlags</name>.<name>mHResize</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">// Position and size aKidFrame and update our reflow state. The origin of</comment>
<comment type="line">// aKidRect is relative to the upper-left origin of our frame</comment>
<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>PlaceChild</name></name><parameter_list>(<param><decl><type><name>nsTableReflowState</name>&amp;</type>  <name>aReflowState</name></decl></param>,
                              <param><decl><type><name>nsIFrame</name>*</type>            <name>aKidFrame</name></decl></param>,
                              <param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type> <name>aKidDesiredSize</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>        <name>aOriginalKidRect</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isFirstReflow</name> <init>=
    <expr>(<call><name><name>aKidFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_FIRST_REFLOW</name>) != 0</expr></init></decl>;</decl_stmt>
  
  <comment type="line">// Place and size the child</comment>
  <expr_stmt><expr><call><name>FinishReflowChild</name><argument_list>(<argument><expr><name>aKidFrame</name></expr></argument>, <argument><expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aKidDesiredSize</name></expr></argument>,
                    <argument><expr><name><name>aReflowState</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aReflowState</name>.<name>y</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>InvalidateFrame</name><argument_list>(<argument><expr><name>aKidFrame</name></expr></argument>, <argument><expr><name>aOriginalKidRect</name></expr></argument>, <argument><expr><name>isFirstReflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Adjust the running y-offset</comment>
  <expr_stmt><expr><name><name>aReflowState</name>.<name>y</name></name> += <name><name>aKidDesiredSize</name>.<name>height</name></name></expr>;</expr_stmt>

  <comment type="line">// If our height is constrained, then update the available height</comment>
  <if>if <condition>(<expr><name>NS_UNCONSTRAINEDSIZE</name> != <name><name>aReflowState</name>.<name>availSize</name>.<name>height</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>aReflowState</name>.<name>availSize</name>.<name>height</name></name> -= <name><name>aKidDesiredSize</name>.<name>height</name></name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>OrderRowGroups</name></name><parameter_list>(<param><decl><type><name>RowGroupArray</name>&amp;</type> <name>aChildren</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name><name>aChildren</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>head</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>foot</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>kidDisplay</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rowGroup</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_LIKELY</name><argument_list>(<argument><expr><name>rowGroup</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <switch>switch<condition>(<expr><name><name>kidDisplay</name>-&gt;<name>mDisplay</name></name></expr>)</condition> <block>{
      <case>case <expr><name>NS_STYLE_DISPLAY_TABLE_HEADER_GROUP</name></expr>:
        <if>if <condition>(<expr><name>head</name></expr>)</condition><then> <block>{ <comment type="line">// treat additional thead like tbody</comment>
          <expr_stmt><expr><call><name><name>aChildren</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>rowGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><name>head</name> = <name>rowGroup</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      </case><case>case <expr><name>NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP</name></expr>:
        <if>if <condition>(<expr><name>foot</name></expr>)</condition><then> <block>{ <comment type="line">// treat additional tfoot like tbody</comment>
          <expr_stmt><expr><call><name><name>aChildren</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>rowGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><name>foot</name> = <name>rowGroup</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      </case><case>case <expr><name>NS_STYLE_DISPLAY_TABLE_ROW_GROUP</name></expr>:
        <expr_stmt><expr><call><name><name>aChildren</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>rowGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"How did this produce an nsTableRowGroupFrame?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Just ignore it</comment>
        <break>break;</break>
      </default>}</block></switch>
    }</block></then></if>
    <comment type="line">// Get the next sibling but skip it if it's also the next-in-flow, since</comment>
    <comment type="line">// a next-in-flow will not be part of the current table.</comment>
    <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>nif</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>kidFrame</name> != <name>nif</name></expr>)</condition><then> 
        <break>break;</break></then></if>
    }</block></while>
  }</block></while>

  <comment type="line">// put the thead first</comment>
  <if>if <condition>(<expr><name>head</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aChildren</name>.<name>InsertElementAt</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// put the tfoot after the last tbody</comment>
  <if>if <condition>(<expr><name>foot</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aChildren</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>foot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>PRUint32</name></type>
<name><name>nsTableFrame</name>::<name>OrderRowGroups</name></name><parameter_list>(<param><decl><type><name>FrameArray</name>&amp;</type> <name>aChildren</name></decl></param>,
                             <param><decl><type><name>nsTableRowGroupFrame</name>**</type> <name>aHead</name></decl></param>,
                             <param><decl><type><name>nsTableRowGroupFrame</name>**</type> <name>aFoot</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name><name>aChildren</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// initialize out parameters</comment>
  <expr_stmt><expr>*<name>aHead</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aFoot</name> = <name>nsnull</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>FrameArray</name></type> <name>nonRowGroups</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>head</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>foot</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>kidDisplay</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rowGroup</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_LIKELY</name><argument_list>(<argument><expr><name>rowGroup</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <switch>switch<condition>(<expr><name><name>kidDisplay</name>-&gt;<name>mDisplay</name></name></expr>)</condition> <block>{
      <case>case <expr><name>NS_STYLE_DISPLAY_TABLE_HEADER_GROUP</name></expr>:
        <if>if <condition>(<expr><name>head</name></expr>)</condition><then> <block>{ <comment type="line">// treat additional thead like tbody</comment>
          <expr_stmt><expr><call><name><name>aChildren</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><name>head</name> = <name>kidFrame</name></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>aHead</name> = <name>rowGroup</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      </case><case>case <expr><name>NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP</name></expr>:
        <if>if <condition>(<expr><name>foot</name></expr>)</condition><then> <block>{ <comment type="line">// treat additional tfoot like tbody</comment>
          <expr_stmt><expr><call><name><name>aChildren</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><name>foot</name> = <name>kidFrame</name></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>aFoot</name> = <name>rowGroup</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      </case><case>case <expr><name>NS_STYLE_DISPLAY_TABLE_ROW_GROUP</name></expr>:
        <expr_stmt><expr><call><name><name>aChildren</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <break>break;</break>
      </default>}</block></switch>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"Non-row-group primary frame list child of an "
                    "nsTableFrame?  How come?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>nonRowGroups</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="line">// Get the next sibling but skip it if it's also the next-in-flow, since</comment>
    <comment type="line">// a next-in-flow will not be part of the current table.</comment>
    <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>nif</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>kidFrame</name> != <name>nif</name></expr>)</condition><then> 
        <break>break;</break></then></if>
    }</block></while>
  }</block></while>
  
  <comment type="line">// put the thead first</comment>
  <if>if <condition>(<expr><name>head</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aChildren</name>.<name>InsertElementAt</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// put the tfoot after the last tbody</comment>
  <if>if <condition>(<expr><name>foot</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aChildren</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>foot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>rowGroupCount</name> <init>= <expr><call><name><name>aChildren</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aChildren</name>.<name>AppendElements</name></name><argument_list>(<argument><expr><name>nonRowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rowGroupCount</name></expr>;</return>
}</block></function>

<function><type><name>nsTableRowGroupFrame</name>*</type>
<name><name>nsTableFrame</name>::<name>GetTHead</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><call><name><name>kidFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call>-&gt;<name>mDisplay</name> ==
          <name>NS_STYLE_DISPLAY_TABLE_HEADER_GROUP</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rg</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>rg</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rg</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>

    <comment type="line">// Get the next sibling but skip it if it's also the next-in-flow, since</comment>
    <comment type="line">// a next-in-flow will not be part of the current table.</comment>
    <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>nif</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>kidFrame</name> != <name>nif</name></expr>)</condition><then> 
        <break>break;</break></then></if>
    }</block></while>
  }</block></while>

  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>nsTableRowGroupFrame</name>*</type>
<name><name>nsTableFrame</name>::<name>GetTFoot</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><call><name><name>kidFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call>-&gt;<name>mDisplay</name> ==
          <name>NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rg</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>rg</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rg</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>

    <comment type="line">// Get the next sibling but skip it if it's also the next-in-flow, since</comment>
    <comment type="line">// a next-in-flow will not be part of the current table.</comment>
    <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>nif</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>kidFrame</name> != <name>nif</name></expr>)</condition><then> 
        <break>break;</break></then></if>
    }</block></while>
  }</block></while>

  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>IsRepeatable</name><parameter_list>(<param><decl><type><name>nscoord</name></type> <name>aFrameHeight</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aPageHeight</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>aFrameHeight</name> &lt; (<name>aPageHeight</name> / 4)</expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsTableFrame</name>::<name>SetupHeaderFooterChild</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsTableReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                                     <param><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>aFrame</name></decl></param>,
                                     <param><decl><type><name>nscoord</name>*</type> <name>aDesiredHeight</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>pageHeight</name> <init>= <expr><call><name><name>presContext</name>-&gt;<name>GetPageSize</name></name><argument_list>()</argument_list></call>.<name>height</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name><name>aFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call> != <name>this</name> || <name>pageHeight</name> == <name>NS_UNCONSTRAINEDSIZE</name></expr>)</condition><then> <block>{
    <comment type="line">// Must be a scrollable head/footer (we don't allow those to repeat), or</comment>
    <comment type="line">// page has unconstrained height for some reason.</comment>
    <expr_stmt><expr>*<name>aDesiredHeight</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Reflow the child with unconstrainted height</comment>
  <decl_stmt><decl><type><name>nsHTMLReflowState</name></type> <name>kidReflowState</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name><name>aReflowState</name>.<name>reflowState</name></name></expr></argument>,
                                   <argument><expr><name>aFrame</name></expr></argument>,
                                   <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name><name>aReflowState</name>.<name>availSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name>NS_UNCONSTRAINEDSIZE</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr>-1</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>InitChildReflowState</name><argument_list>(<argument><expr><name>kidReflowState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>kidReflowState</name>.<name>mFlags</name>.<name>mIsTopOfPage</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsHTMLReflowMetrics</name></type> <name>desiredSize</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>desiredSize</name>.<name>width</name></name> = <name><name>desiredSize</name>.<name>height</name></name> = 0</expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsReflowStatus</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>ReflowChild</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>desiredSize</name></expr></argument>, <argument><expr><name>kidReflowState</name></expr></argument>,
                            <argument><expr><name><name>aReflowState</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aReflowState</name>.<name>y</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// The child will be reflowed again "for real" so no need to place it now</comment>

  <expr_stmt><expr><call><name><name>aFrame</name>-&gt;<name>SetRepeatable</name></name><argument_list>(<argument><expr><call><name>IsRepeatable</name><argument_list>(<argument><expr><name><name>desiredSize</name>.<name>height</name></name></expr></argument>, <argument><expr><name>pageHeight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aDesiredHeight</name> = <name><name>desiredSize</name>.<name>height</name></name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Reflow the children based on the avail size and reason in aReflowState</comment>
<comment type="line">// update aReflowMetrics a aStatus</comment>
<function><type><name>NS_METHOD</name></type> 
<name><name>nsTableFrame</name>::<name>ReflowChildren</name></name><parameter_list>(<param><decl><type><name>nsTableReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                             <param><decl><type><name>nsReflowStatus</name>&amp;</type>     <name>aStatus</name></decl></param>,
                             <param><decl><type><name>nsIFrame</name>*&amp;</type>          <name>aLastChildReflowed</name></decl></param>,
                             <param><decl><type><name>nsRect</name>&amp;</type>             <name>aOverflowArea</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>aStatus</name> = <name>NS_FRAME_COMPLETE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aLastChildReflowed</name> = <name>nsnull</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>prevKidFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type>  <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type>   <name>cellSpacingY</name> <init>= <expr><call><name>GetCellSpacingY</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// XXXldb Should we be checking constrained height instead?</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isPaginated</name> <init>= <expr><call><name><name>presContext</name>-&gt;<name>IsPaginated</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>aOverflowArea</name> = <call><name>nsRect</name> <argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>reflowAllKids</name> <init>= <expr><call><name><name>aReflowState</name>.<name>reflowState</name>.<name>ShouldReflowAllKids</name></name><argument_list>()</argument_list></call> ||
                         <name><name>mBits</name>.<name>mResizedColumns</name></name> ||
                         <call><name>IsGeometryDirty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>FrameArray</name></type> <name>rowGroups</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name> *</type><name>thead</name></decl>, *<decl><type ref="prev"/><name>tfoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>numRowGroups</name> <init>= <expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>, <argument><expr>&amp;<name>thead</name></expr></argument>, <argument><expr>&amp;<name>tfoot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>pageBreak</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>footerHeight</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="line">// Determine the repeatablility of headers and footers, and also the desired</comment>
  <comment type="line">// height of any repeatable footer.</comment>
  <comment type="line">// The repeatability of headers on continued tables is handled</comment>
  <comment type="line">// when they are created in nsCSSFrameConstructor::CreateContinuingTableFrame.</comment>
  <comment type="line">// We handle the repeatability of footers again here because we need to</comment>
  <comment type="line">// determine the footer's height anyway. We could perhaps optimize by</comment>
  <comment type="line">// using the footer's prev-in-flow's height instead of reflowing it again,</comment>
  <comment type="line">// but there's no real need.</comment>
  <if>if <condition>(<expr><name>isPaginated</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>thead</name> &amp;&amp; !<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nscoord</name></type> <name>desiredHeight</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rv</name> = <call><name>SetupHeaderFooterChild</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>thead</name></expr></argument>, <argument><expr>&amp;<name>desiredHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>tfoot</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <call><name>SetupHeaderFooterChild</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>tfoot</name></expr></argument>, <argument><expr>&amp;<name>footerHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>
  }</block></then></if>

  <for>for (<init><decl><type><name>PRUint32</name></type> <name>childX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>childX</name> &lt; <name>numRowGroups</name></expr>;</condition> <incr><expr><name>childX</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>childX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="line">// Get the frame state bits</comment>
    <comment type="line">// See if we should only reflow the dirty child frames</comment>
    <if>if <condition>(<expr><name>reflowAllKids</name> ||
        <call><name>NS_SUBTREE_DIRTY</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call> ||
        (<name><name>aReflowState</name>.<name>reflowState</name>.<name>mFlags</name>.<name>mSpecialHeightReflow</name></name> &amp;&amp;
         (<name>isPaginated</name> || (<call><name><name>kidFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp;
                          <name>NS_FRAME_CONTAINS_RELATIVE_HEIGHT</name>)))</expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>pageBreak</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PushChildren</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>, <argument><expr><name>childX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aStatus</name> = <name>NS_FRAME_NOT_COMPLETE</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>

      <function_decl><type><name>nsSize</name></type> <name>kidAvailSize</name><parameter_list>(<param><decl><type><name><name>aReflowState</name>.<name>availSize</name></name></type></decl></param>)</parameter_list>;</function_decl>
      <comment type="line">// if the child is a tbody in paginated mode reduce the height by a repeated footer</comment>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>allowRepeatedFooter</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>isPaginated</name> &amp;&amp; (<name>NS_UNCONSTRAINEDSIZE</name> != <name><name>kidAvailSize</name>.<name>height</name></name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>kidRG</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>kidRG</name> != <name>thead</name> &amp;&amp; <name>kidRG</name> != <name>tfoot</name> &amp;&amp; <name>tfoot</name> &amp;&amp; <call><name><name>tfoot</name>-&gt;<name>IsRepeatable</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// the child is a tbody and there is a repeatable footer</comment>
          <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>tfoot</name> == <name><name>rowGroups</name><index>[<expr><call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr>]</index></name></expr></argument>, <argument><expr>"Missing footer!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>footerHeight</name> + <name>cellSpacingY</name> &lt; <name><name>kidAvailSize</name>.<name>height</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>allowRepeatedFooter</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>kidAvailSize</name>.<name>height</name></name> -= <name>footerHeight</name> + <name>cellSpacingY</name></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if>

      <decl_stmt><decl><type><name>nsRect</name></type> <name>oldKidRect</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>nsHTMLReflowMetrics</name></type> <name>desiredSize</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>desiredSize</name>.<name>width</name></name> = <name><name>desiredSize</name>.<name>height</name></name> = 0</expr>;</expr_stmt>
  
      <comment type="line">// Reflow the child into the available space</comment>
      <decl_stmt><decl><type><name>nsHTMLReflowState</name></type> <name>kidReflowState</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name><name>aReflowState</name>.<name>reflowState</name></name></expr></argument>,
                                       <argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>kidAvailSize</name></expr></argument>,
                                       <argument><expr>-1</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>InitChildReflowState</name><argument_list>(<argument><expr><name>kidReflowState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// If this isn't the first row group, then we can't be at the top of the page</comment>
      <comment type="line">// When a new page starts, a head row group may be added automatically.</comment>
      <comment type="line">// We also consider the row groups just after the head as the top of the page.</comment>
      <comment type="line">// That is to prevent the infinite loop in some circumstance. See bug 344883.</comment>
      <if>if <condition>(<expr><name>childX</name> &gt; (<name>thead</name> ? 1 : 0)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>kidReflowState</name>.<name>mFlags</name>.<name>mIsTopOfPage</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name><name>aReflowState</name>.<name>y</name></name> += <name>cellSpacingY</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>NS_UNCONSTRAINEDSIZE</name> != <name><name>aReflowState</name>.<name>availSize</name>.<name>height</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>aReflowState</name>.<name>availSize</name>.<name>height</name></name> -= <name>cellSpacingY</name></expr>;</expr_stmt>
      }</block></then></if>
      <comment type="line">// record the presence of a next in flow, it might get destroyed so we</comment>
      <comment type="line">// need to reorder the row group array</comment>
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidNextInFlow</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>reorder</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name><name>kidFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>reorder</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><name>rv</name> = <call><name>ReflowChild</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>desiredSize</name></expr></argument>, <argument><expr><name>kidReflowState</name></expr></argument>,
                       <argument><expr><name><name>aReflowState</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aReflowState</name>.<name>y</name></name></expr></argument>,
                       <argument><expr><name>NS_FRAME_INVALIDATE_ON_MOVE</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>reorder</name></expr>)</condition><then> <block>{
        <comment type="line">// reorder row groups the reflow may have changed the nextinflows</comment>
        <expr_stmt><expr><name>numRowGroups</name> = <call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>, <argument><expr>&amp;<name>thead</name></expr></argument>, <argument><expr>&amp;<name>tfoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>childX</name> = <call><name><name>rowGroups</name>.<name>IndexOf</name></name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>childX</name> == <name><name>RowGroupArray</name>::<name>NoIndex</name></name></expr>)</condition><then> <block>{
          <comment type="line">// XXXbz can this happen?</comment>
          <expr_stmt><expr><name>childX</name> = <name>numRowGroups</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <comment type="line">// see if the rowgroup did not fit on this page might be pushed on</comment>
      <comment type="line">// the next page</comment>
      <if>if <condition>(<expr><call><name>NS_FRAME_IS_COMPLETE</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>)</argument_list></call> &amp;&amp; <name>isPaginated</name> &amp;&amp;
          (<name>NS_UNCONSTRAINEDSIZE</name> != <name><name>kidReflowState</name>.<name>availableHeight</name></name>) &amp;&amp;
          <name><name>kidReflowState</name>.<name>availableHeight</name></name> &lt; <name><name>desiredSize</name>.<name>height</name></name></expr>)</condition><then> <block>{
        <comment type="line">// if we are on top of the page place with dataloss</comment>
        <if>if <condition>(<expr><name><name>kidReflowState</name>.<name>mFlags</name>.<name>mIsTopOfPage</name></name></expr>)</condition><then> <block>{
          <if>if <condition>(<expr><name>childX</name>+1 &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>nextRowGroupFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>childX</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>nextRowGroupFrame</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>PlaceChild</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>desiredSize</name></expr></argument>, <argument><expr><name>oldKidRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>aStatus</name> = <name>NS_FRAME_NOT_COMPLETE</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>PushChildren</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>, <argument><expr><name>childX</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>aLastChildReflowed</name> = <name>kidFrame</name></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
          }</block></then></if>
        }</block></then>
        <else>else <block>{ <comment type="line">// we are not on top, push this rowgroup onto the next page</comment>
          <if>if <condition>(<expr><name>prevKidFrame</name></expr>)</condition><then> <block>{ <comment type="line">// we had a rowgroup before so push this</comment>
            <comment type="line">// XXXroc shouldn't we add a repeated footer here?</comment>
            <expr_stmt><expr><name>aStatus</name> = <name>NS_FRAME_NOT_COMPLETE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PushChildren</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>, <argument><expr><name>childX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>aLastChildReflowed</name> = <name>prevKidFrame</name></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></else></if>
      }</block></then></if>

      <expr_stmt><expr><name>aLastChildReflowed</name>   = <name>kidFrame</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>pageBreak</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      <comment type="line">// see if there is a page break after this row group or before the next one</comment>
      <if>if <condition>(<expr><call><name>NS_FRAME_IS_COMPLETE</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>)</argument_list></call> &amp;&amp; <name>isPaginated</name> &amp;&amp; 
          (<name>NS_UNCONSTRAINEDSIZE</name> != <name><name>kidReflowState</name>.<name>availableHeight</name></name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>nextKid</name> <init>=
          <expr>(<name>childX</name> + 1 &lt; <name>numRowGroups</name>) ? <name><name>rowGroups</name><index>[<expr><name>childX</name> + 1</expr>]</index></name> : <name>nsnull</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pageBreak</name> = <call><name>PageBreakAfter</name><argument_list>(<argument><expr>*<name>kidFrame</name></expr></argument>, <argument><expr><name>nextKid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <comment type="line">// Place the child</comment>
      <expr_stmt><expr><call><name>PlaceChild</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>desiredSize</name></expr></argument>, <argument><expr><name>oldKidRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// Remember where we just were in case we end up pushing children</comment>
      <expr_stmt><expr><name>prevKidFrame</name> = <name>kidFrame</name></expr>;</expr_stmt>

      <comment type="line">// Special handling for incomplete children</comment>
      <if>if <condition>(<expr><call><name>NS_FRAME_IS_NOT_COMPLETE</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{         
        <expr_stmt><expr><name>kidNextInFlow</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>kidNextInFlow</name></expr>)</condition><then> <block>{
          <comment type="line">// The child doesn't have a next-in-flow so create a continuing</comment>
          <comment type="line">// frame. This hooks the child into the flow</comment>
          <decl_stmt><decl><type><name>nsIFrame</name>*</type>     <name>continuingFrame</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>rv</name> = <call><name><name>presContext</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call>-&gt;<call><name>FrameConstructor</name><argument_list>()</argument_list></call>-&gt;
            <call><name>CreateContinuingFrame</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>this</name></expr></argument>,
                                  <argument><expr>&amp;<name>continuingFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>aStatus</name> = <name>NS_FRAME_COMPLETE</name></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>

          <comment type="line">// Add the continuing frame to the sibling list</comment>
          <expr_stmt><expr><call><name><name>continuingFrame</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>kidFrame</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>continuingFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// Update rowGroups with the new rowgroup, just as it</comment>
          <comment type="line">// would have been if we had called OrderRowGroups</comment>
          <comment type="line">// again. Note that rowGroups doesn't get used again after</comment>
          <comment type="line">// we PushChildren below, anyway.</comment>
          <expr_stmt><expr><call><name><name>rowGroups</name>.<name>InsertElementAt</name></name><argument_list>(<argument><expr><name>childX</name> + 1</expr></argument>, <argument><expr><name>continuingFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <comment type="line">// put the nextinflow so that it will get pushed</comment>
          <expr_stmt><expr><call><name><name>rowGroups</name>.<name>InsertElementAt</name></name><argument_list>(<argument><expr><name>childX</name> + 1</expr></argument>, <argument><expr><name>kidNextInFlow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <comment type="line">// We've used up all of our available space so push the remaining</comment>
        <comment type="line">// children to the next-in-flow</comment>
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>nextSibling</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>nsnull</name> != <name>nextSibling</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>PushChildren</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>, <argument><expr><name>childX</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>allowRepeatedFooter</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>kidAvailSize</name>.<name>height</name></name> = <name>footerHeight</name></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>nsHTMLReflowState</name></type> <name>footerReflowState</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>,
                                              <argument><expr><name><name>aReflowState</name>.<name>reflowState</name></name></expr></argument>,
                                              <argument><expr><name>tfoot</name></expr></argument>, <argument><expr><name>kidAvailSize</name></expr></argument>,
                                              <argument><expr>-1</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>InitChildReflowState</name><argument_list>(<argument><expr><name>footerReflowState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>aReflowState</name>.<name>y</name></name> += <name>cellSpacingY</name></expr>;</expr_stmt>

          <decl_stmt><decl><type><name>nsRect</name></type> <name>origTfootRect</name> <init>= <expr><call><name><name>tfoot</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          
          <decl_stmt><decl><type><name>nsReflowStatus</name></type> <name>footerStatus</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>rv</name> = <call><name>ReflowChild</name><argument_list>(<argument><expr><name>tfoot</name></expr></argument>, <argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>desiredSize</name></expr></argument>, <argument><expr><name>footerReflowState</name></expr></argument>,
                           <argument><expr><name><name>aReflowState</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aReflowState</name>.<name>y</name></name></expr></argument>,
                           <argument><expr><name>NS_FRAME_INVALIDATE_ON_MOVE</name></expr></argument>, <argument><expr><name>footerStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>PlaceChild</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>tfoot</name></expr></argument>, <argument><expr><name>desiredSize</name></expr></argument>, <argument><expr><name>origTfootRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      }</block></then></if>
    }</block></then>
    <else>else <block>{ <comment type="line">// it isn't being reflowed</comment>
      <expr_stmt><expr><name><name>aReflowState</name>.<name>y</name></name> += <name>cellSpacingY</name></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsRect</name></type> <name>kidRect</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name><name>kidRect</name>.<name>y</name></name> != <name><name>aReflowState</name>.<name>y</name></name></expr>)</condition><then> <block>{
        <comment type="line">// invalidate the old position</comment>
        <expr_stmt><expr><call><name><name>kidFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>kidRect</name>.<name>y</name></name> = <name><name>aReflowState</name>.<name>y</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>kidFrame</name>-&gt;<name>SetRect</name></name><argument_list>(<argument><expr><name>kidRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="line">// move to the new position</comment>
        <expr_stmt><expr><call><name>RePositionViews</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// invalidate the new position</comment>
        <expr_stmt><expr><call><name><name>kidFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name><name>aReflowState</name>.<name>y</name></name> += <name><name>kidRect</name>.<name>height</name></name></expr>;</expr_stmt>

      <comment type="line">// If our height is constrained then update the available height.</comment>
      <if>if <condition>(<expr><name>NS_UNCONSTRAINEDSIZE</name> != <name><name>aReflowState</name>.<name>availSize</name>.<name>height</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>aReflowState</name>.<name>availSize</name>.<name>height</name></name> -= <name>cellSpacingY</name> + <name><name>kidRect</name>.<name>height</name></name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>ConsiderChildOverflow</name><argument_list>(<argument><expr><name>aOverflowArea</name></expr></argument>, <argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  
  <comment type="line">// We've now propagated the column resizes and geometry changes to all</comment>
  <comment type="line">// the children.</comment>
  <expr_stmt><expr><name><name>mBits</name>.<name>mResizedColumns</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ClearGeometryDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>ReflowColGroups</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>HaveReflowedColGroups</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsHTMLReflowMetrics</name></type> <name>kidMet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsPresContext</name> *</type><name>presContext</name> <init>= <expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><call><name><name>mColGroups</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>kidFrame</name></expr>;</condition>
         <incr><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
      <if>if <condition>(<expr><call><name>NS_SUBTREE_DIRTY</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// The column groups don't care about dimensions or reflow states.</comment>
        <decl_stmt><decl><type><name>nsHTMLReflowState</name></type> <name>kidReflowState</name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>kidFrame</name></expr></argument>,
                                       <argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsReflowStatus</name></type> <name>cgStatus</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ReflowChild</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>kidMet</name></expr></argument>, <argument><expr><name>kidReflowState</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                    <argument><expr><name>cgStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FinishReflowChild</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>kidMet</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>SetHaveReflowedColGroups</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> 
<name><name>nsTableFrame</name>::<name>CalcDesiredHeight</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>, <param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type> <name>aDesiredSize</name></decl></param>)</parameter_list> 
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>cellMap</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"never ever call me until the cell map is built!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aDesiredSize</name>.<name>height</name></name> = 0</expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nscoord</name></type>  <name>cellSpacingY</name> <init>= <expr><call><name>GetCellSpacingY</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsMargin</name></type> <name>borderPadding</name> <init>= <expr><call><name>GetChildAreaOffset</name><argument_list>(<argument><expr>&amp;<name>aReflowState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// get the natural height based on the last child's (row group or scroll frame) rect</comment>
  <decl_stmt><decl><type><name>FrameArray</name></type> <name>rowGroups</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>numRowGroups</name></decl>;</decl_stmt>
  <block>{
    <comment type="line">// Scope for the dummies so we don't use them by accident</comment>
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name> *</type><name>dummy1</name></decl>, *<decl><type ref="prev"/><name>dummy2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>numRowGroups</name> = <call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>, <argument><expr>&amp;<name>dummy1</name></expr></argument>, <argument><expr>&amp;<name>dummy2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
  <if>if <condition>(<expr><name>numRowGroups</name> == 0</expr>)</condition><then> <block>{
    <comment type="line">// tables can be used as rectangular items without content</comment>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>tableSpecifiedHeight</name> <init>= <expr><call><name>CalcBorderBoxHeight</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>(<name>NS_UNCONSTRAINEDSIZE</name> != <name>tableSpecifiedHeight</name>) &amp;&amp;
        (<name>tableSpecifiedHeight</name> &gt; 0) &amp;&amp;
        <name>eCompatibility_NavQuirks</name> != <call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>CompatibilityMode</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// empty tables should not have a size in quirks mode</comment>
      <expr_stmt><expr><name><name>aDesiredSize</name>.<name>height</name></name> = <name>tableSpecifiedHeight</name></expr>;</expr_stmt>
    }</block></then> 
    <else>else
      <expr_stmt><expr><name><name>aDesiredSize</name>.<name>height</name></name> = 0</expr>;</expr_stmt></else></if>
    <return>return;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowCount</name> <init>= <expr><call><name><name>cellMap</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colCount</name> <init>= <expr><call><name><name>cellMap</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>desiredHeight</name> <init>= <expr><name><name>borderPadding</name>.<name>top</name></name> + <name><name>borderPadding</name>.<name>bottom</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>rowCount</name> &gt; 0 &amp;&amp; <name>colCount</name> &gt; 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>desiredHeight</name> += <name>cellSpacingY</name></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>rgX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rgX</name> &lt; <name>numRowGroups</name></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name>desiredHeight</name> += <name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name>-&gt;<call><name>GetSize</name><argument_list>()</argument_list></call>.<name>height</name> + <name>cellSpacingY</name></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>

  <comment type="line">// see if a specified table height requires dividing additional space to rows</comment>
  <if>if <condition>(<expr>!<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nscoord</name></type> <name>tableSpecifiedHeight</name> <init>= <expr><call><name>CalcBorderBoxHeight</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>(<name>tableSpecifiedHeight</name> &gt; 0) &amp;&amp; 
        (<name>tableSpecifiedHeight</name> != <name>NS_UNCONSTRAINEDSIZE</name>) &amp;&amp;
        (<name>tableSpecifiedHeight</name> &gt; <name>desiredHeight</name>)</expr>)</condition><then> <block>{
      <comment type="line">// proportionately distribute the excess height to unconstrained rows in each</comment>
      <comment type="line">// unconstrained row group.</comment>
      <expr_stmt><expr><call><name>DistributeHeightToRows</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>tableSpecifiedHeight</name> - <name>desiredHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// this might have changed the overflow area incorporate the childframe overflow area.</comment>
      <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>kidFrame</name></expr>;</condition> <incr><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <expr_stmt><expr><call><name>ConsiderChildOverflow</name><argument_list>(<argument><expr><name><name>aDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>, <argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for> 
      <expr_stmt><expr><name>desiredHeight</name> = <name>tableSpecifiedHeight</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><name><name>aDesiredSize</name>.<name>height</name></name> = <name>desiredHeight</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier>
<name>void</name></type> <name>ResizeCells</name><parameter_list>(<param><decl><type><name>nsTableFrame</name>&amp;</type> <name>aTableFrame</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsTableFrame</name>::<name>RowGroupArray</name></name></type> <name>rowGroups</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aTableFrame</name>.<name>OrderRowGroups</name></name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsHTMLReflowMetrics</name></type> <name>tableDesiredSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>tableRect</name> <init>= <expr><call><name><name>aTableFrame</name>.<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>tableDesiredSize</name>.<name>width</name></name> = <name><name>tableRect</name>.<name>width</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tableDesiredSize</name>.<name>height</name></name> = <name><name>tableRect</name>.<name>height</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tableDesiredSize</name>.<name>mOverflowArea</name></name> = <call><name>nsRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>tableRect</name>.<name>width</name></name></expr></argument>,
                                          <argument><expr><name><name>tableRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><decl><type><name>PRUint32</name></type> <name>rgX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rgX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
   
    <decl_stmt><decl><type><name>nsRect</name></type> <name>rowGroupRect</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsHTMLReflowMetrics</name></type> <name>groupDesiredSize</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>groupDesiredSize</name>.<name>width</name></name> = <name><name>rowGroupRect</name>.<name>width</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>groupDesiredSize</name>.<name>height</name></name> = <name><name>rowGroupRect</name>.<name>height</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>groupDesiredSize</name>.<name>mOverflowArea</name></name> = <call><name>nsRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>groupDesiredSize</name>.<name>width</name></name></expr></argument>,
                                      <argument><expr><name><name>groupDesiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>rowFrame</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetFirstRow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>rowFrame</name></expr>)</condition> <block>{
      <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>DidResize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>ConsiderChildOverflow</name></name><argument_list>(<argument><expr><name><name>groupDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>, <argument><expr><name>rowFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rowFrame</name> = <call><name><name>rowFrame</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>FinishAndStoreOverflow</name></name><argument_list>(<argument><expr>&amp;<name><name>groupDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>,
                                    <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name><name>groupDesiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>groupDesiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// make the coordinates of |desiredSize.mOverflowArea| incorrect</comment>
    <comment type="line">// since it's about to go away:</comment>
    <expr_stmt><expr><call><name><name>groupDesiredSize</name>.<name>mOverflowArea</name>.<name>MoveBy</name></name><argument_list>(<argument><expr><call><name><name>rgFrame</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>tableDesiredSize</name>.<name>mOverflowArea</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name><name>tableDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>, <argument><expr><name><name>groupDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name><name>aTableFrame</name>.<name>FinishAndStoreOverflow</name></name><argument_list>(<argument><expr>&amp;<name><name>tableDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>,
                                     <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name><name>tableDesiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>tableDesiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>DistributeHeightToRows</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                                     <param><decl><type><name>nscoord</name></type>                  <name>aAmount</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>cellSpacingY</name> <init>= <expr><call><name>GetCellSpacingY</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsMargin</name></type> <name>borderPadding</name> <init>= <expr><call><name>GetChildAreaOffset</name><argument_list>(<argument><expr>&amp;<name>aReflowState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>RowGroupArray</name></type> <name>rowGroups</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nscoord</name></type> <name>amountUsed</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <comment type="line">// distribute space to each pct height row whose row group doesn't have a computed </comment>
  <comment type="line">// height, and base the pct on the table height. If the row group had a computed </comment>
  <comment type="line">// height, then this was already done in nsTableRowGroupFrame::CalculateRowHeights</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>pctBasis</name> <init>= <expr><call><name><name>aReflowState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call> - (<call><name>GetCellSpacingY</name><argument_list>()</argument_list></call> * (<call><name>GetRowCount</name><argument_list>()</argument_list></call> + 1))</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>yOriginRG</name> <init>= <expr><name><name>borderPadding</name>.<name>top</name></name> + <call><name>GetCellSpacingY</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>yEndRG</name> <init>= <expr><name>yOriginRG</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>rgX</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>rgX</name> = 0</expr>;</init> <condition><expr><name>rgX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>amountUsedByRG</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>yOriginRow</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>rgRect</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>rgFrame</name>-&gt;<name>HasStyleHeight</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>rowFrame</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetFirstRow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>rowFrame</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>nsRect</name></type> <name>rowRect</name> <init>= <expr><call><name><name>rowFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name>amountUsed</name> &lt; <name>aAmount</name>) &amp;&amp; <call><name><name>rowFrame</name>-&gt;<name>HasPctHeight</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>nscoord</name></type> <name>pctHeight</name> <init>= <expr><call><name><name>rowFrame</name>-&gt;<name>GetHeight</name></name><argument_list>(<argument><expr><name>pctBasis</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nscoord</name></type> <name>amountForRow</name> <init>= <expr><call><name>PR_MIN</name><argument_list>(<argument><expr><name>aAmount</name> - <name>amountUsed</name></expr></argument>, <argument><expr><name>pctHeight</name> - <name><name>rowRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>amountForRow</name> &gt; 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsRect</name></type> <name>oldRowRect</name> <init>= <expr><name>rowRect</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>rowRect</name>.<name>height</name></name> += <name>amountForRow</name></expr>;</expr_stmt>
            <comment type="line">// XXXbz we don't need to change rowRect.y to be yOriginRow?</comment>
            <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>SetRect</name></name><argument_list>(<argument><expr><name>rowRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>yOriginRow</name> += <name><name>rowRect</name>.<name>height</name></name> + <name>cellSpacingY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>yEndRG</name> += <name><name>rowRect</name>.<name>height</name></name> + <name>cellSpacingY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>amountUsed</name> += <name>amountForRow</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>amountUsedByRG</name> += <name>amountForRow</name></expr>;</expr_stmt>
            <comment type="line">//rowFrame-&gt;DidResize();        </comment>
            <expr_stmt><expr><call><name><name>nsTableFrame</name>::<name>RePositionViews</name></name><argument_list>(<argument><expr><name>rowFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>InvalidateRectDifference</name></name><argument_list>(<argument><expr><name>oldRowRect</name></expr></argument>, <argument><expr><name>rowRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then>
        <else>else <block>{
          <if>if <condition>(<expr><name>amountUsed</name> &gt; 0 &amp;&amp; <name>yOriginRow</name> != <name><name>rowRect</name>.<name>y</name></name> &amp;&amp;
              !(<call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_FIRST_REFLOW</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>SetPosition</name></name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr><name><name>rowRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name>yOriginRow</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>nsTableFrame</name>::<name>RePositionViews</name></name><argument_list>(<argument><expr><name>rowFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>yOriginRow</name> += <name><name>rowRect</name>.<name>height</name></name> + <name>cellSpacingY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>yEndRG</name> += <name><name>rowRect</name>.<name>height</name></name> + <name>cellSpacingY</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>rowFrame</name> = <call><name><name>rowFrame</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <if>if <condition>(<expr><name>amountUsed</name> &gt; 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>rgRect</name>.<name>y</name></name> != <name>yOriginRG</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>nsRect</name></type> <name>origRgRect</name> <init>= <expr><name>rgRect</name></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name><name>rgRect</name>.<name>y</name></name> = <name>yOriginRG</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rgRect</name>.<name>height</name></name> += <name>amountUsedByRG</name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>SetRect</name></name><argument_list>(<argument><expr><name>rgRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>nsTableFrame</name>::<name>InvalidateFrame</name></name><argument_list>(<argument><expr><name>rgFrame</name></expr></argument>, <argument><expr><name>origRgRect</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>amountUsed</name> &gt; 0 &amp;&amp; <name>yOriginRG</name> != <call><name><name>rgFrame</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call>.<name>y</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>rgFrame</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call>.<name>x</name> == 0</expr></argument>, <argument><expr>"Unexpected position"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>SetPosition</name></name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>yOriginRG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Make sure child views are properly positioned</comment>
      <expr_stmt><expr><call><name><name>nsTableFrame</name>::<name>RePositionViews</name></name><argument_list>(<argument><expr><name>rgFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <expr_stmt><expr><name>yOriginRG</name> = <name>yEndRG</name></expr>;</expr_stmt>
  }</block></for>

  <if>if <condition>(<expr><name>amountUsed</name> &gt;= <name>aAmount</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ResizeCells</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <comment type="line">// get the first row without a style height where its row group has an</comment>
  <comment type="line">// unconstrained height</comment>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>firstUnStyledRG</name>  <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type>      <name>firstUnStyledRow</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <for>for (<init><expr><name>rgX</name> = 0</expr>;</init> <condition><expr><name>rgX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call> &amp;&amp; !<name>firstUnStyledRG</name></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>rgFrame</name>-&gt;<name>HasStyleHeight</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>rowFrame</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetFirstRow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>rowFrame</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>!<call><name><name>rowFrame</name>-&gt;<name>HasStyleHeight</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>firstUnStyledRG</name> = <name>rgFrame</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>firstUnStyledRow</name> = <name>rowFrame</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>rowFrame</name> = <call><name><name>rowFrame</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
    }</block></then></if>
  }</block></for>

  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>lastEligibleRow</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <comment type="line">// Accumulate the correct divisor. This will be the total total height of all</comment>
  <comment type="line">// unstyled rows inside unstyled row groups, unless there are none, in which</comment>
  <comment type="line">// case, it will be number of all rows. If the unstyled rows don't have a</comment>
  <comment type="line">// height, divide the space equally among them.</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>divisor</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>eligibleRows</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>expandEmptyRows</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>firstUnStyledRow</name></expr>)</condition><then> <block>{
    <comment type="line">// there is no unstyled row</comment>
    <expr_stmt><expr><name>divisor</name> = <call><name>GetRowCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <for>for (<init><expr><name>rgX</name> = 0</expr>;</init> <condition><expr><name>rgX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>firstUnStyledRG</name> || !<call><name><name>rgFrame</name>-&gt;<name>HasStyleHeight</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>rowFrame</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetFirstRow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>rowFrame</name></expr>)</condition> <block>{
          <if>if <condition>(<expr>!<name>firstUnStyledRG</name> || !<call><name><name>rowFrame</name>-&gt;<name>HasStyleHeight</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>rowFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call>.<name>height</name> &gt;= 0</expr></argument>,
                         <argument><expr>"negative row frame height"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>divisor</name> += <call><name><name>rowFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call>.<name>height</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>eligibleRows</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>lastEligibleRow</name> = <name>rowFrame</name></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>rowFrame</name> = <call><name><name>rowFrame</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
      }</block></then></if>
    }</block></for>
    <if>if <condition>(<expr><name>divisor</name> &lt;= 0</expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>eligibleRows</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>expandEmptyRows</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"invalid divisor"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      }</block></else></if>
    }</block></then></if>
  }</block></else></if>
  <comment type="line">// allocate the extra height to the unstyled row groups and rows</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>heightToDistribute</name> <init>= <expr><name>aAmount</name> - <name>amountUsed</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>yOriginRG</name> = <name><name>borderPadding</name>.<name>top</name></name> + <name>cellSpacingY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>yEndRG</name> = <name>yOriginRG</name></expr>;</expr_stmt>
  <for>for (<init><expr><name>rgX</name> = 0</expr>;</init> <condition><expr><name>rgX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>amountUsedByRG</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>yOriginRow</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>rgRect</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// see if there is an eligible row group or we distribute to all rows</comment>
    <if>if <condition>(<expr>!<name>firstUnStyledRG</name> || !<call><name><name>rgFrame</name>-&gt;<name>HasStyleHeight</name></name><argument_list>()</argument_list></call> || !<name>eligibleRows</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>rowFrame</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetFirstRow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>rowFrame</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>nsRect</name></type> <name>rowRect</name> <init>= <expr><call><name><name>rowFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// see if there is an eligible row or we distribute to all rows</comment>
        <if>if <condition>(<expr>!<name>firstUnStyledRow</name> || !<call><name><name>rowFrame</name>-&gt;<name>HasStyleHeight</name></name><argument_list>()</argument_list></call> || !<name>eligibleRows</name></expr>)</condition><then> <block>{          
          <decl_stmt><decl><type><name>float</name></type> <name>ratio</name></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>eligibleRows</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name>expandEmptyRows</name></expr>)</condition><then> <block>{
              <comment type="line">// The amount of additional space each row gets is proportional to</comment>
              <comment type="line">// its height</comment>
              <expr_stmt><expr><name>ratio</name> = <call><name>float</name><argument_list>(<argument><expr><name><name>rowRect</name>.<name>height</name></name></expr></argument>)</argument_list></call> / <call><name>float</name><argument_list>(<argument><expr><name>divisor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
              <comment type="line">// empty rows get all the same additional space</comment>
              <expr_stmt><expr><name>ratio</name> = 1.0f / <call><name>float</name><argument_list>(<argument><expr><name>eligibleRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
          }</block></then>
          <else>else <block>{
            <comment type="line">// all rows get the same additional space</comment>
            <expr_stmt><expr><name>ratio</name> = 1.0f / <call><name>float</name><argument_list>(<argument><expr><name>divisor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
          <comment type="line">// give rows their additional space, except for the last row which</comment>
          <comment type="line">// gets the remainder</comment>
          <decl_stmt><decl><type><name>nscoord</name></type> <name>amountForRow</name> <init>= <expr>(<name>rowFrame</name> == <name>lastEligibleRow</name>) 
                                 ? <name>aAmount</name> - <name>amountUsed</name> : <call><name>NSToCoordRound</name><argument_list>(<argument><expr>(<call>(<name>float</name>)<argument_list>(<argument><expr><name>heightToDistribute</name></expr></argument>)</argument_list></call>) * <name>ratio</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>amountForRow</name> = <call><name>PR_MIN</name><argument_list>(<argument><expr><name>amountForRow</name></expr></argument>, <argument><expr><name>aAmount</name> - <name>amountUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>yOriginRow</name> != <name><name>rowRect</name>.<name>y</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          
          <comment type="line">// update the row height</comment>
          <decl_stmt><decl><type><name>nsRect</name></type> <name>newRowRect</name><argument_list>(<argument><expr><name><name>rowRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name>yOriginRow</name></expr></argument>, <argument><expr><name><name>rowRect</name>.<name>width</name></name></expr></argument>,
                            <argument><expr><name><name>rowRect</name>.<name>height</name></name> + <name>amountForRow</name></expr></argument>)</argument_list></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>SetRect</name></name><argument_list>(<argument><expr><name>newRowRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>yOriginRow</name> += <name><name>newRowRect</name>.<name>height</name></name> + <name>cellSpacingY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>yEndRG</name> += <name><name>newRowRect</name>.<name>height</name></name> + <name>cellSpacingY</name></expr>;</expr_stmt>

          <expr_stmt><expr><name>amountUsed</name> += <name>amountForRow</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>amountUsedByRG</name> += <name>amountForRow</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>amountUsed</name> &lt;= <name>aAmount</name>)</expr></argument>, <argument><expr>"invalid row allocation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">//rowFrame-&gt;DidResize();        </comment>
          <expr_stmt><expr><call><name><name>nsTableFrame</name>::<name>RePositionViews</name></name><argument_list>(<argument><expr><name>rowFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name><name>nsTableFrame</name>::<name>InvalidateFrame</name></name><argument_list>(<argument><expr><name>rowFrame</name></expr></argument>, <argument><expr><name>rowRect</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <if>if <condition>(<expr><name>amountUsed</name> &gt; 0 &amp;&amp; <name>yOriginRow</name> != <name><name>rowRect</name>.<name>y</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>SetPosition</name></name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr><name><name>rowRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name>yOriginRow</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>nsTableFrame</name>::<name>RePositionViews</name></name><argument_list>(<argument><expr><name>rowFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>yOriginRow</name> += <name><name>rowRect</name>.<name>height</name></name> + <name>cellSpacingY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>yEndRG</name> += <name><name>rowRect</name>.<name>height</name></name> + <name>cellSpacingY</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>rowFrame</name> = <call><name><name>rowFrame</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <if>if <condition>(<expr><name>amountUsed</name> &gt; 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>rgRect</name>.<name>y</name></name> != <name>yOriginRG</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        
        <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>SetRect</name></name><argument_list>(<argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><name><name>rgRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name>yOriginRG</name></expr></argument>, <argument><expr><name><name>rgRect</name>.<name>width</name></name></expr></argument>,
                                <argument><expr><name><name>rgRect</name>.<name>height</name></name> + <name>amountUsedByRG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>nsTableFrame</name>::<name>InvalidateFrame</name></name><argument_list>(<argument><expr><name>rgFrame</name></expr></argument>, <argument><expr><name>rgRect</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <comment type="line">// Make sure child views are properly positioned</comment>
      <comment type="line">// XXX what happens if childFrame is a scroll frame and this gets skipped? see also below</comment>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>amountUsed</name> &gt; 0 &amp;&amp; <name>yOriginRG</name> != <call><name><name>rgFrame</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call>.<name>y</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>rgFrame</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call>.<name>x</name> == 0</expr></argument>, <argument><expr>"Unexpected position"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>SetPosition</name></name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>yOriginRG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Make sure child views are properly positioned</comment>
      <expr_stmt><expr><call><name><name>nsTableFrame</name>::<name>RePositionViews</name></name><argument_list>(<argument><expr><name>rgFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>rgFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <expr_stmt><expr><name>yOriginRG</name> = <name>yEndRG</name></expr>;</expr_stmt>
  }</block></for>

  <expr_stmt><expr><call><name>ResizeCells</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type> 
<name><name>nsTableFrame</name>::<name>IsPctHeight</name></name><parameter_list>(<param><decl><type><name>nsStyleContext</name>*</type> <name>aStyleContext</name></decl></param>)</parameter_list> 
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aStyleContext</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>result</name> = (<name>eStyleUnit_Percent</name> ==
              <call><name><name>aStyleContext</name>-&gt;<name>GetStylePosition</name></name><argument_list>()</argument_list></call>-&gt;<call><name><name>mHeight</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call>)</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type> <name><name>nsTableFrame</name>::<name>GetColumnWidth</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aColIndex</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTableFrame</name> *</type> <name>firstInFlow</name> <init>= <expr>(<name>nsTableFrame</name> *)<call><name>GetFirstInFlow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>firstInFlow</name></expr></argument>, <argument><expr>"illegal state -- no first in flow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>this</name> == <name>firstInFlow</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name>GetColFrame</name><argument_list>(<argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>colFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>result</name> = <call><name><name>colFrame</name>-&gt;<name>GetFinalWidth</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>result</name> = <call><name><name>firstInFlow</name>-&gt;<name>GetColumnWidth</name></name><argument_list>(<argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsTableFrame</name>::<name>SetColumnWidth</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aColIndex</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aWidth</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTableFrame</name>*</type> <name>firstInFlow</name> <init>= <expr>(<name>nsTableFrame</name> *)<call><name>GetFirstInFlow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>firstInFlow</name></expr></argument>, <argument><expr>"illegal state -- no first in flow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>this</name> == <name>firstInFlow</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name>GetColFrame</name><argument_list>(<argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>colFrame</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>colFrame</name>-&gt;<name>SetFinalWidth</name></name><argument_list>(<argument><expr><name>aWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"null col frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name><name>firstInFlow</name>-&gt;<name>SetColumnWidth</name></name><argument_list>(<argument><expr><name>aColIndex</name></expr></argument>, <argument><expr><name>aWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="line">// XXX: could cache this.  But be sure to check style changes if you do!</comment>
<function><type><name>nscoord</name></type> <name><name>nsTableFrame</name>::<name>GetCellSpacingX</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>GetStyleTableBorder</name><argument_list>()</argument_list></call>-&gt;<call><name><name>mBorderSpacingX</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eStyleUnit_Coord</name></expr></argument>,
               <argument><expr>"Not a coord value!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>GetStyleTableBorder</name><argument_list>()</argument_list></call>-&gt;<call><name><name>mBorderSpacingX</name>.<name>GetCoordValue</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// XXX: could cache this. But be sure to check style changes if you do!</comment>
<function><type><name>nscoord</name></type> <name><name>nsTableFrame</name>::<name>GetCellSpacingY</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>GetStyleTableBorder</name><argument_list>()</argument_list></call>-&gt;<call><name><name>mBorderSpacingY</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eStyleUnit_Coord</name></expr></argument>,
               <argument><expr>"Not a coord value!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>GetStyleTableBorder</name><argument_list>()</argument_list></call>-&gt;<call><name><name>mBorderSpacingY</name>.<name>GetCoordValue</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* virtual */</comment> <function><type><name>nscoord</name></type>
<name><name>nsTableFrame</name>::<name>GetBaseline</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>ascent</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RowGroupArray</name></type> <name>orderedRowGroups</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>orderedRowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>firstRow</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>rgIndex</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rgIndex</name> &lt; <call><name><name>orderedRowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgIndex</name>++</expr></incr>) <block>{
    <comment type="line">// XXXbz Do we really want to just let through the scrollable</comment>
    <comment type="line">// rowgroups and use their ascent?</comment>
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>orderedRowGroups</name><index>[<expr><name>rgIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>rgFrame</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>firstRow</name> = <call><name><name>rgFrame</name>-&gt;<name>GetFirstRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><name>ascent</name> = <call><name><name>rgFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call>.<name>y</name> + <call><name><name>firstRow</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call>.<name>y</name> + <call><name><name>firstRow</name>-&gt;<name>GetRowBaseline</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
  <if>if <condition>(<expr>!<name>firstRow</name></expr>)</condition><then>
    <expr_stmt><expr><name>ascent</name> = <call><name>GetRect</name><argument_list>()</argument_list></call>.<name>height</name></expr>;</expr_stmt></then></if>
  <return>return <expr><name>ascent</name></expr>;</return>
}</block></function>
<comment type="block">/* ----- global methods ----- */</comment>

<function><type><name>nsIFrame</name>*</type>
<name>NS_NewTableFrame</name><parameter_list>(<param><decl><type><name>nsIPresShell</name>*</type> <name>aPresShell</name></decl></param>, <param><decl><type><name>nsStyleContext</name>*</type> <name>aContext</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>new (<name>aPresShell</name>) <call><name>nsTableFrame</name><argument_list>(<argument><expr><name>aContext</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsTableFrame</name>*</type>
<name><name>nsTableFrame</name>::<name>GetTableFrame</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aSourceFrame</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aSourceFrame</name></expr>)</condition><then> <block>{
    <comment type="line">// "result" is the result of intermediate calls, not the result we return from this method</comment>
    <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>parentFrame</name> <init>= <expr><call><name><name>aSourceFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>parentFrame</name></expr>;</condition>
         <incr><expr><name>parentFrame</name> = <call><name><name>parentFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
      <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableFrame</name></name> == <call><name><name>parentFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>(<name>nsTableFrame</name>*)<name>parentFrame</name></expr>;</return>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
  <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"unable to find table parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> 
<name><name>nsTableFrame</name>::<name>IsAutoWidth</name></name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>aIsPctWidth</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleCoord</name>&amp;</type> <name>width</name> <init>= <expr><call><name>GetStylePosition</name><argument_list>()</argument_list></call>-&gt;<name>mWidth</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>aIsPctWidth</name></expr>)</condition><then> <block>{
    <comment type="line">// XXX The old code also made the return value true for 0%, but that</comment>
    <comment type="line">// seems silly.</comment>
    <expr_stmt><expr>*<name>aIsPctWidth</name> = <call><name><name>width</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eStyleUnit_Percent</name> &amp;&amp;
                   <call><name><name>width</name>.<name>GetPercentValue</name></name><argument_list>()</argument_list></call> &gt; 0.0f</expr>;</expr_stmt>
    <comment type="line">// Should this handle -moz-available and -moz-fit-content?</comment>
  }</block></then></if>
  <return>return <expr><call><name><name>width</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eStyleUnit_Auto</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> 
<name><name>nsTableFrame</name>::<name>IsAutoHeight</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isAuto</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>  <comment type="line">// the default</comment>

  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStylePosition</name>*</type> <name>position</name> <init>= <expr><call><name>GetStylePosition</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><call><name><name>position</name>-&gt;<name>mHeight</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
    <case>case <expr><name>eStyleUnit_Auto</name></expr>:         <comment type="line">// specified auto width</comment>
      <break>break;</break>
    </case><case>case <expr><name>eStyleUnit_Coord</name></expr>:
      <expr_stmt><expr><name>isAuto</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>eStyleUnit_Percent</name></expr>:
      <if>if <condition>(<expr><call><name><name>position</name>-&gt;<name>mHeight</name>.<name>GetPercentValue</name></name><argument_list>()</argument_list></call> &gt; 0.0f</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>isAuto</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    </case><default>default:
      <break>break;</break>
  </default>}</block></switch>

  <return>return <expr><name>isAuto</name></expr>;</return> 
}</block></function>

<function><type><name>nscoord</name></type> 
<name><name>nsTableFrame</name>::<name>CalcBorderBoxHeight</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aState</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>height</name> <init>= <expr><call><name><name>aState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>NS_AUTOHEIGHT</name> != <name>height</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsMargin</name></type> <name>borderPadding</name> <init>= <expr><call><name>GetContentAreaOffset</name><argument_list>(<argument><expr>&amp;<name>aState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>height</name> += <name><name>borderPadding</name>.<name>top</name></name> + <name><name>borderPadding</name>.<name>bottom</name></name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>height</name> = <call><name>PR_MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>height</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> 
<name><name>nsTableFrame</name>::<name>IsAutoLayout</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>GetStyleTable</name><argument_list>()</argument_list></call>-&gt;<name>mLayoutStrategy</name> == <name>NS_STYLE_TABLE_LAYOUT_AUTO</name></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
  <comment type="line">// a fixed-layout inline-table must have a width</comment>
  <comment type="line">// and tables with 'width: -moz-max-content' must be auto-layout</comment>
  <comment type="line">// (at least as long as FixedTableLayoutStrategy::GetPrefWidth returns</comment>
  <comment type="line">// nscoord_MAX)</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleCoord</name> &amp;</type><name>width</name> <init>= <expr><call><name>GetStylePosition</name><argument_list>()</argument_list></call>-&gt;<name>mWidth</name></expr></init></decl>;</decl_stmt>
  <return>return <expr>(<call><name><name>width</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eStyleUnit_Auto</name>) ||
         (<call><name><name>width</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eStyleUnit_Enumerated</name> &amp;&amp;
          <call><name><name>width</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call> == <name>NS_STYLE_WIDTH_MAX_CONTENT</name>)</expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>GetFrameName</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aResult</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><call><name>MakeFrameName</name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"Table"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Find the closet sibling before aPriorChildFrame (including aPriorChildFrame) that</comment>
<comment type="line">// is of type aChildType</comment>
<function><type><name>nsIFrame</name>*</type> 
<name><name>nsTableFrame</name>::<name>GetFrameAtOrBefore</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type>       <name>aParentFrame</name></decl></param>,
                                 <param><decl><type><name>nsIFrame</name>*</type>       <name>aPriorChildFrame</name></decl></param>,
                                 <param><decl><type><name>nsIAtom</name>*</type>        <name>aChildType</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>result</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>aPriorChildFrame</name></expr>)</condition><then> <block>{
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>aChildType</name> == <call><name><name>aPriorChildFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>aPriorChildFrame</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// aPriorChildFrame is not of type aChildType, so we need start from </comment>
  <comment type="line">// the beginnng and find the closest one </comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>lastMatchingFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>childFrame</name> <init>= <expr><call><name><name>aParentFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>childFrame</name> &amp;&amp; (<name>childFrame</name> != <name>aPriorChildFrame</name>)</expr>)</condition> <block>{
    <if>if <condition>(<expr><name>aChildType</name> == <call><name><name>childFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>lastMatchingFrame</name> = <name>childFrame</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>childFrame</name> = <call><name><name>childFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <return>return <expr><name>lastMatchingFrame</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><name>void</name></type> 
<name><name>nsTableFrame</name>::<name>DumpRowGroup</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aKidFrame</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><call><name>GetRowGroupFrame</name><argument_list>(<argument><expr><name>aKidFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>rgFrame</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rowFrame</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>rowFrame</name></expr>)</condition> <block>{
      <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableRowFrame</name></name> == <call><name><name>rowFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"row(%d)=%p "</expr></argument>, <argument><expr>((<name>nsTableRowFrame</name>*)<name>rowFrame</name>)-&gt;<call><name>GetRowIndex</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rowFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>cellFrame</name> <init>= <expr><call><name><name>rowFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>cellFrame</name></expr>)</condition> <block>{
          <if>if <condition>(<expr><call><name>IS_TABLE_CELL</name><argument_list>(<argument><expr><call><name><name>cellFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PRInt32</name></type> <name>colIndex</name></decl>;</decl_stmt>
            <expr_stmt><expr>((<name>nsTableCellFrame</name>*)<name>cellFrame</name>)-&gt;<call><name>GetColIndex</name><argument_list>(<argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"cell(%d)=%p "</expr></argument>, <argument><expr><name>colIndex</name></expr></argument>, <argument><expr><name>cellFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>cellFrame</name> = <call><name><name>cellFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>DumpRowGroup</name><argument_list>(<argument><expr><name>rowFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>rowFrame</name> = <call><name><name>rowFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> 
<name><name>nsTableFrame</name>::<name>Dump</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type>          <name>aDumpRows</name></decl></param>,
                   <param><decl><type><name>PRBool</name></type>          <name>aDumpCols</name></decl></param>, 
                   <param><decl><type><name>PRBool</name></type>          <name>aDumpCellMap</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"***START TABLE DUMP*** \n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// dump the columns widths array</comment>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"mColWidths="</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numCols</name> <init>= <expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colX</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>colX</name> = 0</expr>;</init> <condition><expr><name>colX</name> &lt; <name>numCols</name></expr>;</condition> <incr><expr><name>colX</name>++</expr></incr>) <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%d "</expr></argument>, <argument><expr><call><name>GetColumnWidth</name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>aDumpRows</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>kidFrame</name></expr>)</condition> <block>{
      <expr_stmt><expr><call><name>DumpRowGroup</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>kidFrame</name> = <call><name><name>kidFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>

  <if>if <condition>(<expr><name>aDumpCols</name></expr>)</condition><then> <block>{
	  <comment type="line">// output col frame cache</comment>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n col frame cache -&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	   <for>for (<init><expr><name>colX</name> = 0</expr>;</init> <condition><expr><name>colX</name> &lt; <name>numCols</name></expr>;</condition> <incr><expr><name>colX</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr>(<name>nsTableColFrame</name> *)<call><name><name>mColFrames</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>0 == (<name>colX</name> % 8)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr>"%d=%p "</expr></argument>, <argument><expr><name>colX</name></expr></argument>, <argument><expr><name>colFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsTableColType</name></type> <name>colType</name> <init>= <expr><call><name><name>colFrame</name>-&gt;<name>GetColType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <switch>switch <condition>(<expr><name>colType</name></expr>)</condition> <block>{
      <case>case <expr><name>eColContent</name></expr>:
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" content "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>eColAnonymousCol</name></expr>: 
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" anonymous-column "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>eColAnonymousColGroup</name></expr>:
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" anonymous-colgroup "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>eColAnonymousCell</name></expr>: 
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" anonymous-cell "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case>}</block></switch>
    }</block></for>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n colgroups-&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>childFrame</name> <init>= <expr><call><name><name>mColGroups</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>childFrame</name></expr>;</condition>
         <incr><expr><name>childFrame</name> = <call><name><name>childFrame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
      <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableColGroupFrame</name></name> == <call><name><name>childFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>colGroupFrame</name> <init>= <expr>(<name>nsTableColGroupFrame</name> *)<name>childFrame</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>colGroupFrame</name>-&gt;<name>Dump</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <for>for (<init><expr><name>colX</name> = 0</expr>;</init> <condition><expr><name>colX</name> &lt; <name>numCols</name></expr>;</condition> <incr><expr><name>colX</name>++</expr></incr>) <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name>GetColFrame</name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>colFrame</name>-&gt;<name>Dump</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
  <if>if <condition>(<expr><name>aDumpCellMap</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>Dump</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" ***END TABLE DUMP*** \n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// nsTableIterator</comment>
<constructor><name><name>nsTableIterator</name>::<name>nsTableIterator</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>&amp;</type> <name>aSource</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>firstChild</name> <init>= <expr><call><name><name>aSource</name>.<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>Init</name><argument_list>(<argument><expr><name>firstChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<constructor><name><name>nsTableIterator</name>::<name>nsTableIterator</name></name><parameter_list>(<param><decl><type><name>nsFrameList</name>&amp;</type> <name>aSource</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>firstChild</name> <init>= <expr><call><name><name>aSource</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>Init</name><argument_list>(<argument><expr><name>firstChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<function><type><name>void</name></type> <name><name>nsTableIterator</name>::<name>Init</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFirstChild</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mFirstListChild</name> = <name>aFirstChild</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mFirstChild</name>     = <name>aFirstChild</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mCurrentChild</name>   = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mLeftToRight</name>    = <name>PR_TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mCount</name>          = -1</expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>mFirstChild</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsTableFrame</name>*</type> <name>table</name> <init>= <expr><call><name><name>nsTableFrame</name>::<name>GetTableFrame</name></name><argument_list>(<argument><expr><name>mFirstChild</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>table</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mLeftToRight</name> = (<name>NS_STYLE_DIRECTION_LTR</name> ==
                    <call><name><name>table</name>-&gt;<name>GetStyleVisibility</name></name><argument_list>()</argument_list></call>-&gt;<name>mDirection</name>)</expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"source of table iterator is not part of a table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></else></if>

  <if>if <condition>(<expr>!<name>mLeftToRight</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCount</name> = 0</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>nextChild</name> <init>= <expr><call><name><name>mFirstChild</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>nsnull</name> != <name>nextChild</name></expr>)</condition> <block>{
      <expr_stmt><expr><name>mCount</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>mFirstChild</name> = <name>nextChild</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nextChild</name> = <call><name><name>nextChild</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  }</block></then></if> 
}</block></function>

<function><type><name>nsIFrame</name>*</type> <name><name>nsTableIterator</name>::<name>First</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mCurrentChild</name> = <name>mFirstChild</name></expr>;</expr_stmt>
  <return>return <expr><name>mCurrentChild</name></expr>;</return>
}</block></function>
      
<function><type><name>nsIFrame</name>*</type> <name><name>nsTableIterator</name>::<name>Next</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mCurrentChild</name></expr>)</condition><then> <block>{
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>mLeftToRight</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCurrentChild</name> = <call><name><name>mCurrentChild</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>mCurrentChild</name></expr>;</return>
  }</block></then>
  <else>else <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>targetChild</name> <init>= <expr><name>mCurrentChild</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mCurrentChild</name> = <name>nsnull</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>child</name> <init>= <expr><name>mFirstListChild</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>child</name> &amp;&amp; (<name>child</name> != <name>targetChild</name>)</expr>)</condition> <block>{
      <expr_stmt><expr><name>mCurrentChild</name> = <name>child</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>child</name> = <call><name><name>child</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>mCurrentChild</name></expr>;</return>
  }</block></else></if>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsTableIterator</name>::<name>IsLeftToRight</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><name>mLeftToRight</name></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type> <name><name>nsTableIterator</name>::<name>Count</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>-1 == <name>mCount</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCount</name> = 0</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>child</name> <init>= <expr><name>mFirstListChild</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>nsnull</name> != <name>child</name></expr>)</condition> <block>{
      <expr_stmt><expr><name>mCount</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>child</name> = <call><name><name>child</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>
  <return>return <expr><name>mCount</name></expr>;</return>
}</block></function>

<comment type="block">/*------------------ nsITableLayout methods ------------------------------*/</comment>
<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>nsTableFrame</name>::<name>GetCellDataAt</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type>        <name>aRowIndex</name></decl></param>, 
                            <param><decl><type><name>PRInt32</name></type>        <name>aColIndex</name></decl></param>,
                            <param><decl><type><name>nsIDOMElement</name>* &amp;</type><name>aCell</name></decl></param>,   <comment type="line">//out params</comment>
                            <param><decl><type><name>PRInt32</name>&amp;</type>       <name>aStartRowIndex</name></decl></param>, 
                            <param><decl><type><name>PRInt32</name>&amp;</type>       <name>aStartColIndex</name></decl></param>, 
                            <param><decl><type><name>PRInt32</name>&amp;</type>       <name>aRowSpan</name></decl></param>, 
                            <param><decl><type><name>PRInt32</name>&amp;</type>       <name>aColSpan</name></decl></param>,
                            <param><decl><type><name>PRInt32</name>&amp;</type>       <name>aActualRowSpan</name></decl></param>, 
                            <param><decl><type><name>PRInt32</name>&amp;</type>       <name>aActualColSpan</name></decl></param>,
                            <param><decl><type><name>PRBool</name>&amp;</type>        <name>aIsSelected</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Initialize out params</comment>
  <expr_stmt><expr><name>aCell</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aStartRowIndex</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>aStartColIndex</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>aRowSpan</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>aColSpan</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>aIsSelected</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>cellMap</name></expr>)</condition><then> <block>{ <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return>}</block></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>originates</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colSpan</name></decl>;</decl_stmt> <comment type="line">// Is this the "effective" or "html" value?</comment>

  <decl_stmt><decl><type><name>nsTableCellFrame</name> *</type><name>cellFrame</name> <init>= <expr><call><name><name>cellMap</name>-&gt;<name>GetCellInfoAt</name></name><argument_list>(<argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>aColIndex</name></expr></argument>, <argument><expr>&amp;<name>originates</name></expr></argument>, <argument><expr>&amp;<name>colSpan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>cellFrame</name></expr>)</condition><then> <return>return <expr><name>NS_TABLELAYOUT_CELL_NOT_FOUND</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name><init>= <expr><call><name><name>cellFrame</name>-&gt;<name>GetRowIndex</name></name><argument_list>(<argument><expr><name>aStartRowIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
  <expr_stmt><expr><name>result</name> = <call><name><name>cellFrame</name>-&gt;<name>GetColIndex</name></name><argument_list>(<argument><expr><name>aStartColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>
  <comment type="line">//This returns HTML value, which may be 0</comment>
  <expr_stmt><expr><name>aRowSpan</name> = <call><name><name>cellFrame</name>-&gt;<name>GetRowSpan</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aColSpan</name> = <call><name><name>cellFrame</name>-&gt;<name>GetColSpan</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aActualRowSpan</name> = <call><name>GetEffectiveRowSpan</name><argument_list>(<argument><expr>*<name>cellFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aActualColSpan</name> = <call><name>GetEffectiveColSpan</name><argument_list>(<argument><expr>*<name>cellFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// If these aren't at least 1, we have a cellmap error</comment>
  <if>if <condition>(<expr><name>aActualRowSpan</name> == 0 || <name>aActualColSpan</name> == 0</expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

  <expr_stmt><expr><name>result</name> = <call><name><name>cellFrame</name>-&gt;<name>GetSelected</name></name><argument_list>(<argument><expr>&amp;<name>aIsSelected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>result</name></expr>;</return></then></if>

  <comment type="line">// do this last, because it addrefs, </comment>
  <comment type="line">// and we don't want the caller leaking it on error</comment>
  <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>content</name> <init>= <expr><call><name><name>cellFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>content</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>   
  
  <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr>&amp;<name>aCell</name></expr></argument>)</argument_list></call></expr>;</return>                                      
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsTableFrame</name>::<name>GetTableSize</name></name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type> <name>aRowCount</name></decl></param>, <param><decl><type><name>PRInt32</name>&amp;</type> <name>aColCount</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// Initialize out params</comment>
  <expr_stmt><expr><name>aRowCount</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>aColCount</name> = 0</expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>cellMap</name></expr>)</condition><then> <block>{ <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return>}</block></then></if>

  <expr_stmt><expr><name>aRowCount</name> = <call><name><name>cellMap</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aColCount</name> = <call><name><name>cellMap</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>GetIndexByRowAndColumn</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aRow</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aColumn</name></decl></param>,
                                     <param><decl><type><name>PRInt32</name> *</type><name>aIndex</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aIndex</name> = -1</expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>cellMap</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return></then></if>

  <expr_stmt><expr>*<name>aIndex</name> = <call><name><name>cellMap</name>-&gt;<name>GetIndexByRowAndColumn</name></name><argument_list>(<argument><expr><name>aRow</name></expr></argument>, <argument><expr><name>aColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsTableFrame</name>::<name>GetRowAndColumnByIndex</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aIndex</name></decl></param>,
                                    <param><decl><type><name>PRInt32</name> *</type><name>aRow</name></decl></param>, <param><decl><type><name>PRInt32</name> *</type><name>aColumn</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aRow</name> = -1</expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aColumn</name> = -1</expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>cellMap</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_INITIALIZED</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name><name>cellMap</name>-&gt;<name>GetRowAndColumnByIndex</name></name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>, <argument><expr><name>aRow</name></expr></argument>, <argument><expr><name>aColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*---------------- end of nsITableLayout implementation ------------------*/</comment>

<function><type><name>PRInt32</name></type> <name><name>nsTableFrame</name>::<name>GetNumCellsOriginatingInCol</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aColIndex</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> 
    <return>return <expr><call><name><name>cellMap</name>-&gt;<name>GetNumCellsOriginatingInCol</name></name><argument_list>(<argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr>0</expr>;</return></else></if>
}</block></function>

<function><type><name>PRInt32</name></type> <name><name>nsTableFrame</name>::<name>GetNumCellsOriginatingInRow</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aRowIndex</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> 
    <return>return <expr><call><name><name>cellMap</name>-&gt;<name>GetNumCellsOriginatingInRow</name></name><argument_list>(<argument><expr><name>aRowIndex</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr>0</expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckFixDamageArea</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNumRows</name></decl></param>,
                   <param><decl><type><name>PRInt32</name></type> <name>aNumCols</name></decl></param>,
                   <param><decl><type><name>nsRect</name>&amp;</type> <name>aDamageArea</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>((<call><name><name>aDamageArea</name>.<name>XMost</name></name><argument_list>()</argument_list></call> &gt; <name>aNumCols</name>) &amp;&amp; (<name><name>aDamageArea</name>.<name>width</name></name>  != 1) &amp;&amp; (<name>aNumCols</name> != 0)) || 
      ((<call><name><name>aDamageArea</name>.<name>YMost</name></name><argument_list>()</argument_list></call> &gt; <name>aNumRows</name>) &amp;&amp; (<name><name>aDamageArea</name>.<name>height</name></name> != 1) &amp;&amp; (<name>aNumRows</name> != 0))</expr>)</condition><then> <block>{
    <comment type="line">// the damage area was set incorrectly, just be safe and make it the entire table</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"invalid BC damage area"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aDamageArea</name>.<name>x</name></name>      = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aDamageArea</name>.<name>y</name></name>      = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aDamageArea</name>.<name>width</name></name>  = <name>aNumCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aDamageArea</name>.<name>height</name></name> = <name>aNumRows</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block" format="doxygen">/********************************************************************************
 * Collapsing Borders
 *
 *  The CSS spec says to resolve border conflicts in this order:
 *  1) any border with the style HIDDEN wins
 *  2) the widest border with a style that is not NONE wins
 *  3) the border styles are ranked in this order, highest to lowest precedence: 
 *     double, solid, dashed, dotted, ridge, outset, groove, inset
 *  4) borders that are of equal width and style (differ only in color) have this precedence:
 *     cell, row, rowgroup, col, colgroup, table
 *  5) if all border styles are NONE, then that's the computed border style.
 *******************************************************************************/</comment>

<function><type><name>void</name></type> 
<name><name>nsTableFrame</name>::<name>SetBCDamageArea</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <function_decl><type><name>nsRect</name></type> <name>newRect</name><parameter_list>(<param><decl><type><name>aValue</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><name><name>newRect</name>.<name>width</name></name>  = <call><name>PR_MAX</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>newRect</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newRect</name>.<name>height</name></name> = <call><name>PR_MAX</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>newRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"invalid call - not border collapse model"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>SetNeedToCalcBCBorders</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Get the property </comment>
  <decl_stmt><decl><type><name>BCPropertyData</name>*</type> <name>value</name> <init>= <expr>(<name>BCPropertyData</name>*)<call><name><name>nsTableFrame</name>::<name>GetProperty</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>tableBCProperty</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{
    <comment type="line">// for now just construct a union of the new and old damage areas</comment>
    <expr_stmt><expr><call><name><name>value</name>-&gt;<name>mDamageArea</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name><name>value</name>-&gt;<name>mDamageArea</name></name></expr></argument>, <argument><expr><name>newRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CheckFixDamageArea</name><argument_list>(<argument><expr><call><name>GetRowCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>mDamageArea</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<comment type="block" format="doxygen">/*****************************************************************
 *  BCMapCellIterator
 ****************************************************************/</comment>
<struct>struct <name>BCMapCellInfo</name> 
<block>{<public type="default">
  <constructor_decl><name>BCMapCellInfo</name><parameter_list>()</parameter_list>;</constructor_decl>
  <function_decl><type><name>void</name></type> <name>Reset</name><parameter_list>()</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>CellData</name>*</type>             <name>cellData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCellMap</name>*</type>            <name>cellMap</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rg</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type>      <name>topRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type>      <name>bottomRow</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsTableColGroupFrame</name>*</type> <name>cg</name></decl>;</decl_stmt>
 
  <decl_stmt><decl><type><name>nsTableColFrame</name>*</type>      <name>leftCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableColFrame</name>*</type>      <name>rightCol</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsBCTableCellFrame</name>*</type>   <name>cell</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>rowIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>rowSpan</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>colIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>colSpan</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRPackedBool</name></type>          <name>rgTop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>          <name>rgBottom</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>          <name>cgLeft</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type>          <name>cgRight</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<constructor><name><name>BCMapCellInfo</name>::<name>BCMapCellInfo</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>Reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<function><type><name>void</name></type> <name><name>BCMapCellInfo</name>::<name>Reset</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>cellData</name>  = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rg</name>        = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>topRow</name>    = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>bottomRow</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cg</name>        = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>leftCol</name>   = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rightCol</name>  = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cell</name>      = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rowIndex</name> = <name>rowSpan</name> = <name>colIndex</name> = <name>colSpan</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>rgTop</name> = <name>rgBottom</name> = <name>cgLeft</name> = <name>cgRight</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
}</block></function>

<class>class <name>BCMapCellIterator</name>
<block>{<private type="default">
</private><public>public:
  <constructor_decl><name>BCMapCellIterator</name><parameter_list>(<param><decl><type><name>nsTableFrame</name>&amp;</type> <name>aTableFrame</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDamageArea</name></decl></param>)</parameter_list>;</constructor_decl>

  <function_decl><type><name>void</name></type> <name>First</name><parameter_list>(<param><decl><type><name>BCMapCellInfo</name>&amp;</type> <name>aMapCellInfo</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>void</name></type> <name>Next</name><parameter_list>(<param><decl><type><name>BCMapCellInfo</name>&amp;</type> <name>aMapCellInfo</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>void</name></type> <name>PeekRight</name><parameter_list>(<param><decl><type><name>BCMapCellInfo</name>&amp;</type> <name>aRefInfo</name></decl></param>,
                 <param><decl><type><name>PRUint32</name></type>     <name>aRowIndex</name></decl></param>,
                 <param><decl><type><name>BCMapCellInfo</name>&amp;</type> <name>aAjaInfo</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>void</name></type> <name>PeekBottom</name><parameter_list>(<param><decl><type><name>BCMapCellInfo</name>&amp;</type> <name>aRefInfo</name></decl></param>,
                  <param><decl><type><name>PRUint32</name></type>     <name>aColIndex</name></decl></param>,
                  <param><decl><type><name>BCMapCellInfo</name>&amp;</type> <name>aAjaInfo</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><name>PRBool</name></type> <name>IsNewRow</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mIsNewRow</name></expr>;</return> }</block></function>

  <function><type><name>nsTableRowFrame</name>*</type> <name>GetPrevRow</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><name>mPrevRow</name></expr>;</return> }</block></function>

  <decl_stmt><decl><type><name>PRInt32</name></type>    <name>mRowGroupStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>    <name>mRowGroupEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>     <name>mAtEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCellMap</name>*</type> <name>mCellMap</name></decl>;</decl_stmt>

</public><private>private:
  <function_decl><type><name>void</name></type> <name>SetInfo</name><parameter_list>(<param><decl><type><name>nsTableRowFrame</name>*</type> <name>aRow</name></decl></param>,
               <param><decl><type><name>PRInt32</name></type>          <name>aColIndex</name></decl></param>,
               <param><decl><type><name>CellData</name>*</type>        <name>aCellData</name></decl></param>,
               <param><decl><type><name>BCMapCellInfo</name>&amp;</type>   <name>aMapInfo</name></decl></param>,
               <param><decl><type><name>nsCellMap</name>*</type>       <name>aCellMap</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>PRBool</name></type> <name>SetNewRow</name><parameter_list>(<param><decl><type><name>nsTableRowFrame</name>*</type> <name>row</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>SetNewRowGroup</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aFindFirstDamagedRow</name></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>nsTableFrame</name>&amp;</type>         <name>mTableFrame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type>       <name>mTableCellMap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsTableFrame</name>::<name>RowGroupArray</name></name></type> <name>mRowGroups</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>mRowGroup</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>mRowGroupIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type>              <name>mNumRows</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type>      <name>mRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type>      <name>mPrevRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>                <name>mIsNewRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>mRowIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type>              <name>mNumCols</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>mColIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPoint</name></type>               <name>mAreaStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPoint</name></type>               <name>mAreaEnd</name></decl>;</decl_stmt>
</private>}</block>;</class>

<constructor><name><name>BCMapCellIterator</name>::<name>BCMapCellIterator</name></name><parameter_list>(<param><decl><type><name>nsTableFrame</name>&amp;</type> <name>aTableFrame</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDamageArea</name></decl></param>)</parameter_list>
<member_list>:<call><name>mTableFrame</name><argument_list>(<argument><expr><name>aTableFrame</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><name>mTableCellMap</name>  = <call><name><name>aTableFrame</name>.<name>GetCellMap</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>mAreaStart</name>.<name>x</name></name>   = <name><name>aDamageArea</name>.<name>x</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mAreaStart</name>.<name>y</name></name>   = <name><name>aDamageArea</name>.<name>y</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mAreaEnd</name>.<name>y</name></name>     = <name><name>aDamageArea</name>.<name>y</name></name> + <name><name>aDamageArea</name>.<name>height</name></name> - 1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mAreaEnd</name>.<name>x</name></name>     = <name><name>aDamageArea</name>.<name>x</name></name> + <name><name>aDamageArea</name>.<name>width</name></name> - 1</expr>;</expr_stmt>

  <expr_stmt><expr><name>mNumRows</name>       = <call><name><name>mTableFrame</name>.<name>GetRowCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mRow</name>           = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mRowIndex</name>      = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mNumCols</name>       = <call><name><name>mTableFrame</name>.<name>GetColCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mColIndex</name>      = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mRowGroupIndex</name> = -1</expr>;</expr_stmt>

  <comment type="line">// Get the ordered row groups </comment>
  <expr_stmt><expr><call><name><name>aTableFrame</name>.<name>OrderRowGroups</name></name><argument_list>(<argument><expr><name>mRowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mAtEnd</name> = <name>PR_TRUE</name></expr>;</expr_stmt> <comment type="line">// gets reset when First() is called</comment>
}</block></constructor>

<function><type><name>void</name></type> 
<name><name>BCMapCellIterator</name>::<name>SetInfo</name></name><parameter_list>(<param><decl><type><name>nsTableRowFrame</name>*</type> <name>aRow</name></decl></param>,
                           <param><decl><type><name>PRInt32</name></type>          <name>aColIndex</name></decl></param>,
                           <param><decl><type><name>CellData</name>*</type>        <name>aCellData</name></decl></param>,
                           <param><decl><type><name>BCMapCellInfo</name>&amp;</type>   <name>aCellInfo</name></decl></param>,
                           <param><decl><type><name>nsCellMap</name>*</type>       <name>aCellMap</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>cellData</name></name> = <name>aCellData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>cellMap</name></name> = (<name>aCellMap</name>) ? <name>aCellMap</name> : <name>mCellMap</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>colIndex</name></name> = <name>aColIndex</name></expr>;</expr_stmt>

  <comment type="line">// row frame info</comment>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>rowIndex</name></name> = 0</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aRow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>aCellInfo</name>.<name>topRow</name></name> = <name>aRow</name></expr>;</expr_stmt> 
    <expr_stmt><expr><name><name>aCellInfo</name>.<name>rowIndex</name></name> = <call><name><name>aRow</name>-&gt;<name>GetRowIndex</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// cell frame info</comment>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>cell</name></name>      = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>rowSpan</name></name>   = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>colSpan</name></name>  = 1</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aCellData</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>aCellInfo</name>.<name>cell</name></name> = (<name>nsBCTableCellFrame</name>*)<call><name><name>aCellData</name>-&gt;<name>GetCellFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
    <if>if <condition>(<expr><name><name>aCellInfo</name>.<name>cell</name></name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<name><name>aCellInfo</name>.<name>topRow</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>aCellInfo</name>.<name>topRow</name></name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTableRowFrame</name>*</expr></argument>&gt;</argument_list></name>
                                      <argument_list>(<argument><expr><call><name><name>aCellInfo</name>.<name>cell</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>aCellInfo</name>.<name>topRow</name></name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>aCellInfo</name>.<name>rowIndex</name></name> = <call><name><name>aCellInfo</name>.<name>topRow</name>-&gt;<name>GetRowIndex</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name><name>aCellInfo</name>.<name>colSpan</name></name> = <call><name><name>mTableFrame</name>.<name>GetEffectiveColSpan</name></name><argument_list>(<argument><expr>*<name><name>aCellInfo</name>.<name>cell</name></name></expr></argument>, <argument><expr><name>aCellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><name><name>aCellInfo</name>.<name>rowSpan</name></name> = <call><name><name>mTableFrame</name>.<name>GetEffectiveRowSpan</name></name><argument_list>(<argument><expr>*<name><name>aCellInfo</name>.<name>cell</name></name></expr></argument>, <argument><expr><name>aCellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>!<name><name>aCellInfo</name>.<name>topRow</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>aCellInfo</name>.<name>topRow</name></name> = <name>mRow</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr>1 == <name><name>aCellInfo</name>.<name>rowSpan</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>aCellInfo</name>.<name>bottomRow</name></name> = <name><name>aCellInfo</name>.<name>topRow</name></name></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name><name>aCellInfo</name>.<name>bottomRow</name></name> = <call><name><name>aCellInfo</name>.<name>topRow</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>aCellInfo</name>.<name>bottomRow</name></name></expr>)</condition><then> <block>{
      <for>for (<init><decl><type><name>PRInt32</name></type> <name>spanX</name> <init>= <expr>2</expr></init></decl>;</init> <condition><expr><name><name>aCellInfo</name>.<name>bottomRow</name></name> &amp;&amp; (<name>spanX</name> &lt; <name><name>aCellInfo</name>.<name>rowSpan</name></name>)</expr>;</condition> <incr><expr><name>spanX</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>aCellInfo</name>.<name>bottomRow</name></name> = <call><name><name>aCellInfo</name>.<name>bottomRow</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>aCellInfo</name>.<name>bottomRow</name></name></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"error in cell map"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aCellInfo</name>.<name>rowSpan</name></name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aCellInfo</name>.<name>bottomRow</name></name> = <name><name>aCellInfo</name>.<name>topRow</name></name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>

  <comment type="line">// row group frame info</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>rgStart</name>  <init>= <expr><name>mRowGroupStart</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>rgEnd</name>    <init>= <expr><name>mRowGroupEnd</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>rg</name></name> = <call><name><name>mTableFrame</name>.<name>GetRowGroupFrame</name></name><argument_list>(<argument><expr><call><name><name>aCellInfo</name>.<name>topRow</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>aCellInfo</name>.<name>rg</name></name> != <name>mRowGroup</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rgStart</name> = <call><name><name>aCellInfo</name>.<name>rg</name>-&gt;<name>GetStartRowIndex</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rgEnd</name>   = <name>rgStart</name> + <call><name><name>aCellInfo</name>.<name>rg</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call> - 1</expr>;</expr_stmt>
  }</block></then></if>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>rowIndex</name>  <init>= <expr><call><name><name>aCellInfo</name>.<name>topRow</name>-&gt;<name>GetRowIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>rgTop</name></name>    = (<name>rgStart</name> == <name>rowIndex</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>rgBottom</name></name> = (<name>rgEnd</name> == <name>rowIndex</name> + <name><name>aCellInfo</name>.<name>rowSpan</name></name> - 1)</expr>;</expr_stmt>

  <comment type="line">// col frame info</comment>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>leftCol</name></name> = <call><name><name>mTableFrame</name>.<name>GetColFrame</name></name><argument_list>(<argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr>!<name><name>aCellInfo</name>.<name>leftCol</name></name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name><name>aCellInfo</name>.<name>rightCol</name></name> = <name><name>aCellInfo</name>.<name>leftCol</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>aCellInfo</name>.<name>colSpan</name></name> &gt; 1</expr>)</condition><then> <block>{
    <for>for (<init><decl><type><name>PRInt32</name></type> <name>spanX</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>spanX</name> &lt; <name><name>aCellInfo</name>.<name>colSpan</name></name></expr>;</condition> <incr><expr><name>spanX</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name><name>mTableFrame</name>.<name>GetColFrame</name></name><argument_list>(<argument><expr><name>aColIndex</name> + <name>spanX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>colFrame</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name><name>aCellInfo</name>.<name>rightCol</name></name> = <name>colFrame</name></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>

  <comment type="line">// col group frame info</comment>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>cg</name></name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTableColGroupFrame</name>*</expr></argument>&gt;</argument_list></name>
                            <argument_list>(<argument><expr><call><name><name>aCellInfo</name>.<name>leftCol</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cgStart</name>  <init>= <expr><call><name><name>aCellInfo</name>.<name>cg</name>-&gt;<name>GetStartColumnIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cgEnd</name>    <init>= <expr><call><name>PR_MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>cgStart</name> + <call><name><name>aCellInfo</name>.<name>cg</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>cgLeft</name></name>  = (<name>cgStart</name> == <name>aColIndex</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aCellInfo</name>.<name>cgRight</name></name> = (<name>cgEnd</name> == <name>aColIndex</name> + (<name>PRInt32</name>)<name><name>aCellInfo</name>.<name>colSpan</name></name> - 1)</expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>BCMapCellIterator</name>::<name>SetNewRow</name></name><parameter_list>(<param><decl><type><name>nsTableRowFrame</name>*</type> <name>aRow</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mAtEnd</name>   = <name>PR_TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mPrevRow</name> = <name>mRow</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aRow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mRow</name> = <name>aRow</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>mRow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mRow</name> = <call><name><name>mRow</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <if>if <condition>(<expr><name>mRow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mRowIndex</name> = <call><name><name>mRow</name>-&gt;<name>GetRowIndex</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// get to the first entry with an originating cell</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>rgRowIndex</name> <init>= <expr><name>mRowIndex</name> - <name>mRowGroupStart</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>PRUint32</name><argument_list>(<argument><expr><name>rgRowIndex</name></expr></argument>)</argument_list></call> &gt;= <call><name><name>mCellMap</name>-&gt;<name>mRows</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> 
      <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>nsCellMap</name>::<name>CellDataArray</name></name>&amp;</type> <name>row</name> <init>= <expr><name><name>mCellMap</name>-&gt;<name>mRows</name><index>[<expr><name>rgRowIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>mColIndex</name> = <name><name>mAreaStart</name>.<name>x</name></name></expr>;</init> <condition><expr><name>mColIndex</name> &lt;= <name><name>mAreaEnd</name>.<name>x</name></name></expr>;</condition> <incr><expr><name>mColIndex</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>CellData</name>*</type> <name>cellData</name> <init>= <expr><call><name><name>row</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>mColIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>cellData</name></expr>)</condition><then> <block>{ <comment type="line">// add a dead cell data</comment>
        <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>cellData</name> = <call><name><name>mCellMap</name>-&gt;<name>AppendCell</name></name><argument_list>(<argument><expr>*<name>mTableCellMap</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>rgRowIndex</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr>!<name>cellData</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      }</block></then></if>
      <if>if <condition>(<expr><name>cellData</name> &amp;&amp; (<call><name><name>cellData</name>-&gt;<name>IsOrig</name></name><argument_list>()</argument_list></call> || <call><name><name>cellData</name>-&gt;<name>IsDead</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><name>mIsNewRow</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mAtEnd</name>    = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr>!<name>mAtEnd</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>BCMapCellIterator</name>::<name>SetNewRowGroup</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aFindFirstDamagedRow</name></decl></param>)</parameter_list>
<block>{
   <expr_stmt><expr><name>mAtEnd</name> = <name>PR_TRUE</name></expr>;</expr_stmt>  
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numRowGroups</name> <init>= <expr><call><name><name>mRowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>mCellMap</name> = <name>nsnull</name></expr>;</expr_stmt>
  <for>for (<init><expr><name>mRowGroupIndex</name>++</expr>;</init> <condition><expr><name>mRowGroupIndex</name> &lt; <name>numRowGroups</name></expr>;</condition> <incr><expr><name>mRowGroupIndex</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name>mRowGroup</name> = <name><name>mRowGroups</name><index>[<expr><name>mRowGroupIndex</name></expr>]</index></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowCount</name> <init>= <expr><call><name><name>mRowGroup</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mRowGroupStart</name> = <call><name><name>mRowGroup</name>-&gt;<name>GetStartRowIndex</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mRowGroupEnd</name>   = <name>mRowGroupStart</name> + <name>rowCount</name> - 1</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rowCount</name> &gt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mCellMap</name> = <call><name><name>mTableCellMap</name>-&gt;<name>GetMapFor</name></name><argument_list>(<argument><expr><name>mRowGroup</name></expr></argument>, <argument><expr><name>mCellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>mCellMap</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>firstRow</name> <init>= <expr><call><name><name>mRowGroup</name>-&gt;<name>GetFirstRow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>aFindFirstDamagedRow</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>(<name><name>mAreaStart</name>.<name>y</name></name> &gt;= <name>mRowGroupStart</name>) &amp;&amp; (<name><name>mAreaStart</name>.<name>y</name></name> &lt;= <name>mRowGroupEnd</name>)</expr>)</condition><then> <block>{
          <comment type="line">// the damage area starts in the row group </comment>
          <if>if <condition>(<expr><name>aFindFirstDamagedRow</name></expr>)</condition><then> <block>{
            <comment type="line">// find the correct first damaged row</comment>
            <decl_stmt><decl><type><name>PRInt32</name></type> <name>numRows</name> <init>= <expr><name><name>mAreaStart</name>.<name>y</name></name> - <name>mRowGroupStart</name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>numRows</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
              <expr_stmt><expr><name>firstRow</name> = <call><name><name>firstRow</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr>!<name>firstRow</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></for>
          }</block></then></if>
        }</block></then>
        <else>else <block>{     
          <continue>continue;</continue>
        }</block></else></if>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>SetNewRow</name><argument_list>(<argument><expr><name>firstRow</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// sets mAtEnd</comment>
        <break>break;</break>
      }</block></then></if>
    }</block></then></if>
  }</block></for>
    
  <return>return <expr>!<name>mAtEnd</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> 
<name><name>BCMapCellIterator</name>::<name>First</name></name><parameter_list>(<param><decl><type><name>BCMapCellInfo</name>&amp;</type> <name>aMapInfo</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aMapInfo</name>.<name>Reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SetNewRowGroup</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// sets mAtEnd</comment>
  <while>while <condition>(<expr>!<name>mAtEnd</name></expr>)</condition> <block>{
    <if>if <condition>(<expr>(<name><name>mAreaStart</name>.<name>y</name></name> &gt;= <name>mRowGroupStart</name>) &amp;&amp; (<name><name>mAreaStart</name>.<name>y</name></name> &lt;= <name>mRowGroupEnd</name>)</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>CellData</name>*</type> <name>cellData</name> <init>= <expr><call><name><name>mCellMap</name>-&gt;<name>GetDataAt</name></name><argument_list>(<argument><expr><name><name>mAreaStart</name>.<name>y</name></name> - <name>mRowGroupStart</name></expr></argument>,
                                               <argument><expr><name><name>mAreaStart</name>.<name>x</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>cellData</name> &amp;&amp; <call><name><name>cellData</name>-&gt;<name>IsOrig</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetInfo</name><argument_list>(<argument><expr><name>mRow</name></expr></argument>, <argument><expr><name><name>mAreaStart</name>.<name>x</name></name></expr></argument>, <argument><expr><name>cellData</name></expr></argument>, <argument><expr><name>aMapInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>((0 == <name><name>mAreaStart</name>.<name>x</name></name>) &amp;&amp; (<name>mRowGroupStart</name> == <name><name>mAreaStart</name>.<name>y</name></name>))</expr></argument> , <argument><expr>"damage area expanded incorrectly"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mAtEnd</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></else></if>
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><call><name>SetNewRowGroup</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// sets mAtEnd</comment>
  }</block></while> 
}</block></function>

<function><type><name>void</name></type> 
<name><name>BCMapCellIterator</name>::<name>Next</name></name><parameter_list>(<param><decl><type><name>BCMapCellInfo</name>&amp;</type> <name>aMapInfo</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mAtEnd</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name><name>aMapInfo</name>.<name>Reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mIsNewRow</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mColIndex</name>++</expr>;</expr_stmt>
  <while>while <condition>(<expr>(<name>mRowIndex</name> &lt;= <name><name>mAreaEnd</name>.<name>y</name></name>) &amp;&amp; !<name>mAtEnd</name></expr>)</condition> <block>{
    <for>for (<init>;</init> <condition><expr><name>mColIndex</name> &lt;= <name><name>mAreaEnd</name>.<name>x</name></name></expr>;</condition> <incr><expr><name>mColIndex</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>rgRowIndex</name> <init>= <expr><name>mRowIndex</name> - <name>mRowGroupStart</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CellData</name>*</type> <name>cellData</name> <init>= <expr><call><name><name>mCellMap</name>-&gt;<name>GetDataAt</name></name><argument_list>(<argument><expr><name>rgRowIndex</name></expr></argument>, <argument><expr><name>mColIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>cellData</name></expr>)</condition><then> <block>{ <comment type="line">// add a dead cell data</comment>
        <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>cellData</name> = <call><name><name>mCellMap</name>-&gt;<name>AppendCell</name></name><argument_list>(<argument><expr>*<name>mTableCellMap</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>rgRowIndex</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr>!<name>cellData</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      }</block></then></if>
      <if>if <condition>(<expr><name>cellData</name> &amp;&amp; (<call><name><name>cellData</name>-&gt;<name>IsOrig</name></name><argument_list>()</argument_list></call> || <call><name><name>cellData</name>-&gt;<name>IsDead</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetInfo</name><argument_list>(<argument><expr><name>mRow</name></expr></argument>, <argument><expr><name>mColIndex</name></expr></argument>, <argument><expr><name>cellData</name></expr></argument>, <argument><expr><name>aMapInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      }</block></then></if>
    }</block></for>
    <if>if <condition>(<expr><name>mRowIndex</name> &gt;= <name>mRowGroupEnd</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SetNewRowGroup</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// could set mAtEnd</comment>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>SetNewRow</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// could set mAtEnd</comment>
    }</block></else></if>
  }</block></while>
  <expr_stmt><expr><name>mAtEnd</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> 
<name><name>BCMapCellIterator</name>::<name>PeekRight</name></name><parameter_list>(<param><decl><type><name>BCMapCellInfo</name>&amp;</type>   <name>aRefInfo</name></decl></param>,
                             <param><decl><type><name>PRUint32</name></type>         <name>aRowIndex</name></decl></param>,
                             <param><decl><type><name>BCMapCellInfo</name>&amp;</type>   <name>aAjaInfo</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aAjaInfo</name>.<name>Reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colIndex</name> <init>= <expr><name><name>aRefInfo</name>.<name>colIndex</name></name> + <name><name>aRefInfo</name>.<name>colSpan</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>rgRowIndex</name> <init>= <expr><name>aRowIndex</name> - <name>mRowGroupStart</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>CellData</name>*</type> <name>cellData</name> <init>= <expr><call><name><name>mCellMap</name>-&gt;<name>GetDataAt</name></name><argument_list>(<argument><expr><name>rgRowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>cellData</name></expr>)</condition><then> <block>{ <comment type="line">// add a dead cell data</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>colIndex</name> &lt; <call><name><name>mTableCellMap</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>cellData</name> = <call><name><name>mCellMap</name>-&gt;<name>AppendCell</name></name><argument_list>(<argument><expr>*<name>mTableCellMap</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>rgRowIndex</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr>!<name>cellData</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>row</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>cellData</name>-&gt;<name>IsRowSpan</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rgRowIndex</name> -= <call><name><name>cellData</name>-&gt;<name>GetRowSpanOffset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cellData</name> = <call><name><name>mCellMap</name>-&gt;<name>GetDataAt</name></name><argument_list>(<argument><expr><name>rgRowIndex</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>cellData</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>row</name> = <name>mRow</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>SetInfo</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>colIndex</name></expr></argument>, <argument><expr><name>cellData</name></expr></argument>, <argument><expr><name>aAjaInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> 
<name><name>BCMapCellIterator</name>::<name>PeekBottom</name></name><parameter_list>(<param><decl><type><name>BCMapCellInfo</name>&amp;</type>   <name>aRefInfo</name></decl></param>,
                              <param><decl><type><name>PRUint32</name></type>         <name>aColIndex</name></decl></param>,
                              <param><decl><type><name>BCMapCellInfo</name>&amp;</type>   <name>aAjaInfo</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aAjaInfo</name>.<name>Reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowIndex</name> <init>= <expr><name><name>aRefInfo</name>.<name>rowIndex</name></name> + <name><name>aRefInfo</name>.<name>rowSpan</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rgRowIndex</name> <init>= <expr><name>rowIndex</name> - <name>mRowGroupStart</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rg</name> <init>= <expr><name>mRowGroup</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCellMap</name>*</type> <name>cellMap</name> <init>= <expr><name>mCellMap</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>nextRow</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>rowIndex</name> &gt; <name>mRowGroupEnd</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>nextRgIndex</name> <init>= <expr><name>mRowGroupIndex</name></expr></init></decl>;</decl_stmt>
    <do>do <block>{
      <expr_stmt><expr><name>nextRgIndex</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>rg</name> = <call><name><name>mRowGroups</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>nextRgIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>rg</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>cellMap</name> = <call><name><name>mTableCellMap</name>-&gt;<name>GetMapFor</name></name><argument_list>(<argument><expr><name>rg</name></expr></argument>, <argument><expr><name>cellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr>!<name>cellMap</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>rgRowIndex</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>nextRow</name> = <call><name><name>rg</name>-&gt;<name>GetFirstRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block>
    while <condition>(<expr><name>rg</name> &amp;&amp; !<name>nextRow</name></expr>)</condition>;</do>
    <if>if<condition>(<expr>!<name>rg</name></expr>)</condition><then> <return>return;</return></then></if>
  }</block></then>
  <else>else <block>{
    <comment type="line">// get the row within the same row group</comment>
    <expr_stmt><expr><name>nextRow</name> = <name>mRow</name></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>aRefInfo</name>.<name>rowSpan</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name>nextRow</name> = <call><name><name>nextRow</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr>!<name>nextRow</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
  }</block></else></if>

  <decl_stmt><decl><type><name>CellData</name>*</type> <name>cellData</name> <init>= <expr><call><name><name>cellMap</name>-&gt;<name>GetDataAt</name></name><argument_list>(<argument><expr><name>rgRowIndex</name></expr></argument>, <argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>cellData</name></expr>)</condition><then> <block>{ <comment type="line">// add a dead cell data</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>rgRowIndex</name> &lt; <call><name><name>cellMap</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>cellData</name> = <call><name><name>cellMap</name>-&gt;<name>AppendCell</name></name><argument_list>(<argument><expr>*<name>mTableCellMap</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>rgRowIndex</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr>!<name>cellData</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>
  <if>if <condition>(<expr><call><name><name>cellData</name>-&gt;<name>IsColSpan</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aColIndex</name> -= <call><name><name>cellData</name>-&gt;<name>GetColSpanOffset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cellData</name> = <call><name><name>cellMap</name>-&gt;<name>GetDataAt</name></name><argument_list>(<argument><expr><name>rgRowIndex</name></expr></argument>, <argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>SetInfo</name><argument_list>(<argument><expr><name>nextRow</name></expr></argument>, <argument><expr><name>aColIndex</name></expr></argument>, <argument><expr><name>cellData</name></expr></argument>, <argument><expr><name>aAjaInfo</name></expr></argument>, <argument><expr><name>cellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Assign priorities to border styles. For example, styleToPriority(NS_STYLE_BORDER_STYLE_SOLID)</comment>
<comment type="line">// will return the priority of NS_STYLE_BORDER_STYLE_SOLID. </comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PRUint8</name></type> <name><name>styleToPriority</name><index>[<expr>13</expr>]</index></name> <init>= <expr><block>{ <expr>0</expr>,  <comment type="line">// NS_STYLE_BORDER_STYLE_NONE</comment>
                                       <expr>2</expr>,  <comment type="line">// NS_STYLE_BORDER_STYLE_GROOVE</comment>
                                       <expr>4</expr>,  <comment type="line">// NS_STYLE_BORDER_STYLE_RIDGE</comment>
                                       <expr>5</expr>,  <comment type="line">// NS_STYLE_BORDER_STYLE_DOTTED</comment>
                                       <expr>6</expr>,  <comment type="line">// NS_STYLE_BORDER_STYLE_DASHED</comment>
                                       <expr>7</expr>,  <comment type="line">// NS_STYLE_BORDER_STYLE_SOLID</comment>
                                       <expr>8</expr>,  <comment type="line">// NS_STYLE_BORDER_STYLE_DOUBLE</comment>
                                       <expr>1</expr>,  <comment type="line">// NS_STYLE_BORDER_STYLE_INSET</comment>
                                       <expr>3</expr>,  <comment type="line">// NS_STYLE_BORDER_STYLE_OUTSET</comment>
                                       <expr>9</expr> }</block></expr></init></decl>;</decl_stmt><comment type="line">// NS_STYLE_BORDER_STYLE_HIDDEN</comment>
<comment type="line">// priority rules follow CSS 2.1 spec</comment>
<comment type="line">// 'hidden', 'double', 'solid', 'dashed', 'dotted', 'ridge', 'outset', 'groove',</comment>
<comment type="line">// and the lowest: 'inset'. none is even weaker</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CELL_CORNER</name></cpp:macro> <cpp:value>PR_TRUE</cpp:value></cpp:define>

<comment type="block" format="doxygen">/** return the border style, border color for a given frame and side
  * @param aFrame           - query the info for this frame 
  * @param aSide            - the side of the frame
  * @param aStyle           - the border style
  * @param aColor           - the border color
  * @param aTableIsLTR      - table direction is LTR
  * @param aIgnoreTableEdge - if is a table edge any borders set for the purpose
  *                           of satisfying the rules attribute should be ignored
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> 
<name>GetColorAndStyle</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type>  <name>aFrame</name></decl></param>,
                 <param><decl><type><name>PRUint8</name></type>          <name>aSide</name></decl></param>,
                 <param><decl><type><name>PRUint8</name>&amp;</type>         <name>aStyle</name></decl></param>,
                 <param><decl><type><name>nscolor</name>&amp;</type>         <name>aColor</name></decl></param>,
                 <param><decl><type><name>PRBool</name></type>           <name>aTableIsLTR</name></decl></param>,
                 <param><decl><type><name>PRBool</name></type>           <name>aIgnoreTableEdge</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>"null frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// initialize out arg</comment>
  <expr_stmt><expr><name>aColor</name> = 0</expr>;</expr_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleBorder</name>*</type> <name>styleData</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetStyleBorder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>(<expr>!<name>aTableIsLTR</name></expr>)</condition><then> <block>{ <comment type="line">// revert the directions</comment>
    <if>if <condition>(<expr><name>NS_SIDE_RIGHT</name> == <name>aSide</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aSide</name> = <name>NS_SIDE_LEFT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>NS_SIDE_LEFT</name> == <name>aSide</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aSide</name> = <name>NS_SIDE_RIGHT</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></then></if>
  <expr_stmt><expr><name>aStyle</name> = <call><name><name>styleData</name>-&gt;<name>GetBorderStyle</name></name><argument_list>(<argument><expr><name>aSide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// if the rules marker is set, set the style either to none or remove the mask</comment>
  <if>if <condition>(<expr><name>NS_STYLE_BORDER_STYLE_RULES_MARKER</name> &amp; <name>aStyle</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>aIgnoreTableEdge</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aStyle</name> = <name>NS_STYLE_BORDER_STYLE_NONE</name></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>aStyle</name> &amp;= ~<name>NS_STYLE_BORDER_STYLE_RULES_MARKER</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <if>if <condition>(<expr>(<name>NS_STYLE_BORDER_STYLE_NONE</name> == <name>aStyle</name>) ||
      (<name>NS_STYLE_BORDER_STYLE_HIDDEN</name> == <name>aStyle</name>)</expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>transparent</name></decl>, <decl><type ref="prev"/><name>foreground</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>styleData</name>-&gt;<name>GetBorderColor</name></name><argument_list>(<argument><expr><name>aSide</name></expr></argument>, <argument><expr><name>aColor</name></expr></argument>, <argument><expr><name>transparent</name></expr></argument>, <argument><expr><name>foreground</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>transparent</name></expr>)</condition><then> <block>{ 
    <expr_stmt><expr><name>aColor</name> = 0</expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>foreground</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aColor</name> = <call><name><name>aFrame</name>-&gt;<name>GetStyleColor</name></name><argument_list>()</argument_list></call>-&gt;<name>mColor</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
}</block></function>

<comment type="block" format="doxygen">/** coerce the paint style as required by CSS2.1
  * @param aFrame           - query the info for this frame 
  * @param aSide            - the side of the frame
  * @param aStyle           - the border style
  * @param aColor           - the border color
  * @param aTableIsLTR      - table direction is LTR
  * @param aIgnoreTableEdge - if is a table edge any borders set for the purpose
  *                           of satisfying the rules attribute should be ignored
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetPaintStyleInfo</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type>  <name>aFrame</name></decl></param>,
                  <param><decl><type><name>PRUint8</name></type>          <name>aSide</name></decl></param>,
                  <param><decl><type><name>PRUint8</name>&amp;</type>         <name>aStyle</name></decl></param>,
                  <param><decl><type><name>nscolor</name>&amp;</type>         <name>aColor</name></decl></param>,
                  <param><decl><type><name>PRBool</name></type>           <name>aTableIsLTR</name></decl></param>,
                  <param><decl><type><name>PRBool</name></type>           <name>aIgnoreTableEdge</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>GetColorAndStyle</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aSide</name></expr></argument>, <argument><expr><name>aStyle</name></expr></argument>, <argument><expr><name>aColor</name></expr></argument>, <argument><expr><name>aTableIsLTR</name></expr></argument>, <argument><expr><name>aIgnoreTableEdge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>NS_STYLE_BORDER_STYLE_INSET</name>    == <name>aStyle</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aStyle</name> = <name>NS_STYLE_BORDER_STYLE_RIDGE</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>NS_STYLE_BORDER_STYLE_OUTSET</name>    == <name>aStyle</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aStyle</name> = <name>NS_STYLE_BORDER_STYLE_GROOVE</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
}</block></function>

<comment type="block" format="doxygen">/** return the border style, border color and the width in pixel for a given
  * frame and side
  * @param aFrame           - query the info for this frame 
  * @param aSide            - the side of the frame
  * @param aStyle           - the border style
  * @param aColor           - the border color
  * @param aTableIsLTR      - table direction is LTR
  * @param aIgnoreTableEdge - if is a table edge any borders set for the purpose
  *                           of satisfying the rules attribute should be ignored
  * @param aWidth           - the border width in px.
  * @param aTwipsToPixels   - conversion factor from twips to pixel
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetColorAndStyle</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type>  <name>aFrame</name></decl></param>,
                 <param><decl><type><name>PRUint8</name></type>          <name>aSide</name></decl></param>,
                 <param><decl><type><name>PRUint8</name>&amp;</type>         <name>aStyle</name></decl></param>,
                 <param><decl><type><name>nscolor</name>&amp;</type>         <name>aColor</name></decl></param>,
                 <param><decl><type><name>PRBool</name></type>           <name>aTableIsLTR</name></decl></param>,
                 <param><decl><type><name>PRBool</name></type>           <name>aIgnoreTableEdge</name></decl></param>,
                 <param><decl><type><name>nscoord</name>&amp;</type>         <name>aWidth</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>GetColorAndStyle</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aSide</name></expr></argument>, <argument><expr><name>aStyle</name></expr></argument>, <argument><expr><name>aColor</name></expr></argument>, <argument><expr><name>aTableIsLTR</name></expr></argument>, <argument><expr><name>aIgnoreTableEdge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name>NS_STYLE_BORDER_STYLE_NONE</name> == <name>aStyle</name>) ||
      (<name>NS_STYLE_BORDER_STYLE_HIDDEN</name> == <name>aStyle</name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aWidth</name> = 0</expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleBorder</name>*</type> <name>styleData</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetStyleBorder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>width</name></decl>;</decl_stmt>
  <if>if<condition>(<expr>!<name>aTableIsLTR</name></expr>)</condition><then> <block>{ <comment type="line">// revert the directions</comment>
    <if>if <condition>(<expr><name>NS_SIDE_RIGHT</name> == <name>aSide</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aSide</name> = <name>NS_SIDE_LEFT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>NS_SIDE_LEFT</name> == <name>aSide</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aSide</name> = <name>NS_SIDE_RIGHT</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></then></if>
  <expr_stmt><expr><name>width</name> = <call><name><name>styleData</name>-&gt;<name>GetBorderWidth</name></name><argument_list>(<argument><expr><name>aSide</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aWidth</name> = <call><name><name>nsPresContext</name>::<name>AppUnitsToIntCSSPixels</name></name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
 
 
<comment type="block">/* BCCellBorder represents a border segment which can be either a horizontal
 * or a vertical segment. For each segment we need to know the color, width,
 * style, who owns it and how long it is in cellmap coordinates.
 * Ownership of these segments is  important to calculate which corners should
 * be bevelled. This structure has dual use, its used first to compute the
 * dominant border for horizontal and vertical segments and to store the
 * preliminary computed border results in the BCCellBorders structure.
 * This temporary storage is not symmetric with respect to horizontal and
 * vertical border segments, its always column oriented. For each column in
 * the cellmap there is a temporary stored vertical and horizontal segment.
 * XXX_Bernd this asymmetry is the root of those rowspan bc border errors
 */</comment>
<struct>struct <name>BCCellBorder</name>
<block>{<public type="default">
  <constructor><name>BCCellBorder</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><call><name>Reset</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></constructor>
  <function_decl><type><name>void</name></type> <name>Reset</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aRowIndex</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aRowSpan</name></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>nscolor</name></type>       <name>color</name></decl>;</decl_stmt>    <comment type="line">// border segment color</comment>
  <decl_stmt><decl><type><name>nscoord</name></type>       <name>width</name></decl>;</decl_stmt>    <comment type="line">// border segment width in pixel coordinates !!</comment>
  <decl_stmt><decl><type><name>PRUint8</name></type>       <name>style</name></decl>;</decl_stmt>    <comment type="line">// border segment style, possible values are defined</comment>
                          <comment type="line">// in nsStyleConsts.h as NS_STYLE_BORDER_STYLE_*</comment>
  <decl_stmt><decl><type><name>BCBorderOwner</name></type> <name>owner</name></decl>;</decl_stmt>    <comment type="line">// border segment owner, possible values are defined</comment>
                          <comment type="line">// in celldata.h. In the cellmap for each border</comment>
                          <comment type="line">// segment we store the owner and later when</comment>
                          <comment type="line">// painting we know the owner and can retrieve the</comment>
                          <comment type="line">// style info from the corresponding frame</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type>       <name>rowIndex</name></decl>;</decl_stmt> <comment type="line">// rowIndex of temporary stored horizontal border segments</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type>       <name>rowSpan</name></decl>;</decl_stmt>  <comment type="line">// row span of temporary stored horizontal border segments</comment>
</public>}</block>;</struct>

<function><type><name>void</name></type>
<name><name>BCCellBorder</name>::<name>Reset</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aRowIndex</name></decl></param>,
                    <param><decl><type><name>PRUint32</name></type> <name>aRowSpan</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>style</name> = <name>NS_STYLE_BORDER_STYLE_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>color</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>width</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>owner</name> = <name>eTableOwner</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rowIndex</name> = <name>aRowIndex</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rowSpan</name>  = <name>aRowSpan</name></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Compare two border segments, this comparison depends whether the two</comment>
<comment type="line">// segments meet at a corner and whether the second segment is horizontal.</comment>
<comment type="line">// The return value is whichever of aBorder1 or aBorder2 dominates.</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>BCCellBorder</name>&amp;</type>
<name>CompareBorders</name><parameter_list>(<param><decl><type><name>PRBool</name></type>              <name>aIsCorner</name></decl></param>, <comment type="line">// Pass PR_TRUE for corner calculations</comment>
               <param><decl><type><specifier>const</specifier> <name>BCCellBorder</name>&amp;</type> <name>aBorder1</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>BCCellBorder</name>&amp;</type> <name>aBorder2</name></decl></param>,
               <param><decl><type><name>PRBool</name></type>              <name>aSecondIsHorizontal</name></decl></param>,
               <param><decl><type><name>PRBool</name>*</type>             <name>aFirstDominates</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>firstDominates</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
  
  <if>if <condition>(<expr><name>NS_STYLE_BORDER_STYLE_HIDDEN</name> == <name><name>aBorder1</name>.<name>style</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>firstDominates</name> = (<name>aIsCorner</name>) ? <name>PR_FALSE</name> : <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>NS_STYLE_BORDER_STYLE_HIDDEN</name> == <name><name>aBorder2</name>.<name>style</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>firstDominates</name> = (<name>aIsCorner</name>) ? <name>PR_TRUE</name> : <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name><name>aBorder1</name>.<name>width</name></name> &lt; <name><name>aBorder2</name>.<name>width</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>firstDominates</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name><name>aBorder1</name>.<name>width</name></name> == <name><name>aBorder2</name>.<name>width</name></name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name><name>styleToPriority</name><index>[<expr><name><name>aBorder1</name>.<name>style</name></name></expr>]</index></name> &lt; <name><name>styleToPriority</name><index>[<expr><name><name>aBorder2</name>.<name>style</name></name></expr>]</index></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>firstDominates</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>styleToPriority</name><index>[<expr><name><name>aBorder1</name>.<name>style</name></name></expr>]</index></name> == <name><name>styleToPriority</name><index>[<expr><name><name>aBorder2</name>.<name>style</name></name></expr>]</index></name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name><name>aBorder1</name>.<name>owner</name></name> == <name><name>aBorder2</name>.<name>owner</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>firstDominates</name> = !<name>aSecondIsHorizontal</name></expr>;</expr_stmt>
      }</block></then>
      <else>else <if>if <condition>(<expr><name><name>aBorder1</name>.<name>owner</name></name> &lt; <name><name>aBorder2</name>.<name>owner</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>firstDominates</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      }</block></then></if></else></if>
    }</block></then></if></else></if>
  }</block></then></if></else></if></else></if></else></if>

  <if>if <condition>(<expr><name>aFirstDominates</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>aFirstDominates</name> = <name>firstDominates</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>firstDominates</name></expr>)</condition><then>
    <return>return <expr><name>aBorder1</name></expr>;</return></then></if>
  <return>return <expr><name>aBorder2</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/** calc the dominant border by considering the table, row/col group, row/col,
  * cell. At the table edges borders coming from the 'rules' attribute should
  * be ignored as they are only inner borders.
  * Depending on whether the side is vertical or horizontal and whether
  * adjacent frames are taken into account the ownership of a single border
  * segment is defined. The return value is the dominating border
  * The cellmap stores only top and left borders for each cellmap position.
  * If the cell border is owned by the cell that is left of the border
  * it will be an adjacent owner aka eAjaCellOwner. See celldata.h for the other
  * scenarios with a adjacent owner.
  * @param xxxFrame         - the frame for style information, might be zero if
  *                           it should not be considered
  * @param aIgnoreTableEdge - if true the border should be ignored at the table
  *                           edge, as rules can be drawn only inside the table
  * @param aSide            - side of the frames that should be considered
  * @param aAja             - the border comparison takes place from the point of
  *                           a frame that is adjacent to the cellmap entry, for
  *                           when a cell owns its lower border it will be the
  *                           adjacent owner as in the cellmap only top and left
  *                           borders are stored. 
  * @param aTwipsToPixels   - conversion factor as borders need to be drawn pixel
  *                           aligned.
  */</comment>
<function><type><specifier>static</specifier> <name>BCCellBorder</name></type>
<name>CompareBorders</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type>  <name>aTableFrame</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type>  <name>aColGroupFrame</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type>  <name>aColFrame</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type>  <name>aRowGroupFrame</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type>  <name>aRowFrame</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type>  <name>aCellFrame</name></decl></param>,
               <param><decl><type><name>PRBool</name></type>           <name>aTableIsLTR</name></decl></param>,
               <param><decl><type><name>PRBool</name></type>           <name>aIgnoreTableEdge</name></decl></param>,
               <param><decl><type><name>PRUint8</name></type>          <name>aSide</name></decl></param>,
               <param><decl><type><name>PRBool</name></type>           <name>aAja</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>BCCellBorder</name></type> <name>border</name></decl>, <decl><type ref="prev"/><name>tempBorder</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>horizontal</name> <init>= <expr>(<name>NS_SIDE_TOP</name> == <name>aSide</name>) || (<name>NS_SIDE_BOTTOM</name> == <name>aSide</name>)</expr></init></decl>;</decl_stmt>

  <comment type="line">// start with the table as dominant if present</comment>
  <if>if <condition>(<expr><name>aTableFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>GetColorAndStyle</name><argument_list>(<argument><expr><name>aTableFrame</name></expr></argument>, <argument><expr><name>aSide</name></expr></argument>, <argument><expr><name><name>border</name>.<name>style</name></name></expr></argument>, <argument><expr><name><name>border</name>.<name>color</name></name></expr></argument>, <argument><expr><name>aTableIsLTR</name></expr></argument>, <argument><expr><name>aIgnoreTableEdge</name></expr></argument>, <argument><expr><name><name>border</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>border</name>.<name>owner</name></name> = <name>eTableOwner</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>NS_STYLE_BORDER_STYLE_HIDDEN</name> == <name><name>border</name>.<name>style</name></name></expr>)</condition><then> <block>{
      <return>return <expr><name>border</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <comment type="line">// see if the colgroup is dominant</comment>
  <if>if <condition>(<expr><name>aColGroupFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>GetColorAndStyle</name><argument_list>(<argument><expr><name>aColGroupFrame</name></expr></argument>, <argument><expr><name>aSide</name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>style</name></name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>color</name></name></expr></argument>, <argument><expr><name>aTableIsLTR</name></expr></argument>, <argument><expr><name>aIgnoreTableEdge</name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tempBorder</name>.<name>owner</name></name> = (<name>aAja</name> &amp;&amp; !<name>horizontal</name>) ? <name>eAjaColGroupOwner</name> : <name>eColGroupOwner</name></expr>;</expr_stmt>
    <comment type="line">// pass here and below PR_FALSE for aSecondIsHorizontal as it is only used for corner calculations.</comment>
    <expr_stmt><expr><name>border</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr>!<name>CELL_CORNER</name></expr></argument>, <argument><expr><name>border</name></expr></argument>, <argument><expr><name>tempBorder</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>NS_STYLE_BORDER_STYLE_HIDDEN</name> == <name><name>border</name>.<name>style</name></name></expr>)</condition><then> <block>{
      <return>return <expr><name>border</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <comment type="line">// see if the col is dominant</comment>
  <if>if <condition>(<expr><name>aColFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>GetColorAndStyle</name><argument_list>(<argument><expr><name>aColFrame</name></expr></argument>, <argument><expr><name>aSide</name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>style</name></name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>color</name></name></expr></argument>, <argument><expr><name>aTableIsLTR</name></expr></argument>, <argument><expr><name>aIgnoreTableEdge</name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tempBorder</name>.<name>owner</name></name> = (<name>aAja</name> &amp;&amp; !<name>horizontal</name>) ? <name>eAjaColOwner</name> : <name>eColOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>border</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr>!<name>CELL_CORNER</name></expr></argument>, <argument><expr><name>border</name></expr></argument>, <argument><expr><name>tempBorder</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>NS_STYLE_BORDER_STYLE_HIDDEN</name> == <name><name>border</name>.<name>style</name></name></expr>)</condition><then> <block>{
      <return>return <expr><name>border</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <comment type="line">// see if the rowgroup is dominant</comment>
  <if>if <condition>(<expr><name>aRowGroupFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>GetColorAndStyle</name><argument_list>(<argument><expr><name>aRowGroupFrame</name></expr></argument>, <argument><expr><name>aSide</name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>style</name></name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>color</name></name></expr></argument>, <argument><expr><name>aTableIsLTR</name></expr></argument>, <argument><expr><name>aIgnoreTableEdge</name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tempBorder</name>.<name>owner</name></name> = (<name>aAja</name> &amp;&amp; <name>horizontal</name>) ? <name>eAjaRowGroupOwner</name> : <name>eRowGroupOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>border</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr>!<name>CELL_CORNER</name></expr></argument>, <argument><expr><name>border</name></expr></argument>, <argument><expr><name>tempBorder</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>NS_STYLE_BORDER_STYLE_HIDDEN</name> == <name><name>border</name>.<name>style</name></name></expr>)</condition><then> <block>{
      <return>return <expr><name>border</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <comment type="line">// see if the row is dominant</comment>
  <if>if <condition>(<expr><name>aRowFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>GetColorAndStyle</name><argument_list>(<argument><expr><name>aRowFrame</name></expr></argument>, <argument><expr><name>aSide</name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>style</name></name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>color</name></name></expr></argument>, <argument><expr><name>aTableIsLTR</name></expr></argument>, <argument><expr><name>aIgnoreTableEdge</name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tempBorder</name>.<name>owner</name></name> = (<name>aAja</name> &amp;&amp; <name>horizontal</name>) ? <name>eAjaRowOwner</name> : <name>eRowOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>border</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr>!<name>CELL_CORNER</name></expr></argument>, <argument><expr><name>border</name></expr></argument>, <argument><expr><name>tempBorder</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>NS_STYLE_BORDER_STYLE_HIDDEN</name> == <name><name>border</name>.<name>style</name></name></expr>)</condition><then> <block>{
      <return>return <expr><name>border</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <comment type="line">// see if the cell is dominant</comment>
  <if>if <condition>(<expr><name>aCellFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>GetColorAndStyle</name><argument_list>(<argument><expr><name>aCellFrame</name></expr></argument>, <argument><expr><name>aSide</name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>style</name></name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>color</name></name></expr></argument>, <argument><expr><name>aTableIsLTR</name></expr></argument>, <argument><expr><name>aIgnoreTableEdge</name></expr></argument>, <argument><expr><name><name>tempBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tempBorder</name>.<name>owner</name></name> = (<name>aAja</name>) ? <name>eAjaCellOwner</name> : <name>eCellOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>border</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr>!<name>CELL_CORNER</name></expr></argument>, <argument><expr><name>border</name></expr></argument>, <argument><expr><name>tempBorder</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>border</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> 
<name>Perpendicular</name><parameter_list>(<param><decl><type><name>PRUint8</name></type> <name>aSide1</name></decl></param>, 
              <param><decl><type><name>PRUint8</name></type> <name>aSide2</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>aSide1</name></expr>)</condition> <block>{
  <case>case <expr><name>NS_SIDE_TOP</name></expr>:
    <return>return <expr>(<name>NS_SIDE_BOTTOM</name> != <name>aSide2</name>)</expr>;</return>
  </case><case>case <expr><name>NS_SIDE_RIGHT</name></expr>:
    <return>return <expr>(<name>NS_SIDE_LEFT</name> != <name>aSide2</name>)</expr>;</return>
  </case><case>case <expr><name>NS_SIDE_BOTTOM</name></expr>:
    <return>return <expr>(<name>NS_SIDE_TOP</name> != <name>aSide2</name>)</expr>;</return>
  </case><default>default: <comment type="line">// NS_SIDE_LEFT</comment>
    <return>return <expr>(<name>NS_SIDE_RIGHT</name> != <name>aSide2</name>)</expr>;</return>
  </default>}</block></switch>
}</block></function>

<comment type="line">// XXX allocate this as number-of-cols+1 instead of number-of-cols+1 * number-of-rows+1</comment>
<struct>struct <name>BCCornerInfo</name> 
<block>{<public type="default">
  <constructor><name>BCCornerInfo</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><name>ownerColor</name> = 0</expr>;</expr_stmt> <expr_stmt><expr><name>ownerWidth</name> = <name>subWidth</name> = <name>ownerSide</name> = <name>ownerElem</name> = <name>subSide</name> = 
                   <name>subElem</name> = <name>hasDashDot</name> = <name>numSegs</name> = <name>bevel</name> = 0</expr>;</expr_stmt>
                   <expr_stmt><expr><name>ownerStyle</name> = 0xFF</expr>;</expr_stmt> <expr_stmt><expr><name>subStyle</name> = <name>NS_STYLE_BORDER_STYLE_SOLID</name></expr>;</expr_stmt>  }</block></constructor>
  <function_decl><type><name>void</name></type> <name>Set</name><parameter_list>(<param><decl><type><name>PRUint8</name></type>       <name>aSide</name></decl></param>,
           <param><decl><type><name>BCCellBorder</name></type>  <name>border</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>void</name></type> <name>Update</name><parameter_list>(<param><decl><type><name>PRUint8</name></type>       <name>aSide</name></decl></param>,
              <param><decl><type><name>BCCellBorder</name></type>  <name>border</name></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>nscolor</name></type>   <name>ownerColor</name></decl>;</decl_stmt>     <comment type="line">// color of borderOwner</comment>
  <decl_stmt><decl><type><name>PRUint16</name></type>  <name>ownerWidth</name></decl>;</decl_stmt>     <comment type="line">// pixel width of borderOwner </comment>
  <decl_stmt><decl><type><name>PRUint16</name></type>  <name>subWidth</name></decl>;</decl_stmt>       <comment type="line">// pixel width of the largest border intersecting the border perpendicular </comment>
                            <comment type="line">// to ownerSide</comment>
  <macro><name>PRUint32</name></macro>  <label><name>ownerSide</name>:</label><expr_stmt><expr>2</expr>;</expr_stmt>    <comment type="line">// side (e.g NS_SIDE_TOP, NS_SIDE_RIGHT, etc) of the border owning </comment>
                            <comment type="line">// the corner relative to the corner</comment>
  <macro><name>PRUint32</name></macro>  <label><name>ownerElem</name>:</label><expr_stmt><expr>3</expr>;</expr_stmt>    <comment type="line">// elem type (e.g. eTable, eGroup, etc) owning the corner</comment>
  <macro><name>PRUint32</name></macro>  <label><name>ownerStyle</name>:</label><expr_stmt><expr>8</expr>;</expr_stmt>   <comment type="line">// border style of ownerElem</comment>
  <macro><name>PRUint32</name></macro>  <label><name>subSide</name>:</label><expr_stmt><expr>2</expr>;</expr_stmt>      <comment type="line">// side of border with subWidth relative to the corner</comment>
  <macro><name>PRUint32</name></macro>  <label><name>subElem</name>:</label><expr_stmt><expr>3</expr>;</expr_stmt>      <comment type="line">// elem type (e.g. eTable, eGroup, etc) of sub owner</comment>
  <macro><name>PRUint32</name></macro>  <label><name>subStyle</name>:</label><expr_stmt><expr>8</expr>;</expr_stmt>     <comment type="line">// border style of subElem</comment>
  <macro><name>PRUint32</name></macro>  <label><name>hasDashDot</name>:</label><expr_stmt><expr>1</expr>;</expr_stmt>   <comment type="line">// does a dashed, dotted segment enter the corner, they cannot be beveled</comment>
  <macro><name>PRUint32</name></macro>  <label><name>numSegs</name>:</label><expr_stmt><expr>3</expr>;</expr_stmt>      <comment type="line">// number of segments entering corner</comment>
  <macro><name>PRUint32</name></macro>  <label><name>bevel</name>:</label><expr_stmt><expr>1</expr>;</expr_stmt>        <comment type="line">// is the corner beveled (uses the above two fields together with subWidth)</comment>
  <macro><name>PRUint32</name></macro>  <label><name>unused</name>:</label><expr_stmt><expr>1</expr>;</expr_stmt>
</public>}</block>;</struct>

<function><type><name>void</name></type> 
<name><name>BCCornerInfo</name>::<name>Set</name></name><parameter_list>(<param><decl><type><name>PRUint8</name></type>       <name>aSide</name></decl></param>,
                  <param><decl><type><name>BCCellBorder</name></type>  <name>aBorder</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>ownerElem</name>  = <name><name>aBorder</name>.<name>owner</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ownerStyle</name> = <name><name>aBorder</name>.<name>style</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ownerWidth</name> = <name><name>aBorder</name>.<name>width</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ownerColor</name> = <name><name>aBorder</name>.<name>color</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ownerSide</name>  = <name>aSide</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hasDashDot</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>numSegs</name>    = 0</expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>aBorder</name>.<name>width</name></name> &gt; 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>numSegs</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>hasDashDot</name> = (<name>NS_STYLE_BORDER_STYLE_DASHED</name> == <name><name>aBorder</name>.<name>style</name></name>) ||
                 (<name>NS_STYLE_BORDER_STYLE_DOTTED</name> == <name><name>aBorder</name>.<name>style</name></name>)</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>bevel</name>      = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>subWidth</name>   = 0</expr>;</expr_stmt>
  <comment type="line">// the following will get set later</comment>
  <expr_stmt><expr><name>subSide</name>    = ((<name>aSide</name> == <name>NS_SIDE_LEFT</name>) || (<name>aSide</name> == <name>NS_SIDE_RIGHT</name>)) ? <name>NS_SIDE_TOP</name> : <name>NS_SIDE_LEFT</name></expr>;</expr_stmt> 
  <expr_stmt><expr><name>subElem</name>    = <name>eTableOwner</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>subStyle</name>   = <name>NS_STYLE_BORDER_STYLE_SOLID</name></expr>;</expr_stmt> 
}</block></function>

<function><type><name>void</name></type> 
<name><name>BCCornerInfo</name>::<name>Update</name></name><parameter_list>(<param><decl><type><name>PRUint8</name></type>       <name>aSide</name></decl></param>,
                     <param><decl><type><name>BCCellBorder</name></type>  <name>aBorder</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>existingWins</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>0xFF == <name>ownerStyle</name></expr>)</condition><then> <block>{ <comment type="line">// initial value indiating that it hasn't been set yet</comment>
    <expr_stmt><expr><call><name>Set</name><argument_list>(<argument><expr><name>aSide</name></expr></argument>, <argument><expr><name>aBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>horizontal</name> <init>= <expr>(<name>NS_SIDE_LEFT</name> == <name>aSide</name>) || (<name>NS_SIDE_RIGHT</name> == <name>aSide</name>)</expr></init></decl>;</decl_stmt> <comment type="line">// relative to the corner</comment>
    <decl_stmt><decl><type><name>BCCellBorder</name></type> <name>oldBorder</name></decl>, <decl><type ref="prev"/><name>tempBorder</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>oldBorder</name>.<name>owner</name></name>  = (<name>BCBorderOwner</name>) <name>ownerElem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>oldBorder</name>.<name>style</name></name> =  <name>ownerStyle</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>oldBorder</name>.<name>width</name></name> =  <name>ownerWidth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>oldBorder</name>.<name>color</name></name> =  <name>ownerColor</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRUint8</name></type> <name>oldSide</name>  <init>= <expr><name>ownerSide</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>tempBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>CELL_CORNER</name></expr></argument>, <argument><expr><name>oldBorder</name></expr></argument>, <argument><expr><name>aBorder</name></expr></argument>, <argument><expr><name>horizontal</name></expr></argument>, <argument><expr>&amp;<name>existingWins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
                         
    <expr_stmt><expr><name>ownerElem</name>  = <name><name>tempBorder</name>.<name>owner</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ownerStyle</name> = <name><name>tempBorder</name>.<name>style</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ownerWidth</name> = <name><name>tempBorder</name>.<name>width</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ownerColor</name> = <name><name>tempBorder</name>.<name>color</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>existingWins</name></expr>)</condition><then> <block>{ <comment type="line">// existing corner is dominant</comment>
      <if>if <condition>(<expr><call><name>::<name>Perpendicular</name></name><argument_list>(<argument><expr><name>ownerSide</name></expr></argument>, <argument><expr><name>aSide</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// see if the new sub info replaces the old</comment>
        <decl_stmt><decl><type><name>BCCellBorder</name></type> <name>subBorder</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>subBorder</name>.<name>owner</name></name> = (<name>BCBorderOwner</name>) <name>subElem</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>subBorder</name>.<name>style</name></name> =  <name>subStyle</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>subBorder</name>.<name>width</name></name> =  <name>subWidth</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>subBorder</name>.<name>color</name></name> = 0</expr>;</expr_stmt> <comment type="line">// we are not interested in subBorder color</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>firstWins</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tempBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>CELL_CORNER</name></expr></argument>, <argument><expr><name>subBorder</name></expr></argument>, <argument><expr><name>aBorder</name></expr></argument>, <argument><expr><name>horizontal</name></expr></argument>, <argument><expr>&amp;<name>firstWins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>subElem</name>  = <name><name>tempBorder</name>.<name>owner</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>subStyle</name> = <name><name>tempBorder</name>.<name>style</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>subWidth</name> = <name><name>tempBorder</name>.<name>width</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>firstWins</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>subSide</name> = <name>aSide</name></expr>;</expr_stmt> 
        }</block></then></if>
      }</block></then></if>
    }</block></then>
    <else>else <block>{ <comment type="line">// input args are dominant</comment>
      <expr_stmt><expr><name>ownerSide</name> = <name>aSide</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>::<name>Perpendicular</name></name><argument_list>(<argument><expr><name>oldSide</name></expr></argument>, <argument><expr><name>ownerSide</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>subElem</name>  = <name><name>oldBorder</name>.<name>owner</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>subStyle</name> = <name><name>oldBorder</name>.<name>style</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>subWidth</name> = <name><name>oldBorder</name>.<name>width</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>subSide</name>  = <name>oldSide</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
    <if>if <condition>(<expr><name><name>aBorder</name>.<name>width</name></name> &gt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>numSegs</name>++</expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>hasDashDot</name> &amp;&amp; ((<name>NS_STYLE_BORDER_STYLE_DASHED</name> == <name><name>aBorder</name>.<name>style</name></name>) ||
                          (<name>NS_STYLE_BORDER_STYLE_DOTTED</name> == <name><name>aBorder</name>.<name>style</name></name>))</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>hasDashDot</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  
    <comment type="line">// bevel the corner if only two perpendicular non dashed/dotted segments enter the corner</comment>
    <expr_stmt><expr><name>bevel</name> = (2 == <name>numSegs</name>) &amp;&amp; (<name>subWidth</name> &gt; 1) &amp;&amp; (0 == <name>hasDashDot</name>)</expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<struct>struct <name>BCCorners</name>
<block>{<public type="default">
  <constructor_decl><name>BCCorners</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNumCorners</name></decl></param>,
            <param><decl><type><name>PRInt32</name></type> <name>aStartIndex</name></decl></param>)</parameter_list>;</constructor_decl>

  <destructor><name>~<name>BCCorners</name></name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr>delete <index>[]</index> <name>corners</name></expr>;</expr_stmt> }</block></destructor>
  
  <function><type><name>BCCornerInfo</name>&amp;</type> <name>operator []</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>i</name></decl></param>)</parameter_list> <specifier>const</specifier>
  <block>{ <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>i</name> &gt;= <name>startIndex</name>) &amp;&amp; (<name>i</name> &lt;= <name>endIndex</name>)</expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>corners</name><index>[<expr><call><name>PR_MAX</name><argument_list>(<argument><expr><call><name>PR_MIN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>)</argument_list></call> - <name>startIndex</name></expr>]</index></name></expr>;</return> }</block></function>

  <decl_stmt><decl><type><name>PRInt32</name></type>       <name>startIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>       <name>endIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCCornerInfo</name>*</type> <name>corners</name></decl>;</decl_stmt>
</public>}</block>;</struct>
  
<constructor><name><name>BCCorners</name>::<name>BCCorners</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNumCorners</name></decl></param>,
                     <param><decl><type><name>PRInt32</name></type> <name>aStartIndex</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>aNumCorners</name> &gt; 0) &amp;&amp; (<name>aStartIndex</name> &gt;= 0)</expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>startIndex</name> = <name>aStartIndex</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>endIndex</name>   = <name>aStartIndex</name> + <name>aNumCorners</name> - 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>corners</name>    = new <name><name>BCCornerInfo</name><index>[<expr><name>aNumCorners</name></expr>]</index></name></expr>;</expr_stmt> 
}</block></constructor>


<struct>struct <name>BCCellBorders</name>
<block>{<public type="default">
  <constructor_decl><name>BCCellBorders</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNumBorders</name></decl></param>,
                <param><decl><type><name>PRInt32</name></type> <name>aStartIndex</name></decl></param>)</parameter_list>;</constructor_decl>

  <destructor><name>~<name>BCCellBorders</name></name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr>delete <index>[]</index> <name>borders</name></expr>;</expr_stmt> }</block></destructor>
  
  <function><type><name>BCCellBorder</name>&amp;</type> <name>operator []</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>i</name></decl></param>)</parameter_list> <specifier>const</specifier>
  <block>{ <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>i</name> &gt;= <name>startIndex</name>) &amp;&amp; (<name>i</name> &lt;= <name>endIndex</name>)</expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>borders</name><index>[<expr><call><name>PR_MAX</name><argument_list>(<argument><expr><call><name>PR_MIN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>endIndex</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>)</argument_list></call> - <name>startIndex</name></expr>]</index></name></expr>;</return> }</block></function>

  <decl_stmt><decl><type><name>PRInt32</name></type>       <name>startIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>       <name>endIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCCellBorder</name>*</type> <name>borders</name></decl>;</decl_stmt>
</public>}</block>;</struct>
  
<constructor><name><name>BCCellBorders</name>::<name>BCCellBorders</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aNumBorders</name></decl></param>,
                             <param><decl><type><name>PRInt32</name></type> <name>aStartIndex</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name>aNumBorders</name> &gt; 0) &amp;&amp; (<name>aStartIndex</name> &gt;= 0)</expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>startIndex</name> = <name>aStartIndex</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>endIndex</name>   = <name>aStartIndex</name> + <name>aNumBorders</name> - 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>borders</name>    = new <name><name>BCCellBorder</name><index>[<expr><name>aNumBorders</name></expr>]</index></name></expr>;</expr_stmt> 
}</block></constructor>

<comment type="line">// this function sets the new border properties and returns true if the border</comment>
<comment type="line">// segment will start a new segment and not prolong the existing segment.</comment>
<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>SetBorder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>BCCellBorder</name>&amp;</type>   <name>aNewBorder</name></decl></param>,
          <param><decl><type><name>BCCellBorder</name>&amp;</type>         <name>aBorder</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>changed</name> <init>= <expr>(<name><name>aNewBorder</name>.<name>style</name></name> != <name><name>aBorder</name>.<name>style</name></name>) ||
                   (<name><name>aNewBorder</name>.<name>width</name></name> != <name><name>aBorder</name>.<name>width</name></name>) ||
                   (<name><name>aNewBorder</name>.<name>color</name></name> != <name><name>aBorder</name>.<name>color</name></name>)</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>aBorder</name>.<name>color</name></name>        = <name><name>aNewBorder</name>.<name>color</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBorder</name>.<name>width</name></name>        = <name><name>aNewBorder</name>.<name>width</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBorder</name>.<name>style</name></name>        = <name><name>aNewBorder</name>.<name>style</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aBorder</name>.<name>owner</name></name>        = <name><name>aNewBorder</name>.<name>owner</name></name></expr>;</expr_stmt>

  <return>return <expr><name>changed</name></expr>;</return>
}</block></function>

<comment type="line">// this function will set the horizontal border. It will return true if the </comment>
<comment type="line">// existing segment will not be continued. Having a vertical owner of a corner</comment>
<comment type="line">// should also start a new segment.</comment>
<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>SetHorBorder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>BCCellBorder</name>&amp;</type> <name>aNewBorder</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>BCCornerInfo</name>&amp;</type> <name>aCorner</name></decl></param>,
             <param><decl><type><name>BCCellBorder</name>&amp;</type>       <name>aBorder</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>startSeg</name> <init>= <expr><call><name>::<name>SetBorder</name></name><argument_list>(<argument><expr><name>aNewBorder</name></expr></argument>, <argument><expr><name>aBorder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>startSeg</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>startSeg</name> = ((<name>NS_SIDE_LEFT</name> != <name><name>aCorner</name>.<name>ownerSide</name></name>) &amp;&amp; (<name>NS_SIDE_RIGHT</name> != <name><name>aCorner</name>.<name>ownerSide</name></name>))</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>startSeg</name></expr>;</return>
}</block></function>

<comment type="line">// Make the damage area larger on the top and bottom by at least one row and on the left and right </comment>
<comment type="line">// at least one column. This is done so that adjacent elements are part of the border calculations. </comment>
<comment type="line">// The extra segments and borders outside the actual damage area will not be updated in the cell map, </comment>
<comment type="line">// because they in turn would need info from adjacent segments outside the damage area to be accurate.</comment>
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>ExpandBCDamageArea</name></name><parameter_list>(<param><decl><type><name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numRows</name> <init>= <expr><call><name>GetRowCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numCols</name> <init>= <expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>dStartX</name> <init>= <expr><name><name>aRect</name>.<name>x</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>dEndX</name>   <init>= <expr><call><name><name>aRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>dStartY</name> <init>= <expr><name><name>aRect</name>.<name>y</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>dEndY</name>   <init>= <expr><call><name><name>aRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</decl_stmt>

  <comment type="line">// expand the damage area in each direction</comment>
  <if>if <condition>(<expr><name>dStartX</name> &gt; 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>dStartX</name>--</expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>dEndX</name> &lt; (<name>numCols</name> - 1)</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>dEndX</name>++</expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>dStartY</name> &gt; 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>dStartY</name>--</expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>dEndY</name> &lt; (<name>numRows</name> - 1)</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>dEndY</name>++</expr>;</expr_stmt>
  }</block></then></if>
  <comment type="line">// Check the damage area so that there are no cells spanning in or out. If there are any then</comment>
  <comment type="line">// make the damage area as big as the table, similarly to the way the cell map decides whether</comment>
  <comment type="line">// to rebuild versus expand. This could be optimized to expand to the smallest area that contains</comment>
  <comment type="line">// no spanners, but it may not be worth the effort in general, and it would need to be done in the</comment>
  <comment type="line">// cell map as well.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>haveSpanner</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>dStartX</name> &gt; 0) || (<name>dEndX</name> &lt; (<name>numCols</name> - 1)) || (<name>dStartY</name> &gt; 0) || (<name>dEndY</name> &lt; (<name>numRows</name> - 1))</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>tableCellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>tableCellMap</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <comment type="line">// Get the ordered row groups </comment>
    <decl_stmt><decl><type><name>RowGroupArray</name></type> <name>rowGroups</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Scope outside loop to be used as hint.</comment>
    <decl_stmt><decl><type><name>nsCellMap</name>*</type> <name>cellMap</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>rgX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rgX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>rgStartY</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetStartRowIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>rgEndY</name>   <init>= <expr><name>rgStartY</name> + <call><name><name>rgFrame</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>dEndY</name> &lt; <name>rgStartY</name></expr>)</condition><then> 
        <break>break;</break></then></if>
      <expr_stmt><expr><name>cellMap</name> = <call><name><name>tableCellMap</name>-&gt;<name>GetMapFor</name></name><argument_list>(<argument><expr><name>rgFrame</name></expr></argument>, <argument><expr><name>cellMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>cellMap</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <comment type="line">// check for spanners from above and below</comment>
      <if>if <condition>(<expr>(<name>dStartY</name> &gt; 0) &amp;&amp; (<name>dStartY</name> &gt;= <name>rgStartY</name>) &amp;&amp; (<name>dStartY</name> &lt;= <name>rgEndY</name>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>PRUint32</name><argument_list>(<argument><expr><name>dStartY</name> - <name>rgStartY</name></expr></argument>)</argument_list></call> &gt;= <call><name><name>cellMap</name>-&gt;<name>mRows</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> 
          <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><specifier>const</specifier> <name><name>nsCellMap</name>::<name>CellDataArray</name></name>&amp;</type> <name>row</name> <init>=
          <expr><name><name>cellMap</name>-&gt;<name>mRows</name><index>[<expr><name>dStartY</name> - <name>rgStartY</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>PRInt32</name></type> <name>x</name> <init>= <expr><name>dStartX</name></expr></init></decl>;</init> <condition><expr><name>x</name> &lt;= <name>dEndX</name></expr>;</condition> <incr><expr><name>x</name>++</expr></incr>) <block>{
          <decl_stmt><decl><type><name>CellData</name>*</type> <name>cellData</name> <init>= <expr><call><name><name>row</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>cellData</name> &amp;&amp; (<call><name><name>cellData</name>-&gt;<name>IsRowSpan</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
             <expr_stmt><expr><name>haveSpanner</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
             <break>break;</break>
          }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr><name>dEndY</name> &lt; <name>rgEndY</name></expr>)</condition><then> <block>{
          <if>if <condition>(<expr><call><name>PRUint32</name><argument_list>(<argument><expr><name>dEndY</name> + 1 - <name>rgStartY</name></expr></argument>)</argument_list></call> &gt;= <call><name><name>cellMap</name>-&gt;<name>mRows</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> 
            <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <decl_stmt><decl><type><specifier>const</specifier> <name><name>nsCellMap</name>::<name>CellDataArray</name></name>&amp;</type> <name>row2</name> <init>=
            <expr><name><name>cellMap</name>-&gt;<name>mRows</name><index>[<expr><name>dEndY</name> + 1 - <name>rgStartY</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <for>for (<init><decl><type><name>PRInt32</name></type> <name>x</name> <init>= <expr><name>dStartX</name></expr></init></decl>;</init> <condition><expr><name>x</name> &lt;= <name>dEndX</name></expr>;</condition> <incr><expr><name>x</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>CellData</name>*</type> <name>cellData</name> <init>= <expr><call><name><name>row2</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>cellData</name> &amp;&amp; (<call><name><name>cellData</name>-&gt;<name>IsRowSpan</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
              <expr_stmt><expr><name>haveSpanner</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
          }</block></for>
        }</block></then></if>
      }</block></then></if>
      <comment type="line">// check for spanners on the left and right</comment>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>iterStartY</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>iterEndY</name>   <init>= <expr>-1</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>(<name>dStartY</name> &gt;= <name>rgStartY</name>) &amp;&amp; (<name>dStartY</name> &lt;= <name>rgEndY</name>)</expr>)</condition><then> <block>{
        <comment type="line">// the damage area starts in the row group</comment>
        <expr_stmt><expr><name>iterStartY</name> = <name>dStartY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iterEndY</name>   = <call><name>PR_MIN</name><argument_list>(<argument><expr><name>dEndY</name></expr></argument>, <argument><expr><name>rgEndY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <if>if <condition>(<expr>(<name>dEndY</name> &gt;= <name>rgStartY</name>) &amp;&amp; (<name>dEndY</name> &lt;= <name>rgEndY</name>)</expr>)</condition><then> <block>{
        <comment type="line">// the damage area ends in the row group</comment>
        <expr_stmt><expr><name>iterStartY</name> = <name>rgStartY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iterEndY</name>   = <call><name>PR_MIN</name><argument_list>(<argument><expr><name>dEndY</name></expr></argument>, <argument><expr><name>rgStartY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <if>if <condition>(<expr>(<name>rgStartY</name> &gt;= <name>dStartY</name>) &amp;&amp; (<name>rgEndY</name> &lt;= <name>dEndY</name>)</expr>)</condition><then> <block>{
        <comment type="line">// the damage area contains the row group</comment>
        <expr_stmt><expr><name>iterStartY</name> = <name>rgStartY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iterEndY</name>   = <name>rgEndY</name></expr>;</expr_stmt>
      }</block></then></if></else></if></else></if>
      <if>if <condition>(<expr>(<name>iterStartY</name> &gt;= 0) &amp;&amp; (<name>iterEndY</name> &gt;= 0)</expr>)</condition><then> <block>{
        <for>for (<init><decl><type><name>PRInt32</name></type> <name>y</name> <init>= <expr><name>iterStartY</name></expr></init></decl>;</init> <condition><expr><name>y</name> &lt;= <name>iterEndY</name></expr>;</condition> <incr><expr><name>y</name>++</expr></incr>) <block>{
          <if>if <condition>(<expr><call><name>PRUint32</name><argument_list>(<argument><expr><name>y</name> - <name>rgStartY</name></expr></argument>)</argument_list></call> &gt;= <call><name><name>cellMap</name>-&gt;<name>mRows</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> 
            <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <decl_stmt><decl><type><specifier>const</specifier> <name><name>nsCellMap</name>::<name>CellDataArray</name></name>&amp;</type> <name>row</name> <init>=
            <expr><name><name>cellMap</name>-&gt;<name>mRows</name><index>[<expr><name>y</name> - <name>rgStartY</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>CellData</name>*</type> <name>cellData</name> <init>= <expr><call><name><name>row</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>dStartX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>cellData</name> &amp;&amp; (<call><name><name>cellData</name>-&gt;<name>IsColSpan</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>haveSpanner</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
          <if>if <condition>(<expr><name>dEndX</name> &lt; (<name>numCols</name> - 1)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cellData</name> = <call><name><name>row</name>.<name>SafeElementAt</name></name><argument_list>(<argument><expr><name>dEndX</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>cellData</name> &amp;&amp; (<call><name><name>cellData</name>-&gt;<name>IsColSpan</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
              <expr_stmt><expr><name>haveSpanner</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
          }</block></then></if>
        }</block></for>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
  <if>if <condition>(<expr><name>haveSpanner</name></expr>)</condition><then> <block>{
    <comment type="line">// make the damage area the whole table</comment>
    <expr_stmt><expr><name><name>aRect</name>.<name>x</name></name>      = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>y</name></name>      = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>width</name></name>  = <name>numCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>height</name></name> = <name>numRows</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name><name>aRect</name>.<name>x</name></name>      = <name>dStartX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>y</name></name>      = <name>dStartY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>width</name></name>  = 1 + <name>dEndX</name> - <name>dStartX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aRect</name>.<name>height</name></name> = 1 + <name>dEndY</name> - <name>dStartY</name></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TABLE_BORDER_WIDTH</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PRUint8</name></type>
<name>LimitBorderWidth</name><parameter_list>(<param><decl><type><name>PRUint16</name></type> <name>aWidth</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>PR_MIN</name><argument_list>(<argument><expr><name>MAX_TABLE_BORDER_WIDTH</name></expr></argument>, <argument><expr><name>aWidth</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Here is the order for storing border edges in the cell map as a cell is processed. There are 
   n=colspan top and bottom border edges per cell and n=rowspan left and right border edges per cell.

   1) On the top edge of the table, store the top edge. Never store the top edge otherwise, since
      a bottom edge from a cell above will take care of it.
   2) On the left edge of the table, store the left edge. Never store the left edge othewise, since
      a right edge from a cell to the left will take care of it.
   3) Store the right edge (or edges if a row span) 
   4) Store the bottom edge (or edges if a col span)
    
   Since corners are computed with only an array of BCCornerInfo indexed by the number-of-cols, corner
   calculations are somewhat complicated. Using an array with number-of-rows * number-of-col entries
   would simplify this, but at an extra in memory cost of nearly 12 bytes per cell map entry. Collapsing 
   borders already have about an extra 8 byte per cell map entry overhead (this could be
   reduced to 4 bytes if we are willing to not store border widths in nsTableCellFrame), Here are the 
   rules in priority order for storing cornes in the cell map as a cell is processed. top-left means the
   left endpoint of the border edge on the top of the cell. There are n=colspan top and bottom border 
   edges per cell and n=rowspan left and right border edges per cell.

   1) On the top edge of the table, store the top-left corner, unless on the left edge of the table.
      Never store the top-right corner, since it will get stored as a right-top corner.
   2) On the left edge of the table, store the left-top corner. Never store the left-bottom corner,
      since it will get stored as a bottom-left corner.
   3) Store the right-top corner if (a) it is the top right corner of the table or (b) it is not on
      the top edge of the table. Never store the right-bottom corner since it will get stored as a 
      bottom-right corner.
   4) Store the bottom-right corner, if it is the bottom right corner of the table. Never store it 
      otherwise, since it will get stored as either a right-top corner by a cell below or
      a bottom-left corner from a cell to the right.
   5) Store the bottom-left corner, if (a) on the bottom edge of the table or (b) if the left edge hits 
      the top side of a colspan in its interior. Never store the corner otherwise, since it will 
      get stored as a right-top corner by a cell from below.

   XXX the BC-RTL hack - The correct fix would be a rewrite as described in bug 203686.
   In order to draw borders in rtl conditions somehow correct, the existing structure which relies
   heavily on the assumption that the next cell sibling will be on the right side, has been modified.
   We flip the border during painting and during style lookup. Look for tableIsLTR for places where
   the flipping is done.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TABLE_EDGE</name></cpp:macro>  <cpp:value>PR_TRUE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADJACENT</name></cpp:macro>    <cpp:value>PR_TRUE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HORIZONTAL</name></cpp:macro>  <cpp:value>PR_TRUE</cpp:value></cpp:define>

<comment type="line">// Calc the dominant border at every cell edge and corner within the current damage area</comment>
<function><type><name>void</name></type> 
<name><name>nsTableFrame</name>::<name>CalcBCBorders</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>IsBorderCollapse</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"calling CalcBCBorders on separated-border table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>tableCellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>tableCellMap</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numRows</name> <init>= <expr><call><name>GetRowCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numCols</name> <init>= <expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>numRows</name> || !<name>numCols</name></expr>)</condition><then>
    <return>return;</return></then></if> <comment type="line">// nothing to do</comment>

  <comment type="line">// Get the property holding the table damage area and border widths</comment>
  <decl_stmt><decl><type><name>BCPropertyData</name>*</type> <name>propData</name> <init>= 
    <expr>(<name>BCPropertyData</name>*)<call><name><name>nsTableFrame</name>::<name>GetProperty</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>tableBCProperty</name></name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>propData</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>tableIsLTR</name> <init>= <expr><call><name>GetStyleVisibility</name><argument_list>()</argument_list></call>-&gt;<name>mDirection</name> == <name>NS_STYLE_DIRECTION_LTR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint8</name></type> <name>firstSide</name></decl>, <decl><type ref="prev"/><name>secondSide</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>tableIsLTR</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>firstSide</name>  = <name>NS_SIDE_LEFT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>secondSide</name> = <name>NS_SIDE_RIGHT</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>firstSide</name>  = <name>NS_SIDE_RIGHT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>secondSide</name> = <name>NS_SIDE_LEFT</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>CheckFixDamageArea</name><argument_list>(<argument><expr><name>numRows</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>, <argument><expr><name><name>propData</name>-&gt;<name>mDamageArea</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// calculate an expanded damage area </comment>
  <function_decl><type><name>nsRect</name></type> <name>damageArea</name><parameter_list>(<param><decl><type><name><name>propData</name>-&gt;<name>mDamageArea</name></name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name>ExpandBCDamageArea</name><argument_list>(<argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// segments that are on the table border edges need to be initialized only once</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name><name>tableBorderReset</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>sideX</name> <init>= <expr><name>NS_SIDE_TOP</name></expr></init></decl>;</init> <condition><expr><name>sideX</name> &lt;= <name>NS_SIDE_LEFT</name></expr>;</condition> <incr><expr><name>sideX</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>tableBorderReset</name><index>[<expr><name>sideX</name></expr>]</index></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// vertical borders indexed in x-direction (cols)</comment>
  <decl_stmt><decl><type><name>BCCellBorders</name></type> <name>lastVerBorders</name><argument_list>(<argument><expr><name><name>damageArea</name>.<name>width</name></name> + 1</expr></argument>, <argument><expr><name><name>damageArea</name>.<name>x</name></name></expr></argument>)</argument_list></decl>;</decl_stmt> <if>if <condition>(<expr>!<name><name>lastVerBorders</name>.<name>borders</name></name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <decl_stmt><decl><type><name>BCCellBorder</name></type>  <name>lastTopBorder</name></decl>, <decl><type ref="prev"/><name>lastBottomBorder</name></decl>;</decl_stmt>
  <comment type="line">// horizontal borders indexed in x-direction (cols)</comment>
  <decl_stmt><decl><type><name>BCCellBorders</name></type> <name>lastBottomBorders</name><argument_list>(<argument><expr><name><name>damageArea</name>.<name>width</name></name> + 1</expr></argument>, <argument><expr><name><name>damageArea</name>.<name>x</name></name></expr></argument>)</argument_list></decl>;</decl_stmt> <if>if <condition>(<expr>!<name><name>lastBottomBorders</name>.<name>borders</name></name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>startSeg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>gotRowBorder</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>BCMapCellInfo</name></type>  <name>info</name></decl>, <decl><type ref="prev"/><name>ajaInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCCellBorder</name></type> <name>currentBorder</name></decl>, <decl><type ref="prev"/><name>adjacentBorder</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>   <name>cellEndRowIndex</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>   <name>cellEndColIndex</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCCorners</name></type> <name>topCorners</name><argument_list>(<argument><expr><name><name>damageArea</name>.<name>width</name></name> + 1</expr></argument>, <argument><expr><name><name>damageArea</name>.<name>x</name></name></expr></argument>)</argument_list></decl>;</decl_stmt> <if>if <condition>(<expr>!<name><name>topCorners</name>.<name>corners</name></name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <decl_stmt><decl><type><name>BCCorners</name></type> <name>bottomCorners</name><argument_list>(<argument><expr><name><name>damageArea</name>.<name>width</name></name> + 1</expr></argument>, <argument><expr><name><name>damageArea</name>.<name>x</name></name></expr></argument>)</argument_list></decl>;</decl_stmt> <if>if <condition>(<expr>!<name><name>bottomCorners</name>.<name>corners</name></name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>BCMapCellIterator</name></type> <name>iter</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <for>for (<init><expr><call><name><name>iter</name>.<name>First</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr>!<name><name>iter</name>.<name>mAtEnd</name></name></expr>;</condition> <incr><expr><call><name><name>iter</name>.<name>Next</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></incr>) <block>{

    <expr_stmt><expr><name>cellEndRowIndex</name> = <name><name>info</name>.<name>rowIndex</name></name> + <name><name>info</name>.<name>rowSpan</name></name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>cellEndColIndex</name> = <name><name>info</name>.<name>colIndex</name></name> + <name><name>info</name>.<name>colSpan</name></name> - 1</expr>;</expr_stmt>
    
    <decl_stmt><decl><type><name>PRBool</name></type> <name>bottomRowSpan</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <comment type="line">// see if lastTopBorder, lastBottomBorder need to be reset</comment>
    <if>if <condition>(<expr><call><name><name>iter</name>.<name>IsNewRow</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ 
      <expr_stmt><expr><name>gotRowBorder</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>lastTopBorder</name>.<name>Reset</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>rowIndex</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>rowSpan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>lastBottomBorder</name>.<name>Reset</name></name><argument_list>(<argument><expr><name>cellEndRowIndex</name> + 1</expr></argument>, <argument><expr><name><name>info</name>.<name>rowSpan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>info</name>.<name>colIndex</name></name> &gt; <name><name>damageArea</name>.<name>x</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>lastBottomBorder</name> = <name><name>lastBottomBorders</name><index>[<expr><name><name>info</name>.<name>colIndex</name></name> - 1</expr>]</index></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>info</name>.<name>rowIndex</name></name> &gt; <name><name>lastBottomBorder</name>.<name>rowIndex</name></name> - <name><name>lastBottomBorder</name>.<name>rowSpan</name></name></expr>)</condition><then> <block>{ 
        <comment type="line">// the top border's left edge butts against the middle of a rowspan</comment>
        <expr_stmt><expr><call><name><name>lastTopBorder</name>.<name>Reset</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>rowIndex</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>rowSpan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><name><name>lastBottomBorder</name>.<name>rowIndex</name></name> &gt; (<name>cellEndRowIndex</name> + 1)</expr>)</condition><then> <block>{
        <comment type="line">// the bottom border's left edge butts against the middle of a rowspan</comment>
        <expr_stmt><expr><call><name><name>lastBottomBorder</name>.<name>Reset</name></name><argument_list>(<argument><expr><name>cellEndRowIndex</name> + 1</expr></argument>, <argument><expr><name><name>info</name>.<name>rowSpan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bottomRowSpan</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if></else></if>

    <comment type="line">// find the dominant border considering the cell's top border and the table, row group, row</comment>
    <comment type="line">// if the border is at the top of the table, otherwise it was processed in a previous row</comment>
    <if>if <condition>(<expr>0 == <name><name>info</name>.<name>rowIndex</name></name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<name><name>tableBorderReset</name><index>[<expr><name>NS_SIDE_TOP</name></expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>propData</name>-&gt;<name>mTopBorderWidth</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tableBorderReset</name><index>[<expr><name>NS_SIDE_TOP</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
      <for>for (<init><decl><type><name>PRInt32</name></type> <name>colX</name> <init>= <expr><name><name>info</name>.<name>colIndex</name></name></expr></init></decl>;</init> <condition><expr><name>colX</name> &lt;= <name>cellEndColIndex</name></expr>;</condition> <incr><expr><name>colX</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name>GetColFrame</name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>colFrame</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>cgFrame</name> <init>= <expr><call><name><name>colFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>cgFrame</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>cgFrame</name></expr></argument>, <argument><expr><name>colFrame</name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>topRow</name></name></expr></argument>,
                                       <argument><expr><name><name>info</name>.<name>cell</name></name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_TOP</name></expr></argument>,
                                       <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update/store the top left &amp; top right corners of the seg </comment>
        <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>tlCorner</name> <init>= <expr><name><name>topCorners</name><index>[<expr><name>colX</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// top left</comment>
        <if>if <condition>(<expr>0 == <name>colX</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>tlCorner</name>.<name>Set</name></name><argument_list>(<argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// we are on right hand side of the corner</comment>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><call><name><name>tlCorner</name>.<name>Update</name></name><argument_list>(<argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderCorner</name></name><argument_list>(<argument><expr><name>eTopLeft</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>colX</name></expr></argument>,
                                          <argument><expr><name><name>tlCorner</name>.<name>ownerSide</name></name></expr></argument>, <argument><expr><name><name>tlCorner</name>.<name>subWidth</name></name></expr></argument>, <argument><expr><name><name>tlCorner</name>.<name>bevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name><name>topCorners</name><index>[<expr><name>colX</name> + 1</expr>]</index></name>.<call><name>Set</name><argument_list>(<argument><expr><name>NS_SIDE_LEFT</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// top right</comment>
        <comment type="line">// update lastTopBorder and see if a new segment starts</comment>
        <expr_stmt><expr><name>startSeg</name> = <call><name>SetHorBorder</name><argument_list>(<argument><expr><name>currentBorder</name></expr></argument>, <argument><expr><name>tlCorner</name></expr></argument>, <argument><expr><name>lastTopBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// store the border segment in the cell map</comment>
        <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderEdge</name></name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>colX</name></expr></argument>,
                                      <argument><expr>1</expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>owner</name></name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><name>startSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update the affected borders of the cell, row, and table</comment>
        <if>if <condition>(<expr><name><name>info</name>.<name>cell</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>SetBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>GetBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>info</name>.<name>topRow</name></name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>half</name> <init>= <expr><call><name>BC_BORDER_BOTTOM_HALF</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>info</name>.<name>topRow</name>-&gt;<name>SetTopBCBorderWidth</name></name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>half</name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>topRow</name>-&gt;<name>GetTopBCBorderWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>propData</name>-&gt;<name>mTopBorderWidth</name></name> = <call><name>LimitBorderWidth</name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>propData</name>-&gt;<name>mTopBorderWidth</name></name></expr></argument>, <argument><expr>(<name>PRUint8</name>)<name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//calculate column continuous borders</comment>
        <comment type="line">//we only need to do this once, so we'll do it only on the first row</comment>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>cgFrame</name></expr></argument>, <argument><expr><name>colFrame</name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>,
                                       <argument><expr><name><name>info</name>.<name>topRow</name></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, 
                                       <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>((<name>nsTableColFrame</name>*)<name>colFrame</name>)-&gt;<call><name>SetContinuousBCBorderWidth</name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>,
                                                                 <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>numCols</name> == <name>cellEndColIndex</name> + 1</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>cgFrame</name></expr></argument>, <argument><expr><name>colFrame</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>,
                                         <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>,
                                         <argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>cgFrame</name></expr></argument>, <argument><expr><name>colFrame</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>,
                                         <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr>!<name>TABLE_EDGE</name></expr></argument>,
                                         <argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr>((<name>nsTableColFrame</name>*)<name>colFrame</name>)-&gt;<call><name>SetContinuousBCBorderWidth</name><argument_list>(<argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>,
                                                                 <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
      }</block></for>
      <comment type="line">//calculate continuous top first row &amp; rowgroup border: special case</comment>
      <comment type="line">//because it must include the table in the collapse</comment>
      <if>if <condition>(<expr><name><name>info</name>.<name>topRow</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>,
                                       <argument><expr><name><name>info</name>.<name>topRow</name></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>,
                                       <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>info</name>.<name>topRow</name>-&gt;<name>SetContinuousBCBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><name><name>info</name>.<name>cgRight</name></name> &amp;&amp; <name><name>info</name>.<name>cg</name></name></expr>)</condition><then> <block>{
        <comment type="line">//calculate continuous top colgroup border once per colgroup</comment>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cg</name></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>,
                                       <argument><expr><name><name>info</name>.<name>topRow</name></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, 
                                       <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>info</name>.<name>cg</name>-&gt;<name>SetContinuousBCBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr>0 == <name><name>info</name>.<name>colIndex</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>leftCol</name></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>,
                                       <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>,
                                       <argument><expr><name>NS_SIDE_LEFT</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mBits</name>.<name>mLeftContBCBorder</name></name> = <name><name>currentBorder</name>.<name>width</name></name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then>
    <else>else <block>{
      <comment type="line">// see if the top border needs to be the start of a segment due to a vertical border owning the corner</comment>
      <if>if <condition>(<expr><name><name>info</name>.<name>colIndex</name></name> &gt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>BCData</name>&amp;</type> <name>data</name> <init>= <expr>((<name>BCCellData</name>*)<name><name>info</name>.<name>cellData</name></name>)-&gt;<name>mData</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>data</name>.<name>IsTopStart</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>PRUint8</name></type> <name>cornerSide</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>bevel</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>data</name>.<name>GetCorner</name></name><argument_list>(<argument><expr><name>cornerSide</name></expr></argument>, <argument><expr><name>bevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>(<name>NS_SIDE_TOP</name> == <name>cornerSide</name>) || (<name>NS_SIDE_BOTTOM</name> == <name>cornerSide</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>data</name>.<name>SetTopStart</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if>  
    }</block></else></if>

    <comment type="line">// find the dominant border considering the cell's left border and the table, col group, col  </comment>
    <comment type="line">// if the border is at the left of the table, otherwise it was processed in a previous col</comment>
    <if>if <condition>(<expr>0 == <name><name>info</name>.<name>colIndex</name></name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<name><name>tableBorderReset</name><index>[<expr><name>NS_SIDE_LEFT</name></expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>propData</name>-&gt;<name>mLeftBorderWidth</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tableBorderReset</name><index>[<expr><name>NS_SIDE_LEFT</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
      <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>rowFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
      <for>for (<init><decl><type><name>PRInt32</name></type> <name>rowX</name> <init>= <expr><name><name>info</name>.<name>rowIndex</name></name></expr></init></decl>;</init> <condition><expr><name>rowX</name> &lt;= <name>cellEndRowIndex</name></expr>;</condition> <incr><expr><name>rowX</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>rowFrame</name> = (<name>rowX</name> == <name><name>info</name>.<name>rowIndex</name></name>) ? <name><name>info</name>.<name>topRow</name></name> : <call><name><name>rowFrame</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>leftCol</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>, <argument><expr><name>rowFrame</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cell</name></name></expr></argument>, 
                                       <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_LEFT</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>tlCorner</name> <init>= <expr>(0 == <name>rowX</name>) ? <name><name>topCorners</name><index>[<expr>0</expr>]</index></name> : <name><name>bottomCorners</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// top left</comment>
        <expr_stmt><expr><call><name><name>tlCorner</name>.<name>Update</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderCorner</name></name><argument_list>(<argument><expr><name>eTopLeft</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>rowX</name></expr></argument>, 
                                        <argument><expr>0</expr></argument>, <argument><expr><name><name>tlCorner</name>.<name>ownerSide</name></name></expr></argument>, <argument><expr><name><name>tlCorner</name>.<name>subWidth</name></name></expr></argument>, <argument><expr><name><name>tlCorner</name>.<name>bevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bottomCorners</name><index>[<expr>0</expr>]</index></name>.<call><name>Set</name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// bottom left             </comment>
        <comment type="line">// update lastVerBordersBorder and see if a new segment starts</comment>
        <expr_stmt><expr><name>startSeg</name> = <call><name>SetBorder</name><argument_list>(<argument><expr><name>currentBorder</name></expr></argument>, <argument><expr><name><name>lastVerBorders</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// store the border segment in the cell map </comment>
        <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderEdge</name></name><argument_list>(<argument><expr><name>NS_SIDE_LEFT</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>rowX</name></expr></argument>, 
                                      <argument><expr><name><name>info</name>.<name>colIndex</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>owner</name></name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><name>startSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update the left border of the cell, col and table</comment>
        <if>if <condition>(<expr><name><name>info</name>.<name>cell</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>SetBorderWidth</name></name><argument_list>(<argument><expr><name>firstSide</name></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>GetBorderWidth</name></name><argument_list>(<argument><expr><name>firstSide</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>info</name>.<name>leftCol</name></name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>half</name> <init>= <expr><call><name>BC_BORDER_RIGHT_HALF</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>info</name>.<name>leftCol</name>-&gt;<name>SetLeftBorderWidth</name></name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>half</name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>leftCol</name>-&gt;<name>GetLeftBorderWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>propData</name>-&gt;<name>mLeftBorderWidth</name></name> = <call><name>LimitBorderWidth</name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>propData</name>-&gt;<name>mLeftBorderWidth</name></name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//get row continuous borders</comment>
        <if>if <condition>(<expr><name>rowFrame</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>leftCol</name></name></expr></argument>,
                                         <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>, <argument><expr><name>rowFrame</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>,
                                         <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_LEFT</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>SetContinuousBCBorderWidth</name></name><argument_list>(<argument><expr><name>firstSide</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
      <comment type="line">//get row group continuous borders</comment>
      <if>if <condition>(<expr><name><name>info</name>.<name>rgBottom</name></name> &amp;&amp; <name><name>info</name>.<name>rg</name></name></expr>)</condition><then> <block>{ <comment type="line">//once per row group, so check for bottom</comment>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>leftCol</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>,
                                       <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_LEFT</name></expr></argument>,
                                       <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>info</name>.<name>rg</name>-&gt;<name>SetContinuousBCBorderWidth</name></name><argument_list>(<argument><expr><name>firstSide</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <comment type="line">// find the dominant border considering the cell's right border, adjacent cells and the table, row group, row</comment>
    <if>if <condition>(<expr><name>numCols</name> == <name>cellEndColIndex</name> + 1</expr>)</condition><then> <block>{ <comment type="line">// touches right edge of table</comment>
      <if>if <condition>(<expr>!<name><name>tableBorderReset</name><index>[<expr><name>NS_SIDE_RIGHT</name></expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>propData</name>-&gt;<name>mRightBorderWidth</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tableBorderReset</name><index>[<expr><name>NS_SIDE_RIGHT</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
      <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>rowFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
      <for>for (<init><decl><type><name>PRInt32</name></type> <name>rowX</name> <init>= <expr><name><name>info</name>.<name>rowIndex</name></name></expr></init></decl>;</init> <condition><expr><name>rowX</name> &lt;= <name>cellEndRowIndex</name></expr>;</condition> <incr><expr><name>rowX</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>rowFrame</name> = (<name>rowX</name> == <name><name>info</name>.<name>rowIndex</name></name>) ? <name><name>info</name>.<name>topRow</name></name> : <call><name><name>rowFrame</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>rightCol</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>, <argument><expr><name>rowFrame</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cell</name></name></expr></argument>, 
                                       <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update/store the top right &amp; bottom right corners </comment>
        <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>trCorner</name> <init>= <expr>(0 == <name>rowX</name>) ? <name><name>topCorners</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name> : <name><name>bottomCorners</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt> 
        <expr_stmt><expr><call><name><name>trCorner</name>.<name>Update</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="line">// top right</comment>
        <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderCorner</name></name><argument_list>(<argument><expr><name>eTopRight</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>rowX</name></expr></argument>, 
                                        <argument><expr><name>cellEndColIndex</name></expr></argument>, <argument><expr><name><name>trCorner</name>.<name>ownerSide</name></name></expr></argument>, <argument><expr><name><name>trCorner</name>.<name>subWidth</name></name></expr></argument>, <argument><expr><name><name>trCorner</name>.<name>bevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>brCorner</name> <init>= <expr><name><name>bottomCorners</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>brCorner</name>.<name>Set</name></name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// bottom right</comment>
        <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderCorner</name></name><argument_list>(<argument><expr><name>eBottomRight</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>rowX</name></expr></argument>,
                                        <argument><expr><name>cellEndColIndex</name></expr></argument>, <argument><expr><name><name>brCorner</name>.<name>ownerSide</name></name></expr></argument>, <argument><expr><name><name>brCorner</name>.<name>subWidth</name></name></expr></argument>, <argument><expr><name><name>brCorner</name>.<name>bevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update lastVerBorders and see if a new segment starts</comment>
        <expr_stmt><expr><name>startSeg</name> = <call><name>SetBorder</name><argument_list>(<argument><expr><name>currentBorder</name></expr></argument>, <argument><expr><name><name>lastVerBorders</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// store the border segment in the cell map and update cellBorders</comment>
        <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderEdge</name></name><argument_list>(<argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>rowX</name></expr></argument>,
                                      <argument><expr><name>cellEndColIndex</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>owner</name></name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><name>startSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update the affected borders of the cell, col, and table</comment>
        <if>if <condition>(<expr><name><name>info</name>.<name>cell</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>SetBorderWidth</name></name><argument_list>(<argument><expr><name>secondSide</name></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>GetBorderWidth</name></name><argument_list>(<argument><expr><name>secondSide</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>info</name>.<name>rightCol</name></name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>half</name> <init>= <expr><call><name>BC_BORDER_LEFT_HALF</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>info</name>.<name>rightCol</name>-&gt;<name>SetRightBorderWidth</name></name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>half</name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>rightCol</name>-&gt;<name>GetRightBorderWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>propData</name>-&gt;<name>mRightBorderWidth</name></name> = <call><name>LimitBorderWidth</name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>propData</name>-&gt;<name>mRightBorderWidth</name></name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//get row continuous borders</comment>
        <if>if <condition>(<expr><name>rowFrame</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>rightCol</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>,
                                         <argument><expr><name>rowFrame</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>,
                                         <argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>rowFrame</name>-&gt;<name>SetContinuousBCBorderWidth</name></name><argument_list>(<argument><expr><name>secondSide</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
      <comment type="line">//get row group continuous borders</comment>
      <if>if <condition>(<expr><name><name>info</name>.<name>rgBottom</name></name> &amp;&amp; <name><name>info</name>.<name>rg</name></name></expr>)</condition><then> <block>{ <comment type="line">//once per rg, so check for bottom</comment>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>rightCol</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>, 
                                       <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>,
                                       <argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>info</name>.<name>rg</name>-&gt;<name>SetContinuousBCBorderWidth</name></name><argument_list>(<argument><expr><name>secondSide</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then>
    <else>else <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>segLength</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BCMapCellInfo</name></type> <name>priorAjaInfo</name></decl>;</decl_stmt>
      <for>for (<init><decl><type><name>PRInt32</name></type> <name>rowX</name> <init>= <expr><name><name>info</name>.<name>rowIndex</name></name></expr></init></decl>;</init> <condition><expr><name>rowX</name> &lt;= <name>cellEndRowIndex</name></expr>;</condition> <incr><expr><name>rowX</name> += <name>segLength</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name><name>iter</name>.<name>PeekRight</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>rowX</name></expr></argument>, <argument><expr><name>ajaInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>cg</name> <init>= <expr>(<name><name>info</name>.<name>cgRight</name></name>) ? <name><name>info</name>.<name>cg</name></name> : <name>nsnull</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>info</name>.<name>rightCol</name></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cell</name></name></expr></argument>,
                                       <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr>!<name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cg</name> = (<name><name>ajaInfo</name>.<name>cgLeft</name></name>) ? <name><name>ajaInfo</name>.<name>cg</name></name> : <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>adjacentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>ajaInfo</name>.<name>leftCol</name></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name><name>ajaInfo</name>.<name>cell</name></name></expr></argument>, 
                                        <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr>!<name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_LEFT</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr>!<name>CELL_CORNER</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>, <argument><expr><name>adjacentBorder</name></expr></argument>, <argument><expr>!<name>HORIZONTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                          
        <expr_stmt><expr><name>segLength</name> = <call><name>PR_MAX</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>ajaInfo</name>.<name>rowIndex</name></name> + <name><name>ajaInfo</name>.<name>rowSpan</name></name> - <name>rowX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>segLength</name> = <call><name>PR_MIN</name><argument_list>(<argument><expr><name>segLength</name></expr></argument>, <argument><expr><name><name>info</name>.<name>rowIndex</name></name> + <name><name>info</name>.<name>rowSpan</name></name> - <name>rowX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// update lastVerBorders and see if a new segment starts</comment>
        <expr_stmt><expr><name>startSeg</name> = <call><name>SetBorder</name><argument_list>(<argument><expr><name>currentBorder</name></expr></argument>, <argument><expr><name><name>lastVerBorders</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// store the border segment in the cell map and update cellBorders</comment>
        <if>if <condition>(<expr><name><name>cellEndColIndex</name> <argument_list>&lt; <argument><expr><name><name>damageArea</name>.<name>XMost</name></name>() &amp;&amp; <name>rowX</name></expr></argument> &gt;</argument_list></name>= <name><name>damageArea</name>.<name>y</name></name> &amp;&amp; <name>rowX</name> &lt; <call><name><name>damageArea</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderEdge</name></name><argument_list>(<argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>rowX</name></expr></argument>, 
                                        <argument><expr><name>cellEndColIndex</name></expr></argument>, <argument><expr><name>segLength</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>owner</name></name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><name>startSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// update the borders of the cells and cols affected </comment>
          <if>if <condition>(<expr><name><name>info</name>.<name>cell</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>SetBorderWidth</name></name><argument_list>(<argument><expr><name>secondSide</name></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>GetBorderWidth</name></name><argument_list>(<argument><expr><name>secondSide</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <if>if <condition>(<expr><name><name>info</name>.<name>rightCol</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>half</name> <init>= <expr><call><name>BC_BORDER_LEFT_HALF</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>info</name>.<name>rightCol</name>-&gt;<name>SetRightBorderWidth</name></name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>half</name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>rightCol</name>-&gt;<name>GetRightBorderWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <if>if <condition>(<expr><name><name>ajaInfo</name>.<name>cell</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>ajaInfo</name>.<name>cell</name>-&gt;<name>SetBorderWidth</name></name><argument_list>(<argument><expr><name>firstSide</name></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><call><name><name>ajaInfo</name>.<name>cell</name>-&gt;<name>GetBorderWidth</name></name><argument_list>(<argument><expr><name>firstSide</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <if>if <condition>(<expr><name><name>ajaInfo</name>.<name>leftCol</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>half</name> <init>= <expr><call><name>BC_BORDER_RIGHT_HALF</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ajaInfo</name>.<name>leftCol</name>-&gt;<name>SetLeftBorderWidth</name></name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>half</name></expr></argument>, <argument><expr><call><name><name>ajaInfo</name>.<name>leftCol</name>-&gt;<name>GetLeftBorderWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
        <comment type="line">// update the top right corner</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>hitsSpanOnRight</name> <init>= <expr>(<name>rowX</name> &gt; <name><name>ajaInfo</name>.<name>rowIndex</name></name>) &amp;&amp; (<name>rowX</name> &lt; <name><name>ajaInfo</name>.<name>rowIndex</name></name> + <name><name>ajaInfo</name>.<name>rowSpan</name></name>)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BCCornerInfo</name>*</type> <name>trCorner</name> <init>= <expr>((0 == <name>rowX</name>) || <name>hitsSpanOnRight</name>) 
                                 ? &amp;<name><name>topCorners</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name> : &amp;<name><name>bottomCorners</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt> 
        <expr_stmt><expr><call><name><name>trCorner</name>-&gt;<name>Update</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// if this is not the first time through, consider the segment to the right</comment>
        <if>if <condition>(<expr><name>rowX</name> != <name><name>info</name>.<name>rowIndex</name></name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>rg</name> <init>= <expr>(<name><name>priorAjaInfo</name>.<name>rgBottom</name></name>) ? <name><name>priorAjaInfo</name>.<name>rg</name></name> : <name>nsnull</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>rg</name></expr></argument>, <argument><expr><name><name>priorAjaInfo</name>.<name>bottomRow</name></name></expr></argument>, <argument><expr><name><name>priorAjaInfo</name>.<name>cell</name></name></expr></argument>,
                                         <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr>!<name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rg</name> = (<name><name>ajaInfo</name>.<name>rgTop</name></name>) ? <name><name>ajaInfo</name>.<name>rg</name></name> : <name>nsnull</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>adjacentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>rg</name></expr></argument>, <argument><expr><name><name>ajaInfo</name>.<name>topRow</name></name></expr></argument>, <argument><expr><name><name>ajaInfo</name>.<name>cell</name></name></expr></argument>,
                                          <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr>!<name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr>!<name>CELL_CORNER</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>, <argument><expr><name>adjacentBorder</name></expr></argument>, <argument><expr><name>HORIZONTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>trCorner</name>-&gt;<name>Update</name></name><argument_list>(<argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="line">// store the top right corner in the cell map </comment>
        <if>if <condition>(<expr><name><name>cellEndColIndex</name> <argument_list>&lt; <argument><expr><name><name>damageArea</name>.<name>XMost</name></name>() &amp;&amp; <name>rowX</name></expr></argument> &gt;</argument_list></name>= <name><name>damageArea</name>.<name>y</name></name></expr>)</condition><then> <block>{
          <if>if <condition>(<expr>0 != <name>rowX</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderCorner</name></name><argument_list>(<argument><expr><name>eTopRight</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>rowX</name></expr></argument>, <argument><expr><name>cellEndColIndex</name></expr></argument>, 
                                            <argument><expr><name><name>trCorner</name>-&gt;<name>ownerSide</name></name></expr></argument>, <argument><expr><name><name>trCorner</name>-&gt;<name>subWidth</name></name></expr></argument>, <argument><expr><name><name>trCorner</name>-&gt;<name>bevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <comment type="line">// store any corners this cell spans together with the aja cell</comment>
          <for>for (<init><decl><type><name>PRInt32</name></type> <name>rX</name> <init>= <expr><name>rowX</name> + 1</expr></init></decl>;</init> <condition><expr><name>rX</name> &lt; <name>rowX</name> + <name>segLength</name></expr>;</condition> <incr><expr><name>rX</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderCorner</name></name><argument_list>(<argument><expr><name>eBottomRight</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>rX</name></expr></argument>, 
                                            <argument><expr><name>cellEndColIndex</name></expr></argument>, <argument><expr><name><name>trCorner</name>-&gt;<name>ownerSide</name></name></expr></argument>, <argument><expr><name><name>trCorner</name>-&gt;<name>subWidth</name></name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></for>
        }</block></then></if>
        <comment type="line">// update bottom right corner, topCorners, bottomCorners</comment>
        <expr_stmt><expr><name>hitsSpanOnRight</name> = (<name>rowX</name> + <name>segLength</name> &lt; <name><name>ajaInfo</name>.<name>rowIndex</name></name> + <name><name>ajaInfo</name>.<name>rowSpan</name></name>)</expr>;</expr_stmt>
        <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>brCorner</name> <init>= <expr>(<name>hitsSpanOnRight</name>) ? <name><name>topCorners</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name> 
                                                   : <name><name>bottomCorners</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>brCorner</name>.<name>Set</name></name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>priorAjaInfo</name> = <name>ajaInfo</name></expr>;</expr_stmt>
      }</block></for>
    }</block></else></if>
    <for>for (<init><decl><type><name>PRInt32</name></type> <name>colX</name> <init>= <expr><name><name>info</name>.<name>colIndex</name></name> + 1</expr></init></decl>;</init> <condition><expr><name>colX</name> &lt;= <name>cellEndColIndex</name></expr>;</condition> <incr><expr><name>colX</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name><name>lastVerBorders</name><index>[<expr><name>colX</name></expr>]</index></name>.<call><name>Reset</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <comment type="line">// find the dominant border considering the cell's bottom border, adjacent cells and the table, row group, row</comment>
    <if>if <condition>(<expr><name>numRows</name> == <name>cellEndRowIndex</name> + 1</expr>)</condition><then> <block>{ <comment type="line">// touches bottom edge of table</comment>
      <if>if <condition>(<expr>!<name><name>tableBorderReset</name><index>[<expr><name>NS_SIDE_BOTTOM</name></expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>propData</name>-&gt;<name>mBottomBorderWidth</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tableBorderReset</name><index>[<expr><name>NS_SIDE_BOTTOM</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
      <for>for (<init><decl><type><name>PRInt32</name></type> <name>colX</name> <init>= <expr><name><name>info</name>.<name>colIndex</name></name></expr></init></decl>;</init> <condition><expr><name>colX</name> &lt;= <name>cellEndColIndex</name></expr>;</condition> <incr><expr><name>colX</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name>GetColFrame</name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>colFrame</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>cgFrame</name> <init>= <expr><call><name><name>colFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>cgFrame</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>cgFrame</name></expr></argument>, <argument><expr><name>colFrame</name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>bottomRow</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>cell</name></name></expr></argument>,
                                       <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update/store the bottom left &amp; bottom right corners </comment>
        <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>blCorner</name> <init>= <expr><name><name>bottomCorners</name><index>[<expr><name>colX</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// bottom left</comment>
        <expr_stmt><expr><call><name><name>blCorner</name>.<name>Update</name></name><argument_list>(<argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderCorner</name></name><argument_list>(<argument><expr><name>eBottomLeft</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>cellEndRowIndex</name></expr></argument>,                
                                        <argument><expr><name>colX</name></expr></argument>, <argument><expr><name><name>blCorner</name>.<name>ownerSide</name></name></expr></argument>, <argument><expr><name><name>blCorner</name>.<name>subWidth</name></name></expr></argument>, <argument><expr><name><name>blCorner</name>.<name>bevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>brCorner</name> <init>= <expr><name><name>bottomCorners</name><index>[<expr><name>colX</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// bottom right</comment>
        <expr_stmt><expr><call><name><name>brCorner</name>.<name>Update</name></name><argument_list>(<argument><expr><name>NS_SIDE_LEFT</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>numCols</name> == <name>colX</name> + 1</expr>)</condition><then> <block>{ <comment type="line">// lower right corner of the table</comment>
          <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderCorner</name></name><argument_list>(<argument><expr><name>eBottomRight</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>cellEndRowIndex</name></expr></argument>,               
                                          <argument><expr><name>colX</name></expr></argument>, <argument><expr><name><name>brCorner</name>.<name>ownerSide</name></name></expr></argument>, <argument><expr><name><name>brCorner</name>.<name>subWidth</name></name></expr></argument>, <argument><expr><name><name>brCorner</name>.<name>bevel</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
        }</block></then></if>
        <comment type="line">// update lastBottomBorder and see if a new segment starts</comment>
        <expr_stmt><expr><name>startSeg</name> = <call><name>SetHorBorder</name><argument_list>(<argument><expr><name>currentBorder</name></expr></argument>, <argument><expr><name>blCorner</name></expr></argument>, <argument><expr><name>lastBottomBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>startSeg</name></expr>)</condition><then> <block>{ 
           <comment type="line">// make sure that we did not compare apples to oranges i.e. the current border </comment>
           <comment type="line">// should be a continuation of the lastBottomBorder, as it is a bottom border </comment>
           <comment type="line">// add 1 to the cellEndRowIndex</comment>
           <expr_stmt><expr><name>startSeg</name> = (<name><name>lastBottomBorder</name>.<name>rowIndex</name></name> != <name>cellEndRowIndex</name> + 1)</expr>;</expr_stmt>
        }</block></then></if>
        <comment type="line">// store the border segment in the cell map and update cellBorders</comment>
        <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderEdge</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>cellEndRowIndex</name></expr></argument>, 
                                      <argument><expr><name>colX</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>owner</name></name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><name>startSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update the bottom borders of the cell, the bottom row, and the table </comment>
        <if>if <condition>(<expr><name><name>info</name>.<name>cell</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>SetBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>GetBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>info</name>.<name>bottomRow</name></name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>half</name> <init>= <expr><call><name>BC_BORDER_TOP_HALF</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>info</name>.<name>bottomRow</name>-&gt;<name>SetBottomBCBorderWidth</name></name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>half</name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>bottomRow</name>-&gt;<name>GetBottomBCBorderWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>propData</name>-&gt;<name>mBottomBorderWidth</name></name> = <call><name>LimitBorderWidth</name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>propData</name>-&gt;<name>mBottomBorderWidth</name></name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// update lastBottomBorders</comment>
        <expr_stmt><expr><name><name>lastBottomBorder</name>.<name>rowIndex</name></name> = <name>cellEndRowIndex</name> + 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastBottomBorder</name>.<name>rowSpan</name></name> = <name><name>info</name>.<name>rowSpan</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastBottomBorders</name><index>[<expr><name>colX</name></expr>]</index></name> = <name>lastBottomBorder</name></expr>;</expr_stmt>
        <comment type="line">//get col continuous border</comment>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>cgFrame</name></expr></argument>, <argument><expr><name>colFrame</name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>bottomRow</name></name></expr></argument>,
                                       <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>,
                                       <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>((<name>nsTableColFrame</name>*)<name>colFrame</name>)-&gt;<call><name>SetContinuousBCBorderWidth</name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>,
                                                                <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <comment type="line">//get row group/col group continuous border</comment>
      <if>if <condition>(<expr><name><name>info</name>.<name>rg</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>bottomRow</name></name></expr></argument>,
                                       <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>,
                                       <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>info</name>.<name>rg</name>-&gt;<name>SetContinuousBCBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><name><name>info</name>.<name>cg</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>info</name>.<name>cg</name></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name><name>info</name>.<name>rg</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>bottomRow</name></name></expr></argument>,
                                       <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>,
                                       <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>info</name>.<name>cg</name>-&gt;<name>SetContinuousBCBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then>
    <else>else <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>segLength</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <for>for (<init><decl><type><name>PRInt32</name></type> <name>colX</name> <init>= <expr><name><name>info</name>.<name>colIndex</name></name></expr></init></decl>;</init> <condition><expr><name>colX</name> &lt;= <name>cellEndColIndex</name></expr>;</condition> <incr><expr><name>colX</name> += <name>segLength</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name><name>iter</name>.<name>PeekBottom</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>colX</name></expr></argument>, <argument><expr><name>ajaInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>rg</name> <init>= <expr>(<name><name>info</name>.<name>rgBottom</name></name>) ? <name><name>info</name>.<name>rg</name></name> : <name>nsnull</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>rg</name></expr></argument>, <argument><expr><name><name>info</name>.<name>bottomRow</name></name></expr></argument>, <argument><expr><name><name>info</name>.<name>cell</name></name></expr></argument>, 
                                       <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr>!<name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rg</name> = (<name><name>ajaInfo</name>.<name>rgTop</name></name>) ? <name><name>ajaInfo</name>.<name>rg</name></name> : <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>adjacentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>rg</name></expr></argument>, <argument><expr><name><name>ajaInfo</name>.<name>topRow</name></name></expr></argument>, <argument><expr><name><name>ajaInfo</name>.<name>cell</name></name></expr></argument>, 
                                        <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr>!<name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr>!<name>CELL_CORNER</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>, <argument><expr><name>adjacentBorder</name></expr></argument>, <argument><expr><name>HORIZONTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>segLength</name> = <call><name>PR_MAX</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>ajaInfo</name>.<name>colIndex</name></name> + <name><name>ajaInfo</name>.<name>colSpan</name></name> - <name>colX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>segLength</name> = <call><name>PR_MIN</name><argument_list>(<argument><expr><name>segLength</name></expr></argument>, <argument><expr><name><name>info</name>.<name>colIndex</name></name> + <name><name>info</name>.<name>colSpan</name></name> - <name>colX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// update, store the bottom left corner</comment>
        <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>blCorner</name> <init>= <expr><name><name>bottomCorners</name><index>[<expr><name>colX</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// bottom left</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>hitsSpanBelow</name> <init>= <expr>(<name>colX</name> &gt; <name><name>ajaInfo</name>.<name>colIndex</name></name>) &amp;&amp; (<name>colX</name> &lt; <name><name>ajaInfo</name>.<name>colIndex</name></name> + <name><name>ajaInfo</name>.<name>colSpan</name></name>)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>update</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name>colX</name> == <name><name>info</name>.<name>colIndex</name></name>) &amp;&amp; (<name>colX</name> &gt; <name><name>damageArea</name>.<name>x</name></name>)</expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>prevRowIndex</name> <init>= <expr><name><name>lastBottomBorders</name><index>[<expr><name>colX</name> - 1</expr>]</index></name>.<name>rowIndex</name></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>prevRowIndex</name> &gt; <name>cellEndRowIndex</name> + 1</expr>)</condition><then> <block>{ <comment type="line">// hits a rowspan on the right</comment>
            <expr_stmt><expr><name>update</name> = <name>PR_FALSE</name></expr>;</expr_stmt> <comment type="line">// the corner was taken care of during the cell on the left</comment>
          }</block></then>
          <else>else <if>if <condition>(<expr><name>prevRowIndex</name> &lt; <name>cellEndRowIndex</name> + 1</expr>)</condition><then> <block>{ <comment type="line">// spans below the cell to the left</comment>
            <expr_stmt><expr><name><name>topCorners</name><index>[<expr><name>colX</name></expr>]</index></name> = <name>blCorner</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>blCorner</name>.<name>Set</name></name><argument_list>(<argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>update</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
          }</block></then></if></else></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>update</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>blCorner</name>.<name>Update</name></name><argument_list>(<argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>cellEndRowIndex</name> <argument_list>&lt; <argument><expr><name><name>damageArea</name>.<name>YMost</name></name>() &amp;&amp; <name>colX</name></expr></argument> &gt;</argument_list></name>= <name><name>damageArea</name>.<name>x</name></name></expr>)</condition><then> <block>{
          <if>if <condition>(<expr><name>hitsSpanBelow</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderCorner</name></name><argument_list>(<argument><expr><name>eBottomLeft</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>cellEndRowIndex</name></expr></argument>, <argument><expr><name>colX</name></expr></argument>,
                                            <argument><expr><name><name>blCorner</name>.<name>ownerSide</name></name></expr></argument>, <argument><expr><name><name>blCorner</name>.<name>subWidth</name></name></expr></argument>, <argument><expr><name><name>blCorner</name>.<name>bevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <comment type="line">// store any corners this cell spans together with the aja cell</comment>
          <for>for (<init><decl><type><name>PRInt32</name></type> <name>cX</name> <init>= <expr><name>colX</name> + 1</expr></init></decl>;</init> <condition><expr><name>cX</name> &lt; <name>colX</name> + <name>segLength</name></expr>;</condition> <incr><expr><name>cX</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>corner</name> <init>= <expr><name><name>bottomCorners</name><index>[<expr><name>cX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>corner</name>.<name>Set</name></name><argument_list>(<argument><expr><name>NS_SIDE_RIGHT</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderCorner</name></name><argument_list>(<argument><expr><name>eBottomLeft</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>cellEndRowIndex</name></expr></argument>,
                                            <argument><expr><name>cX</name></expr></argument>, <argument><expr><name><name>corner</name>.<name>ownerSide</name></name></expr></argument>, <argument><expr><name><name>corner</name>.<name>subWidth</name></name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></for>
        }</block></then></if>
        <comment type="line">// update lastBottomBorders and see if a new segment starts</comment>
        <expr_stmt><expr><name>startSeg</name> = <call><name>SetHorBorder</name><argument_list>(<argument><expr><name>currentBorder</name></expr></argument>, <argument><expr><name>blCorner</name></expr></argument>, <argument><expr><name>lastBottomBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>startSeg</name></expr>)</condition><then> <block>{ 
           <comment type="line">// make sure that we did not compare apples to oranges i.e. the current border </comment>
           <comment type="line">// should be a continuation of the lastBottomBorder, as it is a bottom border </comment>
           <comment type="line">// add 1 to the cellEndRowIndex</comment>
           <expr_stmt><expr><name>startSeg</name> = (<name><name>lastBottomBorder</name>.<name>rowIndex</name></name> != <name>cellEndRowIndex</name> + 1)</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>lastBottomBorder</name>.<name>rowIndex</name></name> = <name>cellEndRowIndex</name> + 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastBottomBorder</name>.<name>rowSpan</name></name> = <name><name>info</name>.<name>rowSpan</name></name></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>PRInt32</name></type> <name>cX</name> <init>= <expr><name>colX</name></expr></init></decl>;</init> <condition><expr><name>cX</name> &lt; <name>colX</name> + <name>segLength</name></expr>;</condition> <incr><expr><name>cX</name>++</expr></incr>) <block>{
          <expr_stmt><expr><name><name>lastBottomBorders</name><index>[<expr><name>cX</name></expr>]</index></name> = <name>lastBottomBorder</name></expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// store the border segment the cell map and update cellBorders</comment>
        <if>if <condition>(<expr><name><name>cellEndRowIndex</name> <argument_list>&lt; <argument><expr><name><name>damageArea</name>.<name>YMost</name></name>() &amp;&amp; <name>colX</name></expr></argument> &gt;</argument_list></name>= <name><name>damageArea</name>.<name>x</name></name> &amp;&amp; <name>colX</name> &lt; <call><name><name>damageArea</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>tableCellMap</name>-&gt;<name>SetBCBorderEdge</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr>*<name><name>info</name>.<name>cellMap</name></name></expr></argument>, <argument><expr><name><name>iter</name>.<name>mRowGroupStart</name></name></expr></argument>, <argument><expr><name>cellEndRowIndex</name></expr></argument>,
                                        <argument><expr><name>colX</name></expr></argument>, <argument><expr><name>segLength</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>owner</name></name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><name>startSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// update the borders of the affected cells and rows</comment>
          <if>if <condition>(<expr><name><name>info</name>.<name>cell</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>SetBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>cell</name>-&gt;<name>GetBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <if>if <condition>(<expr><name><name>info</name>.<name>bottomRow</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>half</name> <init>= <expr><call><name>BC_BORDER_TOP_HALF</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>info</name>.<name>bottomRow</name>-&gt;<name>SetBottomBCBorderWidth</name></name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>half</name></expr></argument>, <argument><expr><call><name><name>info</name>.<name>bottomRow</name>-&gt;<name>GetBottomBCBorderWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <if>if <condition>(<expr><name><name>ajaInfo</name>.<name>cell</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>ajaInfo</name>.<name>cell</name>-&gt;<name>SetBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>, <argument><expr><call><name><name>ajaInfo</name>.<name>cell</name>-&gt;<name>GetBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <if>if <condition>(<expr><name><name>ajaInfo</name>.<name>topRow</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>BCPixelSize</name></type> <name>half</name> <init>= <expr><call><name>BC_BORDER_BOTTOM_HALF</name><argument_list>(<argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ajaInfo</name>.<name>topRow</name>-&gt;<name>SetTopBCBorderWidth</name></name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>half</name></expr></argument>, <argument><expr><call><name><name>ajaInfo</name>.<name>topRow</name>-&gt;<name>GetTopBCBorderWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
        <comment type="line">// update bottom right corner</comment>
        <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>brCorner</name> <init>= <expr><name><name>bottomCorners</name><index>[<expr><name>colX</name> + <name>segLength</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>brCorner</name>.<name>Update</name></name><argument_list>(<argument><expr><name>NS_SIDE_LEFT</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <if>if <condition>(<expr>!<name>gotRowBorder</name> &amp;&amp; 1 == <name><name>info</name>.<name>rowSpan</name></name> &amp;&amp; (<name><name>ajaInfo</name>.<name>topRow</name></name> || <name><name>info</name>.<name>rgBottom</name></name>)</expr>)</condition><then> <block>{
        <comment type="line">//get continuous row/row group border</comment>
        <comment type="line">//we need to check the row group's bottom border if this is</comment>
        <comment type="line">//the last row in the row group, but only a cell with rowspan=1</comment>
        <comment type="line">//will know whether *this* row is at the bottom</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>rg</name> <init>= <expr>(<name><name>info</name>.<name>rgBottom</name></name>) ? <name><name>info</name>.<name>rg</name></name> : <name>nsnull</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>rg</name></expr></argument>, <argument><expr><name><name>info</name>.<name>bottomRow</name></name></expr></argument>,
                                       <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr>!<name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>,
                                       <argument><expr><name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rg</name> = (<name><name>ajaInfo</name>.<name>rgTop</name></name>) ? <name><name>ajaInfo</name>.<name>rg</name></name> : <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>adjacentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>rg</name></expr></argument>, <argument><expr><name><name>ajaInfo</name>.<name>topRow</name></name></expr></argument>,
                                        <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr>!<name>TABLE_EDGE</name></expr></argument>, <argument><expr><name>NS_SIDE_TOP</name></expr></argument>,
                                        <argument><expr>!<name>ADJACENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentBorder</name> = <call><name>CompareBorders</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>currentBorder</name></expr></argument>, <argument><expr><name>adjacentBorder</name></expr></argument>, <argument><expr><name>HORIZONTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>ajaInfo</name>.<name>topRow</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>ajaInfo</name>.<name>topRow</name>-&gt;<name>SetContinuousBCBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_TOP</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>info</name>.<name>rgBottom</name></name> &amp;&amp; <name><name>info</name>.<name>rg</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>info</name>.<name>rg</name>-&gt;<name>SetContinuousBCBorderWidth</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr><name><name>currentBorder</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>gotRowBorder</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>

    <comment type="line">// see if the cell to the right had a rowspan and its lower left border needs be joined with this one's bottom</comment>
    <if>if <condition>(<expr>(<name>numCols</name> != <name>cellEndColIndex</name> + 1) &amp;&amp;                  <comment type="line">// there is a cell to the right</comment>
        (<name><name>lastBottomBorders</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name>.<name>rowSpan</name> &gt; 1)</expr>)</condition><then> <block>{ <comment type="line">// cell to right was a rowspan</comment>
      <decl_stmt><decl><type><name>BCCornerInfo</name>&amp;</type> <name>corner</name> <init>= <expr><name><name>bottomCorners</name><index>[<expr><name>cellEndColIndex</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>(<name>NS_SIDE_TOP</name> != <name><name>corner</name>.<name>ownerSide</name></name>) &amp;&amp; (<name>NS_SIDE_BOTTOM</name> != <name><name>corner</name>.<name>ownerSide</name></name>)</expr>)</condition><then> <block>{ <comment type="line">// not a vertical owner</comment>
        <decl_stmt><decl><type><name>BCCellBorder</name>&amp;</type> <name>thisBorder</name> <init>= <expr><name>lastBottomBorder</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BCCellBorder</name>&amp;</type> <name>nextBorder</name> <init>= <expr><name><name>lastBottomBorders</name><index>[<expr><name><name>info</name>.<name>colIndex</name></name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name><name>thisBorder</name>.<name>color</name></name> == <name><name>nextBorder</name>.<name>color</name></name>) &amp;&amp; (<name><name>thisBorder</name>.<name>width</name></name> == <name><name>nextBorder</name>.<name>width</name></name>) &amp;&amp;
            (<name><name>thisBorder</name>.<name>style</name></name> == <name><name>nextBorder</name>.<name>style</name></name>)</expr>)</condition><then> <block>{
          <comment type="line">// set the flag on the next border indicating it is not the start of a new segment</comment>
          <if>if <condition>(<expr><name><name>iter</name>.<name>mCellMap</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>BCData</name>*</type> <name>bcData</name> <init>= <expr><call><name><name>tableCellMap</name>-&gt;<name>GetBCData</name></name><argument_list>(<argument><expr><name>NS_SIDE_BOTTOM</name></expr></argument>, <argument><expr>*<name><name>iter</name>.<name>mCellMap</name></name></expr></argument>, <argument><expr><name>cellEndRowIndex</name></expr></argument>, 
                                                     <argument><expr><name>cellEndColIndex</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>bcData</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name><name>bcData</name>-&gt;<name>SetTopStart</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></for> <comment type="line">// for (iter.First(info); info.cell; iter.Next(info)) {</comment>

  <comment type="line">// reset the bc flag and damage area</comment>
  <expr_stmt><expr><call><name>SetNeedToCalcBCBorders</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>propData</name>-&gt;<name>mDamageArea</name>.<name>x</name></name> = <name><name>propData</name>-&gt;<name>mDamageArea</name>.<name>y</name></name> = <name><name>propData</name>-&gt;<name>mDamageArea</name>.<name>width</name></name> = <name><name>propData</name>-&gt;<name>mDamageArea</name>.<name>height</name></name> = 0</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TABLE_CELLMAP</name></cpp:ifdef>
  <expr_stmt><expr><call><name><name>mCellMap</name>-&gt;<name>Dump</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="line">// Iterates over borders (left border, corner, top border) in the cell map within a damage area</comment>
<comment type="line">// from left to right, top to bottom. All members are in terms of the 1st in flow frames, except </comment>
<comment type="line">// where suffixed by InFlow.  </comment>
<class>class <name>BCMapBorderIterator</name>
<block>{<private type="default">
</private><public>public:
  <constructor_decl><name>BCMapBorderIterator</name><parameter_list>(<param><decl><type><name>nsTableFrame</name>&amp;</type>         <name>aTableFrame</name></decl></param>,
                      <param><decl><type><name>nsTableRowGroupFrame</name>&amp;</type> <name>aRowGroupFrame</name></decl></param>,
                      <param><decl><type><name>nsTableRowFrame</name>&amp;</type>      <name>aRowFrame</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>         <name>aDamageArea</name></decl></param>)</parameter_list>;</constructor_decl>
  <function_decl><type><name>void</name></type> <name>Reset</name><parameter_list>(<param><decl><type><name>nsTableFrame</name>&amp;</type>         <name>aTableFrame</name></decl></param>,
             <param><decl><type><name>nsTableRowGroupFrame</name>&amp;</type> <name>aRowGroupFrame</name></decl></param>,
             <param><decl><type><name>nsTableRowFrame</name>&amp;</type>      <name>aRowFrame</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>         <name>aDamageArea</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>First</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>Next</name><parameter_list>()</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>nsTableFrame</name>*</type>         <name>table</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type>       <name>tableCellMap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCellMap</name>*</type>            <name>cellMap</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsTableFrame</name>::<name>RowGroupArray</name></name></type> <name>rowGroups</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>prevRg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>rowGroupIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>fifRowGroupStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>rowGroupStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>rowGroupEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>numRows</name></decl>;</decl_stmt> <comment type="line">// number of rows in the table and all continuations</comment>

  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type>      <name>prevRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type>      <name>row</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>numCols</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>y</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsTableCellFrame</name>*</type>     <name>prevCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellFrame</name>*</type>     <name>cell</name></decl>;</decl_stmt>  
  <decl_stmt><decl><type><name>BCCellData</name>*</type>           <name>prevCellData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCCellData</name>*</type>           <name>cellData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCData</name>*</type>               <name>bcData</name></decl>;</decl_stmt>

  <function><type><name>PRBool</name></type>                <name>IsTopMostTable</name><parameter_list>()</parameter_list>    <block>{ <return>return <expr>(<name>y</name> == 0) &amp;&amp; !<call><name><name>table</name>-&gt;<name>GetPrevInFlow</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
  <function><type><name>PRBool</name></type>                <name>IsRightMostTable</name><parameter_list>()</parameter_list>  <block>{ <return>return <expr>(<name>x</name> &gt;= <name>numCols</name>)</expr>;</return> }</block></function>
  <function><type><name>PRBool</name></type>                <name>IsBottomMostTable</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>y</name> &gt;= <name>numRows</name>) &amp;&amp; !<call><name><name>table</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
  <function><type><name>PRBool</name></type>                <name>IsLeftMostTable</name><parameter_list>()</parameter_list>   <block>{ <return>return <expr>(<name>x</name> == 0)</expr>;</return> }</block></function>
  <function><type><name>PRBool</name></type>                <name>IsTopMost</name><parameter_list>()</parameter_list>    <block>{ <return>return <expr>(<name>y</name> == <name>startY</name>)</expr>;</return> }</block></function>
  <function><type><name>PRBool</name></type>                <name>IsRightMost</name><parameter_list>()</parameter_list>  <block>{ <return>return <expr>(<name>x</name> &gt;= <name>endX</name>)</expr>;</return> }</block></function>
  <function><type><name>PRBool</name></type>                <name>IsBottomMost</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>y</name> &gt;= <name>endY</name>)</expr>;</return> }</block></function>
  <function><type><name>PRBool</name></type>                <name>IsLeftMost</name><parameter_list>()</parameter_list>   <block>{ <return>return <expr>(<name>x</name> == <name>startX</name>)</expr>;</return> }</block></function>
  <decl_stmt><decl><type><name>PRBool</name></type>                <name>isNewRow</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>startX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>startY</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>endX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>endY</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>                <name>isRepeatedHeader</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>                <name>isRepeatedFooter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>                <name>atEnd</name></decl>;</decl_stmt>

</public><private>private:

  <function_decl><type><name>PRBool</name></type> <name>SetNewRow</name><parameter_list>(<param><decl><type><name>nsTableRowFrame</name>*</type> <name>aRow</name> <init>= <expr><name>nsnull</name></expr></init></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>SetNewRowGroup</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type>   <name>SetNewData</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aY</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aX</name></decl></param>)</parameter_list>;</function_decl>

</private>}</block>;</class>

<constructor><name><name>BCMapBorderIterator</name>::<name>BCMapBorderIterator</name></name><parameter_list>(<param><decl><type><name>nsTableFrame</name>&amp;</type>         <name>aTable</name></decl></param>,
                                         <param><decl><type><name>nsTableRowGroupFrame</name>&amp;</type> <name>aRowGroup</name></decl></param>,
                                         <param><decl><type><name>nsTableRowFrame</name>&amp;</type>      <name>aRow</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>         <name>aDamageArea</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>Reset</name><argument_list>(<argument><expr><name>aTable</name></expr></argument>, <argument><expr><name>aRowGroup</name></expr></argument>, <argument><expr><name>aRow</name></expr></argument>, <argument><expr><name>aDamageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<function><type><name>void</name></type>
<name><name>BCMapBorderIterator</name>::<name>Reset</name></name><parameter_list>(<param><decl><type><name>nsTableFrame</name>&amp;</type>         <name>aTable</name></decl></param>,
                           <param><decl><type><name>nsTableRowGroupFrame</name>&amp;</type> <name>aRowGroup</name></decl></param>,
                           <param><decl><type><name>nsTableRowFrame</name>&amp;</type>      <name>aRow</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>         <name>aDamageArea</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>atEnd</name> = <name>PR_TRUE</name></expr>;</expr_stmt> <comment type="line">// gets reset when First() is called</comment>

  <expr_stmt><expr><name>table</name>   = &amp;<name>aTable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rg</name>      = &amp;<name>aRowGroup</name></expr>;</expr_stmt> 
  <expr_stmt><expr><name>prevRow</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>row</name>     = &amp;<name>aRow</name></expr>;</expr_stmt>                     

  <decl_stmt><decl><type><name>nsTableFrame</name>*</type> <name>tableFif</name> <init>= <expr>(<name>nsTableFrame</name>*)<call><name><name>table</name>-&gt;<name>GetFirstInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>tableFif</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>tableCellMap</name> = <call><name><name>tableFif</name>-&gt;<name>GetCellMap</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>startX</name>   = <name><name>aDamageArea</name>.<name>x</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>startY</name>   = <name><name>aDamageArea</name>.<name>y</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>endY</name>     = <name><name>aDamageArea</name>.<name>y</name></name> + <name><name>aDamageArea</name>.<name>height</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>endX</name>     = <name><name>aDamageArea</name>.<name>x</name></name> + <name><name>aDamageArea</name>.<name>width</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>numRows</name>       = <call><name><name>tableFif</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>y</name>             = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>numCols</name>       = <call><name><name>tableFif</name>-&gt;<name>GetColCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name>             = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>rowGroupIndex</name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>prevCell</name>      = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cell</name>          = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>prevCellData</name>  = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cellData</name>      = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>bcData</name>        = <name>nsnull</name></expr>;</expr_stmt>

  <comment type="line">// Get the ordered row groups </comment>
  <expr_stmt><expr><call><name><name>table</name>-&gt;<name>OrderRowGroups</name></name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> 
<name><name>BCMapBorderIterator</name>::<name>SetNewData</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aY</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aX</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>tableCellMap</name> || !<name><name>tableCellMap</name>-&gt;<name>mBCInfo</name></name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>x</name>            = <name>aX</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>y</name>            = <name>aY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>prevCellData</name> = <name>cellData</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>IsRightMost</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>IsBottomMost</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>cell</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bcData</name> = &amp;<name><name>tableCellMap</name>-&gt;<name>mBCInfo</name>-&gt;<name>mLowerRightCorner</name></name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name>IsRightMost</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>cellData</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bcData</name> = (<name>BCData</name>*)<call><name><name>tableCellMap</name>-&gt;<name>mBCInfo</name>-&gt;<name>mRightBorders</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>aY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name>IsBottomMost</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>cellData</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bcData</name> = (<name>BCData</name>*)<call><name><name>tableCellMap</name>-&gt;<name>mBCInfo</name>-&gt;<name>mBottomBorders</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>aX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <if>if <condition>(<expr><call><name>PRUint32</name><argument_list>(<argument><expr><name>y</name> - <name>fifRowGroupStart</name></expr></argument>)</argument_list></call> &lt; <call><name><name>cellMap</name>-&gt;<name>mRows</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ 
      <expr_stmt><expr><name>bcData</name> = <name>nsnull</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cellData</name> =
        (<name>BCCellData</name>*)<name><name>cellMap</name>-&gt;<name>mRows</name><index>[<expr><name>y</name> - <name>fifRowGroupStart</name></expr>]</index></name>.<call><name>SafeElementAt</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>cellData</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>bcData</name> = &amp;<name><name>cellData</name>-&gt;<name>mData</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>cellData</name>-&gt;<name>IsOrig</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <if>if <condition>(<expr><call><name><name>cellData</name>-&gt;<name>IsRowSpan</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>aY</name> -= <call><name><name>cellData</name>-&gt;<name>GetRowSpanOffset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <if>if <condition>(<expr><call><name><name>cellData</name>-&gt;<name>IsColSpan</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>aX</name> -= <call><name><name>cellData</name>-&gt;<name>GetColSpanOffset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <if>if <condition>(<expr>(<name>aX</name> &gt;= 0) &amp;&amp; (<name>aY</name> &gt;= 0)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cellData</name> = (<name>BCCellData</name>*)<name><name>cellMap</name>-&gt;<name>mRows</name><index>[<expr><name>aY</name> - <name>fifRowGroupStart</name></expr>]</index><index>[<expr><name>aX</name></expr>]</index></name></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>cellData</name>-&gt;<name>IsOrig</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>prevCell</name> = <name>cell</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cell</name> = <call><name><name>cellData</name>-&gt;<name>GetCellFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></else></if></else></if></else></if>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>BCMapBorderIterator</name>::<name>SetNewRow</name></name><parameter_list>(<param><decl><type><name>nsTableRowFrame</name>*</type> <name>aRow</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>prevRow</name> = <name>row</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>row</name>      = (<name>aRow</name>) ? <name>aRow</name> : <call><name><name>row</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 
  <if>if <condition>(<expr><name>row</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>isNewRow</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> = <call><name><name>row</name>-&gt;<name>GetRowIndex</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> = <name>startX</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>atEnd</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr>!<name>atEnd</name></expr>;</return>
}</block></function>


<function><type><name>PRBool</name></type>
<name><name>BCMapBorderIterator</name>::<name>SetNewRowGroup</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>rowGroupIndex</name>++</expr>;</expr_stmt>

  <expr_stmt><expr><name>isRepeatedHeader</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>isRepeatedFooter</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>rowGroupIndex</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>prevRg</name> = <name>rg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rg</name> = <name><name>rowGroups</name><index>[<expr><name>rowGroupIndex</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>fifRowGroupStart</name> = ((<name>nsTableRowGroupFrame</name>*)<call><name><name>rg</name>-&gt;<name>GetFirstInFlow</name></name><argument_list>()</argument_list></call>)-&gt;<call><name>GetStartRowIndex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rowGroupStart</name>    = <call><name><name>rg</name>-&gt;<name>GetStartRowIndex</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><name>rowGroupEnd</name>      = <name>rowGroupStart</name> + <call><name><name>rg</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call> - 1</expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>SetNewRow</name><argument_list>(<argument><expr><call><name><name>rg</name>-&gt;<name>GetFirstRow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>cellMap</name> =
        <call><name><name>tableCellMap</name>-&gt;<name>GetMapFor</name></name><argument_list>(<argument><expr>(<name>nsTableRowGroupFrame</name>*)<call><name><name>rg</name>-&gt;<name>GetFirstInFlow</name></name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>cellMap</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT1</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>rg</name> &amp;&amp; <call><name><name>table</name>-&gt;<name>GetPrevInFlow</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>rg</name>-&gt;<name>GetPrevInFlow</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// if rg doesn't have a prev in flow, then it may be a repeated header or footer</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>display</name> <init>= <expr><call><name><name>rg</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>y</name> == <name>startY</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>isRepeatedHeader</name> = (<name>NS_STYLE_DISPLAY_TABLE_HEADER_GROUP</name> == <name><name>display</name>-&gt;<name>mDisplay</name></name>)</expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><name>isRepeatedFooter</name> = (<name>NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP</name> == <name><name>display</name>-&gt;<name>mDisplay</name></name>)</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>atEnd</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr>!<name>atEnd</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> 
<name><name>BCMapBorderIterator</name>::<name>First</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>table</name> || (<name>startX</name> &gt;= <name>numCols</name>) || (<name>startY</name> &gt;= <name>numRows</name>)</expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>atEnd</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>numRowGroups</name> <init>= <expr><call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>rgX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rgX</name> &lt; <name>numRowGroups</name></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{ 
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rowG</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>start</name> <init>= <expr><call><name><name>rowG</name>-&gt;<name>GetStartRowIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>end</name>   <init>= <expr><name>start</name> + <call><name><name>rowG</name>-&gt;<name>GetRowCount</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>(<name>startY</name> &gt;= <name>start</name>) &amp;&amp; (<name>startY</name> &lt;= <name>end</name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rowGroupIndex</name> = <name>rgX</name> - 1</expr>;</expr_stmt> <comment type="line">// SetNewRowGroup increments rowGroupIndex</comment>
      <if>if <condition>(<expr><call><name>SetNewRowGroup</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ 
        <while>while <condition>(<expr>(<name>y</name> &lt; <name>startY</name>) &amp;&amp; !<name>atEnd</name></expr>)</condition> <block>{
          <expr_stmt><expr><call><name>SetNewRow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr>!<name>atEnd</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>SetNewData</name><argument_list>(<argument><expr><name>startY</name></expr></argument>, <argument><expr><name>startX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <return>return;</return>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><name>atEnd</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> 
<name><name>BCMapBorderIterator</name>::<name>Next</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>atEnd</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>isNewRow</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>x</name>++</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>x</name> &gt; <name>endX</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>y</name>++</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>y</name> == <name>endY</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>x</name> = <name>startX</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>y</name> &lt; <name>endY</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>y</name> &lt;= <name>rowGroupEnd</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetNewRow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>SetNewRowGroup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>atEnd</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></then></if>
  <if>if <condition>(<expr>!<name>atEnd</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SetNewData</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">// XXX if CalcVerCornerOffset and CalcHorCornerOffset remain similar, combine them</comment>
<function><type><specifier>static</specifier> <name>nscoord</name></type>
<name>CalcVerCornerOffset</name><parameter_list>(<param><decl><type><name>PRUint8</name></type> <name>aCornerOwnerSide</name></decl></param>,
                    <param><decl><type><name>nscoord</name></type> <name>aCornerSubWidth</name></decl></param>,
                    <param><decl><type><name>nscoord</name></type> <name>aHorWidth</name></decl></param>,
                    <param><decl><type><name>PRBool</name></type>  <name>aIsStartOfSeg</name></decl></param>,
                    <param><decl><type><name>PRBool</name></type>  <name>aIsBevel</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <comment type="line">// XXX These should be replaced with appropriate side-specific macros (which?).</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>smallHalf</name></decl>, <decl><type ref="prev"/><name>largeHalf</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>NS_SIDE_TOP</name> == <name>aCornerOwnerSide</name>) || (<name>NS_SIDE_BOTTOM</name> == <name>aCornerOwnerSide</name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>DivideBCBorderSize</name><argument_list>(<argument><expr><name>aCornerSubWidth</name></expr></argument>, <argument><expr><name>smallHalf</name></expr></argument>, <argument><expr><name>largeHalf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>aIsBevel</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>offset</name> = (<name>aIsStartOfSeg</name>) ? -<name>largeHalf</name> : <name>smallHalf</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>offset</name> = (<name>NS_SIDE_TOP</name> == <name>aCornerOwnerSide</name>) ? <name>smallHalf</name> : -<name>largeHalf</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>DivideBCBorderSize</name><argument_list>(<argument><expr><name>aHorWidth</name></expr></argument>, <argument><expr><name>smallHalf</name></expr></argument>, <argument><expr><name>largeHalf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>aIsBevel</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>offset</name> = (<name>aIsStartOfSeg</name>) ? -<name>largeHalf</name> : <name>smallHalf</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>offset</name> = (<name>aIsStartOfSeg</name>) ? <name>smallHalf</name> : -<name>largeHalf</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
  <return>return <expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/** Compute the horizontal offset of a horizontal border segment
  * @param aCornerOwnerSide - which side owns the corner
  * @param aCornerSubWidth  - how wide is the nonwinning side of the corner
  * @param aVerWidth        - how wide is the vertical edge of the corner
  * @param aIsStartOfSeg    - does this corner start a new segment
  * @param aIsBevel         - is this corner beveled
  * @param aPixelsToTwips   - conversion factor
  * @param aTableIsLTR      - direction, the computation depends on ltr or rtl
  * @return                 - offset in pixel
  */</comment>
<function><type><specifier>static</specifier> <name>nscoord</name></type>
<name>CalcHorCornerOffset</name><parameter_list>(<param><decl><type><name>PRUint8</name></type> <name>aCornerOwnerSide</name></decl></param>,
                    <param><decl><type><name>nscoord</name></type> <name>aCornerSubWidth</name></decl></param>,
                    <param><decl><type><name>nscoord</name></type> <name>aVerWidth</name></decl></param>,
                    <param><decl><type><name>PRBool</name></type>  <name>aIsStartOfSeg</name></decl></param>,
                    <param><decl><type><name>PRBool</name></type>  <name>aIsBevel</name></decl></param>,
                    <param><decl><type><name>PRBool</name></type>  <name>aTableIsLTR</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <comment type="line">// XXX These should be replaced with appropriate side-specific macros (which?).</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>smallHalf</name></decl>, <decl><type ref="prev"/><name>largeHalf</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>NS_SIDE_LEFT</name> == <name>aCornerOwnerSide</name>) || (<name>NS_SIDE_RIGHT</name> == <name>aCornerOwnerSide</name>)</expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>aTableIsLTR</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>DivideBCBorderSize</name><argument_list>(<argument><expr><name>aCornerSubWidth</name></expr></argument>, <argument><expr><name>smallHalf</name></expr></argument>, <argument><expr><name>largeHalf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>DivideBCBorderSize</name><argument_list>(<argument><expr><name>aCornerSubWidth</name></expr></argument>, <argument><expr><name>largeHalf</name></expr></argument>, <argument><expr><name>smallHalf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr><name>aIsBevel</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>offset</name> = (<name>aIsStartOfSeg</name>) ? -<name>largeHalf</name> : <name>smallHalf</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>offset</name> = (<name>NS_SIDE_LEFT</name> == <name>aCornerOwnerSide</name>) ? <name>smallHalf</name> : -<name>largeHalf</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then>
  <else>else <block>{
    <if>if <condition>(<expr><name>aTableIsLTR</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>DivideBCBorderSize</name><argument_list>(<argument><expr><name>aVerWidth</name></expr></argument>, <argument><expr><name>smallHalf</name></expr></argument>, <argument><expr><name>largeHalf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>DivideBCBorderSize</name><argument_list>(<argument><expr><name>aVerWidth</name></expr></argument>, <argument><expr><name>largeHalf</name></expr></argument>, <argument><expr><name>smallHalf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr><name>aIsBevel</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>offset</name> = (<name>aIsStartOfSeg</name>) ? -<name>largeHalf</name> : <name>smallHalf</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>offset</name> = (<name>aIsStartOfSeg</name>) ? <name>smallHalf</name> : -<name>largeHalf</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
  <return>return <expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<struct>struct <name>BCVerticalSeg</name>
<block>{<public type="default">
  <constructor_decl><name>BCVerticalSeg</name><parameter_list>()</parameter_list>;</constructor_decl>
 
  <function_decl><type><name>void</name></type> <name>Start</name><parameter_list>(<param><decl><type><name>BCMapBorderIterator</name>&amp;</type> <name>aIter</name></decl></param>,
             <param><decl><type><name>BCBorderOwner</name></type>        <name>aBorderOwner</name></decl></param>,
             <param><decl><type><name>nscoord</name></type>              <name>aVerSegWidth</name></decl></param>,
             <param><decl><type><name>nscoord</name></type>              <name>aPrevHorSegHeight</name></decl></param>,
             <param><decl><type><name>nscoord</name></type>              <name>aHorSegHeight</name></decl></param>,
             <param><decl><type><name>BCVerticalSeg</name>*</type>       <name>aVerInfoArray</name></decl></param>)</parameter_list>;</function_decl>
  
  <union>union <block>{<public type="default">
    <decl_stmt><decl><type><name>nsTableColFrame</name>*</type>  <name>col</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type>           <name>colWidth</name></decl>;</decl_stmt>
  </public>}</block>;</union>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>colX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellFrame</name>*</type>     <name>ajaCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellFrame</name>*</type>     <name>firstCell</name></decl>;</decl_stmt>  <comment type="line">// cell at the start of the segment</comment>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>firstRowGroup</name></decl>;</decl_stmt> <comment type="line">// row group at the start of the segment</comment>
  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type>      <name>firstRow</name></decl>;</decl_stmt> <comment type="line">// row at the start of the segment</comment>
  <decl_stmt><decl><type><name>nsTableCellFrame</name>*</type>     <name>lastCell</name></decl>;</decl_stmt>   <comment type="line">// cell at the current end of the segment</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>segY</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>               <name>segHeight</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt16</name></type>               <name>segWidth</name></decl>;</decl_stmt>   <comment type="line">// width in pixels</comment>
  <decl_stmt><decl><type><name>PRUint8</name></type>               <name>owner</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint8</name></type>               <name>bevelSide</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint16</name></type>              <name>bevelOffset</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<constructor><name><name>BCVerticalSeg</name>::<name>BCVerticalSeg</name></name><parameter_list>()</parameter_list> 
<block>{ 
  <expr_stmt><expr><name>col</name> = <name>nsnull</name></expr>;</expr_stmt> <expr_stmt><expr><name>firstCell</name> = <name>lastCell</name> = <name>ajaCell</name> = <name>nsnull</name></expr>;</expr_stmt> <expr_stmt><expr><name>colX</name> = <name>segY</name> = <name>segHeight</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>segWidth</name> = <name>bevelOffset</name> = 0</expr>;</expr_stmt> <expr_stmt><expr><name>bevelSide</name> = 0</expr>;</expr_stmt> <expr_stmt><expr><name>owner</name> = <name>eCellOwner</name></expr>;</expr_stmt> 
}</block></constructor>
 
<function><type><name>void</name></type>
<name><name>BCVerticalSeg</name>::<name>Start</name></name><parameter_list>(<param><decl><type><name>BCMapBorderIterator</name>&amp;</type> <name>aIter</name></decl></param>,
                     <param><decl><type><name>BCBorderOwner</name></type>        <name>aBorderOwner</name></decl></param>,
                     <param><decl><type><name>nscoord</name></type>              <name>aVerSegWidth</name></decl></param>,
                     <param><decl><type><name>nscoord</name></type>              <name>aPrevHorSegHeight</name></decl></param>,
                     <param><decl><type><name>nscoord</name></type>              <name>aHorSegHeight</name></decl></param>,
                     <param><decl><type><name>BCVerticalSeg</name>*</type>       <name>aVerInfoArray</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRUint8</name></type>      <name>ownerSide</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>bevel</name>     <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>      <name>xAdj</name>      <init>= <expr><name><name>aIter</name>.<name>x</name></name> - <name><name>aIter</name>.<name>startX</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nscoord</name></type> <name>cornerSubWidth</name>  <init>= <expr>(<name><name>aIter</name>.<name>bcData</name></name>) ? <call><name><name>aIter</name>.<name>bcData</name>-&gt;<name>GetCorner</name></name><argument_list>(<argument><expr><name>ownerSide</name></expr></argument>, <argument><expr><name>bevel</name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>  <name>topBevel</name>        <init>= <expr>(<name>aVerSegWidth</name> &gt; 0) ? <name>bevel</name> : <name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>maxHorSegHeight</name> <init>= <expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>aPrevHorSegHeight</name></expr></argument>, <argument><expr><name>aHorSegHeight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>offset</name>          <init>= <expr><call><name>CalcVerCornerOffset</name><argument_list>(<argument><expr><name>ownerSide</name></expr></argument>, <argument><expr><name>cornerSubWidth</name></expr></argument>, <argument><expr><name>maxHorSegHeight</name></expr></argument>, 
                                                <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>topBevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>bevelOffset</name>   = (<name>topBevel</name>) ? <name>maxHorSegHeight</name> : 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>bevelSide</name>     = (<name>aHorSegHeight</name> &gt; 0) ? <name>NS_SIDE_RIGHT</name> : <name>NS_SIDE_LEFT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>segY</name>         += <name>offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>segHeight</name>     = -<name>offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>segWidth</name>      = <name>aVerSegWidth</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>owner</name>         = <name>aBorderOwner</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>firstCell</name>     = <name><name>aIter</name>.<name>cell</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>firstRowGroup</name> = <name><name>aIter</name>.<name>rg</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>firstRow</name>      = <name><name>aIter</name>.<name>row</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>xAdj</name> &gt; 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>ajaCell</name> = <name><name>aVerInfoArray</name><index>[<expr><name>xAdj</name> - 1</expr>]</index></name>.<name>lastCell</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<struct>struct <name>BCHorizontalSeg</name>
<block>{<public type="default">
  <constructor_decl><name>BCHorizontalSeg</name><parameter_list>()</parameter_list>;</constructor_decl>

  <function_decl><type><name>void</name></type> <name>Start</name><parameter_list>(<param><decl><type><name>BCMapBorderIterator</name>&amp;</type> <name>aIter</name></decl></param>,
             <param><decl><type><name>BCBorderOwner</name></type>        <name>aBorderOwner</name></decl></param>,
             <param><decl><type><name>PRUint8</name></type>              <name>aCornerOwnerSide</name></decl></param>,
             <param><decl><type><name>nscoord</name></type>              <name>aSubWidth</name></decl></param>,
             <param><decl><type><name>PRBool</name></type>               <name>aBevel</name></decl></param>,
             <param><decl><type><name>nscoord</name></type>              <name>aTopVerSegWidth</name></decl></param>,
             <param><decl><type><name>nscoord</name></type>              <name>aBottomVerSegWidth</name></decl></param>,
             <param><decl><type><name>nscoord</name></type>              <name>aHorSegHeight</name></decl></param>,
             <param><decl><type><name>nsTableCellFrame</name>*</type>    <name>aLastCell</name></decl></param>,
             <param><decl><type><name>PRBool</name></type>               <name>aTableIsLTR</name></decl></param>)</parameter_list>;</function_decl>
  
  <decl_stmt><decl><type><name>nscoord</name></type>            <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type>            <name>y</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type>            <name>width</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type>            <name>height</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>             <name>leftBevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type>            <name>leftBevelOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint8</name></type>            <name>leftBevelSide</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint8</name></type>            <name>owner</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellFrame</name>*</type>  <name>firstCell</name></decl>;</decl_stmt> <comment type="line">// cell at the start of the segment</comment>
  <decl_stmt><decl><type><name>nsTableCellFrame</name>*</type>  <name>ajaCell</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<constructor><name><name>BCHorizontalSeg</name>::<name>BCHorizontalSeg</name></name><parameter_list>()</parameter_list> 
<block>{ 
  <expr_stmt><expr><name>x</name> = <name>y</name> = <name>width</name> = <name>height</name> = <name>leftBevel</name> = <name>leftBevelOffset</name> = <name>leftBevelSide</name> = 0</expr>;</expr_stmt> 
  <expr_stmt><expr><name>firstCell</name> = <name>ajaCell</name> = <name>nsnull</name></expr>;</expr_stmt>
}</block></constructor>
  
<comment type="block" format="doxygen">/** Initialize a horizontal border segment for painting
  * @param aIter              - iterator storing the current and adjacent frames
  * @param aBorderOwner       - which frame owns the border
  * @param aCornerOwnerSide   - which side owns the starting corner
  * @param aSubWidth          - how wide is the nonowning width of the corner
  * @param aBevel             - is the corner beveled
  * @param aTopVerSegWidth    - vertical segment width going down
  * @param aBottomVerSegWidth - vertical segment width coming from up
  * @param aHorSegHeight      - the height of the segment
  * @param aLastCell          - cell frame above this segment
  * @param aPixelsToTwips     - conversion factor
  * @param aTableIsLTR        - direction, the computation depends on ltr or rtl
  */</comment>
<function><type><name>void</name></type>
<name><name>BCHorizontalSeg</name>::<name>Start</name></name><parameter_list>(<param><decl><type><name>BCMapBorderIterator</name>&amp;</type> <name>aIter</name></decl></param>,
                       <param><decl><type><name>BCBorderOwner</name></type>        <name>aBorderOwner</name></decl></param>,
                       <param><decl><type><name>PRUint8</name></type>              <name>aCornerOwnerSide</name></decl></param>,
                       <param><decl><type><name>nscoord</name></type>              <name>aSubWidth</name></decl></param>,
                       <param><decl><type><name>PRBool</name></type>               <name>aBevel</name></decl></param>,
                       <param><decl><type><name>nscoord</name></type>              <name>aTopVerSegWidth</name></decl></param>,
                       <param><decl><type><name>nscoord</name></type>              <name>aBottomVerSegWidth</name></decl></param>,
                       <param><decl><type><name>nscoord</name></type>              <name>aHorSegHeight</name></decl></param>,
                       <param><decl><type><name>nsTableCellFrame</name>*</type>    <name>aLastCell</name></decl></param>,
                       <param><decl><type><name>PRBool</name></type>               <name>aTableIsLTR</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>owner</name> = <name>aBorderOwner</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>leftBevel</name> = (<name>aHorSegHeight</name> &gt; 0) ? <name>aBevel</name> : <name>PR_FALSE</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>maxVerSegWidth</name> <init>= <expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>aTopVerSegWidth</name></expr></argument>, <argument><expr><name>aBottomVerSegWidth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>offset</name> <init>= <expr><call><name>CalcHorCornerOffset</name><argument_list>(<argument><expr><name>aCornerOwnerSide</name></expr></argument>, <argument><expr><name>aSubWidth</name></expr></argument>, <argument><expr><name>maxVerSegWidth</name></expr></argument>, 
                                       <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>leftBevel</name></expr></argument>, <argument><expr><name>aTableIsLTR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>leftBevelOffset</name> = (<name>leftBevel</name> &amp;&amp; (<name>aHorSegHeight</name> &gt; 0)) ? <name>maxVerSegWidth</name> : 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>leftBevelSide</name>   = (<name>aBottomVerSegWidth</name> &gt; 0) ? <name>NS_SIDE_BOTTOM</name> : <name>NS_SIDE_TOP</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aTableIsLTR</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>x</name>            += <name>offset</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>x</name>            -= <name>offset</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>width</name>           = -<name>offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>height</name>          = <name>aHorSegHeight</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>firstCell</name>       = <name><name>aIter</name>.<name>cell</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ajaCell</name>         = (<call><name><name>aIter</name>.<name>IsTopMost</name></name><argument_list>()</argument_list></call>) ? <name>nsnull</name> : <name>aLastCell</name></expr>;</expr_stmt> 
}</block></function>

<function><type><name>void</name></type> 
<name><name>nsTableFrame</name>::<name>PaintBCBorders</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name>&amp;</type> <name>aRenderingContext</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>        <name>aDirtyRect</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsMargin</name></type> <name>childAreaOffset</name> <init>= <expr><call><name>GetChildAreaOffset</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableFrame</name>*</type> <name>firstInFlow</name> <init>= <expr>(<name>nsTableFrame</name>*)<call><name>GetFirstInFlow</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>firstInFlow</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startRowY</name> <init>= <expr>(<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call>) ? 0 : <name><name>childAreaOffset</name>.<name>top</name></name></expr></init></decl>;</decl_stmt> <comment type="line">// y position of first row in damage area</comment>

  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleBackground</name>*</type> <name>bgColor</name> <init>= <expr><call><name><name>nsCSSRendering</name>::<name>FindNonTransparentBackground</name></name><argument_list>(<argument><expr><name>mStyleContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// determine the damage area in terms of rows and columns and finalize startColX and startRowY</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>startRowIndex</name></decl>, <decl><type ref="prev"/><name>endRowIndex</name></decl>, <decl><type ref="prev"/><name>startColIndex</name></decl>, <decl><type ref="prev"/><name>endColIndex</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>startRowIndex</name> = <name>endRowIndex</name> = <name>startColIndex</name> = <name>endColIndex</name> = 0</expr>;</expr_stmt>

  <decl_stmt><decl><type><name>RowGroupArray</name></type> <name>rowGroups</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OrderRowGroups</name><argument_list>(<argument><expr><name>rowGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>done</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>haveIntersect</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>inFlowRG</name>  <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type>      <name>inFlowRow</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <comment type="line">// find startRowIndex, endRowIndex, startRowY</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>rowY</name> <init>= <expr><name>startRowY</name></expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>rgX</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>rgX</name> &lt; <call><name><name>rowGroups</name>.<name>Length</name></name><argument_list>()</argument_list></call> &amp;&amp; !<name>done</name></expr>;</condition> <incr><expr><name>rgX</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rgFrame</name> <init>= <expr><name><name>rowGroups</name><index>[<expr><name>rgX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>nsTableRowFrame</name>*</type> <name>rowFrame</name> <init>= <expr><call><name><name>rgFrame</name>-&gt;<name>GetFirstRow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>rowFrame</name></expr>;</condition>
         <incr><expr><name>rowFrame</name> = <call><name><name>rowFrame</name>-&gt;<name>GetNextRow</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
      <comment type="line">// conservatively estimate the half border widths outside the row</comment>
      <decl_stmt><decl><type><name>nscoord</name></type> <name>topBorderHalf</name>    <init>= <expr>(<call><name>GetPrevInFlow</name><argument_list>()</argument_list></call>) ? 0 : <call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><call><name><name>rowFrame</name>-&gt;<name>GetTopBCBorderWidth</name></name><argument_list>()</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
      <decl_stmt><decl><type><name>nscoord</name></type> <name>bottomBorderHalf</name> <init>= <expr>(<call><name>GetNextInFlow</name><argument_list>()</argument_list></call>) ? 0 : <call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><call><name><name>rowFrame</name>-&gt;<name>GetBottomBCBorderWidth</name></name><argument_list>()</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="line">// get the row rect relative to the table rather than the row group</comment>
      <decl_stmt><decl><type><name>nsSize</name></type> <name>rowSize</name> <init>= <expr><call><name><name>rowFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>haveIntersect</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name><name>aDirtyRect</name>.<name>YMost</name></name><argument_list>()</argument_list></call> &gt;= (<name>rowY</name> - <name>topBorderHalf</name>)</expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>fifRow</name> <init>= <expr>(<name>nsTableRowFrame</name>*)<call><name><name>rowFrame</name>-&gt;<name>GetFirstInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>fifRow</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><name>endRowIndex</name> = <call><name><name>fifRow</name>-&gt;<name>GetRowIndex</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <expr_stmt><expr><name>done</name> = <name>PR_TRUE</name></expr>;</expr_stmt></else></if>
      }</block></then>
      <else>else <block>{
        <if>if <condition>(<expr>(<name>rowY</name> + <name><name>rowSize</name>.<name>height</name></name> + <name>bottomBorderHalf</name>) &gt;= <name><name>aDirtyRect</name>.<name>y</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>inFlowRG</name>  = <name>rgFrame</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>inFlowRow</name> = <name>rowFrame</name></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>fifRow</name> <init>= <expr>(<name>nsTableRowFrame</name>*)<call><name><name>rowFrame</name>-&gt;<name>GetFirstInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>fifRow</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><name>startRowIndex</name> = <name>endRowIndex</name> = <call><name><name>fifRow</name>-&gt;<name>GetRowIndex</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>haveIntersect</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><name>startRowY</name> += <name><name>rowSize</name>.<name>height</name></name></expr>;</expr_stmt>
        }</block></else></if>
      }</block></else></if>
      <expr_stmt><expr><name>rowY</name> += <name><name>rowSize</name>.<name>height</name></name></expr>;</expr_stmt> 
    }</block></for>
  }</block></for>
  <comment type="line">// outer table borders overflow the table, so the table might be</comment>
  <comment type="line">// target to other areas as the NS_FRAME_OUTSIDE_CHILDREN is set</comment>
  <comment type="line">// on the table</comment>
  <if>if <condition>(<expr>!<name>haveIntersect</name></expr>)</condition><then>
    <return>return;</return></then></if>  
  <if>if <condition>(<expr>!<name>inFlowRG</name> || !<name>inFlowRow</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>startColX</name></decl>;</decl_stmt>
  <comment type="line">// find startColIndex, endColIndex, startColX</comment>
  <expr_stmt><expr><name>haveIntersect</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>numCols</name> <init>= <expr><call><name>GetColCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>0 == <name>numCols</name></expr>)</condition><then> <return>return;</return></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>leftCol</name></decl>, <decl><type ref="prev"/><name>rightCol</name></decl>, <decl><type ref="prev"/><name>colInc</name></decl>;</decl_stmt> <comment type="line">// columns are in the range [leftCol, rightCol)</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>tableIsLTR</name> <init>= <expr><call><name>GetStyleVisibility</name><argument_list>()</argument_list></call>-&gt;<name>mDirection</name> == <name>NS_STYLE_DIRECTION_LTR</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>tableIsLTR</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>startColX</name> = <name><name>childAreaOffset</name>.<name>left</name></name></expr>;</expr_stmt> <comment type="line">// x position of first col in damage area</comment>
    <expr_stmt><expr><name>leftCol</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>rightCol</name> = <name>numCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>colInc</name> = 1</expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>startColX</name> = <name><name>mRect</name>.<name>width</name></name> - <name><name>childAreaOffset</name>.<name>right</name></name></expr>;</expr_stmt> <comment type="line">// x position of first col in damage area</comment>
    <expr_stmt><expr><name>leftCol</name> = <name>numCols</name>-1</expr>;</expr_stmt>
    <expr_stmt><expr><name>rightCol</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>colInc</name> = -1</expr>;</expr_stmt>
  }</block></else></if>

  <decl_stmt><decl><type><name>nscoord</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>colX</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>colX</name> = <name>leftCol</name></expr>;</init> <condition><expr><name>colX</name> != <name>rightCol</name></expr>;</condition> <incr><expr><name>colX</name> += <name>colInc</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name><name>firstInFlow</name>-&gt;<name>GetColFrame</name></name><argument_list>(<argument><expr><name>colX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>colFrame</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <comment type="line">// conservatively estimate the half border widths outside the col</comment>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>leftBorderHalf</name>    <init>= <expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><call><name><name>colFrame</name>-&gt;<name>GetLeftBorderWidth</name></name><argument_list>()</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>nscoord</name></type> <name>rightBorderHalf</name>   <init>= <expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><call><name><name>colFrame</name>-&gt;<name>GetRightBorderWidth</name></name><argument_list>()</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// get the col rect relative to the table rather than the col group</comment>
    <decl_stmt><decl><type><name>nsSize</name></type> <name>size</name> <init>= <expr><call><name><name>colFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>haveIntersect</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name><name>aDirtyRect</name>.<name>XMost</name></name><argument_list>()</argument_list></call> &gt;= (<name>x</name> - <name>leftBorderHalf</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>endColIndex</name> = <name>colX</name></expr>;</expr_stmt>
      }</block></then>
      <else>else <break>break;</break></else></if>
    }</block></then>
    <else>else <block>{
      <if>if <condition>(<expr>(<name>x</name> + <name><name>size</name>.<name>width</name></name> + <name>rightBorderHalf</name>) &gt;= <name><name>aDirtyRect</name>.<name>x</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>startColIndex</name> = <name>endColIndex</name> = <name>colX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>haveIntersect</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><name>startColX</name> += <name>colInc</name> * <name><name>size</name>.<name>width</name></name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if>
    <expr_stmt><expr><name>x</name> += <name><name>size</name>.<name>width</name></name></expr>;</expr_stmt>
  }</block></for>

  <if>if <condition>(<expr>!<name>tableIsLTR</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>temp</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>startColX</name> = <name><name>mRect</name>.<name>width</name></name> - <name><name>childAreaOffset</name>.<name>right</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>temp</name> = <name>startColIndex</name></expr>;</expr_stmt> <expr_stmt><expr><name>startColIndex</name> = <name>endColIndex</name></expr>;</expr_stmt> <expr_stmt><expr><name>endColIndex</name> = <name>temp</name></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>column</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>column</name> &lt; <name>startColIndex</name></expr>;</condition> <incr><expr><name>column</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>colFrame</name> <init>= <expr><call><name><name>firstInFlow</name>-&gt;<name>GetColFrame</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>colFrame</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <decl_stmt><decl><type><name>nsSize</name></type> <name>size</name> <init>= <expr><call><name><name>colFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>startColX</name> += <name>colInc</name> * <name><name>size</name>.<name>width</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
  <if>if <condition>(<expr>!<name>haveIntersect</name></expr>)</condition><then>
    <return>return;</return></then></if>
  <comment type="line">// iterate the cell map and build up border segments</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>damageArea</name><argument_list>(<argument><expr><name>startColIndex</name></expr></argument>, <argument><expr><name>startRowIndex</name></expr></argument>,
                    <argument><expr>1 + <call><name>PR_ABS</name><argument_list>(<argument><expr><call><name>PRInt32</name><argument_list>(<argument><expr><name>endColIndex</name> - <name>startColIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, 
                    <argument><expr>1 + <name>endRowIndex</name> - <name>startRowIndex</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCVerticalSeg</name>*</type> <name>verInfo</name> <init>= <expr>new <name><name>BCVerticalSeg</name><index>[<expr><name><name>damageArea</name>.<name>width</name></name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>verInfo</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>BCBorderOwner</name></type> <name>borderOwner</name></decl>, <decl><type ref="prev"/><name>ignoreBorderOwner</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint8</name></type> <name>ownerSide</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>cornerSubWidth</name></decl>, <decl><type ref="prev"/><name>smallHalf</name></decl>, <decl><type ref="prev"/><name>largeHalf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>rowRect</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isSegStart</name></decl>, <decl><type ref="prev"/><name>ignoreSegStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>prevHorSegHeight</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>bevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>repeatedHeaderY</name> <init>= <expr>-99</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>  <name>afterRepeatedHeader</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type>  <name>startRepeatedFooter</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// First, paint all of the vertical borders from top to bottom and left to right as they become complete</comment>
  <comment type="line">// They are painted first, since they are less efficient to paint than horizontal segments. They were </comment>
  <comment type="line">// stored with as few segments as possible (since horizontal borders are painted last and possibly over them).</comment>
  <decl_stmt><decl><type><name>BCMapBorderIterator</name></type> <name>iter</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr>*<name>inFlowRG</name></expr></argument>, <argument><expr>*<name>inFlowRow</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></decl>;</decl_stmt> 
  <for>for (<init><expr><call><name><name>iter</name>.<name>First</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr>!<name><name>iter</name>.<name>atEnd</name></name></expr>;</condition> <incr><expr><call><name><name>iter</name>.<name>Next</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nscoord</name></type> <name>verSegWidth</name> <init>= <expr>(<name><name>iter</name>.<name>bcData</name></name>) ? <call><name><name>iter</name>.<name>bcData</name>-&gt;<name>GetLeftEdge</name></name><argument_list>(<argument><expr><name>borderOwner</name></expr></argument>, <argument><expr><name>isSegStart</name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>horSegHeight</name> <init>= <expr>(<name><name>iter</name>.<name>bcData</name></name>) ? <call><name><name>iter</name>.<name>bcData</name>-&gt;<name>GetTopEdge</name></name><argument_list>(<argument><expr><name>ignoreBorderOwner</name></expr></argument>, <argument><expr><name>ignoreSegStart</name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>xAdj</name> <init>= <expr><name><name>iter</name>.<name>x</name></name> - <name><name>iter</name>.<name>startX</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>iter</name>.<name>isNewRow</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>prevHorSegHeight</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>rowRect</name> = <call><name><name>iter</name>.<name>row</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>iter</name>.<name>isRepeatedHeader</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>repeatedHeaderY</name> = <name><name>iter</name>.<name>y</name></name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>afterRepeatedHeader</name> = !<name><name>iter</name>.<name>isRepeatedHeader</name></name> &amp;&amp; (<name><name>iter</name>.<name>y</name></name> == (<name>repeatedHeaderY</name> + 1))</expr>;</expr_stmt>
      <expr_stmt><expr><name>startRepeatedFooter</name> = <name><name>iter</name>.<name>isRepeatedFooter</name></name> &amp;&amp; (<name><name>iter</name>.<name>y</name></name> == <name><name>iter</name>.<name>rowGroupStart</name></name>) &amp;&amp; (<name><name>iter</name>.<name>y</name></name> != <name><name>iter</name>.<name>startY</name></name>)</expr>;</expr_stmt>
    }</block></then></if>
    <decl_stmt><decl><type><name>BCVerticalSeg</name>&amp;</type> <name>info</name> <init>= <expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name><name>info</name>.<name>col</name></name></expr>)</condition><then> <block>{ <comment type="line">// on the first damaged row and the first segment in the col</comment>
      <expr_stmt><expr><name><name>info</name>.<name>col</name></name> = <call><name><name>iter</name>.<name>IsRightMostTable</name></name><argument_list>()</argument_list></call> ? <name><name>verInfo</name><index>[<expr><name>xAdj</name> - 1</expr>]</index></name>.<name>col</name> : <call><name><name>firstInFlow</name>-&gt;<name>GetColFrame</name></name><argument_list>(<argument><expr><name><name>iter</name>.<name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name><name>info</name>.<name>col</name></name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr>0 == <name>xAdj</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>info</name>.<name>colX</name></name> = <name>startColX</name></expr>;</expr_stmt>
      }</block></then></if>
      <comment type="line">// set colX for the next column</comment>
      <if>if <condition>(<expr>!<call><name><name>iter</name>.<name>IsRightMost</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>verInfo</name><index>[<expr><name>xAdj</name> + 1</expr>]</index></name>.<name>colX</name> = <name><name>info</name>.<name>colX</name></name> + <name>colInc</name> * <call><name><name>info</name>.<name>col</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call>.<name>width</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name><name>info</name>.<name>segY</name></name> = <name>startRowY</name></expr>;</expr_stmt> 
      <expr_stmt><expr><call><name><name>info</name>.<name>Start</name></name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>borderOwner</name></expr></argument>, <argument><expr><name>verSegWidth</name></expr></argument>, <argument><expr><name>prevHorSegHeight</name></expr></argument>, <argument><expr><name>horSegHeight</name></expr></argument>, <argument><expr><name>verInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>info</name>.<name>lastCell</name></name> = <name><name>iter</name>.<name>cell</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name><name>iter</name>.<name>IsTopMost</name></name><argument_list>()</argument_list></call> &amp;&amp; (<name>isSegStart</name> || <call><name><name>iter</name>.<name>IsBottomMost</name></name><argument_list>()</argument_list></call> || <name>afterRepeatedHeader</name> || <name>startRepeatedFooter</name>)</expr>)</condition><then> <block>{
      <comment type="line">// paint the previous seg or the current one if iter.IsBottomMost()</comment>
      <if>if <condition>(<expr><name><name>info</name>.<name>segHeight</name></name> &gt; 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>iter</name>.<name>bcData</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>cornerSubWidth</name> = <call><name><name>iter</name>.<name>bcData</name>-&gt;<name>GetCorner</name></name><argument_list>(<argument><expr><name>ownerSide</name></expr></argument>, <argument><expr><name>bevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><name>cornerSubWidth</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>ownerSide</name> = 0</expr>;</expr_stmt> <comment type="line">// ???</comment>
          <expr_stmt><expr><name>bevel</name> = <name>PR_FALSE</name></expr>;</expr_stmt> <comment type="line">// ???</comment>
        }</block></else></if>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>endBevel</name> <init>= <expr>(<name><name>info</name>.<name>segWidth</name></name> &gt; 0) ? <name>bevel</name> : <name>PR_FALSE</name></expr></init></decl>;</decl_stmt> 
        <decl_stmt><decl><type><name>nscoord</name></type> <name>bottomHorSegHeight</name> <init>= <expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>prevHorSegHeight</name></expr></argument>, <argument><expr><name>horSegHeight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
        <decl_stmt><decl><type><name>nscoord</name></type> <name>endOffset</name> <init>= <expr><call><name>CalcVerCornerOffset</name><argument_list>(<argument><expr><name>ownerSide</name></expr></argument>, <argument><expr><name>cornerSubWidth</name></expr></argument>, <argument><expr><name>bottomHorSegHeight</name></expr></argument>, 
                                                <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>endBevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>info</name>.<name>segHeight</name></name> += <name>endOffset</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>info</name>.<name>segWidth</name></name> &gt; 0</expr>)</condition><then> <block>{     
          <comment type="line">// get the border style, color and paint the segment</comment>
          <decl_stmt><decl><type><name>PRUint8</name></type> <name>side</name> <init>= <expr>(<call><name><name>iter</name>.<name>IsRightMost</name></name><argument_list>()</argument_list></call>) ? <name>NS_SIDE_RIGHT</name> : <name>NS_SIDE_LEFT</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nsTableRowFrame</name>*</type> <name>row</name>           <init>= <expr><name><name>info</name>.<name>firstRow</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nsTableRowGroupFrame</name>*</type> <name>rowGroup</name> <init>= <expr><name><name>info</name>.<name>firstRowGroup</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>col</name>           <init>= <expr><name><name>info</name>.<name>col</name></name></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>col</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <decl_stmt><decl><type><name>nsTableCellFrame</name>*</type> <name>cell</name>         <init>= <expr><name><name>info</name>.<name>firstCell</name></name></expr></init></decl>;</decl_stmt> 
          <decl_stmt><decl><type><name>PRUint8</name></type> <name>style</name> <init>= <expr><name>NS_STYLE_BORDER_STYLE_SOLID</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nscolor</name></type> <name>color</name> <init>= <expr>0xFFFFFFFF</expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PRBool</name></type> <name>ignoreIfRules</name> <init>= <expr>(<call><name><name>iter</name>.<name>IsRightMostTable</name></name><argument_list>()</argument_list></call> || <call><name><name>iter</name>.<name>IsLeftMostTable</name></name><argument_list>()</argument_list></call>)</expr></init></decl>;</decl_stmt>

          <switch>switch <condition>(<expr><name><name>info</name>.<name>owner</name></name></expr>)</condition> <block>{
          <case>case <expr><name>eTableOwner</name></expr>:
            <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>eAjaColGroupOwner</name></expr>: 
            <expr_stmt><expr><name>side</name> = <name>NS_SIDE_RIGHT</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>iter</name>.<name>IsRightMostTable</name></name><argument_list>()</argument_list></call> &amp;&amp; (<name>xAdj</name> &gt; 0)</expr>)</condition><then> <block>{
              <expr_stmt><expr><name>col</name> = <name><name>verInfo</name><index>[<expr><name>xAdj</name> - 1</expr>]</index></name>.<name>col</name></expr>;</expr_stmt> 
            }</block></then></if> <comment type="line">// and fall through</comment>
          </case><case>case <expr><name>eColGroupOwner</name></expr>:
            <if>if <condition>(<expr><name>col</name></expr>)</condition><then> <block>{
              <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>cg</name> <init>= <expr><call><name><name>col</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
              <if>if <condition>(<expr><name>cg</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>ignoreIfRules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then></if>
            }</block></then></if>
            <break>break;</break>
          </case><case>case <expr><name>eAjaColOwner</name></expr>: 
            <expr_stmt><expr><name>side</name> = <name>NS_SIDE_RIGHT</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>iter</name>.<name>IsRightMostTable</name></name><argument_list>()</argument_list></call> &amp;&amp; (<name>xAdj</name> &gt; 0)</expr>)</condition><then> <block>{
              <expr_stmt><expr><name>col</name> = <name><name>verInfo</name><index>[<expr><name>xAdj</name> - 1</expr>]</index></name>.<name>col</name></expr>;</expr_stmt> 
            }</block></then></if> <comment type="line">// and fall through</comment>
          </case><case>case <expr><name>eColOwner</name></expr>:
            <if>if <condition>(<expr><name>col</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>ignoreIfRules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
          </case><case>case <expr><name>eAjaRowGroupOwner</name></expr>:
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// and fall through</comment>
          </case><case>case <expr><name>eRowGroupOwner</name></expr>:
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>iter</name>.<name>IsLeftMostTable</name></name><argument_list>()</argument_list></call> || <call><name><name>iter</name>.<name>IsRightMostTable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rowGroup</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>rowGroup</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>ignoreIfRules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
          </case><case>case <expr><name>eAjaRowOwner</name></expr>:
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// and fall through</comment>
          </case><case>case <expr><name>eRowOwner</name></expr>: 
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>iter</name>.<name>IsLeftMostTable</name></name><argument_list>()</argument_list></call> || <call><name><name>iter</name>.<name>IsRightMostTable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>row</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>ignoreIfRules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
          </case><case>case <expr><name>eAjaCellOwner</name></expr>:
            <expr_stmt><expr><name>side</name> = <name>NS_SIDE_RIGHT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cell</name> = <name><name>info</name>.<name>ajaCell</name></name></expr>;</expr_stmt> <comment type="line">// and fall through</comment>
          </case><case>case <expr><name>eCellOwner</name></expr>:
            <if>if <condition>(<expr><name>cell</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>cell</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
          </case>}</block></switch>
          <expr_stmt><expr><call><name>DivideBCBorderSize</name><argument_list>(<argument><expr><name><name>info</name>.<name>segWidth</name></name></expr></argument>, <argument><expr><name>smallHalf</name></expr></argument>, <argument><expr><name>largeHalf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>nsRect</name></type> <name>segRect</name><argument_list>(<argument><expr><name><name>info</name>.<name>colX</name></name> - <call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>largeHalf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>info</name>.<name>segY</name></name></expr></argument>, 
                         <argument><expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>segWidth</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>info</name>.<name>segHeight</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nscoord</name></type> <name>bottomBevelOffset</name> <init>= <expr>(<name>endBevel</name>) ? <call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>bottomHorSegHeight</name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PRUint8</name></type> <name>bottomBevelSide</name> <init>= <expr>((<name>horSegHeight</name> &gt; 0) ^ !<name>tableIsLTR</name>) ? <name>NS_SIDE_RIGHT</name> : <name>NS_SIDE_LEFT</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PRUint8</name></type> <name>topBevelSide</name> <init>= <expr>((<name><name>info</name>.<name>bevelSide</name></name> == <name>NS_SIDE_RIGHT</name>) ^ !<name>tableIsLTR</name>)?  <name>NS_SIDE_RIGHT</name> : <name>NS_SIDE_LEFT</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>DrawTableBorderSegment</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>bgColor</name></expr></argument>, <argument><expr><name>segRect</name></expr></argument>, <argument><expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></argument>, 
                                                 <argument><expr><name>topBevelSide</name></expr></argument>, <argument><expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>bevelOffset</name></name></expr></argument>)</argument_list></call></expr></argument>, 
                                                 <argument><expr><name>bottomBevelSide</name></expr></argument>, <argument><expr><name>bottomBevelOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if> <comment type="line">// if (info.segWidth &gt; 0) </comment>
        <expr_stmt><expr><name><name>info</name>.<name>segY</name></name> = <name><name>info</name>.<name>segY</name></name> + <name><name>info</name>.<name>segHeight</name></name> - <name>endOffset</name></expr>;</expr_stmt>
      }</block></then></if> <comment type="line">// if (info.segHeight &gt; 0)</comment>
      <expr_stmt><expr><call><name><name>info</name>.<name>Start</name></name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>borderOwner</name></expr></argument>, <argument><expr><name>verSegWidth</name></expr></argument>, <argument><expr><name>prevHorSegHeight</name></expr></argument>, <argument><expr><name>horSegHeight</name></expr></argument>, <argument><expr><name>verInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if> <comment type="line">// if (!iter.IsTopMost() &amp;&amp; (isSegStart || iter.IsBottomMost()))</comment>

    <expr_stmt><expr><name><name>info</name>.<name>lastCell</name></name>   = <name><name>iter</name>.<name>cell</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name>.<name>segHeight</name></name> += <name><name>rowRect</name>.<name>height</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prevHorSegHeight</name> = <name>horSegHeight</name></expr>;</expr_stmt>
  }</block></for> <comment type="line">// for (iter.First(); !iter.atEnd; iter.Next())</comment>

  <comment type="line">// Next, paint all of the horizontal border segments from top to bottom reuse the verInfo </comment>
  <comment type="line">// array to keep tract of col widths and vertical segments for corner calculations</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>verInfo</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>damageArea</name>.<name>width</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>BCVerticalSeg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// XXX reinitialize properly</comment>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>xIndex</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>xIndex</name> &lt; <name><name>damageArea</name>.<name>width</name></name></expr>;</condition> <incr><expr><name>xIndex</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>verInfo</name><index>[<expr><name>xIndex</name></expr>]</index></name>.<name>colWidth</name> = -1</expr>;</expr_stmt>
  }</block></for>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>nextY</name> <init>= <expr><name>startRowY</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BCHorizontalSeg</name></type> <name>horSeg</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>iter</name>.<name>Reset</name></name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr>*<name>inFlowRG</name></expr></argument>, <argument><expr>*<name>inFlowRow</name></expr></argument>, <argument><expr><name>damageArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><call><name><name>iter</name>.<name>First</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr>!<name><name>iter</name>.<name>atEnd</name></name></expr>;</condition> <incr><expr><call><name><name>iter</name>.<name>Next</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nscoord</name></type> <name>leftSegWidth</name> <init>= <expr>(<name><name>iter</name>.<name>bcData</name></name>) ? <call><name><name>iter</name>.<name>bcData</name>-&gt;<name>GetLeftEdge</name></name><argument_list>(<argument><expr><name>ignoreBorderOwner</name></expr></argument>, <argument><expr><name>ignoreSegStart</name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>topSegHeight</name> <init>= <expr>(<name><name>iter</name>.<name>bcData</name></name>) ? <call><name><name>iter</name>.<name>bcData</name>-&gt;<name>GetTopEdge</name></name><argument_list>(<argument><expr><name>borderOwner</name></expr></argument>, <argument><expr><name>isSegStart</name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>xAdj</name> <init>= <expr><name><name>iter</name>.<name>x</name></name> - <name><name>iter</name>.<name>startX</name></name></expr></init></decl>;</decl_stmt>
    <comment type="line">// store the current col width if it hasn't been already</comment>
    <if>if <condition>(<expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>colWidth</name> &lt; 0</expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name><name>iter</name>.<name>IsRightMostTable</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>colWidth</name> = <name><name>verInfo</name><index>[<expr><name>xAdj</name> - 1</expr>]</index></name>.<name>colWidth</name></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <decl_stmt><decl><type><name>nsTableColFrame</name>*</type> <name>col</name> <init>= <expr><call><name><name>firstInFlow</name>-&gt;<name>GetColFrame</name></name><argument_list>(<argument><expr><name><name>iter</name>.<name>x</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>col</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>colWidth</name> = <call><name><name>col</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call>.<name>width</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
    <expr_stmt><expr><name>cornerSubWidth</name> = (<name><name>iter</name>.<name>bcData</name></name>) ? <call><name><name>iter</name>.<name>bcData</name>-&gt;<name>GetCorner</name></name><argument_list>(<argument><expr><name>ownerSide</name></expr></argument>, <argument><expr><name>bevel</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>verWidth</name> <init>= <expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>segWidth</name></expr></argument>, <argument><expr><name>leftSegWidth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>iter</name>.<name>isNewRow</name></name> || (<call><name><name>iter</name>.<name>IsLeftMost</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>iter</name>.<name>IsBottomMost</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>horSeg</name>.<name>y</name></name> = <name>nextY</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nextY</name>    = <name>nextY</name> + <call><name><name>iter</name>.<name>row</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call>.<name>height</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>horSeg</name>.<name>x</name></name> = <name>startColX</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>horSeg</name>.<name>Start</name></name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>borderOwner</name></expr></argument>, <argument><expr><name>ownerSide</name></expr></argument>, <argument><expr><name>cornerSubWidth</name></expr></argument>, <argument><expr><name>bevel</name></expr></argument>, <argument><expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>segWidth</name></expr></argument>, 
                   <argument><expr><name>leftSegWidth</name></expr></argument>, <argument><expr><name>topSegHeight</name></expr></argument>, <argument><expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>lastCell</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>verOwnsCorner</name> <init>= <expr>(<name>NS_SIDE_TOP</name> == <name>ownerSide</name>) || (<name>NS_SIDE_BOTTOM</name> == <name>ownerSide</name>)</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>iter</name>.<name>IsLeftMost</name></name><argument_list>()</argument_list></call> &amp;&amp; (<name>isSegStart</name> || <call><name><name>iter</name>.<name>IsRightMost</name></name><argument_list>()</argument_list></call> || <name>verOwnsCorner</name>)</expr>)</condition><then> <block>{
      <comment type="line">// paint the previous seg or the current one if iter.IsRightMost()</comment>
      <if>if <condition>(<expr><name><name>horSeg</name>.<name>width</name></name> &gt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>endBevel</name> <init>= <expr>(<name><name>horSeg</name>.<name>height</name></name> &gt; 0) ? <name>bevel</name> : 0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nscoord</name></type> <name>endOffset</name> <init>= <expr><call><name>CalcHorCornerOffset</name><argument_list>(<argument><expr><name>ownerSide</name></expr></argument>, <argument><expr><name>cornerSubWidth</name></expr></argument>, <argument><expr><name>verWidth</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>endBevel</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>horSeg</name>.<name>width</name></name> += <name>endOffset</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>horSeg</name>.<name>height</name></name> &gt; 0</expr>)</condition><then> <block>{
          <comment type="line">// get the border style, color and paint the segment</comment>
          <decl_stmt><decl><type><name>PRUint8</name></type> <name>side</name> <init>= <expr>(<call><name><name>iter</name>.<name>IsBottomMost</name></name><argument_list>()</argument_list></call>) ? <name>NS_SIDE_BOTTOM</name> : <name>NS_SIDE_TOP</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rg</name>   <init>= <expr><name><name>iter</name>.<name>rg</name></name></expr></init></decl>;</decl_stmt>          <if>if <condition>(<expr>!<name>rg</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>row</name>  <init>= <expr><name><name>iter</name>.<name>row</name></name></expr></init></decl>;</decl_stmt>         <if>if <condition>(<expr>!<name>row</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>cell</name> <init>= <expr><name><name>horSeg</name>.<name>firstCell</name></name></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>cell</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>col</name></decl>;</decl_stmt>

          <decl_stmt><decl><type><name>PRUint8</name></type> <name>style</name> <init>= <expr><name>NS_STYLE_BORDER_STYLE_SOLID</name></expr></init></decl>;</decl_stmt> 
          <decl_stmt><decl><type><name>nscolor</name></type> <name>color</name> <init>= <expr>0xFFFFFFFF</expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PRBool</name></type> <name>ignoreIfRules</name> <init>= <expr>(<call><name><name>iter</name>.<name>IsTopMostTable</name></name><argument_list>()</argument_list></call> || <call><name><name>iter</name>.<name>IsBottomMostTable</name></name><argument_list>()</argument_list></call>)</expr></init></decl>;</decl_stmt>

          <switch>switch <condition>(<expr><name><name>horSeg</name>.<name>owner</name></name></expr>)</condition> <block>{
          <case>case <expr><name>eTableOwner</name></expr>:
            <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>eAjaColGroupOwner</name></expr>: 
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// and fall through</comment>
          </case><case>case <expr><name>eColGroupOwner</name></expr>: <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>iter</name>.<name>IsTopMostTable</name></name><argument_list>()</argument_list></call> || <call><name><name>iter</name>.<name>IsBottomMostTable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>col</name> = <call><name><name>firstInFlow</name>-&gt;<name>GetColFrame</name></name><argument_list>(<argument><expr><name><name>iter</name>.<name>x</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr>!<name>col</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
            <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>cg</name> <init>= <expr><call><name><name>col</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <if>if <condition>(<expr>!<name>cg</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>ignoreIfRules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          }</block>
          </case><case>case <expr><name>eAjaColOwner</name></expr>: 
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// and fall through</comment>
          </case><case>case <expr><name>eColOwner</name></expr>:
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>iter</name>.<name>IsTopMostTable</name></name><argument_list>()</argument_list></call> || <call><name><name>iter</name>.<name>IsBottomMostTable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"program error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>col</name> = <call><name><name>firstInFlow</name>-&gt;<name>GetColFrame</name></name><argument_list>(<argument><expr><name><name>iter</name>.<name>x</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <if>if <condition>(<expr>!<name>col</name></expr>)</condition><then> <expr_stmt><expr><call><name>ABORT0</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>ignoreIfRules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>eAjaRowGroupOwner</name></expr>: 
            <expr_stmt><expr><name>side</name> = <name>NS_SIDE_BOTTOM</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rg</name> = (<call><name><name>iter</name>.<name>IsBottomMostTable</name></name><argument_list>()</argument_list></call>) ? <name><name>iter</name>.<name>rg</name></name> : <name><name>iter</name>.<name>prevRg</name></name></expr>;</expr_stmt> <comment type="line">// and fall through</comment>
          </case><case>case <expr><name>eRowGroupOwner</name></expr>:
            <if>if <condition>(<expr><name>rg</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>rg</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>ignoreIfRules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
          </case><case>case <expr><name>eAjaRowOwner</name></expr>: 
            <expr_stmt><expr><name>side</name> = <name>NS_SIDE_BOTTOM</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>row</name> = (<call><name><name>iter</name>.<name>IsBottomMostTable</name></name><argument_list>()</argument_list></call>) ? <name><name>iter</name>.<name>row</name></name> : <name><name>iter</name>.<name>prevRow</name></name></expr>;</expr_stmt> <comment type="line">// and fall through</comment>
          </case><case>case <expr><name>eRowOwner</name></expr>:
            <if>if <condition>(<expr><name>row</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><call><name><name>iter</name>.<name>IsBottomMostTable</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
          </case><case>case <expr><name>eAjaCellOwner</name></expr>:
            <expr_stmt><expr><name>side</name> = <name>NS_SIDE_BOTTOM</name></expr>;</expr_stmt>
            <comment type="line">// if this is null due to the damage area origin-y &gt; 0, then the border won't show up anyway</comment>
            <expr_stmt><expr><name>cell</name> = <name><name>horSeg</name>.<name>ajaCell</name></name></expr>;</expr_stmt> 
            <comment type="line">// and fall through</comment>
          </case><case>case <expr><name>eCellOwner</name></expr>:
            <if>if <condition>(<expr><name>cell</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>::<name>GetPaintStyleInfo</name></name><argument_list>(<argument><expr><name>cell</name></expr></argument>, <argument><expr><name>side</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
          </case>}</block></switch>
          
          <expr_stmt><expr><call><name>DivideBCBorderSize</name><argument_list>(<argument><expr><name><name>horSeg</name>.<name>height</name></name></expr></argument>, <argument><expr><name>smallHalf</name></expr></argument>, <argument><expr><name>largeHalf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>nsRect</name></type> <name>segRect</name><argument_list>(<argument><expr><name><name>horSeg</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>horSeg</name>.<name>y</name></name> - <call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>largeHalf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>horSeg</name>.<name>width</name></name></expr></argument>, 
                         <argument><expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name><name>horSeg</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
           <if>if <condition>(<expr>!<name>tableIsLTR</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>segRect</name>.<name>x</name></name> -= <name><name>segRect</name>.<name>width</name></name></expr>;</expr_stmt></then></if>

          <decl_stmt><decl><type><name>nscoord</name></type> <name>rightBevelOffset</name> <init>= <expr>(<name>endBevel</name>) ? <call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name>verWidth</name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PRUint8</name></type> <name>rightBevelSide</name> <init>= <expr>(<name>leftSegWidth</name> &gt; 0) ? <name>NS_SIDE_BOTTOM</name> : <name>NS_SIDE_TOP</name></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>tableIsLTR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>DrawTableBorderSegment</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>bgColor</name></expr></argument>, <argument><expr><name>segRect</name></expr></argument>, <argument><expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>horSeg</name>.<name>leftBevelSide</name></name></expr></argument>,
                                                 <argument><expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name><name>horSeg</name>.<name>leftBevelOffset</name></name></expr></argument>)</argument_list></call></expr></argument>, 
                                                 <argument><expr><name>rightBevelSide</name></expr></argument>, <argument><expr><name>rightBevelOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then>
          <else>else <block>{
            <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>DrawTableBorderSegment</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>bgColor</name></expr></argument>, <argument><expr><name>segRect</name></expr></argument>, <argument><expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rightBevelSide</name></expr></argument>, <argument><expr><name>rightBevelOffset</name></expr></argument>,
                                                 <argument><expr><name><name>horSeg</name>.<name>leftBevelSide</name></name></expr></argument>, <argument><expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr><name><name>horSeg</name>.<name>leftBevelOffset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>

        }</block></then></if> <comment type="line">// if (horSeg.height &gt; 0)</comment>
        <expr_stmt><expr><name><name>horSeg</name>.<name>x</name></name> += <name>colInc</name> * (<name><name>horSeg</name>.<name>width</name></name> - <name>endOffset</name>)</expr>;</expr_stmt>
      }</block></then></if> <comment type="line">// if (horSeg.width &gt; 0)</comment>
      <expr_stmt><expr><call><name><name>horSeg</name>.<name>Start</name></name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>borderOwner</name></expr></argument>, <argument><expr><name>ownerSide</name></expr></argument>, <argument><expr><name>cornerSubWidth</name></expr></argument>, <argument><expr><name>bevel</name></expr></argument>, <argument><expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>segWidth</name></expr></argument>, 
                   <argument><expr><name>leftSegWidth</name></expr></argument>, <argument><expr><name>topSegHeight</name></expr></argument>, <argument><expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>lastCell</name></expr></argument>, <argument><expr><name>tableIsLTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if> <comment type="line">// if (!iter.IsLeftMost() &amp;&amp; (isSegStart || iter.IsRightMost() || verOwnsCorner))</comment>
    <expr_stmt><expr><name><name>horSeg</name>.<name>width</name></name> += <name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>colWidth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>segWidth</name> = <name>leftSegWidth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>verInfo</name><index>[<expr><name>xAdj</name></expr>]</index></name>.<name>lastCell</name> = <name><name>iter</name>.<name>cell</name></name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr>delete <index>[]</index> <name>verInfo</name></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>PRBool</name></type> 
<name>GetFrameTypeName</name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type> <name>aFrameType</name></decl></param>,
                 <param><decl><type><name>char</name>*</type>    <name>aName</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isTable</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableOuterFrame</name></name> == <name>aFrameType</name></expr>)</condition><then> 
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>aName</name></expr></argument>, <argument><expr>"Tbl"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableFrame</name></name> == <name>aFrameType</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>aName</name></expr></argument>, <argument><expr>"Tbl"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>isTable</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableRowGroupFrame</name></name> == <name>aFrameType</name></expr>)</condition><then> 
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>aName</name></expr></argument>, <argument><expr>"RowG"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableRowFrame</name></name> == <name>aFrameType</name></expr>)</condition><then> 
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>aName</name></expr></argument>, <argument><expr>"Row"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><call><name>IS_TABLE_CELL</name><argument_list>(<argument><expr><name>aFrameType</name></expr></argument>)</argument_list></call></expr>)</condition><then> 
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>aName</name></expr></argument>, <argument><expr>"Cell"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>blockFrame</name></name> == <name>aFrameType</name></expr>)</condition><then> 
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>aName</name></expr></argument>, <argument><expr>"Block"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else 
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"invalid call to GetFrameTypeName"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if></else></if>

  <return>return <expr><name>isTable</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PRBool</name></type> <name><name>nsTableFrame</name>::<name>RowHasSpanningCells</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aRowIndex</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aNumEffCols</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name> <argument_list>(<argument><expr><name>cellMap</name></expr></argument>, <argument><expr>"bad call, cellMap not yet allocated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>result</name> = <call><name><name>cellMap</name>-&gt;<name>RowHasSpanningCells</name></name><argument_list>(<argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>aNumEffCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsTableFrame</name>::<name>RowIsSpannedInto</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aRowIndex</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aNumEffCols</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellMap</name>*</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name> <argument_list>(<argument><expr><name>cellMap</name></expr></argument>, <argument><expr>"bad call, cellMap not yet allocated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>result</name> = <call><name><name>cellMap</name>-&gt;<name>RowIsSpannedInto</name></name><argument_list>(<argument><expr><name>aRowIndex</name></expr></argument>, <argument><expr><name>aNumEffCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsTableFrame</name>::<name>ColHasSpanningCells</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aColIndex</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellMap</name> *</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name> <argument_list>(<argument><expr><name>cellMap</name></expr></argument>, <argument><expr>"bad call, cellMap not yet allocated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>result</name> = <call><name><name>cellMap</name>-&gt;<name>ColHasSpanningCells</name></name><argument_list>(<argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsTableFrame</name>::<name>ColIsSpannedInto</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aColIndex</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsTableCellMap</name> *</type> <name>cellMap</name> <init>= <expr><call><name>GetCellMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name> <argument_list>(<argument><expr><name>cellMap</name></expr></argument>, <argument><expr>"bad call, cellMap not yet allocated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>cellMap</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>result</name> = <call><name><name>cellMap</name>-&gt;<name>ColIsSpannedInto</name></name><argument_list>(<argument><expr><name>aColIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="line">// Destructor function for nscoord properties</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DestroyCoordFunc</name><parameter_list>(<param><decl><type><name>void</name>*</type>           <name>aFrame</name></decl></param>,
                 <param><decl><type><name>nsIAtom</name>*</type>        <name>aPropertyName</name></decl></param>,
                 <param><decl><type><name>void</name>*</type>           <name>aPropertyValue</name></decl></param>,
                 <param><decl><type><name>void</name>*</type>           <name>aDtorData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>delete <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nscoord</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aPropertyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Destructor function point properties</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DestroyPointFunc</name><parameter_list>(<param><decl><type><name>void</name>*</type>           <name>aFrame</name></decl></param>,
                 <param><decl><type><name>nsIAtom</name>*</type>        <name>aPropertyName</name></decl></param>,
                 <param><decl><type><name>void</name>*</type>           <name>aPropertyValue</name></decl></param>,
                 <param><decl><type><name>void</name>*</type>           <name>aDtorData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>delete <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsPoint</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aPropertyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Destructor function for nscoord properties</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DestroyBCPropertyDataFunc</name><parameter_list>(<param><decl><type><name>void</name>*</type>           <name>aFrame</name></decl></param>,
                          <param><decl><type><name>nsIAtom</name>*</type>        <name>aPropertyName</name></decl></param>,
                          <param><decl><type><name>void</name>*</type>           <name>aPropertyValue</name></decl></param>,
                          <param><decl><type><name>void</name>*</type>           <name>aDtorData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>delete <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BCPropertyData</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aPropertyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name>*</type>
<name><name>nsTableFrame</name>::<name>GetProperty</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type>            <name>aFrame</name></decl></param>,
                          <param><decl><type><name>nsIAtom</name>*</type>             <name>aPropertyName</name></decl></param>,
                          <param><decl><type><name>PRBool</name></type>               <name>aCreateIfNecessary</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsPropertyTable</name> *</type><name>propTable</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>PropertyTable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>value</name> <init>= <expr><call><name><name>propTable</name>-&gt;<name>GetProperty</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aPropertyName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{
    <return>return <expr>(<name>nsPoint</name>*)<name>value</name></expr>;</return>  <comment type="line">// the property already exists</comment>
  }</block></then></if>
  <if>if <condition>(<expr><name>aCreateIfNecessary</name></expr>)</condition><then> <block>{
    <comment type="line">// The property isn't set yet, so allocate a new value, set the property,</comment>
    <comment type="line">// and return the newly allocated value</comment>
    <decl_stmt><decl><type><name>NSPropertyDtorFunc</name></type> <name>dtorFunc</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aPropertyName</name> == <name><name>nsGkAtoms</name>::<name>collapseOffsetProperty</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>value</name> = new <call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dtorFunc</name> = <name>DestroyPointFunc</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>aPropertyName</name> == <name><name>nsGkAtoms</name>::<name>rowUnpaginatedHeightProperty</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>value</name> = new <name>nscoord</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>dtorFunc</name> = <name>DestroyCoordFunc</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>aPropertyName</name> == <name><name>nsGkAtoms</name>::<name>tableBCProperty</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>value</name> = new <name>BCPropertyData</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>dtorFunc</name> = <name>DestroyBCPropertyDataFunc</name></expr>;</expr_stmt>
    }</block></then></if></else></if></else></if>
    <if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>propTable</name>-&gt;<name>SetProperty</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aPropertyName</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>dtorFunc</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>value</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment>
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>InvalidateFrame</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aOrigRect</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type> <name>aIsFirstReflow</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>parent</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr>"What happened here?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name><name>parent</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_FIRST_REFLOW</name></expr>)</condition><then> <block>{
    <comment type="line">// Don't bother; we'll invalidate the parent's overflow rect when</comment>
    <comment type="line">// we finish reflowing it.</comment>
    <return>return;</return>
  }</block></then></if>
  
  <if>if <condition>(<expr><name>aIsFirstReflow</name> || <call><name><name>aOrigRect</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call> != <call><name><name>aFrame</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aFrame</name>-&gt;<name>InvalidateOverflowRect</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name><name>parent</name>-&gt;<name>InvalidateRectDifference</name></name><argument_list>(<argument><expr><name>aOrigRect</name></expr></argument>, <argument><expr><call><name><name>aFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>    
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SIZE</name></cpp:macro>  <cpp:value>128</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_INDENT</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>

<function><type><specifier>static</specifier> 
<name>void</name></type> <name>DumpTableFramesRecur</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type>       <name>aFrame</name></decl></param>,
                          <param><decl><type><name>PRUint32</name></type>        <name>aIndent</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>indent</name><index>[<expr><name>MAX_SIZE</name> + 1</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name>aIndent</name> = <call><name>PR_MIN</name><argument_list>(<argument><expr><name>aIndent</name></expr></argument>, <argument><expr><name>MAX_SIZE</name> - <name>MIN_INDENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>indent</name></expr></argument>, <argument><expr>' '</expr></argument>, <argument><expr><name>aIndent</name> + <name>MIN_INDENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>indent</name><index>[<expr><name>aIndent</name> + <name>MIN_INDENT</name></expr>]</index></name> = 0</expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name></type> <name><name>fName</name><index>[<expr><name>MAX_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>fType</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>GetFrameTypeName</name><argument_list>(<argument><expr><name>fType</name></expr></argument>, <argument><expr><name>fName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s%s %p"</expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr><name>fName</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>flowFrame</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetPrevInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>flowFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" pif=%p"</expr></argument>, <argument><expr><name>flowFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>flowFrame</name> = <call><name><name>aFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>flowFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" nif=%p"</expr></argument>, <argument><expr><name>flowFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableFrame</name></name>         == <name>fType</name> ||
      <name><name>nsGkAtoms</name>::<name>tableRowGroupFrame</name></name> == <name>fType</name> ||
      <name><name>nsGkAtoms</name>::<name>tableRowFrame</name></name>      == <name>fType</name> ||
      <call><name>IS_TABLE_CELL</name><argument_list>(<argument><expr><name>fType</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>child</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>child</name></expr>)</condition> <block>{
      <expr_stmt><expr><call><name>DumpTableFramesRecur</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>aIndent</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>child</name> = <call><name><name>child</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>
}</block></function>
  
<function><type><name>void</name></type>
<name><name>nsTableFrame</name>::<name>DumpTableFrames</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsTableFrame</name>*</type> <name>tableFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>tableFrame</name></name> == <call><name><name>aFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ 
    <expr_stmt><expr><name>tableFrame</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTableFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>tableFrame</name> = <call><name><name>nsTableFrame</name>::<name>GetTableFrame</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>tableFrame</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTableFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tableFrame</name>-&gt;<name>GetFirstInFlow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>tableFrame</name></expr>)</condition> <block>{
    <expr_stmt><expr><call><name>DumpTableFramesRecur</name><argument_list>(<argument><expr><name>tableFrame</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tableFrame</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsTableFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tableFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
