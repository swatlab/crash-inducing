<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="005e9f99bb2f7c78d45e69e753b15dcc7e4838c7.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   emk &lt;VYV03354@nifty.ne.jp&gt;
 *   Daniel Glazman &lt;glazman@netscape.com&gt;
 *   L. David Baron &lt;dbaron@dbaron.org&gt;
 *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
 *   Mats Palmgren &lt;mats.palmgren@bredband.net&gt;
 *   Christian Biesinger &lt;cbiesinger@web.de&gt;
 *   Jeff Walden &lt;jwalden+code@mit.edu&gt;
 *   Jonathon Jongsma &lt;jonathon.jongsma@collabora.co.uk&gt;, Collabora Ltd.
 *   Siraj Razick &lt;siraj.razick@collabora.co.uk&gt;, Collabora Ltd.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/* parsing of CSS stylesheets, based on a token stream from the CSS scanner */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSParser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSProps.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSKeywords.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSScanner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mozilla/css/Loader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICSSStyleRule.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICSSImportRule.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSRules.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICSSNameSpaceRule.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIUnicharInputStream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSStyleSheet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mozilla/css/Declaration.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleConsts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIURL.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNetUtil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsReadableUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsUnicharUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAtom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsColor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSPseudoClasses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSPseudoElements.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSAnonBoxes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsINameSpaceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXMLNameSpaceMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsThemeConstants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentErrors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPrintfCString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIMediaList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsILookAndFeel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleUtil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPrincipal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"math.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDOMError.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CSSCalc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsMediaFeatures.h"</cpp:file></cpp:include>

<namespace>namespace <name>css</name> = <name><name>mozilla</name>::<name>css</name></name>;</namespace>

<comment type="line">// Flags for ParseVariant method</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_KEYWORD</name></cpp:macro>         <cpp:value>0x000001</cpp:value></cpp:define>  <comment type="line">// K</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_LENGTH</name></cpp:macro>          <cpp:value>0x000002</cpp:value></cpp:define>  <comment type="line">// L</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_PERCENT</name></cpp:macro>         <cpp:value>0x000004</cpp:value></cpp:define>  <comment type="line">// P</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_COLOR</name></cpp:macro>           <cpp:value>0x000008</cpp:value></cpp:define>  <comment type="line">// C eCSSUnit_Color, eCSSUnit_Ident (e.g.  "red")</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_URL</name></cpp:macro>             <cpp:value>0x000010</cpp:value></cpp:define>  <comment type="line">// U</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_NUMBER</name></cpp:macro>          <cpp:value>0x000020</cpp:value></cpp:define>  <comment type="line">// N</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_INTEGER</name></cpp:macro>         <cpp:value>0x000040</cpp:value></cpp:define>  <comment type="line">// I</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_ANGLE</name></cpp:macro>           <cpp:value>0x000080</cpp:value></cpp:define>  <comment type="line">// G</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_FREQUENCY</name></cpp:macro>       <cpp:value>0x000100</cpp:value></cpp:define>  <comment type="line">// F</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_TIME</name></cpp:macro>            <cpp:value>0x000200</cpp:value></cpp:define>  <comment type="line">// T</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_STRING</name></cpp:macro>          <cpp:value>0x000400</cpp:value></cpp:define>  <comment type="line">// S</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_COUNTER</name></cpp:macro>         <cpp:value>0x000800</cpp:value></cpp:define>  <comment type="line">//</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_ATTR</name></cpp:macro>            <cpp:value>0x001000</cpp:value></cpp:define>  <comment type="line">//</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_IDENTIFIER</name></cpp:macro>      <cpp:value>0x002000</cpp:value></cpp:define>  <comment type="line">// D</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_AUTO</name></cpp:macro>            <cpp:value>0x010000</cpp:value></cpp:define>  <comment type="line">// A</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_INHERIT</name></cpp:macro>         <cpp:value>0x020000</cpp:value></cpp:define>  <comment type="line">// H eCSSUnit_Initial, eCSSUnit_Inherit</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_NONE</name></cpp:macro>            <cpp:value>0x040000</cpp:value></cpp:define>  <comment type="line">// O</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_NORMAL</name></cpp:macro>          <cpp:value>0x080000</cpp:value></cpp:define>  <comment type="line">// M</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_SYSFONT</name></cpp:macro>         <cpp:value>0x100000</cpp:value></cpp:define>  <comment type="line">// eCSSUnit_System_Font</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_GRADIENT</name></cpp:macro>        <cpp:value>0x200000</cpp:value></cpp:define>  <comment type="line">// eCSSUnit_Gradient</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_CUBIC_BEZIER</name></cpp:macro>    <cpp:value>0x400000</cpp:value></cpp:define>  <comment type="line">// CSS transition timing function</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_ALL</name></cpp:macro>             <cpp:value>0x800000</cpp:value></cpp:define>  <comment type="line">//</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_IMAGE_RECT</name></cpp:macro>    <cpp:value>0x01000000</cpp:value></cpp:define>  <comment type="line">// eCSSUnit_Function</comment>
<comment type="line">// This is an extra bit that says that a VARIANT_ANGLE allows unitless zero:</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_ZERO_ANGLE</name></cpp:macro>    <cpp:value>0x02000000</cpp:value></cpp:define>  <comment type="line">// unitless zero for angles</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_CALC</name></cpp:macro>          <cpp:value>0x04000000</cpp:value></cpp:define>  <comment type="line">// eCSSUnit_Calc</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_CALC_NO_MIN_MAX</name></cpp:macro> <cpp:value>0x08000000</cpp:value></cpp:define> <comment type="line">// no min() and max() for calc()</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_ELEMENT</name></cpp:macro>       <cpp:value>0x10000000</cpp:value></cpp:define>  <comment type="line">// eCSSUnit_Element</comment>

<comment type="line">// Common combinations of variants</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_AL</name></cpp:macro>   <cpp:value>(VARIANT_AUTO | VARIANT_LENGTH)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_LP</name></cpp:macro>   <cpp:value>(VARIANT_LENGTH | VARIANT_PERCENT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_AH</name></cpp:macro>   <cpp:value>(VARIANT_AUTO | VARIANT_INHERIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_AHLP</name></cpp:macro> <cpp:value>(VARIANT_AH | VARIANT_LP)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_AHI</name></cpp:macro>  <cpp:value>(VARIANT_AH | VARIANT_INTEGER)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_AHK</name></cpp:macro>  <cpp:value>(VARIANT_AH | VARIANT_KEYWORD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_AHKLP</name></cpp:macro> <cpp:value>(VARIANT_AHLP | VARIANT_KEYWORD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_AHL</name></cpp:macro>  <cpp:value>(VARIANT_AH | VARIANT_LENGTH)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_AHKL</name></cpp:macro> <cpp:value>(VARIANT_AHK | VARIANT_LENGTH)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HK</name></cpp:macro>   <cpp:value>(VARIANT_INHERIT | VARIANT_KEYWORD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HKF</name></cpp:macro>  <cpp:value>(VARIANT_HK | VARIANT_FREQUENCY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HKI</name></cpp:macro>  <cpp:value>(VARIANT_HK | VARIANT_INTEGER)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HKL</name></cpp:macro>  <cpp:value>(VARIANT_HK | VARIANT_LENGTH)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HKLP</name></cpp:macro> <cpp:value>(VARIANT_HK | VARIANT_LP)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HKLPO</name></cpp:macro> <cpp:value>(VARIANT_HKLP | VARIANT_NONE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HL</name></cpp:macro>   <cpp:value>(VARIANT_INHERIT | VARIANT_LENGTH)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HI</name></cpp:macro>   <cpp:value>(VARIANT_INHERIT | VARIANT_INTEGER)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HLP</name></cpp:macro>  <cpp:value>(VARIANT_HL | VARIANT_PERCENT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HLPN</name></cpp:macro> <cpp:value>(VARIANT_HLP | VARIANT_NUMBER)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HLPO</name></cpp:macro> <cpp:value>(VARIANT_HLP | VARIANT_NONE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HTP</name></cpp:macro>  <cpp:value>(VARIANT_INHERIT | VARIANT_TIME | VARIANT_PERCENT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HMK</name></cpp:macro>  <cpp:value>(VARIANT_HK | VARIANT_NORMAL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HC</name></cpp:macro>   <cpp:value>(VARIANT_INHERIT | VARIANT_COLOR)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HCK</name></cpp:macro>  <cpp:value>(VARIANT_HK | VARIANT_COLOR)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HUK</name></cpp:macro>  <cpp:value>(VARIANT_HK | VARIANT_URL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HUO</name></cpp:macro>  <cpp:value>(VARIANT_INHERIT | VARIANT_URL | VARIANT_NONE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_AHUO</name></cpp:macro> <cpp:value>(VARIANT_AUTO | VARIANT_HUO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HPN</name></cpp:macro>  <cpp:value>(VARIANT_INHERIT | VARIANT_PERCENT | VARIANT_NUMBER)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HN</name></cpp:macro>   <cpp:value>(VARIANT_INHERIT | VARIANT_NUMBER)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HON</name></cpp:macro>  <cpp:value>(VARIANT_HN | VARIANT_NONE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_HOS</name></cpp:macro>  <cpp:value>(VARIANT_INHERIT | VARIANT_NONE | VARIANT_STRING)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_TIMING_FUNCTION</name></cpp:macro> <cpp:value>(VARIANT_KEYWORD | VARIANT_CUBIC_BEZIER)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_UK</name></cpp:macro>   <cpp:value>(VARIANT_URL | VARIANT_KEYWORD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_UO</name></cpp:macro>   <cpp:value>(VARIANT_URL | VARIANT_NONE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_ANGLE_OR_ZERO</name></cpp:macro> <cpp:value>(VARIANT_ANGLE | VARIANT_ZERO_ANGLE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_TRANSFORM_LPCALC</name></cpp:macro> <cpp:value>(VARIANT_LP | VARIANT_CALC | \
                                  VARIANT_CALC_NO_MIN_MAX)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_IMAGE</name></cpp:macro> <cpp:value>(VARIANT_URL | VARIANT_NONE | VARIANT_GRADIENT | \
                       VARIANT_IMAGE_RECT | VARIANT_ELEMENT)</cpp:value></cpp:define>

<comment type="line">//----------------------------------------------------------------------</comment>

<namespace>namespace <block>{

<comment type="line">// Rule processing function</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (* <name>RuleAppendFunc</name>) <parameter_list>(<param><decl><type><name>nsICSSRule</name>*</type> <name>aRule</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>;</function_decl></typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendRuleToArray</name><parameter_list>(<param><decl><type><name>nsICSSRule</name>*</type> <name>aRule</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aArray</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendRuleToSheet</name><parameter_list>(<param><decl><type><name>nsICSSRule</name>*</type> <name>aRule</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aParser</name></decl></param>)</parameter_list>;</function_decl>

<comment type="line">// Your basic top-down recursive descent style parser</comment>
<comment type="line">// The exposed methods and members of this class are precisely those</comment>
<comment type="line">// needed by nsCSSParser, far below.</comment>
<class>class <name>CSSParserImpl</name> <block>{<private type="default">
</private><public>public:
  <constructor_decl><name>CSSParserImpl</name><parameter_list>()</parameter_list>;</constructor_decl>
  <destructor_decl><name>~<name>CSSParserImpl</name></name><parameter_list>()</parameter_list>;</destructor_decl>

  <function_decl><type><name>nsresult</name></type> <name>SetStyleSheet</name><parameter_list>(<param><decl><type><name>nsCSSStyleSheet</name>*</type> <name>aSheet</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type> <name>SetQuirkMode</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aQuirkMode</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>  <name>MOZ_SVG</name></cpp:ifdef>
  <function_decl><type><name>nsresult</name></type> <name>SetSVGMode</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aSVGMode</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <function_decl><type><name>nsresult</name></type> <name>SetChildLoader</name><parameter_list>(<param><decl><type><name><name>mozilla</name>::<name>css</name>::<name>Loader</name></name>*</type> <name>aChildLoader</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Clears everything set by the above Set*() functions.</comment>
  <function_decl><type><name>void</name></type> <name>Reset</name><parameter_list>()</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type> <name>Parse</name><parameter_list>(<param><decl><type><name>nsIUnicharInputStream</name>*</type> <name>aInput</name></decl></param>,
                 <param><decl><type><name>nsIURI</name>*</type>                <name>aSheetURI</name></decl></param>,
                 <param><decl><type><name>nsIURI</name>*</type>                <name>aBaseURI</name></decl></param>,
                 <param><decl><type><name>nsIPrincipal</name>*</type>          <name>aSheetPrincipal</name></decl></param>,
                 <param><decl><type><name>PRUint32</name></type>               <name>aLineNumber</name></decl></param>,
                 <param><decl><type><name>PRBool</name></type>                 <name>aAllowUnsafeRules</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type> <name>ParseStyleAttribute</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type>  <name>aAttributeValue</name></decl></param>,
                               <param><decl><type><name>nsIURI</name>*</type>           <name>aDocURL</name></decl></param>,
                               <param><decl><type><name>nsIURI</name>*</type>           <name>aBaseURL</name></decl></param>,
                               <param><decl><type><name>nsIPrincipal</name>*</type>     <name>aNodePrincipal</name></decl></param>,
                               <param><decl><type><name>nsICSSStyleRule</name>**</type> <name>aResult</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type> <name>ParseDeclarations</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type>  <name>aBuffer</name></decl></param>,
                             <param><decl><type><name>nsIURI</name>*</type>           <name>aSheetURL</name></decl></param>,
                             <param><decl><type><name>nsIURI</name>*</type>           <name>aBaseURL</name></decl></param>,
                             <param><decl><type><name>nsIPrincipal</name>*</type>     <name>aSheetPrincipal</name></decl></param>,
                             <param><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>aDeclaration</name></decl></param>,
                             <param><decl><type><name>PRBool</name>*</type>           <name>aChanged</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type> <name>ParseRule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type>        <name>aRule</name></decl></param>,
                     <param><decl><type><name>nsIURI</name>*</type>                 <name>aSheetURL</name></decl></param>,
                     <param><decl><type><name>nsIURI</name>*</type>                 <name>aBaseURL</name></decl></param>,
                     <param><decl><type><name>nsIPrincipal</name>*</type>           <name>aSheetPrincipal</name></decl></param>,
                     <param><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsICSSRule</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aResult</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type> <name>ParseProperty</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aPropValue</name></decl></param>,
                         <param><decl><type><name>nsIURI</name>*</type> <name>aSheetURL</name></decl></param>,
                         <param><decl><type><name>nsIURI</name>*</type> <name>aBaseURL</name></decl></param>,
                         <param><decl><type><name>nsIPrincipal</name>*</type> <name>aSheetPrincipal</name></decl></param>,
                         <param><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>aDeclaration</name></decl></param>,
                         <param><decl><type><name>PRBool</name>*</type> <name>aChanged</name></decl></param>,
                         <param><decl><type><name>PRBool</name></type> <name>aIsImportant</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type> <name>ParseMediaList</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type> <name>aBuffer</name></decl></param>,
                          <param><decl><type><name>nsIURI</name>*</type> <name>aURL</name></decl></param>, <comment type="line">// for error reporting</comment>
                          <param><decl><type><name>PRUint32</name></type> <name>aLineNumber</name></decl></param>, <comment type="line">// for error reporting</comment>
                          <param><decl><type><name>nsMediaList</name>*</type> <name>aMediaList</name></decl></param>,
                          <param><decl><type><name>PRBool</name></type> <name>aHTMLMode</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type> <name>ParseColorString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type> <name>aBuffer</name></decl></param>,
                            <param><decl><type><name>nsIURI</name>*</type> <name>aURL</name></decl></param>, <comment type="line">// for error reporting</comment>
                            <param><decl><type><name>PRUint32</name></type> <name>aLineNumber</name></decl></param>, <comment type="line">// for error reporting</comment>
                            <param><decl><type><name>nscolor</name>*</type> <name>aColor</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsresult</name></type> <name>ParseSelectorString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type> <name>aSelectorString</name></decl></param>,
                               <param><decl><type><name>nsIURI</name>*</type> <name>aURL</name></decl></param>, <comment type="line">// for error reporting</comment>
                               <param><decl><type><name>PRUint32</name></type> <name>aLineNumber</name></decl></param>, <comment type="line">// for error reporting</comment>
                               <param><decl><type><name>nsCSSSelectorList</name> **</type><name>aSelectorList</name></decl></param>)</parameter_list>;</function_decl>

</public><protected>protected:
  <class_decl>class <name>nsAutoParseCompoundProperty</name>;</class_decl>
  <class_decl><specifier>friend</specifier> class <name>nsAutoParseCompoundProperty</name>;</class_decl>

  <function_decl><type><name>void</name></type> <name>AppendRule</name><parameter_list>(<param><decl><type><name>nsICSSRule</name>*</type> <name>aRule</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>friend</specifier> <name>void</name></type> <name>AppendRuleToSheet</name><parameter_list>(<param><decl><type><name>nsICSSRule</name>*</type></decl></param>, <param><decl><type><name>void</name>*</type></decl></param>)</parameter_list>;</function_decl> <comment type="line">// calls AppendRule</comment>

  <comment type="block" format="doxygen">/**
   * This helper class automatically calls SetParsingCompoundProperty in its
   * constructor and takes care of resetting it to false in its destructor.
   */</comment>
  <class>class <name>nsAutoParseCompoundProperty</name> <block>{<private type="default">
    </private><public>public:
      <constructor><name>nsAutoParseCompoundProperty</name><parameter_list>(<param><decl><type><name>CSSParserImpl</name>*</type> <name>aParser</name></decl></param>)</parameter_list> <member_list>: <call><name>mParser</name><argument_list>(<argument><expr><name>aParser</name></expr></argument>)</argument_list></call>
      </member_list><block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name><name>aParser</name>-&gt;<name>IsParsingCompoundProperty</name></name><argument_list>()</argument_list></call></expr></argument>,
                     <argument><expr>"already parsing compound property"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aParser</name></expr></argument>, <argument><expr>"Null parser?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>aParser</name>-&gt;<name>SetParsingCompoundProperty</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></constructor>

      <destructor><name>~<name>nsAutoParseCompoundProperty</name></name><parameter_list>()</parameter_list>
      <block>{
        <expr_stmt><expr><call><name><name>mParser</name>-&gt;<name>SetParsingCompoundProperty</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></destructor>
    </public><private>private:
      <decl_stmt><decl><type><name>CSSParserImpl</name>*</type> <name>mParser</name></decl>;</decl_stmt>
  </private>}</block>;</class>

  <function_decl><type><name>void</name></type> <name>InitScanner</name><parameter_list>(<param><decl><type><name>nsIUnicharInputStream</name>*</type> <name>aInput</name></decl></param>, <param><decl><type><name>nsIURI</name>*</type> <name>aSheetURI</name></decl></param>,
                   <param><decl><type><name>PRUint32</name></type> <name>aLineNumber</name></decl></param>, <param><decl><type><name>nsIURI</name>*</type> <name>aBaseURI</name></decl></param>,
                   <param><decl><type><name>nsIPrincipal</name>*</type> <name>aSheetPrincipal</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="line">// the caller must hold on to aBuffer until parsing is done</comment>
  <function_decl><type><name>void</name></type> <name>InitScanner</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type> <name>aString</name></decl></param>, <param><decl><type><name>nsIURI</name>*</type> <name>aSheetURI</name></decl></param>,
                   <param><decl><type><name>PRUint32</name></type> <name>aLineNumber</name></decl></param>, <param><decl><type><name>nsIURI</name>*</type> <name>aBaseURI</name></decl></param>,
                   <param><decl><type><name>nsIPrincipal</name>*</type> <name>aSheetPrincipal</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>ReleaseScanner</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
  <function><type><name>PRBool</name></type> <name>IsSVGMode</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{
    <return>return <expr><call><name><name>mScanner</name>.<name>IsSVGMode</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <function_decl><type><name>PRBool</name></type> <name>GetToken</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aSkipWS</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>UngetToken</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// get the part in paretheses of the url() function, which is really a</comment>
  <comment type="line">// part of a token in the CSS grammar, but we're using a combination</comment>
  <comment type="line">// of the parser and the scanner to do it to handle the backtracking</comment>
  <comment type="line">// required by the error handling of the tokenization (since if we</comment>
  <comment type="line">// fail to scan the full token, we should fall back to tokenizing as</comment>
  <comment type="line">// FUNCTION ... ')').</comment>
  <comment type="line">// Note that this function WILL WRITE TO aURL IN SOME FAILURE CASES.</comment>
  <function_decl><type><name>PRBool</name></type> <name>GetURLInParens</name><parameter_list>(<param><decl><type><name>nsString</name>&amp;</type> <name>aURL</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><name>void</name></type> <name>AssertInitialState</name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mHTMLMediaMode</name></expr></argument>, <argument><expr>"Bad initial state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mParsingCompoundProperty</name></expr></argument>, <argument><expr>"Bad initial state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function_decl><type><name>PRBool</name></type> <name>ExpectSymbol</name><parameter_list>(<param><decl><type><name>PRUnichar</name></type> <name>aSymbol</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aSkipWS</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ExpectEndProperty</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>CheckEndProperty</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>nsSubstring</name>*</type> <name>NextIdent</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>SkipUntil</name><parameter_list>(<param><decl><type><name>PRUnichar</name></type> <name>aStopSymbol</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>SkipUntilOneOf</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aStopSymbolChars</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>SkipRuleSet</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aInsideBraces</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>SkipAtRule</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>SkipDeclaration</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCheckForBraces</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>PRBool</name></type> <name>PushGroup</name><parameter_list>(<param><decl><type><name>nsICSSGroupRule</name>*</type> <name>aRule</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>PopGroup</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>PRBool</name></type> <name>ParseRuleSet</name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>,
                      <param><decl><type><name>PRBool</name></type> <name>aInsideBraces</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseAtRule</name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseCharsetRule</name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseImportRule</name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>GatherURL</name><parameter_list>(<param><decl><type><name>nsString</name>&amp;</type> <name>aURL</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>GatherMedia</name><parameter_list>(<param><decl><type><name>nsMediaList</name>*</type> <name>aMedia</name></decl></param>,
                     <param><decl><type><name>PRUnichar</name></type> <name>aStopSymbol</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseMediaQuery</name><parameter_list>(<param><decl><type><name>PRUnichar</name></type> <name>aStopSymbol</name></decl></param>, <param><decl><type><name>nsMediaQuery</name> **</type><name>aQuery</name></decl></param>,
                         <param><decl><type><name>PRBool</name> *</type><name>aParsedSomething</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>aHitStop</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseMediaQueryExpression</name><parameter_list>(<param><decl><type><name>nsMediaQuery</name>*</type> <name>aQuery</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>ProcessImport</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aURLSpec</name></decl></param>,
                     <param><decl><type><name>nsMediaList</name>*</type> <name>aMedia</name></decl></param>,
                     <param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseGroupRule</name><parameter_list>(<param><decl><type><name>nsICSSGroupRule</name>*</type> <name>aRule</name></decl></param>, <param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>,
                        <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseMediaRule</name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseMozDocumentRule</name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseNameSpaceRule</name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>ProcessNameSpace</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aPrefix</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aURLSpec</name></decl></param>, <param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>,
                        <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>PRBool</name></type> <name>ParseFontFaceRule</name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseFontDescriptor</name><parameter_list>(<param><decl><type><name>nsCSSFontFaceRule</name>*</type> <name>aRule</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseFontDescriptorValue</name><parameter_list>(<param><decl><type><name>nsCSSFontDesc</name></type> <name>aDescID</name></decl></param>,
                                  <param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>PRBool</name></type> <name>ParsePageRule</name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aProcessData</name></decl></param>)</parameter_list>;</function_decl>

  <enum>enum <name>nsSelectorParsingStatus</name> <block>{
    <comment type="line">// we have parsed a selector and we saw a token that cannot be</comment>
    <comment type="line">// part of a selector:</comment>
    <decl><name>eSelectorParsingStatus_Done</name></decl>,
    <comment type="line">// we should continue parsing the selector:</comment>
    <decl><name>eSelectorParsingStatus_Continue</name></decl>,
    <comment type="line">// we saw an unexpected token or token value,</comment>
    <comment type="line">// or we saw end-of-file with an unfinished selector:</comment>
    <decl><name>eSelectorParsingStatus_Error</name></decl>
  }</block>;</enum>
  <function_decl><type><name>nsSelectorParsingStatus</name></type> <name>ParseIDSelector</name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                          <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsSelectorParsingStatus</name></type> <name>ParseClassSelector</name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                             <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// aPseudoElement and aPseudoElementArgs are the location where</comment>
  <comment type="line">// pseudo-elements (as opposed to pseudo-classes) are stored;</comment>
  <comment type="line">// pseudo-classes are stored on aSelector.  aPseudoElement and</comment>
  <comment type="line">// aPseudoElementArgs must be non-null iff !aIsNegated.</comment>
  <function_decl><type><name>nsSelectorParsingStatus</name></type> <name>ParsePseudoSelector</name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                              <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>,
                                              <param><decl><type><name>PRBool</name></type>         <name>aIsNegated</name></decl></param>,
                                              <param><decl><type><name>nsIAtom</name>**</type>      <name>aPseudoElement</name></decl></param>,
                                              <param><decl><type><name>nsPseudoClassList</name>**</type> <name>aPseudoElementArgs</name></decl></param>,
                                              <param><decl><type><name><name>nsCSSPseudoElements</name>::<name>Type</name></name>*</type> <name>aPseudoElementType</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsSelectorParsingStatus</name></type> <name>ParseAttributeSelector</name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                                 <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsSelectorParsingStatus</name></type> <name>ParseTypeOrUniversalSelector</name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                                       <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>,
                                                       <param><decl><type><name>PRBool</name></type>         <name>aIsNegated</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsSelectorParsingStatus</name></type> <name>ParsePseudoClassWithIdentArg</name><parameter_list>(<param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>,
                                                       <param><decl><type><name>nsIAtom</name>*</type>       <name>aPseudo</name></decl></param>,
                                                       <param><decl><type><name><name>nsCSSPseudoClasses</name>::<name>Type</name></name></type> <name>aType</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsSelectorParsingStatus</name></type> <name>ParsePseudoClassWithNthPairArg</name><parameter_list>(<param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>,
                                                         <param><decl><type><name>nsIAtom</name>*</type>       <name>aPseudo</name></decl></param>,
                                                         <param><decl><type><name><name>nsCSSPseudoClasses</name>::<name>Type</name></name></type> <name>aType</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsSelectorParsingStatus</name></type> <name>ParsePseudoClassWithSelectorListArg</name><parameter_list>(<param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>,
                                                              <param><decl><type><name>nsIAtom</name>*</type>       <name>aPseudo</name></decl></param>,
                                                              <param><decl><type><name><name>nsCSSPseudoClasses</name>::<name>Type</name></name></type> <name>aType</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>nsSelectorParsingStatus</name></type> <name>ParseNegatedSimpleSelector</name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                                     <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// If aStopChar is non-zero, the selector list is done when we hit</comment>
  <comment type="line">// aStopChar.  Otherwise, it's done when we hit EOF.</comment>
  <function_decl><type><name>PRBool</name></type> <name>ParseSelectorList</name><parameter_list>(<param><decl><type><name>nsCSSSelectorList</name>*&amp;</type> <name>aListHead</name></decl></param>,
                           <param><decl><type><name>PRUnichar</name></type> <name>aStopChar</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseSelectorGroup</name><parameter_list>(<param><decl><type><name>nsCSSSelectorList</name>*&amp;</type> <name>aListHead</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseSelector</name><parameter_list>(<param><decl><type><name>nsCSSSelectorList</name>*</type> <name>aList</name></decl></param>, <param><decl><type><name>PRUnichar</name></type> <name>aPrevCombinator</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>ParseDeclarationBlock</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCheckForBraces</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseDeclaration</name><parameter_list>(<param><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>aDeclaration</name></decl></param>,
                          <param><decl><type><name>PRBool</name></type> <name>aCheckForBraces</name></decl></param>,
                          <param><decl><type><name>PRBool</name></type> <name>aMustCallValueAppended</name></decl></param>,
                          <param><decl><type><name>PRBool</name>*</type> <name>aChanged</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>PRBool</name></type> <name>ParseProperty</name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseSingleValueProperty</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                  <param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>;</function_decl>

  <enum>enum <name>PriorityParsingStatus</name> <block>{
    <decl><name>ePriority_None</name></decl>,
    <decl><name>ePriority_Important</name></decl>,
    <decl><name>ePriority_Error</name></decl>
  }</block>;</enum>
  <function_decl><type><name>PriorityParsingStatus</name></type> <name>ParsePriority</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
  <function_decl><type><name>PRBool</name></type> <name>ParseTreePseudoElement</name><parameter_list>(<param><decl><type><name>nsPseudoClassList</name> **</type><name>aPseudoElementArgs</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <function_decl><type><name>void</name></type> <name>InitBoxPropsAsPhysical</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name> *</type><name>aSourceProperties</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Property specific parsing routines</comment>
  <function_decl><type><name>PRBool</name></type> <name>ParseAzimuth</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBackground</name><parameter_list>()</parameter_list>;</function_decl>

  <struct>struct <name>BackgroundParseState</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type>  <name>mColor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>mImage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>mRepeat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>mAttachment</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>mClip</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>mOrigin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValuePairList</name>*</type> <name>mPosition</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValuePairList</name>*</type> <name>mSize</name></decl>;</decl_stmt>
  </public>}</block>;</struct>

  <function_decl><type><name>PRBool</name></type> <name>ParseBackgroundItem</name><parameter_list>(<param><decl><type><name>BackgroundParseState</name>&amp;</type> <name>aState</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>PRBool</name></type> <name>ParseBackgroundList</name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>;</function_decl> <comment type="line">// a single value prop-id</comment>
  <function_decl><type><name>PRBool</name></type> <name>ParseBackgroundPosition</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBoxPositionValues</name><parameter_list>(<param><decl><type><name>nsCSSValuePair</name>&amp;</type> <name>aOut</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aAcceptsInherit</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBackgroundSize</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBackgroundSizeValues</name><parameter_list>(<param><decl><type><name>nsCSSValuePair</name>&amp;</type> <name>aOut</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBorderColor</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBorderColors</name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aProperty</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBorderImage</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBorderSpacing</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBorderSide</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>aPropIDs</name><index>[]</index></name></decl></param>,
                         <param><decl><type><name>PRBool</name></type> <name>aSetAllSides</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseDirectionalBorderSide</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>aPropIDs</name><index>[]</index></name></decl></param>,
                                    <param><decl><type><name>PRInt32</name></type> <name>aSourceType</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBorderStyle</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBorderWidth</name><parameter_list>()</parameter_list>;</function_decl>

  <function_decl><type><name>PRBool</name></type> <name>ParseCalc</name><parameter_list>(<param><decl><type><name>nsCSSValue</name> &amp;</type><name>aValue</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aVariantMask</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseCalcAdditiveExpression</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                     <param><decl><type><name>PRInt32</name>&amp;</type> <name>aVariantMask</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseCalcMultiplicativeExpression</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name>&amp;</type> <name>aVariantMask</name></decl></param>,
                                           <param><decl><type><name>PRBool</name> *</type><name>aHadFinalWS</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseCalcTerm</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><name>PRInt32</name>&amp;</type> <name>aVariantMask</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseCalcMinMax</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><name>nsCSSUnit</name></type> <name>aUnit</name></decl></param>,
                         <param><decl><type><name>PRInt32</name>&amp;</type> <name>aVariantMask</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>RequireWhitespace</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// for 'clip' and '-moz-image-region'</comment>
  <function_decl><type><name>PRBool</name></type> <name>ParseRect</name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseContent</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseCounterData</name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseCue</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseCursor</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseFont</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseFontWeight</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseOneFamily</name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseFamily</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseFontSrc</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseFontSrcFormat</name><parameter_list>(<param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsCSSValue</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>values</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseFontRanges</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseListStyle</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseMargin</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseMarks</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseMozTransform</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseOutline</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseOverflow</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParsePadding</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParsePause</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseQuotes</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseSize</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseTextDecoration</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>PRBool</name></type> <name>ParseShadowItem</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsBoxShadow</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseShadowList</name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aProperty</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseTransitionTime</name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseTransitionProperty</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseTransition</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseTransitionTimingFunction</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseTransitionTimingFunctionValues</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseTransitionTimingFunctionValueComponent</name><parameter_list>(<param><decl><type><name>float</name>&amp;</type> <name>aComponent</name></decl></param>,
                                                     <param><decl><type><name>char</name></type> <name>aStop</name></decl></param>,
                                                     <param><decl><type><name>PRBool</name></type> <name>aCheckRange</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
  <function_decl><type><name>PRBool</name></type> <name>ParsePaint</name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseDasharray</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseMarker</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Reused utility parsing routines</comment>
  <function_decl><type><name>void</name></type> <name>AppendValue</name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBoxProperties</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>aPropIDs</name><index>[]</index></name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseDirectionalBoxProperty</name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aProperty</name></decl></param>,
                                     <param><decl><type><name>PRInt32</name></type> <name>aSourceType</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBoxCornerRadius</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseBoxCornerRadii</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>aPropIDs</name><index>[]</index></name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRInt32</name></type> <name>ParseChoice</name><parameter_list>(<param><decl><type><name>nsCSSValue</name></type> <name><name>aValues</name><index>[]</index></name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>aPropIDs</name><index>[]</index></name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aNumIDs</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseColor</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseColorComponent</name><parameter_list>(<param><decl><type><name>PRUint8</name>&amp;</type> <name>aComponent</name></decl></param>,
                             <param><decl><type><name>PRInt32</name>&amp;</type> <name>aType</name></decl></param>, <param><decl><type><name>char</name></type> <name>aStop</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="line">// ParseHSLColor parses everything starting with the opening '('</comment>
  <comment type="line">// up through and including the aStop char.</comment>
  <function_decl><type><name>PRBool</name></type> <name>ParseHSLColor</name><parameter_list>(<param><decl><type><name>nscolor</name>&amp;</type> <name>aColor</name></decl></param>, <param><decl><type><name>char</name></type> <name>aStop</name></decl></param>)</parameter_list>;</function_decl>
  <comment type="line">// ParseColorOpacity will enforce that the color ends with a ')'</comment>
  <comment type="line">// after the opacity</comment>
  <function_decl><type><name>PRBool</name></type> <name>ParseColorOpacity</name><parameter_list>(<param><decl><type><name>PRUint8</name>&amp;</type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseEnum</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aKeywordTable</name><index>[]</index></name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseVariant</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                      <param><decl><type><name>PRInt32</name></type> <name>aVariantMask</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aKeywordTable</name><index>[]</index></name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseNonNegativeVariant</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                 <param><decl><type><name>PRInt32</name></type> <name>aVariantMask</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aKeywordTable</name><index>[]</index></name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParsePositiveNonZeroVariant</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                     <param><decl><type><name>PRInt32</name></type> <name>aVariantMask</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aKeywordTable</name><index>[]</index></name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseCounter</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseAttr</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>SetValueToURL</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aURL</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseURL</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>TranslateDimension</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aVariantMask</name></decl></param>,
                            <param><decl><type><name>float</name></type> <name>aNumber</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aUnit</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseImageRect</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aImage</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseElement</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseColorStop</name><parameter_list>(<param><decl><type><name>nsCSSValueGradient</name>*</type> <name>aGradient</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseGradient</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsRadial</name></decl></param>,
                       <param><decl><type><name>PRBool</name></type> <name>aIsRepeating</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><name>void</name></type> <name>SetParsingCompoundProperty</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aBool</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aBool</name> == <name>PR_TRUE</name> || <name>aBool</name> == <name>PR_FALSE</name></expr></argument>, <argument><expr>"bad PRBool value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mParsingCompoundProperty</name> = <name>aBool</name></expr>;</expr_stmt>
  }</block></function>
  <function><type><name>PRBool</name></type> <name>IsParsingCompoundProperty</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <specifier>const</specifier> <block>{
    <return>return <expr><name>mParsingCompoundProperty</name></expr>;</return>
  }</block></function>

  <comment type="block">/* Functions for -moz-transform Parsing */</comment>
  <function_decl><type><name>PRBool</name></type> <name>ParseSingleTransform</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseFunction</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name> &amp;</type><name>aFunction</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aAllowedTypes</name><index>[]</index></name></decl></param>,
                       <param><decl><type><name>PRUint16</name></type> <name>aMinElems</name></decl></param>, <param><decl><type><name>PRUint16</name></type> <name>aMaxElems</name></decl></param>,
                       <param><decl><type><name>nsCSSValue</name> &amp;</type><name>aValue</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>PRBool</name></type> <name>ParseFunctionInternals</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aVariantMask</name><index>[]</index></name></decl></param>,
                                <param><decl><type><name>PRUint16</name></type> <name>aMinElems</name></decl></param>,
                                <param><decl><type><name>PRUint16</name></type> <name>aMaxElems</name></decl></param>,
                                <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsCSSValue</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aOutput</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Functions for -moz-transform-origin Parsing */</comment>
  <function_decl><type><name>PRBool</name></type> <name>ParseMozTransformOrigin</name><parameter_list>()</parameter_list>;</function_decl>


  <comment type="block">/* Find and return the namespace ID associated with aPrefix.
     If aPrefix has not been declared in an @namespace rule, returns
     kNameSpaceID_Unknown and sets mFoundUnresolvablePrefix to true. */</comment>
  <function_decl><type><name>PRInt32</name></type> <name>GetNamespaceIdForPrefix</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aPrefix</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Find the correct default namespace, and set it on aSelector. */</comment>
  <function_decl><type><name>void</name></type> <name>SetDefaultNamespaceOnSelector</name><parameter_list>(<param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Current token. The value is valid after calling GetToken and invalidated</comment>
  <comment type="line">// by UngetToken.</comment>
  <decl_stmt><decl><type><name>nsCSSToken</name></type> <name>mToken</name></decl>;</decl_stmt>

  <comment type="line">// Our scanner.</comment>
  <decl_stmt><decl><type><name>nsCSSScanner</name></type> <name>mScanner</name></decl>;</decl_stmt>

  <comment type="line">// The URI to be used as a base for relative URIs.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>mBaseURI</name></decl>;</decl_stmt>

  <comment type="line">// The URI to be used as an HTTP "Referer" and for error reporting.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>mSheetURI</name></decl>;</decl_stmt>

  <comment type="line">// The principal of the sheet involved</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrincipal</name></expr></argument>&gt;</argument_list></name></type> <name>mSheetPrincipal</name></decl>;</decl_stmt>

  <comment type="line">// The sheet we're parsing into</comment>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCSSStyleSheet</name></expr></argument>&gt;</argument_list></name></type> <name>mSheet</name></decl>;</decl_stmt>

  <comment type="line">// Used for @import rules</comment>
  <decl_stmt><decl><type><name><name>mozilla</name>::<name>css</name>::<name>Loader</name></name>*</type> <name>mChildLoader</name></decl>;</decl_stmt> <comment type="line">// not ref counted, it owns us</comment>

  <comment type="line">// Sheet section we're in.  This is used to enforce correct ordering of the</comment>
  <comment type="line">// various rule types (eg the fact that a @charset rule must come before</comment>
  <comment type="line">// anything else).  Note that there are checks of similar things in various</comment>
  <comment type="line">// places in nsCSSStyleSheet.cpp (e.g in insertRule, RebuildChildList).</comment>
  <enum>enum <name>nsCSSSection</name> <block>{
    <decl><name>eCSSSection_Charset</name></decl>,
    <decl><name>eCSSSection_Import</name></decl>,
    <decl><name>eCSSSection_NameSpace</name></decl>,
    <decl><name>eCSSSection_General</name></decl>
  }</block>;</enum>
  <decl_stmt><decl><type><name>nsCSSSection</name></type>  <name>mSection</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsXMLNameSpaceMap</name> *</type><name>mNameSpaceMap</name></decl>;</decl_stmt>  <comment type="line">// weak, mSheet owns it</comment>

  <comment type="line">// After an UngetToken is done this flag is true. The next call to</comment>
  <comment type="line">// GetToken clears the flag.</comment>
  <macro><name>PRPackedBool</name></macro> <label><name>mHavePushBack</name> :</label> <expr_stmt><expr>1</expr>;</expr_stmt>

  <comment type="line">// True if we are in quirks mode; false in standards or almost standards mode</comment>
  <macro><name>PRPackedBool</name></macro>  <label><name>mNavQuirkMode</name> :</label> <expr_stmt><expr>1</expr>;</expr_stmt>

  <comment type="line">// True if unsafe rules should be allowed</comment>
  <macro><name>PRPackedBool</name></macro> <label><name>mUnsafeRulesEnabled</name> :</label> <expr_stmt><expr>1</expr>;</expr_stmt>

  <comment type="line">// True for parsing media lists for HTML attributes, where we have to</comment>
  <comment type="line">// ignore CSS comments.</comment>
  <macro><name>PRPackedBool</name></macro> <label><name>mHTMLMediaMode</name> :</label> <expr_stmt><expr>1</expr>;</expr_stmt>

  <comment type="line">// This flag is set when parsing a non-box shorthand; it's used to not apply</comment>
  <comment type="line">// some quirks during shorthand parsing</comment>
  <macro><name>PRPackedBool</name></macro>  <label><name>mParsingCompoundProperty</name> :</label> <expr_stmt><expr>1</expr>;</expr_stmt>

  <comment type="line">// GetNamespaceIdForPrefix will set mFoundUnresolvablePrefix to true</comment>
  <comment type="line">// when it encounters a prefix that is not mapped to a namespace.</comment>
  <macro><name>PRPackedBool</name></macro>  <label><name>mFoundUnresolvablePrefix</name> :</label> <expr_stmt><expr>1</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <macro><name>PRPackedBool</name></macro> <label><name>mScannerInited</name> :</label> <expr_stmt><expr>1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Stack of rule groups; used for @media and such.</comment>
  <decl_stmt><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsICSSGroupRule</name></expr></argument>&gt;</argument_list></name></type> <name>mGroupStack</name></decl>;</decl_stmt>

  <comment type="line">// During the parsing of a property (which may be a shorthand), the data</comment>
  <comment type="line">// are stored in |mTempData|.  (It is needed to ensure that parser</comment>
  <comment type="line">// errors cause the data to be ignored, and to ensure that a</comment>
  <comment type="line">// non-'!important' declaration does not override an '!important'</comment>
  <comment type="line">// one.)</comment>
  <decl_stmt><decl><type><name>nsCSSExpandedDataBlock</name></type> <name>mTempData</name></decl>;</decl_stmt>

  <comment type="line">// All data from successfully parsed properties are placed into |mData|.</comment>
  <decl_stmt><decl><type><name>nsCSSExpandedDataBlock</name></type> <name>mData</name></decl>;</decl_stmt>

</protected><public>public:
  <comment type="line">// Used from nsCSSParser constructors and destructors</comment>
  <decl_stmt><decl><type><name>CSSParserImpl</name>*</type> <name>mNextFree</name></decl>;</decl_stmt>
</public>}</block>;</class>

<function><type><specifier>static</specifier> <name>void</name></type> <name>AppendRuleToArray</name><parameter_list>(<param><decl><type><name>nsICSSRule</name>*</type> <name>aRule</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aArray</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsICSSRule</name></expr></argument>&gt;</argument_list></name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aArray</name></expr></argument>)</argument_list></call>-&gt;<call><name>AppendObject</name><argument_list>(<argument><expr><name>aRule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>AppendRuleToSheet</name><parameter_list>(<param><decl><type><name>nsICSSRule</name>*</type> <name>aRule</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aParser</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>CSSParserImpl</name>*</type> <name>parser</name> <init>= <expr>(<name>CSSParserImpl</name>*) <name>aParser</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>parser</name>-&gt;<name>AppendRule</name></name><argument_list>(<argument><expr><name>aRule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CSS_REPORT_PARSE_ERRORS</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED</name><parameter_list>(<param><type><name>msg_</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>mScanner.ReportUnexpected(#msg_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED_P</name><parameter_list>(<param><type><name>msg_</name></type></param>, <param><type><name>params_</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>mScanner.ReportUnexpectedParams(#msg_, params_, NS_ARRAY_LENGTH(params_))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED_EOF</name><parameter_list>(<param><type><name>lf_</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>mScanner.ReportUnexpectedEOF(#lf_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED_EOF_CHAR</name><parameter_list>(<param><type><name>ch_</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>mScanner.ReportUnexpectedEOF(ch_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED_TOKEN</name><parameter_list>(<param><type><name>msg_</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>mScanner.ReportUnexpectedToken(mToken, #msg_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED_TOKEN_P</name><parameter_list>(<param><type><name>msg_</name></type></param>, <param><type><name>params_</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>mScanner.ReportUnexpectedTokenParams(mToken, #msg_, \
                                       params_, NS_ARRAY_LENGTH(params_))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_ERROR</name><parameter_list>()</parameter_list></cpp:macro> \
  <cpp:value>mScanner.OutputError()</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_ERROR</name><parameter_list>()</parameter_list></cpp:macro> \
  <cpp:value>mScanner.ClearError()</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED</name><parameter_list>(<param><type><name>msg_</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED_P</name><parameter_list>(<param><type><name>msg_</name></type></param>, <param><type><name>params_</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED_EOF</name><parameter_list>(<param><type><name>lf_</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED_EOF_CHAR</name><parameter_list>(<param><type><name>ch_</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED_TOKEN</name><parameter_list>(<param><type><name>msg_</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_UNEXPECTED_TOKEN_P</name><parameter_list>(<param><type><name>msg_</name></type></param>, <param><type><name>params_</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_ERROR</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_ERROR</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<constructor><name><name>CSSParserImpl</name>::<name>CSSParserImpl</name></name><parameter_list>()</parameter_list>
  <member_list>: <call><name>mToken</name><argument_list>()</argument_list></call>,
    <call><name>mScanner</name><argument_list>()</argument_list></call>,
    <call><name>mChildLoader</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
    <call><name>mSection</name><argument_list>(<argument><expr><name>eCSSSection_Charset</name></expr></argument>)</argument_list></call>,
    <call><name>mNameSpaceMap</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
    <call><name>mHavePushBack</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mNavQuirkMode</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mUnsafeRulesEnabled</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mHTMLMediaMode</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mParsingCompoundProperty</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mFoundUnresolvablePrefix</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    , <call><name>mScannerInited</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    , <call><name>mNextFree</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
</member_list><block>{
}</block></constructor>

<destructor><name><name>CSSParserImpl</name>::~<name>CSSParserImpl</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mData</name>.<name>AssertInitialState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mTempData</name>.<name>AssertInitialState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>SetStyleSheet</name></name><parameter_list>(<param><decl><type><name>nsCSSStyleSheet</name>*</type> <name>aSheet</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aSheet</name> != <name>mSheet</name></expr>)</condition><then> <block>{
    <comment type="line">// Switch to using the new sheet, if any</comment>
    <expr_stmt><expr><call><name><name>mGroupStack</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mSheet</name> = <name>aSheet</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mSheet</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mNameSpaceMap</name> = <call><name><name>mSheet</name>-&gt;<name>GetNameSpaceMap</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>mNameSpaceMap</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>SetQuirkMode</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aQuirkMode</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aQuirkMode</name> == <name>PR_TRUE</name> || <name>aQuirkMode</name> == <name>PR_FALSE</name></expr></argument>, <argument><expr>"bad PRBool value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mNavQuirkMode</name> = <name>aQuirkMode</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>SetSVGMode</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aSVGMode</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aSVGMode</name> == <name>PR_TRUE</name> || <name>aSVGMode</name> == <name>PR_FALSE</name></expr></argument>,
               <argument><expr>"bad PRBool value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetSVGMode</name></name><argument_list>(<argument><expr><name>aSVGMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>SetChildLoader</name></name><parameter_list>(<param><decl><type><name><name>mozilla</name>::<name>css</name>::<name>Loader</name></name>*</type> <name>aChildLoader</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mChildLoader</name> = <name>aChildLoader</name></expr>;</expr_stmt>  <comment type="line">// not ref counted, it owns us</comment>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>Reset</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>! <name>mScannerInited</name></expr></argument>, <argument><expr>"resetting with scanner active"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SetStyleSheet</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SetQuirkMode</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>SetSVGMode</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// MOZ_SVG</comment>
  <expr_stmt><expr><call><name>SetChildLoader</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>InitScanner</name></name><parameter_list>(<param><decl><type><name>nsIUnicharInputStream</name>*</type> <name>aInput</name></decl></param>, <param><decl><type><name>nsIURI</name>*</type> <name>aSheetURI</name></decl></param>,
                           <param><decl><type><name>PRUint32</name></type> <name>aLineNumber</name></decl></param>, <param><decl><type><name>nsIURI</name>*</type> <name>aBaseURI</name></decl></param>,
                           <param><decl><type><name>nsIPrincipal</name>*</type> <name>aSheetPrincipal</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>! <name>mScannerInited</name></expr></argument>, <argument><expr>"already have scanner"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>mScanner</name>.<name>Init</name></name><argument_list>(<argument><expr><name>aInput</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aSheetURI</name></expr></argument>, <argument><expr><name>aLineNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>mScannerInited</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>mBaseURI</name> = <name>aBaseURI</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSheetURI</name> = <name>aSheetURI</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSheetPrincipal</name> = <name>aSheetPrincipal</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>mHavePushBack</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>InitScanner</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type> <name>aString</name></decl></param>, <param><decl><type><name>nsIURI</name>*</type> <name>aSheetURI</name></decl></param>,
                           <param><decl><type><name>PRUint32</name></type> <name>aLineNumber</name></decl></param>, <param><decl><type><name>nsIURI</name>*</type> <name>aBaseURI</name></decl></param>,
                           <param><decl><type><name>nsIPrincipal</name>*</type> <name>aSheetPrincipal</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Having it not own the string is OK since the caller will hold on to</comment>
  <comment type="line">// the stream until we're done parsing.</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>! <name>mScannerInited</name></expr></argument>, <argument><expr>"already have scanner"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>mScanner</name>.<name>Init</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><call><name><name>aString</name>.<name>BeginReading</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aSheetURI</name></expr></argument>, <argument><expr><name>aLineNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>mScannerInited</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>mBaseURI</name> = <name>aBaseURI</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSheetURI</name> = <name>aSheetURI</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSheetPrincipal</name> = <name>aSheetPrincipal</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>mHavePushBack</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>ReleaseScanner</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mScanner</name>.<name>Close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>mScannerInited</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>mBaseURI</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSheetURI</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSheetPrincipal</name> = <name>nsnull</name></expr>;</expr_stmt>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>Parse</name></name><parameter_list>(<param><decl><type><name>nsIUnicharInputStream</name>*</type> <name>aInput</name></decl></param>,
                     <param><decl><type><name>nsIURI</name>*</type>                <name>aSheetURI</name></decl></param>,
                     <param><decl><type><name>nsIURI</name>*</type>                <name>aBaseURI</name></decl></param>,
                     <param><decl><type><name>nsIPrincipal</name>*</type>          <name>aSheetPrincipal</name></decl></param>,
                     <param><decl><type><name>PRUint32</name></type>               <name>aLineNumber</name></decl></param>,
                     <param><decl><type><name>PRBool</name></type>                 <name>aAllowUnsafeRules</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aSheetPrincipal</name></expr></argument>, <argument><expr>"Must have principal here!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aBaseURI</name></expr></argument>, <argument><expr>"need base URI"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aSheetURI</name></expr></argument>, <argument><expr>"need sheet URI"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AssertInitialState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>mSheet</name></expr></argument>, <argument><expr>"Must have sheet to parse into"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_STATE</name><argument_list>(<argument><expr><name>mSheet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>nsIURI</name>*</type> <name>uri</name> <init>= <expr><call><name><name>mSheet</name>-&gt;<name>GetSheetURI</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>equal</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>aSheetURI</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>&amp;<name>equal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; <name>equal</name></expr></argument>,
               <argument><expr>"Sheet URI does not match passed URI"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>mSheet</name>-&gt;<name>Principal</name></name><argument_list>()</argument_list></call>-&gt;<call><name>Equals</name><argument_list>(<argument><expr><name>aSheetPrincipal</name></expr></argument>,
                                                        <argument><expr>&amp;<name>equal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
               <name>equal</name></expr></argument>,
               <argument><expr>"Sheet principal does not match passed principal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>InitScanner</name><argument_list>(<argument><expr><name>aInput</name></expr></argument>, <argument><expr><name>aSheetURI</name></expr></argument>, <argument><expr><name>aLineNumber</name></expr></argument>, <argument><expr><name>aBaseURI</name></expr></argument>, <argument><expr><name>aSheetPrincipal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>ruleCount</name> <init>= <expr><call><name><name>mSheet</name>-&gt;<name>StyleRuleCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>0 &lt; <name>ruleCount</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsICSSRule</name>*</type> <name>lastRule</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mSheet</name>-&gt;<name>GetStyleRuleAt</name></name><argument_list>(<argument><expr><name>ruleCount</name> - 1</expr></argument>, <argument><expr><name>lastRule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>lastRule</name></expr>)</condition><then> <block>{
      <switch>switch <condition>(<expr><call><name><name>lastRule</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <case>case <expr><name><name>nsICSSRule</name>::<name>CHARSET_RULE</name></name></expr>:
        </case><case>case <expr><name><name>nsICSSRule</name>::<name>IMPORT_RULE</name></name></expr>:
          <expr_stmt><expr><name>mSection</name> = <name>eCSSSection_Import</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name><name>nsICSSRule</name>::<name>NAMESPACE_RULE</name></name></expr>:
          <expr_stmt><expr><name>mSection</name> = <name>eCSSSection_NameSpace</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><default>default:
          <expr_stmt><expr><name>mSection</name> = <name>eCSSSection_General</name></expr>;</expr_stmt>
          <break>break;</break>
      </default>}</block></switch>
      <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>lastRule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>mSection</name> = <name>eCSSSection_Charset</name></expr>;</expr_stmt> <comment type="line">// sheet is empty, any rules are fair</comment>
  }</block></else></if>

  <expr_stmt><expr><name>mUnsafeRulesEnabled</name> = <name>aAllowUnsafeRules</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <comment type="line">// Get next non-whitespace token</comment>
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_HTMLComment</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <continue>continue;</continue> <comment type="line">// legal here only</comment>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_AtKeyword</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>ParseAtRule</name><argument_list>(<argument><expr><name>AppendRuleToSheet</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    }</block></then></if>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>ParseRuleSet</name><argument_list>(<argument><expr><name>AppendRuleToSheet</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mSection</name> = <name>eCSSSection_General</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>ReleaseScanner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mUnsafeRulesEnabled</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <comment type="line">// XXX check for low level errors</comment>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Determines whether the identifier contained in the given string is a
 * vendor-specific identifier, as described in CSS 2.1 section 4.1.2.1.
 */</comment>
<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>NonMozillaVendorIdentifier</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>ident</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<call><name><name>ident</name>.<name>First</name></name><argument_list>()</argument_list></call> == <call><name>PRUnichar</name><argument_list>(<argument><expr>'-'</expr></argument>)</argument_list></call> &amp;&amp;
          !<call><name>StringBeginsWith</name><argument_list>(<argument><expr><name>ident</name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"-moz-"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) ||
         <call><name><name>ident</name>.<name>First</name></name><argument_list>()</argument_list></call> == <call><name>PRUnichar</name><argument_list>(<argument><expr>'_'</expr></argument>)</argument_list></call></expr>;</return>

}</block></function>

<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>ParseStyleAttribute</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aAttributeValue</name></decl></param>,
                                   <param><decl><type><name>nsIURI</name>*</type>                  <name>aDocURI</name></decl></param>,
                                   <param><decl><type><name>nsIURI</name>*</type>                  <name>aBaseURI</name></decl></param>,
                                   <param><decl><type><name>nsIPrincipal</name>*</type>            <name>aNodePrincipal</name></decl></param>,
                                   <param><decl><type><name>nsICSSStyleRule</name>**</type>        <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aNodePrincipal</name></expr></argument>, <argument><expr>"Must have principal here!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AssertInitialState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aBaseURI</name></expr></argument>, <argument><expr>"need base URI"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// XXX line number?</comment>
  <expr_stmt><expr><call><name>InitScanner</name><argument_list>(<argument><expr><name>aAttributeValue</name></expr></argument>, <argument><expr><name>aDocURI</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aBaseURI</name></expr></argument>, <argument><expr><name>aNodePrincipal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mSection</name> = <name>eCSSSection_General</name></expr>;</expr_stmt>

  <comment type="line">// In quirks mode, allow style declarations to have braces or not</comment>
  <comment type="line">// (bug 99554).</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>haveBraces</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mNavQuirkMode</name> &amp;&amp; <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>haveBraces</name> = <name>eCSSToken_Symbol</name> == <name><name>mToken</name>.<name>mType</name></name> &amp;&amp;
                 '{' == <name><name>mToken</name>.<name>mSymbol</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>haveBraces</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></else></if>

  <decl_stmt><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>declaration</name> <init>= <expr><call><name>ParseDeclarationBlock</name><argument_list>(<argument><expr><name>haveBraces</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>declaration</name></expr>)</condition><then> <block>{
    <comment type="line">// Create a style rule for the declaration</comment>
    <expr_stmt><expr>*<name>aResult</name> = <call><name>NS_NewCSSStyleRule</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>declaration</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr>*<name>aResult</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></else></if>

  <expr_stmt><expr><call><name>ReleaseScanner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// XXX check for low level errors</comment>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>ParseDeclarations</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type>  <name>aBuffer</name></decl></param>,
                                 <param><decl><type><name>nsIURI</name>*</type>           <name>aSheetURI</name></decl></param>,
                                 <param><decl><type><name>nsIURI</name>*</type>           <name>aBaseURI</name></decl></param>,
                                 <param><decl><type><name>nsIPrincipal</name>*</type>     <name>aSheetPrincipal</name></decl></param>,
                                 <param><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>aDeclaration</name></decl></param>,
                                 <param><decl><type><name>PRBool</name>*</type>           <name>aChanged</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aSheetPrincipal</name></expr></argument>, <argument><expr>"Must have principal here!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AssertInitialState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>aChanged</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>InitScanner</name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aSheetURI</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aBaseURI</name></expr></argument>, <argument><expr><name>aSheetPrincipal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mSection</name> = <name>eCSSSection_General</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>mData</name>.<name>AssertInitialState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aDeclaration</name>-&gt;<name>ClearData</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// We could check if it was already empty, but...</comment>
  <expr_stmt><expr>*<name>aChanged</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <comment type="line">// If we cleared the old decl, then we want to be calling</comment>
    <comment type="line">// ValueAppended as we parse.</comment>
    <if>if <condition>(<expr>!<call><name>ParseDeclaration</name><argument_list>(<argument><expr><name>aDeclaration</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>aChanged</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <call><name><name>mScanner</name>.<name>GetLowLevelError</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then></if>

      <if>if <condition>(<expr>!<call><name>SkipDeclaration</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>mScanner</name>.<name>GetLowLevelError</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></then></if>
  }</block></for>

  <expr_stmt><expr><call><name><name>aDeclaration</name>-&gt;<name>CompressFrom</name></name><argument_list>(<argument><expr>&amp;<name>mData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ReleaseScanner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>ParseRule</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type>        <name>aRule</name></decl></param>,
                         <param><decl><type><name>nsIURI</name>*</type>                 <name>aSheetURI</name></decl></param>,
                         <param><decl><type><name>nsIURI</name>*</type>                 <name>aBaseURI</name></decl></param>,
                         <param><decl><type><name>nsIPrincipal</name>*</type>           <name>aSheetPrincipal</name></decl></param>,
                         <param><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsICSSRule</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aSheetPrincipal</name></expr></argument>, <argument><expr>"Must have principal here!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AssertInitialState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>aBaseURI</name></expr></argument>, <argument><expr>"need base URI"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>InitScanner</name><argument_list>(<argument><expr><name>aRule</name></expr></argument>, <argument><expr><name>aSheetURI</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aBaseURI</name></expr></argument>, <argument><expr><name>aSheetPrincipal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mSection</name> = <name>eCSSSection_Charset</name></expr>;</expr_stmt> <comment type="line">// callers are responsible for rejecting invalid rules.</comment>

  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <comment type="line">// Get first non-whitespace token</comment>
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEParseRuleWSOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><name>eCSSToken_AtKeyword</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ParseAtRule</name><argument_list>(<argument><expr><name>AppendRuleToArray</name></expr></argument>, <argument><expr>&amp;<name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ParseRuleSet</name><argument_list>(<argument><expr><name>AppendRuleToArray</name></expr></argument>, <argument><expr>&amp;<name>aResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ReleaseScanner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// XXX check for low-level errors</comment>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>ParseProperty</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aPropValue</name></decl></param>,
                             <param><decl><type><name>nsIURI</name>*</type> <name>aSheetURI</name></decl></param>,
                             <param><decl><type><name>nsIURI</name>*</type> <name>aBaseURI</name></decl></param>,
                             <param><decl><type><name>nsIPrincipal</name>*</type> <name>aSheetPrincipal</name></decl></param>,
                             <param><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>aDeclaration</name></decl></param>,
                             <param><decl><type><name>PRBool</name>*</type> <name>aChanged</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type> <name>aIsImportant</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aSheetPrincipal</name></expr></argument>, <argument><expr>"Must have principal here!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aBaseURI</name></expr></argument>, <argument><expr>"need base URI"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aDeclaration</name></expr></argument>, <argument><expr>"Need declaration to parse into!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AssertInitialState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mData</name>.<name>AssertInitialState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mTempData</name>.<name>AssertInitialState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aDeclaration</name>-&gt;<name>AssertMutable</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>InitScanner</name><argument_list>(<argument><expr><name>aPropValue</name></expr></argument>, <argument><expr><name>aSheetURI</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aBaseURI</name></expr></argument>, <argument><expr><name>aSheetPrincipal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSection</name> = <name>eCSSSection_General</name></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>aChanged</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>eCSSProperty_UNKNOWN</name> == <name>aPropID</name></expr>)</condition><then> <block>{ <comment type="line">// unknown property</comment>
    <decl_stmt><decl><type><name>NS_ConvertASCIItoUTF16</name></type> <name>propName</name><argument_list>(<argument><expr><call><name><name>nsCSSProps</name>::<name>GetStringValue</name></name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[]</index></name> <init>= <expr><block>{
      <macro><name>propName</name></macro><expr>.<macro><name>get</name><argument_list>()</argument_list></macro></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_P</name><argument_list>(<argument><expr><name>PEUnknownProperty</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEDeclDropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseScanner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>parsedOK</name> <init>= <expr><call><name>ParseProperty</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// We should now be at EOF</comment>
  <if>if <condition>(<expr><name>parsedOK</name> &amp;&amp; <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectEndValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>parsedOK</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>parsedOK</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>NS_ConvertASCIItoUTF16</name></type> <name>propName</name><argument_list>(<argument><expr><call><name><name>nsCSSProps</name>::<name>GetStringValue</name></name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[]</index></name> <init>= <expr><block>{
      <macro><name>propName</name></macro><expr>.<macro><name>get</name><argument_list>()</argument_list></macro></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_P</name><argument_list>(<argument><expr><name>PEValueParsingError</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEDeclDropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mTempData</name>.<name>ClearProperty</name></name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{

    <comment type="line">// We know we don't need to force a ValueAppended call for the new</comment>
    <comment type="line">// value.  So if we are not processing a shorthand, and there's</comment>
    <comment type="line">// already a value for this property in the declaration at the</comment>
    <comment type="line">// same importance level, then we can just copy our parsed value</comment>
    <comment type="line">// directly into the declaration without going through the whole</comment>
    <comment type="line">// expand/compress thing.</comment>
    <if>if <condition>(<expr>!<call><name><name>aDeclaration</name>-&gt;<name>TryReplaceValue</name></name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>aIsImportant</name></expr></argument>, <argument><expr><name>mTempData</name></expr></argument>,
                                       <argument><expr><name>aChanged</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Do it the slow way</comment>
      <expr_stmt><expr><call><name><name>aDeclaration</name>-&gt;<name>ExpandTo</name></name><argument_list>(<argument><expr>&amp;<name>mData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>aChanged</name> = <call><name><name>mData</name>.<name>TransferFromBlock</name></name><argument_list>(<argument><expr><name>mTempData</name></expr></argument>, <argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>aIsImportant</name></expr></argument>,
                                          <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>aDeclaration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aDeclaration</name>-&gt;<name>CompressFrom</name></name><argument_list>(<argument><expr>&amp;<name>mData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>CLEAR_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <expr_stmt><expr><call><name><name>mTempData</name>.<name>AssertInitialState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>result</name> <init>= <expr><call><name><name>mScanner</name>.<name>GetLowLevelError</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ReleaseScanner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>ParseMediaList</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type> <name>aBuffer</name></decl></param>,
                              <param><decl><type><name>nsIURI</name>*</type> <name>aURI</name></decl></param>, <comment type="line">// for error reporting</comment>
                              <param><decl><type><name>PRUint32</name></type> <name>aLineNumber</name></decl></param>, <comment type="line">// for error reporting</comment>
                              <param><decl><type><name>nsMediaList</name>*</type> <name>aMediaList</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type> <name>aHTMLMode</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// XXX Are there cases where the caller wants to keep what it already</comment>
  <comment type="line">// has in case of parser error?</comment>
  <expr_stmt><expr><call><name><name>aMediaList</name>-&gt;<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// fake base URI since media lists don't have URIs in them</comment>
  <expr_stmt><expr><call><name>InitScanner</name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aURI</name></expr></argument>, <argument><expr><name>aLineNumber</name></expr></argument>, <argument><expr><name>aURI</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>AssertInitialState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aHTMLMode</name> == <name>PR_TRUE</name> || <name>aHTMLMode</name> == <name>PR_FALSE</name></expr></argument>,
               <argument><expr>"invalid PRBool"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mHTMLMediaMode</name> = <name>aHTMLMode</name></expr>;</expr_stmt>

    <comment type="line">// XXXldb We need to make the scanner not skip CSS comments!  (Or</comment>
    <comment type="line">// should we?)</comment>

  <comment type="line">// For aHTMLMode, we used to follow the parsing rules in</comment>
  <comment type="line">// http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-media-descriptors</comment>
  <comment type="line">// which wouldn't work for media queries since they remove all but the</comment>
  <comment type="line">// first word.  However, they're changed in</comment>
  <comment type="line">// http://www.whatwg.org/specs/web-apps/current-work/multipage/section-document.html#media2</comment>
  <comment type="line">// (as of 2008-05-29) which says that the media attribute just points</comment>
  <comment type="line">// to a media query.  (The main substative difference is the relative</comment>
  <comment type="line">// precedence of commas and paretheses.)</comment>

  <if>if <condition>(<expr>!<call><name>GatherMedia</name><argument_list>(<argument><expr><name>aMediaList</name></expr></argument>, <argument><expr><call><name>PRUnichar</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aMediaList</name>-&gt;<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aMediaList</name>-&gt;<name>SetNonEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// don't match anything</comment>
    <if>if <condition>(<expr>!<name>mHTMLMediaMode</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mScanner</name>.<name>GetLowLevelError</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>CLEAR_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ReleaseScanner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mHTMLMediaMode</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>ParseColorString</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type> <name>aBuffer</name></decl></param>,
                                <param><decl><type><name>nsIURI</name>*</type> <name>aURI</name></decl></param>, <comment type="line">// for error reporting</comment>
                                <param><decl><type><name>PRUint32</name></type> <name>aLineNumber</name></decl></param>, <comment type="line">// for error reporting</comment>
                                <param><decl><type><name>nscolor</name>*</type> <name>aColor</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>AssertInitialState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>InitScanner</name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aURI</name></expr></argument>, <argument><expr><name>aLineNumber</name></expr></argument>, <argument><expr><name>aURI</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>colorParsed</name> <init>= <expr><call><name>ParseColor</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mScanner</name>.<name>GetLowLevelError</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ReleaseScanner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>colorParsed</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> ? <name>rv</name> : <name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><call><name><name>value</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Ident</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nscolor</name></type> <name>rgba</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_ColorNameToRGB</name><argument_list>(<argument><expr><call><name>nsDependentString</name><argument_list>(<argument><expr><call><name><name>value</name>.<name>GetStringBufferValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>rgba</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr>(*<name>aColor</name>) = <name>rgba</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then> <else>else <if>if <condition>(<expr><call><name><name>value</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Color</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>(*<name>aColor</name>) = <call><name><name>value</name>.<name>GetColorValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><call><name><name>value</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_EnumColor</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>intValue</name> <init>= <expr><call><name><name>value</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>intValue</name> &gt;= 0</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsILookAndFeel</name></expr></argument>&gt;</argument_list></name></type> <name>lfSvc</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr>"@mozilla.org/widget/lookandfeel;1"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>lfSvc</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nscolor</name></type> <name>rgba</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>lfSvc</name>-&gt;<name>GetColor</name></name><argument_list>(<argument><expr>(<name><name>nsILookAndFeel</name>::<name>nsColorID</name></name>) <call><name><name>value</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rgba</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr>(*<name>aColor</name>) = <name>rgba</name></expr>;</expr_stmt></then></if>
      }</block></then></if>
    }</block></then> <else>else <block>{
      <comment type="line">// XXX - this is NS_COLOR_CURRENTCOLOR, NS_COLOR_MOZ_HYPERLINKTEXT, etc.</comment>
      <comment type="line">// which we don't handle as per the ParseColorString definition.  Should</comment>
      <comment type="line">// remove this limitation at some point.</comment>
      <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_FAILURE</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if></else></if></else></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>CSSParserImpl</name>::<name>ParseSelectorString</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type> <name>aSelectorString</name></decl></param>,
                                   <param><decl><type><name>nsIURI</name>*</type> <name>aURI</name></decl></param>, <comment type="line">// for error reporting</comment>
                                   <param><decl><type><name>PRUint32</name></type> <name>aLineNumber</name></decl></param>, <comment type="line">// for error reporting</comment>
                                   <param><decl><type><name>nsCSSSelectorList</name> **</type><name>aSelectorList</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>InitScanner</name><argument_list>(<argument><expr><name>aSelectorString</name></expr></argument>, <argument><expr><name>aURI</name></expr></argument>, <argument><expr><name>aLineNumber</name></expr></argument>, <argument><expr><name>aURI</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>AssertInitialState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// This is the only place that cares about mFoundUnresolvablePrefix,</comment>
  <comment type="line">// so this is the only place that bothers clearing it.</comment>
  <expr_stmt><expr><name>mFoundUnresolvablePrefix</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>success</name> <init>= <expr><call><name>ParseSelectorList</name><argument_list>(<argument><expr>*<name>aSelectorList</name></expr></argument>, <argument><expr><call><name>PRUnichar</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>prefixErr</name> <init>= <expr><name>mFoundUnresolvablePrefix</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ReleaseScanner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>success</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>*<name>aSelectorList</name></expr></argument>, <argument><expr>"Should have list!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!*<name>aSelectorList</name></expr></argument>, <argument><expr>"Shouldn't have list!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>prefixErr</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_DOM_NAMESPACE_ERR</name></expr>;</return></then></if>

  <return>return <expr><name>NS_ERROR_DOM_SYNTAX_ERR</name></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------------------------------------</comment>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>GetToken</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aSkipWS</name></decl></param>)</parameter_list>
<block>{
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<name>mHavePushBack</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name><name>mScanner</name>.<name>Next</name></name><argument_list>(<argument><expr><name>mToken</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>mHavePushBack</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>aSkipWS</name> &amp;&amp; (<name>eCSSToken_WhiteSpace</name> == <name><name>mToken</name>.<name>mType</name></name>)</expr>)</condition><then> <block>{
      <continue>continue;</continue>
    }</block></then></if>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></for>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>GetURLInParens</name></name><parameter_list>(<param><decl><type><name>nsString</name>&amp;</type> <name>aURL</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mHavePushBack</name></expr></argument>, <argument><expr>"mustn't have pushback at this point"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{
    <if>if <condition>(<expr>! <call><name><name>mScanner</name>.<name>NextURL</name></name><argument_list>(<argument><expr><name>mToken</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// EOF</comment>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block> while <condition>(<expr><name>eCSSToken_WhiteSpace</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition>;</do>

  <expr_stmt><expr><name>aURL</name> = <name><name>mToken</name>.<name>mIdent</name></name></expr>;</expr_stmt>

  <if>if <condition>(<expr>(<name>eCSSToken_String</name> != <name><name>mToken</name>.<name>mType</name></name> &amp;&amp; <name>eCSSToken_URL</name> != <name><name>mToken</name>.<name>mType</name></name>) ||
      !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// in the failure case, we do not have to match parentheses, since</comment>
    <comment type="line">// this is now an invalid URL token.</comment>
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>UngetToken</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mHavePushBack</name></expr></argument>, <argument><expr>"double pushback"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mHavePushBack</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ExpectSymbol</name></name><parameter_list>(<param><decl><type><name>PRUnichar</name></type> <name>aSymbol</name></decl></param>,
                            <param><decl><type><name>PRBool</name></type> <name>aSkipWS</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>aSkipWS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// CSS2.1 specifies that all "open constructs" are to be closed at</comment>
    <comment type="line">// EOF.  It simplifies higher layers if we claim to have found an</comment>
    <comment type="line">// ), ], }, or ; if we encounter EOF while looking for one of them.</comment>
    <comment type="line">// Do still issue a diagnostic, to aid debugging.</comment>
    <if>if <condition>(<expr><name>aSymbol</name> == ')' || <name>aSymbol</name> == ']' ||
        <name>aSymbol</name> == '}' || <name>aSymbol</name> == ';'</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF_CHAR</name><argument_list>(<argument><expr><name>aSymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then>
    <else>else
      <return>return <expr><name>PR_FALSE</name></expr>;</return></else></if>
  }</block></then></if>
  <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr><name>aSymbol</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// Checks to see if we're at the end of a property.  If an error occurs during</comment>
<comment type="line">// the check, does not signal a parse error.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>CheckEndProperty</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_TRUE</name></expr>;</return> <comment type="line">// properties may end with eof</comment>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>eCSSToken_Symbol</name> == <name><name>mToken</name>.<name>mType</name></name>) &amp;&amp;
      ((';' == <name><name>mToken</name>.<name>mSymbol</name></name>) ||
       ('!' == <name><name>mToken</name>.<name>mSymbol</name></name>) ||
       ('}' == <name><name>mToken</name>.<name>mSymbol</name></name>))</expr>)</condition><then> <block>{
    <comment type="line">// XXX need to verify that ! is only followed by "important [;|}]</comment>
    <comment type="line">// XXX this requires a multi-token pushback buffer</comment>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// Checks if we're at the end of a property, raising an error if we're not.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ExpectEndProperty</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <comment type="line">// If we're here, we read something incorrect, so we should report it.</comment>
  <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectEndValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// Parses the priority suffix on a property, which at present may be</comment>
<comment type="line">// either '!important' or nothing.</comment>
<function><type><name><name>CSSParserImpl</name>::<name>PriorityParsingStatus</name></name></type>
<name><name>CSSParserImpl</name>::<name>ParsePriority</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>ePriority_None</name></expr>;</return> <comment type="line">// properties may end with EOF</comment>
  }</block></then></if>
  <if>if <condition>(<expr>!<call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'!'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ePriority_None</name></expr>;</return> <comment type="line">// dunno what it is, but it's not a priority</comment>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// EOF is not ok after !</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEImportantEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ePriority_Error</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_Ident</name> ||
      !<call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"important"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedImportant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ePriority_Error</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>ePriority_Important</name></expr>;</return>
}</block></function>

<function><type><name>nsSubstring</name>*</type>
<name><name>CSSParserImpl</name>::<name>NextIdent</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// XXX Error reporting?</comment>
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>eCSSToken_Ident</name> != <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>
  <return>return <expr>&amp;<name><name>mToken</name>.<name>mIdent</name></name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>SkipAtRule</name></name><parameter_list>()</parameter_list>
<block>{
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PESkipAtRuleEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Symbol</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRUnichar</name></type> <name>symbol</name> <init>= <expr><name><name>mToken</name>.<name>mSymbol</name></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>symbol</name> == ';'</expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr><name>symbol</name> == '{'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>'}'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then> <else>else <if>if <condition>(<expr><name>symbol</name> == '('</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><name>symbol</name> == '['</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>']'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>eCSSToken_Function</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></for>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseAtRule</name></name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>,
                           <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSSection</name></type> <name>newSection</name></decl>;</decl_stmt>
  <function_decl><type><name>PRBool</name></type> (<name><name>CSSParserImpl</name>::*<name>parseFunc</name></name>)<parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type></decl></param>, <param><decl><type><name>void</name>*</type></decl></param>)</parameter_list>;</function_decl>

  <if>if <condition>(<expr>(<name>mSection</name> &lt;= <name>eCSSSection_Charset</name>) &amp;&amp;
      (<call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"charset"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>parseFunc</name> = &amp;<name><name>CSSParserImpl</name>::<name>ParseCharsetRule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSection</name> = <name>eCSSSection_Import</name></expr>;</expr_stmt>  <comment type="line">// only one charset allowed</comment>

  }</block></then> <else>else <if>if <condition>(<expr>(<name>mSection</name> &lt;= <name>eCSSSection_Import</name>) &amp;&amp;
             <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"import"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>parseFunc</name> = &amp;<name><name>CSSParserImpl</name>::<name>ParseImportRule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSection</name> = <name>eCSSSection_Import</name></expr>;</expr_stmt>

  }</block></then> <else>else <if>if <condition>(<expr>(<name>mSection</name> &lt;= <name>eCSSSection_NameSpace</name>) &amp;&amp;
             <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"namespace"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>parseFunc</name> = &amp;<name><name>CSSParserImpl</name>::<name>ParseNameSpaceRule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSection</name> = <name>eCSSSection_NameSpace</name></expr>;</expr_stmt>

  }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"media"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>parseFunc</name> = &amp;<name><name>CSSParserImpl</name>::<name>ParseMediaRule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSection</name> = <name>eCSSSection_General</name></expr>;</expr_stmt>

  }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-document"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>parseFunc</name> = &amp;<name><name>CSSParserImpl</name>::<name>ParseMozDocumentRule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSection</name> = <name>eCSSSection_General</name></expr>;</expr_stmt>

  }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"font-face"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>parseFunc</name> = &amp;<name><name>CSSParserImpl</name>::<name>ParseFontFaceRule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSection</name> = <name>eCSSSection_General</name></expr>;</expr_stmt>

  }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"page"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>parseFunc</name> = &amp;<name><name>CSSParserImpl</name>::<name>ParsePageRule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSection</name> = <name>eCSSSection_General</name></expr>;</expr_stmt>

  }</block></then> <else>else <block>{
    <if>if <condition>(<expr>!<call><name>NonMozillaVendorIdentifier</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEUnknownAtRule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// Skip over unsupported at rule, don't advance section</comment>
    <return>return <expr><call><name>SkipAtRule</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if>

  <if>if <condition>(<expr>!<call>(<name><name>this</name>-&gt;*<name>parseFunc</name></name>)<argument_list>(<argument><expr><name>aAppendFunc</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Skip over invalid at rule, don't advance section</comment>
    <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>SkipAtRule</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>mSection</name> = <name>newSection</name></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseCharsetRule</name></name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>,
                                <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PECharsetRuleEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>eCSSToken_String</name> != <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PECharsetRuleNotString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>charset</name> <init>= <expr><name><name>mToken</name>.<name>mIdent</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>';'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICSSRule</name></expr></argument>&gt;</argument_list></name></type> <name>rule</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_NewCSSCharsetRule</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>rule</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>charset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>rule</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call>(*<name>aAppendFunc</name>)<argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>GatherURL</name></name><parameter_list>(<param><decl><type><name>nsString</name>&amp;</type> <name>aURL</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>eCSSToken_String</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aURL</name> = <name><name>mToken</name>.<name>mIdent</name></name></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>eCSSToken_Function</name> == <name><name>mToken</name>.<name>mType</name></name> &amp;&amp;
           <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"url"</expr></argument>)</argument_list></call> &amp;&amp;
           <call><name>GetURLInParens</name><argument_list>(<argument><expr><name>aURL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if></else></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseMediaQuery</name></name><parameter_list>(<param><decl><type><name>PRUnichar</name></type> <name>aStopSymbol</name></decl></param>,
                               <param><decl><type><name>nsMediaQuery</name> **</type><name>aQuery</name></decl></param>,
                               <param><decl><type><name>PRBool</name> *</type><name>aParsedSomething</name></decl></param>,
                               <param><decl><type><name>PRBool</name> *</type><name>aHitStop</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aQuery</name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aParsedSomething</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aHitStop</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

  <comment type="line">// "If the comma-separated list is the empty list it is assumed to</comment>
  <comment type="line">// specify the media query 'all'."  (css3-mediaqueries, section</comment>
  <comment type="line">// "Media Queries")</comment>
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aHitStop</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <comment type="line">// expected termination by EOF</comment>
    <if>if <condition>(<expr><name>aStopSymbol</name> == <call><name>PRUnichar</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

    <comment type="line">// unexpected termination by EOF</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEGatherMediaEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>eCSSToken_Symbol</name> == <name><name>mToken</name>.<name>mType</name></name> &amp;&amp;
      <name><name>mToken</name>.<name>mSymbol</name></name> == <name>aStopSymbol</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aHitStop</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>aParsedSomething</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>nsMediaQuery</name></expr></argument>&gt;</argument_list></name></type> <name>query</name><argument_list>(<argument><expr>new <name>nsMediaQuery</name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>query</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>'('</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// we got an expression without a media type</comment>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// so ParseMediaQueryExpression can handle it</comment>
    <expr_stmt><expr><call><name><name>query</name>-&gt;<name>SetType</name></name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>all</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>query</name>-&gt;<name>SetTypeOmitted</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Just parse the first expression here.</comment>
    <if>if <condition>(<expr>!<call><name>ParseMediaQueryExpression</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>query</name>-&gt;<name>SetHadUnknownExpression</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>mediaType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>gotNotOrOnly</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEGatherMediaEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><name>eCSSToken_Ident</name> != <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEGatherMediaNotIdent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <comment type="line">// case insensitive from CSS - must be lower cased</comment>
      <expr_stmt><expr><call><name><name>nsContentUtils</name>::<name>ASCIIToLower</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mediaType</name> = <call><name>do_GetAtom</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>gotNotOrOnly</name> ||
          (<name>mediaType</name> != <name><name>nsGkAtoms</name>::<name>_not</name></name> &amp;&amp; <name>mediaType</name> != <name><name>nsGkAtoms</name>::<name>only</name></name>)</expr>)</condition><then>
        <break>break;</break></then></if>
      <expr_stmt><expr><name>gotNotOrOnly</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mediaType</name> == <name><name>nsGkAtoms</name>::<name>_not</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>query</name>-&gt;<name>SetNegated</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name><name>query</name>-&gt;<name>SetHasOnly</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></for>
    <expr_stmt><expr><call><name><name>query</name>-&gt;<name>SetType</name></name><argument_list>(<argument><expr><name>mediaType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr>*<name>aHitStop</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <comment type="line">// expected termination by EOF</comment>
      <if>if <condition>(<expr><name>aStopSymbol</name> == <call><name>PRUnichar</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then></if>

      <comment type="line">// unexpected termination by EOF</comment>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEGatherMediaEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>

    <if>if <condition>(<expr><name>eCSSToken_Symbol</name> == <name><name>mToken</name>.<name>mType</name></name> &amp;&amp;
        <name><name>mToken</name>.<name>mSymbol</name></name> == <name>aStopSymbol</name></expr>)</condition><then> <block>{
      <expr_stmt><expr>*<name>aHitStop</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Symbol</name> == <name><name>mToken</name>.<name>mType</name></name> &amp;&amp; <name><name>mToken</name>.<name>mSymbol</name></name> == ','</expr>)</condition><then> <block>{
      <comment type="line">// Done with the expressions for this query</comment>
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Ident</name> != <name><name>mToken</name>.<name>mType</name></name> ||
        !<call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"and"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEGatherMediaNotComma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>ParseMediaQueryExpression</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>query</name>-&gt;<name>SetHadUnknownExpression</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr>*<name>aQuery</name> = <call><name><name>query</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// Returns false only when there is a low-level error in the scanner</comment>
<comment type="line">// (out-of-memory).</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>GatherMedia</name></name><parameter_list>(<param><decl><type><name>nsMediaList</name>*</type> <name>aMedia</name></decl></param>,
                           <param><decl><type><name>PRUnichar</name></type> <name>aStopSymbol</name></decl></param>)</parameter_list>
<block>{
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <decl_stmt><decl><type><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>nsMediaQuery</name></expr></argument>&gt;</argument_list></name></type> <name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>parsedSomething</name></decl>, <decl><type ref="prev"/><name>hitStop</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>ParseMediaQuery</name><argument_list>(<argument><expr><name>aStopSymbol</name></expr></argument>, <argument><expr><call><name>getter_Transfers</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr>&amp;<name>parsedSomething</name></expr></argument>, <argument><expr>&amp;<name>hitStop</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>hitStop</name></expr></argument>, <argument><expr>"should return true when hit stop"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name><name>mScanner</name>.<name>GetLowLevelError</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type> <name><name>stopChars</name><index>[]</index></name> <init>=
        <expr><block>{ <expr><call><name>PRUnichar</name><argument_list>(<argument><expr>','</expr></argument>)</argument_list></call></expr>, <expr><name>aStopSymbol</name></expr> <comment type="block">/* may be null */</comment>, <macro><name>PRUnichar</name><argument_list>(<argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SkipUntilOneOf</name><argument_list>(<argument><expr><name>stopChars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Rely on SkipUntilOneOf leaving mToken around as the last token read.</comment>
      <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Symbol</name> &amp;&amp; <name><name>mToken</name>.<name>mSymbol</name></name> == <name>aStopSymbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hitStop</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>parsedSomething</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aMedia</name>-&gt;<name>SetNonEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>query</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>aMedia</name>-&gt;<name>AppendQuery</name></name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>hitStop</name></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseMediaQueryExpression</name></name><parameter_list>(<param><decl><type><name>nsMediaQuery</name>*</type> <name>aQuery</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>'('</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEMQExpectedExpressionStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEMQExpressionEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>eCSSToken_Ident</name> != <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEMQExpectedFeatureName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsMediaExpression</name> *</type><name>expr</name> <init>= <expr><call><name><name>aQuery</name>-&gt;<name>NewExpression</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>expr</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// case insensitive from CSS - must be lower cased</comment>
  <expr_stmt><expr><call><name><name>nsContentUtils</name>::<name>ASCIIToLower</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name>featureString</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>StringBeginsWith</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"min-"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>expr</name>-&gt;<name>mRange</name></name> = <name><name>nsMediaExpression</name>::<name>eMin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>featureString</name> = <call><name><name>mToken</name>.<name>mIdent</name>.<name>get</name></name><argument_list>()</argument_list></call> + 4</expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><call><name>StringBeginsWith</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"max-"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>expr</name>-&gt;<name>mRange</name></name> = <name><name>nsMediaExpression</name>::<name>eMax</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>featureString</name> = <call><name><name>mToken</name>.<name>mIdent</name>.<name>get</name></name><argument_list>()</argument_list></call> + 4</expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name><name>expr</name>-&gt;<name>mRange</name></name> = <name><name>nsMediaExpression</name>::<name>eEqual</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>featureString</name> = <call><name><name>mToken</name>.<name>mIdent</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>mediaFeatureAtom</name> <init>= <expr><call><name>do_GetAtom</name><argument_list>(<argument><expr><name>featureString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsMediaFeature</name> *</type><name>feature</name> <init>= <expr><name><name>nsMediaFeatures</name>::<name>features</name></name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init> <condition><expr><name><name>feature</name>-&gt;<name>mName</name></name></expr>;</condition> <incr><expr>++<name>feature</name></expr></incr>) <block>{
    <if>if <condition>(<expr>*(<name><name>feature</name>-&gt;<name>mName</name></name>) == <name>mediaFeatureAtom</name></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>
  }</block></for>
  <if>if <condition>(<expr>!<name><name>feature</name>-&gt;<name>mName</name></name> ||
      (<name><name>expr</name>-&gt;<name>mRange</name></name> != <name><name>nsMediaExpression</name>::<name>eEqual</name></name> &amp;&amp;
       <name><name>feature</name>-&gt;<name>mRangeType</name></name> != <name><name>nsMediaFeature</name>::<name>eMinMaxAllowed</name></name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEMQExpectedFeatureName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name><name>expr</name>-&gt;<name>mFeature</name></name> = <name>feature</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> || <call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Query expressions for any feature can be given without a value.</comment>
    <comment type="line">// However, min/max prefixes are not allowed.</comment>
    <if>if <condition>(<expr><name><name>expr</name>-&gt;<name>mRange</name></name> != <name><name>nsMediaExpression</name>::<name>eEqual</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEMQNoMinMaxWithoutValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>expr</name>-&gt;<name>mValue</name>.<name>Reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEMQExpectedFeatureNameEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>rv</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>feature</name>-&gt;<name>mValueType</name></name></expr>)</condition> <block>{
    <case>case <expr><name><name>nsMediaFeature</name>::<name>eLength</name></name></expr>:
      <expr_stmt><expr><name>rv</name> = <call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name><name>expr</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name><name>nsMediaFeature</name>::<name>eInteger</name></name></expr>:
    </case><case>case <expr><name><name>nsMediaFeature</name>::<name>eBoolInteger</name></name></expr>:
      <expr_stmt><expr><name>rv</name> = <call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name><name>expr</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>VARIANT_INTEGER</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Enforce extra restrictions for eBoolInteger</comment>
      <if>if <condition>(<expr><name>rv</name> &amp;&amp;
          <name><name>feature</name>-&gt;<name>mValueType</name></name> == <name><name>nsMediaFeature</name>::<name>eBoolInteger</name></name> &amp;&amp;
          <call><name><name>expr</name>-&gt;<name>mValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
        <expr_stmt><expr><name>rv</name> = <name>PR_FALSE</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </case><case>case <expr><name><name>nsMediaFeature</name>::<name>eIntRatio</name></name></expr>:
      <block>{
        <comment type="line">// Two integers separated by '/', with optional whitespace on</comment>
        <comment type="line">// either side of the '/'.</comment>
        <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>a</name> <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>a</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>expr</name>-&gt;<name>mValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>eCSSUnit_Array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// We don't bother with ParseNonNegativeVariant since we have to</comment>
        <comment type="line">// check for != 0 as well; no need to worry about the UngetToken</comment>
        <comment type="line">// since we're throwing out up to the next ')' anyway.</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>a</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_INTEGER</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> &amp;&amp;
             <call><name><name>a</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>.<call><name>GetIntValue</name><argument_list>()</argument_list></call> &gt; 0 &amp;&amp;
             <call><name>ExpectSymbol</name><argument_list>(<argument><expr>'/'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> &amp;&amp;
             <call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>a</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_INTEGER</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> &amp;&amp;
             <call><name><name>a</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call>.<call><name>GetIntValue</name><argument_list>()</argument_list></call> &gt; 0</expr>;</expr_stmt>
      }</block>
      <break>break;</break>
    </case><case>case <expr><name><name>nsMediaFeature</name>::<name>eResolution</name></name></expr>:
      <expr_stmt><expr><name>rv</name> = <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>rv</name></expr>)</condition><then>
        <break>break;</break></then></if>
      <expr_stmt><expr><name>rv</name> = <name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Dimension</name> &amp;&amp;
           <name><name>mToken</name>.<name>mIntegerValid</name></name> &amp;&amp; <name><name>mToken</name>.<name>mNumber</name></name> &gt; 0.0f</expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>rv</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
      <comment type="line">// No worries about whether unitless zero is allowed, since the</comment>
      <comment type="line">// value must be positive (and we checked that above).</comment>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name><name>mToken</name>.<name>mIdent</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"unit lied"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"dpi"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>expr</name>-&gt;<name>mValue</name>.<name>SetFloatValue</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mNumber</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Inch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"dpcm"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>expr</name>-&gt;<name>mValue</name>.<name>SetFloatValue</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mNumber</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Centimeter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      }</block></else></if></else></if>
      <break>break;</break>
    </case><case>case <expr><name><name>nsMediaFeature</name>::<name>eEnumerated</name></name></expr>:
      <expr_stmt><expr><name>rv</name> = <call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>expr</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                        <argument><expr><name><name>feature</name>-&gt;<name>mData</name>.<name>mKeywordTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </case>}</block></switch>
  <if>if <condition>(<expr>!<name>rv</name> || !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEMQExpectedFeatureValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// Parse a CSS2 import rule: "@import STRING | URL [medium [, medium]]"</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseImportRule</name></name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsMediaList</name></expr></argument>&gt;</argument_list></name></type> <name>media</name> <init>= <expr>new <call><name>nsMediaList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>media</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>url</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>GatherURL</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEImportNotURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>';'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>GatherMedia</name><argument_list>(<argument><expr><name>media</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call> ||
        !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>';'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEImportUnexpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// don't advance section, simply ignore invalid @import</comment>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// Safe to assert this, since we ensured that there is something</comment>
    <comment type="line">// other than the ';' coming after the @import's url() token.</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>media</name>-&gt;<name>Count</name></name><argument_list>()</argument_list></call> != 0</expr></argument>, <argument><expr>"media list must be nonempty"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>ProcessImport</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>media</name></expr></argument>, <argument><expr><name>aAppendFunc</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>ProcessImport</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aURLSpec</name></decl></param>,
                             <param><decl><type><name>nsMediaList</name>*</type> <name>aMedia</name></decl></param>,
                             <param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>,
                             <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICSSImportRule</name></expr></argument>&gt;</argument_list></name></type> <name>rule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>NS_NewCSSImportRule</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>rule</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aURLSpec</name></expr></argument>, <argument><expr><name>aMedia</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// out of memory</comment>
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><call>(*<name>aAppendFunc</name>)<argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Diagnose bad URIs even if we don't have a child loader.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>url</name></decl>;</decl_stmt>
  <comment type="line">// Charset will be deduced from mBaseURI, which is more or less correct.</comment>
  <expr_stmt><expr><name>rv</name> = <call><name>NS_NewURI</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aURLSpec</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>mBaseURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>rv</name> == <name>NS_ERROR_MALFORMED_URI</name></expr>)</condition><then> <block>{
      <comment type="line">// import url is bad</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[]</index></name> <init>= <expr><block>{
        <macro><name>aURLSpec</name></macro><expr>.<macro><name>get</name><argument_list>()</argument_list></macro></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_P</name><argument_list>(<argument><expr><name>PEImportBadURI</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>mChildLoader</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mChildLoader</name>-&gt;<name>LoadChildSheet</name></name><argument_list>(<argument><expr><name>mSheet</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>aMedia</name></expr></argument>, <argument><expr><name>rule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">// Parse the {} part of an @media or @-moz-document rule.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseGroupRule</name></name><parameter_list>(<param><decl><type><name>nsICSSGroupRule</name>*</type> <name>aRule</name></decl></param>,
                              <param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>,
                              <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// XXXbz this could use better error reporting throughout the method</comment>
  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>'{'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// push rule on stack, loop over children</comment>
  <if>if <condition>(<expr>!<call><name>PushGroup</name><argument_list>(<argument><expr><name>aRule</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsCSSSection</name></type> <name>holdSection</name> <init>= <expr><name>mSection</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>mSection</name> = <name>eCSSSection_General</name></expr>;</expr_stmt>

  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <comment type="line">// Get next non-whitespace token</comment>
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEGroupRuleEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'}'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// done!</comment>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_AtKeyword</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SkipAtRule</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// group rules cannot contain @rules</comment>
      <continue>continue;</continue>
    }</block></then></if>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ParseRuleSet</name><argument_list>(<argument><expr><name>AppendRuleToSheet</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>PopGroup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>'}'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mSection</name> = <name>holdSection</name></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call>(*<name>aAppendFunc</name>)<argument_list>(<argument><expr><name>aRule</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// Parse a CSS2 media rule: "@media medium [, medium] { ... }"</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseMediaRule</name></name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsMediaList</name></expr></argument>&gt;</argument_list></name></type> <name>media</name> <init>= <expr>new <call><name>nsMediaList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>media</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><call><name>GatherMedia</name><argument_list>(<argument><expr><name>media</name></expr></argument>, <argument><expr>'{'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// XXXbz this could use better error reporting throughout the method</comment>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCSSMediaRule</name></expr></argument>&gt;</argument_list></name></type> <name>rule</name><argument_list>(<argument><expr>new <call><name>nsCSSMediaRule</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <comment type="line">// Append first, so when we do SetMedia() the rule</comment>
    <comment type="line">// knows what its stylesheet is.</comment>
    <if>if <condition>(<expr><name>rule</name> &amp;&amp; <call><name>ParseGroupRule</name><argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><name>aAppendFunc</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>rule</name>-&gt;<name>SetMedia</name></name><argument_list>(<argument><expr><name>media</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// Parse a @-moz-document rule.  This is like an @media rule, but instead</comment>
<comment type="line">// of a medium it has a nonempty list of items where each item is either</comment>
<comment type="line">// url(), url-prefix(), or domain().</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseMozDocumentRule</name></name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCSSDocumentRule</name>::<name>URL</name></name> *</type><name>urls</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCSSDocumentRule</name>::<name>URL</name></name> **</type><name>next</name> <init>= <expr>&amp;<name>urls</name></expr></init></decl>;</decl_stmt>
  <do>do <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> ||
        <name>eCSSToken_Function</name> != <name><name>mToken</name>.<name>mType</name></name> ||
        !(<call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"url"</expr></argument>)</argument_list></call> ||
          <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"url-prefix"</expr></argument>)</argument_list></call> ||
          <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"domain"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEMozDocRuleBadFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>delete <name>urls</name></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name><name>nsCSSDocumentRule</name>::<name>URL</name></name> *</type><name>cur</name> <init>= <expr>*<name>next</name> = new <name><name>nsCSSDocumentRule</name>::<name>URL</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>cur</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>delete <name>urls</name></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>next</name> = &amp;<name><name>cur</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"url"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>func</name></name> = <name><name>nsCSSDocumentRule</name>::<name>eURL</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"url-prefix"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>func</name></name> = <name><name>nsCSSDocumentRule</name>::<name>eURLPrefix</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"domain"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>func</name></name> = <name><name>nsCSSDocumentRule</name>::<name>eDomain</name></name></expr>;</expr_stmt>
    }</block></then></if></else></if></else></if>

    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>url</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>GetURLInParens</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEMozDocRuleNotURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>delete <name>urls</name></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// We could try to make the URL (as long as it's not domain())</comment>
    <comment type="line">// canonical and absolute with NS_NewURI and GetSpec, but I'm</comment>
    <comment type="line">// inclined to think we shouldn't.</comment>
    <expr_stmt><expr><call><name>CopyUTF16toUTF8</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name><name>cur</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block> while <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCSSDocumentRule</name></expr></argument>&gt;</argument_list></name></type> <name>rule</name><argument_list>(<argument><expr>new <call><name>nsCSSDocumentRule</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>rule</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>delete <name>urls</name></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>rule</name>-&gt;<name>SetURLs</name></name><argument_list>(<argument><expr><name>urls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>ParseGroupRule</name><argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><name>aAppendFunc</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Parse a CSS3 namespace rule: "@namespace [prefix] STRING | URL;"</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseNameSpaceRule</name></name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAtNSPrefixEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsAutoString</name></type>  <name>prefix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type>  <name>url</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>prefix</name> = <name><name>mToken</name>.<name>mIdent</name></name></expr>;</expr_stmt>
    <comment type="line">// user-specified identifiers are case-sensitive (bug 416106)</comment>
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAtNSURIEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>eCSSToken_String</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>url</name> = <name><name>mToken</name>.<name>mIdent</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>';'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>ProcessNameSpace</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>aAppendFunc</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then>
  <else>else <if>if <condition>(<expr>(<name>eCSSToken_Function</name> == <name><name>mToken</name>.<name>mType</name></name>) &amp;&amp;
           (<call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"url"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>GetURLInParens</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call> &amp;&amp;
        <call><name>ExpectSymbol</name><argument_list>(<argument><expr>';'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>ProcessNameSpace</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>aAppendFunc</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAtNSUnexpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>ProcessNameSpace</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aPrefix</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aURLSpec</name></decl></param>,
                                <param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>,
                                <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICSSNameSpaceRule</name></expr></argument>&gt;</argument_list></name></type> <name>rule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>prefix</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name><name>aPrefix</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>prefix</name> = <call><name>do_GetAtom</name><argument_list>(<argument><expr><name>aPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_NewCSSNameSpaceRule</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>rule</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>aURLSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>rule</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call>(*<name>aAppendFunc</name>)<argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If this was the first namespace rule encountered, it will trigger</comment>
    <comment type="line">// creation of a namespace map.</comment>
    <if>if <condition>(<expr>!<name>mNameSpaceMap</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mNameSpaceMap</name> = <call><name><name>mSheet</name>-&gt;<name>GetNameSpaceMap</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="line">// font-face-rule: '@font-face' '{' font-description '}'</comment>
<comment type="line">// font-description: font-descriptor+</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFontFaceRule</name></name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>'{'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEBadFontBlockStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCSSFontFaceRule</name></expr></argument>&gt;</argument_list></name></type> <name>rule</name><argument_list>(<argument><expr>new <call><name>nsCSSFontFaceRule</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>rule</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEFontFaceEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'}'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// done!</comment>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>

    <comment type="line">// ignore extra semicolons</comment>
    <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>';'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <continue>continue;</continue></then></if>

    <if>if <condition>(<expr>!<call><name>ParseFontDescriptor</name><argument_list>(<argument><expr><name>rule</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEDeclSkipped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<call><name>SkipDeclaration</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></then></if>
  }</block></for>
  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>'}'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEBadFontBlockEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call>(*<name>aAppendFunc</name>)<argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// font-descriptor: font-family-desc</comment>
<comment type="line">//                | font-style-desc</comment>
<comment type="line">//                | font-weight-desc</comment>
<comment type="line">//                | font-stretch-desc</comment>
<comment type="line">//                | font-src-desc</comment>
<comment type="line">//                | unicode-range-desc</comment>
<comment type="line">//</comment>
<comment type="line">// All font-*-desc productions follow the pattern</comment>
<comment type="line">//    IDENT ':' value ';'</comment>
<comment type="line">//</comment>
<comment type="line">// On entry to this function, mToken is the IDENT.</comment>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFontDescriptor</name></name><parameter_list>(<param><decl><type><name>nsCSSFontFaceRule</name>*</type> <name>aRule</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>eCSSToken_Ident</name> != <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEFontDescExpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsString</name></type> <name>descName</name> <init>= <expr><name><name>mToken</name>.<name>mIdent</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>':'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEParseDeclarationNoColon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsCSSFontDesc</name></type> <name>descID</name> <init>= <expr><call><name><name>nsCSSProps</name>::<name>LookupFontDesc</name></name><argument_list>(<argument><expr><name>descName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>descID</name> == <name>eCSSFontDesc_UNKNOWN</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>NonMozillaVendorIdentifier</name><argument_list>(<argument><expr><name>descName</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// silently skip other vendors' extensions</comment>
      <expr_stmt><expr><call><name>SkipDeclaration</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then> <else>else <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[]</index></name> <init>= <expr><block>{
        <macro><name>descName</name></macro><expr>.<macro><name>get</name><argument_list>()</argument_list></macro></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_P</name><argument_list>(<argument><expr><name>PEUnknownFontDesc</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></else></if>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>ParseFontDescriptorValue</name><argument_list>(<argument><expr><name>descID</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[]</index></name> <init>= <expr><block>{
      <macro><name>descName</name></macro><expr>.<macro><name>get</name><argument_list>()</argument_list></macro></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_P</name><argument_list>(<argument><expr><name>PEValueParsingError</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name><name>aRule</name>-&gt;<name>SetDesc</name></name><argument_list>(<argument><expr><name>descID</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>


<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParsePageRule</name></name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// XXX not yet implemented</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>SkipUntil</name></name><parameter_list>(<param><decl><type><name>PRUnichar</name></type> <name>aStopSymbol</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>PRUnichar</name></expr></argument>, <argument><expr>16</expr></argument>&gt;</argument_list></name></type> <name>stack</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>stack</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>aStopSymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Symbol</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRUnichar</name></type> <name>symbol</name> <init>= <expr><name><name>tk</name>-&gt;<name>mSymbol</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRUint32</name></type> <name>stackTopIndex</name> <init>= <expr><call><name><name>stack</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>symbol</name> == <call><name><name>stack</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>stackTopIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>stack</name>.<name>RemoveElementAt</name></name><argument_list>(<argument><expr><name>stackTopIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>stackTopIndex</name> == 0</expr>)</condition><then> <block>{
          <break>break;</break>
        }</block></then></if>

      <comment type="line">// Just handle out-of-memory by parsing incorrectly.  It's</comment>
      <comment type="line">// highly unlikely we're dealing with a legitimate style sheet</comment>
      <comment type="line">// anyway.</comment>
      }</block></then> <else>else <if>if <condition>(<expr>'{' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>stack</name>.<name>AppendElement</name></name><argument_list>(<argument><expr>'}'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr>'[' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>stack</name>.<name>AppendElement</name></name><argument_list>(<argument><expr>']'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr>'(' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>stack</name>.<name>AppendElement</name></name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if></else></if></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>stack</name>.<name>AppendElement</name></name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></for>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>SkipUntilOneOf</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aStopSymbolChars</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>nsDependentString</name></type> <name>stopSymbolChars</name><parameter_list>(<param><decl><type><name>aStopSymbolChars</name></type></decl></param>)</parameter_list>;</function_decl>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Symbol</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRUnichar</name></type> <name>symbol</name> <init>= <expr><name><name>tk</name>-&gt;<name>mSymbol</name></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name><name>stopSymbolChars</name>.<name>FindChar</name></name><argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then> <else>else <if>if <condition>(<expr>'{' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>'}'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr>'[' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>']'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr>'(' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if></else></if></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></for>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>SkipDeclaration</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCheckForBraces</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>aCheckForBraces</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PESkipDeclBraceEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Symbol</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRUnichar</name></type> <name>symbol</name> <init>= <expr><name><name>tk</name>-&gt;<name>mSymbol</name></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>';' == <name>symbol</name></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr><name>aCheckForBraces</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>'}' == <name>symbol</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></then></if>
      <if>if <condition>(<expr>'{' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>'}'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr>'(' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr>'[' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>']'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></for>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>SkipRuleSet</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aInsideBraces</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PESkipRSBraceEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Symbol</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRUnichar</name></type> <name>symbol</name> <init>= <expr><name><name>tk</name>-&gt;<name>mSymbol</name></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>'}' == <name>symbol</name> &amp;&amp; <name>aInsideBraces</name></expr>)</condition><then> <block>{
        <comment type="line">// leave block closer for higher-level grammar to consume</comment>
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then> <else>else <if>if <condition>(<expr>'{' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>'}'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then> <else>else <if>if <condition>(<expr>'(' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr>'[' == <name>symbol</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>']'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if></else></if></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></for> 
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>PushGroup</name></name><parameter_list>(<param><decl><type><name>nsICSSGroupRule</name>*</type> <name>aRule</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>mGroupStack</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><name>aRule</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>PopGroup</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>count</name> <init>= <expr><call><name><name>mGroupStack</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>0 &lt; <name>count</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mGroupStack</name>.<name>RemoveObjectAt</name></name><argument_list>(<argument><expr><name>count</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>AppendRule</name></name><parameter_list>(<param><decl><type><name>nsICSSRule</name>*</type> <name>aRule</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>count</name> <init>= <expr><call><name><name>mGroupStack</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>0 &lt; <name>count</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>mGroupStack</name><index>[<expr><name>count</name> - 1</expr>]</index></name>-&gt;<call><name>AppendStyleRule</name><argument_list>(<argument><expr><name>aRule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name><name>mSheet</name>-&gt;<name>AppendStyleRule</name></name><argument_list>(<argument><expr><name>aRule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseRuleSet</name></name><parameter_list>(<param><decl><type><name>RuleAppendFunc</name></type> <name>aAppendFunc</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>,
                            <param><decl><type><name>PRBool</name></type> <name>aInsideBraces</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// First get the list of selectors for the rule</comment>
  <decl_stmt><decl><type><name>nsCSSSelectorList</name>*</type> <name>slist</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>linenum</name> <init>= <expr><call><name><name>mScanner</name>.<name>GetLineNumber</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>! <call><name>ParseSelectorList</name><argument_list>(<argument><expr><name>slist</name></expr></argument>, <argument><expr><call><name>PRUnichar</name><argument_list>(<argument><expr>'{'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEBadSelectorRSIgnored</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SkipRuleSet</name><argument_list>(<argument><expr><name>aInsideBraces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>slist</name></expr></argument>, <argument><expr>"null selector list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CLEAR_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Next parse the declaration block</comment>
  <decl_stmt><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>declaration</name> <init>= <expr><call><name>ParseDeclarationBlock</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>nsnull</name> == <name>declaration</name></expr>)</condition><then> <block>{
    <comment type="line">// XXX skip something here</comment>
    <expr_stmt><expr>delete <name>slist</name></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
  slist-&gt;Dump();
  fputs("{\n", stdout);
  declaration-&gt;List();
  fputs("}\n", stdout);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Translate the selector list and declaration block into style data</comment>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICSSStyleRule</name></expr></argument>&gt;</argument_list></name></type> <name>rule</name> <init>= <expr><call><name>NS_NewCSSStyleRule</name><argument_list>(<argument><expr><name>slist</name></expr></argument>, <argument><expr><name>declaration</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>rule</name>-&gt;<name>SetLineNumber</name></name><argument_list>(<argument><expr><name>linenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call>(*<name>aAppendFunc</name>)<argument_list>(<argument><expr><name>rule</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseSelectorList</name></name><parameter_list>(<param><decl><type><name>nsCSSSelectorList</name>*&amp;</type> <name>aListHead</name></decl></param>,
                                 <param><decl><type><name>PRUnichar</name></type> <name>aStopChar</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSSelectorList</name>*</type> <name>list</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>! <call><name>ParseSelectorGroup</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// must have at least one selector group</comment>
    <expr_stmt><expr><name>aListHead</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>nsnull</name> != <name>list</name></expr></argument>, <argument><expr>"no selector list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aListHead</name> = <name>list</name></expr>;</expr_stmt>

  <comment type="line">// After that there must either be a "," or a "{" (the latter if</comment>
  <comment type="line">// StopChar is nonzero)</comment>
  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>aStopChar</name> == <call><name>PRUnichar</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_TRUE</name></expr>;</return>
      }</block></then></if>

      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PESelectorListExtraEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>

    <if>if <condition>(<expr><name>eCSSToken_Symbol</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>',' == <name><name>tk</name>-&gt;<name>mSymbol</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsCSSSelectorList</name>*</type> <name>newList</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
        <comment type="line">// Another selector group must follow</comment>
        <if>if <condition>(<expr>! <call><name>ParseSelectorGroup</name><argument_list>(<argument><expr><name>newList</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <break>break;</break>
        }</block></then></if>
        <comment type="line">// add new list to the end of the selector list</comment>
        <expr_stmt><expr><name><name>list</name>-&gt;<name>mNext</name></name> = <name>newList</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>list</name> = <name>newList</name></expr>;</expr_stmt>
        <continue>continue;</continue>
      }</block></then> <else>else <if>if <condition>(<expr><name>aStopChar</name> == <name><name>tk</name>-&gt;<name>mSymbol</name></name> &amp;&amp; <name>aStopChar</name> != <call><name>PRUnichar</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_TRUE</name></expr>;</return>
      }</block></then></if></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PESelectorListExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block></for>

  <expr_stmt><expr>delete <name>aListHead</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aListHead</name> = <name>nsnull</name></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>IsUniversalSelector</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>PRBool</name><argument_list>(<argument><expr>(<name><name>aSelector</name>.<name>mNameSpace</name></name> == <name>kNameSpaceID_Unknown</name>) &amp;&amp;
                (<name><name>aSelector</name>.<name>mLowercaseTag</name></name> == <name>nsnull</name>) &amp;&amp;
                (<name><name>aSelector</name>.<name>mIDList</name></name> == <name>nsnull</name>) &amp;&amp;
                (<name><name>aSelector</name>.<name>mClassList</name></name> == <name>nsnull</name>) &amp;&amp;
                (<name><name>aSelector</name>.<name>mAttrList</name></name> == <name>nsnull</name>) &amp;&amp;
                (<name><name>aSelector</name>.<name>mNegations</name></name> == <name>nsnull</name>) &amp;&amp;
                (<name><name>aSelector</name>.<name>mPseudoClassList</name></name> == <name>nsnull</name>)</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseSelectorGroup</name></name><parameter_list>(<param><decl><type><name>nsCSSSelectorList</name>*&amp;</type> <name>aList</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRUnichar</name></type> <name>combinator</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>nsCSSSelectorList</name></expr></argument>&gt;</argument_list></name></type> <name>list</name><argument_list>(<argument><expr>new <call><name>nsCSSSelectorList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>ParseSelector</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>combinator</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// Look for a combinator.</comment>
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <break>break;</break> <comment type="line">// EOF ok here</comment>
    }</block></then></if>

    <expr_stmt><expr><name>combinator</name> = <call><name>PRUnichar</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_WhiteSpace</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break> <comment type="line">// EOF ok here</comment>
      }</block></then></if>
      <expr_stmt><expr><name>combinator</name> = <call><name>PRUnichar</name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_Symbol</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// not a combinator</comment>
    }</block></then> <else>else <block>{
      <decl_stmt><decl><type><name>PRUnichar</name></type> <name>symbol</name> <init>= <expr><name><name>mToken</name>.<name>mSymbol</name></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>symbol</name> == '+' || <name>symbol</name> == '&gt;' || <name>symbol</name> == '~'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>combinator</name> = <name><name>mToken</name>.<name>mSymbol</name></name></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// not a combinator</comment>
        <if>if <condition>(<expr><name>symbol</name> == ',' || <name>symbol</name> == '{' || <name>symbol</name> == ')'</expr>)</condition><then> <block>{
          <break>break;</break> <comment type="line">// end of selector group</comment>
        }</block></then></if>
      }</block></else></if>
    }</block></else></if>

    <if>if <condition>(<expr>!<name>combinator</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PESelectorListExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <expr_stmt><expr><name>aList</name> = <call><name><name>list</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEL_MASK_NSPACE</name></cpp:macro>   <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEL_MASK_ELEM</name></cpp:macro>     <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEL_MASK_ID</name></cpp:macro>       <cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEL_MASK_CLASS</name></cpp:macro>    <cpp:value>0x08</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEL_MASK_ATTRIB</name></cpp:macro>   <cpp:value>0x10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEL_MASK_PCLASS</name></cpp:macro>   <cpp:value>0x20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEL_MASK_PELEM</name></cpp:macro>    <cpp:value>0x40</cpp:value></cpp:define>

<comment type="line">//</comment>
<comment type="line">// Parses an ID selector #name</comment>
<comment type="line">//</comment>
<function><type><name><name>CSSParserImpl</name>::<name>nsSelectorParsingStatus</name></name></type>
<name><name>CSSParserImpl</name>::<name>ParseIDSelector</name></name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                               <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name><name>mToken</name>.<name>mIdent</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Empty mIdent in eCSSToken_ID token?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ID</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aSelector</name>.<name>AddID</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>eSelectorParsingStatus_Continue</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// Parses a class selector .name</comment>
<comment type="line">//</comment>
<function><type><name><name>CSSParserImpl</name>::<name>nsSelectorParsingStatus</name></name></type>
<name><name>CSSParserImpl</name>::<name>ParseClassSelector</name></name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                  <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// get ident</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEClassSelEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>eCSSToken_Ident</name> != <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{  <comment type="line">// malformed selector</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEClassSelNotIdent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_CLASS</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>aSelector</name>.<name>AddClass</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>eSelectorParsingStatus_Continue</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// Parse a type element selector or a universal selector</comment>
<comment type="line">// namespace|type or namespace|* or *|* or *</comment>
<comment type="line">//</comment>
<function><type><name><name>CSSParserImpl</name>::<name>nsSelectorParsingStatus</name></name></type>
<name><name>CSSParserImpl</name>::<name>ParseTypeOrUniversalSelector</name></name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                            <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>,
                                            <param><decl><type><name>PRBool</name></type>         <name>aIsNegated</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>buffer</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'*'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// universal element selector, or universal namespace</comment>
    <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>'|'</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// was namespace</comment>
      <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_NSPACE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aSelector</name>.<name>SetNameSpace</name></name><argument_list>(<argument><expr><name>kNameSpaceID_Unknown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// namespace wildcard</comment>

      <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PETypeSelEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{  <comment type="line">// element name</comment>
        <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ELEM</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>aSelector</name>.<name>SetTag</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'*'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// universal selector</comment>
        <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ELEM</name></expr>;</expr_stmt>
        <comment type="line">// don't set tag</comment>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PETypeSelNotType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></else></if></else></if>
    }</block></then>
    <else>else <block>{  <comment type="line">// was universal element selector</comment>
      <expr_stmt><expr><call><name>SetDefaultNamespaceOnSelector</name><argument_list>(<argument><expr><name>aSelector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ELEM</name></expr>;</expr_stmt>
      <comment type="line">// don't set any tag in the selector</comment>
    }</block></else></if>
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{   <comment type="line">// premature eof is ok (here!)</comment>
      <return>return <expr><name>eSelectorParsingStatus_Done</name></expr>;</return>
    }</block></then></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{    <comment type="line">// element name or namespace name</comment>
    <expr_stmt><expr><name>buffer</name> = <name><name>mToken</name>.<name>mIdent</name></name></expr>;</expr_stmt> <comment type="line">// hang on to ident</comment>

    <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>'|'</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// was namespace</comment>
      <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_NSPACE</name></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>nameSpaceID</name> <init>= <expr><call><name>GetNamespaceIdForPrefix</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>nameSpaceID</name> == <name>kNameSpaceID_Unknown</name></expr>)</condition><then> <block>{
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>aSelector</name>.<name>SetNameSpace</name></name><argument_list>(<argument><expr><name>nameSpaceID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PETypeSelEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{  <comment type="line">// element name</comment>
        <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ELEM</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>aSelector</name>.<name>SetTag</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'*'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// universal selector</comment>
        <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ELEM</name></expr>;</expr_stmt>
        <comment type="line">// don't set tag</comment>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PETypeSelNotType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></else></if></else></if>
    }</block></then>
    <else>else <block>{  <comment type="line">// was element name</comment>
      <expr_stmt><expr><call><name>SetDefaultNamespaceOnSelector</name><argument_list>(<argument><expr><name>aSelector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aSelector</name>.<name>SetTag</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ELEM</name></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{   <comment type="line">// premature eof is ok (here!)</comment>
      <return>return <expr><name>eSelectorParsingStatus_Done</name></expr>;</return>
    }</block></then></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'|'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// No namespace</comment>
    <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_NSPACE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aSelector</name>.<name>SetNameSpace</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// explicit NO namespace</comment>

    <comment type="line">// get mandatory tag</comment>
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PETypeSelEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{  <comment type="line">// element name</comment>
      <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ELEM</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aSelector</name>.<name>SetTag</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'*'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// universal selector</comment>
      <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ELEM</name></expr>;</expr_stmt>
      <comment type="line">// don't set tag</comment>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PETypeSelNotType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></else></if></else></if>
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{   <comment type="line">// premature eof is ok (here!)</comment>
      <return>return <expr><name>eSelectorParsingStatus_Done</name></expr>;</return>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>SetDefaultNamespaceOnSelector</name><argument_list>(<argument><expr><name>aSelector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if>

  <if>if <condition>(<expr><name>aIsNegated</name></expr>)</condition><then> <block>{
    <comment type="line">// restore last token read in case of a negated type selector</comment>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>eSelectorParsingStatus_Continue</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// Parse attribute selectors [attr], [attr=value], [attr|=value],</comment>
<comment type="line">// [attr~=value], [attr^=value], [attr$=value] and [attr*=value]</comment>
<comment type="line">//</comment>
<function><type><name><name>CSSParserImpl</name>::<name>nsSelectorParsingStatus</name></name></type>
<name><name>CSSParserImpl</name>::<name>ParseAttributeSelector</name></name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                      <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature EOF</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAttributeNameEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>nameSpaceID</name> <init>= <expr><name>kNameSpaceID_None</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type>  <name>attr</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'*'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// wildcard namespace</comment>
    <expr_stmt><expr><name>nameSpaceID</name> = <name>kNameSpaceID_Unknown</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>'|'</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature EOF</comment>
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAttributeNameEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{ <comment type="line">// attr name</comment>
        <expr_stmt><expr><name>attr</name> = <name><name>mToken</name>.<name>mIdent</name></name></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttributeNameExpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
       }</block></else></if>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttSelNoBar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></else></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'|'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// NO namespace</comment>
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature EOF</comment>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAttributeNameEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{ <comment type="line">// attr name</comment>
      <expr_stmt><expr><name>attr</name> = <name><name>mToken</name>.<name>mIdent</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttributeNameExpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></else></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{ <comment type="line">// attr name or namespace</comment>
    <expr_stmt><expr><name>attr</name> = <name><name>mToken</name>.<name>mIdent</name></name></expr>;</expr_stmt> <comment type="line">// hang on to it</comment>
    <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>'|'</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// was a namespace</comment>
      <expr_stmt><expr><name>nameSpaceID</name> = <call><name>GetNamespaceIdForPrefix</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>nameSpaceID</name> == <name>kNameSpaceID_Unknown</name></expr>)</condition><then> <block>{
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature EOF</comment>
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAttributeNameEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{ <comment type="line">// attr name</comment>
        <expr_stmt><expr><name>attr</name> = <name><name>mToken</name>.<name>mIdent</name></name></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttributeNameExpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></else></if>
    }</block></then></if>
  }</block></then>
  <else>else <block>{  <comment type="line">// malformed</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttributeNameOrNamespaceExpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></else></if></else></if></else></if>

  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature EOF</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAttSelInnerEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>eCSSToken_Symbol</name> == <name><name>mToken</name>.<name>mType</name></name>) ||
      (<name>eCSSToken_Includes</name> == <name><name>mToken</name>.<name>mType</name></name>) ||
      (<name>eCSSToken_Dashmatch</name> == <name><name>mToken</name>.<name>mType</name></name>) ||
      (<name>eCSSToken_Beginsmatch</name> == <name><name>mToken</name>.<name>mType</name></name>) ||
      (<name>eCSSToken_Endsmatch</name> == <name><name>mToken</name>.<name>mType</name></name>) ||
      (<name>eCSSToken_Containsmatch</name> == <name><name>mToken</name>.<name>mType</name></name>)</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRUint8</name></type> <name>func</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>eCSSToken_Includes</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>func</name> = <name>NS_ATTR_FUNC_INCLUDES</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>eCSSToken_Dashmatch</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>func</name> = <name>NS_ATTR_FUNC_DASHMATCH</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>eCSSToken_Beginsmatch</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>func</name> = <name>NS_ATTR_FUNC_BEGINSMATCH</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>eCSSToken_Endsmatch</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>func</name> = <name>NS_ATTR_FUNC_ENDSMATCH</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>eCSSToken_Containsmatch</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>func</name> = <name>NS_ATTR_FUNC_CONTAINSMATCH</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>']' == <name><name>mToken</name>.<name>mSymbol</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ATTRIB</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aSelector</name>.<name>AddAttribute</name></name><argument_list>(<argument><expr><name>nameSpaceID</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>func</name> = <name>NS_ATTR_FUNC_SET</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>'=' == <name><name>mToken</name>.<name>mSymbol</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>func</name> = <name>NS_ATTR_FUNC_EQUALS</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttSelUnexpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// bad function</comment>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
    <if>if <condition>(<expr><name>NS_ATTR_FUNC_SET</name> != <name>func</name></expr>)</condition><then> <block>{ <comment type="line">// get value</comment>
      <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature EOF</comment>
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAttSelValueEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr>(<name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name>) || (<name>eCSSToken_String</name> == <name><name>mToken</name>.<name>mType</name></name>)</expr>)</condition><then> <block>{
        <function_decl><type><name>nsAutoString</name></type>  <name>value</name><parameter_list>(<param><decl><type><name><name>mToken</name>.<name>mIdent</name></name></type></decl></param>)</parameter_list>;</function_decl>
        <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature EOF</comment>
          <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAttSelCloseEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>']'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>PRBool</name></type> <name>isCaseSensitive</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>

          <comment type="line">// For cases when this style sheet is applied to an HTML</comment>
          <comment type="line">// element in an HTML document, and the attribute selector is</comment>
          <comment type="line">// for a non-namespaced attribute, then check to see if it's</comment>
          <comment type="line">// one of the known attributes whose VALUE is</comment>
          <comment type="line">// case-insensitive.</comment>
          <if>if <condition>(<expr><name>nameSpaceID</name> == <name>kNameSpaceID_None</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name>*</type> <name><name>caseInsensitiveHTMLAttribute</name><index>[]</index></name> <init>= <expr><block>{
              <comment type="line">// list based on http://www.w3.org/TR/html4/</comment>
              <expr>"lang"</expr>,
              <expr>"dir"</expr>,
              <expr>"http-equiv"</expr>,
              <expr>"text"</expr>,
              <expr>"link"</expr>,
              <expr>"vlink"</expr>,
              <expr>"alink"</expr>,
              <expr>"compact"</expr>,
              <expr>"align"</expr>,
              <expr>"frame"</expr>,
              <expr>"rules"</expr>,
              <expr>"valign"</expr>,
              <expr>"scope"</expr>,
              <expr>"axis"</expr>,
              <expr>"nowrap"</expr>,
              <expr>"hreflang"</expr>,
              <expr>"rel"</expr>,
              <expr>"rev"</expr>,
              <expr>"charset"</expr>,
              <expr>"codetype"</expr>,
              <expr>"declare"</expr>,
              <expr>"valuetype"</expr>,
              <expr>"shape"</expr>,
              <expr>"nohref"</expr>,
              <expr>"media"</expr>,
              <expr>"bgcolor"</expr>,
              <expr>"clear"</expr>,
              <expr>"color"</expr>,
              <expr>"face"</expr>,
              <expr>"noshade"</expr>,
              <expr>"noresize"</expr>,
              <expr>"scrolling"</expr>,
              <expr>"target"</expr>,
              <expr>"method"</expr>,
              <expr>"enctype"</expr>,
              <expr>"accept-charset"</expr>,
              <expr>"accept"</expr>,
              <expr>"checked"</expr>,
              <expr>"multiple"</expr>,
              <expr>"selected"</expr>,
              <expr>"disabled"</expr>,
              <expr>"readonly"</expr>,
              <expr>"language"</expr>,
              <expr>"defer"</expr>,
              <expr>"type"</expr>,
              <comment type="line">// additional attributes not in HTML4</comment>
              <expr>"direction"</expr>, <comment type="line">// marquee</comment>
              <expr><name>nsnull</name></expr>
            }</block></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>short</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>htmlAttr</name></decl>;</decl_stmt>
            <while>while <condition>(<expr>(<name>htmlAttr</name> = <name><name>caseInsensitiveHTMLAttribute</name><index>[<expr><name>i</name>++</expr>]</index></name>)</expr>)</condition> <block>{
              <if>if <condition>(<expr><call><name><name>attr</name>.<name>LowerCaseEqualsASCII</name></name><argument_list>(<argument><expr><name>htmlAttr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>isCaseSensitive</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
                <break>break;</break>
              }</block></then></if>
            }</block></while>
          }</block></then></if>
          <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_ATTRIB</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>aSelector</name>.<name>AddAttribute</name></name><argument_list>(<argument><expr><name>nameSpaceID</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isCaseSensitive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttSelNoClose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
        }</block></else></if>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttSelBadValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></else></if>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttSelUnexpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// bad dog, no biscut!</comment>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
   }</block></else></if>
   <return>return <expr><name>eSelectorParsingStatus_Continue</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// Parse pseudo-classes and pseudo-elements</comment>
<comment type="line">//</comment>
<function><type><name><name>CSSParserImpl</name>::<name>nsSelectorParsingStatus</name></name></type>
<name><name>CSSParserImpl</name>::<name>ParsePseudoSelector</name></name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                   <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>,
                                   <param><decl><type><name>PRBool</name></type>         <name>aIsNegated</name></decl></param>,
                                   <param><decl><type><name>nsIAtom</name>**</type>      <name>aPseudoElement</name></decl></param>,
                                   <param><decl><type><name>nsPseudoClassList</name>**</type> <name>aPseudoElementArgs</name></decl></param>,
                                   <param><decl><type><name><name>nsCSSPseudoElements</name>::<name>Type</name></name>*</type> <name>aPseudoElementType</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aIsNegated</name> || (<name>aPseudoElement</name> &amp;&amp; <name>aPseudoElementArgs</name>)</expr></argument>,
               <argument><expr>"expected location to store pseudo element"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aIsNegated</name> || (!<name>aPseudoElement</name> &amp;&amp; !<name>aPseudoElementArgs</name>)</expr></argument>,
               <argument><expr>"negated selectors shouldn't have a place to store "
               "pseudo elements"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature eof</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEPseudoSelEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// First, find out whether we are parsing a CSS3 pseudo-element</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>parsingPseudoElement</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>parsingPseudoElement</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature eof</comment>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEPseudoSelEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Do some sanity-checking on the token</comment>
  <if>if <condition>(<expr><name>eCSSToken_Ident</name> != <name><name>mToken</name>.<name>mType</name></name> &amp;&amp; <name>eCSSToken_Function</name> != <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <comment type="line">// malformed selector</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoSelBadName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// OK, now we know we have an mIdent.  Atomize it.  All the atoms, for</comment>
  <comment type="line">// pseudo-classes as well as pseudo-elements, start with a single ':'.</comment>
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>buffer</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>buffer</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>PRUnichar</name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>buffer</name>.<name>Append</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>nsContentUtils</name>::<name>ASCIIToLower</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>pseudo</name> <init>= <expr><call><name>do_GetAtom</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>pseudo</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// stash away some info about this pseudo so we only have to get it once.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isTreePseudo</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCSSPseudoElements</name>::<name>Type</name></name></type> <name>pseudoElementType</name> <init>=
    <expr><call><name><name>nsCSSPseudoElements</name>::<name>GetPseudoType</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
  <expr_stmt><expr><name>isTreePseudo</name> = (<name>pseudoElementType</name> == <name><name>nsCSSPseudoElements</name>::<name>ePseudo_XULTree</name></name>)</expr>;</expr_stmt>
  <comment type="line">// If a tree pseudo-element is using the function syntax, it will</comment>
  <comment type="line">// get isTree set here and will pass the check below that only</comment>
  <comment type="line">// allows functions if they are in our list of things allowed to be</comment>
  <comment type="line">// functions.  If it is _not_ using the function syntax, isTree will</comment>
  <comment type="line">// be false, and it will still pass that check.  So the tree</comment>
  <comment type="line">// pseudo-elements are allowed to be either functions or not, as</comment>
  <comment type="line">// desired.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isTree</name> <init>= <expr>(<name>eCSSToken_Function</name> == <name><name>mToken</name>.<name>mType</name></name>) &amp;&amp; <name>isTreePseudo</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isPseudoElement</name> <init>=
    <expr>(<name>pseudoElementType</name> &lt; <name><name>nsCSSPseudoElements</name>::<name>ePseudo_PseudoElementCount</name></name>)</expr></init></decl>;</decl_stmt>
  <comment type="line">// anonymous boxes are only allowed if they're the tree boxes or we have</comment>
  <comment type="line">// enabled unsafe rules</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isAnonBox</name> <init>= <expr><name>isTreePseudo</name> ||
    (<name>pseudoElementType</name> == <name><name>nsCSSPseudoElements</name>::<name>ePseudo_AnonBox</name></name> &amp;&amp;
     <name>mUnsafeRulesEnabled</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCSSPseudoClasses</name>::<name>Type</name></name></type> <name>pseudoClassType</name> <init>=
    <expr><call><name><name>nsCSSPseudoClasses</name>::<name>GetPseudoType</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isPseudoClass</name> <init>=
    <expr>(<name>pseudoClassType</name> != <name><name>nsCSSPseudoClasses</name>::<name>ePseudoClass_NotPseudoClass</name></name>)</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>isPseudoClass</name> ||
               <name>pseudoElementType</name> == <name><name>nsCSSPseudoElements</name>::<name>ePseudo_NotPseudoElement</name></name></expr></argument>,
               <argument><expr>"Why is this atom both a pseudo-class and a pseudo-element?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>isPseudoClass</name> + <name>isPseudoElement</name> + <name>isAnonBox</name> &lt;= 1</expr></argument>,
               <argument><expr>"Shouldn't be more than one of these"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>isPseudoClass</name> &amp;&amp; !<name>isPseudoElement</name> &amp;&amp; !<name>isAnonBox</name></expr>)</condition><then> <block>{
    <comment type="line">// Not a pseudo-class, not a pseudo-element.... forget it</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoSelUnknown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// If it's a function token, it better be on our "ok" list, and if the name</comment>
  <comment type="line">// is that of a function pseudo it better be a function token</comment>
  <if>if <condition>(<expr>(<name>eCSSToken_Function</name> == <name><name>mToken</name>.<name>mType</name></name>) !=
      (
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
       <name>isTree</name> ||
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       <name><name>nsCSSPseudoClasses</name>::<name>notPseudo</name></name> == <name>pseudo</name> ||
       <call><name><name>nsCSSPseudoClasses</name>::<name>HasStringArg</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call> ||
       <call><name><name>nsCSSPseudoClasses</name>::<name>HasNthPairArg</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call> ||
       <call><name><name>nsCSSPseudoClasses</name>::<name>HasSelectorListArg</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
    <comment type="line">// There are no other function pseudos</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoSelNonFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// If it starts with "::", it better be a pseudo-element</comment>
  <if>if <condition>(<expr><name>parsingPseudoElement</name> &amp;&amp;
      !<name>isPseudoElement</name> &amp;&amp;
      !<name>isAnonBox</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoSelNotPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>parsingPseudoElement</name> &amp;&amp; <name><name>nsCSSPseudoClasses</name>::<name>notPseudo</name></name> == <name>pseudo</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>aIsNegated</name></expr>)</condition><then> <block>{ <comment type="line">// :not() can't be itself negated</comment>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoSelDoubleNot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></then></if>
    <comment type="line">// CSS 3 Negation pseudo-class takes one simple selector as argument</comment>
    <decl_stmt><decl><type><name>nsSelectorParsingStatus</name></type> <name>parsingStatus</name> <init>=
      <expr><call><name>ParseNegatedSimpleSelector</name><argument_list>(<argument><expr><name>aDataMask</name></expr></argument>, <argument><expr><name>aSelector</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>eSelectorParsingStatus_Continue</name> != <name>parsingStatus</name></expr>)</condition><then> <block>{
      <return>return <expr><name>parsingStatus</name></expr>;</return>
    }</block></then></if>
  }</block></then>
  <else>else <if>if <condition>(<expr>!<name>parsingPseudoElement</name> &amp;&amp; <name>isPseudoClass</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_PCLASS</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>eCSSToken_Function</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsSelectorParsingStatus</name></type> <name>parsingStatus</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name><name>nsCSSPseudoClasses</name>::<name>HasStringArg</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>parsingStatus</name> =
          <call><name>ParsePseudoClassWithIdentArg</name><argument_list>(<argument><expr><name>aSelector</name></expr></argument>, <argument><expr><name>pseudo</name></expr></argument>, <argument><expr><name>pseudoClassType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <if>if <condition>(<expr><call><name><name>nsCSSPseudoClasses</name>::<name>HasNthPairArg</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>parsingStatus</name> =
          <call><name>ParsePseudoClassWithNthPairArg</name><argument_list>(<argument><expr><name>aSelector</name></expr></argument>, <argument><expr><name>pseudo</name></expr></argument>, <argument><expr><name>pseudoClassType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name><name>nsCSSPseudoClasses</name>::<name>HasSelectorListArg</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr>"unexpected pseudo with function token"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>parsingStatus</name> = <call><name>ParsePseudoClassWithSelectorListArg</name><argument_list>(<argument><expr><name>aSelector</name></expr></argument>, <argument><expr><name>pseudo</name></expr></argument>,
                                                            <argument><expr><name>pseudoClassType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if></else></if>
      <if>if <condition>(<expr><name>eSelectorParsingStatus_Continue</name> != <name>parsingStatus</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>eSelectorParsingStatus_Error</name> == <name>parsingStatus</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>parsingStatus</name></expr>;</return>
      }</block></then></if>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name><name>aSelector</name>.<name>AddPseudoClass</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>, <argument><expr><name>pseudoClassType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>isPseudoElement</name> || <name>isAnonBox</name></expr>)</condition><then> <block>{
    <comment type="line">// Pseudo-element.  Make some more sanity checks.</comment>

    <if>if <condition>(<expr><name>aIsNegated</name></expr>)</condition><then> <block>{ <comment type="line">// pseudo-elements can't be negated</comment>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoSelPEInNot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></then></if>
    <comment type="line">// CSS2 pseudo-elements and -moz-tree-* pseudo-elements are allowed</comment>
    <comment type="line">// to have a single ':' on them.  Others (CSS3+ pseudo-elements and</comment>
    <comment type="line">// various -moz-* pseudo-elements) must have |parsingPseudoElement|</comment>
    <comment type="line">// set.</comment>
    <if>if <condition>(<expr>!<name>parsingPseudoElement</name> &amp;&amp;
        !<call><name><name>nsCSSPseudoElements</name>::<name>IsCSS2PseudoElement</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>)</argument_list></call>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
        &amp;&amp; !<name>isTreePseudo</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        )</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoSelNewStyleOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>0 == (<name>aDataMask</name> &amp; <name>SEL_MASK_PELEM</name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aDataMask</name> |= <name>SEL_MASK_PELEM</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aPseudoElement</name> = <name>pseudo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>aPseudoElementType</name> = <name>pseudoElementType</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
      <if>if <condition>(<expr><name>isTree</name></expr>)</condition><then> <block>{
        <comment type="line">// We have encountered a pseudoelement of the form</comment>
        <comment type="line">// -moz-tree-xxxx(a,b,c).  We parse (a,b,c) and add each</comment>
        <comment type="line">// item in the list to the pseudoclass list.  They will be pulled</comment>
        <comment type="line">// from the list later along with the pseudo-element.</comment>
        <if>if <condition>(<expr>!<call><name>ParseTreePseudoElement</name><argument_list>(<argument><expr><name>aPseudoElementArgs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="line">// the next *non*whitespace token must be '{' or ',' or EOF</comment>
      <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature eof is ok (here!)</comment>
        <return>return <expr><name>eSelectorParsingStatus_Done</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr>(<call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'{'</expr></argument>)</argument_list></call> || <call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>','</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Done</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoSelTrailing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></then>
    <else>else <block>{  <comment type="line">// multiple pseudo elements, not legal</comment>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoSelMultiplePE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></else></if>
  }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <else>else <block>{
    <comment type="line">// We should never end up here.  Indeed, if we ended up here, we know (from</comment>
    <comment type="line">// the current if/else cascade) that !isPseudoElement and !isAnonBox.  But</comment>
    <comment type="line">// then due to our earlier check we know that isPseudoClass.  Since we</comment>
    <comment type="line">// didn't fall into the isPseudoClass case in this cascade, we must have</comment>
    <comment type="line">// parsingPseudoElement.  But we've already checked the</comment>
    <comment type="line">// parsingPseudoElement &amp;&amp; !isPseudoClass &amp;&amp; !isAnonBox case and bailed if</comment>
    <comment type="line">// it's happened.</comment>
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"How did this happen?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>eSelectorParsingStatus_Continue</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// Parse the argument of a negation pseudo-class :not()</comment>
<comment type="line">//</comment>
<function><type><name><name>CSSParserImpl</name>::<name>nsSelectorParsingStatus</name></name></type>
<name><name>CSSParserImpl</name>::<name>ParseNegatedSimpleSelector</name></name><parameter_list>(<param><decl><type><name>PRInt32</name>&amp;</type>       <name>aDataMask</name></decl></param>,
                                          <param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature eof</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PENegationEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PENegationBadArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Create a new nsCSSSelector and add it to the end of</comment>
  <comment type="line">// aSelector.mNegations.</comment>
  <comment type="line">// Given the current parsing rules, every selector in mNegations</comment>
  <comment type="line">// contains only one simple selector (css3 definition) within it.</comment>
  <comment type="line">// This could easily change in future versions of CSS, and the only</comment>
  <comment type="line">// thing we need to change to support that is this parsing code and the</comment>
  <comment type="line">// serialization code for nsCSSSelector.</comment>
  <decl_stmt><decl><type><name>nsCSSSelector</name> *</type><name>newSel</name> <init>= <expr>new <call><name>nsCSSSelector</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>newSel</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsCSSSelector</name>*</type> <name>negations</name> <init>= <expr>&amp;<name>aSelector</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name><name>negations</name>-&gt;<name>mNegations</name></name></expr>)</condition> <block>{
    <expr_stmt><expr><name>negations</name> = <name><name>negations</name>-&gt;<name>mNegations</name></name></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><name><name>negations</name>-&gt;<name>mNegations</name></name> = <name>newSel</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsSelectorParsingStatus</name></type> <name>parsingStatus</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>eCSSToken_ID</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{ <comment type="line">// #id</comment>
    <expr_stmt><expr><name>parsingStatus</name> = <call><name>ParseIDSelector</name><argument_list>(<argument><expr><name>aDataMask</name></expr></argument>, <argument><expr>*<name>newSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'.'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{    <comment type="line">// .class</comment>
    <expr_stmt><expr><name>parsingStatus</name> = <call><name>ParseClassSelector</name><argument_list>(<argument><expr><name>aDataMask</name></expr></argument>, <argument><expr>*<name>newSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{    <comment type="line">// :pseudo</comment>
    <expr_stmt><expr><name>parsingStatus</name> = <call><name>ParsePseudoSelector</name><argument_list>(<argument><expr><name>aDataMask</name></expr></argument>, <argument><expr>*<name>newSel</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>,
                                        <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'['</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{    <comment type="line">// [attribute</comment>
    <expr_stmt><expr><name>parsingStatus</name> = <call><name>ParseAttributeSelector</name><argument_list>(<argument><expr><name>aDataMask</name></expr></argument>, <argument><expr>*<name>newSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <comment type="line">// then it should be a type element or universal selector</comment>
    <expr_stmt><expr><name>parsingStatus</name> = <call><name>ParseTypeOrUniversalSelector</name><argument_list>(<argument><expr><name>aDataMask</name></expr></argument>, <argument><expr>*<name>newSel</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if></else></if>
  <if>if <condition>(<expr><name>eSelectorParsingStatus_Error</name> == <name>parsingStatus</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PENegationBadInner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>parsingStatus</name></expr>;</return>
  }</block></then></if>
  <comment type="line">// close the parenthesis</comment>
  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PENegationNoClose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>newSel</name>-&gt;<name>mNameSpace</name></name> == <name>kNameSpaceID_Unknown</name> ||
               (!<name><name>newSel</name>-&gt;<name>mIDList</name></name> &amp;&amp; !<name><name>newSel</name>-&gt;<name>mClassList</name></name> &amp;&amp;
                !<name><name>newSel</name>-&gt;<name>mPseudoClassList</name></name> &amp;&amp; !<name><name>newSel</name>-&gt;<name>mAttrList</name></name>)</expr></argument>,
               <argument><expr>"Need to fix the serialization code to deal with this"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>eSelectorParsingStatus_Continue</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// Parse the argument of a pseudo-class that has an ident arg</comment>
<comment type="line">//</comment>
<function><type><name><name>CSSParserImpl</name>::<name>nsSelectorParsingStatus</name></name></type>
<name><name>CSSParserImpl</name>::<name>ParsePseudoClassWithIdentArg</name></name><parameter_list>(<param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>,
                                            <param><decl><type><name>nsIAtom</name>*</type>       <name>aPseudo</name></decl></param>,
                                            <param><decl><type><name><name>nsCSSPseudoClasses</name>::<name>Type</name></name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature eof</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEPseudoClassArgEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>
  <comment type="line">// We expect an identifier with a language abbreviation</comment>
  <if>if <condition>(<expr><name>eCSSToken_Ident</name> != <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoClassArgNotIdent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
  }</block></then></if>

  <comment type="line">// -moz-locale-dir can only have values of 'ltr' or 'rtl'.</comment>
  <if>if <condition>(<expr><name>aPseudo</name> == <name><name>nsCSSPseudoClasses</name>::<name>mozLocaleDir</name></name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name><name>mToken</name>.<name>mIdent</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"ltr"</expr></argument>)</argument_list></call> &amp;&amp;
        !<call><name><name>mToken</name>.<name>mIdent</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"rtl"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Add the pseudo with the language parameter</comment>
  <expr_stmt><expr><call><name><name>aSelector</name>.<name>AddPseudoClass</name></name><argument_list>(<argument><expr><name>aPseudo</name></expr></argument>, <argument><expr><name>aType</name></expr></argument>, <argument><expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// close the parenthesis</comment>
  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoClassNoClose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
  }</block></then></if>

  <return>return <expr><name>eSelectorParsingStatus_Continue</name></expr>;</return>
}</block></function>

<function><type><name><name>CSSParserImpl</name>::<name>nsSelectorParsingStatus</name></name></type>
<name><name>CSSParserImpl</name>::<name>ParsePseudoClassWithNthPairArg</name></name><parameter_list>(<param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>,
                                              <param><decl><type><name>nsIAtom</name>*</type>       <name>aPseudo</name></decl></param>,
                                              <param><decl><type><name><name>nsCSSPseudoClasses</name>::<name>Type</name></name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name><name>numbers</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{ <expr>0</expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>lookForB</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Follow the whitespace rules as proposed in</comment>
  <comment type="line">// http://lists.w3.org/Archives/Public/www-style/2008Mar/0121.html</comment>

  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEPseudoClassArgEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name> || <name>eCSSToken_Dimension</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <comment type="line">// The CSS tokenization doesn't handle :nth-child() containing - well:</comment>
    <comment type="line">//   2n-1 is a dimension</comment>
    <comment type="line">//   n-1 is an identifier</comment>
    <comment type="line">// The easiest way to deal with that is to push everything from the</comment>
    <comment type="line">// minus on back onto the scanner's pushback buffer.</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>truncAt</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>StringBeginsWith</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"n-"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>truncAt</name> = 1</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>StringBeginsWith</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>, <argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"-n-"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>truncAt</name> = 2</expr>;</expr_stmt>
    }</block></then></if></else></if>
    <if>if <condition>(<expr><name>truncAt</name> != 0</expr>)</condition><then> <block>{
      <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= <name>truncAt</name></expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name><name>mScanner</name>.<name>Pushback</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>Truncate</name></name><argument_list>(<argument><expr><name>truncAt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"odd"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>numbers</name><index>[<expr>0</expr>]</index></name> = 2</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>numbers</name><index>[<expr>1</expr>]</index></name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>lookForB</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"even"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>numbers</name><index>[<expr>0</expr>]</index></name> = 2</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>numbers</name><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>lookForB</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"n"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>numbers</name><index>[<expr>0</expr>]</index></name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-n"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>numbers</name><index>[<expr>0</expr>]</index></name> = -1</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoClassArgNotNth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
    }</block></else></if></else></if></else></if></else></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>eCSSToken_Number</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<name><name>mToken</name>.<name>mIntegerValid</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoClassArgNotNth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
    }</block></then></if>
    <expr_stmt><expr><name><name>numbers</name><index>[<expr>1</expr>]</index></name> = <name><name>mToken</name>.<name>mInteger</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lookForB</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>eCSSToken_Dimension</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<name><name>mToken</name>.<name>mIntegerValid</name></name> || !<call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"n"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoClassArgNotNth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
    }</block></then></if>
    <expr_stmt><expr><name><name>numbers</name><index>[<expr>0</expr>]</index></name> = <name><name>mToken</name>.<name>mInteger</name></name></expr>;</expr_stmt>
  }</block></then>
  <comment type="line">// XXX If it's a ')', is that valid?  (as 0n+0)</comment>
  <else>else <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoClassArgNotNth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
  }</block></else></if></else></if></else></if>

  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEPseudoClassArgEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>lookForB</name> &amp;&amp; !<call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// The '+' or '-' sign can optionally be separated by whitespace.</comment>
    <comment type="line">// If it is separated by whitespace from what follows it, it appears</comment>
    <comment type="line">// as a separate token rather than part of the number token.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>haveSign</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>sign</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'+'</expr></argument>)</argument_list></call> || <call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'-'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>haveSign</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'-'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEPseudoClassArgEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Number</name> != <name><name>mToken</name>.<name>mType</name></name> ||
        !<name><name>mToken</name>.<name>mIntegerValid</name></name> || <name><name>mToken</name>.<name>mHasSign</name></name> == <name>haveSign</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoClassArgNotNth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
    }</block></then></if>
    <expr_stmt><expr><name><name>numbers</name><index>[<expr>1</expr>]</index></name> = <name><name>mToken</name>.<name>mInteger</name></name> * <name>sign</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEPseudoClassArgEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>!<call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoClassNoClose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>aSelector</name>.<name>AddPseudoClass</name></name><argument_list>(<argument><expr><name>aPseudo</name></expr></argument>, <argument><expr><name>aType</name></expr></argument>, <argument><expr><name>numbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>eSelectorParsingStatus_Continue</name></expr>;</return>
}</block></function>

<comment type="line">//</comment>
<comment type="line">// Parse the argument of a pseudo-class that has a selector list argument.</comment>
<comment type="line">// Such selector lists cannot contain combinators, but can contain</comment>
<comment type="line">// anything that goes between a pair of combinators.</comment>
<comment type="line">//</comment>
<function><type><name><name>CSSParserImpl</name>::<name>nsSelectorParsingStatus</name></name></type>
<name><name>CSSParserImpl</name>::<name>ParsePseudoClassWithSelectorListArg</name></name><parameter_list>(<param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>,
                                                   <param><decl><type><name>nsIAtom</name>*</type>       <name>aPseudo</name></decl></param>,
                                                   <param><decl><type><name><name>nsCSSPseudoClasses</name>::<name>Type</name></name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>nsCSSSelectorList</name></expr></argument>&gt;</argument_list></name></type> <name>slist</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>! <call><name>ParseSelectorList</name><argument_list>(<argument><expr>*<call><name>getter_Transfers</name><argument_list>(<argument><expr><name>slist</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PRUnichar</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
  }</block></then></if>

  <comment type="line">// Check that none of the selectors in the list have combinators or</comment>
  <comment type="line">// pseudo-elements.</comment>
  <for>for (<init><decl><type><name>nsCSSSelectorList</name> *</type><name>l</name> <init>= <expr><name>slist</name></expr></init></decl>;</init> <condition><expr><name>l</name></expr>;</condition> <incr><expr><name>l</name> = <name><name>l</name>-&gt;<name>mNext</name></name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsCSSSelector</name> *</type><name>s</name> <init>= <expr><name><name>l</name>-&gt;<name>mSelectors</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>mNext</name></name> || <call><name><name>s</name>-&gt;<name>IsPseudoElement</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
    }</block></then></if>
  }</block></for>

  <comment type="line">// Add the pseudo with the selector list parameter</comment>
  <expr_stmt><expr><call><name><name>aSelector</name>.<name>AddPseudoClass</name></name><argument_list>(<argument><expr><name>aPseudo</name></expr></argument>, <argument><expr><name>aType</name></expr></argument>, <argument><expr><call><name><name>slist</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// close the parenthesis</comment>
  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEPseudoClassNoClose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>eSelectorParsingStatus_Error</name></expr>;</return> <comment type="line">// our caller calls SkipUntil(')')</comment>
  }</block></then></if>

  <return>return <expr><name>eSelectorParsingStatus_Continue</name></expr>;</return>
}</block></function>


<comment type="block" format="doxygen">/**
 * This is the format for selectors:
 * operator? [[namespace |]? element_name]? [ ID | class | attrib | pseudo ]*
 */</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseSelector</name></name><parameter_list>(<param><decl><type><name>nsCSSSelectorList</name>*</type> <name>aList</name></decl></param>,
                             <param><decl><type><name>PRUnichar</name></type> <name>aPrevCombinator</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PESelectorEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsCSSSelector</name>*</type> <name>selector</name> <init>= <expr><call><name><name>aList</name>-&gt;<name>AddSelector</name></name><argument_list>(<argument><expr><name>aPrevCombinator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>pseudoElement</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>nsPseudoClassList</name></expr></argument>&gt;</argument_list></name></type> <name>pseudoElementArgs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCSSPseudoElements</name>::<name>Type</name></name></type> <name>pseudoElementType</name> <init>=
    <expr><name><name>nsCSSPseudoElements</name>::<name>ePseudo_NotPseudoElement</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>dataMask</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsSelectorParsingStatus</name></type> <name>parsingStatus</name> <init>=
    <expr><call><name>ParseTypeOrUniversalSelector</name><argument_list>(<argument><expr><name>dataMask</name></expr></argument>, <argument><expr>*<name>selector</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><name>parsingStatus</name> == <name>eSelectorParsingStatus_Continue</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><name>eCSSToken_ID</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{ <comment type="line">// #id</comment>
      <expr_stmt><expr><name>parsingStatus</name> = <call><name>ParseIDSelector</name><argument_list>(<argument><expr><name>dataMask</name></expr></argument>, <argument><expr>*<name>selector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'.'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{    <comment type="line">// .class</comment>
      <expr_stmt><expr><name>parsingStatus</name> = <call><name>ParseClassSelector</name><argument_list>(<argument><expr><name>dataMask</name></expr></argument>, <argument><expr>*<name>selector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{    <comment type="line">// :pseudo</comment>
      <expr_stmt><expr><name>parsingStatus</name> = <call><name>ParsePseudoSelector</name><argument_list>(<argument><expr><name>dataMask</name></expr></argument>, <argument><expr>*<name>selector</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                          <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>pseudoElement</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>getter_Transfers</name><argument_list>(<argument><expr><name>pseudoElementArgs</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr>&amp;<name>pseudoElementType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'['</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{    <comment type="line">// [attribute</comment>
      <expr_stmt><expr><name>parsingStatus</name> = <call><name>ParseAttributeSelector</name><argument_list>(<argument><expr><name>dataMask</name></expr></argument>, <argument><expr>*<name>selector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{  <comment type="line">// not a selector token, we're done</comment>
      <expr_stmt><expr><name>parsingStatus</name> = <name>eSelectorParsingStatus_Done</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></else></if></else></if></else></if></else></if>

    <if>if <condition>(<expr><name>parsingStatus</name> != <name>eSelectorParsingStatus_Continue</name></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>

    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// premature eof is ok (here!)</comment>
      <expr_stmt><expr><name>parsingStatus</name> = <name>eSelectorParsingStatus_Done</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></while>

  <if>if <condition>(<expr><name>parsingStatus</name> == <name>eSelectorParsingStatus_Error</name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>dataMask</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name><name>selector</name>-&gt;<name>mNext</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PESelectorGroupExtraCombinator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PESelectorGroupNoSelector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>pseudoElementType</name> == <name><name>nsCSSPseudoElements</name>::<name>ePseudo_AnonBox</name></name></expr>)</condition><then> <block>{
    <comment type="line">// We got an anonymous box pseudo-element; it must be the only</comment>
    <comment type="line">// thing in this selector group.</comment>
    <if>if <condition>(<expr><name><name>selector</name>-&gt;<name>mNext</name></name> || !<call><name>IsUniversalSelector</name><argument_list>(<argument><expr>*<name>selector</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEAnonBoxNotAlone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// Rewrite the current selector as this pseudo-element.</comment>
    <comment type="line">// It does not contribute to selector weight.</comment>
    <expr_stmt><expr><call><name><name>selector</name>-&gt;<name>mLowercaseTag</name>.<name>swap</name></name><argument_list>(<argument><expr><name>pseudoElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>selector</name>-&gt;<name>mPseudoClassList</name></name> = <call><name><name>pseudoElementArgs</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>selector</name>-&gt;<name>SetPseudoType</name></name><argument_list>(<argument><expr><name>pseudoElementType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name><name>aList</name>-&gt;<name>mWeight</name></name> += <call><name><name>selector</name>-&gt;<name>CalcWeight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Pseudo-elements other than anonymous boxes are represented as</comment>
  <comment type="line">// direct children ('&gt;' combinator) of the rest of the selector.</comment>
  <if>if <condition>(<expr><name>pseudoElement</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>selector</name> = <call><name><name>aList</name>-&gt;<name>AddSelector</name></name><argument_list>(<argument><expr>'&gt;'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>selector</name>-&gt;<name>mLowercaseTag</name>.<name>swap</name></name><argument_list>(<argument><expr><name>pseudoElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>selector</name>-&gt;<name>mPseudoClassList</name></name> = <call><name><name>pseudoElementArgs</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>selector</name>-&gt;<name>SetPseudoType</name></name><argument_list>(<argument><expr><name>pseudoElementType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name><name>css</name>::<name>Declaration</name></name>*</type>
<name><name>CSSParserImpl</name>::<name>ParseDeclarationBlock</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCheckForBraces</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aCheckForBraces</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>'{'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEBadDeclBlockStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>nsnull</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <decl_stmt><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>declaration</name> <init>= <expr>new <call><name><name>css</name>::<name>Declaration</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>mData</name>.<name>AssertInitialState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>declaration</name></expr>)</condition><then> <block>{
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>changed</name></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<call><name>ParseDeclaration</name><argument_list>(<argument><expr><name>declaration</name></expr></argument>, <argument><expr><name>aCheckForBraces</name></expr></argument>,
                            <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr>&amp;<name>changed</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>SkipDeclaration</name><argument_list>(<argument><expr><name>aCheckForBraces</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <break>break;</break>
        }</block></then></if>
        <if>if <condition>(<expr><name>aCheckForBraces</name></expr>)</condition><then> <block>{
          <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>'}'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <break>break;</break>
          }</block></then></if>
        }</block></then></if>
        <comment type="line">// Since the skipped declaration didn't end the block we parse</comment>
        <comment type="line">// the next declaration.</comment>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name><name>declaration</name>-&gt;<name>CompressFrom</name></name><argument_list>(<argument><expr>&amp;<name>mData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>declaration</name></expr>;</return>
}</block></function>

<comment type="line">// The types to pass to ParseColorComponent.  These correspond to the</comment>
<comment type="line">// various datatypes that can go within rgb().</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_TYPE_UNKNOWN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_TYPE_INTEGERS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_TYPE_PERCENTAGES</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseColor</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEColorEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscolor</name></type> <name>rgba</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition> <block>{
    <case>case <expr><name>eCSSToken_ID</name></expr>:
    </case><case>case <expr><name>eCSSToken_Ref</name></expr>:
      <comment type="line">// #xxyyzz</comment>
      <if>if <condition>(<expr><call><name>NS_HexToRGB</name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>, <argument><expr>&amp;<name>rgba</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aValue</name>.<name>SetColorValue</name></name><argument_list>(<argument><expr><name>rgba</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_TRUE</name></expr>;</return>
      }</block></then></if>
      <break>break;</break>

    </case><case>case <expr><name>eCSSToken_Ident</name></expr>:
      <if>if <condition>(<expr><call><name>NS_ColorNameToRGB</name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>, <argument><expr>&amp;<name>rgba</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aValue</name>.<name>SetStringValue</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_TRUE</name></expr>;</return>
      }</block></then>
      <else>else <block>{
        <decl_stmt><decl><type><name>nsCSSKeyword</name></type> <name>keyword</name> <init>= <expr><call><name><name>nsCSSKeywords</name>::<name>LookupKeyword</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>eCSSKeyword_UNKNOWN</name> &lt; <name>keyword</name></expr>)</condition><then> <block>{ <comment type="line">// known keyword</comment>
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>value</name></decl>;</decl_stmt>
          <if>if <condition>(<expr><call><name><name>nsCSSProps</name>::<name>FindKeyword</name></name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kColorKTable</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>aValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>eCSSUnit_EnumColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>PR_TRUE</name></expr>;</return>
          }</block></then></if>
        }</block></then></if>
      }</block></else></if>
      <break>break;</break>
    </case><case>case <expr><name>eCSSToken_Function</name></expr>:
      <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"rgb"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// rgb ( component , component , component )</comment>
        <decl_stmt><decl><type><name>PRUint8</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>g</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>type</name> <init>= <expr><name>COLOR_TYPE_UNKNOWN</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>ParseColorComponent</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>ParseColorComponent</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>ParseColorComponent</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>')'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetColorValue</name></name><argument_list>(<argument><expr><call><name>NS_RGB</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>g</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then>
      <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-rgba"</expr></argument>)</argument_list></call> ||
               <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"rgba"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// rgba ( component , component , component , opacity )</comment>
        <decl_stmt><decl><type><name>PRUint8</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>g</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>a</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>type</name> <init>= <expr><name>COLOR_TYPE_UNKNOWN</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>ParseColorComponent</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>ParseColorComponent</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>ParseColorComponent</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>ParseColorOpacity</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetColorValue</name></name><argument_list>(<argument><expr><call><name>NS_RGBA</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then>
      <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"hsl"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// hsl ( hue , saturation , lightness )</comment>
        <comment type="line">// "hue" is a number, "saturation" and "lightness" are percentages.</comment>
        <if>if <condition>(<expr><call><name>ParseHSLColor</name><argument_list>(<argument><expr><name>rgba</name></expr></argument>, <argument><expr>')'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetColorValue</name></name><argument_list>(<argument><expr><name>rgba</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then>
      <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-hsla"</expr></argument>)</argument_list></call> ||
               <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"hsla"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// hsla ( hue , saturation , lightness , opacity )</comment>
        <comment type="line">// "hue" is a number, "saturation" and "lightness" are percentages,</comment>
        <comment type="line">// "opacity" is a number.</comment>
        <decl_stmt><decl><type><name>PRUint8</name></type> <name>a</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>ParseHSLColor</name><argument_list>(<argument><expr><name>rgba</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>ParseColorOpacity</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetColorValue</name></name><argument_list>(<argument><expr><call><name>NS_RGBA</name><argument_list>(<argument><expr><call><name>NS_GET_R</name><argument_list>(<argument><expr><name>rgba</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NS_GET_G</name><argument_list>(<argument><expr><name>rgba</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>NS_GET_B</name><argument_list>(<argument><expr><name>rgba</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if></else></if></else></if></else></if>
      <break>break;</break>
    </case><default>default:
      <break>break;</break>
  </default>}</block></switch>

  <comment type="line">// try 'xxyyzz' without '#' prefix for compatibility with IE and Nav4x (bug 23236 and 45804)</comment>
  <if>if <condition>(<expr><name>mNavQuirkMode</name> &amp;&amp; !<call><name>IsParsingCompoundProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// - If the string starts with 'a-f', the nsCSSScanner builds the</comment>
    <comment type="line">//   token as a eCSSToken_Ident and we can parse the string as a</comment>
    <comment type="line">//   'xxyyzz' RGB color.</comment>
    <comment type="line">// - If it only contains '0-9' digits, the token is a</comment>
    <comment type="line">//   eCSSToken_Number and it must be converted back to a 6</comment>
    <comment type="line">//   characters string to be parsed as a RGB color.</comment>
    <comment type="line">// - If it starts with '0-9' and contains any 'a-f', the token is a</comment>
    <comment type="line">//   eCSSToken_Dimension, the mNumber part must be converted back to</comment>
    <comment type="line">//   a string and the mIdent part must be appended to that string so</comment>
    <comment type="line">//   that the resulting string has 6 characters.</comment>
    <comment type="line">// Note: This is a hack for Nav compatibility.  Do not attempt to</comment>
    <comment type="line">// simplify it by hacking into the ncCSSScanner.  This would be very</comment>
    <comment type="line">// bad.</comment>
    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition> <block>{
      <case>case <expr><name>eCSSToken_Ident</name></expr>:
        <expr_stmt><expr><call><name><name>str</name>.<name>Assign</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>eCSSToken_Number</name></expr>:
        <if>if <condition>(<expr><name><name>tk</name>-&gt;<name>mIntegerValid</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>PR_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%06d"</expr></argument>, <argument><expr><name><name>tk</name>-&gt;<name>mInteger</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>str</name>.<name>AssignWithConversion</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr><name>eCSSToken_Dimension</name></expr>:
        <if>if <condition>(<expr><call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>Length</name></name><argument_list>()</argument_list></call> &lt;= 6</expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>PR_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%06.0f"</expr></argument>, <argument><expr><name><name>tk</name>-&gt;<name>mNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>nsAutoString</name></type> <name>temp</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>temp</name>.<name>AssignWithConversion</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>temp</name>.<name>Right</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>6 - <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name><name>str</name>.<name>Append</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><default>default:
        <comment type="line">// There is a whole bunch of cases that are</comment>
        <comment type="line">// not handled by this switch.  Ignore them.</comment>
        <break>break;</break>
    </default>}</block></switch>
    <if>if <condition>(<expr><call><name>NS_HexToRGB</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>rgba</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aValue</name>.<name>SetColorValue</name></name><argument_list>(<argument><expr><name>rgba</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// It's not a color</comment>
  <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEColorNotColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// aType will be set if we have already parsed other color components</comment>
<comment type="line">// in this color spec</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseColorComponent</name></name><parameter_list>(<param><decl><type><name>PRUint8</name>&amp;</type> <name>aComponent</name></decl></param>,
                                   <param><decl><type><name>PRInt32</name>&amp;</type> <name>aType</name></decl></param>,
                                   <param><decl><type><name>char</name></type> <name>aStop</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEColorComponentEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>float</name></type> <name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition> <block>{
  <case>case <expr><name>eCSSToken_Number</name></expr>:
    <switch>switch <condition>(<expr><name>aType</name></expr>)</condition> <block>{
      <case>case <expr><name>COLOR_TYPE_UNKNOWN</name></expr>:
        <expr_stmt><expr><name>aType</name> = <name>COLOR_TYPE_INTEGERS</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>COLOR_TYPE_INTEGERS</name></expr>:
        <break>break;</break>
      </case><case>case <expr><name>COLOR_TYPE_PERCENTAGES</name></expr>:
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedPercent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      </case><default>default:
        <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"Someone forgot to add the new color component type in here"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>

    <if>if <condition>(<expr>!<name><name>mToken</name>.<name>mIntegerValid</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>value</name> = <name><name>tk</name>-&gt;<name>mNumber</name></name></expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>eCSSToken_Percentage</name></expr>:
    <switch>switch <condition>(<expr><name>aType</name></expr>)</condition> <block>{
      <case>case <expr><name>COLOR_TYPE_UNKNOWN</name></expr>:
        <expr_stmt><expr><name>aType</name> = <name>COLOR_TYPE_PERCENTAGES</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>COLOR_TYPE_INTEGERS</name></expr>:
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      </case><case>case <expr><name>COLOR_TYPE_PERCENTAGES</name></expr>:
        <break>break;</break>
      </case><default>default:
        <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"Someone forgot to add the new color component type in here"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>
    <expr_stmt><expr><name>value</name> = <name><name>tk</name>-&gt;<name>mNumber</name></name> * 255.0f</expr>;</expr_stmt>
    <break>break;</break>
  </case><default>default:
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEColorBadRGBContents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </default>}</block></switch>
  <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr><name>aStop</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>value</name> &lt; 0.0f</expr>)</condition><then> <expr_stmt><expr><name>value</name> = 0.0f</expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>value</name> &gt; 255.0f</expr>)</condition><then> <expr_stmt><expr><name>value</name> = 255.0f</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>aComponent</name> = <call><name>NSToIntRound</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type> <name><name>stopString</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>PRUnichar</name><argument_list>(<argument><expr><name>aStop</name></expr></argument>)</argument_list></call></expr>, <macro><name>PRUnichar</name><argument_list>(<argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>nsnull</name></expr>,
    <expr><name>stopString</name></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN_P</name><argument_list>(<argument><expr><name>PEColorComponentBadTerm</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>


<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseHSLColor</name></name><parameter_list>(<param><decl><type><name>nscolor</name>&amp;</type> <name>aColor</name></decl></param>,
                             <param><decl><type><name>char</name></type> <name>aStop</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>float</name></type> <name>h</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>l</name></decl>;</decl_stmt>

  <comment type="line">// Get the hue</comment>
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEColorHueEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_Number</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>h</name> = <name><name>mToken</name>.<name>mNumber</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> /= 360.0f</expr>;</expr_stmt>
  <comment type="line">// hue values are wraparound</comment>
  <expr_stmt><expr><name>h</name> = <name>h</name> - <call><name>floor</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedComma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Get the saturation</comment>
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEColorSaturationEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_Percentage</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedPercent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>s</name> = <name><name>mToken</name>.<name>mNumber</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>s</name> &lt; 0.0f</expr>)</condition><then> <expr_stmt><expr><name>s</name> = 0.0f</expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>s</name> &gt; 1.0f</expr>)</condition><then> <expr_stmt><expr><name>s</name> = 1.0f</expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedComma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Get the lightness</comment>
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEColorLightnessEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_Percentage</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedPercent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>l</name> = <name><name>mToken</name>.<name>mNumber</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>l</name> &lt; 0.0f</expr>)</condition><then> <expr_stmt><expr><name>l</name> = 0.0f</expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>l</name> &gt; 1.0f</expr>)</condition><then> <expr_stmt><expr><name>l</name> = 1.0f</expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr><name>aStop</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>aColor</name> = <call><name>NS_HSL2RGB</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type> <name><name>stopString</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>PRUnichar</name><argument_list>(<argument><expr><name>aStop</name></expr></argument>)</argument_list></call></expr>, <macro><name>PRUnichar</name><argument_list>(<argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>nsnull</name></expr>,
    <expr><name>stopString</name></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN_P</name><argument_list>(<argument><expr><name>PEColorComponentBadTerm</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>


<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseColorOpacity</name></name><parameter_list>(<param><decl><type><name>PRUint8</name>&amp;</type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEColorOpacityEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_Number</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name><name>mToken</name>.<name>mNumber</name></name> &lt; 0.0f</expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>mToken</name>.<name>mNumber</name></name> = 0.0f</expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><name><name>mToken</name>.<name>mNumber</name></name> &gt; 1.0f</expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>mToken</name>.<name>mNumber</name></name> = 1.0f</expr>;</expr_stmt>
  }</block></then></if></else></if>

  <decl_stmt><decl><type><name>PRUint8</name></type> <name>value</name> <init>= <expr><call><name><name>nsStyleUtil</name>::<name>FloatToColorComponent</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mNumber</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// Need to compare to something slightly larger</comment>
  <comment type="line">// than 0.5 due to floating point inaccuracies.</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr>255.0f*<name><name>mToken</name>.<name>mNumber</name></name> - <name>value</name></expr></argument>)</argument_list></call> &lt;= 0.51f</expr></argument>,
               <argument><expr>"FloatToColorComponent did something weird"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedCloseParen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>aOpacity</name> = <name>value</name></expr>;</expr_stmt>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_XUL</name></cpp:ifdef>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseTreePseudoElement</name></name><parameter_list>(<param><decl><type><name>nsPseudoClassList</name> **</type><name>aPseudoElementArgs</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// The argument to a tree pseudo-element is a sequence of identifiers</comment>
  <comment type="line">// that are either space- or comma-separated.  (Was the intent to</comment>
  <comment type="line">// allow only comma-separated?  That's not what was done.)</comment>
  <decl_stmt><decl><type><name>nsCSSSelector</name></type> <name>fakeSelector</name></decl>;</decl_stmt> <comment type="line">// so we can reuse AddPseudoClass</comment>

  <while>while <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>pseudo</name> <init>= <expr><call><name>do_GetAtom</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>fakeSelector</name>.<name>AddPseudoClass</name></name><argument_list>(<argument><expr><name>pseudo</name></expr></argument>,
                                  <argument><expr><name><name>nsCSSPseudoClasses</name>::<name>ePseudoClass_NotPseudoClass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>','</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if></else></if>
  }</block></while>
  <expr_stmt><expr>*<name>aPseudoElementArgs</name> = <name><name>fakeSelector</name>.<name>mPseudoClassList</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fakeSelector</name>.<name>mPseudoClassList</name></name> = <name>nsnull</name></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//----------------------------------------------------------------------</comment>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseDeclaration</name></name><parameter_list>(<param><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>aDeclaration</name></decl></param>,
                                <param><decl><type><name>PRBool</name></type> <name>aCheckForBraces</name></decl></param>,
                                <param><decl><type><name>PRBool</name></type> <name>aMustCallValueAppended</name></decl></param>,
                                <param><decl><type><name>PRBool</name>*</type> <name>aChanged</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mTempData</name>.<name>AssertInitialState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Get property name</comment>
  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>propertyName</name></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>aCheckForBraces</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEDeclEndEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>propertyName</name> = <name><name>tk</name>-&gt;<name>mIdent</name></name></expr>;</expr_stmt>
      <comment type="line">// grab the ident before the ExpectSymbol trashes the token</comment>
      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>':'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEParseDeclarationNoColon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEDeclDropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><call><name><name>tk</name>-&gt;<name>IsSymbol</name></name><argument_list>(<argument><expr>';'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// dangling semicolons are skipped</comment>
      <continue>continue;</continue>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name><name>tk</name>-&gt;<name>IsSymbol</name></name><argument_list>(<argument><expr>'}'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEParseDeclarationDeclExpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEDeclSkipped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// Not a declaration...</comment>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></for>

  <comment type="line">// Map property name to its ID and then parse the property</comment>
  <decl_stmt><decl><type><name>nsCSSProperty</name></type> <name>propID</name> <init>= <expr><call><name><name>nsCSSProps</name>::<name>LookupProperty</name></name><argument_list>(<argument><expr><name>propertyName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>eCSSProperty_UNKNOWN</name> == <name>propID</name></expr>)</condition><then> <block>{ <comment type="line">// unknown property</comment>
    <if>if <condition>(<expr>!<call><name>NonMozillaVendorIdentifier</name><argument_list>(<argument><expr><name>propertyName</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[]</index></name> <init>= <expr><block>{
        <macro><name>propertyName</name></macro><expr>.<macro><name>get</name><argument_list>()</argument_list></macro></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_P</name><argument_list>(<argument><expr><name>PEUnknownProperty</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEDeclDropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>! <call><name>ParseProperty</name><argument_list>(<argument><expr><name>propID</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// XXX Much better to put stuff in the value parsers instead...</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[]</index></name> <init>= <expr><block>{
      <macro><name>propertyName</name></macro><expr>.<macro><name>get</name><argument_list>()</argument_list></macro></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_P</name><argument_list>(<argument><expr><name>PEValueParsingError</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEDeclDropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mTempData</name>.<name>ClearProperty</name></name><argument_list>(<argument><expr><name>propID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mTempData</name>.<name>AssertInitialState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>CLEAR_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Look for "!important".</comment>
  <decl_stmt><decl><type><name>PriorityParsingStatus</name></type> <name>status</name> <init>= <expr><call><name>ParsePriority</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Look for a semicolon or close brace.</comment>
  <if>if <condition>(<expr><name>status</name> != <name>ePriority_Error</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// EOF is always ok</comment>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>';'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// semicolon is always ok</comment>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'}'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// brace is ok if aCheckForBraces, but don't eat it</comment>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>aCheckForBraces</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>status</name> = <name>ePriority_Error</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>status</name> = <name>ePriority_Error</name></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>status</name> == <name>ePriority_Error</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>aCheckForBraces</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEBadDeclOrRuleEnd2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEBadDeclEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEDeclDropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OUTPUT_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mTempData</name>.<name>ClearProperty</name></name><argument_list>(<argument><expr><name>propID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mTempData</name>.<name>AssertInitialState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>aChanged</name> |= <call><name><name>mData</name>.<name>TransferFromBlock</name></name><argument_list>(<argument><expr><name>mTempData</name></expr></argument>, <argument><expr><name>propID</name></expr></argument>,
                                       <argument><expr><name>status</name> == <name>ePriority_Important</name></expr></argument>,
                                       <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>aMustCallValueAppended</name></expr></argument>,
                                       <argument><expr><name>aDeclaration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderTopIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty_border_top_width</name></expr>,
  <expr><name>eCSSProperty_border_top_style</name></expr>,
  <expr><name>eCSSProperty_border_top_color</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderRightIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty_border_right_width_value</name></expr>,
  <expr><name>eCSSProperty_border_right_style_value</name></expr>,
  <expr><name>eCSSProperty_border_right_color_value</name></expr>,
  <expr><name>eCSSProperty_border_right_width</name></expr>,
  <expr><name>eCSSProperty_border_right_style</name></expr>,
  <expr><name>eCSSProperty_border_right_color</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderBottomIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty_border_bottom_width</name></expr>,
  <expr><name>eCSSProperty_border_bottom_style</name></expr>,
  <expr><name>eCSSProperty_border_bottom_color</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderLeftIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty_border_left_width_value</name></expr>,
  <expr><name>eCSSProperty_border_left_style_value</name></expr>,
  <expr><name>eCSSProperty_border_left_color_value</name></expr>,
  <expr><name>eCSSProperty_border_left_width</name></expr>,
  <expr><name>eCSSProperty_border_left_style</name></expr>,
  <expr><name>eCSSProperty_border_left_color</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderStartIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty_border_start_width_value</name></expr>,
  <expr><name>eCSSProperty_border_start_style_value</name></expr>,
  <expr><name>eCSSProperty_border_start_color_value</name></expr>,
  <expr><name>eCSSProperty_border_start_width</name></expr>,
  <expr><name>eCSSProperty_border_start_style</name></expr>,
  <expr><name>eCSSProperty_border_start_color</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderEndIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty_border_end_width_value</name></expr>,
  <expr><name>eCSSProperty_border_end_style_value</name></expr>,
  <expr><name>eCSSProperty_border_end_color_value</name></expr>,
  <expr><name>eCSSProperty_border_end_width</name></expr>,
  <expr><name>eCSSProperty_border_end_style</name></expr>,
  <expr><name>eCSSProperty_border_end_color</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kColumnRuleIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty__moz_column_rule_width</name></expr>,
  <expr><name>eCSSProperty__moz_column_rule_style</name></expr>,
  <expr><name>eCSSProperty__moz_column_rule_color</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseEnum</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aKeywordTable</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsSubstring</name>*</type> <name>ident</name> <init>= <expr><call><name>NextIdent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>nsnull</name> == <name>ident</name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsCSSKeyword</name></type> <name>keyword</name> <init>= <expr><call><name><name>nsCSSKeywords</name>::<name>LookupKeyword</name></name><argument_list>(<argument><expr>*<name>ident</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>eCSSKeyword_UNKNOWN</name> &lt; <name>keyword</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>value</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>nsCSSProps</name>::<name>FindKeyword</name></name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>aKeywordTable</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Put the unknown identifier back and return</comment>
  <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>


<struct>struct <name>UnitInfo</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>  <comment type="line">// needs to be long enough for the longest unit, with</comment>
                 <comment type="line">// terminating null.</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSUnit</name></type> <name>unit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>type</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_WITH_LEN</name><parameter_list>(<param><type><name>_str</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>_str, sizeof(_str) - 1</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>UnitInfo</name></type> <name><name>UnitData</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"px"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Pixel</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"em"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_EM</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"ex"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_XHeight</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"pt"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Point</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"in"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Inch</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"cm"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Centimeter</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"ch"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Char</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"rem"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_RootEM</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"mm"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Millimeter</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"mozmm"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_PhysicalMillimeter</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"pc"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Pica</name></expr>, <expr><name>VARIANT_LENGTH</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"deg"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Degree</name></expr>, <expr><name>VARIANT_ANGLE</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"grad"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Grad</name></expr>, <expr><name>VARIANT_ANGLE</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"rad"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Radian</name></expr>, <expr><name>VARIANT_ANGLE</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"hz"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Hertz</name></expr>, <expr><name>VARIANT_FREQUENCY</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"khz"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Kilohertz</name></expr>, <expr><name>VARIANT_FREQUENCY</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"s"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Seconds</name></expr>, <expr><name>VARIANT_TIME</name></expr> }</block></expr>,
  <expr><block>{ <expr><call><name>STR_WITH_LEN</name><argument_list>(<argument><expr>"ms"</expr></argument>)</argument_list></call></expr>, <expr><name>eCSSUnit_Milliseconds</name></expr>, <expr><name>VARIANT_TIME</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STR_WITH_LEN</name></cpp:undef>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>TranslateDimension</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                  <param><decl><type><name>PRInt32</name></type> <name>aVariantMask</name></decl></param>,
                                  <param><decl><type><name>float</name></type> <name>aNumber</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aUnit</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSUnit</name></type> <name>units</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type>   <name>type</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>aUnit</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>UnitData</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
      <if>if <condition>(<expr><call><name><name>aUnit</name>.<name>LowerCaseEqualsASCII</name></name><argument_list>(<argument><expr><name><name>UnitData</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>,
                                     <argument><expr><name><name>UnitData</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>units</name> = <name><name>UnitData</name><index>[<expr><name>i</name></expr>]</index></name>.<name>unit</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> = <name><name>UnitData</name><index>[<expr><name>i</name></expr>]</index></name>.<name>type</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>i</name> == <call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>UnitData</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Unknown unit</comment>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <comment type="line">// Must be a zero number...</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>0 == <name>aNumber</name></expr></argument>, <argument><expr>"numbers without units must be 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>VARIANT_LENGTH</name> &amp; <name>aVariantMask</name>) != 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>units</name> = <name>eCSSUnit_Point</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>type</name> = <name>VARIANT_LENGTH</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>(<name>VARIANT_ANGLE</name> &amp; <name>aVariantMask</name>) != 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aVariantMask</name> &amp; <name>VARIANT_ZERO_ANGLE</name></expr></argument>,
                   <argument><expr>"must have allowed zero angle"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>units</name> = <name>eCSSUnit_Degree</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>type</name> = <name>VARIANT_ANGLE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"Variant mask does not include dimension; why were we called?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></else></if></else></if>
  }</block></else></if>
  <if>if <condition>(<expr>(<name>type</name> &amp; <name>aVariantMask</name>) != 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetFloatValue</name></name><argument_list>(<argument><expr><name>aNumber</name></expr></argument>, <argument><expr><name>units</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// Note that this does include VARIANT_CALC, which is numeric.  This is</comment>
<comment type="line">// because calc() parsing, as proposed, drops range restrictions inside</comment>
<comment type="line">// the calc() expression and clamps the result of the calculation to the</comment>
<comment type="line">// range.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_ALL_NONNUMERIC</name></cpp:macro> \
  <cpp:value>VARIANT_KEYWORD | \
  VARIANT_COLOR | \
  VARIANT_URL | \
  VARIANT_STRING | \
  VARIANT_COUNTER | \
  VARIANT_ATTR | \
  VARIANT_IDENTIFIER | \
  VARIANT_AUTO | \
  VARIANT_INHERIT | \
  VARIANT_NONE | \
  VARIANT_NORMAL | \
  VARIANT_SYSFONT | \
  VARIANT_GRADIENT | \
  VARIANT_CUBIC_BEZIER | \
  VARIANT_ALL | \
  VARIANT_CALC | \
  VARIANT_CALC_NO_MIN_MAX</cpp:value></cpp:define>

<comment type="line">// Note that callers passing VARIANT_CALC in aVariantMask will get</comment>
<comment type="line">// full-range parsing inside the calc() expression, and the code that</comment>
<comment type="line">// computes the calc will be required to clamp the resulting value to an</comment>
<comment type="line">// appropriate range.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseNonNegativeVariant</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                       <param><decl><type><name>PRInt32</name></type> <name>aVariantMask</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aKeywordTable</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// The variant mask must only contain non-numeric variants or the ones</comment>
  <comment type="line">// that we specifically handle.</comment>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr>(<name>aVariantMask</name> &amp; ~(<name>VARIANT_ALL_NONNUMERIC</name> |
                                      <name>VARIANT_NUMBER</name> |
                                      <name>VARIANT_LENGTH</name> |
                                      <name>VARIANT_PERCENT</name> |
                                      <name>VARIANT_INTEGER</name>)) == 0</expr></argument>,
                    <argument><expr>"need to update code below to handle additional variants"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>aVariantMask</name></expr></argument>, <argument><expr><name>aKeywordTable</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>eCSSUnit_Number</name> == <call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> ||
        <call><name><name>aValue</name>.<name>IsLengthUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then><block>{
      <if>if <condition>(<expr><call><name><name>aValue</name>.<name>GetFloatValue</name></name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Percent</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name><name>aValue</name>.<name>GetPercentValue</name></name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Integer</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></then></if></else></if></else></if>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// Note that callers passing VARIANT_CALC in aVariantMask will get</comment>
<comment type="line">// full-range parsing inside the calc() expression, and the code that</comment>
<comment type="line">// computes the calc will be required to clamp the resulting value to an</comment>
<comment type="line">// appropriate range.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParsePositiveNonZeroVariant</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name></type> <name>aVariantMask</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aKeywordTable</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// The variant mask must only contain non-numeric variants or the ones</comment>
  <comment type="line">// that we specifically handle.</comment>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr>(<name>aVariantMask</name> &amp; ~(<name>VARIANT_ALL_NONNUMERIC</name> |
                                      <name>VARIANT_INTEGER</name>)) == 0</expr></argument>,
                    <argument><expr>"need to update code below to handle additional variants"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>aVariantMask</name></expr></argument>, <argument><expr><name>aKeywordTable</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Integer</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call> &lt;= 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// Assigns to aValue iff it returns PR_TRUE.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseVariant</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                            <param><decl><type><name>PRInt32</name></type> <name>aVariantMask</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aKeywordTable</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>IsParsingCompoundProperty</name><argument_list>()</argument_list></call> ||
               ((~<name>aVariantMask</name>) &amp; (<name>VARIANT_LENGTH</name>|<name>VARIANT_COLOR</name>))</expr></argument>,
               <argument><expr>"cannot distinguish lengths and colors in quirks mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; (<name>VARIANT_AHK</name> | <name>VARIANT_NORMAL</name> | <name>VARIANT_NONE</name> | <name>VARIANT_ALL</name>)) != 0) &amp;&amp;
      (<name>eCSSToken_Ident</name> == <name><name>tk</name>-&gt;<name>mType</name></name>)</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsCSSKeyword</name></type> <name>keyword</name> <init>= <expr><call><name><name>nsCSSKeywords</name>::<name>LookupKeyword</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>eCSSKeyword_UNKNOWN</name> &lt; <name>keyword</name></expr>)</condition><then> <block>{ <comment type="line">// known keyword</comment>
      <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_AUTO</name>) != 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>eCSSKeyword_auto</name> == <name>keyword</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetAutoValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
      <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_INHERIT</name>) != 0</expr>)</condition><then> <block>{
        <comment type="line">// XXX Should we check IsParsingCompoundProperty, or do all</comment>
        <comment type="line">// callers handle it?  (Not all callers set it, though, since</comment>
        <comment type="line">// they want the quirks that are disabled by setting it.)</comment>
        <if>if <condition>(<expr><name>eCSSKeyword_inherit</name> == <name>keyword</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetInheritValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>eCSSKeyword__moz_initial</name> == <name>keyword</name></expr>)</condition><then> <block>{ <comment type="line">// anything that can inherit can also take an initial val.</comment>
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetInitialValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if></else></if>
      }</block></then></if>
      <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_NONE</name>) != 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>eCSSKeyword_none</name> == <name>keyword</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetNoneValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
      <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_ALL</name>) != 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>eCSSKeyword_all</name> == <name>keyword</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetAllValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
      <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_NORMAL</name>) != 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>eCSSKeyword_normal</name> == <name>keyword</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetNormalValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
      <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_SYSFONT</name>) != 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>eCSSKeyword__moz_use_system_font</name> == <name>keyword</name> &amp;&amp;
            !<call><name>IsParsingCompoundProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetSystemFontValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
      <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_KEYWORD</name>) != 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>value</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>nsCSSProps</name>::<name>FindKeyword</name></name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>aKeywordTable</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; (<name>VARIANT_LENGTH</name> | <name>VARIANT_ANGLE</name> |
                        <name>VARIANT_FREQUENCY</name> | <name>VARIANT_TIME</name>)) != 0 &amp;&amp;
       <name>eCSSToken_Dimension</name> == <name><name>tk</name>-&gt;<name>mType</name></name>) ||
      ((<name>aVariantMask</name> &amp; (<name>VARIANT_LENGTH</name> | <name>VARIANT_ZERO_ANGLE</name>)) != 0 &amp;&amp;
       <name>eCSSToken_Number</name> == <name><name>tk</name>-&gt;<name>mType</name></name> &amp;&amp;
       <name><name>tk</name>-&gt;<name>mNumber</name></name> == 0.0f)</expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>TranslateDimension</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>aVariantMask</name></expr></argument>, <argument><expr><name><name>tk</name>-&gt;<name>mNumber</name></name></expr></argument>, <argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
    <comment type="line">// Put the token back; we didn't parse it, so we shouldn't consume it</comment>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_PERCENT</name>) != 0) &amp;&amp;
      (<name>eCSSToken_Percentage</name> == <name><name>tk</name>-&gt;<name>mType</name></name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetPercentValue</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_NUMBER</name>) != 0) &amp;&amp;
      (<name>eCSSToken_Number</name> == <name><name>tk</name>-&gt;<name>mType</name></name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetFloatValue</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mNumber</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_INTEGER</name>) != 0) &amp;&amp;
      (<name>eCSSToken_Number</name> == <name><name>tk</name>-&gt;<name>mType</name></name>) &amp;&amp; <name><name>tk</name>-&gt;<name>mIntegerValid</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mInteger</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Integer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>mNavQuirkMode</name> &amp;&amp; !<call><name>IsParsingCompoundProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// NONSTANDARD: Nav interprets unitless numbers as px</comment>
    <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_LENGTH</name>) != 0) &amp;&amp;
        (<name>eCSSToken_Number</name> == <name><name>tk</name>-&gt;<name>mType</name></name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aValue</name>.<name>SetFloatValue</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mNumber</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Pixel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>  <name>MOZ_SVG</name></cpp:ifdef>
  <if>if <condition>(<expr><call><name>IsSVGMode</name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>IsParsingCompoundProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// STANDARD: SVG Spec states that lengths and coordinates can be unitless</comment>
    <comment type="line">// in which case they default to user-units (1 px = 1 user unit)</comment>
    <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_LENGTH</name>) != 0) &amp;&amp;
        (<name>eCSSToken_Number</name> == <name><name>tk</name>-&gt;<name>mType</name></name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aValue</name>.<name>SetFloatValue</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mNumber</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Pixel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_URL</name>) != 0) &amp;&amp;
      (<name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name>) &amp;&amp;
      <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"url"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>ParseURL</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_GRADIENT</name>) != 0 &amp;&amp;
      <name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
    <comment type="line">// a generated gradient</comment>
    <if>if <condition>(<expr><call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-linear-gradient"</expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>ParseGradient</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-radial-gradient"</expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>ParseGradient</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-repeating-linear-gradient"</expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>ParseGradient</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-repeating-radial-gradient"</expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>ParseGradient</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_IMAGE_RECT</name>) != 0 &amp;&amp;
      <name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name> &amp;&amp;
      <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-image-rect"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><call><name>ParseImageRect</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_ELEMENT</name>) != 0 &amp;&amp;
      <name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name> &amp;&amp;
      <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-element"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><call><name>ParseElement</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_COLOR</name>) != 0</expr>)</condition><then> <block>{
    <if>if <condition>(<expr>(<name>mNavQuirkMode</name> &amp;&amp; !<call><name>IsParsingCompoundProperty</name><argument_list>()</argument_list></call>) || <comment type="line">// NONSTANDARD: Nav interprets 'xxyyzz' values even without '#' prefix</comment>
        (<name>eCSSToken_ID</name> == <name><name>tk</name>-&gt;<name>mType</name></name>) ||
        (<name>eCSSToken_Ref</name> == <name><name>tk</name>-&gt;<name>mType</name></name>) ||
        (<name>eCSSToken_Ident</name> == <name><name>tk</name>-&gt;<name>mType</name></name>) ||
        ((<name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name>) &amp;&amp;
         (<call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"rgb"</expr></argument>)</argument_list></call> ||
          <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"hsl"</expr></argument>)</argument_list></call> ||
          <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-rgba"</expr></argument>)</argument_list></call> ||
          <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-hsla"</expr></argument>)</argument_list></call> ||
          <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"rgba"</expr></argument>)</argument_list></call> ||
          <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"hsla"</expr></argument>)</argument_list></call>))</expr>)</condition><then>
    <block>{
      <comment type="line">// Put token back so that parse color can get it</comment>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>ParseColor</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_TRUE</name></expr>;</return>
      }</block></then></if>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_STRING</name>) != 0) &amp;&amp;
      (<name>eCSSToken_String</name> == <name><name>tk</name>-&gt;<name>mType</name></name>)</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsAutoString</name></type>  <name>buffer</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>buffer</name>.<name>Append</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetStringValue</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>eCSSUnit_String</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_IDENTIFIER</name>) != 0) &amp;&amp;
      (<name>eCSSToken_Ident</name> == <name><name>tk</name>-&gt;<name>mType</name></name>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetStringValue</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_COUNTER</name>) != 0) &amp;&amp;
      (<name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name>) &amp;&amp;
      (<call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"counter"</expr></argument>)</argument_list></call> ||
       <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"counters"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
    <return>return <expr><call><name>ParseCounter</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_ATTR</name>) != 0) &amp;&amp;
      (<name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name>) &amp;&amp;
      <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"attr"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>ParseAttr</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>((<name>aVariantMask</name> &amp; <name>VARIANT_CUBIC_BEZIER</name>) != 0) &amp;&amp;
      (<name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name>)</expr>)</condition><then> <block>{
     <if>if <condition>(<expr><call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"cubic-bezier"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>ParseTransitionTimingFunctionValues</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>aVariantMask</name> &amp; <name>VARIANT_CALC</name>) &amp;&amp;
      (<name>eCSSToken_Function</name> == <name><name>tk</name>-&gt;<name>mType</name></name>) &amp;&amp;
      (<call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-calc"</expr></argument>)</argument_list></call> ||
       <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-min"</expr></argument>)</argument_list></call> ||
       <call><name><name>tk</name>-&gt;<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-max"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
    <comment type="line">// calc() currently allows only lengths and percents inside it.</comment>
    <return>return <expr><call><name>ParseCalc</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>,
                     <argument><expr><name>aVariantMask</name> &amp; (<name>VARIANT_LP</name> | <name>VARIANT_CALC_NO_MIN_MAX</name>)</expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>


<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseCounter</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSUnit</name></type> <name>unit</name> <init>= <expr>(<call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"counter"</expr></argument>)</argument_list></call> ?
                    <name>eCSSUnit_Counter</name> : <name>eCSSUnit_Counters</name>)</expr></init></decl>;</decl_stmt>

  <comment type="line">// A non-iterative for loop to break out when an error occurs.</comment>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Ident</name> != <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>val</name> <init>=
      <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr><name>unit</name> == <name>eCSSUnit_Counter</name> ? 2 : 3</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>val</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>.<call><name>SetStringValue</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>eCSSUnit_Counters</name> == <name>unit</name></expr>)</condition><then> <block>{
      <comment type="line">// must have a comma and then a separator string</comment>
      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> || !<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr><name>eCSSToken_String</name> != <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call>.<call><name>SetStringValue</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>, <argument><expr><name>eCSSUnit_String</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// get optional type</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>type</name> <init>= <expr><name>NS_STYLE_LIST_STYLE_DECIMAL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <decl_stmt><decl><type><name>nsCSSKeyword</name></type> <name>keyword</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>eCSSToken_Ident</name> != <name><name>mToken</name>.<name>mType</name></name> ||
          (<name>keyword</name> = <call><name><name>nsCSSKeywords</name>::<name>LookupKeyword</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call>) ==
            <name>eCSSKeyword_UNKNOWN</name> ||
          !<call><name><name>nsCSSProps</name>::<name>FindKeyword</name></name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kListStyleKTable</name></name></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>typeItem</name> <init>= <expr><name>eCSSUnit_Counters</name> == <name>unit</name> ? 2 : 1</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>typeItem</name></expr></argument>)</argument_list></call>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></for>

  <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseAttr</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>attr</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{  <comment type="line">// attr name or namespace</comment>
    <function_decl><type><name>nsAutoString</name></type>  <name>holdIdent</name><parameter_list>(<param><decl><type><name><name>mToken</name>.<name>mIdent</name></name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>'|'</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// namespace</comment>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>nameSpaceID</name> <init>= <expr><call><name>GetNamespaceIdForPrefix</name><argument_list>(<argument><expr><name>holdIdent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>nameSpaceID</name> == <name>kNameSpaceID_Unknown</name></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>attr</name>.<name>AppendInt</name></name><argument_list>(<argument><expr><name>nameSpaceID</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>attr</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>PRUnichar</name><argument_list>(<argument><expr>'|'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAttributeNameEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>attr</name>.<name>Append</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttributeNameExpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></else></if>
    }</block></then>
    <else>else <block>{  <comment type="line">// no namespace</comment>
      <expr_stmt><expr><name>attr</name> = <name>holdIdent</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'*'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// namespace wildcard</comment>
    <comment type="line">// Wildcard namespace makes no sense here and is not allowed</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttributeNameExpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'|'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// explicit NO namespace</comment>
    <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_EOF</name><argument_list>(<argument><expr><name>PEAttributeNameEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>attr</name>.<name>Append</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttributeNameExpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></else></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEAttributeNameOrNamespaceExpected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></else></if></else></if></else></if>
  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>aValue</name>.<name>SetStringValue</name></name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>eCSSUnit_Attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>SetValueToURL</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aURL</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mSheetPrincipal</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"Codepaths that expect to parse URLs MUST pass in an "
                  "origin principal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Translate url into an absolute url if the url is relative to the</comment>
  <comment type="line">// style sheet.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>uri</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_NewURI</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aURL</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>mBaseURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsStringBuffer</name>*</type> <name>buffer</name> <init>= <expr><call><name><name>nsCSSValue</name>::<name>BufferFromString</name></name><argument_list>(<argument><expr><name>aURL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_UNLIKELY</name><argument_list>(<argument><expr>!<name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name><name>nsCSSValue</name>::<name>URL</name></name> *</type><name>urlVal</name> <init>=
    <expr>new <call><name><name>nsCSSValue</name>::<name>URL</name></name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>mSheetURI</name></expr></argument>, <argument><expr><name>mSheetPrincipal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>buffer</name>-&gt;<name>Release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_UNLIKELY</name><argument_list>(<argument><expr>!<name>urlVal</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>aValue</name>.<name>SetURLValue</name></name><argument_list>(<argument><expr><name>urlVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseURL</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>url</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>GetURLInParens</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <return>return <expr><call><name>SetValueToURL</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Parse the arguments of -moz-image-rect() function.
 * -moz-image-rect(&lt;uri&gt;, &lt;top&gt;, &lt;right&gt;, &lt;bottom&gt;, &lt;left&gt;)
 */</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseImageRect</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aImage</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// A non-iterative for loop to break out when an error occurs.</comment>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>newFunction</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PRUint32</name></type> <name>kNumArgs</name> <init>= <expr>5</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCSSValue</name>::<name>Array</name></name>*</type> <name>func</name> <init>=
      <expr><call><name><name>newFunction</name>.<name>InitFunction</name></name><argument_list>(<argument><expr><name>eCSSKeyword__moz_image_rect</name></expr></argument>, <argument><expr><name>kNumArgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>func</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>

    <comment type="line">// func-&gt;Item(0) is reserved for the function name.</comment>
    <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>url</name>    <init>= <expr><call><name><name>func</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>top</name>    <init>= <expr><call><name><name>func</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>right</name>  <init>= <expr><call><name><name>func</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>bottom</name> <init>= <expr><call><name><name>func</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>left</name>   <init>= <expr><call><name><name>func</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>
    <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_String</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>SetValueToURL</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></then> <else>else <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Function</name> &amp;&amp;
               <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"url"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>ParseURL</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></else></if></else></if>
    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PRInt32</name></type> <name>VARIANT_SIDE</name> <init>= <expr><name>VARIANT_NUMBER</name> | <name>VARIANT_PERCENT</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>VARIANT_SIDE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> ||
        !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> ||
        !<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>VARIANT_SIDE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> ||
        !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> ||
        !<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>bottom</name></expr></argument>, <argument><expr><name>VARIANT_SIDE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> ||
        !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> ||
        !<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>VARIANT_SIDE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> ||
        !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>

    <expr_stmt><expr><name>aImage</name> = <name>newFunction</name></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></for>

  <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// &lt;element&gt;: -moz-element(# &lt;element_id&gt; )</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseElement</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// A non-iterative for loop to break out when an error occurs.</comment>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>

    <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_ID</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aValue</name>.<name>SetStringValue</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></else></if>

    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>

    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></for>

  <comment type="line">// If we detect a syntax error, we must match the opening parenthesis of the</comment>
  <comment type="line">// function with the closing parenthesis and skip all the tokens in between.</comment>
  <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// &lt;color-stop&gt; : &lt;color&gt; [ &lt;percentage&gt; | &lt;length&gt; ]?</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseColorStop</name></name><parameter_list>(<param><decl><type><name>nsCSSValueGradient</name>*</type> <name>aGradient</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValueGradientStop</name>*</type> <name>stop</name> <init>= <expr><call><name><name>aGradient</name>-&gt;<name>mStops</name>.<name>AppendElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>stop</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>stop</name>-&gt;<name>mColor</name></name></expr></argument>, <argument><expr><name>VARIANT_COLOR</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Stop positions do not have to fall between the starting-point and</comment>
  <comment type="line">// ending-point, so we don't use ParseNonNegativeVariant.</comment>
  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>stop</name>-&gt;<name>mLocation</name></name></expr></argument>, <argument><expr><name>VARIANT_LP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>stop</name>-&gt;<name>mLocation</name>.<name>SetNoneValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// &lt;gradient&gt;</comment>
<comment type="line">//    : linear-gradient( &lt;gradient-line&gt;? &lt;color-stops&gt; ')'</comment>
<comment type="line">//    : radial-gradient( &lt;gradient-line&gt;? &lt;gradient-shape-size&gt;?</comment>
<comment type="line">//                       &lt;color-stops&gt; ')'</comment>
<comment type="line">//</comment>
<comment type="line">// &lt;gradient-line&gt; : [&lt;bg-position&gt; || &lt;angle&gt;] ,</comment>
<comment type="line">//</comment>
<comment type="line">// &lt;gradient-shape-size&gt; : [&lt;gradient-shape&gt; || &lt;gradient-size&gt;] ,</comment>
<comment type="line">// &lt;gradient-shape&gt; : circle | ellipse</comment>
<comment type="line">// &lt;gradient-size&gt; : closest-side | closest-corner</comment>
<comment type="line">//                 | farthest-side | farthest-corner</comment>
<comment type="line">//                 | contain | cover</comment>
<comment type="line">//</comment>
<comment type="line">// &lt;color-stops&gt; : &lt;color-stop&gt; , &lt;color-stop&gt; [, &lt;color-stop&gt;]*</comment>


<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseGradient</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsRadial</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type> <name>aIsRepeating</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCSSValueGradient</name></expr></argument>&gt;</argument_list></name></type> <name>cssGradient</name>
    <init>= <expr>new <call><name>nsCSSValueGradient</name><argument_list>(<argument><expr><name>aIsRadial</name></expr></argument>, <argument><expr><name>aIsRepeating</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// &lt;gradient-line&gt;</comment>
  <comment type="line">// N.B. ParseBoxPositionValues is not guaranteed to put back</comment>
  <comment type="line">// everything it scanned if it fails, so we must only call it</comment>
  <comment type="line">// if there is no alternative to consuming a &lt;box-position&gt;.</comment>
  <comment type="line">// ParseVariant, as used here, will either succeed and consume</comment>
  <comment type="line">// a single token, or fail and consume none, so we can be more</comment>
  <comment type="line">// cavalier about calling it.</comment>

  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsCSSTokenType</name></type> <name>ty</name> <init>= <expr><name><name>mToken</name>.<name>mType</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsString</name></type> <name>id</name> <init>= <expr><name><name>mToken</name>.<name>mIdent</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>haveGradientLine</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>ty</name></expr>)</condition> <block>{
  <case>case <expr><name>eCSSToken_Percentage</name></expr>:
  </case><case>case <expr><name>eCSSToken_Number</name></expr>:
  </case><case>case <expr><name>eCSSToken_Dimension</name></expr>:
    <expr_stmt><expr><name>haveGradientLine</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <break>break;</break>

  </case><case>case <expr><name>eCSSToken_Function</name></expr>:
  </case><case>case <expr><name>eCSSToken_ID</name></expr>:
  </case><case>case <expr><name>eCSSToken_Ref</name></expr>:
    <comment type="line">// this is a color</comment>
    <break>break;</break>

  </case><case>case <expr><name>eCSSToken_Ident</name></expr>: <block>{
    <comment type="line">// This is only a gradient line if it's a box position keyword.</comment>
    <decl_stmt><decl><type><name>nsCSSKeyword</name></type> <name>kw</name> <init>= <expr><call><name><name>nsCSSKeywords</name>::<name>LookupKeyword</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>junk</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>kw</name> != <name>eCSSKeyword_UNKNOWN</name> &amp;&amp;
        <call><name><name>nsCSSProps</name>::<name>FindKeyword</name></name><argument_list>(<argument><expr><name>kw</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundPositionKTable</name></name></expr></argument>,
                                <argument><expr><name>junk</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>haveGradientLine</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>
    <break>break;</break>
  }</block>

  </case><default>default:
    <comment type="line">// error</comment>
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </default>}</block></switch>

  <if>if <condition>(<expr><name>haveGradientLine</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>haveAngle</name> <init>=
      <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cssGradient</name>-&gt;<name>mAngle</name></name></expr></argument>, <argument><expr><name>VARIANT_ANGLE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// if we got an angle, we might now have a comma, ending the gradient-line</comment>
    <if>if <condition>(<expr>!<name>haveAngle</name> || !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>ParseBoxPositionValues</name><argument_list>(<argument><expr><name><name>cssGradient</name>-&gt;<name>mBgPos</name></name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>

      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> &amp;&amp;
          <comment type="line">// if we didn't already get an angle, we might have one now,</comment>
          <comment type="line">// otherwise it's an error</comment>
          (<name>haveAngle</name> ||
           !<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cssGradient</name>-&gt;<name>mAngle</name></name></expr></argument>, <argument><expr><name>VARIANT_ANGLE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> ||
           <comment type="line">// now we better have a comma</comment>
           !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// radial gradients might have a &lt;gradient-shape-size&gt; here</comment>
  <if>if <condition>(<expr><name>aIsRadial</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>haveShape</name> <init>=
      <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cssGradient</name>-&gt;<name>mRadialShape</name></name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                   <argument><expr><name><name>nsCSSProps</name>::<name>kRadialGradientShapeKTable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>haveSize</name> <init>=
      <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cssGradient</name>-&gt;<name>mRadialSize</name></name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                   <argument><expr><name><name>nsCSSProps</name>::<name>kRadialGradientSizeKTable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// could be in either order</comment>
    <if>if <condition>(<expr>!<name>haveShape</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>haveShape</name> =
        <call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cssGradient</name>-&gt;<name>mRadialShape</name></name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                     <argument><expr><name><name>nsCSSProps</name>::<name>kRadialGradientShapeKTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>haveShape</name> || <name>haveSize</name>) &amp;&amp; !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// At least two color stops are required</comment>
  <if>if <condition>(<expr>!<call><name>ParseColorStop</name><argument_list>(<argument><expr><name>cssGradient</name></expr></argument>)</argument_list></call> ||
      !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> ||
      !<call><name>ParseColorStop</name><argument_list>(<argument><expr><name>cssGradient</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Additional color stops</comment>
  <while>while <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
    <if>if <condition>(<expr>!<call><name>ParseColorStop</name><argument_list>(<argument><expr><name>cssGradient</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></while>

  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>aValue</name>.<name>SetGradientValue</name></name><argument_list>(<argument><expr><name>cssGradient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>CSSParserImpl</name>::<name>ParseChoice</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name></type> <name><name>aValues</name><index>[]</index></name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>aPropIDs</name><index>[]</index></name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aNumIDs</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>found</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <function_decl><type><name>nsAutoParseCompoundProperty</name></type> <name>compound</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>loop</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>loop</name> = 0</expr>;</init> <condition><expr><name>loop</name> &lt; <name>aNumIDs</name></expr>;</condition> <incr><expr><name>loop</name>++</expr></incr>) <block>{
    <comment type="line">// Try each property parser in order</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>hadFound</name> <init>= <expr><name>found</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>index</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name>index</name> &lt; <name>aNumIDs</name></expr>;</condition> <incr><expr><name>index</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>bit</name> <init>= <expr>1 &lt;&lt; <name>index</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>(<name>found</name> &amp; <name>bit</name>) == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name><name>aValues</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>aPropIDs</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>found</name> |= <name>bit</name></expr>;</expr_stmt>
          <comment type="line">// It's more efficient to break since it will reset |hadFound|</comment>
          <comment type="line">// to |found|.  Furthermore, ParseListStyle depends on our going</comment>
          <comment type="line">// through the properties in order for each value..</comment>
          <break>break;</break>
        }</block></then></if>
      }</block></then></if>
    }</block></for>
    <if>if <condition>(<expr><name>found</name> == <name>hadFound</name></expr>)</condition><then> <block>{  <comment type="line">// found nothing new</comment>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
  <if>if <condition>(<expr>0 &lt; <name>found</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>1 == <name>found</name></expr>)</condition><then> <block>{ <comment type="line">// only first property</comment>
      <if>if <condition>(<expr><name>eCSSUnit_Inherit</name> == <name><name>aValues</name><index>[<expr>0</expr>]</index></name>.<call><name>GetUnit</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// one inherit, all inherit</comment>
        <for>for (<init><expr><name>loop</name> = 1</expr>;</init> <condition><expr><name>loop</name> &lt; <name>aNumIDs</name></expr>;</condition> <incr><expr><name>loop</name>++</expr></incr>) <block>{
          <expr_stmt><expr><name><name>aValues</name><index>[<expr><name>loop</name></expr>]</index></name>.<call><name>SetInheritValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>found</name> = ((1 &lt;&lt; <name>aNumIDs</name>) - 1)</expr>;</expr_stmt>
      }</block></then>
      <else>else <if>if <condition>(<expr><name>eCSSUnit_Initial</name> == <name><name>aValues</name><index>[<expr>0</expr>]</index></name>.<call><name>GetUnit</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// one initial, all initial</comment>
        <for>for (<init><expr><name>loop</name> = 1</expr>;</init> <condition><expr><name>loop</name> &lt; <name>aNumIDs</name></expr>;</condition> <incr><expr><name>loop</name>++</expr></incr>) <block>{
          <expr_stmt><expr><name><name>aValues</name><index>[<expr><name>loop</name></expr>]</index></name>.<call><name>SetInitialValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>found</name> = ((1 &lt;&lt; <name>aNumIDs</name>) - 1)</expr>;</expr_stmt>
      }</block></then></if></else></if>
    }</block></then>
    <else>else <block>{  <comment type="line">// more than one value, verify no inherits or initials</comment>
      <for>for (<init><expr><name>loop</name> = 0</expr>;</init> <condition><expr><name>loop</name> &lt; <name>aNumIDs</name></expr>;</condition> <incr><expr><name>loop</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name>eCSSUnit_Inherit</name> == <name><name>aValues</name><index>[<expr><name>loop</name></expr>]</index></name>.<call><name>GetUnit</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>found</name> = -1</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>eCSSUnit_Initial</name> == <name><name>aValues</name><index>[<expr><name>loop</name></expr>]</index></name>.<call><name>GetUnit</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>found</name> = -1</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if></else></if>
      }</block></for>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>found</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>AppendValue</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mTempData</name>.<name>AddLonghandProperty</name></name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block" format="doxygen">/**
 * Parse a "box" property. Box properties have 1 to 4 values. When less
 * than 4 values are provided a standard mapping is used to replicate
 * existing values.
 */</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBoxProperties</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>aPropIDs</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Get up to four values for the property</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSRect</name></type> <name>result</name></decl>;</decl_stmt>
  <macro><name>NS_FOR_CSS_SIDES</name> <argument_list>(<argument>index</argument>)</argument_list></macro> <block>{
    <if>if <condition>(<expr>! <call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name><name>result</name>.*</name>(<name><name>nsCSSRect</name>::<name>sides</name><index>[<expr><name>index</name></expr>]</index></name>)</expr></argument>,
                                   <argument><expr><name><name>aPropIDs</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
  }</block>
  <if>if <condition>(<expr>(<name>count</name> == 0) || (<name>PR_FALSE</name> == <call><name>ExpectEndProperty</name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>1 &lt; <name>count</name></expr>)</condition><then> <block>{ <comment type="line">// verify no more than single inherit or initial</comment>
    <macro><name>NS_FOR_CSS_SIDES</name> <argument_list>(<argument>index</argument>)</argument_list></macro> <block>{
      <decl_stmt><decl><type><name>nsCSSUnit</name></type> <name>unit</name> <init>= <expr>(<name><name>result</name>.*</name>(<name><name>nsCSSRect</name>::<name>sides</name><index>[<expr><name>index</name></expr>]</index></name>)).<call><name>GetUnit</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>eCSSUnit_Inherit</name> == <name>unit</name> || <name>eCSSUnit_Initial</name> == <name>unit</name></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block>
  }</block></then></if>

  <comment type="line">// Provide missing values by replicating some of the values found</comment>
  <switch>switch <condition>(<expr><name>count</name></expr>)</condition> <block>{
    <case>case <expr>1</expr>: <comment type="line">// Make right == top</comment>
      <expr_stmt><expr><name><name>result</name>.<name>mRight</name></name> = <name><name>result</name>.<name>mTop</name></name></expr>;</expr_stmt>
    </case><case>case <expr>2</expr>: <comment type="line">// Make bottom == top</comment>
      <expr_stmt><expr><name><name>result</name>.<name>mBottom</name></name> = <name><name>result</name>.<name>mTop</name></name></expr>;</expr_stmt>
    </case><case>case <expr>3</expr>: <comment type="line">// Make left == right</comment>
      <expr_stmt><expr><name><name>result</name>.<name>mLeft</name></name> = <name><name>result</name>.<name>mRight</name></name></expr>;</expr_stmt>
  </case>}</block></switch>

  <macro><name>NS_FOR_CSS_SIDES</name> <argument_list>(<argument>index</argument>)</argument_list></macro> <block>{
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>aPropIDs</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>result</name>.*</name>(<name><name>nsCSSRect</name>::<name>sides</name><index>[<expr><name>index</name></expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseDirectionalBoxProperty</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aProperty</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name></type> <name>aSourceType</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsCSSProperty</name>*</type> <name>subprops</name> <init>= <expr><call><name><name>nsCSSProps</name>::<name>SubpropertyEntryFor</name></name><argument_list>(<argument><expr><name>aProperty</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>subprops</name><index>[<expr>3</expr>]</index></name> == <name>eCSSProperty_UNKNOWN</name></expr></argument>,
               <argument><expr>"not box property with physical vs. logical cascading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>subprops</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> ||
      !<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>subprops</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <function_decl><type><name>nsCSSValue</name></type> <name>typeVal</name><parameter_list>(<param><decl><type><name>aSourceType</name></type></decl></param>, <param><decl><type><name>eCSSUnit_Enumerated</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>subprops</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>typeVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>subprops</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name>typeVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBoxCornerRadius</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>dimenX</name></decl>, <decl><type ref="prev"/><name>dimenY</name></decl>;</decl_stmt>
  <comment type="line">// required first value</comment>
  <if>if <condition>(<expr>! <call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>dimenX</name></expr></argument>, <argument><expr><name>VARIANT_HLP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <comment type="line">// optional second value (forbidden if first value is inherit/initial)</comment>
  <if>if <condition>(<expr><call><name><name>dimenX</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_Inherit</name> &amp;&amp;
      <call><name><name>dimenX</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_Initial</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>dimenY</name></expr></argument>, <argument><expr><name>VARIANT_LP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>dimenX</name> == <name>dimenY</name> || <call><name><name>dimenY</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Null</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>dimenX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>value</name>.<name>SetPairValue</name></name><argument_list>(<argument><expr><name>dimenX</name></expr></argument>, <argument><expr><name>dimenY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBoxCornerRadii</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>aPropIDs</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Rectangles are used as scratch storage.</comment>
  <comment type="line">// top =&gt; top-left, right =&gt; top-right,</comment>
  <comment type="line">// bottom =&gt; bottom-right, left =&gt; bottom-left.</comment>
  <decl_stmt><decl><type><name>nsCSSRect</name></type> <name>dimenX</name></decl>, <decl><type ref="prev"/><name>dimenY</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>countX</name> <init>= <expr>0</expr></init>, <name>countY</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <macro><name>NS_FOR_CSS_SIDES</name> <argument_list>(<argument>side</argument>)</argument_list></macro> <block>{
    <if>if <condition>(<expr>! <call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name><name>dimenX</name>.*<name>nsCSSRect</name>::<name>sides</name><index>[<expr><name>side</name></expr>]</index></name></expr></argument>,
                                  <argument><expr><name>side</name> &gt; 0 ? <name>VARIANT_LP</name> : <name>VARIANT_HLP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>
    <expr_stmt><expr><name>countX</name>++</expr>;</expr_stmt>
  }</block>
  <if>if <condition>(<expr><name>countX</name> == 0</expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>'/'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <macro><name>NS_FOR_CSS_SIDES</name> <argument_list>(<argument>side</argument>)</argument_list></macro> <block>{
      <if>if <condition>(<expr>! <call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name><name>dimenY</name>.*<name>nsCSSRect</name>::<name>sides</name><index>[<expr><name>side</name></expr>]</index></name></expr></argument>,
                                    <argument><expr><name>VARIANT_LP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then></if>
      <expr_stmt><expr><name>countY</name>++</expr>;</expr_stmt>
    }</block>
    <if>if <condition>(<expr><name>countY</name> == 0</expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <comment type="line">// if 'initial' or 'inherit' was used, it must be the only value</comment>
  <if>if <condition>(<expr><name>countX</name> &gt; 1 || <name>countY</name> &gt; 0</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsCSSUnit</name></type> <name>unit</name> <init>= <expr><call><name><name>dimenX</name>.<name>mTop</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>eCSSUnit_Inherit</name> == <name>unit</name> || <name>eCSSUnit_Initial</name> == <name>unit</name></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  }</block></then></if>

  <comment type="line">// if we have no Y-values, use the X-values</comment>
  <if>if <condition>(<expr><name>countY</name> == 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>dimenY</name> = <name>dimenX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>countY</name> = <name>countX</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Provide missing values by replicating some of the values found</comment>
  <switch>switch <condition>(<expr><name>countX</name></expr>)</condition> <block>{
    <case>case <expr>1</expr>: <expr_stmt><expr><name><name>dimenX</name>.<name>mRight</name></name> = <name><name>dimenX</name>.<name>mTop</name></name></expr>;</expr_stmt>  <comment type="line">// top-right same as top-left, and</comment>
    </case><case>case <expr>2</expr>: <expr_stmt><expr><name><name>dimenX</name>.<name>mBottom</name></name> = <name><name>dimenX</name>.<name>mTop</name></name></expr>;</expr_stmt> <comment type="line">// bottom-right same as top-left, and </comment>
    </case><case>case <expr>3</expr>: <expr_stmt><expr><name><name>dimenX</name>.<name>mLeft</name></name> = <name><name>dimenX</name>.<name>mRight</name></name></expr>;</expr_stmt> <comment type="line">// bottom-left same as top-right</comment>
  </case>}</block></switch>

  <switch>switch <condition>(<expr><name>countY</name></expr>)</condition> <block>{
    <case>case <expr>1</expr>: <expr_stmt><expr><name><name>dimenY</name>.<name>mRight</name></name> = <name><name>dimenY</name>.<name>mTop</name></name></expr>;</expr_stmt>  <comment type="line">// top-right same as top-left, and</comment>
    </case><case>case <expr>2</expr>: <expr_stmt><expr><name><name>dimenY</name>.<name>mBottom</name></name> = <name><name>dimenY</name>.<name>mTop</name></name></expr>;</expr_stmt> <comment type="line">// bottom-right same as top-left, and </comment>
    </case><case>case <expr>3</expr>: <expr_stmt><expr><name><name>dimenY</name>.<name>mLeft</name></name> = <name><name>dimenY</name>.<name>mRight</name></name></expr>;</expr_stmt> <comment type="line">// bottom-left same as top-right</comment>
  </case>}</block></switch>

  <macro><name>NS_FOR_CSS_SIDES</name><argument_list>(<argument>side</argument>)</argument_list></macro> <block>{
    <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>x</name> <init>= <expr><name><name>dimenX</name>.*<name>nsCSSRect</name>::<name>sides</name><index>[<expr><name>side</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>y</name> <init>= <expr><name><name>dimenY</name>.*<name>nsCSSRect</name>::<name>sides</name><index>[<expr><name>side</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>x</name> == <name>y</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>aPropIDs</name><index>[<expr><name>side</name></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>pair</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>pair</name>.<name>SetPairValue</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>aPropIDs</name><index>[<expr><name>side</name></expr>]</index></name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// These must be in CSS order (top,right,bottom,left) for indexing to work</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderStyleIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty_border_top_style</name></expr>,
  <expr><name>eCSSProperty_border_right_style_value</name></expr>,
  <expr><name>eCSSProperty_border_bottom_style</name></expr>,
  <expr><name>eCSSProperty_border_left_style_value</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderWidthIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty_border_top_width</name></expr>,
  <expr><name>eCSSProperty_border_right_width_value</name></expr>,
  <expr><name>eCSSProperty_border_bottom_width</name></expr>,
  <expr><name>eCSSProperty_border_left_width_value</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderColorIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty_border_top_color</name></expr>,
  <expr><name>eCSSProperty_border_right_color_value</name></expr>,
  <expr><name>eCSSProperty_border_bottom_color</name></expr>,
  <expr><name>eCSSProperty_border_left_color_value</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderRadiusIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty__moz_border_radius_topLeft</name></expr>,
  <expr><name>eCSSProperty__moz_border_radius_topRight</name></expr>,
  <expr><name>eCSSProperty__moz_border_radius_bottomRight</name></expr>,
  <expr><name>eCSSProperty__moz_border_radius_bottomLeft</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kOutlineRadiusIDs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>eCSSProperty__moz_outline_radius_topLeft</name></expr>,
  <expr><name>eCSSProperty__moz_outline_radius_topRight</name></expr>,
  <expr><name>eCSSProperty__moz_outline_radius_bottomRight</name></expr>,
  <expr><name>eCSSProperty__moz_outline_radius_bottomLeft</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseProperty</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aPropID</name> &lt; <name>eCSSProperty_COUNT</name></expr></argument>, <argument><expr>"index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>aPropID</name></expr>)</condition> <block>{  <comment type="line">// handle shorthand or multiple properties</comment>
  <case>case <expr><name>eCSSProperty_background</name></expr>:
    <return>return <expr><call><name>ParseBackground</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_background_position</name></expr>:
    <return>return <expr><call><name>ParseBackgroundPosition</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_background_attachment</name></expr>:
  </case><case>case <expr><name>eCSSProperty_background_clip</name></expr>:
  </case><case>case <expr><name>eCSSProperty_background_image</name></expr>:
  </case><case>case <expr><name>eCSSProperty_background_origin</name></expr>:
  </case><case>case <expr><name>eCSSProperty_background_repeat</name></expr>:
    <return>return <expr><call><name>ParseBackgroundList</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_background_size</name></expr>:
    <return>return <expr><call><name>ParseBackgroundSize</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border</name></expr>:
    <return>return <expr><call><name>ParseBorderSide</name><argument_list>(<argument><expr><name>kBorderTopIDs</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_color</name></expr>:
    <return>return <expr><call><name>ParseBorderColor</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_spacing</name></expr>:
    <return>return <expr><call><name>ParseBorderSpacing</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_style</name></expr>:
    <return>return <expr><call><name>ParseBorderStyle</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_bottom</name></expr>:
    <return>return <expr><call><name>ParseBorderSide</name><argument_list>(<argument><expr><name>kBorderBottomIDs</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_end</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBorderSide</name><argument_list>(<argument><expr><name>kBorderEndIDs</name></expr></argument>,
                                      <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_left</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBorderSide</name><argument_list>(<argument><expr><name>kBorderLeftIDs</name></expr></argument>,
                                      <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_right</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBorderSide</name><argument_list>(<argument><expr><name>kBorderRightIDs</name></expr></argument>,
                                      <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_start</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBorderSide</name><argument_list>(<argument><expr><name>kBorderStartIDs</name></expr></argument>,
                                      <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_top</name></expr>:
    <return>return <expr><call><name>ParseBorderSide</name><argument_list>(<argument><expr><name>kBorderTopIDs</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_bottom_colors</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_colors</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_colors</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_top_colors</name></expr>:
    <return>return <expr><call><name>ParseBorderColors</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_image</name></expr>:
    <return>return <expr><call><name>ParseBorderImage</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_width</name></expr>:
    <return>return <expr><call><name>ParseBorderWidth</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_end_color</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_end_color</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_left_color</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_left_color</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_right_color</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_right_color</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_start_color</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_start_color</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_end_width</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_end_width</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_left_width</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_left_width</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_right_width</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_right_width</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_start_width</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_start_width</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_end_style</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_end_style</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_left_style</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_left_style</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_right_style</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_right_style</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_start_style</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_border_start_style</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_border_radius</name></expr>:
    <return>return <expr><call><name>ParseBoxCornerRadii</name><argument_list>(<argument><expr><name>kBorderRadiusIDs</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_outline_radius</name></expr>:
    <return>return <expr><call><name>ParseBoxCornerRadii</name><argument_list>(<argument><expr><name>kOutlineRadiusIDs</name></expr></argument>)</argument_list></call></expr>;</return>

  </case><case>case <expr><name>eCSSProperty__moz_border_radius_topLeft</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_border_radius_topRight</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_border_radius_bottomRight</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_border_radius_bottomLeft</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_outline_radius_topLeft</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_outline_radius_topRight</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_outline_radius_bottomRight</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_outline_radius_bottomLeft</name></expr>:
    <return>return <expr><call><name>ParseBoxCornerRadius</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr>;</return>

  </case><case>case <expr><name>eCSSProperty_box_shadow</name></expr>:
  </case><case>case <expr><name>eCSSProperty_text_shadow</name></expr>:
    <return>return <expr><call><name>ParseShadowList</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr>;</return>

  </case><case>case <expr><name>eCSSProperty_clip</name></expr>:
    <return>return <expr><call><name>ParseRect</name><argument_list>(<argument><expr><name>eCSSProperty_clip</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_column_rule</name></expr>:
    <return>return <expr><call><name>ParseBorderSide</name><argument_list>(<argument><expr><name>kColumnRuleIDs</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_content</name></expr>:
    <return>return <expr><call><name>ParseContent</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_counter_increment</name></expr>:
  </case><case>case <expr><name>eCSSProperty_counter_reset</name></expr>:
    <return>return <expr><call><name>ParseCounterData</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_cue</name></expr>:
    <return>return <expr><call><name>ParseCue</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_cursor</name></expr>:
    <return>return <expr><call><name>ParseCursor</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_font</name></expr>:
    <return>return <expr><call><name>ParseFont</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_image_region</name></expr>:
    <return>return <expr><call><name>ParseRect</name><argument_list>(<argument><expr><name>eCSSProperty_image_region</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_list_style</name></expr>:
    <return>return <expr><call><name>ParseListStyle</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_margin</name></expr>:
    <return>return <expr><call><name>ParseMargin</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_margin_end</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_margin_end</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_margin_left</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_margin_left</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_margin_right</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_margin_right</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_margin_start</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_margin_start</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_outline</name></expr>:
    <return>return <expr><call><name>ParseOutline</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_overflow</name></expr>:
    <return>return <expr><call><name>ParseOverflow</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_padding</name></expr>:
    <return>return <expr><call><name>ParsePadding</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_padding_end</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_padding_end</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_padding_left</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_padding_left</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_padding_right</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_padding_right</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_PHYSICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_padding_start</name></expr>:
    <return>return <expr><call><name>ParseDirectionalBoxProperty</name><argument_list>(<argument><expr><name>eCSSProperty_padding_start</name></expr></argument>,
                                       <argument><expr><name>NS_BOXPROP_SOURCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_pause</name></expr>:
    <return>return <expr><call><name>ParsePause</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_quotes</name></expr>:
    <return>return <expr><call><name>ParseQuotes</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_size</name></expr>:
    <return>return <expr><call><name>ParseSize</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_transform</name></expr>:
    <return>return <expr><call><name>ParseMozTransform</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_transform_origin</name></expr>:
    <return>return <expr><call><name>ParseMozTransformOrigin</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_transition</name></expr>:
      <return>return <expr><call><name>ParseTransition</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_transition_property</name></expr>:
    <return>return <expr><call><name>ParseTransitionProperty</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_transition_timing_function</name></expr>:
    <return>return <expr><call><name>ParseTransitionTimingFunction</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_transition_duration</name></expr>:
  </case><case>case <expr><name>eCSSProperty_transition_delay</name></expr>:
    <return>return <expr><call><name>ParseTransitionTime</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
  </case><case>case <expr><name>eCSSProperty_fill</name></expr>:
  </case><case>case <expr><name>eCSSProperty_stroke</name></expr>:
    <return>return <expr><call><name>ParsePaint</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stroke_dasharray</name></expr>:
    <return>return <expr><call><name>ParseDasharray</name><argument_list>()</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_marker</name></expr>:
    <return>return <expr><call><name>ParseMarker</name><argument_list>()</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Strip out properties we use internally.</comment>
  </case><case>case <expr><name>eCSSProperty__x_system_font</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_end_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_left_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_right_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_start_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_left_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_left_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_right_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_right_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_end_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_left_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_right_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_start_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_left_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_left_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_right_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_right_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_end_color_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_color_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_color_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_start_color_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_color_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_color_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_color_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_color_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_end_style_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_style_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_style_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_start_style_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_style_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_style_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_style_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_style_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_end_width_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_width_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_width_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_start_width_value</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_width_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_width_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_width_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_width_rtl_source</name></expr>:
    <comment type="line">// The user can't use these</comment>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED</name><argument_list>(<argument><expr><name>PEInaccessibleProperty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </case><default>default:  <comment type="line">// must be single property</comment>
    <block>{
      <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
        <comment type="line">// XXX Report errors?</comment>
      }</block></then></if>
      <comment type="line">// XXX Report errors?</comment>
    }</block>
  </default>}</block></switch>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// Bits used in determining which background position info we have</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BG_CENTER</name></cpp:macro>  <cpp:value>NS_STYLE_BG_POSITION_CENTER</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BG_TOP</name></cpp:macro>     <cpp:value>NS_STYLE_BG_POSITION_TOP</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BG_BOTTOM</name></cpp:macro>  <cpp:value>NS_STYLE_BG_POSITION_BOTTOM</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BG_LEFT</name></cpp:macro>    <cpp:value>NS_STYLE_BG_POSITION_LEFT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BG_RIGHT</name></cpp:macro>   <cpp:value>NS_STYLE_BG_POSITION_RIGHT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BG_CTB</name></cpp:macro>    <cpp:value>(BG_CENTER | BG_TOP | BG_BOTTOM)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BG_CLR</name></cpp:macro>    <cpp:value>(BG_CENTER | BG_LEFT | BG_RIGHT)</cpp:value></cpp:define>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseSingleValueProperty</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                        <param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>aPropID</name></expr>)</condition> <block>{
  <case>case <expr><name>eCSSProperty_UNKNOWN</name></expr>:
  </case><case>case <expr><name>eCSSProperty_background</name></expr>:
  </case><case>case <expr><name>eCSSProperty_background_position</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_color</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_bottom_colors</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_image</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_colors</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_colors</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_end_color</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_color</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_color</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_start_color</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_end_style</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_style</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_style</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_start_style</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_end_width</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_width</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_width</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_start_width</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_top_colors</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_spacing</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_style</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_bottom</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_end</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_start</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_top</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_width</name></expr>:
  </case><case>case <expr><name>eCSSProperty_background_size</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_border_radius</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_border_radius_topLeft</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_border_radius_topRight</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_border_radius_bottomRight</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_border_radius_bottomLeft</name></expr>:
  </case><case>case <expr><name>eCSSProperty_box_shadow</name></expr>:
  </case><case>case <expr><name>eCSSProperty_clip</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_column_rule</name></expr>:
  </case><case>case <expr><name>eCSSProperty_content</name></expr>:
  </case><case>case <expr><name>eCSSProperty_counter_increment</name></expr>:
  </case><case>case <expr><name>eCSSProperty_counter_reset</name></expr>:
  </case><case>case <expr><name>eCSSProperty_cue</name></expr>:
  </case><case>case <expr><name>eCSSProperty_cursor</name></expr>:
  </case><case>case <expr><name>eCSSProperty_font</name></expr>:
  </case><case>case <expr><name>eCSSProperty_image_region</name></expr>:
  </case><case>case <expr><name>eCSSProperty_list_style</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_end</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_left</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_right</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_start</name></expr>:
  </case><case>case <expr><name>eCSSProperty_outline</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_outline_radius</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_outline_radius_topLeft</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_outline_radius_topRight</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_outline_radius_bottomRight</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_outline_radius_bottomLeft</name></expr>:
  </case><case>case <expr><name>eCSSProperty_overflow</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_end</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_left</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_right</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_start</name></expr>:
  </case><case>case <expr><name>eCSSProperty_pause</name></expr>:
  </case><case>case <expr><name>eCSSProperty_quotes</name></expr>:
  </case><case>case <expr><name>eCSSProperty_size</name></expr>:
  </case><case>case <expr><name>eCSSProperty_text_shadow</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_transform</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_transform_origin</name></expr>:
  </case><case>case <expr><name>eCSSProperty_transition</name></expr>:
  </case><case>case <expr><name>eCSSProperty_transition_property</name></expr>:
  </case><case>case <expr><name>eCSSProperty_transition_timing_function</name></expr>:
  </case><case>case <expr><name>eCSSProperty_transition_duration</name></expr>:
  </case><case>case <expr><name>eCSSProperty_transition_delay</name></expr>:
  </case><case>case <expr><name>eCSSProperty_COUNT</name></expr>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
  </case><case>case <expr><name>eCSSProperty_fill</name></expr>:
  </case><case>case <expr><name>eCSSProperty_stroke</name></expr>:
  </case><case>case <expr><name>eCSSProperty_stroke_dasharray</name></expr>:
  </case><case>case <expr><name>eCSSProperty_marker</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </case><case>case <expr><name>eCSSPropertyExtra_no_properties</name></expr>:
  </case><case>case <expr><name>eCSSPropertyExtra_all_properties</name></expr>:
    <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"not a single value property"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>

  </case><case>case <expr><name>eCSSProperty__x_system_font</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_left_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_left_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_right_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_right_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_left_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_left_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_right_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_right_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_color_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_color_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_color_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_color_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_style_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_style_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_style_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_style_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_width_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_left_width_rtl_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_width_ltr_source</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_right_width_rtl_source</name></expr>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_MATHML</name></cpp:ifdef>
  </case><case>case <expr><name>eCSSProperty_script_size_multiplier</name></expr>:
  </case><case>case <expr><name>eCSSProperty_script_min_size</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"not currently parsed here"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>

  </case><case>case <expr><name>eCSSProperty_appearance</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kAppearanceKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_azimuth</name></expr>:
    <return>return <expr><call><name>ParseAzimuth</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_background_attachment</name></expr>:
    <comment type="line">// Used only internally.</comment>
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundAttachmentKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_background_clip</name></expr>:
    <comment type="line">// Used only internally.</comment>
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundOriginKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_background_color</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_background_image</name></expr>:
    <comment type="line">// Used only internally.</comment>
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_IMAGE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_background_inline_policy</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundInlinePolicyKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_background_origin</name></expr>:
    <comment type="line">// Used only internally.</comment>
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundOriginKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_background_repeat</name></expr>:
    <comment type="line">// Used only internally.</comment>
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundRepeatKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_binding</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HUO</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_collapse</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBorderCollapseKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_bottom_color</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_end_color_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_left_color_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_right_color_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_start_color_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_top_color</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_column_rule_color</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HCK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBorderColorKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_bottom_style</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_end_style_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_left_style_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_right_style_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_start_style_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_top_style</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_column_rule_style</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBorderStyleKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_border_bottom_width</name></expr>:
  </case><case>case <expr><name>eCSSProperty_border_end_width_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_left_width_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_right_width_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_start_width_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_border_top_width</name></expr>:
  </case><case>case <expr><name>eCSSProperty__moz_column_rule_width</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HKL</name> | <name>VARIANT_CALC</name></expr></argument>,
                                   <argument><expr><name><name>nsCSSProps</name>::<name>kBorderWidthKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_column_count</name></expr>:
    <comment type="line">// Need to reject 0 in addition to negatives.  If we accept 0, we</comment>
    <comment type="line">// need to change NS_STYLE_COLUMN_COUNT_AUTO to something else.</comment>
    <return>return <expr><call><name>ParsePositiveNonZeroVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_AHI</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_column_width</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_AHL</name> | <name>VARIANT_CALC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_column_gap</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HL</name> | <name>VARIANT_NORMAL</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_bottom</name></expr>:
  </case><case>case <expr><name>eCSSProperty_top</name></expr>:
  </case><case>case <expr><name>eCSSProperty_left</name></expr>:
  </case><case>case <expr><name>eCSSProperty_right</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_AHLP</name> | <name>VARIANT_CALC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_box_align</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBoxAlignKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_box_direction</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBoxDirectionKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_box_flex</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_box_orient</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBoxOrientKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_box_pack</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBoxPackKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_box_ordinal_group</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HI</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
  </case><case>case <expr><name>eCSSProperty_clip_path</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HUO</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_clip_rule</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kFillRuleKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_color_interpolation</name></expr>:
  </case><case>case <expr><name>eCSSProperty_color_interpolation_filters</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kColorInterpolationKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_dominant_baseline</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kDominantBaselineKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_fill_opacity</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name></expr></argument>,
                        <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_fill_rule</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kFillRuleKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_filter</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HUO</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_flood_color</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_flood_opacity</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_image_rendering</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kImageRenderingKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_lighting_color</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_marker_end</name></expr>:
  </case><case>case <expr><name>eCSSProperty_marker_mid</name></expr>:
  </case><case>case <expr><name>eCSSProperty_marker_start</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HUO</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_mask</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HUO</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_shape_rendering</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kShapeRenderingKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stop_color</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HC</name></expr></argument>,
                        <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stop_opacity</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name></expr></argument>,
                        <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stroke_dashoffset</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HLPN</name></expr></argument>,
                        <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stroke_linecap</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kStrokeLinecapKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stroke_linejoin</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kStrokeLinejoinKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stroke_miterlimit</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> &amp;&amp;
           <comment type="line">// Enforce the restriction that the value is greater than 1.</comment>
           (<call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_Number</name> || 
            <call><name><name>aValue</name>.<name>GetFloatValue</name></name><argument_list>()</argument_list></call> &gt;= 1.0f)</expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stroke_opacity</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name></expr></argument>,
                        <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stroke_width</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HLPN</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_text_anchor</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kTextAnchorKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_text_rendering</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kTextRenderingKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </case><case>case <expr><name>eCSSProperty_box_sizing</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBoxSizingKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_height</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_AHLP</name> | <name>VARIANT_CALC</name></expr></argument>,
                                   <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_width</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_AHKLP</name> | <name>VARIANT_CALC</name></expr></argument>,
                                   <argument><expr><name><name>nsCSSProps</name>::<name>kWidthKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_force_broken_image_icon</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HI</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_caption_side</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kCaptionSideKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_clear</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kClearKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_color</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_cue_after</name></expr>:
  </case><case>case <expr><name>eCSSProperty_cue_before</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HUO</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_direction</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kDirectionKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_display</name></expr>:
    <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kDisplayKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Enumerated</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
          <case>case <expr><name>NS_STYLE_DISPLAY_MARKER</name></expr>:        <comment type="line">// bug 2055</comment>
          </case><case>case <expr><name>NS_STYLE_DISPLAY_RUN_IN</name></expr>:        <comment type="line">// bug 2056</comment>
          </case><case>case <expr><name>NS_STYLE_DISPLAY_COMPACT</name></expr>:       <comment type="line">// bug 14983</comment>
            <return>return <expr><name>PR_FALSE</name></expr>;</return>
        </case>}</block></switch>
      }</block></then></if>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_elevation</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name> | <name>VARIANT_ANGLE</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kElevationKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_empty_cells</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kEmptyCellsKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_float</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kFloatKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_float_edge</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kFloatEdgeKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_font_family</name></expr>:
    <return>return <expr><call><name>ParseFamily</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_font_feature_settings</name></expr>:
  </case><case>case <expr><name>eCSSProperty_font_language_override</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_NORMAL</name> | <name>VARIANT_INHERIT</name> |
                                <name>VARIANT_STRING</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_font_size</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>,
                                   <argument><expr><name>VARIANT_HKLP</name> | <name>VARIANT_SYSFONT</name> |
                                     <name>VARIANT_CALC</name></expr></argument>,
                                   <argument><expr><name><name>nsCSSProps</name>::<name>kFontSizeKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_font_size_adjust</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HON</name> | <name>VARIANT_SYSFONT</name></expr></argument>,
                        <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_font_stretch</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name> | <name>VARIANT_SYSFONT</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kFontStretchKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_font_style</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name> | <name>VARIANT_SYSFONT</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kFontStyleKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_font_variant</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name> | <name>VARIANT_SYSFONT</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kFontVariantKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_font_weight</name></expr>:
    <return>return <expr><call><name>ParseFontWeight</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_ime_mode</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kIMEModeKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_tab_size</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HI</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_letter_spacing</name></expr>:
  </case><case>case <expr><name>eCSSProperty_word_spacing</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HL</name> | <name>VARIANT_NORMAL</name> | <name>VARIANT_CALC</name></expr></argument>,
                        <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_line_height</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HLPN</name> | <name>VARIANT_KEYWORD</name> | <name>VARIANT_NORMAL</name> | <name>VARIANT_SYSFONT</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kLineHeightKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_list_style_image</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HUO</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_list_style_position</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kListStylePositionKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_list_style_type</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kListStyleKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_margin_bottom</name></expr>:
  </case><case>case <expr><name>eCSSProperty_margin_end_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_margin_left_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_margin_right_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_margin_start_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_margin_top</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_AHLP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_marker_offset</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_AHL</name> | <name>VARIANT_CALC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_marks</name></expr>:
    <return>return <expr><call><name>ParseMarks</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_max_height</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HLPO</name> | <name>VARIANT_CALC</name></expr></argument>,
                                   <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_max_width</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HKLPO</name> | <name>VARIANT_CALC</name></expr></argument>,
                                   <argument><expr><name><name>nsCSSProps</name>::<name>kWidthKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_min_height</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HLP</name> | <name>VARIANT_CALC</name></expr></argument>,
                                   <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_min_width</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HKLP</name> | <name>VARIANT_CALC</name></expr></argument>,
                                   <argument><expr><name><name>nsCSSProps</name>::<name>kWidthKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_opacity</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_orphans</name></expr>:
  </case><case>case <expr><name>eCSSProperty_widows</name></expr>:
    <return>return <expr><call><name>ParsePositiveNonZeroVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HI</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_outline_color</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HCK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kOutlineColorKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_outline_style</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kOutlineStyleKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_outline_width</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HKL</name></expr></argument>,
                                   <argument><expr><name><name>nsCSSProps</name>::<name>kBorderWidthKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_outline_offset</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HL</name> | <name>VARIANT_CALC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_overflow_x</name></expr>:
  </case><case>case <expr><name>eCSSProperty_overflow_y</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kOverflowSubKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_padding_bottom</name></expr>:
  </case><case>case <expr><name>eCSSProperty_padding_end_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_padding_left_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_padding_right_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_padding_start_value</name></expr>: <comment type="line">// for internal use</comment>
  </case><case>case <expr><name>eCSSProperty_padding_top</name></expr>:
    <return>return <expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HLP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_page</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_AUTO</name> | <name>VARIANT_IDENTIFIER</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_page_break_after</name></expr>:
  </case><case>case <expr><name>eCSSProperty_page_break_before</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kPageBreakKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_page_break_inside</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kPageBreakInsideKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_pause_after</name></expr>:
  </case><case>case <expr><name>eCSSProperty_pause_before</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HTP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_pitch</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HKF</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kPitchKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_pitch_range</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_pointer_events</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kPointerEventsKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_position</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kPositionKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_resize</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kResizeKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_richness</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_MATHML</name></cpp:ifdef>
  <comment type="line">// script-level can take Integer or Number values, but only Integer ("relative")</comment>
  <comment type="line">// values can be specified in a style sheet. Also we only allow this property</comment>
  <comment type="line">// when unsafe rules are enabled, because otherwise it could interfere</comment>
  <comment type="line">// with rulenode optimizations if used in a non-MathML-enabled document.</comment>
  </case><case>case <expr><name>eCSSProperty_script_level</name></expr>:
    <if>if <condition>(<expr>!<name>mUnsafeRulesEnabled</name></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HI</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </case><case>case <expr><name>eCSSProperty_speak</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kSpeakKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_speak_header</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kSpeakHeaderKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_speak_numeral</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kSpeakNumeralKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_speak_punctuation</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kSpeakPunctuationKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_speech_rate</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name> | <name>VARIANT_KEYWORD</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kSpeechRateKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stack_sizing</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kStackSizingKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_stress</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HN</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_table_layout</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kTableLayoutKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_text_align</name></expr>:
    <comment type="line">// When we support aligning on a string, we can parse text-align</comment>
    <comment type="line">// as a string....</comment>
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument> <comment type="block">/* | VARIANT_STRING */</comment>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kTextAlignKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_text_decoration</name></expr>:
    <return>return <expr><call><name>ParseTextDecoration</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_text_indent</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HLP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_text_transform</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kTextTransformKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_unicode_bidi</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kUnicodeBidiKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_user_focus</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kUserFocusKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_user_input</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kUserInputKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_user_modify</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kUserModifyKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_user_select</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kUserSelectKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_vertical_align</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HKLP</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kVerticalAlignKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_visibility</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kVisibilityKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_voice_family</name></expr>:
    <return>return <expr><call><name>ParseFamily</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_volume</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HPN</name> | <name>VARIANT_KEYWORD</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kVolumeKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_white_space</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kWhitespaceKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty__moz_window_shadow</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kWindowShadowKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_word_wrap</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kWordwrapKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSProperty_z_index</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_AHI</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>eCSSPropertyExtra_x_none_value</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_NONE</name> | <name>VARIANT_INHERIT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
  </case>}</block></switch>
  <comment type="line">// explicitly do NOT have a default case to let the compiler</comment>
  <comment type="line">// help find missing properties</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// nsFont::EnumerateFamilies callback for ParseFontDescriptorValue</comment>
<struct>struct <macro><name>NS_STACK_CLASS</name></macro> <name>ExtractFirstFamilyData</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>mFamilyName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>mGood</name></decl>;</decl_stmt>
  <constructor><name>ExtractFirstFamilyData</name><parameter_list>()</parameter_list> <member_list>: <call><name>mFamilyName</name><argument_list>()</argument_list></call>, <call><name>mGood</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>ExtractFirstFamily</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aFamily</name></decl></param>,
                   <param><decl><type><name>PRBool</name></type> <name>aGeneric</name></decl></param>,
                   <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>ExtractFirstFamilyData</name>*</type> <name>realData</name> <init>= <expr>(<name>ExtractFirstFamilyData</name>*) <name>aData</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aGeneric</name> || <call><name><name>realData</name>-&gt;<name>mFamilyName</name>.<name>Length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>realData</name>-&gt;<name>mGood</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>realData</name>-&gt;<name>mFamilyName</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>aFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>realData</name>-&gt;<name>mGood</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// font-descriptor: descriptor ':' value ';'</comment>
<comment type="line">// caller has advanced mToken to point at the descriptor</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFontDescriptorValue</name></name><parameter_list>(<param><decl><type><name>nsCSSFontDesc</name></type> <name>aDescID</name></decl></param>,
                                        <param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>aDescID</name></expr>)</condition> <block>{
    <comment type="line">// These four are similar to the properties of the same name,</comment>
    <comment type="line">// possibly with more restrictions on the values they can take.</comment>
  <case>case <expr><name>eCSSFontDesc_Family</name></expr>: <block>{
    <if>if <condition>(<expr>!<call><name>ParseFamily</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call> ||
        <call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_Families</name></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <comment type="line">// the style parameters to the nsFont constructor are ignored,</comment>
    <comment type="line">// because it's only being used to call EnumerateFamilies</comment>
    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>valueStr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aValue</name>.<name>GetStringValue</name></name><argument_list>(<argument><expr><name>valueStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsFont</name></type> <name>font</name><argument_list>(<argument><expr><name>valueStr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExtractFirstFamilyData</name></type> <name>dat</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>font</name>.<name>EnumerateFamilies</name></name><argument_list>(<argument><expr><name>ExtractFirstFamily</name></expr></argument>, <argument><expr>(<name>void</name>*) &amp;<name>dat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>dat</name>.<name>mGood</name></name></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetStringValue</name></name><argument_list>(<argument><expr><name><name>dat</name>.<name>mFamilyName</name></name></expr></argument>, <argument><expr><name>eCSSUnit_String</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block>

  </case><case>case <expr><name>eCSSFontDesc_Style</name></expr>:
    <comment type="line">// property is VARIANT_HMK|VARIANT_SYSFONT</comment>
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name> | <name>VARIANT_NORMAL</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kFontStyleKTable</name></name></expr></argument>)</argument_list></call></expr>;</return>

  </case><case>case <expr><name>eCSSFontDesc_Weight</name></expr>:
    <return>return <expr>(<call><name>ParseFontWeight</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call> &amp;&amp;
            <call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_Inherit</name> &amp;&amp;
            <call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_Initial</name> &amp;&amp;
            (<call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_Enumerated</name> ||
             (<call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call> != <name>NS_STYLE_FONT_WEIGHT_BOLDER</name> &amp;&amp;
              <call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call> != <name>NS_STYLE_FONT_WEIGHT_LIGHTER</name>)))</expr>;</return>

  </case><case>case <expr><name>eCSSFontDesc_Stretch</name></expr>:
    <comment type="line">// property is VARIANT_HK|VARIANT_SYSFONT</comment>
    <return>return <expr>(<call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                         <argument><expr><name><name>nsCSSProps</name>::<name>kFontStretchKTable</name></name></expr></argument>)</argument_list></call> &amp;&amp;
            (<call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call> != <name>NS_STYLE_FONT_STRETCH_WIDER</name> &amp;&amp;
             <call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call> != <name>NS_STYLE_FONT_STRETCH_NARROWER</name>))</expr>;</return>

    <comment type="line">// These two are unique to @font-face and have their own special grammar.</comment>
  </case><case>case <expr><name>eCSSFontDesc_Src</name></expr>:
    <return>return <expr><call><name>ParseFontSrc</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>

  </case><case>case <expr><name>eCSSFontDesc_UnicodeRange</name></expr>:
    <return>return <expr><call><name>ParseFontRanges</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>

  </case><case>case <expr><name>eCSSFontDesc_FontFeatureSettings</name></expr>:
  </case><case>case <expr><name>eCSSFontDesc_FontLanguageOverride</name></expr>:
    <return>return <expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_NORMAL</name> | <name>VARIANT_STRING</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>

  </case><case>case <expr><name>eCSSFontDesc_UNKNOWN</name></expr>:
  </case><case>case <expr><name>eCSSFontDesc_COUNT</name></expr>:
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"bad nsCSSFontDesc code"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </case>}</block></switch>
  <comment type="line">// explicitly do NOT have a default case to let the compiler</comment>
  <comment type="line">// help find missing descriptors</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>InitBoxPropsAsPhysical</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name> *</type><name>aSourceProperties</name></decl></param>)</parameter_list>
<block>{
  <function_decl><type><name>nsCSSValue</name></type> <name>physical</name><parameter_list>(<param><decl><type><name>NS_BOXPROP_SOURCE_PHYSICAL</name></type></decl></param>, <param><decl><type><name>eCSSUnit_Enumerated</name></type></decl></param>)</parameter_list>;</function_decl>
  <for>for (<init><decl><type><specifier>const</specifier> <name>nsCSSProperty</name> *</type><name>prop</name> <init>= <expr><name>aSourceProperties</name></expr></init></decl>;</init>
       <condition><expr>*<name>prop</name> != <name>eCSSProperty_UNKNOWN</name></expr>;</condition> <incr><expr>++<name>prop</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr>*<name>prop</name></expr></argument>, <argument><expr><name>physical</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseAzimuth</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name> | <name>VARIANT_ANGLE</name></expr></argument>,
                   <argument><expr><name><name>nsCSSProps</name>::<name>kAzimuthKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>eCSSUnit_Enumerated</name> == <call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>intValue</name> <init>= <expr><call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>(<name>NS_STYLE_AZIMUTH_LEFT_SIDE</name> &lt;= <name>intValue</name>) &amp;&amp;
          (<name>intValue</name> &lt;= <name>NS_STYLE_AZIMUTH_BEHIND</name>)</expr>)</condition><then> <block>{  <comment type="line">// look for optional modifier</comment>
        <decl_stmt><decl><type><name>nsCSSValue</name></type>  <name>modifier</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>ParseEnum</name><argument_list>(<argument><expr><name>modifier</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kAzimuthKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>enumValue</name> <init>= <expr><call><name><name>modifier</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>((<name>intValue</name> == <name>NS_STYLE_AZIMUTH_BEHIND</name>) &amp;&amp;
               (<name>NS_STYLE_AZIMUTH_LEFT_SIDE</name> &lt;= <name>enumValue</name>) &amp;&amp; (<name>enumValue</name> &lt;= <name>NS_STYLE_AZIMUTH_RIGHT_SIDE</name>)) ||
              ((<name>enumValue</name> == <name>NS_STYLE_AZIMUTH_BEHIND</name>) &amp;&amp;
               (<name>NS_STYLE_AZIMUTH_LEFT_SIDE</name> &lt;= <name>intValue</name>) &amp;&amp; (<name>intValue</name> &lt;= <name>NS_STYLE_AZIMUTH_RIGHT_SIDE</name>))</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>aValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>intValue</name> | <name>enumValue</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>PR_TRUE</name></expr>;</return>
          }</block></then></if>
          <comment type="line">// Put the unknown identifier back and return</comment>
          <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsCSSValue</name></type>
<name>BoxPositionMaskToCSSValue</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aMask</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>isX</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>val</name> <init>= <expr><name>NS_STYLE_BG_POSITION_CENTER</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>isX</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>aMask</name> &amp; <name>BG_LEFT</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>val</name> = <name>NS_STYLE_BG_POSITION_LEFT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>aMask</name> &amp; <name>BG_RIGHT</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>val</name> = <name>NS_STYLE_BG_POSITION_RIGHT</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></then>
  <else>else <block>{
    <if>if <condition>(<expr><name>aMask</name> &amp; <name>BG_TOP</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>val</name> = <name>NS_STYLE_BG_POSITION_TOP</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>aMask</name> &amp; <name>BG_BOTTOM</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>val</name> = <name>NS_STYLE_BG_POSITION_BOTTOM</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></else></if>

  <return>return <expr><call><name>nsCSSValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBackground</name></name><parameter_list>()</parameter_list>
<block>{
  <function_decl><type><name>nsAutoParseCompoundProperty</name></type> <name>compound</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// background-color can only be set once, so it's not a list.</comment>
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>color</name></decl>;</decl_stmt>

  <comment type="line">// Check first for inherit/initial.</comment>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>color</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// must be alone</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <for>for (<init><decl><type><specifier>const</specifier> <name>nsCSSProperty</name>*</type> <name>subprops</name> <init>=
           <expr><call><name><name>nsCSSProps</name>::<name>SubpropertyEntryFor</name></name><argument_list>(<argument><expr><name>eCSSProperty_background</name></expr></argument>)</argument_list></call></expr></init></decl>;</init>
         <condition><expr>*<name>subprops</name> != <name>eCSSProperty_UNKNOWN</name></expr>;</condition> <incr><expr>++<name>subprops</name></expr></incr>) <block>{
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr>*<name>subprops</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>image</name></decl>, <decl><type ref="prev"/><name>repeat</name></decl>, <decl><type ref="prev"/><name>attachment</name></decl>, <decl><type ref="prev"/><name>clip</name></decl>, <decl><type ref="prev"/><name>origin</name></decl>, <decl><type ref="prev"/><name>position</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BackgroundParseState</name></type> <name>state</name> <init>= <expr><block>{
    <expr><name>color</name></expr>,
    <expr><call><name><name>image</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr>,
    <expr><call><name><name>repeat</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr>,
    <expr><call><name><name>attachment</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr>,
    <expr><call><name><name>clip</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr>,
    <expr><call><name><name>origin</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr>,
    <expr><call><name><name>position</name>.<name>SetPairListValue</name></name><argument_list>()</argument_list></call></expr>,
    <macro><name>size</name></macro><expr>.<macro><name>SetPairListValue</name><argument_list>()</argument_list></macro></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>ParseBackgroundItem</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>
    <comment type="line">// If we saw a color, this must be the last item.</comment>
    <if>if <condition>(<expr><call><name><name>color</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_Null</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectEndValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <comment type="line">// Otherwise, a comma is mandatory.</comment>
    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <comment type="line">// Chain another entry on all the lists.</comment>
    <expr_stmt><expr><name><name>state</name>.<name>mImage</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mImage</name></name> = <name><name>state</name>.<name>mImage</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mRepeat</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mRepeat</name></name> = <name><name>state</name>.<name>mRepeat</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mAttachment</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mAttachment</name></name> = <name><name>state</name>.<name>mAttachment</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mClip</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mClip</name></name> = <name><name>state</name>.<name>mClip</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mOrigin</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mOrigin</name></name> = <name><name>state</name>.<name>mOrigin</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mPosition</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValuePairList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mPosition</name></name> = <name><name>state</name>.<name>mPosition</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mSize</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValuePairList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>mSize</name></name> = <name><name>state</name>.<name>mSize</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// If we get to this point without seeing a color, provide a default.</comment>
  <if>if <condition>(<expr><call><name><name>color</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Null</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>color</name>.<name>SetColorValue</name></name><argument_list>(<argument><expr><call><name>NS_RGBA</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_background_image</name></expr></argument>,      <argument><expr><name>image</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_background_repeat</name></expr></argument>,     <argument><expr><name>repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_background_attachment</name></expr></argument>, <argument><expr><name>attachment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_background_clip</name></expr></argument>,       <argument><expr><name>clip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_background_origin</name></expr></argument>,     <argument><expr><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_background_position</name></expr></argument>,   <argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_background_size</name></expr></argument>,       <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_background_color</name></expr></argument>,      <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// Parse one item of the background shorthand property.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBackgroundItem</name></name><parameter_list>(<param><decl><type><name><name>CSSParserImpl</name>::<name>BackgroundParseState</name></name>&amp;</type> <name>aState</name></decl></param>)</parameter_list>

<block>{
  <comment type="line">// Fill in the values that the shorthand will set if we don't find</comment>
  <comment type="line">// other values.</comment>
  <expr_stmt><expr><call><name><name>aState</name>.<name>mImage</name>-&gt;<name>mValue</name>.<name>SetNoneValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aState</name>.<name>mRepeat</name>-&gt;<name>mValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>NS_STYLE_BG_REPEAT_XY</name></expr></argument>,
                                     <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aState</name>.<name>mAttachment</name>-&gt;<name>mValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>NS_STYLE_BG_ATTACHMENT_SCROLL</name></expr></argument>,
                                         <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aState</name>.<name>mClip</name>-&gt;<name>mValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>NS_STYLE_BG_CLIP_BORDER</name></expr></argument>,
                                   <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aState</name>.<name>mOrigin</name>-&gt;<name>mValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>NS_STYLE_BG_ORIGIN_PADDING</name></expr></argument>,
                                     <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aState</name>.<name>mPosition</name>-&gt;<name>mXValue</name>.<name>SetPercentValue</name></name><argument_list>(<argument><expr>0.0f</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aState</name>.<name>mPosition</name>-&gt;<name>mYValue</name>.<name>SetPercentValue</name></name><argument_list>(<argument><expr>0.0f</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aState</name>.<name>mSize</name>-&gt;<name>mXValue</name>.<name>SetAutoValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aState</name>.<name>mSize</name>-&gt;<name>mYValue</name>.<name>SetAutoValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>haveColor</name> <init>= <expr><name>PR_FALSE</name></expr></init>,
         <name>haveImage</name> <init>= <expr><name>PR_FALSE</name></expr></init>,
         <name>haveRepeat</name> <init>= <expr><name>PR_FALSE</name></expr></init>,
         <name>haveAttach</name> <init>= <expr><name>PR_FALSE</name></expr></init>,
         <name>havePosition</name> <init>= <expr><name>PR_FALSE</name></expr></init>,
         <name>haveOrigin</name> <init>= <expr><name>PR_FALSE</name></expr></init>,
         <name>haveSomething</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>nsCSSTokenType</name></type> <name>tt</name> <init>= <expr><name><name>mToken</name>.<name>mType</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// ...but we'll still cheat and use mToken</comment>
    <if>if <condition>(<expr><name>tt</name> == <name>eCSSToken_Symbol</name></expr>)</condition><then> <block>{
      <comment type="line">// ExpectEndProperty only looks for symbols, and nothing else will</comment>
      <comment type="line">// show up as one.</comment>
      <break>break;</break>
    }</block></then></if>

    <if>if <condition>(<expr><name>tt</name> == <name>eCSSToken_Ident</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsCSSKeyword</name></type> <name>keyword</name> <init>= <expr><call><name><name>nsCSSKeywords</name>::<name>LookupKeyword</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>dummy</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>keyword</name> == <name>eCSSKeyword_inherit</name> ||
          <name>keyword</name> == <name>eCSSKeyword__moz_initial</name></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then> <else>else <if>if <condition>(<expr><name>keyword</name> == <name>eCSSKeyword_none</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>haveImage</name></expr>)</condition><then>
          <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>haveImage</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mImage</name>-&gt;<name>mValue</name></name></expr></argument>,
                                      <argument><expr><name>eCSSProperty_background_image</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"should be able to parse"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
      }</block></then> <else>else <if>if <condition>(<expr><call><name><name>nsCSSProps</name>::<name>FindKeyword</name></name><argument_list>(<argument><expr><name>keyword</name></expr></argument>,
                   <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundAttachmentKTable</name></name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>haveAttach</name></expr>)</condition><then>
          <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>haveAttach</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mAttachment</name>-&gt;<name>mValue</name></name></expr></argument>,
                                      <argument><expr><name>eCSSProperty_background_attachment</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"should be able to parse"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
      }</block></then> <else>else <if>if <condition>(<expr><call><name><name>nsCSSProps</name>::<name>FindKeyword</name></name><argument_list>(<argument><expr><name>keyword</name></expr></argument>,
                   <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundRepeatKTable</name></name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>haveRepeat</name></expr>)</condition><then>
          <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>haveRepeat</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mRepeat</name>-&gt;<name>mValue</name></name></expr></argument>,
                                      <argument><expr><name>eCSSProperty_background_repeat</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"should be able to parse"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
      }</block></then> <else>else <if>if <condition>(<expr><call><name><name>nsCSSProps</name>::<name>FindKeyword</name></name><argument_list>(<argument><expr><name>keyword</name></expr></argument>,
                   <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundPositionKTable</name></name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>havePosition</name></expr>)</condition><then>
          <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>havePosition</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsCSSValuePair</name></type> <name>scratch</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>ParseBoxPositionValues</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>aState</name>.<name>mPosition</name>-&gt;<name>mXValue</name></name> = <name><name>scratch</name>.<name>mXValue</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aState</name>.<name>mPosition</name>-&gt;<name>mYValue</name></name> = <name><name>scratch</name>.<name>mYValue</name></name></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><call><name><name>nsCSSProps</name>::<name>FindKeyword</name></name><argument_list>(<argument><expr><name>keyword</name></expr></argument>,
                   <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundOriginKTable</name></name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>haveOrigin</name></expr>)</condition><then>
          <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>haveOrigin</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mOrigin</name>-&gt;<name>mValue</name></name></expr></argument>,
                                      <argument><expr><name>eCSSProperty_background_origin</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"should be able to parse"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>PR_STATIC_ASSERT</name><argument_list>(<argument><expr><name>NS_STYLE_BG_CLIP_BORDER</name> ==
                         <name>NS_STYLE_BG_ORIGIN_BORDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PR_STATIC_ASSERT</name><argument_list>(<argument><expr><name>NS_STYLE_BG_CLIP_PADDING</name> ==
                         <name>NS_STYLE_BG_ORIGIN_PADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PR_STATIC_ASSERT</name><argument_list>(<argument><expr><name>NS_STYLE_BG_CLIP_CONTENT</name> ==
                         <name>NS_STYLE_BG_ORIGIN_CONTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aState</name>.<name>mClip</name>-&gt;<name>mValue</name></name> = <name><name>aState</name>.<name>mOrigin</name>-&gt;<name>mValue</name></name></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <if>if <condition>(<expr><name>haveColor</name></expr>)</condition><then>
          <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>haveColor</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mColor</name></name></expr></argument>,
                                      <argument><expr><name>eCSSProperty_background_color</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
      }</block></else></if></else></if></else></if></else></if></else></if></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> == <name>eCSSToken_Function</name> &amp;&amp;
               (<call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"url"</expr></argument>)</argument_list></call> ||
                <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-linear-gradient"</expr></argument>)</argument_list></call> ||
                <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-radial-gradient"</expr></argument>)</argument_list></call> ||
                <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-repeating-linear-gradient"</expr></argument>)</argument_list></call> ||
                <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-repeating-radial-gradient"</expr></argument>)</argument_list></call> ||
                <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-image-rect"</expr></argument>)</argument_list></call> ||
                <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-element"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>haveImage</name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
      <expr_stmt><expr><name>haveImage</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mImage</name>-&gt;<name>mValue</name></name></expr></argument>,
                                    <argument><expr><name>eCSSProperty_background_image</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>tt</name> == <name>eCSSToken_Dimension</name> ||
               <name>tt</name> == <name>eCSSToken_Number</name> ||
               <name>tt</name> == <name>eCSSToken_Percentage</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>havePosition</name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
      <expr_stmt><expr><name>havePosition</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsCSSValuePair</name></type> <name>scratch</name></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<call><name>ParseBoxPositionValues</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>aState</name>.<name>mPosition</name>-&gt;<name>mXValue</name></name> = <name><name>scratch</name>.<name>mXValue</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aState</name>.<name>mPosition</name>-&gt;<name>mYValue</name></name> = <name><name>scratch</name>.<name>mYValue</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <if>if <condition>(<expr><name>haveColor</name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
      <expr_stmt><expr><name>haveColor</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <comment type="line">// Note: This parses 'inherit' and 'initial', but</comment>
      <comment type="line">// we've already checked for them, so it's ok.</comment>
      <if>if <condition>(<expr>!<call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mColor</name></name></expr></argument>,
                                    <argument><expr><name>eCSSProperty_background_color</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></else></if></else></if></else></if>
    <expr_stmt><expr><name>haveSomething</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></while>

  <return>return <expr><name>haveSomething</name></expr>;</return>
}</block></function>

<comment type="line">// This function is very similar to ParseBackgroundPosition and</comment>
<comment type="line">// ParseBackgroundSize.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBackgroundList</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// aPropID is a single value prop-id</comment>
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'initial' and 'inherit' stand alone, no list permitted.</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>item</name> <init>= <expr><call><name><name>value</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>aPropID</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>item</name> = <name><name>item</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// This function is very similar to ParseBackgroundList and ParseBackgroundSize.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBackgroundPosition</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'initial' and 'inherit' stand alone, no list permitted.</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValuePair</name></type> <name>valuePair</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>ParseBoxPositionValues</name><argument_list>(<argument><expr><name>valuePair</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>nsCSSValuePairList</name>*</type> <name>item</name> <init>= <expr><call><name><name>value</name>.<name>SetPairListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <expr_stmt><expr><name><name>item</name>-&gt;<name>mXValue</name></name> = <name><name>valuePair</name>.<name>mXValue</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>mYValue</name></name> = <name><name>valuePair</name>.<name>mYValue</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>ParseBoxPositionValues</name><argument_list>(<argument><expr><name>valuePair</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValuePairList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>item</name> = <name><name>item</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_background_position</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Parses two values that correspond to positions in a box.  These can be
 * values corresponding to percentages of the box, raw offsets, or keywords
 * like "top," "left center," etc.
 *
 * @param aOut The nsCSSValuePair in which to place the result.
 * @param aAcceptsInherit If true, 'inherit' and 'initial' are legal values
 * @return Whether or not the operation succeeded.
 */</comment>
<function><type><name>PRBool</name></type> <name><name>CSSParserImpl</name>::<name>ParseBoxPositionValues</name></name><parameter_list>(<param><decl><type><name>nsCSSValuePair</name> &amp;</type><name>aOut</name></decl></param>,
                                             <param><decl><type><name>PRBool</name></type> <name>aAcceptsInherit</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// First try a percentage or a length value</comment>
  <decl_stmt><decl><type><name>nsCSSValue</name> &amp;</type><name>xValue</name> <init>= <expr><name><name>aOut</name>.<name>mXValue</name></name></expr></init>,
             &amp;<name>yValue</name> <init>= <expr><name><name>aOut</name>.<name>mYValue</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>variantMask</name> <init>= <expr><name>aAcceptsInherit</name> ? <name>VARIANT_HLP</name> : <name>VARIANT_LP</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>xValue</name></expr></argument>, <argument><expr><name>variantMask</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>eCSSUnit_Inherit</name> == <call><name><name>xValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> ||
        <name>eCSSUnit_Initial</name> == <call><name><name>xValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{  <comment type="line">// both are inherited or both are set to initial</comment>
      <expr_stmt><expr><name>yValue</name> = <name>xValue</name></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
    <comment type="line">// We have one percentage/length. Get the optional second</comment>
    <comment type="line">// percentage/length/keyword.</comment>
    <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>yValue</name></expr></argument>, <argument><expr><name>VARIANT_LP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// We have two numbers</comment>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ParseEnum</name><argument_list>(<argument><expr><name>yValue</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundPositionKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>yVal</name> <init>= <expr><call><name><name>yValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!(<name>yVal</name> &amp; <name>BG_CTB</name>)</expr>)</condition><then> <block>{
        <comment type="line">// The second keyword can only be 'center', 'top', or 'bottom'</comment>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>yValue</name> = <call><name>BoxPositionMaskToCSSValue</name><argument_list>(<argument><expr><name>yVal</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// If only one percentage or length value is given, it sets the</comment>
    <comment type="line">// horizontal position only, and the vertical position will be 50%.</comment>
    <expr_stmt><expr><call><name><name>yValue</name>.<name>SetPercentValue</name></name><argument_list>(<argument><expr>0.5f</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Now try keywords. We do this manually to allow for the first</comment>
  <comment type="line">// appearance of "center" to apply to the either the x or y</comment>
  <comment type="line">// position (it's ambiguous so we have to disambiguate). Each</comment>
  <comment type="line">// allowed keyword value is assigned it's own bit. We don't allow</comment>
  <comment type="line">// any duplicate keywords other than center. We try to get two</comment>
  <comment type="line">// keywords but it's okay if there is only one.</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>mask</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseEnum</name><argument_list>(<argument><expr><name>xValue</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundPositionKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>bit</name> <init>= <expr><call><name><name>xValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>mask</name> |= <name>bit</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>ParseEnum</name><argument_list>(<argument><expr><name>xValue</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundPositionKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>bit</name> = <call><name><name>xValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mask</name> &amp; (<name>bit</name> &amp; ~<name>BG_CENTER</name>)</expr>)</condition><then> <block>{
        <comment type="line">// Only the 'center' keyword can be duplicated.</comment>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>mask</name> |= <name>bit</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <comment type="line">// Only one keyword.  See if we have a length or percentage.</comment>
      <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>yValue</name></expr></argument>, <argument><expr><name>VARIANT_LP</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!(<name>mask</name> &amp; <name>BG_CLR</name>)</expr>)</condition><then> <block>{
          <comment type="line">// The first keyword can only be 'center', 'left', or 'right'</comment>
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>xValue</name> = <call><name>BoxPositionMaskToCSSValue</name><argument_list>(<argument><expr><name>mask</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_TRUE</name></expr>;</return>
      }</block></then></if>
    }</block></else></if>
  }</block></then></if>

  <comment type="line">// Check for bad input. Bad input consists of no matching keywords,</comment>
  <comment type="line">// or pairs of x keywords or pairs of y keywords.</comment>
  <if>if <condition>(<expr>(<name>mask</name> == 0) || (<name>mask</name> == (<name>BG_TOP</name> | <name>BG_BOTTOM</name>)) ||
      (<name>mask</name> == (<name>BG_LEFT</name> | <name>BG_RIGHT</name>))</expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Create style values</comment>
  <expr_stmt><expr><name>xValue</name> = <call><name>BoxPositionMaskToCSSValue</name><argument_list>(<argument><expr><name>mask</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>yValue</name> = <call><name>BoxPositionMaskToCSSValue</name><argument_list>(<argument><expr><name>mask</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// This function is very similar to ParseBackgroundList and</comment>
<comment type="line">// ParseBackgroundPosition.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBackgroundSize</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'initial' and 'inherit' stand alone, no list permitted.</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValuePair</name></type> <name>valuePair</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>ParseBackgroundSizeValues</name><argument_list>(<argument><expr><name>valuePair</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>nsCSSValuePairList</name>*</type> <name>item</name> <init>= <expr><call><name><name>value</name>.<name>SetPairListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <expr_stmt><expr><name><name>item</name>-&gt;<name>mXValue</name></name> = <name><name>valuePair</name>.<name>mXValue</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>mYValue</name></name> = <name><name>valuePair</name>.<name>mYValue</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>ParseBackgroundSizeValues</name><argument_list>(<argument><expr><name>valuePair</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValuePairList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>item</name> = <name><name>item</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_background_size</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Parses two values that correspond to lengths for the background-size
 * property.  These can be one or two lengths (or the 'auto' keyword) or
 * percentages corresponding to the element's dimensions or the single keywords
 * 'contain' or 'cover'.  'initial' and 'inherit' must be handled by the caller
 * if desired.
 *
 * @param aOut The nsCSSValuePair in which to place the result.
 * @return Whether or not the operation succeeded.
 */</comment>
<function><type><name>PRBool</name></type> <name><name>CSSParserImpl</name>::<name>ParseBackgroundSizeValues</name></name><parameter_list>(<param><decl><type><name>nsCSSValuePair</name> &amp;</type><name>aOut</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// First try a percentage or a length value</comment>
  <decl_stmt><decl><type><name>nsCSSValue</name> &amp;</type><name>xValue</name> <init>= <expr><name><name>aOut</name>.<name>mXValue</name></name></expr></init>,
             &amp;<name>yValue</name> <init>= <expr><name><name>aOut</name>.<name>mYValue</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>xValue</name></expr></argument>, <argument><expr><name>VARIANT_LP</name> | <name>VARIANT_AUTO</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// We have one percentage/length/auto. Get the optional second</comment>
    <comment type="line">// percentage/length/keyword.</comment>
    <if>if <condition>(<expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>yValue</name></expr></argument>, <argument><expr><name>VARIANT_LP</name> | <name>VARIANT_AUTO</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// We have a second percentage/length/auto.</comment>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// If only one percentage or length value is given, it sets the</comment>
    <comment type="line">// horizontal size only, and the vertical size will be as if by 'auto'.</comment>
    <expr_stmt><expr><call><name><name>yValue</name>.<name>SetAutoValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Now address 'contain' and 'cover'.</comment>
  <if>if <condition>(<expr>!<call><name>ParseEnum</name><argument_list>(<argument><expr><name>xValue</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kBackgroundSizeKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name><name>yValue</name>.<name>Reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBorderColor</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderColorSources</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSProperty_border_left_color_ltr_source</name></expr>,
    <expr><name>eCSSProperty_border_left_color_rtl_source</name></expr>,
    <expr><name>eCSSProperty_border_right_color_ltr_source</name></expr>,
    <expr><name>eCSSProperty_border_right_color_rtl_source</name></expr>,
    <expr><name>eCSSProperty_UNKNOWN</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <comment type="line">// do this now, in case 4 values weren't specified</comment>
  <expr_stmt><expr><call><name>InitBoxPropsAsPhysical</name><argument_list>(<argument><expr><name>kBorderColorSources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ParseBoxProperties</name><argument_list>(<argument><expr><name>kBorderColorIDs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBorderImage</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>val</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name> | <name>VARIANT_NONE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_border_image</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// &lt;uri&gt; [&lt;number&gt; | &lt;percentage&gt;]{1,4}</comment>
  <comment type="line">//       [ / &lt;border-width&gt;{1,4} ]? [stretch | repeat | round]{0,2}</comment>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>arr</name> <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr>11</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>arr</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>url</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>splitTop</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>splitRight</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>splitBottom</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>splitLeft</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>borderWidthTop</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>borderWidthRight</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>borderWidthBottom</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>7</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>borderWidthLeft</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>horizontalKeyword</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>9</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name>&amp;</type> <name>verticalKeyword</name> <init>= <expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// &lt;uri&gt;</comment>
  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>VARIANT_URL</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// [&lt;number&gt; | &lt;percentage&gt;]{1,4}</comment>
  <if>if <condition>(<expr>!<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>splitTop</name></expr></argument>,
                               <argument><expr><name>VARIANT_NUMBER</name> | <name>VARIANT_PERCENT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>!<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>splitRight</name></expr></argument>,
                               <argument><expr><name>VARIANT_NUMBER</name> | <name>VARIANT_PERCENT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>splitRight</name> = <name>splitTop</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>!<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>splitBottom</name></expr></argument>,
                               <argument><expr><name>VARIANT_NUMBER</name> | <name>VARIANT_PERCENT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>splitBottom</name> = <name>splitTop</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>!<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>splitLeft</name></expr></argument>,
                               <argument><expr><name>VARIANT_NUMBER</name> | <name>VARIANT_PERCENT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>splitLeft</name> = <name>splitRight</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// [ / &lt;border-width&gt;{1,4} ]?</comment>
  <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>'/'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// if have '/', at least one value is required</comment>
    <if>if <condition>(<expr>!<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>borderWidthTop</name></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>borderWidthRight</name></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>borderWidthRight</name> = <name>borderWidthTop</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>borderWidthBottom</name></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>borderWidthBottom</name> = <name>borderWidthTop</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>borderWidthLeft</name></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>borderWidthLeft</name> = <name>borderWidthRight</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// [stretch | repeat | round]{0,2}</comment>
  <comment type="line">// missing keywords are handled in nsRuleNode::ComputeBorderData()</comment>
  <if>if <condition>(<expr><call><name>ParseEnum</name><argument_list>(<argument><expr><name>horizontalKeyword</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kBorderImageKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr>(<name>void</name>)<call><name>ParseEnum</name><argument_list>(<argument><expr><name>verticalKeyword</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kBorderImageKTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>val</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>eCSSUnit_Array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_border_image</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBorderSpacing</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>xValue</name></decl>, <decl><type ref="prev"/><name>yValue</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>xValue</name></expr></argument>, <argument><expr><name>VARIANT_HL</name> | <name>VARIANT_CALC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// If we have one length, get the optional second length.</comment>
  <comment type="line">// set the second value equal to the first.</comment>
  <if>if <condition>(<expr><call><name><name>xValue</name>.<name>IsLengthUnit</name></name><argument_list>()</argument_list></call> || <call><name><name>xValue</name>.<name>IsCalcUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>yValue</name></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name> | <name>VARIANT_CALC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>yValue</name> == <name>xValue</name> || <call><name><name>yValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Null</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_border_spacing</name></expr></argument>, <argument><expr><name>xValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>pair</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pair</name>.<name>SetPairValue</name></name><argument_list>(<argument><expr><name>xValue</name></expr></argument>, <argument><expr><name>yValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_border_spacing</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBorderSide</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>aPropIDs</name><index>[]</index></name></decl></param>,
                               <param><decl><type><name>PRBool</name></type> <name>aSetAllSides</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name>numProps</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name></type>  <name><name>values</name><index>[<expr><name>numProps</name></expr>]</index></name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>found</name> <init>= <expr><call><name>ParseChoice</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>aPropIDs</name></expr></argument>, <argument><expr><name>numProps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>found</name> &lt; 1) || (<name>PR_FALSE</name> == <call><name>ExpectEndProperty</name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>(<name>found</name> &amp; 1) == 0</expr>)</condition><then> <block>{ <comment type="line">// Provide default border-width</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>0</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_BORDER_WIDTH_MEDIUM</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 2) == 0</expr>)</condition><then> <block>{ <comment type="line">// Provide default border-style</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>1</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_BORDER_STYLE_NONE</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 4) == 0</expr>)</condition><then> <block>{ <comment type="line">// text color will be used</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>2</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>aSetAllSides</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderSources</name><index>[]</index></name> <init>= <expr><block>{
      <expr><name>eCSSProperty_border_left_color_ltr_source</name></expr>,
      <expr><name>eCSSProperty_border_left_color_rtl_source</name></expr>,
      <expr><name>eCSSProperty_border_right_color_ltr_source</name></expr>,
      <expr><name>eCSSProperty_border_right_color_rtl_source</name></expr>,
      <expr><name>eCSSProperty_border_left_style_ltr_source</name></expr>,
      <expr><name>eCSSProperty_border_left_style_rtl_source</name></expr>,
      <expr><name>eCSSProperty_border_right_style_ltr_source</name></expr>,
      <expr><name>eCSSProperty_border_right_style_rtl_source</name></expr>,
      <expr><name>eCSSProperty_border_left_width_ltr_source</name></expr>,
      <expr><name>eCSSProperty_border_left_width_rtl_source</name></expr>,
      <expr><name>eCSSProperty_border_right_width_ltr_source</name></expr>,
      <expr><name>eCSSProperty_border_right_width_rtl_source</name></expr>,
      <expr><name>eCSSProperty_UNKNOWN</name></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>InitBoxPropsAsPhysical</name><argument_list>(<argument><expr><name>kBorderSources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Parsing "border" shorthand; set all four sides to the same thing</comment>
    <for>for (<init><decl><type><name>PRInt32</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>index</name> &lt; 4</expr>;</condition> <incr><expr><name>index</name>++</expr></incr>) <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>numProps</name> == 3</expr></argument>, <argument><expr>"This code needs updating"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>kBorderWidthIDs</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>kBorderStyleIDs</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>kBorderColorIDs</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderColorsProps</name><index>[]</index></name> <init>= <expr><block>{
      <expr><name>eCSSProperty_border_top_colors</name></expr>,
      <expr><name>eCSSProperty_border_right_colors</name></expr>,
      <expr><name>eCSSProperty_border_bottom_colors</name></expr>,
      <expr><name>eCSSProperty_border_left_colors</name></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <comment type="line">// Set the other properties that the border shorthand sets to their</comment>
    <comment type="line">// initial values.</comment>
    <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>extraValue</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>values</name><index>[<expr>0</expr>]</index></name>.<call><name>GetUnit</name><argument_list>()</argument_list></call></expr>)</condition> <block>{
      <case>case <expr><name>eCSSUnit_Inherit</name></expr>:    <expr_stmt><expr><call><name><name>extraValue</name>.<name>SetInheritValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>    <break>break;</break>
      </case><case>case <expr><name>eCSSUnit_Initial</name></expr>:    <expr_stmt><expr><call><name><name>extraValue</name>.<name>SetInitialValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>    <break>break;</break>
      </case><default>default:                  <expr_stmt><expr><call><name><name>extraValue</name>.<name>SetNoneValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>       <break>break;</break>
    </default>}</block></switch>
    <macro><name>NS_FOR_CSS_SIDES</name><argument_list>(<argument>side</argument>)</argument_list></macro> <block>{
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>kBorderColorsProps</name><index>[<expr><name>side</name></expr>]</index></name></expr></argument>, <argument><expr><name>extraValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_border_image</name></expr></argument>, <argument><expr><name>extraValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <comment type="line">// Just set our one side</comment>
    <for>for (<init><decl><type><name>PRInt32</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>index</name> &lt; <name>numProps</name></expr>;</condition> <incr><expr><name>index</name>++</expr></incr>) <block>{
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>aPropIDs</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseDirectionalBorderSide</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>aPropIDs</name><index>[]</index></name></decl></param>,
                                          <param><decl><type><name>PRInt32</name></type> <name>aSourceType</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name>numProps</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name></type>  <name><name>values</name><index>[<expr><name>numProps</name></expr>]</index></name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>found</name> <init>= <expr><call><name>ParseChoice</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>aPropIDs</name></expr></argument>, <argument><expr><name>numProps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>found</name> &lt; 1) || (<name>PR_FALSE</name> == <call><name>ExpectEndProperty</name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>(<name>found</name> &amp; 1) == 0</expr>)</condition><then> <block>{ <comment type="line">// Provide default border-width</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>0</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_BORDER_WIDTH_MEDIUM</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 2) == 0</expr>)</condition><then> <block>{ <comment type="line">// Provide default border-style</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>1</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_BORDER_STYLE_NONE</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 4) == 0</expr>)</condition><then> <block>{ <comment type="line">// text color will be used</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>2</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>index</name> &lt; <name>numProps</name></expr>;</condition> <incr><expr><name>index</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsCSSProperty</name>*</type> <name>subprops</name> <init>=
      <expr><call><name><name>nsCSSProps</name>::<name>SubpropertyEntryFor</name></name><argument_list>(<argument><expr><name><name>aPropIDs</name><index>[<expr><name>index</name> + <name>numProps</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>subprops</name><index>[<expr>3</expr>]</index></name> == <name>eCSSProperty_UNKNOWN</name></expr></argument>,
                 <argument><expr>"not box property with physical vs. logical cascading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>subprops</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <function_decl><type><name>nsCSSValue</name></type> <name>typeVal</name><parameter_list>(<param><decl><type><name>aSourceType</name></type></decl></param>, <param><decl><type><name>eCSSUnit_Enumerated</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>subprops</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>typeVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>subprops</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name>typeVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBorderStyle</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderStyleSources</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSProperty_border_left_style_ltr_source</name></expr>,
    <expr><name>eCSSProperty_border_left_style_rtl_source</name></expr>,
    <expr><name>eCSSProperty_border_right_style_ltr_source</name></expr>,
    <expr><name>eCSSProperty_border_right_style_rtl_source</name></expr>,
    <expr><name>eCSSProperty_UNKNOWN</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <comment type="line">// do this now, in case 4 values weren't specified</comment>
  <expr_stmt><expr><call><name>InitBoxPropsAsPhysical</name><argument_list>(<argument><expr><name>kBorderStyleSources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ParseBoxProperties</name><argument_list>(<argument><expr><name>kBorderStyleIDs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBorderWidth</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kBorderWidthSources</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSProperty_border_left_width_ltr_source</name></expr>,
    <expr><name>eCSSProperty_border_left_width_rtl_source</name></expr>,
    <expr><name>eCSSProperty_border_right_width_ltr_source</name></expr>,
    <expr><name>eCSSProperty_border_right_width_rtl_source</name></expr>,
    <expr><name>eCSSProperty_UNKNOWN</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <comment type="line">// do this now, in case 4 values weren't specified</comment>
  <expr_stmt><expr><call><name>InitBoxPropsAsPhysical</name><argument_list>(<argument><expr><name>kBorderWidthSources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ParseBoxProperties</name><argument_list>(<argument><expr><name>kBorderWidthIDs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseBorderColors</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aProperty</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name> | <name>VARIANT_NONE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'inherit', 'initial', and 'none' are only allowed on their own</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValueList</name> *</type><name>cur</name> <init>= <expr><call><name><name>value</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cur</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>VARIANT_COLOR</name> | <name>VARIANT_KEYWORD</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kBorderColorKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>HasMinMax</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name><name>nsCSSValue</name>::<name>Array</name></name> *</type><name>aArray</name></decl></param>)</parameter_list>
<block>{
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>i_end</name> <init>= <expr><call><name><name>aArray</name>-&gt;<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> != <name>i_end</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsCSSValue</name> &amp;</type><name>v</name> <init>= <expr><call><name><name>aArray</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>IsCalcUnit</name></name><argument_list>()</argument_list></call> &amp;&amp;
        (<call><name><name>v</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Calc_Minimum</name> ||
         <call><name><name>v</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Calc_Maximum</name> ||
         <call><name>HasMinMax</name><argument_list>(<argument><expr><call><name><name>v</name>.<name>GetArrayValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// Parse the top level of a calc() expression, which can be calc(),</comment>
<comment type="line">// min(), or max().</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseCalc</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name> &amp;</type><name>aValue</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aVariantMask</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Parsing calc expressions requires, in a number of cases, looking</comment>
  <comment type="line">// for a token that is *either* a value of the property or a number.</comment>
  <comment type="line">// This can be done without lookahead when we assume that the property</comment>
  <comment type="line">// values cannot themselves be numbers.</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!(<name>aVariantMask</name> &amp; <name>VARIANT_NUMBER</name>)</expr></argument>, <argument><expr>"unexpected variant mask"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>aVariantMask</name> != 0</expr></argument>, <argument><expr>"unexpected variant mask"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>noMinMax</name> <init>= <expr><name>aVariantMask</name> &amp; <name>VARIANT_CALC_NO_MIN_MAX</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>aVariantMask</name> &amp;= ~<name>VARIANT_CALC_NO_MIN_MAX</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsCSSUnit</name></type> <name>unit</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-min"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>unit</name> = <name>eCSSUnit_Calc_Minimum</name></expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-max"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>unit</name> = <name>eCSSUnit_Calc_Maximum</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-calc"</expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr>"unexpected function"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>unit</name> = <name>eCSSUnit_Calc</name></expr>;</expr_stmt>
  }</block></else></if></else></if>

  <if>if <condition>(<expr><name>unit</name> != <name>eCSSUnit_Calc</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>noMinMax</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>ParseCalcMinMax</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>, <argument><expr><name>aVariantMask</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <comment type="line">// One-iteration loop so we can break to the error-handling case.</comment>
  <do>do <block>{
    <comment type="line">// The toplevel of a calc() is always an nsCSSValue::Array of length 1.</comment>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>arr</name> <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>arr</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>ParseCalcAdditiveExpression</name><argument_list>(<argument><expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aVariantMask</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>

    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>

    <if>if <condition>(<expr><name>noMinMax</name> &amp;&amp; <call><name>HasMinMax</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>eCSSUnit_Calc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block> while <condition>(<expr><name>PR_FALSE</name></expr>)</condition>;</do>

  <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// We optimize away the &lt;value-expression&gt; production given that</comment>
<comment type="line">// ParseVariant consumes initial whitespace and we call</comment>
<comment type="line">// ExpectSymbol(')') with PR_TRUE for aSkipWS.</comment>
<comment type="line">//  * If aVariantMask is VARIANT_NUMBER, this function parses the</comment>
<comment type="line">//    &lt;number-additive-expression&gt; production.</comment>
<comment type="line">//  * If aVariantMask does not contain VARIANT_NUMBER, this function</comment>
<comment type="line">//    parses the &lt;value-additive-expression&gt; production.</comment>
<comment type="line">//  * Otherwise (VARIANT_NUMBER and other bits) this function parses</comment>
<comment type="line">//    whichever one of the productions matches ***and modifies</comment>
<comment type="line">//    aVariantMask*** to reflect which one it has parsed by either</comment>
<comment type="line">//    removing VARIANT_NUMBER or removing all other bits.</comment>
<comment type="line">// It does so iteratively, but builds the correct recursive</comment>
<comment type="line">// data structure.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseCalcAdditiveExpression</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                           <param><decl><type><name>PRInt32</name>&amp;</type> <name>aVariantMask</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>aVariantMask</name> != 0</expr></argument>, <argument><expr>"unexpected variant mask"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name> *</type><name>storage</name> <init>= <expr>&amp;<name>aValue</name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>haveWS</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>ParseCalcMultiplicativeExpression</name><argument_list>(<argument><expr>*<name>storage</name></expr></argument>, <argument><expr><name>aVariantMask</name></expr></argument>, <argument><expr>&amp;<name>haveWS</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<name>haveWS</name> || !<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>nsCSSUnit</name></type> <name>unit</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'+'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>unit</name> = <name>eCSSUnit_Calc_Plus</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'-'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>unit</name> = <name>eCSSUnit_Calc_Minus</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></else></if></else></if>
    <if>if <condition>(<expr>!<call><name>RequireWhitespace</name><argument_list>()</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>arr</name> <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>arr</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call> = <name>aValue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>storage</name> = &amp;<call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<struct>struct <name>ReduceNumberCalcOps</name> <super>: <specifier>public</specifier> <name><name>mozilla</name>::<name>css</name>::<name>BasicFloatCalcOps</name></name>,
                             <specifier>public</specifier> <name><name>mozilla</name>::<name>css</name>::<name>CSSValueInputCalcOps</name></name></super>
<block>{<public type="default">
  <function><type><name>result_type</name></type> <name>ComputeLeafValue</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Number</name></expr></argument>, <argument><expr>"unexpected unit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>aValue</name>.<name>GetFloatValue</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>

  <function><type><name>float</name></type> <name>ComputeNumber</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
  <block>{
    <return>return <expr><call><name><name>mozilla</name>::<name>css</name>::<name>ComputeCalc</name></name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr>*<name>this</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>
</public>}</block>;</struct>

<comment type="line">//  * If aVariantMask is VARIANT_NUMBER, this function parses the</comment>
<comment type="line">//    &lt;number-multiplicative-expression&gt; production.</comment>
<comment type="line">//  * If aVariantMask does not contain VARIANT_NUMBER, this function</comment>
<comment type="line">//    parses the &lt;value-multiplicative-expression&gt; production.</comment>
<comment type="line">//  * Otherwise (VARIANT_NUMBER and other bits) this function parses</comment>
<comment type="line">//    whichever one of the productions matches ***and modifies</comment>
<comment type="line">//    aVariantMask*** to reflect which one it has parsed by either</comment>
<comment type="line">//    removing VARIANT_NUMBER or removing all other bits.</comment>
<comment type="line">// It does so iteratively, but builds the correct recursive data</comment>
<comment type="line">// structure.</comment>
<comment type="line">// This function always consumes *trailing* whitespace when it returns</comment>
<comment type="line">// true; whether there was any such whitespace is returned in the</comment>
<comment type="line">// aHadFinalWS parameter.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseCalcMultiplicativeExpression</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>,
                                                 <param><decl><type><name>PRInt32</name>&amp;</type> <name>aVariantMask</name></decl></param>,
                                                 <param><decl><type><name>PRBool</name> *</type><name>aHadFinalWS</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>aVariantMask</name> != 0</expr></argument>, <argument><expr>"unexpected variant mask"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>gotValue</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt> <comment type="line">// already got the part with the unit</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>afterDivision</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsCSSValue</name> *</type><name>storage</name> <init>= <expr>&amp;<name>aValue</name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>variantMask</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>afterDivision</name> || <name>gotValue</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>variantMask</name> = <name>VARIANT_NUMBER</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>variantMask</name> = <name>aVariantMask</name> | <name>VARIANT_NUMBER</name></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr>!<call><name>ParseCalcTerm</name><argument_list>(<argument><expr>*<name>storage</name></expr></argument>, <argument><expr><name>variantMask</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>variantMask</name> != 0</expr></argument>,
                      <argument><expr>"ParseCalcTerm did not set variantMask appropriately"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr>!(<name>variantMask</name> &amp; <name>VARIANT_NUMBER</name>) ||
                      !(<name>variantMask</name> &amp; ~<call><name>PRInt32</name><argument_list>(<argument><expr><name>VARIANT_NUMBER</name></expr></argument>)</argument_list></call>)</expr></argument>,
                      <argument><expr>"ParseCalcTerm did not set variantMask appropriately"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>variantMask</name> &amp; <name>VARIANT_NUMBER</name></expr>)</condition><then> <block>{
      <comment type="line">// Simplify the value immediately so we can check for division by</comment>
      <comment type="line">// zero.</comment>
      <decl_stmt><decl><type><name>ReduceNumberCalcOps</name></type> <name>ops</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>float</name></type> <name>number</name> <init>= <expr><call><name><name>mozilla</name>::<name>css</name>::<name>ComputeCalc</name></name><argument_list>(<argument><expr>*<name>storage</name></expr></argument>, <argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>number</name> == 0.0 &amp;&amp; <name>afterDivision</name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
      <expr_stmt><expr><call><name><name>storage</name>-&gt;<name>SetFloatValue</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>eCSSUnit_Number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>gotValue</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>storage</name> != &amp;<name>aValue</name></expr>)</condition><then> <block>{
        <comment type="line">// Simplify any numbers in the Times_L position (which are</comment>
        <comment type="line">// not simplified by the check above).</comment>
        <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>storage</name> == &amp;<call><name><name>aValue</name>.<name>GetArrayValue</name></name><argument_list>()</argument_list></call>-&gt;<call><name>Item</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr>"unexpected relationship to current storage"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsCSSValue</name> &amp;</type><name>leftValue</name> <init>= <expr><call><name><name>aValue</name>.<name>GetArrayValue</name></name><argument_list>()</argument_list></call>-&gt;<call><name>Item</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ReduceNumberCalcOps</name></type> <name>ops</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type> <name>number</name> <init>= <expr><call><name><name>mozilla</name>::<name>css</name>::<name>ComputeCalc</name></name><argument_list>(<argument><expr><name>leftValue</name></expr></argument>, <argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>leftValue</name>.<name>SetFloatValue</name></name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><name>eCSSUnit_Number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>hadWS</name> <init>= <expr><call><name>RequireWhitespace</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr>*<name>aHadFinalWS</name> = <name>hadWS</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <decl_stmt><decl><type><name>nsCSSUnit</name></type> <name>unit</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'*'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>unit</name> = <name>gotValue</name> ? <name>eCSSUnit_Calc_Times_R</name> : <name>eCSSUnit_Calc_Times_L</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>afterDivision</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'/'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>unit</name> = <name>eCSSUnit_Calc_Divided</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>afterDivision</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>aHadFinalWS</name> = <name>hadWS</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block></else></if></else></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>arr</name> <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>arr</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call> = <name>aValue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>storage</name> = &amp;<call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// Adjust aVariantMask (see comments above function) to reflect which</comment>
  <comment type="line">// option we took.</comment>
  <if>if <condition>(<expr><name>aVariantMask</name> &amp; <name>VARIANT_NUMBER</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>gotValue</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aVariantMask</name> &amp;= ~<call><name>PRInt32</name><argument_list>(<argument><expr><name>VARIANT_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>aVariantMask</name> = <name>VARIANT_NUMBER</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then> <else>else <block>{
    <if>if <condition>(<expr>!<name>gotValue</name></expr>)</condition><then> <block>{
      <comment type="line">// We had to find a value, but we didn't.</comment>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></else></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">//  * If aVariantMask is VARIANT_NUMBER, this function parses the</comment>
<comment type="line">//    &lt;number-term&gt; production.</comment>
<comment type="line">//  * If aVariantMask does not contain VARIANT_NUMBER, this function</comment>
<comment type="line">//    parses the &lt;value-term&gt; production.</comment>
<comment type="line">//  * Otherwise (VARIANT_NUMBER and other bits) this function parses</comment>
<comment type="line">//    whichever one of the productions matches ***and modifies</comment>
<comment type="line">//    aVariantMask*** to reflect which one it has parsed by either</comment>
<comment type="line">//    removing VARIANT_NUMBER or removing all other bits.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseCalcTerm</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><name>PRInt32</name>&amp;</type> <name>aVariantMask</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>aVariantMask</name> != 0</expr></argument>, <argument><expr>"unexpected variant mask"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <comment type="line">// Either an additive expression in parentheses...</comment>
  <if>if <condition>(<expr><call><name><name>mToken</name>.<name>IsSymbol</name></name><argument_list>(<argument><expr>'('</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>ParseCalcAdditiveExpression</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>aVariantMask</name></expr></argument>)</argument_list></call> ||
        !<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <comment type="line">// ... or a min() or max() expression</comment>
  <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Function</name> &amp;&amp;
      (<call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"min"</expr></argument>)</argument_list></call> ||
       <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"max"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsCSSUnit</name></type> <name>unit</name> <init>= <expr><call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"min"</expr></argument>)</argument_list></call>
                       ? <name>eCSSUnit_Calc_Minimum</name> : <name>eCSSUnit_Calc_Maximum</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>ParseCalcMinMax</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>, <argument><expr><name>aVariantMask</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <comment type="line">// ... or just a value</comment>
  <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>aVariantMask</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <comment type="line">// If we did the value parsing, we need to adjust aVariantMask to</comment>
  <comment type="line">// reflect which option we took (see above).</comment>
  <if>if <condition>(<expr><name>aVariantMask</name> &amp; <name>VARIANT_NUMBER</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Number</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aVariantMask</name> = <name>VARIANT_NUMBER</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>aVariantMask</name> &amp;= ~<call><name>PRInt32</name><argument_list>(<argument><expr><name>VARIANT_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// This function handles and modifies aVariantMask exactly as</comment>
<comment type="line">// described for ParcCalcTerm above.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseCalcMinMax</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><name>nsCSSUnit</name></type> <name>aUnit</name></decl></param>,
                               <param><decl><type><name>PRInt32</name>&amp;</type> <name>aVariantMask</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>aVariantMask</name> != 0</expr></argument>, <argument><expr>"unexpected variant mask"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aUnit</name> == <name>eCSSUnit_Calc_Minimum</name> ||
               <name>aUnit</name> == <name>eCSSUnit_Calc_Maximum</name></expr></argument>,
               <argument><expr>"unexpected unit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Function</name></expr></argument>, <argument><expr>"unexpected current token"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aUnit</name> != <name>eCSSUnit_Calc_Minimum</name> ||
               <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"min"</expr></argument>)</argument_list></call> ||
               <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-min"</expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr>"unexpected current token"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aUnit</name> != <name>eCSSUnit_Calc_Maximum</name> ||
               <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"max"</expr></argument>)</argument_list></call> ||
               <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"-moz-max"</expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr>"unexpected current token"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>nsCSSValue</name></expr></argument>, <argument><expr>4</expr></argument>&gt;</argument_list></name></type> <name>values</name></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <decl_stmt><decl><type><name>nsCSSValue</name> *</type><name>v</name> <init>= <expr><call><name><name>values</name>.<name>AppendElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>v</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>ParseCalcAdditiveExpression</name><argument_list>(<argument><expr>*<name>v</name></expr></argument>, <argument><expr><name>aVariantMask</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr>!(<name>aVariantMask</name> &amp; <name>VARIANT_NUMBER</name>) ||
                      !(<name>aVariantMask</name> &amp; ~<call><name>PRInt32</name><argument_list>(<argument><expr><name>VARIANT_NUMBER</name></expr></argument>)</argument_list></call>)</expr></argument>,
                      <argument><expr>"parsing additive expr did not adjust variant mask"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>aVariantMask</name> != 0</expr></argument>, <argument><expr>"unexpected variant mask"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <continue>continue;</continue></then></if>

    <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>

    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></for>

  <comment type="line">// We allow min() and max() to take 1 or more arguments; the code</comment>
  <comment type="line">// above already ensures that.</comment>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name><name>values</name>.<name>Length</name></name><argument_list>()</argument_list></call> &gt; 0</expr></argument>, <argument><expr>"unexpected length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>arr</name> <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr><call><name><name>values</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>arr</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>i_end</name> <init>= <expr><call><name><name>values</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>i_end</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name><name>arr</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> = <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>

  <expr_stmt><expr><call><name><name>aValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>aUnit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// This function consumes all consecutive whitespace and returns whether</comment>
<comment type="line">// there was any.</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>RequireWhitespace</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_WhiteSpace</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <comment type="line">// Skip any additional whitespace tokens.</comment>
  <if>if <condition>(<expr><call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseRect</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>val</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Ident</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsCSSKeyword</name></type> <name>keyword</name> <init>= <expr><call><name><name>nsCSSKeywords</name>::<name>LookupKeyword</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>keyword</name></expr>)</condition> <block>{
      <case>case <expr><name>eCSSKeyword_auto</name></expr>:
        <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>val</name>.<name>SetAutoValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>eCSSKeyword_inherit</name></expr>:
        <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>val</name>.<name>SetInheritValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>eCSSKeyword__moz_initial</name></expr>:
        <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>val</name>.<name>SetInitialValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
    </default>}</block></switch>
  }</block></then> <else>else <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Function</name> &amp;&amp;
             <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"rect"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsCSSRect</name>&amp;</type> <name>rect</name> <init>= <expr><call><name><name>val</name>.<name>SetRectValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <macro><name>NS_FOR_CSS_SIDES</name><argument_list>(<argument>side</argument>)</argument_list></macro> <block>{
      <if>if <condition>(<expr>! <call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>rect</name>.*</name>(<name><name>nsCSSRect</name>::<name>sides</name><index>[<expr><name>side</name></expr>]</index></name>)</expr></argument>,
                         <argument><expr><name>VARIANT_AL</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><name>side</name> &lt; 3</expr>)</condition><then> <block>{
        <comment type="line">// skip optional commas between elements</comment>
        <expr_stmt><expr>(<name>void</name>)<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block>
    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></else></if></else></if>

  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARIANT_CONTENT</name></cpp:macro> <cpp:value>(VARIANT_STRING | VARIANT_URL | VARIANT_COUNTER | VARIANT_ATTR | \
                         VARIANT_KEYWORD)</cpp:value></cpp:define>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseContent</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// We need to divide the 'content' keywords into two classes for</comment>
  <comment type="line">// ParseVariant's sake, so we can't just use nsCSSProps::kContentKTable.</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PRInt32</name></type> <name><name>kContentListKWs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSKeyword_open_quote</name></expr>, <expr><name>NS_STYLE_CONTENT_OPEN_QUOTE</name></expr>,
    <expr><name>eCSSKeyword_close_quote</name></expr>, <expr><name>NS_STYLE_CONTENT_CLOSE_QUOTE</name></expr>,
    <expr><name>eCSSKeyword_no_open_quote</name></expr>, <expr><name>NS_STYLE_CONTENT_NO_OPEN_QUOTE</name></expr>,
    <expr><name>eCSSKeyword_no_close_quote</name></expr>, <expr><name>NS_STYLE_CONTENT_NO_CLOSE_QUOTE</name></expr>,
    <expr><name>eCSSKeyword_UNKNOWN</name></expr>,<expr>-1</expr>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PRInt32</name></type> <name><name>kContentSolitaryKWs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSKeyword__moz_alt_content</name></expr>, <expr><name>NS_STYLE_CONTENT_ALT_CONTENT</name></expr>,
    <expr><name>eCSSKeyword_UNKNOWN</name></expr>,<expr>-1</expr>
  }</block></expr></init></decl>;</decl_stmt>

  <comment type="line">// Verify that these two lists add up to the size of</comment>
  <comment type="line">// nsCSSProps::kContentKTable.</comment>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name><name>nsCSSProps</name>::<name>kContentKTable</name><index>[
                      <expr><call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>kContentListKWs</name></expr></argument>)</argument_list></call> +
                      <call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>kContentSolitaryKWs</name></expr></argument>)</argument_list></call> - 4</expr>]</index></name> ==
                    <name>eCSSKeyword_UNKNOWN</name> &amp;&amp;
                    <name><name>nsCSSProps</name>::<name>kContentKTable</name><index>[
                      <expr><call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>kContentListKWs</name></expr></argument>)</argument_list></call> +
                      <call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>kContentSolitaryKWs</name></expr></argument>)</argument_list></call> - 3</expr>]</index></name> == -1</expr></argument>,
                    <argument><expr>"content keyword tables out of sync"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_HMK</name> | <name>VARIANT_NONE</name></expr></argument>,
                   <argument><expr><name>kContentSolitaryKWs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'inherit', 'initial', 'normal', 'none', and 'alt-content' must be alone</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>cur</name> <init>= <expr><call><name><name>value</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cur</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>VARIANT_CONTENT</name></expr></argument>, <argument><expr><name>kContentListKWs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_content</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseCounterData</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name> | <name>VARIANT_NONE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> || <name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_Ident</name></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsCSSValuePairList</name> *</type><name>cur</name> <init>= <expr><call><name><name>value</name>.<name>SetPairListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <expr_stmt><expr><call><name><name>cur</name>-&gt;<name>mXValue</name>.<name>SetStringValue</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Number</name> &amp;&amp; <name><name>mToken</name>.<name>mIntegerValid</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cur</name>-&gt;<name>mYValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mInteger</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Integer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> || <name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_Ident</name></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValuePairList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseCue</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>before</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name>before</name></expr></argument>, <argument><expr><name>eCSSProperty_cue_before</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>eCSSUnit_Inherit</name> != <call><name><name>before</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> &amp;&amp;
        <name>eCSSUnit_Initial</name> != <call><name><name>before</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>after</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name>after</name></expr></argument>, <argument><expr><name>eCSSProperty_cue_after</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_cue_before</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_cue_after</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_cue_before</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_cue_after</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseCursor</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'inherit' and 'initial' must be alone</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>cur</name> <init>= <expr><call><name><name>value</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cur</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>VARIANT_UK</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kCursorKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name><name>cur</name>-&gt;<name>mValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_URL</name></expr>)</condition><then> <block>{ <comment type="line">// keyword must be last</comment>
        <if>if <condition>(<expr><call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <break>break;</break>
        }</block></then></if>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>

      <comment type="line">// We have a URL, so make a value array with three values.</comment>
      <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>val</name> <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call> = <name><name>cur</name>-&gt;<name>mValue</name></name></expr>;</expr_stmt>

      <comment type="line">// Parse optional x and y position of cursor hotspot (css3-ui).</comment>
      <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_NUMBER</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// If we have one number, we must have two.</comment>
        <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_NUMBER</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>cur</name>-&gt;<name>mValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>eCSSUnit_Array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// url must not be last</comment>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_cursor</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>


<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFont</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>fontIDs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSProperty_font_style</name></expr>,
    <expr><name>eCSSProperty_font_variant</name></expr>,
    <expr><name>eCSSProperty_font_weight</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsCSSValue</name></type>  <name>family</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>family</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kFontKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>eCSSUnit_Inherit</name> == <call><name><name>family</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> ||
          <name>eCSSUnit_Initial</name> == <call><name><name>family</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty__x_system_font</name></expr></argument>, <argument><expr><call><name>nsCSSValue</name><argument_list>(<argument><expr><name>eCSSUnit_None</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_family</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_style</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_variant</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_weight</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_size</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_line_height</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_stretch</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_size_adjust</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_feature_settings</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_language_override</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty__x_system_font</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <function_decl><type><name>nsCSSValue</name></type> <name>systemFont</name><parameter_list>(<param><decl><type><name>eCSSUnit_System_Font</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_family</name></expr></argument>, <argument><expr><name>systemFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_style</name></expr></argument>, <argument><expr><name>systemFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_variant</name></expr></argument>, <argument><expr><name>systemFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_weight</name></expr></argument>, <argument><expr><name>systemFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_size</name></expr></argument>, <argument><expr><name>systemFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_line_height</name></expr></argument>, <argument><expr><name>systemFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_stretch</name></expr></argument>, <argument><expr><name>systemFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_size_adjust</name></expr></argument>, <argument><expr><name>systemFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_feature_settings</name></expr></argument>, <argument><expr><name>systemFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_language_override</name></expr></argument>, <argument><expr><name>systemFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Get optional font-style, font-variant and font-weight (in any order)</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name>numProps</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name></type>  <name><name>values</name><index>[<expr><name>numProps</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>found</name> <init>= <expr><call><name>ParseChoice</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>fontIDs</name></expr></argument>, <argument><expr><name>numProps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>found</name> &lt; 0) || (<name>eCSSUnit_Inherit</name> == <name><name>values</name><index>[<expr>0</expr>]</index></name>.<call><name>GetUnit</name><argument_list>()</argument_list></call>) ||
      (<name>eCSSUnit_Initial</name> == <name><name>values</name><index>[<expr>0</expr>]</index></name>.<call><name>GetUnit</name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{ <comment type="line">// illegal data</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 1) == 0</expr>)</condition><then> <block>{
    <comment type="line">// Provide default font-style</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>0</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_FONT_STYLE_NORMAL</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 2) == 0</expr>)</condition><then> <block>{
    <comment type="line">// Provide default font-variant</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>1</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_FONT_VARIANT_NORMAL</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 4) == 0</expr>)</condition><then> <block>{
    <comment type="line">// Provide default font-weight</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>2</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_FONT_WEIGHT_NORMAL</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Get mandatory font-size</comment>
  <decl_stmt><decl><type><name>nsCSSValue</name></type>  <name>size</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>! <call><name>ParseVariant</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name> | <name>VARIANT_LP</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kFontSizeKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Get optional "/" line-height</comment>
  <decl_stmt><decl><type><name>nsCSSValue</name></type>  <name>lineHeight</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>'/'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>! <call><name>ParseNonNegativeVariant</name><argument_list>(<argument><expr><name>lineHeight</name></expr></argument>,
                                  <argument><expr><name>VARIANT_NUMBER</name> | <name>VARIANT_LP</name> | <name>VARIANT_NORMAL</name></expr></argument>,
                                  <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name><name>lineHeight</name>.<name>SetNormalValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="line">// Get final mandatory font-family</comment>
  <function_decl><type><name>nsAutoParseCompoundProperty</name></type> <name>compound</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  <if>if <condition>(<expr><call><name>ParseFamily</name><argument_list>(<argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>(<name>eCSSUnit_Inherit</name> != <call><name><name>family</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call>) &amp;&amp; (<name>eCSSUnit_Initial</name> != <call><name><name>family</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call>) &amp;&amp;
        <call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty__x_system_font</name></expr></argument>, <argument><expr><call><name>nsCSSValue</name><argument_list>(<argument><expr><name>eCSSUnit_None</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_family</name></expr></argument>, <argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_style</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_variant</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_weight</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_line_height</name></expr></argument>, <argument><expr><name>lineHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_stretch</name></expr></argument>,
                  <argument><expr><call><name>nsCSSValue</name><argument_list>(<argument><expr><name>NS_FONT_STRETCH_NORMAL</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_size_adjust</name></expr></argument>, <argument><expr><call><name>nsCSSValue</name><argument_list>(<argument><expr><name>eCSSUnit_None</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_feature_settings</name></expr></argument>, <argument><expr><call><name>nsCSSValue</name><argument_list>(<argument><expr><name>eCSSUnit_Normal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_font_language_override</name></expr></argument>, <argument><expr><call><name>nsCSSValue</name><argument_list>(<argument><expr><name>eCSSUnit_Normal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFontWeight</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HKI</name> | <name>VARIANT_SYSFONT</name></expr></argument>,
                   <argument><expr><name><name>nsCSSProps</name>::<name>kFontWeightKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>eCSSUnit_Integer</name> == <call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{ <comment type="line">// ensure unit value</comment>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>intValue</name> <init>= <expr><call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>(100 &lt;= <name>intValue</name>) &amp;&amp;
          (<name>intValue</name> &lt;= 900) &amp;&amp;
          (0 == (<name>intValue</name> % 100))</expr>)</condition><then> <block>{
        <return>return <expr><name>PR_TRUE</name></expr>;</return>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></else></if>
    }</block></then></if>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseOneFamily</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aFamily</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aFamily</name>.<name>Append</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then></if>

      <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aFamily</name>.<name>Append</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><name>eCSSToken_WhiteSpace</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
        <comment type="line">// Lookahead one token and drop whitespace if we are ending the</comment>
        <comment type="line">// font name.</comment>
        <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <break>break;</break></then></if>

        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then>
          <expr_stmt><expr><call><name><name>aFamily</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>PRUnichar</name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
          <break>break;</break></else></if>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></else></if></else></if>
    }</block></for>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>

  }</block></then> <else>else <if>if <condition>(<expr><name>eCSSToken_String</name> == <name><name>tk</name>-&gt;<name>mType</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aFamily</name>.<name>Append</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mSymbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// replace the quotes</comment>
    <expr_stmt><expr><call><name><name>aFamily</name>.<name>Append</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mIdent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// XXX What if it had escaped quotes?</comment>
    <expr_stmt><expr><call><name><name>aFamily</name>.<name>Append</name></name><argument_list>(<argument><expr><name><name>tk</name>-&gt;<name>mSymbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>

  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></else></if></else></if>
}</block></function>

<comment type="line" format="doxygen">///////////////////////////////////////////////////////</comment>
<comment type="line">// -moz-transform Parsing Implementation</comment>

<comment type="block">/* Reads a function list of arguments.  Do not call this function
 * directly; it's mean to be caled from ParseFunction.
 */</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFunctionInternals</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aVariantMask</name><index>[]</index></name></decl></param>,
                                      <param><decl><type><name>PRUint16</name></type> <name>aMinElems</name></decl></param>,
                                      <param><decl><type><name>PRUint16</name></type> <name>aMaxElems</name></decl></param>,
                                      <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsCSSValue</name></expr></argument>&gt;</argument_list></name> &amp;</type><name>aOutput</name></decl></param>)</parameter_list>
<block>{
  <for>for (<init><decl><type><name>PRUint16</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>index</name> &lt; <name>aMaxElems</name></expr>;</condition> <incr><expr>++<name>index</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>newValue</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>, <argument><expr><name><name>aVariantMask</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<call><name><name>aOutput</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    
    <comment type="line">// See whether to continue or whether to look for end of function.</comment>
    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// We need to read the closing parenthesis, and also must take care</comment>
      <comment type="line">// that we haven't read too few symbols.</comment>
      <return>return <expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>index</name> + 1) &gt;= <name>aMinElems</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <comment type="line">// If we're here, we finished looping without hitting the end, so we read too</comment>
  <comment type="line">// many elements.</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/* Parses a function [ input of the form (a [, b]*) ] and stores it
 * as an nsCSSValue that holds a function of the form
 * function-name arg1 arg2 ... argN
 *
 * On error, the return value is PR_FALSE.
 *
 * @param aFunction The name of the function that we're reading.
 * @param aAllowedTypes An array of values corresponding to the legal
 *        types for each element in the function.  The zeroth element in the
 *        array corresponds to the first function parameter, etc.  The length
 *        of this array _must_ be greater than or equal to aMaxElems or the
 *        behavior is undefined.
 * @param aMinElems Minimum number of elements to read.  Reading fewer than
 *        this many elements will result in the function failing.
 * @param aMaxElems Maximum number of elements to read.  Reading more than
 *        this many elements will result in the function failing.
 * @param aValue (out) The value that was parsed.
 */</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFunction</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name> &amp;</type><name>aFunction</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name><name>aAllowedTypes</name><index>[]</index></name></decl></param>,
                             <param><decl><type><name>PRUint16</name></type> <name>aMinElems</name></decl></param>, <param><decl><type><name>PRUint16</name></type> <name>aMaxElems</name></decl></param>,
                             <param><decl><type><name>nsCSSValue</name> &amp;</type><name>aValue</name></decl></param>)</parameter_list>
<block>{
  <typedef>typedef <type><name><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsCSSValue</name></expr></argument>&gt;</argument_list></name>::<name>size_type</name></name></type> <name>arrlen_t</name>;</typedef>

  <comment type="block">/* 2^16 - 2, so that if we have 2^16 - 2 transforms, we have 2^16 - 1
   * elements stored in the the nsCSSValue::Array.
   */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>arrlen_t</name></type> <name>MAX_ALLOWED_ELEMS</name> <init>= <expr>0xFFFE</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Make a copy of the function name, since the reference is _probably_ to
   * mToken.mIdent, which is going to get overwritten during the course of this
   * function.
   */</comment>
  <function_decl><type><name>nsString</name></type> <name>functionName</name><parameter_list>(<param><decl><type><name>aFunction</name></type></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Read in a list of values as an nsTArray, failing if we can't or if
   * it's out of bounds.
   */</comment>
  <decl_stmt><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsCSSValue</name></expr></argument>&gt;</argument_list></name></type> <name>foundValues</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseFunctionInternals</name><argument_list>(<argument><expr><name>aAllowedTypes</name></expr></argument>, <argument><expr><name>aMinElems</name></expr></argument>, <argument><expr><name>aMaxElems</name></expr></argument>,
                              <argument><expr><name>foundValues</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  
  <comment type="block">/* Now, convert this nsTArray into an nsCSSValue::Array object.
   * We'll need N + 1 spots, one for the function name and the rest for the
   * arguments.  In case the user has given us more than 2^16 - 2 arguments,
   * we'll truncate them at 2^16 - 2 arguments.
   */</comment>
  <decl_stmt><decl><type><name>PRUint16</name></type> <name>numElements</name> <init>= <expr>(<call><name><name>foundValues</name>.<name>Length</name></name><argument_list>()</argument_list></call> &lt;= <name>MAX_ALLOWED_ELEMS</name> ?
                          <call><name><name>foundValues</name>.<name>Length</name></name><argument_list>()</argument_list></call> + 1 : <name>MAX_ALLOWED_ELEMS</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>convertedArray</name> <init>=
    <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr><name>numElements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>convertedArray</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  
  <comment type="block">/* Copy things over. */</comment>
  <expr_stmt><expr><call><name><name>convertedArray</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>.<call><name>SetStringValue</name><argument_list>(<argument><expr><name>functionName</name></expr></argument>, <argument><expr><name>eCSSUnit_Ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><decl><type><name>PRUint16</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>index</name> + 1 &lt; <name>numElements</name></expr>;</condition> <incr><expr>++<name>index</name></expr></incr>)
    <expr_stmt><expr><call><name><name>convertedArray</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>index</name> + 1</expr></argument>)</argument_list></call> = <name><name>foundValues</name><index>[<expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>arrlen_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt></for>
  
  <comment type="block">/* Fill in the outparam value with the array. */</comment>
  <expr_stmt><expr><call><name><name>aValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>convertedArray</name></expr></argument>, <argument><expr><name>eCSSUnit_Function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Return it! */</comment>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Given a token, determines the minimum and maximum number of function
 * parameters to read, along with the mask that should be used to read
 * those function parameters.  If the token isn't a transform function,
 * returns an error.
 *
 * @param aToken The token identifying the function.
 * @param aMinElems [out] The minimum number of elements to read.
 * @param aMaxElems [out] The maximum number of elements to read
 * @param aVariantMask [out] The variant mask to use during parsing
 * @return Whether the information was loaded successfully.
 */</comment>
<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>GetFunctionParseInformation</name><parameter_list>(<param><decl><type><name>nsCSSKeyword</name></type> <name>aToken</name></decl></param>,
                                          <param><decl><type><name>PRUint16</name> &amp;</type><name>aMinElems</name></decl></param>,
                                          <param><decl><type><name>PRUint16</name> &amp;</type><name>aMaxElems</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>PRInt32</name> *&amp;</type> <name>aVariantMask</name></decl></param>)</parameter_list>
<block>{
<comment type="block">/* These types represent the common variant masks that will be used to
   * parse out the individual functions.  The order in the enumeration
   * must match the order in which the masks are declared.
   */</comment>
  <enum>enum <block>{ <decl><name>eLengthPercentCalc</name></decl>,
         <decl><name>eTwoLengthPercentCalcs</name></decl>,
         <decl><name>eAngle</name></decl>,
         <decl><name>eTwoAngles</name></decl>,
         <decl><name>eNumber</name></decl>,
         <decl><name>eTwoNumbers</name></decl>,
         <decl><name>eMatrix</name></decl>,
         <decl><name>eNumVariantMasks</name></decl> }</block>;</enum>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PRInt32</name></type> <name>kMaxElemsPerFunction</name> <init>= <expr>6</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PRInt32</name></type> <name><name>kVariantMasks</name><index>[<expr><name>eNumVariantMasks</name></expr>]</index><index>[<expr><name>kMaxElemsPerFunction</name></expr>]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><name>VARIANT_TRANSFORM_LPCALC</name></expr>}</block></expr>,
    <expr><block>{<expr><name>VARIANT_TRANSFORM_LPCALC</name></expr>, <expr><name>VARIANT_TRANSFORM_LPCALC</name></expr>}</block></expr>,
    <expr><block>{<expr><name>VARIANT_ANGLE_OR_ZERO</name></expr>}</block></expr>,
    <expr><block>{<expr><name>VARIANT_ANGLE_OR_ZERO</name></expr>, <expr><name>VARIANT_ANGLE_OR_ZERO</name></expr>}</block></expr>,
    <expr><block>{<expr><name>VARIANT_NUMBER</name></expr>}</block></expr>,
    <expr><block>{<expr><name>VARIANT_NUMBER</name></expr>, <expr><name>VARIANT_NUMBER</name></expr>}</block></expr>,
    <expr><block>{<expr><name>VARIANT_NUMBER</name></expr>, <expr><name>VARIANT_NUMBER</name></expr>, <expr><name>VARIANT_NUMBER</name></expr>, <expr><name>VARIANT_NUMBER</name></expr>,
     <expr><name>VARIANT_TRANSFORM_LPCALC</name></expr>, <expr><name>VARIANT_TRANSFORM_LPCALC</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PRUint8</name></type> <name><name>kVariantMaskLengths</name><index>[<expr><name>eNumVariantMasks</name></expr>]</index></name> <init>=
    <expr><block>{<expr>1</expr>, <expr>2</expr>, <expr>1</expr>, <expr>2</expr>, <expr>1</expr>, <expr>2</expr>, <expr>6</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>variantIndex</name> <init>= <expr><name>eNumVariantMasks</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>aToken</name></expr>)</condition> <block>{
  <case>case <expr><name>eCSSKeyword_translatex</name></expr>:
  </case><case>case <expr><name>eCSSKeyword_translatey</name></expr>:
    <comment type="block">/* Exactly one length or percent. */</comment>
    <expr_stmt><expr><name>variantIndex</name> = <name>eLengthPercentCalc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMinElems</name> = 1U</expr>;</expr_stmt>
    <expr_stmt><expr><name>aMaxElems</name> = 1U</expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>eCSSKeyword_scalex</name></expr>:
    <comment type="block">/* Exactly one scale factor. */</comment>
    <expr_stmt><expr><name>variantIndex</name> = <name>eNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMinElems</name> = 1U</expr>;</expr_stmt>
    <expr_stmt><expr><name>aMaxElems</name> = 1U</expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>eCSSKeyword_scaley</name></expr>:
    <comment type="block">/* Exactly one scale factor. */</comment>
    <expr_stmt><expr><name>variantIndex</name> = <name>eNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMinElems</name> = 1U</expr>;</expr_stmt>
    <expr_stmt><expr><name>aMaxElems</name> = 1U</expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>eCSSKeyword_rotate</name></expr>:
    <comment type="block">/* Exactly one angle. */</comment>
    <expr_stmt><expr><name>variantIndex</name> = <name>eAngle</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMinElems</name> = 1U</expr>;</expr_stmt>
    <expr_stmt><expr><name>aMaxElems</name> = 1U</expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>eCSSKeyword_translate</name></expr>:
    <comment type="block">/* One or two lengths or percents. */</comment>
    <expr_stmt><expr><name>variantIndex</name> = <name>eTwoLengthPercentCalcs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMinElems</name> = 1U</expr>;</expr_stmt>
    <expr_stmt><expr><name>aMaxElems</name> = 2U</expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>eCSSKeyword_skew</name></expr>:
    <comment type="block">/* Exactly one or two angles. */</comment>
    <expr_stmt><expr><name>variantIndex</name> = <name>eTwoAngles</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMinElems</name> = 1U</expr>;</expr_stmt>
    <expr_stmt><expr><name>aMaxElems</name> = 2U</expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>eCSSKeyword_scale</name></expr>:
    <comment type="block">/* One or two scale factors. */</comment>
    <expr_stmt><expr><name>variantIndex</name> = <name>eTwoNumbers</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMinElems</name> = 1U</expr>;</expr_stmt>
    <expr_stmt><expr><name>aMaxElems</name> = 2U</expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>eCSSKeyword_skewx</name></expr>:
    <comment type="block">/* Exactly one angle. */</comment>
    <expr_stmt><expr><name>variantIndex</name> = <name>eAngle</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMinElems</name> = 1U</expr>;</expr_stmt>
    <expr_stmt><expr><name>aMaxElems</name> = 1U</expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>eCSSKeyword_skewy</name></expr>:
    <comment type="block">/* Exactly one angle. */</comment>
    <expr_stmt><expr><name>variantIndex</name> = <name>eAngle</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMinElems</name> = 1U</expr>;</expr_stmt>
    <expr_stmt><expr><name>aMaxElems</name> = 1U</expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>eCSSKeyword_matrix</name></expr>:
    <comment type="block">/* Six values, which can be numbers, lengths, or percents. */</comment>
    <expr_stmt><expr><name>variantIndex</name> = <name>eMatrix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>aMinElems</name> = 6U</expr>;</expr_stmt>
    <expr_stmt><expr><name>aMaxElems</name> = 6U</expr>;</expr_stmt>
    <break>break;</break>    
  </case><default>default:
    <comment type="block">/* Oh dear, we didn't match.  Report an error. */</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </default>}</block></switch>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aMinElems</name> &gt; 0</expr></argument>, <argument><expr>"Didn't update minimum elements!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aMaxElems</name> &gt; 0</expr></argument>, <argument><expr>"Didn't update maximum elements!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aMinElems</name> &lt;= <name>aMaxElems</name></expr></argument>, <argument><expr>"aMinElems &gt; aMaxElems!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>variantIndex</name> &gt;= 0</expr></argument>, <argument><expr>"Invalid variant mask!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>variantIndex</name> &lt; <name>eNumVariantMasks</name></expr></argument>, <argument><expr>"Invalid variant mask!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aMaxElems</name> &lt;= <name><name>kVariantMaskLengths</name><index>[<expr><name>variantIndex</name></expr>]</index></name></expr></argument>,
               <argument><expr>"Invalid aMaxElems for this variant mask."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Convert the index into a mask.</comment>
  <expr_stmt><expr><name>aVariantMask</name> = <name><name>kVariantMasks</name><index>[<expr><name>variantIndex</name></expr>]</index></name></expr>;</expr_stmt>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/* Reads a single transform function from the tokenizer stream, reporting an
 * error if something goes wrong.
 */</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseSingleTransform</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_Function</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><specifier>const</specifier> <name>PRInt32</name>*</type> <name>variantMask</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint16</name></type> <name>minElems</name></decl>, <decl><type ref="prev"/><name>maxElems</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>GetFunctionParseInformation</name><argument_list>(<argument><expr><call><name><name>nsCSSKeywords</name>::<name>LookupKeyword</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>minElems</name></expr></argument>, <argument><expr><name>maxElems</name></expr></argument>, <argument><expr><name>variantMask</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <return>return <expr><call><name>ParseFunction</name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>, <argument><expr><name>variantMask</name></expr></argument>, <argument><expr><name>minElems</name></expr></argument>, <argument><expr><name>maxElems</name></expr></argument>, <argument><expr><name>aValue</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Parses a -moz-transform property list by continuously reading in properties
 * and constructing a matrix from it.
 */</comment>
<function><type><name>PRBool</name></type> <name><name>CSSParserImpl</name>::<name>ParseMozTransform</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name> | <name>VARIANT_NONE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'inherit', 'initial', and 'none' must be alone</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>cur</name> <init>= <expr><call><name><name>value</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>ParseSingleTransform</name><argument_list>(<argument><expr><name><name>cur</name>-&gt;<name>mValue</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty__moz_transform</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>CSSParserImpl</name>::<name>ParseMozTransformOrigin</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValuePair</name></type> <name>position</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseBoxPositionValues</name><argument_list>(<argument><expr><name>position</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> || !<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <comment type="line">// Unlike many other uses of pairs, this position should always be stored</comment>
  <comment type="line">// as a pair, even if the values are the same, so it always serializes as</comment>
  <comment type="line">// a pair, and to keep the computation code simple.</comment>
  <if>if <condition>(<expr><call><name><name>position</name>.<name>mXValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Inherit</name> ||
      <call><name><name>position</name>.<name>mXValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Initial</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name><name>position</name>.<name>mXValue</name></name> == <name><name>position</name>.<name>mYValue</name></name></expr></argument>,
                      <argument><expr>"inherit/initial only half?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty__moz_transform_origin</name></expr></argument>, <argument><expr><name><name>position</name>.<name>mXValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>pair</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pair</name>.<name>SetPairValue</name></name><argument_list>(<argument><expr>&amp;<name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty__moz_transform_origin</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFamily</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>eCSSToken_Ident</name> == <name><name>mToken</name>.<name>mType</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsCSSKeyword</name></type> <name>keyword</name> <init>= <expr><call><name><name>nsCSSKeywords</name>::<name>LookupKeyword</name></name><argument_list>(<argument><expr><name><name>mToken</name>.<name>mIdent</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>keyword</name> == <name>eCSSKeyword_inherit</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aValue</name>.<name>SetInheritValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>keyword</name> == <name>eCSSKeyword__moz_initial</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aValue</name>.<name>SetInitialValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>keyword</name> == <name>eCSSKeyword__moz_use_system_font</name> &amp;&amp;
        !<call><name>IsParsingCompoundProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aValue</name>.<name>SetSystemFontValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsAutoString</name></type> <name>family</name></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>ParseOneFamily</name><argument_list>(<argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>

    <expr_stmt><expr><call><name><name>family</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>PRUnichar</name><argument_list>(<argument><expr>','</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <if>if <condition>(<expr><call><name><name>family</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>aValue</name>.<name>SetStringValue</name></name><argument_list>(<argument><expr><name>family</name></expr></argument>, <argument><expr><name>eCSSUnit_Families</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// src: ( uri-src | local-src ) (',' ( uri-src | local-src ) )*</comment>
<comment type="line">// uri-src: uri [ 'format(' string ( ',' string )* ')' ]</comment>
<comment type="line">// local-src: 'local(' ( string | ident ) ')'</comment>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFontSrc</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// could we maybe turn nsCSSValue::Array into nsTArray&lt;nsCSSValue&gt;?</comment>
  <decl_stmt><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsCSSValue</name></expr></argument>&gt;</argument_list></name></type> <name>values</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>cur</name></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>

    <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Function</name> &amp;&amp;
        <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"url"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>!<call><name>ParseURL</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
      <expr_stmt><expr><call><name><name>values</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<call><name>ParseFontSrcFormat</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    }</block></then> <else>else <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Function</name> &amp;&amp;
               <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"local"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// css3-fonts does not specify a formal grammar for local().</comment>
      <comment type="line">// The text permits both unquoted identifiers and quoted</comment>
      <comment type="line">// strings.  We resolve this ambiguity in the spec by</comment>
      <comment type="line">// assuming that the appropriate production is a single</comment>
      <comment type="line">// &lt;family-name&gt;, possibly surrounded by whitespace.</comment>

      <decl_stmt><decl><type><name>nsAutoString</name></type> <name>family</name></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<call><name>ParseOneFamily</name><argument_list>(<argument><expr><name>family</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>

      <comment type="line">// the style parameters to the nsFont constructor are ignored,</comment>
      <comment type="line">// because it's only being used to call EnumerateFamilies</comment>
      <decl_stmt><decl><type><name>nsFont</name></type> <name>font</name><argument_list>(<argument><expr><name>family</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ExtractFirstFamilyData</name></type> <name>dat</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name><name>font</name>.<name>EnumerateFamilies</name></name><argument_list>(<argument><expr><name>ExtractFirstFamily</name></expr></argument>, <argument><expr>(<name>void</name>*) &amp;<name>dat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name><name>dat</name>.<name>mGood</name></name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

      <expr_stmt><expr><call><name><name>cur</name>.<name>SetStringValue</name></name><argument_list>(<argument><expr><name><name>dat</name>.<name>mFamilyName</name></name></expr></argument>, <argument><expr><name>eCSSUnit_Local_Font</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>values</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></else></if></else></if>

    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>
  }</block></for>

  <if>if <condition>(<expr><call><name><name>values</name>.<name>Length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>srcVals</name>
    <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr><call><name><name>values</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>srcVals</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name><name>values</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <expr_stmt><expr><call><name><name>srcVals</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> = <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
  <expr_stmt><expr><call><name><name>aValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>srcVals</name></expr></argument>, <argument><expr><name>eCSSUnit_Array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFontSrcFormat</name></name><parameter_list>(<param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsCSSValue</name></expr></argument>&gt;</argument_list></name> &amp;</type> <name>values</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if> <comment type="line">// EOF harmless here</comment>
  <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_Function</name> ||
      !<call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"format"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <do>do <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if> <comment type="line">// EOF - no need for SkipUntil</comment>

    <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_String</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <function_decl><type><name>nsCSSValue</name></type> <name>cur</name><parameter_list>(<param><decl><type><name><name>mToken</name>.<name>mIdent</name></name></type></decl></param>, <param><decl><type><name>eCSSUnit_Font_Format</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name><name>values</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block> while <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

  <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>')'</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SkipUntil</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="line">// font-ranges: urange ( ',' urange )*</comment>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseFontRanges</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>PRUint32</name></expr></argument>&gt;</argument_list></name></type> <name>ranges</name></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>

    <if>if <condition>(<expr><name><name>mToken</name>.<name>mType</name></name> != <name>eCSSToken_URange</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>UngetToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>

    <comment type="line">// An invalid range token is a parsing error, causing the entire</comment>
    <comment type="line">// descriptor to be ignored.</comment>
    <if>if <condition>(<expr>!<name><name>mToken</name>.<name>mIntegerValid</name></name></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>low</name> <init>= <expr><name><name>mToken</name>.<name>mInteger</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>high</name> <init>= <expr><name><name>mToken</name>.<name>mInteger2</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// A range that descends, or a range that is entirely outside the</comment>
    <comment type="line">// current range of Unicode (U+0-10FFFF) is ignored, but does not</comment>
    <comment type="line">// invalidate the descriptor.  A range that straddles the high end</comment>
    <comment type="line">// is clipped.</comment>
    <if>if <condition>(<expr><name>low</name> &lt;= 0x10FFFF &amp;&amp; <name>low</name> &lt;= <name>high</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>high</name> &gt; 0x10FFFF</expr>)</condition><then>
        <expr_stmt><expr><name>high</name> = 0x10FFFF</expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name><name>ranges</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>low</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>ranges</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>
  }</block></for>

  <if>if <condition>(<expr><call><name><name>ranges</name>.<name>Length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>srcVals</name>
    <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr><call><name><name>ranges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>srcVals</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>ranges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <expr_stmt><expr><call><name><name>srcVals</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name><name>ranges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>eCSSUnit_Integer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
  <expr_stmt><expr><call><name><name>aValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>srcVals</name></expr></argument>, <argument><expr><name>eCSSUnit_Array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseListStyle</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// 'list-style' can accept 'none' for two different subproperties,</comment>
  <comment type="line">// 'list-style-type' and 'list-style-position'.  In order to accept</comment>
  <comment type="line">// 'none' as the value of either but still allow another value for</comment>
  <comment type="line">// either, we need to ensure that the first 'none' we find gets</comment>
  <comment type="line">// allocated to a dummy property instead.</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>listStyleIDs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSPropertyExtra_x_none_value</name></expr>,
    <expr><name>eCSSProperty_list_style_type</name></expr>,
    <expr><name>eCSSProperty_list_style_position</name></expr>,
    <expr><name>eCSSProperty_list_style_image</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name><name>values</name><index>[<expr><call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>listStyleIDs</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>found</name> <init>=
    <expr><call><name>ParseChoice</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>listStyleIDs</name></expr></argument>, <argument><expr><call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>listStyleIDs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>found</name> &lt; 1 || !<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>(<name>found</name> &amp; (1|2|8)) == (1|2|8)</expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name><name>values</name><index>[<expr>0</expr>]</index></name>.<call><name>GetUnit</name><argument_list>()</argument_list></call> == <name>eCSSUnit_None</name></expr>)</condition><then> <block>{
      <comment type="line">// We found a 'none' plus another value for both of</comment>
      <comment type="line">// 'list-style-type' and 'list-style-image'.  This is a parse</comment>
      <comment type="line">// error, since the 'none' has to count for at least one of them.</comment>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>found</name> == (1|2|4|8) &amp;&amp; <name><name>values</name><index>[<expr>0</expr>]</index></name> == <name><name>values</name><index>[<expr>1</expr>]</index></name> &amp;&amp;
                   <name><name>values</name><index>[<expr>0</expr>]</index></name> == <name><name>values</name><index>[<expr>2</expr>]</index></name> &amp;&amp; <name><name>values</name><index>[<expr>0</expr>]</index></name> == <name><name>values</name><index>[<expr>3</expr>]</index></name></expr></argument>,
                   <argument><expr>"should be a special value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <comment type="line">// Provide default values</comment>
  <if>if <condition>(<expr>(<name>found</name> &amp; 2) == 0</expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>found</name> &amp; 1</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>values</name><index>[<expr>1</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_LIST_STYLE_NONE</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name><name>values</name><index>[<expr>1</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_LIST_STYLE_DISC</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 4) == 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>values</name><index>[<expr>2</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_LIST_STYLE_POSITION_OUTSIDE</name></expr></argument>,
                          <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 8) == 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>values</name><index>[<expr>3</expr>]</index></name>.<call><name>SetNoneValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Start at 1 to avoid appending fake value.</comment>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>index</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>index</name> &lt; <call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>listStyleIDs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>index</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>listStyleIDs</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseMargin</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kMarginSideIDs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSProperty_margin_top</name></expr>,
    <expr><name>eCSSProperty_margin_right_value</name></expr>,
    <expr><name>eCSSProperty_margin_bottom</name></expr>,
    <expr><name>eCSSProperty_margin_left_value</name></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kMarginSources</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSProperty_margin_left_ltr_source</name></expr>,
    <expr><name>eCSSProperty_margin_left_rtl_source</name></expr>,
    <expr><name>eCSSProperty_margin_right_ltr_source</name></expr>,
    <expr><name>eCSSProperty_margin_right_rtl_source</name></expr>,
    <expr><name>eCSSProperty_UNKNOWN</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <comment type="line">// do this now, in case 4 values weren't specified</comment>
  <expr_stmt><expr><call><name>InitBoxPropsAsPhysical</name><argument_list>(<argument><expr><name>kMarginSources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ParseBoxProperties</name><argument_list>(<argument><expr><name>kMarginSideIDs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseMarks</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kPageMarksKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>eCSSUnit_Enumerated</name> == <call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>NS_STYLE_PAGE_MARKS_NONE</name> != <call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call> &amp;&amp;
          <name>PR_FALSE</name> == <call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>second</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>ParseEnum</name><argument_list>(<argument><expr><name>second</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kPageMarksKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// 'none' keyword in conjuction with others is not allowed</comment>
          <if>if <condition>(<expr><name>NS_STYLE_PAGE_MARKS_NONE</name> != <call><name><name>second</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>aValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call> | <call><name><name>second</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>PR_TRUE</name></expr>;</return>
          }</block></then></if>
        }</block></then></if>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseOutline</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name>numProps</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kOutlineIDs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSProperty_outline_color</name></expr>,
    <expr><name>eCSSProperty_outline_style</name></expr>,
    <expr><name>eCSSProperty_outline_width</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsCSSValue</name></type>  <name><name>values</name><index>[<expr><name>numProps</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>found</name> <init>= <expr><call><name>ParseChoice</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>kOutlineIDs</name></expr></argument>, <argument><expr><name>numProps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>found</name> &lt; 1) || (<name>PR_FALSE</name> == <call><name>ExpectEndProperty</name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Provide default values</comment>
  <if>if <condition>(<expr>(<name>found</name> &amp; 1) == 0</expr>)</condition><then> <block>{ <comment type="line">// Provide default outline-color</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GFX_HAS_INVERT</name></cpp:ifdef>
    <expr_stmt><expr><name><name>values</name><index>[<expr>0</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_COLOR_INVERT</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>values</name><index>[<expr>0</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 2) == 0</expr>)</condition><then> <block>{ <comment type="line">// Provide default outline-style</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>1</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_BORDER_STYLE_NONE</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>found</name> &amp; 4) == 0</expr>)</condition><then> <block>{ <comment type="line">// Provide default outline-width</comment>
    <expr_stmt><expr><name><name>values</name><index>[<expr>2</expr>]</index></name>.<call><name>SetIntValue</name><argument_list>(<argument><expr><name>NS_STYLE_BORDER_WIDTH_MEDIUM</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>index</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name>index</name> &lt; <name>numProps</name></expr>;</condition> <incr><expr><name>index</name>++</expr></incr>) <block>{
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>kOutlineIDs</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseOverflow</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>overflow</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>overflow</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>,
                    <argument><expr><name><name>nsCSSProps</name>::<name>kOverflowKTable</name></name></expr></argument>)</argument_list></call> ||
      !<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <function_decl><type><name>nsCSSValue</name></type> <name>overflowX</name><parameter_list>(<param><decl><type><name>overflow</name></type></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsCSSValue</name></type> <name>overflowY</name><parameter_list>(<param><decl><type><name>overflow</name></type></decl></param>)</parameter_list>;</function_decl>
  <if>if <condition>(<expr><name>eCSSUnit_Enumerated</name> == <call><name><name>overflow</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <switch>switch<condition>(<expr><call><name><name>overflow</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
      <case>case <expr><name>NS_STYLE_OVERFLOW_SCROLLBARS_HORIZONTAL</name></expr>:
        <expr_stmt><expr><call><name><name>overflowX</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>NS_STYLE_OVERFLOW_SCROLL</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>overflowY</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>NS_STYLE_OVERFLOW_HIDDEN</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>NS_STYLE_OVERFLOW_SCROLLBARS_VERTICAL</name></expr>:
        <expr_stmt><expr><call><name><name>overflowX</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>NS_STYLE_OVERFLOW_HIDDEN</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>overflowY</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>NS_STYLE_OVERFLOW_SCROLL</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case>}</block></switch></then></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_overflow_x</name></expr></argument>, <argument><expr><name>overflowX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_overflow_y</name></expr></argument>, <argument><expr><name>overflowY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParsePadding</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kPaddingSideIDs</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSProperty_padding_top</name></expr>,
    <expr><name>eCSSProperty_padding_right_value</name></expr>,
    <expr><name>eCSSProperty_padding_bottom</name></expr>,
    <expr><name>eCSSProperty_padding_left_value</name></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kPaddingSources</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSProperty_padding_left_ltr_source</name></expr>,
    <expr><name>eCSSProperty_padding_left_rtl_source</name></expr>,
    <expr><name>eCSSProperty_padding_right_ltr_source</name></expr>,
    <expr><name>eCSSProperty_padding_right_rtl_source</name></expr>,
    <expr><name>eCSSProperty_UNKNOWN</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <comment type="line">// do this now, in case 4 values weren't specified</comment>
  <expr_stmt><expr><call><name>InitBoxPropsAsPhysical</name><argument_list>(<argument><expr><name>kPaddingSources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ParseBoxProperties</name><argument_list>(<argument><expr><name>kPaddingSideIDs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParsePause</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type>  <name>before</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name>before</name></expr></argument>, <argument><expr><name>eCSSProperty_pause_before</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>eCSSUnit_Inherit</name> != <call><name><name>before</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>eCSSUnit_Initial</name> != <call><name><name>before</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>after</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name>after</name></expr></argument>, <argument><expr><name>eCSSProperty_pause_after</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_pause_before</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_pause_after</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_TRUE</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_pause_before</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_pause_after</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseQuotes</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_HOS</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><call><name><name>value</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_String</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>open</name> <init>= <expr><name>value</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCSSValuePairList</name>*</type> <name>quotes</name> <init>= <expr><call><name><name>value</name>.<name>SetPairListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <expr_stmt><expr><name><name>quotes</name>-&gt;<name>mXValue</name></name> = <name>open</name></expr>;</expr_stmt>
      <comment type="line">// get mandatory close</comment>
      <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>quotes</name>-&gt;<name>mYValue</name></name></expr></argument>, <argument><expr><name>VARIANT_STRING</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <comment type="line">// look for another open</comment>
      <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>open</name></expr></argument>, <argument><expr><name>VARIANT_STRING</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>quotes</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValuePairList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>quotes</name> = <name><name>quotes</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_quotes</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseSize</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>width</name></decl>, <decl><type ref="prev"/><name>height</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>width</name></expr></argument>, <argument><expr><name>VARIANT_AHKL</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kPageSizeKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><call><name><name>width</name>.<name>IsLengthUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>height</name></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>width</name> == <name>height</name> || <call><name><name>height</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Null</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_size</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>pair</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pair</name>.<name>SetPairValue</name></name><argument_list>(<argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_size</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseTextDecoration</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>VARIANT_HK</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kTextDecorationKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>eCSSUnit_Enumerated</name> == <call><name><name>aValue</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>intValue</name> <init>= <expr><call><name><name>aValue</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>intValue</name> != <name>NS_STYLE_TEXT_DECORATION_NONE</name></expr>)</condition><then> <block>{
        <comment type="line">// look for more keywords</comment>
        <decl_stmt><decl><type><name>nsCSSValue</name></type>  <name>keyword</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>index</name></decl>;</decl_stmt>
        <for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name>index</name> &lt; 3</expr>;</condition> <incr><expr><name>index</name>++</expr></incr>) <block>{
          <if>if <condition>(<expr><call><name>ParseEnum</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name><name>nsCSSProps</name>::<name>kTextDecorationKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PRInt32</name></type> <name>newValue</name> <init>= <expr><call><name><name>keyword</name>.<name>GetIntValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>newValue</name> == <name>NS_STYLE_TEXT_DECORATION_NONE</name> ||
                <name>newValue</name> &amp; <name>intValue</name></expr>)</condition><then> <block>{
              <comment type="line">// 'none' keyword in conjuction with others is not allowed, and</comment>
              <comment type="line">// duplicate keyword is not allowed.</comment>
              <return>return <expr><name>PR_FALSE</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>intValue</name> |= <name>newValue</name></expr>;</expr_stmt>
          }</block></then>
          <else>else <block>{
            <break>break;</break>
          }</block></else></if>
        }</block></for>
        <expr_stmt><expr><call><name><name>aValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>intValue</name></expr></argument>, <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>


<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseTransitionTime</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'inherit' and 'initial' must be alone</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>cur</name> <init>= <expr><call><name><name>value</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cur</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>VARIANT_TIME</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseTransitionProperty</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name> | <name>VARIANT_NONE</name> | <name>VARIANT_ALL</name></expr></argument>,
                   <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'inherit', 'initial', 'none', and 'all' must be alone</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <comment type="line">// Accept a list of arbitrary identifiers.  They should be</comment>
    <comment type="line">// CSS properties, but we want to accept any so that we</comment>
    <comment type="line">// accept properties that we don't know about yet, e.g.</comment>
    <comment type="line">// transition-property: invalid-property, left, opacity;</comment>
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>cur</name> <init>= <expr><call><name><name>value</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cur</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>VARIANT_IDENTIFIER</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <decl_stmt><decl><type><name>nsDependentString</name></type> <name>str</name><argument_list>(<argument><expr><call><name><name>cur</name>-&gt;<name>mValue</name>.<name>GetStringBufferValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
      <comment type="line">// Exclude 'none' and 'all' and 'inherit' and 'initial'</comment>
      <comment type="line">// according to the same rules as for 'counter-reset' in CSS 2.1</comment>
      <comment type="line">// (except 'counter-reset' doesn't exclude 'all' since it</comment>
      <comment type="line">// doesn't support 'all' as a special value).</comment>
      <if>if <condition>(<expr><call><name><name>str</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"none"</expr></argument>)</argument_list></call> ||
          <call><name><name>str</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"all"</expr></argument>)</argument_list></call> ||
          <call><name><name>str</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"inherit"</expr></argument>)</argument_list></call> ||
          <call><name><name>str</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"initial"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>REPORT_UNEXPECTED_TOKEN</name><argument_list>(<argument><expr><name>PEExpectedComma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_transition_property</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseTransitionTimingFunction</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'inherit' and 'initial' must be alone</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>cur</name> <init>= <expr><call><name><name>value</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cur</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>VARIANT_TIMING_FUNCTION</name></expr></argument>,
                        <argument><expr><name><name>nsCSSProps</name>::<name>kTransitionTimingFunctionKTable</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_transition_timing_function</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseTransitionTimingFunctionValues</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mHavePushBack</name> &amp;&amp;
               <name><name>mToken</name>.<name>mType</name></name> == <name>eCSSToken_Function</name> &amp;&amp;
               <call><name><name>mToken</name>.<name>mIdent</name>.<name>LowerCaseEqualsLiteral</name></name><argument_list>(<argument><expr>"cubic-bezier"</expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr>"unexpected initial state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>val</name> <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>val</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mScanner</name>.<name>SetLowLevelError</name></name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>float</name></type> <name>x1</name></decl>, <decl><type ref="prev"/><name>x2</name></decl>, <decl><type ref="prev"/><name>y1</name></decl>, <decl><type ref="prev"/><name>y2</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseTransitionTimingFunctionValueComponent</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> ||
      !<call><name>ParseTransitionTimingFunctionValueComponent</name><argument_list>(<argument><expr><name>y1</name></expr></argument>, <argument><expr>','</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call> ||
      !<call><name>ParseTransitionTimingFunctionValueComponent</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call> ||
      !<call><name>ParseTransitionTimingFunctionValueComponent</name><argument_list>(<argument><expr><name>y2</name></expr></argument>, <argument><expr>')'</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>.<call><name>SetFloatValue</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>eCSSUnit_Number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call>.<call><name>SetFloatValue</name><argument_list>(<argument><expr><name>y1</name></expr></argument>, <argument><expr><name>eCSSUnit_Number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call>.<call><name>SetFloatValue</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>eCSSUnit_Number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call>.<call><name>SetFloatValue</name><argument_list>(<argument><expr><name>y2</name></expr></argument>, <argument><expr><name>eCSSUnit_Number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>aValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>eCSSUnit_Cubic_Bezier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseTransitionTimingFunctionValueComponent</name></name><parameter_list>(<param><decl><type><name>float</name>&amp;</type> <name>aComponent</name></decl></param>,
                                                           <param><decl><type><name>char</name></type> <name>aStop</name></decl></param>,
                                                           <param><decl><type><name>PRBool</name></type> <name>aCheckRange</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>GetToken</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsCSSToken</name>*</type> <name>tk</name> <init>= <expr>&amp;<name>mToken</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>tk</name>-&gt;<name>mType</name></name> == <name>eCSSToken_Number</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>float</name></type> <name>num</name> <init>= <expr><name><name>tk</name>-&gt;<name>mNumber</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>aCheckRange</name> &amp;&amp; (<name><name>num</name> <argument_list>&lt; <argument><expr>0.0 || <name>num</name></expr></argument> &gt;</argument_list></name> 1.0)</expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>aComponent</name> = <name>num</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr><name>aStop</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsCSSValueList</name>*</type>
<name>AppendValueToList</name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aContainer</name></decl></param>,
                  <param><decl><type><name>nsCSSValueList</name>*</type> <name>aTail</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>entry</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>aContainer</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Null</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr>!<name>aTail</name></expr></argument>, <argument><expr>"should not have an entry"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>entry</name> = <call><name><name>aContainer</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr>!<name><name>aTail</name>-&gt;<name>mNext</name></name></expr></argument>, <argument><expr>"should not have a next entry"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name><name>aContainer</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_List</name></expr></argument>, <argument><expr>"not a list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>entry</name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aTail</name>-&gt;<name>mNext</name></name> = <name>entry</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name><name>entry</name>-&gt;<name>mValue</name></name> = <name>aValue</name></expr>;</expr_stmt>
  <return>return <expr><name>entry</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseTransition</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsCSSProperty</name></type> <name><name>kTransitionProperties</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name>eCSSProperty_transition_duration</name></expr>,
    <expr><name>eCSSProperty_transition_timing_function</name></expr>,
    <comment type="line">// Must check 'transition-delay' after 'transition-duration', since</comment>
    <comment type="line">// that's our assumption about what the spec means for the shorthand</comment>
    <comment type="line">// syntax (the first time given is the duration, and the second</comment>
    <comment type="line">// given is the delay).</comment>
    <expr><name>eCSSProperty_transition_delay</name></expr>,
    <comment type="line">// Must check 'transition-property' after</comment>
    <comment type="line">// 'transition-timing-function' since 'transition-property' accepts</comment>
    <comment type="line">// any keyword.</comment>
    <expr><name>eCSSProperty_transition_property</name></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PRUint32</name></type> <name>numProps</name> <init>= <expr><call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>kTransitionProperties</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// this is a shorthand property that accepts -property, -delay,</comment>
  <comment type="line">// -duration, and -timing-function with some components missing.</comment>
  <comment type="line">// there can be multiple transitions, separated with commas</comment>

  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>tempValue</name></decl>;</decl_stmt>
  <comment type="line">// first see if 'inherit' or '-moz-initial' is specified.  If one is,</comment>
  <comment type="line">// it can be the only thing specified, so don't attempt to parse any</comment>
  <comment type="line">// additional properties</comment>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>tempValue</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>numProps</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>kTransitionProperties</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tempValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name><name>values</name><index>[<expr><name>numProps</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsCSSValueList</name> *</type><name><name>cur</name><index>[<expr><name>numProps</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>nsnull</name></expr>, <expr><name>nsnull</name></expr>, <expr><name>nsnull</name></expr>, <expr><name>nsnull</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>atEOP</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt> <comment type="line">// at end of property?</comment>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{ <comment type="line">// loop over comma-separated transitions</comment>
    <comment type="line">// whether a particular subproperty was specified for this transition</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name><name>parsedProperty</name><index>[<expr><name>numProps</name></expr>]</index></name> <init>=
      <expr><block>{ <expr><name>PR_FALSE</name></expr>, <expr><name>PR_FALSE</name></expr>, <expr><name>PR_FALSE</name></expr>, <expr><name>PR_FALSE</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{ <comment type="line">// loop over values within a transition</comment>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>foundProperty</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
      <comment type="line">// check to see if we're at the end of one full transition definition</comment>
      <comment type="line">// (either because we hit a comma or because we hit the end of the</comment>
      <comment type="line">// property definition)</comment>
      <if>if <condition>(<expr><call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>atEOP</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>

      <comment type="line">// else, try to parse the next transition sub-property</comment>
      <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr>!<name>foundProperty</name> &amp;&amp; <name>i</name> &lt; <name>numProps</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<name><name>parsedProperty</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
          <comment type="line">// if we haven't found this property yet, try to parse it</comment>
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>variantMask</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>PRInt32</name>*</type> <name>table</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
          <switch>switch <condition>(<expr><name><name>kTransitionProperties</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{
            <case>case <expr><name>eCSSProperty_transition_property</name></expr>:
              <expr_stmt><expr><name>variantMask</name> = <name>VARIANT_IDENTIFIER</name> | <name>VARIANT_NONE</name> | <name>VARIANT_ALL</name></expr>;</expr_stmt>
              <break>break;</break>
            </case><case>case <expr><name>eCSSProperty_transition_duration</name></expr>:
            </case><case>case <expr><name>eCSSProperty_transition_delay</name></expr>:
              <expr_stmt><expr><name>variantMask</name> = <name>VARIANT_TIME</name></expr>;</expr_stmt>
              <break>break;</break>
            </case><case>case <expr><name>eCSSProperty_transition_timing_function</name></expr>:
              <expr_stmt><expr><name>variantMask</name> = <name>VARIANT_TIMING_FUNCTION</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>table</name> = <name><name>nsCSSProps</name>::<name>kTransitionTimingFunctionKTable</name></name></expr>;</expr_stmt>
              <break>break;</break>
            </case><default>default:
              <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"Invalid transition property"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </default>}</block></switch>
          <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>tempValue</name></expr></argument>, <argument><expr><name>variantMask</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>parsedProperty</name><index>[<expr><name>i</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cur</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>AppendValueToList</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>cur</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tempValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>foundProperty</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <break>break;</break> <comment type="line">// out of inner loop; continue looking for next sub-property</comment>
          }</block></then></if>
        }</block></then></if>
      }</block></for>
      <if>if <condition>(<expr>!<name>foundProperty</name></expr>)</condition><then> <block>{
        <comment type="line">// We're not at a ',' or at the end of the property, but we couldn't</comment>
        <comment type="line">// parse any of the sub-properties, so the declaration is invalid.</comment>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block></for>

    <comment type="line">// We hit the end of the property or the end of one transition</comment>
    <comment type="line">// definition, add its components to the list.</comment>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>numProps</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
      <comment type="line">// If all of the subproperties were not explicitly specified, fill</comment>
      <comment type="line">// in the missing ones with initial values.</comment>
      <if>if <condition>(<expr>!<name><name>parsedProperty</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name><name>kTransitionProperties</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{
          <case>case <expr><name>eCSSProperty_transition_property</name></expr>:
            <expr_stmt><expr><call><name><name>tempValue</name>.<name>SetAllValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>eCSSProperty_transition_duration</name></expr>:
          </case><case>case <expr><name>eCSSProperty_transition_delay</name></expr>:
            <expr_stmt><expr><call><name><name>tempValue</name>.<name>SetFloatValue</name></name><argument_list>(<argument><expr>0.0</expr></argument>, <argument><expr><name>eCSSUnit_Seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>eCSSProperty_transition_timing_function</name></expr>:
            <expr_stmt><expr><call><name><name>tempValue</name>.<name>SetIntValue</name></name><argument_list>(<argument><expr><name>NS_STYLE_TRANSITION_TIMING_FUNCTION_EASE</name></expr></argument>,
                                  <argument><expr><name>eCSSUnit_Enumerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><default>default:
            <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"Invalid transition property"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
        <expr_stmt><expr><name><name>cur</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>AppendValueToList</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>cur</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tempValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>atEOP</name></expr>)</condition><then>
      <break>break;</break></then></if>
    <comment type="line">// else we just hit a ',' so continue parsing the next compound transition</comment>
  }</block></for>

  <comment type="line">// Make two checks on the list for 'transition-property':</comment>
  <comment type="line">//   + If there is more than one item, then none of the items can be</comment>
  <comment type="line">//     'none' or 'all'.</comment>
  <comment type="line">//   + None of the items can be 'inherit' or 'initial' (this is the case,</comment>
  <comment type="line">//     like with counter-reset &amp;c., where CSS 2.1 specifies 'initial', so</comment>
  <comment type="line">//     we should check it without the -moz- prefix).</comment>
  <block>{
    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name><name>kTransitionProperties</name><index>[<expr>3</expr>]</index></name> ==
                        <name>eCSSProperty_transition_property</name></expr></argument>,
                      <argument><expr>"array index mismatch"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsCSSValueList</name> *</type><name>l</name> <init>= <expr><name><name>values</name><index>[<expr>3</expr>]</index></name>.<call><name>GetListValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>multipleItems</name> <init>= <expr>!!<name><name>l</name>-&gt;<name>mNext</name></name></expr></init></decl>;</decl_stmt>
    <do>do <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>nsCSSValue</name>&amp;</type> <name>val</name> <init>= <expr><name><name>l</name>-&gt;<name>mValue</name></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name><name>val</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_Ident</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name><name>val</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_None</name> ||
                          <call><name><name>val</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_All</name></expr></argument>, <argument><expr>"unexpected unit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>multipleItems</name></expr>)</condition><then> <block>{
          <comment type="line">// This is a syntax error.</comment>
          <return>return <expr><name>PR_FALSE</name></expr>;</return>
        }</block></then></if>

        <comment type="line">// Unbox a solitary 'none' or 'all'.</comment>
        <if>if <condition>(<expr><call><name><name>val</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_None</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>values</name><index>[<expr>3</expr>]</index></name>.<call><name>SetNoneValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><name><name>values</name><index>[<expr>3</expr>]</index></name>.<call><name>SetAllValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      }</block></then></if>
      <decl_stmt><decl><type><name>nsDependentString</name></type> <name>str</name><argument_list>(<argument><expr><call><name><name>val</name>.<name>GetStringBufferValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name><name>str</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"inherit"</expr></argument>)</argument_list></call> || <call><name><name>str</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"initial"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
    }</block> while <condition>(<expr>(<name>l</name> = <name><name>l</name>-&gt;<name>mNext</name></name>)</expr>)</condition>;</do>
  }</block>

  <comment type="line">// Save all parsed transition sub-properties in mTempData</comment>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>numProps</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name><name>kTransitionProperties</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseShadowItem</name></name><parameter_list>(<param><decl><type><name>nsCSSValue</name>&amp;</type> <name>aValue</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsBoxShadow</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// A shadow list item is an array, with entries in this sequence:</comment>
  <enum>enum <block>{
    <decl><name>IndexX</name></decl>,
    <decl><name>IndexY</name></decl>,
    <decl><name>IndexRadius</name></decl>,
    <decl><name>IndexSpread</name></decl>,  <comment type="line">// only for box-shadow</comment>
    <decl><name>IndexColor</name></decl>,
    <decl><name>IndexInset</name></decl>    <comment type="line">// only for box-shadow</comment>
  }</block>;</enum>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsCSSValue</name>::<name>Array</name></name></expr></argument>&gt;</argument_list></name></type> <name>val</name> <init>= <expr><call><name><name>nsCSSValue</name>::<name>Array</name>::<name>Create</name></name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>aIsBoxShadow</name></expr>)</condition><then> <block>{
    <comment type="line">// Optional inset keyword (ignore errors)</comment>
    <expr_stmt><expr><call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexInset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                 <argument><expr><name><name>nsCSSProps</name>::<name>kBoxShadowTypeKTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>xOrColor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>haveColor</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>xOrColor</name></expr></argument>, <argument><expr><name>VARIANT_COLOR</name> | <name>VARIANT_LENGTH</name> | <name>VARIANT_CALC</name></expr></argument>,
                    <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><call><name><name>xOrColor</name>.<name>IsLengthUnit</name></name><argument_list>()</argument_list></call> || <call><name><name>xOrColor</name>.<name>IsCalcUnit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexX</name></expr></argument>)</argument_list></call> = <name>xOrColor</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// Must be a color (as string or color value)</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>xOrColor</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Ident</name> ||
                 <call><name><name>xOrColor</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_Color</name> ||
                 <call><name><name>xOrColor</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_EnumColor</name></expr></argument>,
                 <argument><expr>"Must be a color value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexColor</name></expr></argument>)</argument_list></call> = <name>xOrColor</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>haveColor</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <comment type="line">// X coordinate mandatory after color</comment>
    <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name> | <name>VARIANT_CALC</name></expr></argument>,
                      <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></else></if>

  <comment type="line">// Y coordinate; mandatory</comment>
  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name> | <name>VARIANT_CALC</name></expr></argument>,
                    <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Optional radius. Ignore errors except if they pass a negative</comment>
  <comment type="line">// value which we must reject. If we use ParseNonNegativeVariant</comment>
  <comment type="line">// we can't tell the difference between an unspecified radius</comment>
  <comment type="line">// and a negative radius.</comment>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexRadius</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name> | <name>VARIANT_CALC</name></expr></argument>,
                   <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call> &amp;&amp;
      <call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexRadius</name></expr></argument>)</argument_list></call>.<call><name>IsLengthUnit</name><argument_list>()</argument_list></call> &amp;&amp;
      <call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexRadius</name></expr></argument>)</argument_list></call>.<call><name>GetFloatValue</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>aIsBoxShadow</name></expr>)</condition><then> <block>{
    <comment type="line">// Optional spread</comment>
    <expr_stmt><expr><call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexSpread</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_LENGTH</name> | <name>VARIANT_CALC</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>haveColor</name></expr>)</condition><then> <block>{
    <comment type="line">// Optional color</comment>
    <expr_stmt><expr><call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexColor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_COLOR</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>aIsBoxShadow</name> &amp;&amp; <call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexInset</name></expr></argument>)</argument_list></call>.<call><name>GetUnit</name><argument_list>()</argument_list></call> == <name>eCSSUnit_Null</name></expr>)</condition><then> <block>{
    <comment type="line">// Optional inset keyword</comment>
    <expr_stmt><expr><call><name>ParseVariant</name><argument_list>(<argument><expr><call><name><name>val</name>-&gt;<name>Item</name></name><argument_list>(<argument><expr><name>IndexInset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VARIANT_KEYWORD</name></expr></argument>,
                 <argument><expr><name><name>nsCSSProps</name>::<name>kBoxShadowTypeKTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>aValue</name>.<name>SetArrayValue</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>eCSSUnit_Array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseShadowList</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aProperty</name></decl></param>)</parameter_list>
<block>{
  <function_decl><type><name>nsAutoParseCompoundProperty</name></type> <name>compound</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isBoxShadow</name> <init>= <expr><name>aProperty</name> == <name>eCSSProperty_box_shadow</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name> | <name>VARIANT_NONE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'inherit', 'initial', and 'none' must be alone</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValueList</name>*</type> <name>cur</name> <init>= <expr><call><name><name>value</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>ParseShadowItem</name><argument_list>(<argument><expr><name><name>cur</name>-&gt;<name>mValue</name></name></expr></argument>, <argument><expr><name>isBoxShadow</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr>!<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>cur</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aProperty</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>CSSParserImpl</name>::<name>GetNamespaceIdForPrefix</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aPrefix</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name><name>aPrefix</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Must have a prefix here"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>nameSpaceID</name> <init>= <expr><name>kNameSpaceID_Unknown</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mNameSpaceMap</name></expr>)</condition><then> <block>{
    <comment type="line">// user-specified identifiers are case-sensitive (bug 416106)</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name></type> <name>prefix</name> <init>= <expr><call><name>do_GetAtom</name><argument_list>(<argument><expr><name>aPrefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nameSpaceID</name> = <call><name><name>mNameSpaceMap</name>-&gt;<name>FindNameSpaceID</name></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <comment type="line">// else no declared namespaces</comment>

  <if>if <condition>(<expr><name>nameSpaceID</name> == <name>kNameSpaceID_Unknown</name></expr>)</condition><then> <block>{   <comment type="line">// unknown prefix, dump it</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[]</index></name> <init>= <expr><block>{
      <macro><name>aPrefix</name></macro><expr>.<macro><name>get</name><argument_list>()</argument_list></macro></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>REPORT_UNEXPECTED_P</name><argument_list>(<argument><expr><name>PEUnknownNamespacePrefix</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mFoundUnresolvablePrefix</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>nameSpaceID</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>CSSParserImpl</name>::<name>SetDefaultNamespaceOnSelector</name></name><parameter_list>(<param><decl><type><name>nsCSSSelector</name>&amp;</type> <name>aSelector</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mNameSpaceMap</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aSelector</name>.<name>SetNameSpace</name></name><argument_list>(<argument><expr><call><name><name>mNameSpaceMap</name>-&gt;<name>FindNameSpaceID</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name><name>aSelector</name>.<name>SetNameSpace</name></name><argument_list>(<argument><expr><name>kNameSpaceID_Unknown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// wildcard</comment>
  }</block></else></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParsePaint</name></name><parameter_list>(<param><decl><type><name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>VARIANT_HC</name> | <name>VARIANT_NONE</name> | <name>VARIANT_URL</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <if>if <condition>(<expr><call><name><name>x</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eCSSUnit_URL</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>VARIANT_COLOR</name> | <name>VARIANT_NONE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>y</name>.<name>SetColorValue</name></name><argument_list>(<argument><expr><call><name>NS_RGB</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name><name>x</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> != <name>eCSSUnit_URL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>val</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>val</name>.<name>SetPairValue</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseDasharray</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>value</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseVariant</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>VARIANT_INHERIT</name> | <name>VARIANT_NONE</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// 'inherit', 'initial', and 'none' are only allowed on their own</comment>
    <if>if <condition>(<expr>!<call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsCSSValueList</name> *</type><name>cur</name> <init>= <expr><call><name><name>value</name>.<name>SetListValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
      <if>if <condition>(<expr>!<call><name>ParseVariant</name><argument_list>(<argument><expr><name><name>cur</name>-&gt;<name>mValue</name></name></expr></argument>,
                        <argument><expr><name>VARIANT_LENGTH</name> | <name>VARIANT_PERCENT</name> | <name>VARIANT_NUMBER</name></expr></argument>,
                        <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>CheckEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <comment type="line">// skip optional commas between elements</comment>
      <expr_stmt><expr>(<name>void</name>)<call><name>ExpectSymbol</name><argument_list>(<argument><expr>','</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>cur</name>-&gt;<name>mNext</name></name> = new <name>nsCSSValueList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>mNext</name></name></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_stroke_dasharray</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>CSSParserImpl</name>::<name>ParseMarker</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsCSSValue</name></type> <name>marker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>ParseSingleValueProperty</name><argument_list>(<argument><expr><name>marker</name></expr></argument>, <argument><expr><name>eCSSProperty_marker_end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>ExpectEndProperty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_marker_end</name></expr></argument>, <argument><expr><name>marker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_marker_mid</name></expr></argument>, <argument><expr><name>marker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>AppendValue</name><argument_list>(<argument><expr><name>eCSSProperty_marker_start</name></expr></argument>, <argument><expr><name>marker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></namespace> <comment type="line">// anonymous namespace</comment>

<comment type="line">// Recycling of parser implementation objects</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>CSSParserImpl</name>*</type> <name>gFreeList</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

<constructor><name><name>nsCSSParser</name>::<name>nsCSSParser</name></name><parameter_list>(<param><decl><type><name><name>mozilla</name>::<name>css</name>::<name>Loader</name></name>*</type> <name>aLoader</name></decl></param>,
                         <param><decl><type><name>nsCSSStyleSheet</name>*</type> <name>aSheet</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>CSSParserImpl</name> *</type><name>impl</name> <init>= <expr><name>gFreeList</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>impl</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>gFreeList</name> = <name><name>impl</name>-&gt;<name>mNextFree</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>impl</name>-&gt;<name>mNextFree</name></name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>impl</name> = new <call><name>CSSParserImpl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <if>if <condition>(<expr><name>aLoader</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>impl</name>-&gt;<name>SetChildLoader</name></name><argument_list>(<argument><expr><name>aLoader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>impl</name>-&gt;<name>SetQuirkMode</name></name><argument_list>(<argument><expr><call><name><name>aLoader</name>-&gt;<name>GetCompatibilityMode</name></name><argument_list>()</argument_list></call> ==
                       <name>eCompatibility_NavQuirks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>aSheet</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>impl</name>-&gt;<name>SetStyleSheet</name></name><argument_list>(<argument><expr><name>aSheet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>mImpl</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>nsCSSParser</name>::~<name>nsCSSParser</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>CSSParserImpl</name> *</type><name>impl</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>impl</name>-&gt;<name>Reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>impl</name>-&gt;<name>mNextFree</name></name> = <name>gFreeList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>gFreeList</name> = <name>impl</name></expr>;</expr_stmt>
}</block></destructor>

<comment type="block">/* static */</comment> <function><type><name>void</name></type>
<name><name>nsCSSParser</name>::<name>Shutdown</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>CSSParserImpl</name> *</type><name>tofree</name> <init>= <expr><name>gFreeList</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CSSParserImpl</name> *</type><name>next</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>tofree</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><name>next</name> = <name><name>tofree</name>-&gt;<name>mNextFree</name></name></expr>;</expr_stmt>
      <expr_stmt><expr>delete <name>tofree</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tofree</name> = <name>next</name></expr>;</expr_stmt>
    }</block></while>
}</block></function>

<comment type="line">// Wrapper methods</comment>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>SetStyleSheet</name></name><parameter_list>(<param><decl><type><name>nsCSSStyleSheet</name>*</type> <name>aSheet</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>SetStyleSheet</name><argument_list>(<argument><expr><name>aSheet</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>SetQuirkMode</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aQuirkMode</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>SetQuirkMode</name><argument_list>(<argument><expr><name>aQuirkMode</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>  <name>MOZ_SVG</name></cpp:ifdef>
<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>SetSVGMode</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aSVGMode</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>SetSVGMode</name><argument_list>(<argument><expr><name>aSVGMode</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>SetChildLoader</name></name><parameter_list>(<param><decl><type><name><name>mozilla</name>::<name>css</name>::<name>Loader</name></name>*</type> <name>aChildLoader</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>SetChildLoader</name><argument_list>(<argument><expr><name>aChildLoader</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>Parse</name></name><parameter_list>(<param><decl><type><name>nsIUnicharInputStream</name>*</type> <name>aInput</name></decl></param>,
                   <param><decl><type><name>nsIURI</name>*</type>                <name>aSheetURI</name></decl></param>,
                   <param><decl><type><name>nsIURI</name>*</type>                <name>aBaseURI</name></decl></param>,
                   <param><decl><type><name>nsIPrincipal</name>*</type>          <name>aSheetPrincipal</name></decl></param>,
                   <param><decl><type><name>PRUint32</name></type>               <name>aLineNumber</name></decl></param>,
                   <param><decl><type><name>PRBool</name></type>                 <name>aAllowUnsafeRules</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>Parse</name><argument_list>(<argument><expr><name>aInput</name></expr></argument>, <argument><expr><name>aSheetURI</name></expr></argument>, <argument><expr><name>aBaseURI</name></expr></argument>, <argument><expr><name>aSheetPrincipal</name></expr></argument>, <argument><expr><name>aLineNumber</name></expr></argument>,
          <argument><expr><name>aAllowUnsafeRules</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>ParseStyleAttribute</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type>  <name>aAttributeValue</name></decl></param>,
                                 <param><decl><type><name>nsIURI</name>*</type>           <name>aDocURI</name></decl></param>,
                                 <param><decl><type><name>nsIURI</name>*</type>           <name>aBaseURI</name></decl></param>,
                                 <param><decl><type><name>nsIPrincipal</name>*</type>     <name>aNodePrincipal</name></decl></param>,
                                 <param><decl><type><name>nsICSSStyleRule</name>**</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>ParseStyleAttribute</name><argument_list>(<argument><expr><name>aAttributeValue</name></expr></argument>, <argument><expr><name>aDocURI</name></expr></argument>, <argument><expr><name>aBaseURI</name></expr></argument>,
                        <argument><expr><name>aNodePrincipal</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>ParseDeclarations</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type>  <name>aBuffer</name></decl></param>,
                               <param><decl><type><name>nsIURI</name>*</type>           <name>aSheetURI</name></decl></param>,
                               <param><decl><type><name>nsIURI</name>*</type>           <name>aBaseURI</name></decl></param>,
                               <param><decl><type><name>nsIPrincipal</name>*</type>     <name>aSheetPrincipal</name></decl></param>,
                               <param><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type> <name>aDeclaration</name></decl></param>,
                               <param><decl><type><name>PRBool</name>*</type>           <name>aChanged</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>ParseDeclarations</name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aSheetURI</name></expr></argument>, <argument><expr><name>aBaseURI</name></expr></argument>, <argument><expr><name>aSheetPrincipal</name></expr></argument>,
                      <argument><expr><name>aDeclaration</name></expr></argument>, <argument><expr><name>aChanged</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>ParseRule</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type>        <name>aRule</name></decl></param>,
                       <param><decl><type><name>nsIURI</name>*</type>                 <name>aSheetURI</name></decl></param>,
                       <param><decl><type><name>nsIURI</name>*</type>                 <name>aBaseURI</name></decl></param>,
                       <param><decl><type><name>nsIPrincipal</name>*</type>           <name>aSheetPrincipal</name></decl></param>,
                       <param><decl><type><name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsICSSRule</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>ParseRule</name><argument_list>(<argument><expr><name>aRule</name></expr></argument>, <argument><expr><name>aSheetURI</name></expr></argument>, <argument><expr><name>aBaseURI</name></expr></argument>, <argument><expr><name>aSheetPrincipal</name></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>ParseProperty</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSSProperty</name></type> <name>aPropID</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type>    <name>aPropValue</name></decl></param>,
                           <param><decl><type><name>nsIURI</name>*</type>             <name>aSheetURI</name></decl></param>,
                           <param><decl><type><name>nsIURI</name>*</type>             <name>aBaseURI</name></decl></param>,
                           <param><decl><type><name>nsIPrincipal</name>*</type>       <name>aSheetPrincipal</name></decl></param>,
                           <param><decl><type><name><name>css</name>::<name>Declaration</name></name>*</type>   <name>aDeclaration</name></decl></param>,
                           <param><decl><type><name>PRBool</name>*</type>             <name>aChanged</name></decl></param>,
                           <param><decl><type><name>PRBool</name></type>              <name>aIsImportant</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>ParseProperty</name><argument_list>(<argument><expr><name>aPropID</name></expr></argument>, <argument><expr><name>aPropValue</name></expr></argument>, <argument><expr><name>aSheetURI</name></expr></argument>, <argument><expr><name>aBaseURI</name></expr></argument>,
                  <argument><expr><name>aSheetPrincipal</name></expr></argument>, <argument><expr><name>aDeclaration</name></expr></argument>, <argument><expr><name>aChanged</name></expr></argument>, <argument><expr><name>aIsImportant</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>ParseMediaList</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type> <name>aBuffer</name></decl></param>,
                            <param><decl><type><name>nsIURI</name>*</type>            <name>aURI</name></decl></param>,
                            <param><decl><type><name>PRUint32</name></type>           <name>aLineNumber</name></decl></param>,
                            <param><decl><type><name>nsMediaList</name>*</type>       <name>aMediaList</name></decl></param>,
                            <param><decl><type><name>PRBool</name></type>             <name>aHTMLMode</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>ParseMediaList</name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aURI</name></expr></argument>, <argument><expr><name>aLineNumber</name></expr></argument>, <argument><expr><name>aMediaList</name></expr></argument>, <argument><expr><name>aHTMLMode</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>ParseColorString</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type> <name>aBuffer</name></decl></param>,
                              <param><decl><type><name>nsIURI</name>*</type>            <name>aURI</name></decl></param>,
                              <param><decl><type><name>PRUint32</name></type>           <name>aLineNumber</name></decl></param>,
                              <param><decl><type><name>nscolor</name>*</type>           <name>aColor</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>ParseColorString</name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aURI</name></expr></argument>, <argument><expr><name>aLineNumber</name></expr></argument>, <argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsCSSParser</name>::<name>ParseSelectorString</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsSubstring</name>&amp;</type>  <name>aSelectorString</name></decl></param>,
                                 <param><decl><type><name>nsIURI</name>*</type>             <name>aURI</name></decl></param>,
                                 <param><decl><type><name>PRUint32</name></type>            <name>aLineNumber</name></decl></param>,
                                 <param><decl><type><name>nsCSSSelectorList</name>**</type> <name>aSelectorList</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>CSSParserImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>ParseSelectorString</name><argument_list>(<argument><expr><name>aSelectorString</name></expr></argument>, <argument><expr><name>aURI</name></expr></argument>, <argument><expr><name>aLineNumber</name></expr></argument>, <argument><expr><name>aSelectorList</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
