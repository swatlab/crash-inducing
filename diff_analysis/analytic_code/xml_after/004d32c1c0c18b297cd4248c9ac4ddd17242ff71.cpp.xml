<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="004d32c1c0c18b297cd4248c9ac4ddd17242ff71.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* vim: set ts=2 sw=2 et tw=78: */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * nsBaseContentList is a basic list of content nodes; nsContentList
 * is a commonly used NodeList implementation (used for
 * getElementsByTagName, some properties on nsIDOMHTMLDocument, etc).
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMNode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOM3Node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGenericElement.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentUtils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGkAtoms.h"</cpp:file></cpp:include>

<comment type="line">// Form related includes</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLFormElement.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pldhash.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CONTENT_LIST</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIContentIterator.h"</cpp:file></cpp:include>
<function_decl><type><name>nsresult</name></type>
<name>NS_NewPreContentIterator</name><parameter_list>(<param><decl><type><name>nsIContentIterator</name>**</type> <name>aInstancePtrResult</name></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_IN_SYNC</name></cpp:macro> <cpp:value>AssertInSync()</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_IN_SYNC</name></cpp:macro> <cpp:value>PR_BEGIN_MACRO PR_END_MACRO</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<using>using namespace <name><name>mozilla</name>::<name>dom</name></name>;</using>

<destructor><name><name>nsBaseContentList</name>::~<name>nsBaseContentList</name></name><parameter_list>()</parameter_list>
<block>{
}</block></destructor>

<macro><name>NS_IMPL_CYCLE_COLLECTION_CLASS</name><argument_list>(<argument>nsBaseContentList</argument>)</argument_list></macro>
<macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN</name><argument_list>(<argument>nsBaseContentList</argument>)</argument_list></macro>
  <macro><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY</name><argument_list>(<argument>mElements</argument>)</argument_list></macro>
<decl_stmt><decl><type><name>NS_IMPL_CYCLE_COLLECTION_UNLINK_END</name></type>
<name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN</name><argument_list>(<argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>
  <name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY</name><argument_list>(<argument><expr><name>mElements</name></expr></argument>)</argument_list>
<name>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END</name>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_CONTENT_LIST_INTERFACES</name><parameter_list>(<param><type><name>_class</name></type></param>)</parameter_list></cpp:macro>                                    \
    <cpp:value>NS_INTERFACE_TABLE_ENTRY(_class, nsINodeList)                             \
    NS_INTERFACE_TABLE_ENTRY(_class, nsIDOMNodeList)</cpp:value></cpp:define>

<name>DOMCI_DATA</name><argument_list>(<argument><expr><name>NodeList</name></expr></argument>, <argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>

<comment type="line">// QueryInterface implementation for nsBaseContentList</comment>
<name>NS_INTERFACE_TABLE_HEAD</name><argument_list>(<argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>
  <name>NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN</name><argument_list>(<argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>
    <name>NS_CONTENT_LIST_INTERFACES</name><argument_list>(<argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>
  <name>NS_OFFSET_AND_INTERFACE_TABLE_END</name>
  <name>NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE</name>
  <name>NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION</name><argument_list>(<argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>
  <name>NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO</name><argument_list>(<argument><expr><name>NodeList</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_MAP_END</name>


<name>NS_IMPL_CYCLE_COLLECTING_ADDREF</name><argument_list>(<argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>
<name>NS_IMPL_CYCLE_COLLECTING_RELEASE</name><argument_list>(<argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>


<name>NS_IMETHODIMP</name>
<name><name>nsBaseContentList</name>::<name>GetLength</name></name><argument_list>(<argument><expr><name>PRUint32</name>* <name>aLength</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr>*<name>aLength</name> = <call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></argument>;

  return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>

<name>NS_IMETHODIMP</name>
<name><name>nsBaseContentList</name>::<name>Item</name></name><argument_list>(<argument><expr><name>PRUint32</name> <name>aIndex</name></expr></argument>, <argument><expr><name>nsIDOMNode</name>** <name>aReturn</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><name>nsISupports</name> *<name>tmp</name> = <call><name>GetNodeAt</name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr></argument>;

  if <argument><expr>(!<name>tmp</name>) <block>{
    <expr>*<name>aReturn</name> = <name>nsnull</name></expr>;

    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></expr></argument>

  <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>aReturn</name></expr></argument>)</argument_list></call></expr>;</return></argument_list></decl></decl_stmt>
}

nsIContent<expr_stmt><expr>*
<macro><name>nsBaseContentList</name></macro><name>::<name>GetNodeAt</name></name>(<name>PRUint32</name> <name>aIndex</name>)
<block>{
  <return>return <expr><call><name><name>mElements</name>.<name>SafeObjectAt</name></name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>PRInt32</name></type>
<name><name>nsBaseContentList</name>::<name>IndexOf</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aDoFlush</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mElements</name>.<name>IndexOf</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>nsBaseContentList</name>::<name>IndexOf</name></name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>IndexOf</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsBaseContentList</name>::<name>AppendElement</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list> 
<block>{
  <expr_stmt><expr><call><name><name>mElements</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name><name>nsBaseContentList</name>::<name>RemoveElement</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list> 
<block>{
  <expr_stmt><expr><call><name><name>mElements</name>.<name>RemoveObject</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name><name>nsBaseContentList</name>::<name>InsertElementAt</name></name><parameter_list>(<param><decl><type><name>nsIContent</name>*</type> <name>aContent</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aIndex</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr>"Element to insert must not be null"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mElements</name>.<name>InsertObjectAt</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// nsFormContentList</comment>

<constructor><name><name>nsFormContentList</name>::<name>nsFormContentList</name></name><parameter_list>(<param><decl><type><name>nsIDOMHTMLFormElement</name> *</type><name>aForm</name></decl></param>,
                                     <param><decl><type><name>nsBaseContentList</name>&amp;</type> <name>aContentList</name></decl></param>)</parameter_list>
  <member_list>: <call><name>nsBaseContentList</name><argument_list>()</argument_list></call>
</member_list><block>{

  <comment type="line">// move elements that belong to mForm into this content list</comment>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>length</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>aContentList</name>.<name>GetLength</name></name><argument_list>(<argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIContent</name> *</type><name>c</name> <init>= <expr><call><name><name>aContentList</name>.<name>GetNodeAt</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>c</name> &amp;&amp; <call><name><name>nsContentUtils</name>::<name>BelongsInForm</name></name><argument_list>(<argument><expr><name>aForm</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>AppendElement</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></constructor>

<comment type="line">// Hashtable for storing nsContentLists</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PLDHashTable</name></type> <name>gContentListHashTable</name></decl>;</decl_stmt>

<struct>struct <name>ContentListHashEntry</name> <super>: <specifier>public</specifier> <name>PLDHashEntryHdr</name></super>
<block>{<public type="default">
  <decl_stmt><decl><type><name>nsContentList</name>*</type> <name>mContentList</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>PLDHashNumber</name></type>
<name>ContentListHashtableHashKey</name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsContentListKey</name>*</type> <name>list</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>nsContentListKey</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>list</name>-&gt;<name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>ContentListHashtableMatchEntry</name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>table</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>PLDHashEntryHdr</name> *</type><name>entry</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>ContentListHashEntry</name> *</type><name>e</name> <init>=
    <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>ContentListHashEntry</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsContentListKey</name>*</type> <name>list1</name> <init>= <expr><call><name><name>e</name>-&gt;<name>mContentList</name>-&gt;<name>GetKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsContentListKey</name>*</type> <name>list2</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>nsContentListKey</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name><name>list1</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr>*<name>list2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>nsContentList</name></expr></argument>&gt;</argument_list></name></type>
<name>NS_GetContentList</name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aRootNode</name></decl></param>, 
                  <param><decl><type><name>PRInt32</name></type>  <name>aMatchNameSpaceId</name></decl></param>,
                  <param><decl><type><name>nsIAtom</name>*</type> <name>aHTMLMatchAtom</name></decl></param>,
                  <param><decl><type><name>nsIAtom</name>*</type> <name>aXMLMatchAtom</name></decl></param>)</parameter_list>
                  
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aRootNode</name></expr></argument>, <argument><expr>"content list has to have a root"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>(<expr>!<name>aXMLMatchAtom</name></expr>)</condition><then>
    <expr_stmt><expr><name>aXMLMatchAtom</name> = <name>aHTMLMatchAtom</name></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>nsContentList</name>*</type> <name>list</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <name>PLDHashTableOps</name></type> <name>hash_table_ops</name> <init>=
  <expr><block>{
    <expr><name>PL_DHashAllocTable</name></expr>,
    <expr><name>PL_DHashFreeTable</name></expr>,
    <expr><name>ContentListHashtableHashKey</name></expr>,
    <expr><name>ContentListHashtableMatchEntry</name></expr>,
    <expr><name>PL_DHashMoveEntryStub</name></expr>,
    <expr><name>PL_DHashClearEntryStub</name></expr>,
    <expr><name>PL_DHashFinalizeStub</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <comment type="line">// Initialize the hashtable if needed.</comment>
  <if>if <condition>(<expr>!<name><name>gContentListHashTable</name>.<name>ops</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>success</name> <init>= <expr><call><name>PL_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name>gContentListHashTable</name></expr></argument>,
                                       <argument><expr>&amp;<name>hash_table_ops</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>,
                                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ContentListHashEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                       <argument><expr>16</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>success</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>gContentListHashTable</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  
  <decl_stmt><decl><type><name>ContentListHashEntry</name> *</type><name>entry</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <comment type="line">// First we look in our hashtable.  Then we create a content list if needed</comment>
  <if>if <condition>(<expr><name><name>gContentListHashTable</name>.<name>ops</name></name></expr>)</condition><then> <block>{
    <function_decl><type><name>nsContentListKey</name></type> <name>hashKey</name><parameter_list>(<param><decl><type><name>aRootNode</name></type></decl></param>, <param><decl><type><name>aHTMLMatchAtom</name></type></decl></param>,
                             <param><decl><type><name>aXMLMatchAtom</name></type></decl></param>, <param><decl><type><name>aMatchNameSpaceId</name></type></decl></param>)</parameter_list>;</function_decl>
    
    <comment type="line">// A PL_DHASH_ADD is equivalent to a PL_DHASH_LOOKUP for cases</comment>
    <comment type="line">// when the entry is already in the hashtable.</comment>
    <expr_stmt><expr><name>entry</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>ContentListHashEntry</name> *</expr></argument>&gt;</argument_list></name>
                       <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>gContentListHashTable</name></expr></argument>,
                                                <argument><expr>&amp;<name>hashKey</name></expr></argument>,
                                                <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>entry</name></expr>)</condition><then>
      <expr_stmt><expr><name>list</name> = <name><name>entry</name>-&gt;<name>mContentList</name></name></expr>;</expr_stmt></then></if>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then> <block>{
    <comment type="line">// We need to create a ContentList and add it to our new entry, if</comment>
    <comment type="line">// we have an entry</comment>
    <expr_stmt><expr><name>list</name> = new <call><name>nsContentList</name><argument_list>(<argument><expr><name>aRootNode</name></expr></argument>, <argument><expr><name>aMatchNameSpaceId</name></expr></argument>,
                             <argument><expr><name>aHTMLMatchAtom</name></expr></argument>, <argument><expr><name>aXMLMatchAtom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>entry</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>entry</name>-&gt;<name>mContentList</name></name> = <name>list</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>list</name></expr>;</return>
}</block></function>

<comment type="line">// Hashtable for storing nsCacheableFuncStringContentList</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PLDHashTable</name></type> <name>gFuncStringContentListHashTable</name></decl>;</decl_stmt>

<struct>struct <name>FuncStringContentListHashEntry</name> <super>: <specifier>public</specifier> <name>PLDHashEntryHdr</name></super>
<block>{<public type="default">
  <decl_stmt><decl><type><name>nsCacheableFuncStringContentList</name>*</type> <name>mContentList</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>PLDHashNumber</name></type>
<name>FuncStringContentListHashtableHashKey</name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsFuncStringCacheKey</name>*</type> <name>funcStringKey</name> <init>=
    <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>nsFuncStringCacheKey</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>funcStringKey</name>-&gt;<name>GetHash</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>FuncStringContentListHashtableMatchEntry</name><parameter_list>(<param><decl><type><name>PLDHashTable</name> *</type><name>table</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>PLDHashEntryHdr</name> *</type><name>entry</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>FuncStringContentListHashEntry</name> *</type><name>e</name> <init>=
    <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>FuncStringContentListHashEntry</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsFuncStringCacheKey</name>*</type> <name>ourKey</name> <init>=
    <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>nsFuncStringCacheKey</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name><name>e</name>-&gt;<name>mContentList</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name>ourKey</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>nsContentList</name></expr></argument>&gt;</argument_list></name></type>
<name>NS_GetFuncStringContentList</name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aRootNode</name></decl></param>,
                            <param><decl><type><name>nsContentListMatchFunc</name></type> <name>aFunc</name></decl></param>,
                            <param><decl><type><name>nsContentListDestroyFunc</name></type> <name>aDestroyFunc</name></decl></param>,
                            <param><decl><type><name>nsFuncStringContentListDataAllocator</name></type> <name>aDataAllocator</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aString</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aRootNode</name></expr></argument>, <argument><expr>"content list has to have a root"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsCacheableFuncStringContentList</name>*</type> <name>list</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <name>PLDHashTableOps</name></type> <name>hash_table_ops</name> <init>=
  <expr><block>{
    <expr><name>PL_DHashAllocTable</name></expr>,
    <expr><name>PL_DHashFreeTable</name></expr>,
    <expr><name>FuncStringContentListHashtableHashKey</name></expr>,
    <expr><name>FuncStringContentListHashtableMatchEntry</name></expr>,
    <expr><name>PL_DHashMoveEntryStub</name></expr>,
    <expr><name>PL_DHashClearEntryStub</name></expr>,
    <expr><name>PL_DHashFinalizeStub</name></expr>
  }</block></expr></init></decl>;</decl_stmt>

  <comment type="line">// Initialize the hashtable if needed.</comment>
  <if>if <condition>(<expr>!<name><name>gFuncStringContentListHashTable</name>.<name>ops</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>success</name> <init>= <expr><call><name>PL_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name>gFuncStringContentListHashTable</name></expr></argument>,
                                       <argument><expr>&amp;<name>hash_table_ops</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>,
                                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuncStringContentListHashEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                       <argument><expr>16</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>success</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>gFuncStringContentListHashTable</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name>FuncStringContentListHashEntry</name> *</type><name>entry</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <comment type="line">// First we look in our hashtable.  Then we create a content list if needed</comment>
  <if>if <condition>(<expr><name><name>gFuncStringContentListHashTable</name>.<name>ops</name></name></expr>)</condition><then> <block>{
    <function_decl><type><name>nsFuncStringCacheKey</name></type> <name>hashKey</name><parameter_list>(<param><decl><type><name>aRootNode</name></type></decl></param>, <param><decl><type><name>aFunc</name></type></decl></param>, <param><decl><type><name>aString</name></type></decl></param>)</parameter_list>;</function_decl>

    <comment type="line">// A PL_DHASH_ADD is equivalent to a PL_DHASH_LOOKUP for cases</comment>
    <comment type="line">// when the entry is already in the hashtable.</comment>
    <expr_stmt><expr><name>entry</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>FuncStringContentListHashEntry</name> *</expr></argument>&gt;</argument_list></name>
                       <argument_list>(<argument><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>gFuncStringContentListHashTable</name></expr></argument>,
                                             <argument><expr>&amp;<name>hashKey</name></expr></argument>,
                                             <argument><expr><name>PL_DHASH_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>entry</name></expr>)</condition><then>
      <expr_stmt><expr><name>list</name> = <name><name>entry</name>-&gt;<name>mContentList</name></name></expr>;</expr_stmt></then></if>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>list</name></expr>)</condition><then> <block>{
    <comment type="line">// We need to create a ContentList and add it to our new entry, if</comment>
    <comment type="line">// we have an entry</comment>
    <expr_stmt><expr><name>list</name> = new <call><name>nsCacheableFuncStringContentList</name><argument_list>(<argument><expr><name>aRootNode</name></expr></argument>, <argument><expr><name>aFunc</name></expr></argument>, <argument><expr><name>aDestroyFunc</name></expr></argument>,
                                                <argument><expr><name>aDataAllocator</name></expr></argument>, <argument><expr><name>aString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>list</name> &amp;&amp; !<call><name><name>list</name>-&gt;<name>AllocatedData</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Failed to allocate the data</comment>
      <expr_stmt><expr>delete <name>list</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>list</name> = <name>nsnull</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>entry</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>list</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>entry</name>-&gt;<name>mContentList</name></name> = <name>list</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>PL_DHashTableRawRemove</name><argument_list>(<argument><expr>&amp;<name>gContentListHashTable</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Don't cache these lists globally</comment>

  <return>return <expr><name>list</name></expr>;</return>
}</block></function>

<comment type="line">// nsContentList implementation</comment>

<constructor><name><name>nsContentList</name>::<name>nsContentList</name></name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aRootNode</name></decl></param>,
                             <param><decl><type><name>PRInt32</name></type> <name>aMatchNameSpaceId</name></decl></param>,
                             <param><decl><type><name>nsIAtom</name>*</type> <name>aHTMLMatchAtom</name></decl></param>,
                             <param><decl><type><name>nsIAtom</name>*</type> <name>aXMLMatchAtom</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type> <name>aDeep</name></decl></param>)</parameter_list>
  <member_list>: <call><name>nsBaseContentList</name><argument_list>()</argument_list></call>,
    <call><name>nsContentListKey</name><argument_list>(<argument><expr><name>aRootNode</name></expr></argument>, <argument><expr><name>aHTMLMatchAtom</name></expr></argument>, <argument><expr><name>aXMLMatchAtom</name></expr></argument>, <argument><expr><name>aMatchNameSpaceId</name></expr></argument>)</argument_list></call>,
    <call><name>mFunc</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
    <call><name>mDestroyFunc</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
    <call><name>mData</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
    <call><name>mState</name><argument_list>(<argument><expr><name>LIST_DIRTY</name></expr></argument>)</argument_list></call>,
    <call><name>mDeep</name><argument_list>(<argument><expr><name>aDeep</name></expr></argument>)</argument_list></call>,
    <call><name>mFuncMayDependOnAttr</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mRootNode</name></expr></argument>, <argument><expr>"Must have root"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>_asterix</name></name> == <name>mHTMLMatchAtom</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mXMLMatchAtom</name> == <name><name>nsGkAtoms</name>::<name>_asterix</name></name></expr></argument>, <argument><expr>"HTML atom and XML atom are not both asterix?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mMatchAll</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>mMatchAll</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name><name>mRootNode</name>-&gt;<name>AddMutationObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<constructor><name><name>nsContentList</name>::<name>nsContentList</name></name><parameter_list>(<param><decl><type><name>nsINode</name>*</type> <name>aRootNode</name></decl></param>,
                             <param><decl><type><name>nsContentListMatchFunc</name></type> <name>aFunc</name></decl></param>,
                             <param><decl><type><name>nsContentListDestroyFunc</name></type> <name>aDestroyFunc</name></decl></param>,
                             <param><decl><type><name>void</name>*</type> <name>aData</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type> <name>aDeep</name></decl></param>,
                             <param><decl><type><name>nsIAtom</name>*</type> <name>aMatchAtom</name></decl></param>,
                             <param><decl><type><name>PRInt32</name></type> <name>aMatchNameSpaceId</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type> <name>aFuncMayDependOnAttr</name></decl></param>)</parameter_list>
  <member_list>: <call><name>nsBaseContentList</name><argument_list>()</argument_list></call>,
    <call><name>nsContentListKey</name><argument_list>(<argument><expr><name>aRootNode</name></expr></argument>, <argument><expr><name>aMatchAtom</name></expr></argument>, <argument><expr><name>aMatchAtom</name></expr></argument>, <argument><expr><name>aMatchNameSpaceId</name></expr></argument>)</argument_list></call>,
    <call><name>mFunc</name><argument_list>(<argument><expr><name>aFunc</name></expr></argument>)</argument_list></call>,
    <call><name>mDestroyFunc</name><argument_list>(<argument><expr><name>aDestroyFunc</name></expr></argument>)</argument_list></call>,
    <call><name>mData</name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call>,
    <call><name>mMatchAll</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mState</name><argument_list>(<argument><expr><name>LIST_DIRTY</name></expr></argument>)</argument_list></call>,
    <call><name>mDeep</name><argument_list>(<argument><expr><name>aDeep</name></expr></argument>)</argument_list></call>,
    <call><name>mFuncMayDependOnAttr</name><argument_list>(<argument><expr><name>aFuncMayDependOnAttr</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mRootNode</name></expr></argument>, <argument><expr>"Must have root"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mRootNode</name>-&gt;<name>AddMutationObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>nsContentList</name>::~<name>nsContentList</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>RemoveFromHashtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mRootNode</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mRootNode</name>-&gt;<name>RemoveMutationObserver</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>mDestroyFunc</name></expr>)</condition><then> <block>{
    <comment type="line">// Clean up mData</comment>
    <expr_stmt><expr><call>(*<name>mDestroyFunc</name>)<argument_list>(<argument><expr><name>mData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></destructor>

<macro><name>DOMCI_DATA</name><argument_list>(<argument>ContentList</argument>, <argument>nsContentList</argument>)</argument_list></macro>

<comment type="line">// QueryInterface implementation for nsContentList</comment>
<macro><name>NS_INTERFACE_TABLE_HEAD</name><argument_list>(<argument>nsContentList</argument>)</argument_list></macro>
  <decl_stmt><decl><type><name>NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY</name></type>
  <name>NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN</name><argument_list>(<argument><expr><name>nsContentList</name></expr></argument>)</argument_list>
    <name>NS_CONTENT_LIST_INTERFACES</name><argument_list>(<argument><expr><name>nsContentList</name></expr></argument>)</argument_list>
    <name>NS_INTERFACE_TABLE_ENTRY</name><argument_list>(<argument><expr><name>nsContentList</name></expr></argument>, <argument><expr><name>nsIHTMLCollection</name></expr></argument>)</argument_list>
    <name>NS_INTERFACE_TABLE_ENTRY</name><argument_list>(<argument><expr><name>nsContentList</name></expr></argument>, <argument><expr><name>nsIDOMHTMLCollection</name></expr></argument>)</argument_list>
    <name>NS_INTERFACE_TABLE_ENTRY</name><argument_list>(<argument><expr><name>nsContentList</name></expr></argument>, <argument><expr><name>nsIMutationObserver</name></expr></argument>)</argument_list>
  <name>NS_OFFSET_AND_INTERFACE_TABLE_END</name>
  <name>NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE</name>
  <name>NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO</name><argument_list>(<argument><expr><name>ContentList</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_MAP_END_INHERITING</name><argument_list>(<argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>


<name>NS_IMPL_ADDREF_INHERITED</name><argument_list>(<argument><expr><name>nsContentList</name></expr></argument>, <argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>
<name>NS_IMPL_RELEASE_INHERITED</name><argument_list>(<argument><expr><name>nsContentList</name></expr></argument>, <argument><expr><name>nsBaseContentList</name></expr></argument>)</argument_list>

<name>PRUint32</name>
<name><name>nsContentList</name>::<name>Length</name></name><argument_list>(<argument><expr><name>PRBool</name> <name>aDoFlush</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><call><name>BringSelfUpToDate</name><argument_list>(<argument><expr><name>aDoFlush</name></expr></argument>)</argument_list></call></expr></argument>;
    
  return <argument><expr><call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></argument>;
}</argument_list>

<name>nsIContent</name> *
<name><name>nsContentList</name>::<name>Item</name></name><argument_list>(<argument><expr><name>PRUint32</name> <name>aIndex</name></expr></argument>, <argument><expr><name>PRBool</name> <name>aDoFlush</name></expr></argument>)</argument_list>
<argument_list>{
  if <argument><expr>(<name>mRootNode</name> &amp;&amp; <name>aDoFlush</name>) <block>{
    <comment type="line">// XXX sXBL/XBL2 issue</comment>
    <expr><name>nsIDocument</name>* <name>doc</name> = <call><name><name>mRootNode</name>-&gt;<name>GetCurrentDoc</name></name><argument_list>()</argument_list></call></expr>;
    <if>if <condition>(<expr><name>doc</name></expr>)</condition><then> <expr_stmt><expr><block>{
      <comment type="line">// Flush pending content changes Bug 4891.</comment>
      <expr><call><name><name>doc</name>-&gt;<name>FlushPendingNotifications</name></name><argument_list>(<argument><expr><name>Flush_ContentAndNotify</name></expr></argument>)</argument_list></call></expr>;
    }</block>
  }</expr></expr_stmt></then></if>

  <if>if <condition>(<expr><name>mState</name> != <name>LIST_UP_TO_DATE</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>PopulateSelf</name><argument_list>(<argument><expr><name>aIndex</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <name>ASSERT_IN_SYNC</name></block></expr></argument>;
  <argument><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mRootNode</name> || <name>mState</name> != <name>LIST_DIRTY</name></expr></argument>,
               <argument><expr>"PopulateSelf left the list in a dirty (useless) state!"</expr></argument>)</argument_list></call></expr></argument>;

  return <argument><expr><call><name><name>mElements</name>.<name>SafeObjectAt</name></name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr></argument>;
}</argument_list>

<name>nsIContent</name> *
<name><name>nsContentList</name>::<name>NamedItem</name></name><argument_list>(<argument><expr>const <name>nsAString</name>&amp; <name>aName</name></expr></argument>, <argument><expr><name>PRBool</name> <name>aDoFlush</name></expr></argument>)</argument_list>
<argument_list>{
  <argument><expr><call><name>BringSelfUpToDate</name><argument_list>(<argument><expr><name>aDoFlush</name></expr></argument>)</argument_list></call></expr></argument>;
    
  <argument><expr><name>PRInt32</name> <name>i</name></expr></argument>, <argument><expr><name>count</name> = <call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></argument>;

  <comment type="line">// Typically IDs and names are atomized</comment>
  <argument><expr><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAtom</name></expr></argument>&gt;</argument_list></name> <name>name</name> = <call><name>do_GetAtom</name><argument_list>(<argument><expr><name>aName</name></expr></argument>)</argument_list></call></expr></argument>;
  <argument><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></argument>;

  for <argument><expr>(<name>i</name> = 0; <name>i</name> &lt; <name>count</name>; <name>i</name>++) <block>{
    <expr><name>nsIContent</name> *<name>content</name> = <name><name>mElements</name><index>[<expr><name>i</name></expr>]</index></name></expr>;
    <comment type="line">// XXX Should this pass eIgnoreCase?</comment>
    <if>if <condition>(<expr><name>content</name> &amp;&amp;
        (<call><name><name>content</name>-&gt;<name>AttrValueIs</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>name</name></name></expr></argument>,
                              <argument><expr><name>name</name></expr></argument>, <argument><expr><name>eCaseMatters</name></expr></argument>)</argument_list></call> ||
         <call><name><name>content</name>-&gt;<name>AttrValueIs</name></name><argument_list>(<argument><expr><name>kNameSpaceID_None</name></expr></argument>, <argument><expr><name><name>nsGkAtoms</name>::<name>id</name></name></expr></argument>,
                              <argument><expr><name>name</name></expr></argument>, <argument><expr><name>eCaseMatters</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <expr_stmt><expr><block>{
      <return>return <expr><name>content</name></expr>;</return>
    }</block>
  }</expr></expr_stmt></then></if>

  <return>return <expr><name>nsnull</name></expr>;</return>
}</block>

<name>PRInt32</name>
<macro><name>nsContentList</name></macro><name>::<name>IndexOf</name></name>(<name>nsIContent</name> *<name>aContent</name>, <name>PRBool</name> <name>aDoFlush</name>)
<block>{
  <expr><call><name>BringSelfUpToDate</name><argument_list>(<argument><expr><name>aDoFlush</name></expr></argument>)</argument_list></call></expr>;
    
  <return>return <expr><call><name><name>mElements</name>.<name>IndexOf</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>PRInt32</name>
<macro><name>nsContentList</name></macro><name>::<name>IndexOf</name></name>(<name>nsIContent</name>* <name>aContent</name>)
<block>{
  <return>return <expr><call><name>IndexOf</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name>
<macro><name>nsContentList</name></macro><name>::<name>NodeWillBeDestroyed</name></name>(const <name>nsINode</name>* <name>aNode</name>)
<block>{
  <comment type="line">// We shouldn't do anything useful from now on</comment>

  <expr><call><name>RemoveFromCaches</name><argument_list>()</argument_list></call></expr>;
  <expr><name>mRootNode</name> = <name>nsnull</name></expr>;

  <comment type="line">// We will get no more updates, so we can never know we're up to</comment>
  <comment type="line">// date</comment>
  <expr><call><name>SetDirty</name><argument_list>()</argument_list></call></expr>;
}</block>

<name>NS_IMETHODIMP</name>
<macro><name>nsContentList</name></macro><name>::<name>GetLength</name></name>(<name>PRUint32</name>* <name>aLength</name>)
<block>{
  <expr>*<name>aLength</name> = <call><name>Length</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block>

<name>NS_IMETHODIMP</name>
<macro><name>nsContentList</name></macro><name>::<name>Item</name></name>(<name>PRUint32</name> <name>aIndex</name>, <name>nsIDOMNode</name>** <name>aReturn</name>)
<block>{
  <expr><name>nsINode</name>* <name>node</name> = <call><name>GetNodeAt</name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr>;

  <if>if <condition>(<expr><name>node</name></expr>)</condition><then> <expr_stmt><expr><block>{
    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>aReturn</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block>

  *<name>aReturn</name> = <name>nsnull</name></expr>;</expr_stmt></then></if></block></expr></argument>

  <return>return <expr><name>NS_OK</name></expr>;</return></argument_list></decl></decl_stmt>
}

NS_IMETHODIMP
<macro><name>nsContentList</name></macro><expr_stmt><expr><name>::<name>NamedItem</name></name>(const <name>nsAString</name>&amp; <name>aName</name>, <name>nsIDOMNode</name>** <name>aReturn</name>)
<block>{
  <expr><name>nsIContent</name> *<name>content</name> = <call><name>NamedItem</name><argument_list>(<argument><expr><name>aName</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;

  <if>if <condition>(<expr><name>content</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>aReturn</name></expr></argument>)</argument_list></call></expr>;</return>
  <expr_stmt/></block></then></if>}</block>

  *<name>aReturn</name> = <name>nsnull</name></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}

nsIContent<expr_stmt><expr>*
<macro><name>nsContentList</name></macro><name>::<name>GetNodeAt</name></name>(<name>PRUint32</name> <name>aIndex</name>)
<block>{
  <return>return <expr><call><name>Item</name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>nsIContent</name>*</type>
<name><name>nsContentList</name>::<name>GetNodeAt</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aIndex</name></decl></param>, <param><decl><type><name>nsresult</name>*</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aResult</name> = <name>NS_OK</name></expr>;</expr_stmt>
  <return>return <expr><call><name>Item</name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsISupports</name>*</type>
<name><name>nsContentList</name>::<name>GetNamedItem</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aName</name></decl></param>, <param><decl><type><name>nsWrapperCache</name> **</type><name>aCache</name></decl></param>,
                            <param><decl><type><name>nsresult</name>*</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aResult</name> = <name>NS_OK</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIContent</name> *</type><name>item</name></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>aCache</name> = <name>item</name> = <call><name>NamedItem</name><argument_list>(<argument><expr><name>aName</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>item</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsContentList</name>::<name>AttributeChanged</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>, <param><decl><type><name>Element</name>*</type> <name>aElement</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aNameSpaceID</name></decl></param>, <param><decl><type><name>nsIAtom</name>*</type> <name>aAttribute</name></decl></param>,
                                <param><decl><type><name>PRInt32</name></type> <name>aModType</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aElement</name></expr></argument>, <argument><expr>"Must have a content node to work with"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if>if <condition>(<expr>!<name>mFunc</name> || !<name>mFuncMayDependOnAttr</name> || <name>mState</name> == <name>LIST_DIRTY</name> ||
      !<call><name>MayContainRelevantNodes</name><argument_list>(<argument><expr><call><name><name>aElement</name>-&gt;<name>GetNodeParent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> ||
      !<call><name><name>nsContentUtils</name>::<name>IsInSameAnonymousTree</name></name><argument_list>(<argument><expr><name>mRootNode</name></expr></argument>, <argument><expr><name>aElement</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Either we're already dirty or this notification doesn't affect</comment>
    <comment type="line">// whether we might match aElement.</comment>
    <return>return;</return>
  }</block></then></if>
  
  <if>if <condition>(<expr><call><name>Match</name><argument_list>(<argument><expr><name>aElement</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name><name>mElements</name>.<name>IndexOf</name></name><argument_list>(<argument><expr><name>aElement</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
      <comment type="line">// We match aElement now, and it's not in our list already.  Just dirty</comment>
      <comment type="line">// ourselves; this is simpler than trying to figure out where to insert</comment>
      <comment type="line">// aElement.</comment>
      <expr_stmt><expr><call><name>SetDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <comment type="line">// We no longer match aElement.  Remove it from our list.  If it's</comment>
    <comment type="line">// already not there, this is a no-op (though a potentially</comment>
    <comment type="line">// expensive one).  Either way, no change of mState is required</comment>
    <comment type="line">// here.</comment>
    <expr_stmt><expr><call><name><name>mElements</name>.<name>RemoveObject</name></name><argument_list>(<argument><expr><name>aElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsContentList</name>::<name>ContentAppended</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name>*</type> <name>aDocument</name></decl></param>, <param><decl><type><name>nsIContent</name>*</type> <name>aContainer</name></decl></param>,
                               <param><decl><type><name>nsIContent</name>*</type> <name>aFirstNewContent</name></decl></param>,
                               <param><decl><type><name>PRInt32</name></type> <name>aNewIndexInContainer</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aContainer</name></expr></argument>, <argument><expr>"Can't get at the new content if no container!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/*
   * If the state is LIST_DIRTY then we have no useful information in our list
   * and we want to put off doing work as much as possible.  Also, if
   * aContainer is anonymous from our point of view, we know that we can't
   * possibly be matching any of the kids.
   */</comment>
  <if>if <condition>(<expr><name>mState</name> == <name>LIST_DIRTY</name> ||
      !<call><name><name>nsContentUtils</name>::<name>IsInSameAnonymousTree</name></name><argument_list>(<argument><expr><name>mRootNode</name></expr></argument>, <argument><expr><name>aContainer</name></expr></argument>)</argument_list></call> ||
      !<call><name>MayContainRelevantNodes</name><argument_list>(<argument><expr><name>aContainer</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="block">/*
   * We want to handle the case of ContentAppended by sometimes
   * appending the content to our list, not just setting state to
   * LIST_DIRTY, since most of our ContentAppended notifications
   * should come during pageload and be at the end of the document.
   * Do a bit of work to see whether we could just append to what we
   * already have.
   */</comment>
  
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>count</name> <init>= <expr><call><name><name>aContainer</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>count</name> &gt; 0</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>ourCount</name> <init>= <expr><call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>appendToList</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>ourCount</name> == 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>appendToList</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>ourLastContent</name> <init>= <expr><name><name>mElements</name><index>[<expr><name>ourCount</name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
      <comment type="block">/*
       * We want to append instead of invalidating if the first thing
       * that got appended comes after ourLastContent.
       */</comment>
      <if>if <condition>(<expr><call><name><name>nsContentUtils</name>::<name>PositionIsBefore</name></name><argument_list>(<argument><expr><name>ourLastContent</name></expr></argument>, <argument><expr><name>aFirstNewContent</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>appendToList</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
    

    <if>if <condition>(<expr>!<name>appendToList</name></expr>)</condition><then> <block>{
      <comment type="line">// The new stuff is somewhere in the middle of our list; check</comment>
      <comment type="line">// whether we need to invalidate</comment>
      <for>for (<init><decl><type><name>nsIContent</name>*</type> <name>cur</name> <init>= <expr><name>aFirstNewContent</name></expr></init></decl>;</init> <condition><expr><name>cur</name></expr>;</condition> <incr><expr><name>cur</name> = <call><name><name>cur</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>MatchSelf</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// Uh-oh.  We're gonna have to add elements into the middle</comment>
          <comment type="line">// of our list. That's not worth the effort.</comment>
          <expr_stmt><expr><call><name>SetDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></for>

      <expr_stmt><expr><name>ASSERT_IN_SYNC</name></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>

    <comment type="block">/*
     * At this point we know we could append.  If we're not up to
     * date, however, that would be a bad idea -- it could miss some
     * content that we never picked up due to being lazy.  Further, we
     * may never get asked for this content... so don't grab it yet.
     */</comment>
    <if>if <condition>(<expr><name>mState</name> == <name>LIST_LAZY</name></expr>)</condition><then> <comment type="line">// be lazy</comment>
      <return>return;</return></then></if>

    <comment type="block">/*
     * We're up to date.  That means someone's actively using us; we
     * may as well grab this content....
     */</comment>
    <if>if <condition>(<expr><name>mDeep</name></expr>)</condition><then> <block>{
      <for>for (<init><decl><type><name>nsIContent</name>*</type> <name>cur</name> <init>= <expr><name>aFirstNewContent</name></expr></init></decl>;</init>
           <condition><expr><name>cur</name></expr>;</condition>
           <incr><expr><name>cur</name> = <call><name><name>cur</name>-&gt;<name>GetNextNode</name></name><argument_list>(<argument><expr><name>aContainer</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name><name>cur</name>-&gt;<name>IsElement</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>Match</name><argument_list>(<argument><expr><call><name><name>cur</name>-&gt;<name>AsElement</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>mElements</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
    }</block></then> <else>else <block>{
      <for>for (<init><decl><type><name>nsIContent</name>*</type> <name>cur</name> <init>= <expr><name>aFirstNewContent</name></expr></init></decl>;</init> <condition><expr><name>cur</name></expr>;</condition> <incr><expr><name>cur</name> = <call><name><name>cur</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name><name>cur</name>-&gt;<name>IsElement</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>Match</name><argument_list>(<argument><expr><call><name><name>cur</name>-&gt;<name>AsElement</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>mElements</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
    }</block></else></if>

    <expr_stmt><expr><name>ASSERT_IN_SYNC</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsContentList</name>::<name>ContentInserted</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                               <param><decl><type><name>nsIContent</name>*</type> <name>aContainer</name></decl></param>,
                               <param><decl><type><name>nsIContent</name>*</type> <name>aChild</name></decl></param>,
                               <param><decl><type><name>PRInt32</name></type> <name>aIndexInContainer</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Note that aContainer can be null here if we are inserting into</comment>
  <comment type="line">// the document itself; any attempted optimizations to this method</comment>
  <comment type="line">// should deal with that.</comment>
  <if>if <condition>(<expr><name>mState</name> != <name>LIST_DIRTY</name> &amp;&amp;
      <call><name>MayContainRelevantNodes</name><argument_list>(<argument><expr><call><name>NODE_FROM</name><argument_list>(<argument><expr><name>aContainer</name></expr></argument>, <argument><expr><name>aDocument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
      <call><name><name>nsContentUtils</name>::<name>IsInSameAnonymousTree</name></name><argument_list>(<argument><expr><name>mRootNode</name></expr></argument>, <argument><expr><name>aChild</name></expr></argument>)</argument_list></call> &amp;&amp;
      <call><name>MatchSelf</name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SetDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>ASSERT_IN_SYNC</name></expr>;</expr_stmt>
}</block></function>
 
<function><type><name>void</name></type>
<name><name>nsContentList</name>::<name>ContentRemoved</name></name><parameter_list>(<param><decl><type><name>nsIDocument</name> *</type><name>aDocument</name></decl></param>,
                              <param><decl><type><name>nsIContent</name>*</type> <name>aContainer</name></decl></param>,
                              <param><decl><type><name>nsIContent</name>*</type> <name>aChild</name></decl></param>,
                              <param><decl><type><name>PRInt32</name></type> <name>aIndexInContainer</name></decl></param>,
                              <param><decl><type><name>nsIContent</name>*</type> <name>aPreviousSibling</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Note that aContainer can be null here if we are removing from</comment>
  <comment type="line">// the document itself; any attempted optimizations to this method</comment>
  <comment type="line">// should deal with that.</comment>
  <if>if <condition>(<expr><name>mState</name> != <name>LIST_DIRTY</name> &amp;&amp;
      <call><name>MayContainRelevantNodes</name><argument_list>(<argument><expr><call><name>NODE_FROM</name><argument_list>(<argument><expr><name>aContainer</name></expr></argument>, <argument><expr><name>aDocument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
      <call><name><name>nsContentUtils</name>::<name>IsInSameAnonymousTree</name></name><argument_list>(<argument><expr><name>mRootNode</name></expr></argument>, <argument><expr><name>aChild</name></expr></argument>)</argument_list></call> &amp;&amp;
      <call><name>MatchSelf</name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SetDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>ASSERT_IN_SYNC</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsContentList</name>::<name>Match</name></name><parameter_list>(<param><decl><type><name>Element</name> *</type><name>aElement</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mFunc</name></expr>)</condition><then> <block>{
    <return>return <expr><call>(*<name>mFunc</name>)<argument_list>(<argument><expr><name>aElement</name></expr></argument>, <argument><expr><name>mMatchNameSpaceId</name></expr></argument>, <argument><expr><name>mXMLMatchAtom</name></expr></argument>, <argument><expr><name>mData</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>mXMLMatchAtom</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsINodeInfo</name> *</type><name>ni</name> <init>= <expr><call><name><name>aElement</name>-&gt;<name>NodeInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
 
  <decl_stmt><decl><type><name>PRBool</name></type> <name>unknown</name> <init>= <expr><name>mMatchNameSpaceId</name> == <name>kNameSpaceID_Unknown</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>wildcard</name> <init>= <expr><name>mMatchNameSpaceId</name> == <name>kNameSpaceID_Wildcard</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>toReturn</name> <init>= <expr><name>mMatchAll</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>unknown</name> &amp;&amp; !<name>wildcard</name></expr>)</condition><then>
    <expr_stmt><expr><name>toReturn</name> &amp;= <call><name><name>ni</name>-&gt;<name>NamespaceEquals</name></name><argument_list>(<argument><expr><name>mMatchNameSpaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>toReturn</name></expr>)</condition><then>
    <return>return <expr><name>toReturn</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIDocument</name>*</type> <name>doc</name> <init>= <expr><call><name><name>aElement</name>-&gt;<name>GetOwnerDoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>matchHTML</name> <init>= <expr><call><name><name>aElement</name>-&gt;<name>GetNameSpaceID</name></name><argument_list>()</argument_list></call> == <name>kNameSpaceID_XHTML</name> &amp;&amp;
    <name>doc</name> &amp;&amp; <call><name><name>doc</name>-&gt;<name>IsHTML</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
 
  <if>if <condition>(<expr><name>unknown</name></expr>)</condition><then> <block>{
    <return>return <expr><name>matchHTML</name> ? <call><name><name>ni</name>-&gt;<name>QualifiedNameEquals</name></name><argument_list>(<argument><expr><name>mHTMLMatchAtom</name></expr></argument>)</argument_list></call> :
                       <call><name><name>ni</name>-&gt;<name>QualifiedNameEquals</name></name><argument_list>(<argument><expr><name>mXMLMatchAtom</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  
  <if>if <condition>(<expr><name>wildcard</name></expr>)</condition><then> <block>{
    <return>return <expr><name>matchHTML</name> ? <call><name><name>ni</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name>mHTMLMatchAtom</name></expr></argument>)</argument_list></call> :
                       <call><name><name>ni</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name>mXMLMatchAtom</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  
  <return>return <expr><name>matchHTML</name> ? <call><name><name>ni</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name>mHTMLMatchAtom</name></expr></argument>, <argument><expr><name>mMatchNameSpaceId</name></expr></argument>)</argument_list></call> :
                     <call><name><name>ni</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name>mXMLMatchAtom</name></expr></argument>, <argument><expr><name>mMatchNameSpaceId</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> 
<name><name>nsContentList</name>::<name>MatchSelf</name></name><parameter_list>(<param><decl><type><name>nsIContent</name> *</type><name>aContent</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>, <argument><expr>"Can't match null stuff, you know"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>mDeep</name> || <call><name><name>aContent</name>-&gt;<name>GetNodeParent</name></name><argument_list>()</argument_list></call> == <name>mRootNode</name></expr></argument>,
                  <argument><expr>"MatchSelf called on a node that we can't possibly match"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name><name>aContent</name>-&gt;<name>IsElement</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  
  <if>if <condition>(<expr><call><name>Match</name><argument_list>(<argument><expr><call><name><name>aContent</name>-&gt;<name>AsElement</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <if>if <condition>(<expr>!<name>mDeep</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <for>for (<init><decl><type><name>nsIContent</name>*</type> <name>cur</name> <init>= <expr><call><name><name>aContent</name>-&gt;<name>GetFirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
       <condition><expr><name>cur</name></expr>;</condition>
       <incr><expr><name>cur</name> = <call><name><name>cur</name>-&gt;<name>GetNextNode</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
    <if>if <condition>(<expr><call><name><name>cur</name>-&gt;<name>IsElement</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>Match</name><argument_list>(<argument><expr><call><name><name>cur</name>-&gt;<name>AsElement</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></for>
  
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> 
<name><name>nsContentList</name>::<name>PopulateSelf</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aNeededLength</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mRootNode</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><name>ASSERT_IN_SYNC</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>count</name> <init>= <expr><call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mState</name> != <name>LIST_DIRTY</name> || <name>count</name> == 0</expr></argument>,
               <argument><expr>"Reset() not called when setting state to LIST_DIRTY?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>count</name> &gt;= <name>aNeededLength</name></expr>)</condition><then> <comment type="line">// We're all set</comment>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>elementsToAppend</name> <init>= <expr><name>aNeededLength</name> - <name>count</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>invariant</name> <init>= <expr><name>elementsToAppend</name> + <call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><name>mDeep</name></expr>)</condition><then> <block>{
    <comment type="line">// If we already have nodes start searching at the last one, otherwise</comment>
    <comment type="line">// start searching at the root.</comment>
    <decl_stmt><decl><type><name>nsINode</name>*</type> <name>cur</name> <init>= <expr><name>count</name> ? <name><name>mElements</name><index>[<expr><name>count</name> - 1</expr>]</index></name> : <name>mRootNode</name></expr></init></decl>;</decl_stmt>
    <do>do <block>{
      <expr_stmt><expr><name>cur</name> = <call><name><name>cur</name>-&gt;<name>GetNextNode</name></name><argument_list>(<argument><expr><name>mRootNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>cur</name></expr>)</condition><then> <block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr><call><name><name>cur</name>-&gt;<name>IsElement</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>Match</name><argument_list>(<argument><expr><call><name><name>cur</name>-&gt;<name>AsElement</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mElements</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><call><name><name>cur</name>-&gt;<name>AsElement</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>--<name>elementsToAppend</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block> while <condition>(<expr><name>elementsToAppend</name></expr>)</condition>;</do>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsIContent</name>*</type> <name>cur</name> <init>=
      <expr><name>count</name> ? <name><name>mElements</name><index>[<expr><name>count</name>-1</expr>]</index></name>-&gt;<call><name>GetNextSibling</name><argument_list>()</argument_list></call> : <call><name><name>mRootNode</name>-&gt;<name>GetFirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for ( <init>;</init> <condition><expr><name>cur</name> &amp;&amp; <name>elementsToAppend</name></expr>;</condition> <incr><expr><name>cur</name> = <call><name><name>cur</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
      <if>if <condition>(<expr><call><name><name>cur</name>-&gt;<name>IsElement</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>Match</name><argument_list>(<argument><expr><call><name><name>cur</name>-&gt;<name>AsElement</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mElements</name>.<name>AppendObject</name></name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>--<name>elementsToAppend</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></else></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>elementsToAppend</name> + <call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call> == <name>invariant</name></expr></argument>,
               <argument><expr>"Something is awry!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>elementsToAppend</name> != 0</expr>)</condition><then>
    <expr_stmt><expr><name>mState</name> = <name>LIST_UP_TO_DATE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>mState</name> = <name>LIST_LAZY</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>ASSERT_IN_SYNC</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsContentList</name>::<name>RemoveFromHashtable</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mFunc</name></expr>)</condition><then> <block>{
    <comment type="line">// This can't be in the table anyway</comment>
    <return>return;</return>
  }</block></then></if>
  
  <if>if <condition>(<expr>!<name><name>gContentListHashTable</name>.<name>ops</name></name></expr>)</condition><then>
    <return>return;</return></then></if>

  <expr_stmt><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>gContentListHashTable</name></expr></argument>,
                       <argument><expr><call><name>GetKey</name><argument_list>()</argument_list></call></expr></argument>,
                       <argument><expr><name>PL_DHASH_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>gContentListHashTable</name>.<name>entryCount</name></name> == 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PL_DHashTableFinish</name><argument_list>(<argument><expr>&amp;<name>gContentListHashTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gContentListHashTable</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsContentList</name>::<name>BringSelfUpToDate</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aDoFlush</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mRootNode</name> &amp;&amp; <name>aDoFlush</name></expr>)</condition><then> <block>{
    <comment type="line">// XXX sXBL/XBL2 issue</comment>
    <decl_stmt><decl><type><name>nsIDocument</name>*</type> <name>doc</name> <init>= <expr><call><name><name>mRootNode</name>-&gt;<name>GetCurrentDoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>doc</name></expr>)</condition><then> <block>{
      <comment type="line">// Flush pending content changes Bug 4891.</comment>
      <expr_stmt><expr><call><name><name>doc</name>-&gt;<name>FlushPendingNotifications</name></name><argument_list>(<argument><expr><name>Flush_ContentAndNotify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>mState</name> != <name>LIST_UP_TO_DATE</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>PopulateSelf</name><argument_list>(<argument><expr><call><name>PRUint32</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    
  <expr_stmt><expr><name>ASSERT_IN_SYNC</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mRootNode</name> || <name>mState</name> == <name>LIST_UP_TO_DATE</name></expr></argument>,
               <argument><expr>"PopulateSelf dod not bring content list up to date!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<destructor><name><name>nsCacheableFuncStringContentList</name>::~<name>nsCacheableFuncStringContentList</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>RemoveFromFuncStringHashtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>void</name></type>
<name><name>nsCacheableFuncStringContentList</name>::<name>RemoveFromFuncStringHashtable</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name><name>gFuncStringContentListHashTable</name>.<name>ops</name></name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <function_decl><type><name>nsFuncStringCacheKey</name></type> <name>key</name><parameter_list>(<param><decl><type><name>mRootNode</name></type></decl></param>, <param><decl><type><name>mFunc</name></type></decl></param>, <param><decl><type><name>mString</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name>PL_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name>gFuncStringContentListHashTable</name></expr></argument>,
                       <argument><expr>&amp;<name>key</name></expr></argument>,
                       <argument><expr><name>PL_DHASH_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>gFuncStringContentListHashTable</name>.<name>entryCount</name></name> == 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PL_DHashTableFinish</name><argument_list>(<argument><expr>&amp;<name>gFuncStringContentListHashTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gFuncStringContentListHashTable</name>.<name>ops</name></name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CONTENT_LIST</name></cpp:ifdef>
<function><type><name>void</name></type>
<name><name>nsContentList</name>::<name>AssertInSync</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mState</name> == <name>LIST_DIRTY</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>mRootNode</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call> == 0 &amp;&amp; <name>mState</name> == <name>LIST_DIRTY</name></expr></argument>,
                 <argument><expr>"Empty iterator isn't quite empty?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <comment type="line">// XXX This code will need to change if nsContentLists can ever match</comment>
  <comment type="line">// elements that are outside of the document element.</comment>
  <decl_stmt><decl><type><name>nsIContent</name> *</type><name>root</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>mRootNode</name>-&gt;<name>IsNodeOfType</name></name><argument_list>(<argument><expr><name><name>nsINode</name>::<name>eDOCUMENT</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>root</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIDocument</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mRootNode</name></expr></argument>)</argument_list></call>-&gt;<call><name>GetRootElement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>root</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIContent</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mRootNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContentIterator</name></expr></argument>&gt;</argument_list></name></type> <name>iter</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mDeep</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_NewPreContentIterator</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>iter</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>iter</name>-&gt;<name>First</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cnt</name> <init>= <expr>0</expr></init>, <name>index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>PR_TRUE</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><name>cnt</name> == <call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>mState</name> == <name>LIST_LAZY</name></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsIContent</name> *</type><name>cur</name> <init>= <expr><name>mDeep</name> ? <call><name><name>iter</name>-&gt;<name>GetCurrentNode</name></name><argument_list>()</argument_list></call> :
                              <call><name><name>mRootNode</name>-&gt;<name>GetChildAt</name></name><argument_list>(<argument><expr><name>index</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>cur</name></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>

    <if>if <condition>(<expr><call><name><name>cur</name>-&gt;<name>IsElement</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>Match</name><argument_list>(<argument><expr><call><name><name>cur</name>-&gt;<name>AsElement</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>cnt</name> &lt; <call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>mElements</name><index>[<expr><name>cnt</name></expr>]</index></name> == <name>cur</name></expr></argument>,
                   <argument><expr>"Elements is out of sync"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>++<name>cnt</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>mDeep</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>iter</name>-&gt;<name>Next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></while>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>cnt</name> == <call><name><name>mElements</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Too few elements"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
