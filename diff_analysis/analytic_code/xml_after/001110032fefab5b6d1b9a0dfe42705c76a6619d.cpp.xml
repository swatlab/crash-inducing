<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="001110032fefab5b6d1b9a0dfe42705c76a6619d.cpp"><comment type="block" format="doxygen">/******* BEGIN LICENSE BLOCK *******
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * 
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * 
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 * 
 * The Initial Developers of the Original Code are Kevin Hendricks (MySpell)
 * and László Németh (Hunspell). Portions created by the Initial Developers
 * are Copyright (C) 2002-2005 the Initial Developers. All Rights Reserved.
 * 
 * Contributor(s): Kevin Hendricks (kevin.hendricks@sympatico.ca)
 *                 David Einstein (deinst@world.std.com)
 *                 László Németh (nemethl@gyorsposta.hu)
 *                 Davide Prina
 *                 Giuseppe Modugno
 *                 Gianluca Turconi
 *                 Simon Brouwer
 *                 Noll Janos
 *                 Biro Arpad
 *                 Goldman Eleonora
 *                 Sarlos Tamas
 *                 Bencsath Boldizsar
 *                 Halacsy Peter
 *                 Dvornik Laszlo
 *                 Gefferth Andras
 *                 Nagy Viktor
 *                 Varga Daniel
 *                 Chris Halls
 *                 Rene Engelhard
 *                 Bram Moolenaar
 *                 Dafydd Jones
 *                 Harri Pitkanen
 *                 Andras Timar
 *                 Tor Lillqvist
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 ******* END LICENSE BLOCK *******/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MOZILLA_CLIENT</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdlib&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstring&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdio&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cctype&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"suggestmgr.hxx"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MOZILLA_CLIENT</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>W32</name></cpp:ifndef>
<using>using namespace <name>std</name>;</using>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<constructor><name><name>SuggestMgr</name>::<name>SuggestMgr</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>tryme</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxn</name></decl></param>, 
                       <param><decl><type><name>AffixMgr</name> *</type> <name>aptr</name></decl></param>)</parameter_list>
<block>{

  <comment type="line">// register affix manager and check in string of chars to </comment>
  <comment type="line">// try when building candidate suggestions</comment>
  <expr_stmt><expr><name>pAMgr</name> = <name>aptr</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>ctryl</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>ctry</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ctry_utf</name> = <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>maxSug</name> = <name>maxn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nosplitsugs</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>maxngramsugs</name> = <name>MAXNGRAMSUGS</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>utf8</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>complexprefixes</name> = 0</expr>;</expr_stmt>

  <if>if <condition>(<expr><name>pAMgr</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type> <name>enc</name> <init>= <expr><call><name><name>pAMgr</name>-&gt;<name>get_encoding</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>csconv</name> = <call><name>get_current_cs</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nosplitsugs</name> = <call><name><name>pAMgr</name>-&gt;<name>get_nosplitsugs</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>pAMgr</name>-&gt;<name>get_maxngramsugs</name></name><argument_list>()</argument_list></call> &gt;= 0</expr>)</condition><then> <expr_stmt><expr><name>maxngramsugs</name> = <call><name><name>pAMgr</name>-&gt;<name>get_maxngramsugs</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>utf8</name> = <call><name><name>pAMgr</name>-&gt;<name>get_utf8</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>complexprefixes</name> = <call><name><name>pAMgr</name>-&gt;<name>get_complexprefixes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>tryme</name></expr>)</condition><then> <block>{  
    <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>w_char</name></type> <name><name>t</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>    
        <expr_stmt><expr><name>ctryl</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>tryme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ctry_utf</name> = (<name>w_char</name> *) <call><name>malloc</name><argument_list>(<argument><expr><name>ctryl</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>ctry_utf</name></expr>)</condition><then> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ctry_utf</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>ctryl</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>ctry</name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>tryme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ctryl</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>ctry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></constructor>


<destructor><name><name>SuggestMgr</name>::~<name>SuggestMgr</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>pAMgr</name> = <name>NULL</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>ctry</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ctry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>ctry</name> = <name>NULL</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>ctry_utf</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ctry_utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>ctry_utf</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ctryl</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>maxSug</name> = 0</expr>;</expr_stmt>
}</block></destructor>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>testsug</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>candidate</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>,
   <param><decl><type><name>int</name> *</type> <name>timer</name></decl></param>, <param><decl><type><name>time_t</name> *</type> <name>timelimit</name></decl></param>)</parameter_list> <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>cwrd</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>ns</name> == <name>maxSug</name></expr>)</condition><then> <return>return <expr><name>maxSug</name></expr>;</return></then></if>
      <for>for (<init><decl><type><name>int</name></type> <name>k</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>,<argument><expr><name><name>wlst</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <expr_stmt><expr><name>cwrd</name> = 0</expr>;</expr_stmt></then></if>
      }</block></for>
      <if>if <condition>(<expr>(<name>cwrd</name>) &amp;&amp; <call><name>checkword</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>j</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>j</name>&lt;<name>ns</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
      }</block></then></if> 
      <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// generate suggestions for a mispelled word</comment>
<comment type="line">//    pass in address of array of char * pointers</comment>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>suggest</name></name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nocompoundtwowords</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type> <name>wlst</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>w_char</name></type> <name><name>word_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>wl</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXWORDUTF8LEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name> <init>= <expr><name>w</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// word reversing wrapper for complex prefixes</comment>
  <if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
  }</block></then></if>
    
    <if>if <condition>(<expr>*<name>slst</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>wlst</name> = *<name>slst</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>wlst</name> = (<name>char</name> **) <call><name>malloc</name><argument_list>(<argument><expr><name>maxSug</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>wlst</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>maxSug</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></for>
    }</block></else></if>
    
    <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>wl</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <for>for (<init><decl><type><name>int</name></type> <name>cpdsuggest</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr>(<name>cpdsuggest</name>&lt;2) &amp;&amp; (<name>nocompoundtwowords</name>==0)</expr>;</condition> <incr><expr><name>cpdsuggest</name>++</expr></incr>) <block>{

    <comment type="line">// suggestions for an uppercase word (html -&gt; HTML)</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>capchars_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
                    <call><name>capchars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// perhaps we made a typical fault of spelling</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then>
    <expr_stmt><expr><name>nsug</name> = <call><name>replchars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// perhaps we made chose the wrong char from a related set</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1) &amp;&amp; (<name>cpdsuggest</name> == 0)</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>nsug</name> = <call><name>mapchars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// did we swap the order of chars by mistake</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>swapchar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
                    <call><name>swapchar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// did we swap the order of non adjacent chars by mistake</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>longswapchar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
                    <call><name>longswapchar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// did we forgot a char</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>forgotchar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
                    <call><name>forgotchar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// did we move a char</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>movechar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
                    <call><name>movechar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// did we add a char that should not be there</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>extrachar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
                    <call><name>extrachar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// did we just hit the wrong key in place of a good char</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>badchar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
                    <call><name>badchar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// did we double two characters</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>doubletwochars_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
                    <call><name>doubletwochars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>


    <comment type="line">// only suggest compound words when no other suggestion</comment>
    <if>if <condition>(<expr>(<name>cpdsuggest</name>==0) &amp;&amp; (<name>nsug</name>&gt;0)</expr>)</condition><then> <expr_stmt><expr><name>nocompoundtwowords</name>=1</expr>;</expr_stmt></then></if>

    <comment type="line">// perhaps we forgot to hit space and two words ran together</comment>
    <if>if <condition>(<expr>(!<name>nosplitsugs</name>) &amp;&amp; (<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>nsug</name> = <call><name>twowords</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

    }</block></for> <comment type="line">// repeating ``for'' statement compounding support</comment>

    <if>if <condition>(<expr><name>nsug</name> &lt; 0</expr>)</condition><then> <block>{
     <comment type="line">// we ran out of memory - we should free up as much as possible</comment>
       <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>maxSug</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
         <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
       <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>wlst</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr>*<name>slst</name> = <name>wlst</name></expr>;</expr_stmt>
    <return>return <expr><name>nsug</name></expr>;</return>
}</block></function>

<comment type="line">// generate suggestions for a word with typical mistake</comment>
<comment type="line">//    pass in address of array of char * pointers</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HUNSPELL_EXPERIMENTAL</name></cpp:ifdef>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>suggest_auto</name></name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nocompoundtwowords</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type> <name>wlst</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXWORDUTF8LEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name> <init>= <expr><name>w</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// word reversing wrapper for complex prefixes</comment>
  <if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
  }</block></then></if>

    <if>if <condition>(<expr>*<name>slst</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>wlst</name> = *<name>slst</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>wlst</name> = (<name>char</name> **) <call><name>malloc</name><argument_list>(<argument><expr><name>maxSug</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>wlst</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    }</block></else></if>

    <for>for (<init><decl><type><name>int</name></type> <name>cpdsuggest</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr>(<name>cpdsuggest</name>&lt;2) &amp;&amp; (<name>nocompoundtwowords</name>==0)</expr>;</condition> <incr><expr><name>cpdsuggest</name>++</expr></incr>) <block>{

    <comment type="line">// perhaps we made a typical fault of spelling</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then>
    <expr_stmt><expr><name>nsug</name> = <call><name>replchars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// perhaps we made chose the wrong char from a related set</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1) &amp;&amp; (<name>cpdsuggest</name> == 0)</expr>)</condition><then>
      <expr_stmt><expr><name>nsug</name> = <call><name>mapchars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>(<name>cpdsuggest</name>==0) &amp;&amp; (<name>nsug</name>&gt;0)</expr>)</condition><then> <expr_stmt><expr><name>nocompoundtwowords</name>=1</expr>;</expr_stmt></then></if>

    <comment type="line">// perhaps we forgot to hit space and two words ran together</comment>

    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1) &amp;&amp; <call><name>check_forbidden</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>nsug</name> = <call><name>twowords</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    
    }</block></for> <comment type="line">// repeating ``for'' statement compounding support</comment>

    <if>if <condition>(<expr><name>nsug</name> &lt; 0</expr>)</condition><then> <block>{
       <for>for (<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>maxSug</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
         <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
       <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>*<name>slst</name> = <name>wlst</name></expr>;</expr_stmt>
    <return>return <expr><name>nsug</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// END OF HUNSPELL_EXPERIMENTAL CODE</comment>

<comment type="line">// suggestions for an uppercase word (html -&gt; HTML)</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>capchars_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>w_char</name></type> <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>mkallcap_utf</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_langnum</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// suggestions for an uppercase word (html -&gt; HTML)</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>capchars</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>mkallcap</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// suggestions for when chose the wrong char out of a related set</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>mapchars</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>time_t</name></type> <name>timelimit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>timer</name></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>int</name></type> <name>wl</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>wl</name> &lt; 2 || ! <name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>int</name></type> <name>nummap</name> <init>= <expr><call><name><name>pAMgr</name>-&gt;<name>get_nummap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>mapentry</name>*</type> <name>maptable</name> <init>= <expr><call><name><name>pAMgr</name>-&gt;<name>get_maptable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>maptable</name>==<name>NULL</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>

  <expr_stmt><expr><name>timelimit</name> = <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>timer</name> = <name>MINTIMER</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>w_char</name></type> <name><name>w</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>ns</name> = <call><name>map_related_utf</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <expr_stmt><expr><name>ns</name> = <call><name>map_related</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>map_related</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>mapentry</name>*</type> <name>maptable</name></decl></param>, <param><decl><type><name>int</name></type> <name>nummap</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>timer</name></decl></param>, <param><decl><type><name>time_t</name> *</type> <name>timelimit</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr>*(<name>word</name> + <name>i</name>)</expr></init></decl>;</decl_stmt>  
  <if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>cwrd</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>wl</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <for>for (<init><decl><type><name>int</name></type> <name>m</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>m</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>m</name>++</expr></incr>)
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>,<argument><expr><name><name>wlst</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <expr_stmt><expr><name>cwrd</name> = 0</expr>;</expr_stmt></then></if></for>
      <if>if <condition>(<expr>(<name>cwrd</name>) &amp;&amp; (<call><name>checkword</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call> || 
        <call><name>checkword</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
          <if>if <condition>(<expr><name>ns</name> &lt; <name>maxSug</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
              <expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
          }</block></then></if>
      }</block></then></if>
      <return>return <expr><name>ns</name></expr>;</return>
  }</block></then></if> 
  <decl_stmt><decl><type><name>int</name></type> <name>in_map</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>nummap</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
    <if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>set</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>in_map</name> = 1</expr>;</expr_stmt>
      <decl_stmt><decl><type><name>char</name> *</type> <name>newword</name> <init>= <expr><call><name>mystrdup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <for>for (<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>len</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
        <expr_stmt><expr>*(<name>newword</name> + <name>i</name>) = *(<name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>set</name> + <name>k</name>)</expr>;</expr_stmt>
        <expr_stmt><expr><name>ns</name> = <call><name>map_related</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr>(<name>i</name>+1)</expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!(*<name>timelimit</name>)</expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
      }</block></for>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <if>if <condition>(<expr>!<name>in_map</name></expr>)</condition><then> <block>{
     <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
     <expr_stmt><expr><name>ns</name> = <call><name>map_related</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>map_related_utf</name></name><parameter_list>(<param><decl><type><name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>mapentry</name>*</type> <name>maptable</name></decl></param>, <param><decl><type><name>int</name></type> <name>nummap</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>timer</name></decl></param>, <param><decl><type><name>time_t</name> *</type> <name>timelimit</name></decl></param>)</parameter_list> 
<block>{
  <if>if <condition>(<expr><name>i</name> == <name>len</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>cwrd</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>wl</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>wl</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><decl><type><name>int</name></type> <name>m</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>m</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>m</name>++</expr></incr>)
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name><name>wlst</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <expr_stmt><expr><name>cwrd</name> = 0</expr>;</expr_stmt></then></if></for>
      <if>if <condition>(<expr>(<name>cwrd</name>) &amp;&amp; (<call><name>checkword</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call> || 
            <call><name>checkword</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
          <if>if <condition>(<expr><name>ns</name> &lt; <name>maxSug</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
              <expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
          }</block></then></if>
      }</block></then></if>
      <return>return <expr><name>ns</name></expr>;</return>
  }</block></then></if> 
  <decl_stmt><decl><type><name>int</name></type> <name>in_map</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>c</name> <init>= <expr>*((<name>unsigned</name> <name>short</name> *) <name>word</name> + <name>i</name>)</expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>nummap</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
    <if>if <condition>(<expr><call><name>flag_bsearch</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>short</name> *) <name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>set_utf16</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>in_map</name> = 1</expr>;</expr_stmt>
      <for>for (<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>len</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
        <expr_stmt><expr>*(<name>word</name> + <name>i</name>) = *(<name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>set_utf16</name> + <name>k</name>)</expr>;</expr_stmt>
        <expr_stmt><expr><name>ns</name> = <call><name>map_related_utf</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!(*<name>timelimit</name>)</expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
      }</block></for>
      <expr_stmt><expr>*((<name>unsigned</name> <name>short</name> *) <name>word</name> + <name>i</name>) = <name>c</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <if>if <condition>(<expr>!<name>in_map</name></expr>)</condition><then> <block>{
     <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
     <expr_stmt><expr><name>ns</name> = <call><name>map_related_utf</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>ns</name></expr>;</return>
}</block></function>



<comment type="line">// suggestions for a typical fault of spelling, that</comment>
<comment type="line">// differs with more, than 1 letter from the right form.</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>replchars</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>lenr</name></decl>, <decl><type ref="prev"/><name>lenp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wl</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>wl</name> &lt; 2 || ! <name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>int</name></type> <name>numrep</name> <init>= <expr><call><name><name>pAMgr</name>-&gt;<name>get_numrep</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>replentry</name>*</type> <name>reptable</name> <init>= <expr><call><name><name>pAMgr</name>-&gt;<name>get_reptable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>reptable</name>==<name>NULL</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
  <for>for (<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>numrep</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr> ) <block>{
      <expr_stmt><expr><name>r</name> = <name>word</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>lenr</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>reptable</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pattern2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lenp</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>reptable</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// search every occurence of the pattern in the word</comment>
      <while>while <condition>(<expr>(<name>r</name>=<call><name>strstr</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>reptable</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pattern</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
          <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>r</name>-<name>word</name> + <name>lenr</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>r</name>+<name>lenp</name></expr></argument>)</argument_list></call> &gt;= <name>MAXSWUTF8L</name></expr>)</condition><then> <break>break;</break></then></if>
          <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name>+(<name>r</name>-<name>word</name>)</expr></argument>,<argument><expr><name><name>reptable</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pattern2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name>+(<name>r</name>-<name>word</name>)+<name>lenr</name></expr></argument>, <argument><expr><name>r</name>+<name>lenp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name>-<name>lenp</name>+<name>lenr</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
          <expr_stmt><expr><name>r</name>++</expr>;</expr_stmt> <comment type="line">// search for the next letter</comment>
      }</block></while>
   }</block></for>
   <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// perhaps we doubled two characters (pattern aba -&gt; ababa, for example vacation -&gt; vacacation)</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>doubletwochars</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>state</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wl</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>wl</name> &lt; 5 || ! <name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
  <for>for (<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>2</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>wl</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr> ) <block>{
      <if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name></expr>]</index></name>==<name><name>word</name><index>[<expr><name>i</name>-2</expr>]</index></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>state</name>++</expr>;</expr_stmt>
          <if>if <condition>(<expr><name>state</name>==3</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>,<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name>+<name>i</name>-1</expr></argument>,<argument><expr><name>word</name>+<name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name>-2</expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
            <expr_stmt><expr><name>state</name>=0</expr>;</expr_stmt>
          }</block></then></if>
      }</block></then> <else>else <block>{
            <expr_stmt><expr><name>state</name>=0</expr>;</expr_stmt>
      }</block></else></if>
  }</block></for>
  <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// perhaps we doubled two characters (pattern aba -&gt; ababa, for example vacation -&gt; vacacation)</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>doubletwochars_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>w_char</name></type>        <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>          <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>state</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>wl</name> &lt; 5 || ! <name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
  <for>for (<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>2</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>wl</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <if>if <condition>(<expr>(<name><name>word</name><index>[<expr><name>i</name></expr>]</index></name>.<name>l</name>==<name><name>word</name><index>[<expr><name>i</name>-2</expr>]</index></name>.<name>l</name>) &amp;&amp; (<name><name>word</name><index>[<expr><name>i</name></expr>]</index></name>.<name>h</name>==<name><name>word</name><index>[<expr><name>i</name>-2</expr>]</index></name>.<name>h</name>)</expr>)</condition><then>  <block>{
          <expr_stmt><expr><name>state</name>++</expr>;</expr_stmt>
          <if>if <condition>(<expr><name>state</name>==3</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr>(<name>i</name> - 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name>+<name>i</name>-1</expr></argument>, <argument><expr><name>word</name>+<name>i</name>+1</expr></argument>, <argument><expr>(<name>wl</name>-<name>i</name>-1) * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
            <expr_stmt><expr><name>state</name>=0</expr>;</expr_stmt>
          }</block></then></if>
      }</block></then> <else>else <block>{
            <expr_stmt><expr><name>state</name>=0</expr>;</expr_stmt>
      }</block></else></if>
  }</block></for>
  <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is wrong char in place of correct one</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>badchar</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type>  <name>tmpc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>  <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>time_t</name></type> <name>timelimit</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>timer</name> <init>= <expr><name>MINTIMER</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wl</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// swap out each char one by one and try all the tryme</comment>
  <comment type="line">// chars in its place to see if that makes a good word</comment>
  <for>for (<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>wl</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name>tmpc</name> = <name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>int</name></type> <name>j</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>ctryl</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
       <if>if <condition>(<expr><name><name>ctry</name><index>[<expr><name>j</name></expr>]</index></name> == <name>tmpc</name></expr>)</condition><then> <continue>continue;</continue></then></if>
       <expr_stmt><expr><name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>ctry</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
       <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
       <if>if <condition>(<expr>!<name>timelimit</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
       <expr_stmt><expr><name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
    }</block></for>
  }</block></for>
  <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is wrong char in place of correct one</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>badchar_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>w_char</name></type>        <name>tmpc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>w_char</name></type>        <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>          <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>time_t</name></type> <name>timelimit</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>timer</name> <init>= <expr><name>MINTIMER</name></expr></init></decl>;</decl_stmt>  
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// swap out each char one by one and try all the tryme</comment>
  <comment type="line">// chars in its place to see if that makes a good word</comment>
  <for>for (<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>wl</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name>tmpc</name> = <name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>int</name></type> <name>j</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>ctryl</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
       <if>if <condition>(<expr>(<name><name>ctry_utf</name><index>[<expr><name>j</name></expr>]</index></name>.<name>l</name> == <name><name>tmpc</name>.<name>l</name></name>) &amp;&amp; (<name><name>ctry_utf</name><index>[<expr><name>j</name></expr>]</index></name>.<name>h</name> == <name><name>tmpc</name>.<name>h</name></name>)</expr>)</condition><then> <continue>continue;</continue></then></if>
       <expr_stmt><expr><name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>ctry_utf</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
       <if>if <condition>(<expr>!<name>timelimit</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
       <expr_stmt><expr><name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
    }</block></for>
  }</block></for>
  <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is word has an extra letter it does not need </comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>extrachar_utf</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name></type> <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>const</specifier> <name>w_char</name> *</type> <name>p</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name> *</type> <name>r</name></decl>;</decl_stmt>
   <if>if <condition>(<expr><name>wl</name> &lt; 2</expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
   <comment type="line">// try omitting one char of word at a time</comment>
   <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name> + 1</expr></argument>, <argument><expr>(<name>wl</name> - 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for (<init><expr><name>p</name> = <name>word</name></expr>, <expr><name>r</name> = <name>candidate_utf</name></expr>;</init>  <condition><expr><name>p</name> &lt; <name>word</name> + <name>wl</name></expr>;</condition>  <incr/>) <block>{
       <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>       
       <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
       <expr_stmt><expr>*<name>r</name>++ = *<name>p</name>++</expr>;</expr_stmt>
   }</block></for>
   <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is word has an extra letter it does not need </comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>extrachar</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>char</name></type>    <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type>  <name>p</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name> *</type>  <name>r</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>wl</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <if>if <condition>(<expr><name>wl</name> &lt; 2</expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
   <comment type="line">// try omitting one char of word at a time</comment>
   <expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for (<init><expr><name>p</name> = <name>word</name></expr>, <expr><name>r</name> = <name>candidate</name></expr>;</init>  <condition><expr>*<name>p</name> != 0</expr>;</condition>  <incr/>) <block>{
      <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name>-1</expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
      <expr_stmt><expr>*<name>r</name>++ = *<name>p</name>++</expr>;</expr_stmt>
   }</block></for>
   <return>return <expr><name>ns</name></expr>;</return>
}</block></function>


<comment type="line">// error is missing a letter it needs</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>forgotchar</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>p</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name> *</type>       <name>q</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>time_t</name></type> <name>timelimit</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>timer</name> <init>= <expr><name>MINTIMER</name></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>wl</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <comment type="line">// try inserting a tryme character before every letter</comment>
   <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name> + 1</expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for (<init><expr><name>p</name> = <name>word</name></expr>, <expr><name>q</name> = <name>candidate</name></expr>;</init>  <condition><expr>*<name>p</name> != 0</expr>;</condition>  <incr/>)  <block>{
      <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init>  <condition><expr><name>i</name> &lt; <name>ctryl</name></expr>;</condition>  <incr><expr><name>i</name>++</expr></incr>) <block>{
         <expr_stmt><expr>*<name>q</name> = <name><name>ctry</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
         <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name>+1</expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
         <if>if <condition>(<expr>!<name>timelimit</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
      }</block></for>
      <expr_stmt><expr>*<name>q</name>++ = *<name>p</name>++</expr>;</expr_stmt>
   }</block></for>
   <comment type="line">// now try adding one to end */</comment>
   <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init>  <condition><expr><name>i</name> &lt; <name>ctryl</name></expr>;</condition>  <incr><expr><name>i</name>++</expr></incr>) <block>{
      <expr_stmt><expr>*<name>q</name> = <name><name>ctry</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name>+1</expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
   }</block></for>
   <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is missing a letter it needs</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>forgotchar_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>w_char</name></type>  <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name></type>    <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>const</specifier> <name>w_char</name> *</type> <name>p</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name> *</type> <name>q</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>cwrd</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>time_t</name></type> <name>timelimit</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>timer</name> <init>= <expr><name>MINTIMER</name></expr></init></decl>;</decl_stmt>
   <comment type="line">// try inserting a tryme character before every letter</comment>
   <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name> + 1</expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for (<init><expr><name>p</name> = <name>word</name></expr>, <expr><name>q</name> = <name>candidate_utf</name></expr>;</init>  <condition><expr><name>p</name> &lt; (<name>word</name> + <name>wl</name>)</expr>;</condition> <incr/>)  <block>{
      <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init>  <condition><expr><name>i</name> &lt; <name>ctryl</name></expr>;</condition>  <incr><expr><name>i</name>++</expr></incr>) <block>{
         <expr_stmt><expr>*<name>q</name> = <name><name>ctry_utf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
         <expr_stmt><expr><name>cwrd</name> = 1</expr>;</expr_stmt>
         <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
         <if>if <condition>(<expr>!<name>timelimit</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
       }</block></for>
      <expr_stmt><expr>*<name>q</name>++ = *<name>p</name>++</expr>;</expr_stmt>
   }</block></for>
   <comment type="line">// now try adding one to end */</comment>
   <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init>  <condition><expr><name>i</name> &lt; <name>ctryl</name></expr>;</condition>  <incr><expr><name>i</name>++</expr></incr>) <block>{
      <expr_stmt><expr>*<name>q</name> = <name><name>ctry_utf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cwrd</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
   }</block></for>
   <return>return <expr><name>ns</name></expr>;</return>
}</block></function>


<comment type="block">/* error is should have been two words */</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>twowords</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type> <name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>forbidden</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cwrd</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>wl</name><init>=<expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>wl</name> &lt; 3</expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
    
    <if>if <condition>(<expr><call><name><name>pAMgr</name>-&gt;<name>get_langnum</name></name><argument_list>()</argument_list></call> == <name>LANG_hu</name></expr>)</condition><then> <expr_stmt><expr><name>forbidden</name> = <call><name>check_forbidden</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name> + 1</expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// split the string into two pieces after every char</comment>
    <comment type="line">// if both pieces are good words make them a suggestion</comment>
    <for>for (<init><expr><name>p</name> = <name>candidate</name> + 1</expr>;</init>  <condition><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> != '\0'</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
       <expr_stmt><expr><name><name>p</name><index>[<expr>-1</expr>]</index></name> = *<name>p</name></expr>;</expr_stmt>
       <comment type="line">// go to end of the UTF-8 character</comment>
       <while>while <condition>(<expr><name>utf8</name> &amp;&amp; ((<name><name>p</name><index>[<expr>1</expr>]</index></name> &amp; 0xc0) == 0x80)</expr>)</condition> <block>{
         <expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
         <expr_stmt><expr><name><name>p</name><index>[<expr>-1</expr>]</index></name> = *<name>p</name></expr>;</expr_stmt>
       }</block></while>
       <expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
       <expr_stmt><expr><name>c1</name> = <call><name>checkword</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <if>if <condition>(<expr><name>c1</name></expr>)</condition><then> <block>{
         <expr_stmt><expr><name>c2</name> = <call><name>checkword</name><argument_list>(<argument><expr>(<name>p</name>+1)</expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name>+1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if>if <condition>(<expr><name>c2</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name> = ' '</expr>;</expr_stmt>

            <comment type="line">// spec. Hungarian code (need a better compound word support)</comment>
            <if>if <condition>(<expr>(<call><name><name>pAMgr</name>-&gt;<name>get_langnum</name></name><argument_list>()</argument_list></call> == <name>LANG_hu</name>) &amp;&amp; !<name>forbidden</name> &amp;&amp;
                <comment type="line">// if 3 repeating letter, use - instead of space</comment>
                (((<name><name>p</name><index>[<expr>-1</expr>]</index></name> == <name><name>p</name><index>[<expr>1</expr>]</index></name>) &amp;&amp; (((<name>p</name>&gt;<name>candidate</name>+1) &amp;&amp; (<name><name>p</name><index>[<expr>-1</expr>]</index></name> == <name><name>p</name><index>[<expr>-2</expr>]</index></name>)) || (<name><name>p</name><index>[<expr>-1</expr>]</index></name> == <name><name>p</name><index>[<expr>2</expr>]</index></name>))) ||
                <comment type="line">// or multiple compounding, with more, than 6 syllables</comment>
                ((<name>c1</name> == 3) &amp;&amp; (<name>c2</name> &gt;= 2)))</expr>)</condition><then> <expr_stmt><expr>*<name>p</name> = '-'</expr>;</expr_stmt></then></if>

            <expr_stmt><expr><name>cwrd</name> = 1</expr>;</expr_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>k</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>)
                <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>,<argument><expr><name><name>wlst</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <expr_stmt><expr><name>cwrd</name> = 0</expr>;</expr_stmt></then></if></for>
            <if>if <condition>(<expr><name>ns</name> &lt; <name>maxSug</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>cwrd</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
                    <expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
                }</block></then></if>
            }</block></then> <else>else <return>return <expr><name>ns</name></expr>;</return></else></if>
         }</block></then></if>
       }</block></then></if>
    }</block></for>
    <return>return <expr><name>ns</name></expr>;</return>
}</block></function>


<comment type="line">// error is adjacent letter were swapped</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>swapchar</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name> *</type> <name>p</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name></type> <name>tmpc</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>wl</name><init>=<expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <comment type="line">// try swapping adjacent chars one by one</comment>
   <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for (<init><expr><name>p</name> = <name>candidate</name></expr>;</init>  <condition><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> != 0</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name>tmpc</name> = *<name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>p</name> = <name><name>p</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
      <expr_stmt><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> = *<name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>p</name> = <name>tmpc</name></expr>;</expr_stmt>
   }</block></for>
   <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is adjacent letter were swapped</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>swapchar_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>w_char</name></type> <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name></type>   <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name> *</type> <name>p</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name></type> <name>tmpc</name></decl>;</decl_stmt>
   <comment type="line">// try swapping adjacent chars one by one</comment>
   <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for (<init><expr><name>p</name> = <name>candidate_utf</name></expr>;</init>  <condition><expr><name>p</name> &lt; (<name>candidate_utf</name> + <name>wl</name> - 1)</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name>tmpc</name> = *<name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>p</name> = <name><name>p</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
      <expr_stmt><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> = *<name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>p</name> = <name>tmpc</name></expr>;</expr_stmt>
   }</block></for>
   <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is not adjacent letter were swapped</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>longswapchar</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name> *</type> <name>p</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name> *</type> <name>q</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name></type> <name>tmpc</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>wl</name><init>=<expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <comment type="line">// try swapping not adjacent chars one by one</comment>
   <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for (<init><expr><name>p</name> = <name>candidate</name></expr>;</init>  <condition><expr>*<name>p</name> != 0</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
    <for>for (<init><expr><name>q</name> = <name>candidate</name></expr>;</init>  <condition><expr>*<name>q</name> != 0</expr>;</condition>  <incr><expr><name>q</name>++</expr></incr>) <block>{
     <if>if <condition>(<expr><call><name>abs</name><argument_list>(<argument><expr><name>p</name>-<name>q</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>tmpc</name> = *<name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>p</name> = *<name>q</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
      <expr_stmt><expr>*<name>q</name> = *<name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>p</name> = <name>tmpc</name></expr>;</expr_stmt>
     }</block></then></if>
    }</block></for>
   }</block></for>
   <return>return <expr><name>ns</name></expr>;</return>
}</block></function>


<comment type="line">// error is adjacent letter were swapped</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>longswapchar_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>w_char</name></type> <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name></type>   <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name> *</type> <name>p</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name> *</type> <name>q</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name></type> <name>tmpc</name></decl>;</decl_stmt>
   <comment type="line">// try swapping not adjacent chars</comment>
   <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for (<init><expr><name>p</name> = <name>candidate_utf</name></expr>;</init>  <condition><expr><name>p</name> &lt; (<name>candidate_utf</name> + <name>wl</name>)</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
     <for>for (<init><expr><name>q</name> = <name>candidate_utf</name></expr>;</init>  <condition><expr><name>q</name> &lt; (<name>candidate_utf</name> + <name>wl</name>)</expr>;</condition>  <incr><expr><name>q</name>++</expr></incr>) <block>{
       <if>if <condition>(<expr><call><name>abs</name><argument_list>(<argument><expr><name>p</name>-<name>q</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
         <expr_stmt><expr><name>tmpc</name> = *<name>p</name></expr>;</expr_stmt>
         <expr_stmt><expr>*<name>p</name> = *<name>q</name></expr>;</expr_stmt>
         <expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
         <expr_stmt><expr>*<name>q</name> = *<name>p</name></expr>;</expr_stmt>
         <expr_stmt><expr>*<name>p</name> = <name>tmpc</name></expr>;</expr_stmt>
       }</block></then></if>
     }</block></for>
   }</block></for>
   <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is a letter was moved</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>movechar</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name> *</type> <name>p</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name> *</type> <name>q</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name></type> <name>tmpc</name></decl>;</decl_stmt>

   <decl_stmt><decl><type><name>int</name></type> <name>wl</name><init>=<expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <comment type="line">// try moving a char</comment>
   <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for (<init><expr><name>p</name> = <name>candidate</name></expr>;</init>  <condition><expr>*<name>p</name> != 0</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
     <for>for (<init><expr><name>q</name> = <name>p</name> + 1</expr>;</init>  <condition><expr>(*<name>q</name> != 0) &amp;&amp; ((<name>q</name> - <name>p</name>) &lt; 10)</expr>;</condition>  <incr><expr><name>q</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name>tmpc</name> = *(<name>q</name>-1)</expr>;</expr_stmt>
      <expr_stmt><expr>*(<name>q</name>-1) = *<name>q</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
      <if>if <condition>(<expr>(<name>q</name>-<name>p</name>) &lt; 2</expr>)</condition><then> <continue>continue;</continue></then></if> <comment type="line">// omit swap char</comment>
      <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   }</block></for>
   <for>for (<init><expr><name>p</name> = <name>candidate</name> + <name>wl</name> - 1</expr>;</init>  <condition><expr><name>p</name> &gt; <name>candidate</name></expr>;</condition>  <incr><expr><name>p</name>--</expr></incr>) <block>{
     <for>for (<init><expr><name>q</name> = <name>p</name> - 1</expr>;</init>  <condition><expr>(<name>q</name> &gt;= <name>candidate</name>) &amp;&amp; ((<name>p</name> - <name>q</name>) &lt; 10)</expr>;</condition>  <incr><expr><name>q</name>--</expr></incr>) <block>{
      <expr_stmt><expr><name>tmpc</name> = *(<name>q</name>+1)</expr>;</expr_stmt>
      <expr_stmt><expr>*(<name>q</name>+1) = *<name>q</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
      <if>if <condition>(<expr>(<name>p</name>-<name>q</name>) &lt; 2</expr>)</condition><then> <continue>continue;</continue></then></if> <comment type="line">// omit swap char</comment>
      <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   }</block></for>   
   <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is a letter was moved</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>movechar_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>w_char</name></type> <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name></type>   <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name> *</type> <name>p</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name> *</type> <name>q</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>w_char</name></type> <name>tmpc</name></decl>;</decl_stmt>
   <comment type="line">// try moving a char</comment>
   <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <for>for (<init><expr><name>p</name> = <name>candidate_utf</name></expr>;</init>  <condition><expr><name>p</name> &lt; (<name>candidate_utf</name> + <name>wl</name>)</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
     <for>for (<init><expr><name>q</name> = <name>p</name> + 1</expr>;</init>  <condition><expr>(<name>q</name> &lt; (<name>candidate_utf</name> + <name>wl</name>)) &amp;&amp; ((<name>q</name> - <name>p</name>) &lt; 10)</expr>;</condition>  <incr><expr><name>q</name>++</expr></incr>) <block>{
         <expr_stmt><expr><name>tmpc</name> = *(<name>q</name>-1)</expr>;</expr_stmt>
         <expr_stmt><expr>*(<name>q</name>-1) = *<name>q</name></expr>;</expr_stmt>
         <expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
         <if>if <condition>(<expr>(<name>q</name>-<name>p</name>) &lt; 2</expr>)</condition><then> <continue>continue;</continue></then></if> <comment type="line">// omit swap char</comment>
         <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
     }</block></for>
     <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   }</block></for>
   <for>for (<init><expr><name>p</name> = <name>candidate_utf</name> + <name>wl</name> - 1</expr>;</init>  <condition><expr><name>p</name> &gt; <name>candidate_utf</name></expr>;</condition>  <incr><expr><name>p</name>--</expr></incr>) <block>{
     <for>for (<init><expr><name>q</name> = <name>p</name> - 1</expr>;</init>  <condition><expr>(<name>q</name> &gt;= <name>candidate_utf</name>) &amp;&amp; ((<name>p</name> - <name>q</name>) &lt; 10)</expr>;</condition>  <incr><expr><name>q</name>--</expr></incr>) <block>{
         <expr_stmt><expr><name>tmpc</name> = *(<name>q</name>+1)</expr>;</expr_stmt>
         <expr_stmt><expr>*(<name>q</name>+1) = *<name>q</name></expr>;</expr_stmt>
         <expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
         <if>if <condition>(<expr>(<name>p</name>-<name>q</name>) &lt; 2</expr>)</condition><then> <continue>continue;</continue></then></if> <comment type="line">// omit swap char</comment>
         <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
     }</block></for>
     <expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   }</block></for>
   <return>return <expr><name>ns</name></expr>;</return>   
}</block></function>

<comment type="line">// generate a set of suggestions for very poorly spelled words</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>ngsuggest</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>w</name></decl></param>, <param><decl><type><name>HashMgr</name>*</type> <name>pHMgr</name></decl></param>)</parameter_list>
<block>{

  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>lval</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>sc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>lp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nonbmp</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>pHMgr</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>

  <comment type="line">// exhaustively search through all root words</comment>
  <comment type="line">// keeping track of the MAX_ROOTS most similar root words</comment>
  <decl_stmt><decl><type>struct <name>hentry</name> *</type> <name><name>roots</name><index>[<expr><name>MAX_ROOTS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>scores</name><index>[<expr><name>MAX_ROOTS</name></expr>]</index></name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_ROOTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>roots</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scores</name><index>[<expr><name>i</name></expr>]</index></name> = -100 * <name>i</name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>lp</name> = <name>MAX_ROOTS</name> - 1</expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXWORDUTF8LEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type> <name>word</name> <init>= <expr><name>w</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// word reversing wrapper for complex prefixes</comment>
  <if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>char</name></type> <name><name>mw</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>w_char</name></type> <name><name>u8</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nc</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>(<name>utf8</name>) ? <call><name>u8_u16</name><argument_list>(<argument><expr><name>u8</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call> : <name>nc</name></expr></init></decl>;</decl_stmt>
  
  <comment type="line">// set character based ngram suggestion for words with non-BMP Unicode characters</comment>
  <if>if <condition>(<expr><name>n</name> == -1</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>utf8</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> = <name>nc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nonbmp</name> = 1</expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type>struct <name>hentry</name>*</type> <name>hp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>col</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr>(<name>hp</name> = <call><name><name>pHMgr</name>-&gt;<name>walk_hashtable</name></name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>hp</name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
    <if>if <condition>(<expr>(<name><name>hp</name>-&gt;<name>astr</name></name>) &amp;&amp; (<name>pAMgr</name>) &amp;&amp; 
       (<call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>hp</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_forbiddenword</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>hp</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
          <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>hp</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><name>ONLYUPCASEFLAG</name></expr></argument>, <argument><expr><name><name>hp</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
          <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>hp</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_nosuggest</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>hp</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
          <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>hp</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_onlyincompound</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>hp</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <continue>continue;</continue></then></if>
    <expr_stmt><expr><name>sc</name> = <call><name>ngram</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>hp</name>-&gt;<name>word</name></name></expr></argument>, <argument><expr><name>NGRAM_LONGER_WORSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>sc</name> &gt; <name><name>scores</name><index>[<expr><name>lp</name></expr>]</index></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>scores</name><index>[<expr><name>lp</name></expr>]</index></name> = <name>sc</name></expr>;</expr_stmt>  
      <expr_stmt><expr><name><name>roots</name><index>[<expr><name>lp</name></expr>]</index></name> = <name>hp</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>lval</name> = <name>sc</name></expr>;</expr_stmt>
      <for>for (<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name> &lt; <name>MAX_ROOTS</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
        <if>if <condition>(<expr><name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name> &lt; <name>lval</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>lp</name> = <name>j</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>lval</name> = <name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if></for>
    }</block></then></if>  
  }</block></while>

  <comment type="line">// find minimum threshhold for a passable suggestion</comment>
  <comment type="line">// mangle original word three differnt ways</comment>
  <comment type="line">// and score them to generate a minimum acceptable score</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>thresh</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>int</name></type> <name>sp</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>sp</name> &lt; 4</expr>;</condition> <incr><expr><name>sp</name>++</expr></incr>) <block>{
     <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
       <for>for (<init><decl><type><name>int</name></type> <name>k</name><init>=<expr><name>sp</name></expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>k</name>+=4</expr></incr>) <expr_stmt><expr>*((<name>unsigned</name> <name>short</name> *) <name>u8</name> + <name>k</name>) = '*'</expr>;</expr_stmt></for>
       <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>mw</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>u8</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>thresh</name> = <name>thresh</name> + <call><name>ngram</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>mw</name></expr></argument>, <argument><expr><name>NGRAM_ANY_MISMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     }</block></then> <else>else <block>{
       <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>mw</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <for>for (<init><decl><type><name>int</name></type> <name>k</name><init>=<expr><name>sp</name></expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>k</name>+=4</expr></incr>) <expr_stmt><expr>*(<name>mw</name> + <name>k</name>) = '*'</expr>;</expr_stmt></for>
       <expr_stmt><expr><name>thresh</name> = <name>thresh</name> + <call><name>ngram</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>mw</name></expr></argument>, <argument><expr><name>NGRAM_ANY_MISMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     }</block></else></if>
  }</block></for>
  <expr_stmt><expr><name>thresh</name> = <name>thresh</name> / 3</expr>;</expr_stmt>
  <expr_stmt><expr><name>thresh</name>--</expr>;</expr_stmt>

  <comment type="line">// now expand affixes on each of these root words and</comment>
  <comment type="line">// and use length adjusted ngram scores to select</comment>
  <comment type="line">// possible suggestions</comment>
  <decl_stmt><decl><type><name>char</name> *</type> <name><name>guess</name><index>[<expr><name>MAX_GUESS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>gscore</name><index>[<expr><name>MAX_GUESS</name></expr>]</index></name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init><condition><expr><name>i</name>&lt;<name>MAX_GUESS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <block>{
     <expr_stmt><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
     <expr_stmt><expr><name><name>gscore</name><index>[<expr><name>i</name></expr>]</index></name> = -100 * <name>i</name></expr>;</expr_stmt>
  }</block></for>

  <expr_stmt><expr><name>lp</name> = <name>MAX_GUESS</name> - 1</expr>;</expr_stmt>

  <decl_stmt><decl><type>struct <name>guessword</name> *</type> <name>glst</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>glst</name> = (struct <name>guessword</name> *) <call><name>calloc</name><argument_list>(<argument><expr><name>MAX_WORDS</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>guessword</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>glst</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>nonbmp</name></expr>)</condition><then> <expr_stmt><expr><name>utf8</name> = 1</expr>;</expr_stmt></then></if>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_ROOTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{

      <if>if <condition>(<expr><name><name>roots</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rp</name> <init>= <expr><name><name>roots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nw</name> <init>= <expr><call><name><name>pAMgr</name>-&gt;<name>expand_rootword</name></name><argument_list>(<argument><expr><name>glst</name></expr></argument>, <argument><expr><name>MAX_WORDS</name></expr></argument>, <argument><expr><name><name>rp</name>-&gt;<name>word</name></name></expr></argument>, <argument><expr><name><name>rp</name>-&gt;<name>wlen</name></name></expr></argument>,
                                        <argument><expr><name><name>rp</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><name><name>rp</name>-&gt;<name>alen</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>nw</name></expr> ;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
           <expr_stmt><expr><name>sc</name> = <call><name>ngram</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>word</name></expr></argument>, <argument><expr><name>NGRAM_ANY_MISMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <if>if <condition>(<expr>(<name>sc</name> &gt; <name>thresh</name>)</expr>)</condition><then> <block>{
              <if>if <condition>(<expr><name>sc</name> &gt; <name><name>gscore</name><index>[<expr><name>lp</name></expr>]</index></name></expr>)</condition><then> <block>{
                 <if>if <condition>(<expr><name><name>guess</name><index>[<expr><name>lp</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>lp</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                 <expr_stmt><expr><name><name>gscore</name><index>[<expr><name>lp</name></expr>]</index></name> = <name>sc</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name><name>guess</name><index>[<expr><name>lp</name></expr>]</index></name> = <name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>word</name></expr>;</expr_stmt>
                 <expr_stmt><expr><name>lval</name> = <name>sc</name></expr>;</expr_stmt>
                 <for>for (<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name> &lt; <name>MAX_GUESS</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
                    <if>if <condition>(<expr><name><name>gscore</name><index>[<expr><name>j</name></expr>]</index></name> &lt; <name>lval</name></expr>)</condition><then> <block>{
                       <expr_stmt><expr><name>lp</name> = <name>j</name></expr>;</expr_stmt>
                       <expr_stmt><expr><name>lval</name> = <name><name>gscore</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                    }</block></then></if></for>
              }</block></then> <else>else <expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>  
           }</block></then> <else>else <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></for>
      }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>glst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// now we are done generating guesses</comment>
  <comment type="line">// sort in order of decreasing score</comment>
  
  <expr_stmt><expr><call><name>bubblesort</name><argument_list>(<argument><expr>&amp;<name><name>guess</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>gscore</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>MAX_GUESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// weight suggestions with a similarity index, based on</comment>
  <comment type="line">// the longest common subsequent algorithm and resort</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>is_swap</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_GUESS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <if>if <condition>(<expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
        <comment type="line">// lowering guess[i]</comment>
        <decl_stmt><decl><type><name>char</name></type> <name><name>gl</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>w_char</name></type> <name><name>_w</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
          <expr_stmt><expr><name>len</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>_w</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>mkallsmall_utf</name><argument_list>(<argument><expr><name>_w</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_langnum</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>gl</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>_w</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>gl</name></expr></argument>, <argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>mkallsmall</name><argument_list>(<argument><expr><name>gl</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <decl_stmt><decl><type><name>int</name></type> <name>_lcs</name> <init>= <expr><call><name>lcslen</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// same characters with different casing</comment>
        <if>if <condition>(<expr>(<name>n</name> == <name>len</name>) &amp;&amp; (<name>n</name> == <name>_lcs</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>gscore</name><index>[<expr><name>i</name></expr>]</index></name> += 2000</expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        
        <comment type="line">// heuristic weigthing of ngram scores</comment>
        <expr_stmt><expr><name><name>gscore</name><index>[<expr><name>i</name></expr>]</index></name> +=
          <comment type="line">// length of longest common subsequent minus lenght difference</comment>
          2 * <name>_lcs</name> - <call><name>abs</name><argument_list>(<argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>n</name> - <name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
          <comment type="line">// weight equal first letter</comment>
          <call><name>equalfirstletter</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>)</argument_list></call> +
          <comment type="line">// weight equal character positions</comment>
          ((<name>_lcs</name> == <call><name>commoncharacterpositions</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>, <argument><expr>&amp;<name>is_swap</name></expr></argument>)</argument_list></call>) ? 1: 0) +
          <comment type="line">// swap character (not neighboring)</comment>
          ((<name>is_swap</name>) ? 1000 : 0)</expr>;</expr_stmt>
      }</block></then></if>
  }</block></for>

  <expr_stmt><expr><call><name>bubblesort</name><argument_list>(<argument><expr>&amp;<name><name>guess</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>gscore</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>MAX_GUESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// copy over</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>ns</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>same</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_GUESS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <if>if <condition>(<expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr>(<name>ns</name> &lt; <name>maxngramsugs</name>) &amp;&amp; (<name>ns</name> &lt; <name>maxSug</name>) &amp;&amp; (!<name>same</name> || (<name><name>gscore</name><index>[<expr><name>i</name></expr>]</index></name> &gt; 1000))</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>unique</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
        <comment type="line">// we have excellent suggestion(s)</comment>
        <if>if <condition>(<expr><name><name>gscore</name><index>[<expr><name>i</name></expr>]</index></name> &gt; 1000</expr>)</condition><then> <expr_stmt><expr><name>same</name> = 1</expr>;</expr_stmt></then></if>
        <for>for (<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
          <comment type="line">// don't suggest previous suggestions or a previous suggestion with prefixes or affixes</comment>
          <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> || 
            <comment type="line">// check forbidden words</comment>
            !<call><name>checkword</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>unique</name> = 0</expr>;</expr_stmt></then></if></for>
        <if>if <condition>(<expr><name>unique</name></expr>)</condition><then> <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name>++</expr>]</index></name> = <name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      }</block></then> <else>else <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
  }</block></for>

  <if>if <condition>(<expr><name>nonbmp</name></expr>)</condition><then> <expr_stmt><expr><name>utf8</name> = 1</expr>;</expr_stmt></then></if>
  <return>return <expr><name>ns</name></expr>;</return>
}</block></function>


<comment type="line">// see if a candidate suggestion is spelled correctly</comment>
<comment type="line">// needs to check both root words and words with affixes</comment>

<comment type="line">// obsolote MySpell-HU modifications:</comment>
<comment type="line">// return value 2 and 3 marks compounding with hyphen (-)</comment>
<comment type="line">// `3' marks roots without suffix</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>checkword</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>timer</name></decl></param>, <param><decl><type><name>time_t</name> *</type> <name>timelimit</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nosuffix</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  
  <comment type="line">// check time limit</comment>
  <if>if <condition>(<expr><name>timer</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>(*<name>timer</name>)--</expr>;</expr_stmt>
    <if>if <condition>(<expr>!(*<name>timer</name>) &amp;&amp; <name>timelimit</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &gt; *<name>timelimit</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>timelimit</name> = 0</expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
      <expr_stmt><expr>*<name>timer</name> = <name>MAXPLUSTIMER</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  
  <if>if <condition>(<expr><name>pAMgr</name></expr>)</condition><then> <block>{ 
    <if>if <condition>(<expr><name>cpdsuggest</name>==1</expr>)</condition><then> <block>{
      <if>if <condition>(<expr><call><name><name>pAMgr</name>-&gt;<name>get_compound</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>compound_check</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <return>return <expr>3</expr>;</return></then></if> <comment type="line">// XXX obsolote categorisation</comment>
        }</block></then></if>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>lookup</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>(<name><name>rv</name>-&gt;<name>astr</name></name>) &amp;&amp; (<call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_forbiddenword</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call>
               || <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_nosuggest</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
        <while>while <condition>(<expr><name>rv</name></expr>)</condition> <block>{
    	    <if>if <condition>(<expr><name><name>rv</name>-&gt;<name>astr</name></name> &amp;&amp; (<call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_pseudoroot</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
                  <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><name>ONLYUPCASEFLAG</name></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
            <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_onlyincompound</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        	<expr_stmt><expr><name>rv</name> = <name><name>rv</name>-&gt;<name>next_homonym</name></name></expr>;</expr_stmt>
    	    }</block></then> <else>else <break>break;</break></else></if>
    	}</block></while>
    }</block></then> <else>else <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>prefix_check</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if> <comment type="line">// only prefix, and prefix + suffix XXX</comment>
    
    <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nosuffix</name>=1</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>suffix_check</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// only suffix</comment>
    }</block></else></if>

    <if>if <condition>(<expr>!<name>rv</name> &amp;&amp; <call><name><name>pAMgr</name>-&gt;<name>have_contclass</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>suffix_check_twosfx</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FLAG_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>rv</name></expr>)</condition><then> <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>prefix_check_twosfx</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>FLAG_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <comment type="line">// check forbidden words</comment>
    <if>if <condition>(<expr>(<name>rv</name>) &amp;&amp; (<name><name>rv</name>-&gt;<name>astr</name></name>) &amp;&amp; (<call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_forbiddenword</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
      <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><name>ONLYUPCASEFLAG</name></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
      <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_nosuggest</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
      <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_onlyincompound</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>

    <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{ <comment type="line">// XXX obsolote    </comment>
      <if>if <condition>(<expr>(<call><name><name>pAMgr</name>-&gt;<name>get_compoundflag</name></name><argument_list>()</argument_list></call>) &amp;&amp; 
          <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_compoundflag</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>2 + <name>nosuffix</name></expr>;</return></then></if> 
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>check_forbidden</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>pAMgr</name></expr>)</condition><then> <block>{ 
    <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>lookup</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> &amp;&amp; <name><name>rv</name>-&gt;<name>astr</name></name> &amp;&amp; (<call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_pseudoroot</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
        <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_onlyincompound</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <expr_stmt><expr><name>rv</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>!(<call><name><name>pAMgr</name>-&gt;<name>prefix_check</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>suffix_check</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>,<argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> <comment type="line">// prefix+suffix, suffix</comment>
    <comment type="line">// check forbidden words</comment>
    <if>if <condition>(<expr>(<name>rv</name>) &amp;&amp; (<name><name>rv</name>-&gt;<name>astr</name></name>) &amp;&amp; <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_forbiddenword</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
   }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HUNSPELL_EXPERIMENTAL</name></cpp:ifdef>
<comment type="line">// suggest stems, XXX experimental code</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>suggest_stems</name></name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type> <name>wlst</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int</name></type> <name>prevnsug</name> <init>= <expr><name>nsug</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXWORDUTF8LEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name> <init>= <expr><name>w</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// word reversing wrapper for complex prefixes</comment>
  <if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
  }</block></then></if>

    <if>if <condition>(<expr>*<name>slst</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>wlst</name> = *<name>slst</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>wlst</name> = (<name>char</name> **) <call><name>calloc</name><argument_list>(<argument><expr><name>maxSug</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>wlst</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    }</block></else></if>
    <comment type="line">// perhaps there are a fix stem in the dictionary</comment>
    <if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
    
    <expr_stmt><expr><name>nsug</name> = <call><name>fixstems</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>nsug</name> == <name>prevnsug</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type> <name>s</name> <init>= <expr><call><name>mystrdup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type> <name>p</name> <init>= <expr><name>s</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr>(*<name>p</name> != '-') &amp;&amp; (<name>p</name> != <name>s</name>)</expr>)</condition> <expr_stmt><expr><name>p</name>--</expr>;</expr_stmt></while>
        <if>if <condition>(<expr>*<name>p</name> == '-'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr><name>nsug</name> = <call><name>fixstems</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>nsug</name> == <name>prevnsug</name>) &amp;&amp; (<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt;= 0)</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>char</name> *</type> <name>t</name></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
                <for>for (<init><expr><name>t</name> = <name>s</name></expr>;</init> <condition><expr>(<name><name>t</name><index>[<expr>0</expr>]</index></name> != '\0') &amp;&amp; ((<name><name>t</name><index>[<expr>0</expr>]</index></name> &gt;= '0') || (<name><name>t</name><index>[<expr>0</expr>]</index></name> &lt;= '9'))</expr>;</condition> <incr><expr><name>t</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for> <comment type="line">// is a number?</comment>
                <if>if <condition>(<expr>*<name>t</name> != '\0'</expr>)</condition><then> <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"# "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>nsug</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>nsug</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
                <expr_stmt><expr><name>nsug</name>++</expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>nsug</name> = <call><name>fixstems</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>nsug</name> &lt; 0</expr>)</condition><then> <block>{
       <for>for (<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>maxSug</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
         <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
         <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>*<name>slst</name> = <name>wlst</name></expr>;</expr_stmt>
    <return>return <expr><name>nsug</name></expr>;</return>
}</block></function>


<comment type="line">// there are fix stems in dictionary</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>fixstems</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>prefix</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name> <init>= <expr>""</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>dicstem</name> <init>= <expr>1</expr></init></decl>;</decl_stmt> <comment type="line">// 0 = lookup, 1= affix, 2 = compound</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>cpdindex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>wl</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cmpdstemnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>cmpdstem</name><index>[<expr><name>MAXCOMPOUND</name></expr>]</index></name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>pAMgr</name></expr>)</condition><then> <block>{ 
        <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>lookup</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dicstem</name> = 0</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="line">// try stripping off affixes </comment>
            <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>affix_check</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// else try check compound word</comment>
            <if>if <condition>(<expr>!<name>rv</name> &amp;&amp; <call><name><name>pAMgr</name>-&gt;<name>get_compound</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>compound_check</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>,
                     <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>100</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>cmpdstemnum</name></expr></argument>, <argument><expr><name>cmpdstem</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>dicstem</name> = 2</expr>;</expr_stmt>
                    <for>for (<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>cmpdstemnum</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
                        <expr_stmt><expr><name>cpdindex</name> += <name><name>cmpdstem</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                    }</block></for>
                    <if>if<condition>(<expr>! (<call><name><name>pAMgr</name>-&gt;<name>lookup</name></name><argument_list>(<argument><expr><name>word</name> + <name>cpdindex</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>pAMgr</name>-&gt;<name>affix_check</name></name><argument_list>(<argument><expr><name>word</name> + <name>cpdindex</name></expr></argument>, <argument><expr><name>wl</name> - <name>cpdindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> <comment type="line">// for prefix</comment>
                }</block></then></if>
            }</block></then></if>


            <if>if <condition>(<expr><call><name><name>pAMgr</name>-&gt;<name>get_prefix</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_prefix</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// XXX obsolete, will be a general solution for stemming</comment>
            <if>if <condition>(<expr>(<name>prefix</name>) &amp;&amp; (<call><name>strncmp</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr>"leg"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call>==0)</expr>)</condition><then> <expr_stmt><expr><name><name>prefix</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if> <comment type="line">// (HU)       </comment>
        }</block></else></if>

    }</block></then></if>



    <if>if <condition>(<expr>(<name>rv</name>) &amp;&amp; (<name>ns</name> &lt; <name>maxSug</name>)</expr>)</condition><then> <block>{
    
        <comment type="line">// check fixstem flag and not_valid_stem flag</comment>
        <comment type="line">// first word</comment>
        <if>if <condition>(<expr>(<name>ns</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>dicstem</name> &lt; 2)</expr>)</condition><then> <block>{ 
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>dicstem</name> &gt; 0) &amp;&amp; <call><name><name>pAMgr</name>-&gt;<name>get_derived</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// XXX obsolote</comment>
                   <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>(<call><name><name>pAMgr</name>-&gt;<name>get_derived</name></name><argument_list>()</argument_list></call>) + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                   }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_derived</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                   }</block></else></if>
                }</block></then> <else>else <block>{
                        <comment type="line">// special stem in affix description</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>wordchars</name> <init>= <expr><call><name><name>pAMgr</name>-&gt;<name>get_wordchars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name><name>rv</name>-&gt;<name>description</name></name> &amp;&amp; 
                           (<call><name>strchr</name><argument_list>(<argument><expr><name>wordchars</name></expr></argument>, <argument><expr>*(<name><name>rv</name>-&gt;<name>description</name></name>)</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                           <decl_stmt><decl><type><name>char</name> *</type> <name>desc</name> <init>= <expr>(<name><name>rv</name>-&gt;<name>description</name></name>) + 1</expr></init></decl>;</decl_stmt>
                           <while>while <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>wordchars</name></expr></argument>, <argument><expr>*<name>desc</name></expr></argument>)</argument_list></call></expr>)</condition> <expr_stmt><expr><name>desc</name>++</expr>;</expr_stmt></while>
                           <expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>description</name></name></expr></argument>, <argument><expr><name>desc</name> - (<name><name>rv</name>-&gt;<name>description</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                }</block></else></if>
            <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
            <expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>dicstem</name> == 2</expr>)</condition><then> <block>{

            <comment type="line">// compound stem</comment>

<comment type="line">//          if (rv-&gt;astr &amp;&amp; (strchr(rv-&gt;astr, '0') == NULL)) {</comment>
            <if>if <condition>(<expr><name><name>rv</name>-&gt;<name>astr</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>buf</name><index>[<expr><name>cpdindex</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>prefix</name></expr>)</condition><then> <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr><call><name><name>pAMgr</name>-&gt;<name>get_derived</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_derived</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                        <comment type="line">// special stem in affix description</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>wordchars</name> <init>= <expr><call><name><name>pAMgr</name>-&gt;<name>get_wordchars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name><name>rv</name>-&gt;<name>description</name></name> &amp;&amp; 
                           (<call><name>strchr</name><argument_list>(<argument><expr><name>wordchars</name></expr></argument>, <argument><expr>*(<name><name>rv</name>-&gt;<name>description</name></name>)</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                           <decl_stmt><decl><type><name>char</name> *</type> <name>desc</name> <init>= <expr>(<name><name>rv</name>-&gt;<name>description</name></name>) + 1</expr></init></decl>;</decl_stmt>
                           <while>while <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>wordchars</name></expr></argument>, <argument><expr>*<name>desc</name></expr></argument>)</argument_list></call></expr>)</condition> <expr_stmt><expr><name>desc</name>++</expr>;</expr_stmt></while>
                           <expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>description</name></name></expr></argument>, <argument><expr><name>desc</name> - (<name><name>rv</name>-&gt;<name>description</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                }</block></else></if>
                <if>if <condition>(<expr><name>ns</name> &lt; <name>maxSug</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
                    <expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// suggest possible stems</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>suggest_pos_stems</name></name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> **</type> <name>wlst</name></decl>;</decl_stmt>    

    <decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name> <init>= <expr><name>w</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// word reversing wrapper for complex prefixes</comment>
  <if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
  }</block></then></if>

    <decl_stmt><decl><type><name>int</name></type> <name>wl</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


    <if>if <condition>(<expr>*<name>slst</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>wlst</name> = *<name>slst</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>wlst</name> = (<name>char</name> **) <call><name>calloc</name><argument_list>(<argument><expr><name>maxSug</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>wlst</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
    }</block></else></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>suffix_check</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>maxSug</name></expr></argument>, <argument><expr>&amp;<name>nsug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// delete dash from end of word</comment>
    <if>if <condition>(<expr><name>nsug</name> &gt; 0</expr>)</condition><then> <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>j</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>nsug</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> - 1</expr>]</index></name> == '-'</expr>)</condition><then> <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> - 1</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>
        }</block></for>
    }</block></then></if>

    <expr_stmt><expr>*<name>slst</name> = <name>wlst</name></expr>;</expr_stmt>
    <return>return <expr><name>nsug</name></expr>;</return>
}</block></function>


<function><type><name>char</name> *</type> <name><name>SuggestMgr</name>::<name>suggest_morph</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>w</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>result</name><index>[<expr><name>MAXLNLEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type> <name>r</name> <init>= <expr>(<name>char</name> *) <name>result</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type> <name>st</name></decl>;</decl_stmt>

    <decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>result</name> = '\0'</expr>;</expr_stmt>

    <if>if <condition>(<expr>! <name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name> <init>= <expr><name>w</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// word reversing wrapper for complex prefixes</comment>
  <if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
  }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>pAMgr</name>-&gt;<name>lookup</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <while>while <condition>(<expr><name>rv</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>(!<name><name>rv</name>-&gt;<name>astr</name></name>) || !(<call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_forbiddenword</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
            <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_pseudoroot</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call> ||
            <call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>,<argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_onlyincompound</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>rv</name>-&gt;<name>description</name></name> &amp;&amp; ((!<name><name>rv</name>-&gt;<name>astr</name></name>) || 
                !<call><name>TESTAFF</name><argument_list>(<argument><expr><name><name>rv</name>-&gt;<name>astr</name></name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_lemma_present</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>alen</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name><name>rv</name>-&gt;<name>description</name></name></expr>)</condition><then> <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>rv</name>-&gt;<name>description</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>rv</name> = <name><name>rv</name>-&gt;<name>next_homonym</name></name></expr>;</expr_stmt>
    }</block></while>
    
    <expr_stmt><expr><name>st</name> = <call><name><name>pAMgr</name>-&gt;<name>affix_check_morph</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>st</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name><name>pAMgr</name>-&gt;<name>get_compound</name></name><argument_list>()</argument_list></call> &amp;&amp; (*<name>result</name> == '\0')</expr>)</condition><then>
        <expr_stmt><expr><call><name><name>pAMgr</name>-&gt;<name>compound_check_morph</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>100</expr></argument>, <argument><expr>0</expr></argument>,<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    
    <return>return <expr>(*<name>result</name>) ? <call><name>mystrdup</name><argument_list>(<argument><expr><call><name>line_uniq</name><argument_list>(<argument><expr><call><name>delete_zeros</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type> <name><name>SuggestMgr</name>::<name>suggest_morph_for_spelling_error</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type> <name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type> <name>wlst</name> <init>= <expr>(<name>char</name> **) <call><name>calloc</name><argument_list>(<argument><expr><name>maxSug</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!**<name>wlst</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <comment type="line">// we will use only the first suggestion</comment>
    <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>maxSug</name> - 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name> = ""</expr>;</expr_stmt></for>
    <decl_stmt><decl><type><name>int</name></type> <name>ns</name> <init>= <expr><call><name>suggest</name><argument_list>(<argument><expr>&amp;<name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>maxSug</name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>ns</name> == <name>maxSug</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>p</name> = <call><name>suggest_morph</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>maxSug</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>maxSug</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>wlst</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>p</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// END OF HUNSPELL_EXPERIMENTAL CODE</comment>


<comment type="line">// generate an n-gram score comparing s1 and s2</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>ngram</name></name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>s1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name></type> <name>uselen</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nscore</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ns</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>l1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>l2</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>w_char</name></type> <name><name>su1</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>w_char</name></type> <name><name>su2</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name>l1</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>su1</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>l2</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>l2</name> || (<name>l1</name>==-1) || (<name>l2</name>==-1)</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <comment type="line">// lowering dictionary word</comment>
    <expr_stmt><expr><call><name>mkallsmall_utf</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_langnum</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>j</name> &lt;= <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name>ns</name> = 0</expr>;</expr_stmt>
      <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= (<name>l1</name>-<name>j</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>l</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>l</name> &lt;= (<name>l2</name>-<name>j</name>)</expr>;</condition> <incr><expr><name>l</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
            <for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr>(<name>k</name> &lt; <name>j</name>)</expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
              <decl_stmt><decl><type><name>w_char</name> *</type> <name>c1</name> <init>= <expr><name>su1</name> + <name>i</name> + <name>k</name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>w_char</name> *</type> <name>c2</name> <init>= <expr><name>su2</name> + <name>l</name> + <name>k</name></expr></init></decl>;</decl_stmt>
              <if>if <condition>(<expr>(<name><name>c1</name>-&gt;<name>l</name></name> != <name><name>c2</name>-&gt;<name>l</name></name>) || (<name><name>c1</name>-&gt;<name>h</name></name> != <name><name>c2</name>-&gt;<name>h</name></name>)</expr>)</condition><then> <break>break;</break></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>k</name> == <name>j</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>
      }</block></for>
      <expr_stmt><expr><name>nscore</name> = <name>nscore</name> + <name>ns</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ns</name> &lt; 2</expr>)</condition><then> <break>break;</break></then></if>
    }</block></for>
  }</block></then> <else>else <block>{  
    <decl_stmt><decl><type><name>char</name></type> <name><name>t</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name>l1</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>l2</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>l2</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mkallsmall</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>j</name> &lt;= <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name>ns</name> = 0</expr>;</expr_stmt>
      <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= (<name>l1</name>-<name>j</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr>*(<name>s1</name> + <name>i</name> + <name>j</name>)</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*(<name>s1</name> + <name>i</name> + <name>j</name>) = '\0'</expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr>(<name>s1</name>+<name>i</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt></then></if>
        <expr_stmt><expr>*(<name>s1</name> + <name>i</name> + <name>j</name> ) = <name>c</name></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><name>nscore</name> = <name>nscore</name> + <name>ns</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ns</name> &lt; 2</expr>)</condition><then> <break>break;</break></then></if>
    }</block></for>
  }</block></else></if>
  
  <expr_stmt><expr><name>ns</name> = 0</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>uselen</name> == <name>NGRAM_LONGER_WORSE</name></expr>)</condition><then> <expr_stmt><expr><name>ns</name> = (<name>l2</name>-<name>l1</name>)-2</expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>uselen</name> == <name>NGRAM_ANY_MISMATCH</name></expr>)</condition><then> <expr_stmt><expr><name>ns</name> = <call><name>abs</name><argument_list>(<argument><expr><name>l2</name>-<name>l1</name></expr></argument>)</argument_list></call>-2</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>ns</name> = (<name>nscore</name> - ((<name>ns</name> &gt; 0) ? <name>ns</name> : 0))</expr>;</expr_stmt>
  <return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>equalfirstletter</name></name><parameter_list>(<param><decl><type><name>char</name> *</type> <name>s1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>s2</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>w_char</name></type> <name><name>su1</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>w_char</name></type> <name><name>su2</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
    <comment type="line">// decapitalize dictionary word</comment>
    <if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>l1</name> <init>= <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su1</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>l2</name> <init>= <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>*((<name>short</name> *)<name>su1</name>+<name>l1</name>-1) == *((<name>short</name> *)<name>su2</name>+<name>l2</name>-1)</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su1</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>*((<name>short</name> *)<name>su1</name>) == *((<name>short</name> *)<name>su2</name>)</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
    }</block></else></if>
  }</block></then> <else>else <block>{
    <if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>l1</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>l2</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>*(<name>s2</name>+<name>l1</name>-1) == *(<name>s2</name>+<name>l2</name>-1)</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
    }</block></then> <else>else <block>{
      <if>if <condition>(<expr>*<name>s1</name> == *<name>s2</name></expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
    }</block></else></if>
  }</block></else></if>
  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>commoncharacterpositions</name></name><parameter_list>(<param><decl><type><name>char</name> *</type> <name>s1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>is_swap</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>diffpos</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>is_swap</name> = 0</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>w_char</name></type> <name><name>su1</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>w_char</name></type> <name><name>su2</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>l1</name> <init>= <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su1</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>l2</name> <init>= <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// decapitalize dictionary word</comment>
    <if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>mkallsmall_utf</name><argument_list>(<argument><expr><name>su2</name>+<name>l2</name>-1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_langnum</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>mkallsmall_utf</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name><name>pAMgr</name>-&gt;<name>get_langnum</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr>(<name>i</name> &lt; <name>l1</name>) &amp;&amp; (<name>i</name> &lt; <name>l2</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <if>if <condition>(<expr>((<name>short</name> *) <name>su1</name>)<index>[<expr><name>i</name></expr>]</index> == ((<name>short</name> *) <name>su2</name>)<index>[<expr><name>i</name></expr>]</index></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>num</name>++</expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <if>if <condition>(<expr><name>diff</name> &lt; 2</expr>)</condition><then> <expr_stmt><expr><name><name>diffpos</name><index>[<expr><name>diff</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>diff</name>++</expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
    <if>if <condition>(<expr>(<name>diff</name> == 2) &amp;&amp; (<name>l1</name> == <name>l2</name>) &amp;&amp;
        (((<name>short</name> *) <name>su1</name>)<index>[<expr><name><name>diffpos</name><index>[<expr>0</expr>]</index></name></expr>]</index> == ((<name>short</name> *) <name>su2</name>)<index>[<expr><name><name>diffpos</name><index>[<expr>1</expr>]</index></name></expr>]</index>) &amp;&amp;
        (((<name>short</name> *) <name>su1</name>)<index>[<expr><name><name>diffpos</name><index>[<expr>1</expr>]</index></name></expr>]</index> == ((<name>short</name> *) <name>su2</name>)<index>[<expr><name><name>diffpos</name><index>[<expr>0</expr>]</index></name></expr>]</index>)</expr>)</condition><then> <expr_stmt><expr>*<name>is_swap</name> = 1</expr>;</expr_stmt></then></if>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>t</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// decapitalize dictionary word</comment>
    <if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>l2</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr>*(<name>t</name>+<name>l2</name>-1) = <name><name>csconv</name><index>[<expr>((<name>unsigned</name> <name>char</name>)*(<name>t</name>+<name>l2</name>-1))</expr>]</index></name>.<name>clower</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name>mkallsmall</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr>(*(<name>s1</name>+<name>i</name>) != 0) &amp;&amp; (*(<name>t</name>+<name>i</name>) != 0)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <if>if <condition>(<expr>*(<name>s1</name>+<name>i</name>) == *(<name>t</name>+<name>i</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>num</name>++</expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <if>if <condition>(<expr><name>diff</name> &lt; 2</expr>)</condition><then> <expr_stmt><expr><name><name>diffpos</name><index>[<expr><name>diff</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>diff</name>++</expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
    <if>if <condition>(<expr>(<name>diff</name> == 2) &amp;&amp; (*(<name>s1</name>+<name>i</name>) == 0) &amp;&amp; (*(<name>t</name>+<name>i</name>) == 0) &amp;&amp;
      (*(<name>s1</name>+<name><name>diffpos</name><index>[<expr>0</expr>]</index></name>) == *(<name>t</name>+<name><name>diffpos</name><index>[<expr>1</expr>]</index></name>)) &amp;&amp;
      (*(<name>s1</name>+<name><name>diffpos</name><index>[<expr>1</expr>]</index></name>) == *(<name>t</name>+<name><name>diffpos</name><index>[<expr>0</expr>]</index></name>))</expr>)</condition><then> <expr_stmt><expr>*<name>is_swap</name> = 1</expr>;</expr_stmt></then></if>
  }</block></else></if>
  <return>return <expr><name>num</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>mystrlen</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>word</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>w_char</name></type> <name><name>w</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
    <return>return <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then> <else>else <return>return <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<comment type="line">// sort in decreasing order of score</comment>
<function><type><name>void</name></type> <name><name>SuggestMgr</name>::<name>bubblesort</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>rword</name></decl></param>, <param><decl><type><name>int</name>*</type> <name>rsc</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param> )</parameter_list>
<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>m</name> &lt; <name>n</name></expr>)</condition> <block>{
          <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>m</name></expr></init></decl>;</decl_stmt>
          <while>while <condition>(<expr><name>j</name> &gt; 0</expr>)</condition> <block>{
            <if>if <condition>(<expr><name><name>rsc</name><index>[<expr><name>j</name>-1</expr>]</index></name> &lt; <name><name>rsc</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>sctmp</name> <init>= <expr><name><name>rsc</name><index>[<expr><name>j</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> *</type> <name>wdtmp</name> <init>= <expr><name><name>rword</name><index>[<expr><name>j</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>rsc</name><index>[<expr><name>j</name>-1</expr>]</index></name> = <name><name>rsc</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rword</name><index>[<expr><name>j</name>-1</expr>]</index></name> = <name><name>rword</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rsc</name><index>[<expr><name>j</name></expr>]</index></name> = <name>sctmp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rword</name><index>[<expr><name>j</name></expr>]</index></name> = <name>wdtmp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
            }</block></then> <else>else <break>break;</break></else></if>
          }</block></while>
          <expr_stmt><expr><name>m</name>++</expr>;</expr_stmt>
      }</block></while>
      <return>return;</return>
}</block></function>

<comment type="line">// longest common subsequence</comment>
<function><type><name>void</name></type> <name><name>SuggestMgr</name>::<name>lcs</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>s</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>l1</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>l2</name></decl></param>, <param><decl><type><name>char</name> **</type> <name>result</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>w_char</name></type> <name><name>su</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>w_char</name></type> <name><name>su2</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type> <name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>m</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>m</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>c</name> = (<name>char</name> *) <call><name>malloc</name><argument_list>(<argument><expr>(<name>m</name> + 1) * (<name>n</name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> = (<name>char</name> *) <call><name>malloc</name><argument_list>(<argument><expr>(<name>m</name> + 1) * (<name>n</name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>c</name> || !<name>b</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>c</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>b</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr>*<name>result</name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= <name>m</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1)</expr>]</index></name> = 0</expr>;</expr_stmt></for>
  <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt;= <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <expr_stmt><expr><name><name>c</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>
  <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= <name>m</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <for>for (<init><expr><name>j</name> = 1</expr>;</init> <condition><expr><name>j</name> &lt;= <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
      <if>if <condition>(<expr>(<name>utf8</name>) &amp;&amp; (*((<name>short</name> *) <name>su</name>+<name>i</name>-1) == *((<name>short</name> *)<name>su2</name>+<name>j</name>-1))
          || (!<name>utf8</name>) &amp;&amp; ((*(<name>s</name>+<name>i</name>-1)) == (*(<name>s2</name>+<name>j</name>-1)))</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name><name>c</name><index>[<expr>(<name>i</name>-1)*(<name>n</name>+1) + <name>j</name>-1</expr>]</index></name>+1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name>LCS_UPLEFT</name></expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><name><name>c</name><index>[<expr>(<name>i</name>-1)*(<name>n</name>+1) + <name>j</name></expr>]</index></name> &gt;= <name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name>-1</expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name><name>c</name><index>[<expr>(<name>i</name>-1)*(<name>n</name>+1) + <name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name>LCS_UP</name></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name>-1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name>LCS_LEFT</name></expr>;</expr_stmt>
      }</block></else></if></else></if>
    }</block></for>
  }</block></for>
  <expr_stmt><expr>*<name>result</name> = <name>b</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>l1</name> = <name>m</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>l2</name> = <name>n</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>lcslen</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type> <name>s</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>s2</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>m</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lcs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>i</name> = <name>m</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>j</name> = <name>n</name></expr>;</expr_stmt>
  <while>while <condition>(<expr>(<name>i</name> != 0) &amp;&amp; (<name>j</name> != 0)</expr>)</condition> <block>{
    <if>if <condition>(<expr><name><name>result</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> == <name>LCS_UPLEFT</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>len</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name><name>result</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> == <name>LCS_UP</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt>
    }</block></then> <else>else <expr_stmt><expr><name>j</name>--</expr>;</expr_stmt></else></if></else></if>
  }</block></while>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>len</name></expr>;</return>
}</block></function>
</unit>
