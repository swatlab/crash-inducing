<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0029699a9650a52975d4afebf2126fbe429716b3.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* vim:set ts=2 sts=2 sw=2 et cin: */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Masayuki Nakano &lt;masayuki@d-toybox.com&gt;
 *
 * Original nsWindow.cpp Contributor(s):
 *   Dean Tessman &lt;dean_tessman@hotmail.com&gt;
 *   Ere Maijala &lt;ere@atp.fi&gt;
 *   Mark Hammond &lt;markh@activestate.com&gt;
 *   Michael Lowe &lt;michael.lowe@bigfoot.com&gt;
 *   Peter Bajusz &lt;hyp-x@inf.bme.hu&gt;
 *   Pierre Phaneuf &lt;pp@ludusdesign.com&gt;
 *   Robert O'Callahan &lt;roc+moz@cs.cmu.edu&gt;
 *   Roy Yokoyama &lt;yokoyama@netscape.com&gt;
 *   Makoto Kato  &lt;m_kato@ga2.so-net.ne.jp&gt;
 *   Masayuki Nakano &lt;masayuki@d-toybox.com&gt;
 *   Dainis Jonitis &lt;Dainis_Jonitis@swh-t.lv&gt;
 *   Christian Biesinger &lt;cbiesinger@web.de&gt;
 *   Mats Palmgren &lt;mats.palmgren@bredband.net&gt;
 *   Ningjie Chen &lt;chenn@email.uc.edu&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_LOGGING</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORCE_PR_LOG</name></cpp:macro></cpp:define> <comment type="block">/* Allow logging in the release build */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// MOZ_LOGGING</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prlog.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIMM32Handler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsWindow.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>nsIMM32Handler</name>*</type> <name>gIMM32Handler</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
<decl_stmt><decl><type><name>PRLogModuleInfo</name>*</type> <name>gIMM32Log</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IME_MOUSE_HANDLING</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>UINT</name></type> <name>sWM_MSIME_MOUSE</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">// mouse message for MSIME 98/2000</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>PRPackedBool</name></type> <name><name>nsIMM32Handler</name>::<name>sIsComposingOnPlugin</name></name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRPackedBool</name></type> <name><name>nsIMM32Handler</name>::<name>sIsStatusChanged</name></name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>UINT</name></type> <name><name>nsIMM32Handler</name>::<name>sCodePage</name></name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name><name>nsIMM32Handler</name>::<name>sIMEProperty</name></name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/* static */</comment> <function><type><name>void</name></type>
<name><name>nsIMM32Handler</name>::<name>EnsureHandlerInstance</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>gIMM32Handler</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>gIMM32Handler</name> = new <call><name>nsIMM32Handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>void</name></type>
<name><name>nsIMM32Handler</name>::<name>Initialize</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
  <if>if <condition>(<expr>!<name>gIMM32Log</name></expr>)</condition><then>
    <expr_stmt><expr><name>gIMM32Log</name> = <call><name>PR_NewLogModule</name><argument_list>(<argument><expr>"nsIMM32HandlerWidgets"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IME_MOUSE_HANDLING</name></cpp:ifdef>
  <if>if <condition>(<expr>!<name>sWM_MSIME_MOUSE</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>sWM_MSIME_MOUSE</name> = <call><name>::<name>RegisterWindowMessage</name></name><argument_list>(<argument><expr><name>RWM_MOUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>InitKeyboardLayout</name><argument_list>(<argument><expr><call><name>::<name>GetKeyboardLayout</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>void</name></type>
<name><name>nsIMM32Handler</name>::<name>Terminate</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>gIMM32Handler</name></expr>)</condition><then>
    <return>return;</return></then></if>
  <expr_stmt><expr>delete <name>gIMM32Handler</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>gIMM32Handler</name> = <name>nsnull</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>IsComposing</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>aWindow</name>-&gt;<name>PluginHasFocus</name></name><argument_list>()</argument_list></call> ? !!<name>sIsComposingOnPlugin</name> :
           <name>gIMM32Handler</name> &amp;&amp; <name><name>gIMM32Handler</name>-&gt;<name>mIsComposing</name></name></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>IsDoingKakuteiUndo</name></name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>aWnd</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// This message pattern is "Kakutei-Undo" on ATOK and WXG.</comment>
  <comment type="line">// In this case, the message queue has following messages:</comment>
  <comment type="line">// ---------------------------------------------------------------------------</comment>
  <comment type="line">// WM_KEYDOWN              * n (wParam = VK_BACK, lParam = 0x1)</comment>
  <comment type="line">// WM_KEYUP                * 1 (wParam = VK_BACK, lParam = 0xC0000001) # ATOK</comment>
  <comment type="line">// WM_IME_STARTCOMPOSITION * 1 (wParam = 0x0, lParam = 0x0)</comment>
  <comment type="line">// WM_IME_COMPOSITION      * 1 (wParam = 0x0, lParam = 0x1BF)</comment>
  <comment type="line">// WM_CHAR                 * n (wParam = VK_BACK, lParam = 0x1)</comment>
  <comment type="line">// WM_KEYUP                * 1 (wParam = VK_BACK, lParam = 0xC00E0001)</comment>
  <comment type="line">// ---------------------------------------------------------------------------</comment>
  <comment type="line">// This message pattern does not match to the above case;</comment>
  <comment type="line">// i.e.,WM_KEYDOWN -&gt; WM_CHAR -&gt; WM_KEYDOWN -&gt; WM_CHAR.</comment>
  <comment type="line">// For more information of this problem:</comment>
  <comment type="line">// https://bugzilla.mozilla.gr.jp/show_bug.cgi?id=2885 (written in Japanese)</comment>
  <comment type="line">// https://bugzilla.mozilla.org/show_bug.cgi?id=194559 (written in English)</comment>
  <decl_stmt><decl><type><name>MSG</name></type> <name>imeStartCompositionMsg</name></decl>, <decl><type ref="prev"/><name>imeCompositionMsg</name></decl>, <decl><type ref="prev"/><name>charMsg</name></decl>;</decl_stmt>
  <return>return <expr><call><name>::<name>PeekMessageW</name></name><argument_list>(<argument><expr>&amp;<name>imeStartCompositionMsg</name></expr></argument>, <argument><expr><name>aWnd</name></expr></argument>,
                        <argument><expr><name>WM_IME_STARTCOMPOSITION</name></expr></argument>, <argument><expr><name>WM_IME_STARTCOMPOSITION</name></expr></argument>,
                        <argument><expr><name>PM_NOREMOVE</name> | <name>PM_NOYIELD</name></expr></argument>)</argument_list></call> &amp;&amp;
         <call><name>::<name>PeekMessageW</name></name><argument_list>(<argument><expr>&amp;<name>imeCompositionMsg</name></expr></argument>, <argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>WM_IME_COMPOSITION</name></expr></argument>,
                        <argument><expr><name>WM_IME_COMPOSITION</name></expr></argument>, <argument><expr><name>PM_NOREMOVE</name> | <name>PM_NOYIELD</name></expr></argument>)</argument_list></call> &amp;&amp;
         <call><name>::<name>PeekMessageW</name></name><argument_list>(<argument><expr>&amp;<name>charMsg</name></expr></argument>, <argument><expr><name>aWnd</name></expr></argument>, <argument><expr><name>WM_CHAR</name></expr></argument>, <argument><expr><name>WM_CHAR</name></expr></argument>,
                        <argument><expr><name>PM_NOREMOVE</name> | <name>PM_NOYIELD</name></expr></argument>)</argument_list></call> &amp;&amp;
         <name><name>imeStartCompositionMsg</name>.<name>wParam</name></name> == 0x0 &amp;&amp;
         <name><name>imeStartCompositionMsg</name>.<name>lParam</name></name> == 0x0 &amp;&amp;
         <name><name>imeCompositionMsg</name>.<name>wParam</name></name> == 0x0 &amp;&amp;
         <name><name>imeCompositionMsg</name>.<name>lParam</name></name> == 0x1BF &amp;&amp;
         <name><name>charMsg</name>.<name>wParam</name></name> == <name>VK_BACK</name> &amp;&amp; <name><name>charMsg</name>.<name>lParam</name></name> == 0x1 &amp;&amp;
         <name><name>imeStartCompositionMsg</name>.<name>time</name></name> &lt;= <name><name>imeCompositionMsg</name>.<name>time</name></name> &amp;&amp;
         <name><name>imeCompositionMsg</name>.<name>time</name></name> &lt;= <name><name>charMsg</name>.<name>time</name></name></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>ShouldDrawCompositionStringOurselves</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
  <comment type="line">// We are not sure we should use native IME behavior...</comment>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="line">// If current IME has special UI or its composition window should not</comment>
  <comment type="line">// positioned to caret position, we should now draw composition string</comment>
  <comment type="line">// ourselves.</comment>
  <return>return <expr>!(<name>sIMEProperty</name> &amp; <name>IME_PROP_SPECIAL_UI</name>) &amp;&amp;
          (<name>sIMEProperty</name> &amp; <name>IME_PROP_AT_CARET</name>)</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>void</name></type>
<name><name>nsIMM32Handler</name>::<name>InitKeyboardLayout</name></name><parameter_list>(<param><decl><type><name>HKL</name></type> <name>aKeyboardLayout</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>WORD</name></type> <name>langID</name> <init>= <expr><call><name>LOWORD</name><argument_list>(<argument><expr><name>aKeyboardLayout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>GetLocaleInfoW</name></name><argument_list>(<argument><expr><call><name>MAKELCID</name><argument_list>(<argument><expr><name>langID</name></expr></argument>, <argument><expr><name>SORT_DEFAULT</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>LOCALE_IDEFAULTANSICODEPAGE</name> | <name>LOCALE_RETURN_NUMBER</name></expr></argument>,
                   <argument><expr>(<name>PWSTR</name>)&amp;<name>sCodePage</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sCodePage</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sIMEProperty</name> = <call><name>::<name>ImmGetProperty</name></name><argument_list>(<argument><expr><name>aKeyboardLayout</name></expr></argument>, <argument><expr><name>IGP_PROPERTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: InitKeyboardLayout, aKeyboardLayout=%08x, sCodePage=%lu, sIMEProperty=%08x\n",
     <name>aKeyboardLayout</name>, <name>sCodePage</name>, <name>sIMEProperty</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>UINT</name></type>
<name><name>nsIMM32Handler</name>::<name>GetKeyboardCodePage</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE</name></cpp:ifdef>
  <return>return <expr><call><name>::<name>GetACP</name></name><argument_list>()</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name>sCodePage</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="line">// used for checking the lParam of WM_IME_COMPOSITION</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_COMPOSING_LPARAM</name><parameter_list>(<param><type><name>lParam</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>((lParam) &amp; (GCS_COMPSTR | GCS_COMPATTR | GCS_COMPCLAUSE | GCS_CURSORPOS))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_COMMITTING_LPARAM</name><parameter_list>(<param><type><name>lParam</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((lParam) &amp; GCS_RESULTSTR)</cpp:value></cpp:define>
<comment type="line">// Some IMEs (e.g., the standard IME for Korean) don't have caret position,</comment>
<comment type="line">// then, we should not set caret position to text event.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_IME_CARET</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<constructor><name><name>nsIMM32Handler</name>::<name>nsIMM32Handler</name></name><parameter_list>()</parameter_list> <member_list>:
  <call><name>mCursorPosition</name><argument_list>(<argument><expr><name>NO_IME_CARET</name></expr></argument>)</argument_list></call>, <call><name>mIsComposing</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
  <call><name>mNativeCaretIsCreated</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>, <argument><expr>("IMM32: nsIMM32Handler is created\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>nsIMM32Handler</name>::~<name>nsIMM32Handler</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mIsComposing</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: ~nsIMM32Handler, ERROR, the instance is still composing\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>, <argument><expr>("IMM32: nsIMM32Handler is destroyed\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>nsresult</name></type>
<name><name>nsIMM32Handler</name>::<name>EnsureClauseArray</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aCount</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_MIN</name><argument_list>(<argument><expr><name>aCount</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name><name>mClauseArray</name>.<name>SetCapacity</name></name><argument_list>(<argument><expr><name>aCount</name> + 32</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: EnsureClauseArray, aCount=%ld, FAILED to allocate\n",
       <name>aCount</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsIMM32Handler</name>::<name>EnsureAttributeArray</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aCount</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_MIN</name><argument_list>(<argument><expr><name>aCount</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name><name>mAttributeArray</name>.<name>SetCapacity</name></name><argument_list>(<argument><expr><name>aCount</name> + 64</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: EnsureAttributeArray, aCount=%ld, FAILED to allocate\n",
       <name>aCount</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>ProcessMessage</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>msg</name></decl></param>,
                               <param><decl><type><name>WPARAM</name> &amp;</type><name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name> &amp;</type><name>lParam</name></decl></param>,
                               <param><decl><type><name>LRESULT</name> *</type><name>aRetValue</name></decl></param>, <param><decl><type><name>PRBool</name> &amp;</type><name>aEatMessage</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// XXX We should store the composing window handle.  If IME messages are</comment>
  <comment type="line">// sent to different window, we should commit the old transaction.  And also</comment>
  <comment type="line">// if the new window handle is not focused, probably, we should not start</comment>
  <comment type="line">// the composition, however, such case should not be, it's just bad scenario.</comment>

  <if>if <condition>(<expr><call><name><name>aWindow</name>-&gt;<name>PluginHasFocus</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><call><name>ProcessMessageForPlugin</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>aRetValue</name></expr></argument>,
                                   <argument><expr><name>aEatMessage</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>aRetValue</name> = 0</expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>msg</name></expr>)</condition> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IME_MOUSE_HANDLING</name></cpp:ifdef>
    <case>case <expr><name>WM_LBUTTONDOWN</name></expr>:
    </case><case>case <expr><name>WM_MBUTTONDOWN</name></expr>:
    </case><case>case <expr><name>WM_RBUTTONDOWN</name></expr>: <block>{
      <comment type="line">// We don't need to create the instance of the handler here.</comment>
      <if>if <condition>(<expr>!<name>gIMM32Handler</name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
      <if>if <condition>(<expr>!<call><name><name>gIMM32Handler</name>-&gt;<name>OnMouseEvent</name></name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>,
                            <argument><expr><name>msg</name> == <name>WM_LBUTTONDOWN</name> ? <name>IMEMOUSE_LDOWN</name> :
                            <name>msg</name> == <name>WM_MBUTTONDOWN</name> ? <name>IMEMOUSE_MDOWN</name> :
                                                    <name>IMEMOUSE_RDOWN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>aEatMessage</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// ENABLE_IME_MOUSE_HANDLING</comment>
    </case><case>case <expr><name>WM_INPUTLANGCHANGE</name></expr>:
      <comment type="line">// We don't need to create the instance of the handler here.</comment>
      <if>if <condition>(<expr><name>gIMM32Handler</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>aEatMessage</name> = <call><name><name>gIMM32Handler</name>-&gt;<name>OnInputLangChange</name></name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>InitKeyboardLayout</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>HKL</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// We can release the instance here, because the instance may be nerver</comment>
      <comment type="line">// used. E.g., the new keyboard layout may not use IME, or it may use TSF.</comment>
      <expr_stmt><expr>delete <name>gIMM32Handler</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>gIMM32Handler</name> = <name>nsnull</name></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    </case><case>case <expr><name>WM_IME_STARTCOMPOSITION</name></expr>:
      <expr_stmt><expr><call><name>EnsureHandlerInstance</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aEatMessage</name> = <call><name><name>gIMM32Handler</name>-&gt;<name>OnIMEStartComposition</name></name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    </case><case>case <expr><name>WM_IME_COMPOSITION</name></expr>:
      <expr_stmt><expr><call><name>EnsureHandlerInstance</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aEatMessage</name> = <call><name><name>gIMM32Handler</name>-&gt;<name>OnIMEComposition</name></name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    </case><case>case <expr><name>WM_IME_ENDCOMPOSITION</name></expr>:
      <expr_stmt><expr><call><name>EnsureHandlerInstance</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aEatMessage</name> = <call><name><name>gIMM32Handler</name>-&gt;<name>OnIMEEndComposition</name></name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    </case><case>case <expr><name>WM_IME_CHAR</name></expr>:
      <expr_stmt><expr><name>aEatMessage</name> = <call><name>OnIMEChar</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    </case><case>case <expr><name>WM_IME_NOTIFY</name></expr>:
      <expr_stmt><expr><name>aEatMessage</name> = <call><name>OnIMENotify</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    </case><case>case <expr><name>WM_IME_REQUEST</name></expr>:
      <expr_stmt><expr><call><name>EnsureHandlerInstance</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aEatMessage</name> =
        <call><name><name>gIMM32Handler</name>-&gt;<name>OnIMERequest</name></name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>aRetValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    </case><case>case <expr><name>WM_IME_SELECT</name></expr>:
      <expr_stmt><expr><name>aEatMessage</name> = <call><name>OnIMESelect</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    </case><case>case <expr><name>WM_IME_SETCONTEXT</name></expr>:
      <expr_stmt><expr><name>aEatMessage</name> = <call><name>OnIMESetContext</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    </case><default>default:
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </default>}</block></switch><empty_stmt>;</empty_stmt>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>ProcessMessageForPlugin</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>msg</name></decl></param>,
                                        <param><decl><type><name>WPARAM</name> &amp;</type><name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name> &amp;</type><name>lParam</name></decl></param>,
                                        <param><decl><type><name>LRESULT</name> *</type><name>aRetValue</name></decl></param>,
                                        <param><decl><type><name>PRBool</name> &amp;</type><name>aEatMessage</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aRetValue</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>aEatMessage</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>msg</name></expr>)</condition> <block>{
    <case>case <expr><name>WM_IME_COMPOSITION</name></expr>:
      <comment type="line">// We should end composition if there is a committed string.</comment>
      <if>if <condition>(<expr><call><name>IS_COMMITTING_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>sIsComposingOnPlugin</name> = <name>PR_FALSE</name></expr>;</expr_stmt></then></if>
      <comment type="line">// Continue composition if there is still a string being composed.</comment>
      <if>if <condition>(<expr><call><name>IS_COMPOSING_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>sIsComposingOnPlugin</name> = 1</expr>;</expr_stmt></then></if>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    </case><case>case <expr><name>WM_IME_STARTCOMPOSITION</name></expr>:
      <expr_stmt><expr><name>sIsComposingOnPlugin</name> = 1</expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    </case><case>case <expr><name>WM_IME_ENDCOMPOSITION</name></expr>:
      <expr_stmt><expr><name>sIsComposingOnPlugin</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </case>}</block></switch>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnInputLangChange</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                                  <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>,
                                  <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: OnInputLangChange, hWnd=%08x, wParam=%08x, lParam=%08x\n",
     <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>wParam</name>, <name>lParam</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>ResetInputState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mIsComposing</name></expr></argument>, <argument><expr>"ResetInputState failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mIsComposing</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>HandleEndComposition</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnIMEStartComposition</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: OnIMEStartComposition, hWnd=%08x, mIsComposing=%s\n",
     <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>mIsComposing</name> ? "TRUE" : "FALSE")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// ATOK send the messages following order at starting composition.</comment>
  <comment type="line">// 1. WM_IME_COMPOSITION</comment>
  <comment type="line">// 2. WM_IME_STARTCOMPOSITION</comment>
  <comment type="line">// We call this function at both step #1 and #2.</comment>
  <comment type="line">// However, the composition start event should occur only once.</comment>
  <if>if <condition>(<expr><name>mIsComposing</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIMEContext</name></type> <name>IMEContext</name><argument_list>(<argument><expr><call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>HandleStartComposition</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>IMEContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnIMEComposition</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                                 <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>,
                                 <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: OnIMEComposition, hWnd=%08x, lParam=%08x, mIsComposing=%s\n",
     <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>lParam</name>, <name>mIsComposing</name> ? "TRUE" : "FALSE")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: OnIMEComposition, GCS_RESULTSTR=%s, GCS_COMPSTR=%s, GCS_COMPATTR=%s, GCS_COMPCLAUSE=%s, GCS_CURSORPOS=%s\n",
     <name>lParam</name> &amp; <name>GCS_RESULTSTR</name>  ? "YES" : "no",
     <name>lParam</name> &amp; <name>GCS_COMPSTR</name>    ? "YES" : "no",
     <name>lParam</name> &amp; <name>GCS_COMPATTR</name>   ? "YES" : "no",
     <name>lParam</name> &amp; <name>GCS_COMPCLAUSE</name> ? "YES" : "no",
     <name>lParam</name> &amp; <name>GCS_CURSORPOS</name>  ? "YES" : "no")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name><name>aWindow</name>-&gt;<name>PluginHasFocus</name></name><argument_list>()</argument_list></call></expr></argument>,
    <argument><expr>"OnIMEComposition should not be called when a plug-in has focus"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIMEContext</name></type> <name>IMEContext</name><argument_list>(<argument><expr><call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <return>return <expr><call><name>HandleComposition</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>IMEContext</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnIMEEndComposition</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: OnIMEEndComposition, hWnd=%08x, mIsComposing=%s\n",
     <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>mIsComposing</name> ? "TRUE" : "FALSE")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>mIsComposing</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>

  <comment type="line">// IME on Korean NT somehow send WM_IME_ENDCOMPOSITION</comment>
  <comment type="line">// first when we hit space in composition mode</comment>
  <comment type="line">// we need to clear out the current composition string</comment>
  <comment type="line">// in that case.</comment>
  <expr_stmt><expr><call><name><name>mCompositionString</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIMEContext</name></type> <name>IMEContext</name><argument_list>(<argument><expr><call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>DispatchTextEvent</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>IMEContext</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>HandleEndComposition</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnIMEChar</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                          <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>,
                          <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: OnIMEChar, hWnd=%08x, char=%08x\n",
     <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>wParam</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// We don't need to fire any text events from here. This method will be</comment>
  <comment type="line">// called when the composition string of the current IME is not drawn by us</comment>
  <comment type="line">// and some characters are committed. In that case, the committed string was</comment>
  <comment type="line">// processed in nsWindow::OnIMEComposition already.</comment>

  <comment type="line">// We need to return TRUE here so that Windows don't send two WM_CHAR msgs</comment>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnIMECompositionFull</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: OnIMECompositionFull, hWnd=%08x\n",
     <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// not implement yet</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnIMENotify</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                            <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>,
                            <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
  <switch>switch <condition>(<expr><name>wParam</name></expr>)</condition> <block>{
    <case>case <expr><name>IMN_CHANGECANDIDATE</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_CHANGECANDIDATE, lParam=%08x\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>lParam</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_CLOSECANDIDATE</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_CLOSECANDIDATE, lParam=%08x\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>lParam</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_CLOSESTATUSWINDOW</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_CLOSESTATUSWINDOW\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_GUIDELINE</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_GUIDELINE\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_OPENCANDIDATE</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_OPENCANDIDATE, lParam=%08x\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>lParam</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_OPENSTATUSWINDOW</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_OPENSTATUSWINDOW\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_SETCANDIDATEPOS</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_SETCANDIDATEPOS, lParam=%08x\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>lParam</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_SETCOMPOSITIONFONT</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_SETCOMPOSITIONFONT\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_SETCOMPOSITIONWINDOW</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_SETCOMPOSITIONWINDOW\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_SETCONVERSIONMODE</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_SETCONVERSIONMODE\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_SETOPENSTATUS</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_SETOPENSTATUS\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_SETSENTENCEMODE</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_SETSENTENCEMODE\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_SETSTATUSWINDOWPOS</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_SETSTATUSWINDOWPOS\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>IMN_PRIVATE</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMENotify, hWnd=%08x, IMN_PRIVATE\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
  </case>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// PR_LOGGING</comment>

  <if>if <condition>(<expr><call><name>::<name>GetKeyState</name></name><argument_list>(<argument><expr><name>NS_VK_ALT</name></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// XXXmnakano Following code was added by bug 28852 (Key combo to trun ON/OFF</comment>
  <comment type="line">// Japanese IME incorrectly activates "File" menu).  If one or more keypress</comment>
  <comment type="line">// events come between Alt keydown event and Alt keyup event, XUL menubar</comment>
  <comment type="line">// isn't activated by the Alt keyup event.  Therefore, this code sends dummy</comment>
  <comment type="line">// keypress event to Gecko.  But this is ugly, and this fires incorrect DOM</comment>
  <comment type="line">// keypress event.  So, we should find another way for the bug.</comment>

  <comment type="line">// add hacky code here</comment>
  <function_decl><type><name>nsModifierKeyState</name></type> <name>modKeyState</name><parameter_list>(<param><decl><type><name>PR_FALSE</name></type></decl></param>, <param><decl><type><name>PR_FALSE</name></type></decl></param>, <param><decl><type><name>PR_TRUE</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>DispatchKeyEvent</name></name><argument_list>(<argument><expr><name>NS_KEY_PRESS</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>192</expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>modKeyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sIsStatusChanged</name> = <name>sIsStatusChanged</name> || (<name>wParam</name> == <name>IMN_SETOPENSTATUS</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: OnIMENotify, sIsStatusChanged=%s\n",
     <name>sIsStatusChanged</name> ? "TRUE" : "FALSE")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// not implement yet</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnIMERequest</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                             <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>,
                             <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>,
                             <param><decl><type><name>LRESULT</name> *</type><name>oResult</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>wParam</name></expr>)</condition> <block>{
    <case>case <expr><name>IMR_RECONVERTSTRING</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMERequest, hWnd=%08x, IMR_RECONVERTSTRING\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>HandleReconvert</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>oResult</name></expr></argument>)</argument_list></call></expr>;</return>
    </case><case>case <expr><name>IMR_QUERYCHARPOSITION</name></expr>:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMERequest, hWnd=%08x, IMR_QUERYCHARPOSITION\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>HandleQueryCharPosition</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>, <argument><expr><name>oResult</name></expr></argument>)</argument_list></call></expr>;</return>
    </case><default>default:
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: OnIMERequest, hWnd=%08x, wParam=%08x\n",
         <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>wParam</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </default>}</block></switch>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnIMESelect</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                            <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>,
                            <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: OnIMESelect, hWnd=%08x, wParam=%08x, lParam=%08x\n",
     <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>wParam</name>, <name>lParam</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// not implement yet</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment> <function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnIMESetContext</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                                <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>,
                                <param><decl><type><name>LPARAM</name> &amp;</type><name>lParam</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: OnIMESetContext, hWnd=%08x, %s, lParam=%08x\n",
     <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>, <name>wParam</name> ? "Active" : "Deactive", <name>lParam</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>wParam</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>ResetInputState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>wParam</name> &amp;&amp; (<name>lParam</name> &amp; <name>ISC_SHOWUICOMPOSITIONWINDOW</name>) &amp;&amp;
      <call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: OnIMESetContext, ISC_SHOWUICOMPOSITIONWINDOW is removed\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lParam</name> &amp;= ~<name>ISC_SHOWUICOMPOSITIONWINDOW</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// We still return FALSE here even if we should draw a composition string</comment>
  <comment type="line">// ourselves. Because we need to pass the aISC w/ ISC_SHOWUICOMPOSITIONWINDOW</comment>
  <comment type="line">// directly to the default window proc so it will draw the candidate window</comment>
  <comment type="line">// for us...</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIMM32Handler</name>::<name>HandleStartComposition</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>nsIMEContext</name> &amp;</type><name>aIMEContext</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mIsComposing</name></expr></argument>,
    <argument><expr>"HandleStartComposition is called but mIsComposing is TRUE"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name><name>aWindow</name>-&gt;<name>PluginHasFocus</name></name><argument_list>()</argument_list></call></expr></argument>,
    <argument><expr>"HandleStartComposition should not be called when a plug-in has focus"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <function_decl><type><name>nsCompositionEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_COMPOSITION_START</name></type></decl></param>, <param><decl><type><name>aWindow</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>point</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>InitEvent</name></name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>DispatchWindowEvent</name></name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">//</comment>
  <comment type="line">// Post process event</comment>
  <comment type="line">//</comment>

  <expr_stmt><expr><call><name>SetIMERelatedWindowsPos</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>aIMEContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mIsComposing</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: HandleStartComposition, START composition\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>event</name>.<name>theReply</name>.<name>mCursorPosition</name>.<name>width</name></name> &lt;= 0 &amp;&amp;
      <name><name>event</name>.<name>theReply</name>.<name>mCursorPosition</name>.<name>height</name></name> &lt;= 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleStartComposition, mCursorPosition is empty\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// for some reason we don't know yet, theReply may contain invalid result</comment>
    <comment type="line">// need more debugging in nsCaret to find out the reason</comment>
    <comment type="line">// the best we can do now is to ignore the invalid result</comment>
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>cursorPosition</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ResolveIMECaretPos</name><argument_list>(<argument><expr><name><name>event</name>.<name>theReply</name>.<name>mReferenceWidget</name></name></expr></argument>,
                     <argument><expr><name><name>event</name>.<name>theReply</name>.<name>mCursorPosition</name></name></expr></argument>, <argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>cursorPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IME_MOUSE_HANDLING</name></cpp:ifdef>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mCompCharPos</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RECT</name></expr></argument>)</argument_list></sizeof> * <name>IME_MAX_CHAR_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr>0</expr>]</index></name>.<name>left</name> = <name><name>cursorPosition</name>.<name>x</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr>0</expr>]</index></name>.<name>top</name> = <name><name>cursorPosition</name>.<name>y</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr>0</expr>]</index></name>.<name>bottom</name> = <call><name><name>cursorPosition</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// ENABLE_IME_MOUSE_HANDLING</comment>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>HandleComposition</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>nsIMEContext</name> &amp;</type><name>aIMEContext</name></decl></param>,
                                  <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name><name>aWindow</name>-&gt;<name>PluginHasFocus</name></name><argument_list>()</argument_list></call></expr></argument>,
    <argument><expr>"HandleComposition should not be called when a plug-in has focus"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// for bug #60050</comment>
  <comment type="line">// MS-IME 95/97/98/2000 may send WM_IME_COMPOSITION with non-conversion</comment>
  <comment type="line">// mode before it send WM_IME_STARTCOMPOSITION.</comment>

  <if>if <condition>(<expr>!<call><name>IS_COMMITTING_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>IS_COMPOSING_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleComposition, Handle 0 length TextEvent\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// XXX This block should be wrong. If composition string is not change,</comment>
    <comment type="line">// we should do nothing.</comment>

    <if>if <condition>(<expr>!<name>mIsComposing</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>HandleStartComposition</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>aIMEContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>mCompositionString</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DispatchTextEvent</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>aIMEContext</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then></if>


  <decl_stmt><decl><type><name>PRBool</name></type> <name>startCompositionMessageHasBeenSent</name> <init>= <expr><name>mIsComposing</name></expr></init></decl>;</decl_stmt>

  <comment type="line">//</comment>
  <comment type="line">// This catches a fixed result</comment>
  <comment type="line">//</comment>
  <if>if <condition>(<expr><call><name>IS_COMMITTING_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<name>mIsComposing</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>HandleStartComposition</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>aIMEContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>GetCompositionString</name><argument_list>(<argument><expr><name>aIMEContext</name></expr></argument>, <argument><expr><name>GCS_RESULTSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleComposition, GCS_RESULTSTR\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DispatchTextEvent</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>aIMEContext</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HandleEndComposition</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>IS_COMPOSING_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>
  }</block></then></if>


  <comment type="line">//</comment>
  <comment type="line">// This provides us with a composition string</comment>
  <comment type="line">//</comment>
  <if>if <condition>(<expr>!<name>mIsComposing</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>HandleStartComposition</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>aIMEContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">//--------------------------------------------------------</comment>
  <comment type="line">// 1. Get GCS_COMPSTR</comment>
  <comment type="line">//--------------------------------------------------------</comment>
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: HandleComposition, GCS_COMPSTR\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>GetCompositionString</name><argument_list>(<argument><expr><name>aIMEContext</name></expr></argument>, <argument><expr><name>GCS_COMPSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// See https://bugzilla.mozilla.org/show_bug.cgi?id=296339</comment>
  <if>if <condition>(<expr><call><name><name>mCompositionString</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; !<name>startCompositionMessageHasBeenSent</name></expr>)</condition><then> <block>{
    <comment type="line">// In this case, maybe, the sender is MSPinYin. That sends *only*</comment>
    <comment type="line">// WM_IME_COMPOSITION with GCS_COMP* and GCS_RESULT* when</comment>
    <comment type="line">// user inputted the Chinese full stop. So, that doesn't send</comment>
    <comment type="line">// WM_IME_STARTCOMPOSITION and WM_IME_ENDCOMPOSITION.</comment>
    <comment type="line">// If WM_IME_STARTCOMPOSITION was not sent and the composition</comment>
    <comment type="line">// string is null (it indicates the composition transaction ended),</comment>
    <comment type="line">// WM_IME_ENDCOMPOSITION may not be sent. If so, we cannot run</comment>
    <comment type="line">// HandleEndComposition() in other place.</comment>
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleComposition, Aborting GCS_COMPSTR\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HandleEndComposition</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>IS_COMMITTING_LPARAM</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <comment type="line">//--------------------------------------------------------</comment>
  <comment type="line">// 2. Get GCS_COMPCLAUSE</comment>
  <comment type="line">//--------------------------------------------------------</comment>
  <decl_stmt><decl><type><name>long</name></type> <name>clauseArrayLength</name> <init>=
    <expr><call><name>::<name>ImmGetCompositionStringW</name></name><argument_list>(<argument><expr><call><name><name>aIMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>GCS_COMPCLAUSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>clauseArrayLength</name> /= <sizeof>sizeof<argument_list>(<argument><expr><name>PRUint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>clauseArrayLength</name> &gt; 0</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>EnsureClauseArray</name><argument_list>(<argument><expr><name>clauseArrayLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    <comment type="line">// Intelligent ABC IME (Simplified Chinese IME, the code page is 936)</comment>
    <comment type="line">// will crash in ImmGetCompositionStringW for GCS_COMPCLAUSE (bug 424663).</comment>
    <comment type="line">// See comment 35 of the bug for the detail. Therefore, we should use A</comment>
    <comment type="line">// API for it, however, we should not kill Unicode support on all IMEs.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>useA_API</name> <init>= <expr>!(<name>sIMEProperty</name> &amp; <name>IME_PROP_UNICODE</name>)</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleComposition, GCS_COMPCLAUSE, useA_API=%s\n",
       <name>useA_API</name> ? "TRUE" : "FALSE")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>long</name></type> <name>clauseArrayLength2</name> <init>= 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
      <expr><name>useA_API</name> ?
        <call><name>::<name>ImmGetCompositionStringA</name></name><argument_list>(<argument><expr><call><name><name>aIMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>GCS_COMPCLAUSE</name></expr></argument>,
                                   <argument><expr><call><name><name>mClauseArray</name>.<name>Elements</name></name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><call><name><name>mClauseArray</name>.<name>Capacity</name></name><argument_list>()</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>PRUint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> :
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <call><name>::<name>ImmGetCompositionStringW</name></name><argument_list>(<argument><expr><call><name><name>aIMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>GCS_COMPCLAUSE</name></expr></argument>,
                                   <argument><expr><call><name><name>mClauseArray</name>.<name>Elements</name></name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><call><name><name>mClauseArray</name>.<name>Capacity</name></name><argument_list>()</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>PRUint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>clauseArrayLength2</name> /= <sizeof>sizeof<argument_list>(<argument><expr><name>PRUint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>clauseArrayLength</name> != <name>clauseArrayLength2</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: HandleComposition, GCS_COMPCLAUSE, clauseArrayLength=%ld but clauseArrayLength2=%ld\n",
         <name>clauseArrayLength</name>, <name>clauseArrayLength2</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>clauseArrayLength</name> &gt; <name>clauseArrayLength2</name></expr>)</condition><then>
        <expr_stmt><expr><name>clauseArrayLength</name> = <name>clauseArrayLength2</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
    <if>if <condition>(<expr><name>useA_API</name></expr>)</condition><then> <block>{
      <comment type="line">// Convert each values of sIMECompClauseArray. The values mean offset of</comment>
      <comment type="line">// the clauses in ANSI string. But we need the values in Unicode string.</comment>
      <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>compANSIStr</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>ConvertToANSIString</name><argument_list>(<argument><expr><name>mCompositionString</name></expr></argument>, <argument><expr><call><name>GetKeyboardCodePage</name><argument_list>()</argument_list></call></expr></argument>,
                              <argument><expr><name>compANSIStr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>maxlen</name> <init>= <expr><call><name><name>compANSIStr</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>mClauseArray</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt> <comment type="line">// first value must be 0</comment>
        <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>clauseArrayLength</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
          <decl_stmt><decl><type><name>PRUint32</name></type> <name>len</name> <init>= <expr><call><name>PR_MIN</name><argument_list>(<argument><expr><name><name>mClauseArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>mClauseArray</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>::<name>MultiByteToWideChar</name></name><argument_list>(<argument><expr><call><name>GetKeyboardCodePage</name><argument_list>()</argument_list></call></expr></argument>, 
                                                  <argument><expr><name>MB_PRECOMPOSED</name></expr></argument>,
                                                  <argument><expr>(<name>LPCSTR</name>)<call><name><name>compANSIStr</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                  <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
  <comment type="line">// compClauseArrayLength may be negative. I.e., ImmGetCompositionStringW</comment>
  <comment type="line">// may return an error code.</comment>
  <expr_stmt><expr><call><name><name>mClauseArray</name>.<name>SetLength</name></name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>clauseArrayLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: HandleComposition, GCS_COMPCLAUSE, mClauseLength=%ld\n",
     <call><name><name>mClauseArray</name>.<name>Length</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">//--------------------------------------------------------</comment>
  <comment type="line">// 3. Get GCS_COMPATTR</comment>
  <comment type="line">//--------------------------------------------------------</comment>
  <comment type="line">// This provides us with the attribute string necessary </comment>
  <comment type="line">// for doing hiliting</comment>
  <decl_stmt><decl><type><name>long</name></type> <name>attrArrayLength</name> <init>=
    <expr><call><name>::<name>ImmGetCompositionStringW</name></name><argument_list>(<argument><expr><call><name><name>aIMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>GCS_COMPATTR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>attrArrayLength</name> /= <sizeof>sizeof<argument_list>(<argument><expr><name>PRUint8</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>attrArrayLength</name> &gt; 0</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>EnsureAttributeArray</name><argument_list>(<argument><expr><name>attrArrayLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attrArrayLength</name> =
      <call><name>::<name>ImmGetCompositionStringW</name></name><argument_list>(<argument><expr><call><name><name>aIMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>GCS_COMPATTR</name></expr></argument>,
                                 <argument><expr><call><name><name>mAttributeArray</name>.<name>Elements</name></name><argument_list>()</argument_list></call></expr></argument>,
                                 <argument><expr><call><name><name>mAttributeArray</name>.<name>Capacity</name></name><argument_list>()</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>PRUint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// attrStrLen may be negative. I.e., ImmGetCompositionStringW may return an</comment>
  <comment type="line">// error code.</comment>
  <expr_stmt><expr><call><name><name>mAttributeArray</name>.<name>SetLength</name></name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>attrArrayLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: HandleComposition, GCS_COMPATTR, mAttributeLength=%ld\n",
     <call><name><name>mAttributeArray</name>.<name>Length</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">//--------------------------------------------------------</comment>
  <comment type="line">// 4. Get GCS_CURSOPOS</comment>
  <comment type="line">//--------------------------------------------------------</comment>
  <comment type="line">// Some IMEs (e.g., the standard IME for Korean) don't have caret position.</comment>
  <if>if <condition>(<expr><name>lParam</name> &amp; <name>GCS_CURSORPOS</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCursorPosition</name> =
      <call><name>::<name>ImmGetCompositionStringW</name></name><argument_list>(<argument><expr><call><name><name>aIMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>GCS_CURSORPOS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mCursorPosition</name> &lt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mCursorPosition</name> = <name>NO_IME_CARET</name></expr>;</expr_stmt> <comment type="line">// The result is error</comment>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>mCursorPosition</name> = <name>NO_IME_CARET</name></expr>;</expr_stmt>
  }</block></else></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mCursorPosition</name> &lt;= (<name>long</name>)<call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"illegal pos"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: HandleComposition, GCS_CURSORPOS, mCursorPosition=%d\n",
     <name>mCursorPosition</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">//--------------------------------------------------------</comment>
  <comment type="line">// 5. Send the text event</comment>
  <comment type="line">//--------------------------------------------------------</comment>
  <expr_stmt><expr><call><name>DispatchTextEvent</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>aIMEContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIMM32Handler</name>::<name>HandleEndComposition</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>mIsComposing</name></expr></argument>,
    <argument><expr>"HandleEndComposition is called but mIsComposing is FALSE"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<call><name><name>aWindow</name>-&gt;<name>PluginHasFocus</name></name><argument_list>()</argument_list></call></expr></argument>,
    <argument><expr>"HandleComposition should not be called when a plug-in has focus"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: HandleEndComposition\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <function_decl><type><name>nsCompositionEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_COMPOSITION_END</name></type></decl></param>, <param><decl><type><name>aWindow</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>point</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>mNativeCaretIsCreated</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>DestroyCaret</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mNativeCaretIsCreated</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>InitEvent</name></name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>DispatchWindowEvent</name></name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mIsComposing</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>HandleReconvert</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                                <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>,
                                <param><decl><type><name>LRESULT</name> *</type><name>oResult</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>oResult</name> = 0</expr>;</expr_stmt>
  <decl_stmt><decl><type><name>RECONVERTSTRING</name>*</type> <name>pReconv</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>RECONVERTSTRING</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <function_decl><type><name>nsQueryContentEvent</name></type> <name>selection</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_QUERY_SELECTED_TEXT</name></type></decl></param>, <param><decl><type><name>aWindow</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>point</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>InitEvent</name></name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>DispatchWindowEvent</name></name><argument_list>(<argument><expr>&amp;<name>selection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name><name>selection</name>.<name>mSucceeded</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleReconvert, FAILED (NS_QUERY_SELECTED_TEXT)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>pReconv</name></expr>)</condition><then> <block>{
    <comment type="line">// Return need size to reconvert.</comment>
    <if>if <condition>(<expr><call><name><name>selection</name>.<name>mReply</name>.<name>mString</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: HandleReconvert, There are not selected text\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>len</name> <init>= <expr><call><name><name>selection</name>.<name>mReply</name>.<name>mString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>oResult</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>RECONVERTSTRING</name></expr></argument>)</argument_list></sizeof> + <name>len</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleReconvert, SUCCEEDED result=%ld\n",
       *<name>oResult</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Fill reconvert struct</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>len</name> <init>= <expr><call><name><name>selection</name>.<name>mReply</name>.<name>mString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>needSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>RECONVERTSTRING</name></expr></argument>)</argument_list></sizeof> + <name>len</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>pReconv</name>-&gt;<name>dwSize</name></name> &lt; <name>needSize</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleReconvert, FAILED pReconv-&gt;dwSize=%ld, needSize=%ld\n",
       <name><name>pReconv</name>-&gt;<name>dwSize</name></name>, <name>needSize</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>oResult</name> = <name>needSize</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>DWORD</name></type> <name>tmpSize</name> <init>= <expr><name><name>pReconv</name>-&gt;<name>dwSize</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>ZeroMemory</name></name><argument_list>(<argument><expr><name>pReconv</name></expr></argument>, <argument><expr><name>tmpSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReconv</name>-&gt;<name>dwSize</name></name>            = <name>tmpSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReconv</name>-&gt;<name>dwVersion</name></name>         = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReconv</name>-&gt;<name>dwStrLen</name></name>          = <name>len</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReconv</name>-&gt;<name>dwStrOffset</name></name>       = <sizeof>sizeof<argument_list>(<argument><expr><name>RECONVERTSTRING</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReconv</name>-&gt;<name>dwCompStrLen</name></name>      = <name>len</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReconv</name>-&gt;<name>dwCompStrOffset</name></name>   = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReconv</name>-&gt;<name>dwTargetStrLen</name></name>    = <name>len</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReconv</name>-&gt;<name>dwTargetStrOffset</name></name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><call><name>::<name>CopyMemory</name></name><argument_list>(<argument><expr><call>(<name>LPVOID</name>) <argument_list>(<argument><expr><name>lParam</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>RECONVERTSTRING</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name><name>selection</name>.<name>mReply</name>.<name>mString</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>len</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: HandleReconvert, SUCCEEDED str=\"%s\"\n",
     <call><name>NS_ConvertUTF16toUTF8</name><argument_list>(<argument><expr><name><name>selection</name>.<name>mReply</name>.<name>mString</name></name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>HandleQueryCharPosition</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                                        <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>,
                                        <param><decl><type><name>LRESULT</name> *</type><name>oResult</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>len</name> <init>= <expr><name>mIsComposing</name> ? <call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call> : 0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>oResult</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>IMECHARPOSITION</name>*</type> <name>pCharPosition</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>IMECHARPOSITION</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>pCharPosition</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleQueryCharPosition, FAILED (pCharPosition is null)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name><name>pCharPosition</name>-&gt;<name>dwSize</name></name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>IMECHARPOSITION</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleReconvert, FAILED, pCharPosition-&gt;dwSize=%ld, sizeof(IMECHARPOSITION)=%ld\n",
       <name><name>pCharPosition</name>-&gt;<name>dwSize</name></name>, <sizeof>sizeof<argument_list>(<argument><expr><name>IMECHARPOSITION</name></expr></argument>)</argument_list></sizeof>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><call><name>::<name>GetFocus</name></name><argument_list>()</argument_list></call> != <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleReconvert, FAILED, ::GetFocus()=%08x, OurWindowHandle=%08x\n",
       <call><name>::<name>GetFocus</name></name><argument_list>()</argument_list></call>, <call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name><name>pCharPosition</name>-&gt;<name>dwCharPos</name></name> &gt; <name>len</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: HandleQueryCharPosition, FAILED, pCharPosition-&gt;dwCharPos=%ld, len=%ld\n",
      <name><name>pCharPosition</name>-&gt;<name>dwCharPos</name></name>, <name>len</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>ret</name> <init>=
    <expr><call><name>GetCharacterRectOfSelectedTextAt</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name><name>pCharPosition</name>-&gt;<name>dwCharPos</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>screenRect</name></decl>;</decl_stmt>
  <comment type="line">// We always need top level window that is owner window of the popup window</comment>
  <comment type="line">// even if the content of the popup window has focus.</comment>
  <expr_stmt><expr><call><name>ResolveIMECaretPos</name><argument_list>(<argument><expr><call><name><name>aWindow</name>-&gt;<name>GetTopLevelWindow</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>r</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>screenRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCharPosition</name>-&gt;<name>pt</name>.<name>x</name></name> = <name><name>screenRect</name>.<name>x</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCharPosition</name>-&gt;<name>pt</name>.<name>y</name></name> = <name><name>screenRect</name>.<name>y</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pCharPosition</name>-&gt;<name>cLineHeight</name></name> = <name><name>r</name>.<name>height</name></name></expr>;</expr_stmt>

  <comment type="line">// XXX we should use NS_QUERY_EDITOR_RECT event here.</comment>
  <expr_stmt><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name><name>pCharPosition</name>-&gt;<name>rcDocument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>oResult</name> = <name>TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: HandleQueryCharPosition, SUCCEEDED\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRUint32</name></type>
<name>PlatformToNSAttr</name><parameter_list>(<param><decl><type><name>PRUint8</name></type> <name>aAttr</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>aAttr</name></expr>)</condition>
  <block>{
    <case>case <expr><name>ATTR_INPUT_ERROR</name></expr>:
    <comment type="line">// case ATTR_FIXEDCONVERTED:</comment>
    </case><case>case <expr><name>ATTR_INPUT</name></expr>:
      <return>return <expr><name>NS_TEXTRANGE_RAWINPUT</name></expr>;</return>
    </case><case>case <expr><name>ATTR_CONVERTED</name></expr>:
      <return>return <expr><name>NS_TEXTRANGE_CONVERTEDTEXT</name></expr>;</return>
    </case><case>case <expr><name>ATTR_TARGET_NOTCONVERTED</name></expr>:
      <return>return <expr><name>NS_TEXTRANGE_SELECTEDRAWTEXT</name></expr>;</return>
    </case><case>case <expr><name>ATTR_TARGET_CONVERTED</name></expr>:
      <return>return <expr><name>NS_TEXTRANGE_SELECTEDCONVERTEDTEXT</name></expr>;</return>
    </case><default>default:
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"unknown attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NS_TEXTRANGE_CARETPOSITION</name></expr>;</return>
  </default>}</block></switch>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name>*</type>
<name>GetRangeTypeName</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aRangeType</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>aRangeType</name></expr>)</condition> <block>{
    <case>case <expr><name>NS_TEXTRANGE_RAWINPUT</name></expr>:
      <return>return <expr>"NS_TEXTRANGE_RAWINPUT"</expr>;</return>
    </case><case>case <expr><name>NS_TEXTRANGE_CONVERTEDTEXT</name></expr>:
      <return>return <expr>"NS_TEXTRANGE_CONVERTEDTEXT"</expr>;</return>
    </case><case>case <expr><name>NS_TEXTRANGE_SELECTEDRAWTEXT</name></expr>:
      <return>return <expr>"NS_TEXTRANGE_SELECTEDRAWTEXT"</expr>;</return>
    </case><case>case <expr><name>NS_TEXTRANGE_SELECTEDCONVERTEDTEXT</name></expr>:
      <return>return <expr>"NS_TEXTRANGE_SELECTEDCONVERTEDTEXT"</expr>;</return>
    </case><case>case <expr><name>NS_TEXTRANGE_CARETPOSITION</name></expr>:
      <return>return <expr>"NS_TEXTRANGE_CARETPOSITION"</expr>;</return>
    </case><default>default:
      <return>return <expr>"UNKNOWN SELECTION TYPE!!"</expr>;</return>
  </default>}</block></switch>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name><name>nsIMM32Handler</name>::<name>DispatchTextEvent</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>nsIMEContext</name> &amp;</type><name>aIMEContext</name></decl></param>,
                                  <param><decl><type><name>PRBool</name></type> <name>aCheckAttr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mIsComposing</name></expr></argument>, <argument><expr>"conflict state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: DispatchTextEvent, aCheckAttr=%s\n",
     <name>aCheckAttr</name> ? "TRUE": "FALSE")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// If we don't need to draw composition string ourselves and this is not</comment>
  <comment type="line">// commit event (i.e., under composing), we don't need to fire text event</comment>
  <comment type="line">// during composing.</comment>
  <if>if <condition>(<expr><name>aCheckAttr</name> &amp;&amp; !<call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// But we need to adjust composition window pos and native caret pos, here.</comment>
    <expr_stmt><expr><call><name>SetIMERelatedWindowsPos</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>aIMEContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <function_decl><type><name>nsTextEvent</name></type> <name>event</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_TEXT_TEXT</name></type></decl></param>, <param><decl><type><name>aWindow</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>point</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>InitEvent</name></name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>nsTextRange</name></expr></argument>, <argument><expr>4</expr></argument>&gt;</argument_list></name></type> <name>textRanges</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>aCheckAttr</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>SetTextRangeList</name><argument_list>(<argument><expr><name>textRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name><name>event</name>.<name>rangeCount</name></name> = <call><name><name>textRanges</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>rangeArray</name></name> = <call><name><name>textRanges</name>.<name>Elements</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>event</name>.<name>theText</name></name> = <call><name><name>mCompositionString</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsModifierKeyState</name></type> <name>modKeyState</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isShift</name></name> = <name><name>modKeyState</name>.<name>mIsShiftDown</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isControl</name></name> = <name><name>modKeyState</name>.<name>mIsControlDown</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isMeta</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>event</name>.<name>isAlt</name></name> = <name><name>modKeyState</name>.<name>mIsAltDown</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>DispatchWindowEvent</name></name><argument_list>(<argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">//</comment>
  <comment type="line">// Post process event</comment>
  <comment type="line">//</comment>

  <expr_stmt><expr><call><name>SetIMERelatedWindowsPos</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>aIMEContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>event</name>.<name>theReply</name>.<name>mCursorPosition</name>.<name>width</name></name> &lt;= 0 &amp;&amp;
      <name><name>event</name>.<name>theReply</name>.<name>mCursorPosition</name>.<name>height</name></name> &lt;= 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: DispatchTextEvent, mCursorPosition is empty\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// for some reason we don't know yet, theReply may contain invalid result</comment>
    <comment type="line">// need more debugging in nsCaret to find out the reason</comment>
    <comment type="line">// the best we can do now is to ignore the invalid result</comment>
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>cursorPosition</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ResolveIMECaretPos</name><argument_list>(<argument><expr><name><name>event</name>.<name>theReply</name>.<name>mReferenceWidget</name></name></expr></argument>,
                     <argument><expr><name><name>event</name>.<name>theReply</name>.<name>mCursorPosition</name></name></expr></argument>, <argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>cursorPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IME_MOUSE_HANDLING</name></cpp:ifdef>
  <if>if <condition>(<expr><name>mCursorPosition</name> &lt;= 0 || <name>mCursorPosition</name> &gt;= <name>IME_MAX_CHAR_POS</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <comment type="line">// Record previous composing char position</comment>
  <comment type="line">// The cursor is always on the right char before it, but not necessarily on</comment>
  <comment type="line">// the left of next char, as what happens in wrapping.</comment>
  <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>mCursorPosition</name>-1</expr>]</index></name>.<name>right</name> = <name><name>cursorPosition</name>.<name>x</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>mCursorPosition</name>-1</expr>]</index></name>.<name>top</name> = <name><name>cursorPosition</name>.<name>y</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>mCursorPosition</name>-1</expr>]</index></name>.<name>bottom</name> = <call><name><name>cursorPosition</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>mCompCharPos</name><index>[<expr><name>mCursorPosition</name>-1</expr>]</index></name>.<name>top</name> != <name><name>cursorPosition</name>.<name>y</name></name></expr>)</condition><then> <block>{
    <comment type="line">// wrapping, invalidate left position</comment>
    <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>mCursorPosition</name>-1</expr>]</index></name>.<name>left</name> = -1</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>mCursorPosition</name></expr>]</index></name>.<name>left</name> = <name><name>cursorPosition</name>.<name>x</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>mCursorPosition</name></expr>]</index></name>.<name>top</name> = <name><name>cursorPosition</name>.<name>y</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>mCursorPosition</name></expr>]</index></name>.<name>bottom</name> = <call><name><name>cursorPosition</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// ENABLE_IME_MOUSE_HANDLING</comment>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIMM32Handler</name>::<name>SetTextRangeList</name></name><parameter_list>(<param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsTextRange</name></expr></argument>&gt;</argument_list></name> &amp;</type><name>aTextRangeList</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Sogou (Simplified Chinese IME) returns contradictory values: The cursor</comment>
  <comment type="line">// position is actual cursor position. However, other values (composition</comment>
  <comment type="line">// string and attributes) are empty. So, if you want to remove following</comment>
  <comment type="line">// assertion, be careful.</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr></argument>,
    <argument><expr>"SetTextRangeList is called when we don't need to fire text event"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsTextRange</name></type> <name>range</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>mClauseArray</name>.<name>Length</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then> <block>{
    <comment type="line">// Some IMEs don't return clause array information, then, we assume that</comment>
    <comment type="line">// all characters in the composition string are in one clause.</comment>
    <expr_stmt><expr><name><name>range</name>.<name>mStartOffset</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>range</name>.<name>mEndOffset</name></name> = <call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>range</name>.<name>mRangeType</name></name> = <name>NS_TEXTRANGE_RAWINPUT</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aTextRangeList</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: SetTextRangeList, mClauseLength=0\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// iterate over the attributes</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>lastOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>mClauseArray</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <decl_stmt><decl><type><name>PRUint32</name></type> <name>current</name> <init>= <expr><name><name>mClauseArray</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>current</name> &gt; <call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
          <argument><expr>("IMM32: SetTextRangeList, mClauseArray[%ld]=%lu. This is larger than mCompositionString.Length()=%lu\n",
           <name>i</name> + 1, <name>current</name>, <call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>current</name> = <call><name>PRInt32</name><argument_list>(<argument><expr><call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <expr_stmt><expr><name><name>range</name>.<name>mRangeType</name></name> = <call><name>PlatformToNSAttr</name><argument_list>(<argument><expr><name><name>mAttributeArray</name><index>[<expr><name>lastOffset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>range</name>.<name>mStartOffset</name></name> = <name>lastOffset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>range</name>.<name>mEndOffset</name></name> = <name>current</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aTextRangeList</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>lastOffset</name> = <name>current</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: SetTextRangeList, index=%ld, rangeType=%s, range=[%lu-%lu]\n",
         <name>i</name>, <call><name>GetRangeTypeName</name><argument_list>(<argument><expr><name><name>range</name>.<name>mRangeType</name></name></expr></argument>)</argument_list></call>, <name><name>range</name>.<name>mStartOffset</name></name>,
         <name><name>range</name>.<name>mEndOffset</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>

  <if>if <condition>(<expr><name>mCursorPosition</name> == <name>NO_IME_CARET</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: GetTextRangeList, no caret\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>cursor</name> <init>= <expr><name>mCursorPosition</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>PRUint32</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call> &gt; <call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: SetTextRangeList, mCursorPosition=%ld. This is larger than mCompositionString.Length()=%lu\n",
       <name>mCursorPosition</name>, <call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cursor</name> = <call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name><name>range</name>.<name>mStartOffset</name></name> = <name><name>range</name>.<name>mEndOffset</name></name> = <name>cursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>.<name>mRangeType</name></name> = <name>NS_TEXTRANGE_CARETPOSITION</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aTextRangeList</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: SetTextRangeList, caret position=%ld\n",
     <name><name>range</name>.<name>mStartOffset</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIMM32Handler</name>::<name>GetCompositionString</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIMEContext</name> &amp;</type><name>aIMEContext</name></decl></param>,
                                     <param><decl><type><name>DWORD</name></type> <name>aIndex</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Retrieve the size of the required output buffer.</comment>
  <decl_stmt><decl><type><name>long</name></type> <name>lRtn</name> <init>= <expr><call><name>::<name>ImmGetCompositionStringW</name></name><argument_list>(<argument><expr><call><name><name>aIMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aIndex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>lRtn</name> &lt; 0 ||
      !<call><name>EnsureStringLength</name><argument_list>(<argument><expr><name>mCompositionString</name></expr></argument>, <argument><expr>(<name>lRtn</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof>) + 1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: GetCompositionString, FAILED by OOM\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return> <comment type="line">// Error or out of memory.</comment>
  }</block></then></if>

  <comment type="line">// Actually retrieve the composition string information.</comment>
  <expr_stmt><expr><name>lRtn</name> = <call><name>::<name>ImmGetCompositionStringW</name></name><argument_list>(<argument><expr><call><name><name>aIMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aIndex</name></expr></argument>,
                                    <argument><expr>(<name>LPVOID</name>)<call><name><name>mCompositionString</name>.<name>BeginWriting</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><name>lRtn</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mCompositionString</name>.<name>SetLength</name></name><argument_list>(<argument><expr><name>lRtn</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: GetCompositionString, SUCCEEDED mCompositionString=\"%s\"\n",
     <call><name>NS_ConvertUTF16toUTF8</name><argument_list>(<argument><expr><name>mCompositionString</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>ConvertToANSIString</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAFlatString</name>&amp;</type> <name>aStr</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>aCodePage</name></decl></param>,
                                   <param><decl><type><name>nsACString</name>&amp;</type> <name>aANSIStr</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>::<name>WideCharToMultiByte</name></name><argument_list>(<argument><expr><name>aCodePage</name></expr></argument>, <argument><expr>0</expr></argument>,
                                  <argument><expr>(<name>LPCWSTR</name>)<call><name><name>aStr</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aStr</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>len</name> &gt;= 0</expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>EnsureStringLength</name><argument_list>(<argument><expr><name>aANSIStr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: ConvertToANSIString, FAILED by OOM\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>::<name>WideCharToMultiByte</name></name><argument_list>(<argument><expr><name>aCodePage</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>LPCWSTR</name>)<call><name><name>aStr</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aStr</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr>(<name>LPSTR</name>)<call><name><name>aANSIStr</name>.<name>BeginWriting</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>GetCharacterRectOfSelectedTextAt</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                                                 <param><decl><type><name>PRUint32</name></type> <name>aOffset</name></decl></param>,
                                                 <param><decl><type><name>nsIntRect</name> &amp;</type><name>aCharRect</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>point</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>

  <function_decl><type><name>nsQueryContentEvent</name></type> <name>selection</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_QUERY_SELECTED_TEXT</name></type></decl></param>, <param><decl><type><name>aWindow</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>InitEvent</name></name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>DispatchWindowEvent</name></name><argument_list>(<argument><expr>&amp;<name>selection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name><name>selection</name>.<name>mSucceeded</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: GetCharacterRectOfSelectedTextAt, aOffset=%lu, FAILED (NS_QUERY_SELECTED_TEXT)\n",
       <name>aOffset</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>offset</name> <init>= <expr><name><name>selection</name>.<name>mReply</name>.<name>mOffset</name></name> + <name>aOffset</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>useCaretRect</name> <init>= <expr><call><name><name>selection</name>.<name>mReply</name>.<name>mString</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>useCaretRect</name> &amp;&amp; <call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call> &amp;&amp;
      <name>mIsComposing</name> &amp;&amp; !<call><name><name>mCompositionString</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// There is not a normal selection, but we have composition string.</comment>
    <comment type="line">// XXX mnakano - Should we implement NS_QUERY_IME_SELECTED_TEXT?</comment>
    <expr_stmt><expr><name>useCaretRect</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mCursorPosition</name> != <name>NO_IME_CARET</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRUint32</name></type> <name>cursorPosition</name> <init>=
        <expr><call><name>PR_MIN</name><argument_list>(<argument><expr><call><name>PRUint32</name><argument_list>(<argument><expr><name>mCursorPosition</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>offset</name> -= <name>cursorPosition</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>offset</name> &gt;= 0</expr></argument>, <argument><expr>"offset is negative!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>r</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>useCaretRect</name></expr>)</condition><then> <block>{
    <function_decl><type><name>nsQueryContentEvent</name></type> <name>charRect</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_QUERY_TEXT_RECT</name></type></decl></param>, <param><decl><type><name>aWindow</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name><name>charRect</name>.<name>InitForQueryTextRect</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>InitEvent</name></name><argument_list>(<argument><expr><name>charRect</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>DispatchWindowEvent</name></name><argument_list>(<argument><expr>&amp;<name>charRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>charRect</name>.<name>mSucceeded</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aCharRect</name> = <name><name>charRect</name>.<name>mReply</name>.<name>mRect</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: GetCharacterRectOfSelectedTextAt, aOffset=%lu, SUCCEEDED\n",
         <name>aOffset</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
        <argument><expr>("IMM32: GetCharacterRectOfSelectedTextAt, aCharRect={ x: %ld, y: %ld, width: %ld, height: %ld }\n",
         <name><name>aCharRect</name>.<name>x</name></name>, <name><name>aCharRect</name>.<name>y</name></name>, <name><name>aCharRect</name>.<name>width</name></name>, <name><name>aCharRect</name>.<name>height</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><call><name>GetCaretRect</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>aCharRect</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>GetCaretRect</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>, <param><decl><type><name>nsIntRect</name> &amp;</type><name>aCaretRect</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>point</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>

  <function_decl><type><name>nsQueryContentEvent</name></type> <name>selection</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_QUERY_SELECTED_TEXT</name></type></decl></param>, <param><decl><type><name>aWindow</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>InitEvent</name></name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>DispatchWindowEvent</name></name><argument_list>(<argument><expr>&amp;<name>selection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name><name>selection</name>.<name>mSucceeded</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: GetCaretRect,  FAILED (NS_QUERY_SELECTED_TEXT)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>offset</name> <init>= <expr><name><name>selection</name>.<name>mReply</name>.<name>mOffset</name></name></expr></init></decl>;</decl_stmt>

  <function_decl><type><name>nsQueryContentEvent</name></type> <name>caretRect</name><parameter_list>(<param><decl><type><name>PR_TRUE</name></type></decl></param>, <param><decl><type><name>NS_QUERY_CARET_RECT</name></type></decl></param>, <param><decl><type><name>aWindow</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>caretRect</name>.<name>InitForQueryCaretRect</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>InitEvent</name></name><argument_list>(<argument><expr><name>caretRect</name></expr></argument>, <argument><expr>&amp;<name>point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aWindow</name>-&gt;<name>DispatchWindowEvent</name></name><argument_list>(<argument><expr>&amp;<name>caretRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name><name>caretRect</name>.<name>mSucceeded</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: GetCaretRect,  FAILED (NS_QUERY_CARET_RECT)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>aCaretRect</name> = <name><name>caretRect</name>.<name>mReply</name>.<name>mRect</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
    <argument><expr>("IMM32: GetCaretRect, SUCCEEDED, aCaretRect={ x: %ld, y: %ld, width: %ld, height: %ld }\n",
     <name><name>aCaretRect</name>.<name>x</name></name>, <name><name>aCaretRect</name>.<name>y</name></name>, <name><name>aCaretRect</name>.<name>width</name></name>, <name><name>aCaretRect</name>.<name>height</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>SetIMERelatedWindowsPos</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>nsIMEContext</name> &amp;</type><name>aIMEContext</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>r</name></decl>;</decl_stmt>
  <comment type="line">// Get first character rect of current a normal selected text or a composing</comment>
  <comment type="line">// string.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>ret</name> <init>= <expr><call><name>GetCharacterRectOfSelectedTextAt</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsWindow</name>*</type> <name>toplevelWindow</name> <init>= <expr><call><name><name>aWindow</name>-&gt;<name>GetTopLevelWindow</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>firstSelectedCharRect</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ResolveIMECaretPos</name><argument_list>(<argument><expr><name>toplevelWindow</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>firstSelectedCharRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Set native caret size/position to our caret. Some IMEs honor it. E.g.,</comment>
  <comment type="line">// "Intelligent ABC" (Simplified Chinese) and "MS PinYin 3.0" (Simplified</comment>
  <comment type="line">// Chinese) on XP.</comment>
  <function_decl><type><name>nsIntRect</name></type> <name>caretRect</name><parameter_list>(<param><decl><type><name>firstSelectedCharRect</name></type></decl></param>)</parameter_list>;</function_decl>
  <if>if <condition>(<expr><call><name>GetCaretRect</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ResolveIMECaretPos</name><argument_list>(<argument><expr><name>toplevelWindow</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>caretRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"failed to get caret rect"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>caretRect</name>.<name>width</name></name> = 1</expr>;</expr_stmt>
  }</block></else></if>
  <if>if <condition>(<expr>!<name>mNativeCaretIsCreated</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mNativeCaretIsCreated</name> = <call><name>::<name>CreateCaret</name></name><argument_list>(<argument><expr><call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>,
                                          <argument><expr><name><name>caretRect</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>caretRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: SetIMERelatedWindowsPos, mNativeCaretIsCreated=%s, width=%ld height=%ld\n",
       <name>mNativeCaretIsCreated</name> ? "TRUE" : "FALSE",
       <name><name>caretRect</name>.<name>width</name></name>, <name><name>caretRect</name>.<name>height</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>::<name>SetCaretPos</name></name><argument_list>(<argument><expr><name><name>caretRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>caretRect</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>ShouldDrawCompositionStringOurselves</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: SetIMERelatedWindowsPos, Set candidate window\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Get a rect of first character in current target in composition string.</comment>
    <if>if <condition>(<expr><name>mIsComposing</name> &amp;&amp; !<call><name><name>mCompositionString</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// If there are no targetted selection, we should use it's first character</comment>
      <comment type="line">// rect instead.</comment>
      <decl_stmt><decl><type><name>PRUint32</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>mAttributeArray</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>mAttributeArray</name><index>[<expr><name>i</name></expr>]</index></name> == <name>ATTR_TARGET_NOTCONVERTED</name> ||
            <name><name>mAttributeArray</name><index>[<expr><name>i</name></expr>]</index></name> == <name>ATTR_TARGET_CONVERTED</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>offset</name> = <name>i</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></for>
      <expr_stmt><expr><name>ret</name> = <call><name>GetCharacterRectOfSelectedTextAt</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <comment type="line">// If there are no composition string, we should use a first character</comment>
      <comment type="line">// rect.</comment>
      <expr_stmt><expr><name>ret</name> = <call><name>GetCharacterRectOfSelectedTextAt</name><argument_list>(<argument><expr><name>aWindow</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <decl_stmt><decl><type><name>nsIntRect</name></type> <name>firstTargetCharRect</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ResolveIMECaretPos</name><argument_list>(<argument><expr><name>toplevelWindow</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>aWindow</name></expr></argument>, <argument><expr><name>firstTargetCharRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Move the candidate window to first character position of the target.</comment>
    <decl_stmt><decl><type><name>CANDIDATEFORM</name></type> <name>candForm</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>candForm</name>.<name>dwIndex</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>candForm</name>.<name>dwStyle</name></name> = <name>CFS_EXCLUDE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>candForm</name>.<name>ptCurrentPos</name>.<name>x</name></name> = <name><name>firstTargetCharRect</name>.<name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>candForm</name>.<name>ptCurrentPos</name>.<name>y</name></name> = <name><name>firstTargetCharRect</name>.<name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>candForm</name>.<name>rcArea</name>.<name>right</name></name> = <name><name>candForm</name>.<name>rcArea</name>.<name>left</name></name> = <name><name>candForm</name>.<name>ptCurrentPos</name>.<name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>candForm</name>.<name>rcArea</name>.<name>top</name></name> = <name><name>candForm</name>.<name>ptCurrentPos</name>.<name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>candForm</name>.<name>rcArea</name>.<name>bottom</name></name> = <name><name>candForm</name>.<name>ptCurrentPos</name>.<name>y</name></name> +
                               <name><name>firstTargetCharRect</name>.<name>height</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>ImmSetCandidateWindow</name></name><argument_list>(<argument><expr><call><name><name>aIMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>candForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gIMM32Log</name></expr></argument>, <argument><expr><name>PR_LOG_ALWAYS</name></expr></argument>,
      <argument><expr>("IMM32: SetIMERelatedWindowsPos, Set composition window\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Move the composition window to caret position (if selected some</comment>
    <comment type="line">// characters, we should use first character rect of them).</comment>
    <comment type="line">// And in this mode, IME adjusts the candidate window position</comment>
    <comment type="line">// automatically. So, we don't need to set it.</comment>
    <decl_stmt><decl><type><name>COMPOSITIONFORM</name></type> <name>compForm</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>compForm</name>.<name>dwStyle</name></name> = <name>CFS_POINT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>compForm</name>.<name>ptCurrentPos</name>.<name>x</name></name> = <name><name>firstSelectedCharRect</name>.<name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>compForm</name>.<name>ptCurrentPos</name>.<name>y</name></name> = <name><name>firstSelectedCharRect</name>.<name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>ImmSetCompositionWindow</name></name><argument_list>(<argument><expr><call><name><name>aIMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>compForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsIMM32Handler</name>::<name>ResolveIMECaretPos</name></name><parameter_list>(<param><decl><type><name>nsIWidget</name>*</type> <name>aReferenceWidget</name></decl></param>,
                                   <param><decl><type><name>nsIntRect</name>&amp;</type> <name>aCursorRect</name></decl></param>,
                                   <param><decl><type><name>nsIWidget</name>*</type> <name>aNewOriginWidget</name></decl></param>,
                                   <param><decl><type><name>nsIntRect</name>&amp;</type> <name>aOutRect</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>aOutRect</name> = <name>aCursorRect</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>aReferenceWidget</name> == <name>aNewOriginWidget</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <if>if <condition>(<expr><name>aReferenceWidget</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>aOutRect</name>.<name>MoveBy</name></name><argument_list>(<argument><expr><call><name><name>aReferenceWidget</name>-&gt;<name>WidgetToScreenOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>aNewOriginWidget</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>aOutRect</name>.<name>MoveBy</name></name><argument_list>(<argument><expr>-<call><name><name>aNewOriginWidget</name>-&gt;<name>WidgetToScreenOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_IME_MOUSE_HANDLING</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PT_IN_RECT</name><parameter_list>(<param><type><name>pt</name></type></param>, <param><type><name>rc</name></type></param>)</parameter_list></cpp:macro> \
          <cpp:value>((pt).x&gt;(rc).left &amp;&amp; (pt).x &lt;(rc).right &amp;&amp; \
           (pt).y&gt;(rc).top &amp;&amp; (pt).y&lt;(rc).bottom)</cpp:value></cpp:define>

<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>OnMouseEvent</name></name><parameter_list>(<param><decl><type><name>nsWindow</name>*</type> <name>aWindow</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>, <param><decl><type><name>int</name></type> <name>aAction</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>sWM_MSIME_MOUSE</name> || !<name>mIsComposing</name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>POINT</name></type> <name>ptPos</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ptPos</name>.<name>x</name></name> = (<name>short</name>)<call><name>LOWORD</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ptPos</name>.<name>y</name></name> = (<name>short</name>)<call><name>HIWORD</name><argument_list>(<argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>IMECompositionHitTest</name><argument_list>(<argument><expr><name>ptPos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>int</name></type> <name>positioning</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="line">// calcurate positioning and offset</comment>
  <comment type="line">// char :            JCH1|JCH2|JCH3</comment>
  <comment type="line">// offset:           0011 1122 2233</comment>
  <comment type="line">// positioning:      2301 2301 2301</comment>

  <comment type="line">// Note: hitText has been done, so no check of mCompCharPos</comment>
  <comment type="line">// and composing char maximum limit is necessary.</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>len</name> <init>= <expr><call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <if>if <condition>(<expr><call><name>PT_IN_RECT</name><argument_list>(<argument><expr><name>ptPos</name></expr></argument>, <argument><expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <break>break;</break></then></if>
  }</block></for>
  <expr_stmt><expr><name>offset</name> = <name>i</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>ptPos</name>.<name>x</name></name> - <name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>left</name> &gt; <name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>right</name> - <name><name>ptPos</name>.<name>x</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>offset</name>++</expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>positioning</name> = (<name><name>ptPos</name>.<name>x</name></name> - <name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>left</name>) * 4 /
                  (<name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>right</name> - <name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>left</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>positioning</name> = (<name>positioning</name> + 2) % 4</expr>;</expr_stmt>

  <comment type="line">// send MS_MSIME_MOUSE message to default IME window.</comment>
  <decl_stmt><decl><type><name>HWND</name></type> <name>imeWnd</name> <init>= <expr><call><name>::<name>ImmGetDefaultIMEWnd</name></name><argument_list>(<argument><expr><call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIMEContext</name></type> <name>IMEContext</name><argument_list>(<argument><expr><call><name><name>aWindow</name>-&gt;<name>GetWindowHandle</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <return>return <expr><call><name>::<name>SendMessageW</name></name><argument_list>(<argument><expr><name>imeWnd</name></expr></argument>, <argument><expr><name>sWM_MSIME_MOUSE</name></expr></argument>,
                        <argument><expr><call><name>MAKELONG</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><name>aAction</name></expr></argument>, <argument><expr><name>positioning</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr>(<name>LPARAM</name>) <call><name><name>IMEContext</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == 1</expr>;</return>
}</block></function>

<comment type="line">//The coordinate is relative to the upper-left corner of the client area.</comment>
<function><type><name>PRBool</name></type>
<name><name>nsIMM32Handler</name>::<name>IMECompositionHitTest</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>POINT</name>&amp;</type> <name>aPos</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// figure out how many char in composing string,</comment>
  <comment type="line">// but keep it below the limit we can handle</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>len</name> <init>= <expr><call><name><name>mCompositionString</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>len</name> &gt; <name>IME_MAX_CHAR_POS</name></expr>)</condition><then>
    <expr_stmt><expr><name>len</name> = <name>IME_MAX_CHAR_POS</name></expr>;</expr_stmt></then></if>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>aveWidth</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <comment type="line">// found per char width</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <if>if <condition>(<expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>left</name> &gt;= 0 &amp;&amp; <name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>right</name> &gt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>aveWidth</name> = <name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>right</name> - <name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>left</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>

  <comment type="line">// validate each rect and test</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <if>if <condition>(<expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>left</name> &lt; 0</expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>i</name> != 0 &amp;&amp; <name><name>mCompCharPos</name><index>[<expr><name>i</name>-1</expr>]</index></name>.<name>top</name> == <name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>top</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>left</name> = <name><name>mCompCharPos</name><index>[<expr><name>i</name>-1</expr>]</index></name>.<name>right</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>left</name> = <name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>right</name> - <name>aveWidth</name></expr>;</expr_stmt></else></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>right</name> &lt; 0</expr>)</condition><then>
      <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>right</name> = <name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>left</name> + <name>aveWidth</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>top</name> &lt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>top</name> = <name><name>mCompCharPos</name><index>[<expr><name>i</name>-1</expr>]</index></name>.<name>top</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name>.<name>bottom</name> = <name><name>mCompCharPos</name><index>[<expr><name>i</name>-1</expr>]</index></name>.<name>bottom</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>PT_IN_RECT</name><argument_list>(<argument><expr><name>aPos</name></expr></argument>, <argument><expr><name><name>mCompCharPos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// ENABLE_IME_MOUSE_HANDLING</comment>
</unit>
