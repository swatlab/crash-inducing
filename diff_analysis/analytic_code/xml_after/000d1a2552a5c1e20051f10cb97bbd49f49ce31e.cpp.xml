<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="000d1a2552a5c1e20051f10cb97bbd49f49ce31e.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/* rendering object that goes directly inside the document's scrollbars */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCanvasFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIServiceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHTMLParts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHTMLContainerFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSRendering.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPresContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRenderingContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGUIEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleConsts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGkAtoms.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIEventStateManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDeviceContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPresShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScrollPositionListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDisplayList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAbsoluteContainingBlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSFrameConstructor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameManager.h"</cpp:file></cpp:include>

<comment type="line">// for focus</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMWindowInternal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScrollableFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocShell.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_rods</name></cpp:ifdef>
<comment type="line">//#define DEBUG_CANVAS_FOCUS</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CANVAS_ABS_POS_CHILD_LIST</name></cpp:macro> <cpp:value>NS_CONTAINER_LIST_COUNT_INCL_OC</cpp:value></cpp:define>


<function><type><name>nsIFrame</name>*</type>
<name>NS_NewCanvasFrame</name><parameter_list>(<param><decl><type><name>nsIPresShell</name>*</type> <name>aPresShell</name></decl></param>, <param><decl><type><name>nsStyleContext</name>*</type> <name>aContext</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>new (<name>aPresShell</name>) <call><name>nsCanvasFrame</name><argument_list>(<argument><expr><name>aContext</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>NS_IMPL_FRAMEARENA_HELPERS</name><argument_list>(<argument>nsCanvasFrame</argument>)</argument_list></macro>

<macro><name>NS_QUERYFRAME_HEAD</name><argument_list>(<argument>nsCanvasFrame</argument>)</argument_list></macro>
  <macro><name>NS_QUERYFRAME_ENTRY</name><argument_list>(<argument>nsCanvasFrame</argument>)</argument_list></macro>
<macro><name>NS_QUERYFRAME_TAIL_INHERITING</name><argument_list>(<argument>nsHTMLContainerFrame</argument>)</argument_list></macro>

<function><type><name>void</name></type>
<name><name>nsCanvasFrame</name>::<name>DestroyFrom</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aDestructRoot</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mAbsoluteContainer</name>.<name>DestroyFrames</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aDestructRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsIScrollableFrame</name>*</type> <name>sf</name> <init>=
    <expr><call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>GetPresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootScrollFrameAsScrollable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>sf</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>sf</name>-&gt;<name>RemoveScrollPositionListener</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>nsHTMLContainerFrame</name>::<name>DestroyFrom</name></name><argument_list>(<argument><expr><name>aDestructRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCanvasFrame</name>::<name>ScrollPositionWillChange</name></name><parameter_list>(<param><decl><type><name>nscoord</name></type> <name>aX</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aY</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mDoPaintFocus</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mDoPaintFocus</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call>-&gt;<call><name>InvalidateOverflowRect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasFrame</name>::<name>SetHasFocus</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aHasFocus</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mDoPaintFocus</name> != <name>aHasFocus</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mDoPaintFocus</name> = <name>aHasFocus</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>FrameManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call>-&gt;<call><name>InvalidateOverflowRect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>mAddedScrollPositionListener</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mAddedScrollPositionListener</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsIScrollableFrame</name>*</type> <name>sf</name> <init>=
        <expr><call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>GetPresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootScrollFrameAsScrollable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>sf</name>-&gt;<name>AddScrollPositionListener</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasFrame</name>::<name>SetInitialChildList</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type>        <name>aListName</name></decl></param>,
                                 <param><decl><type><name>nsFrameList</name>&amp;</type>    <name>aChildList</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>absoluteList</name></name> == <name>aListName</name></expr>)</condition><then>
    <return>return <expr><call><name><name>mAbsoluteContainer</name>.<name>SetInitialChildList</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aListName</name></expr></argument>, <argument><expr><name>aChildList</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aListName</name> || <call><name><name>aChildList</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> || <call><name><name>aChildList</name>.<name>OnlyChild</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Primary child list can have at most one frame in it"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>nsHTMLContainerFrame</name>::<name>SetInitialChildList</name></name><argument_list>(<argument><expr><name>aListName</name></expr></argument>, <argument><expr><name>aChildList</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasFrame</name>::<name>AppendFrames</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type>        <name>aListName</name></decl></param>,
                          <param><decl><type><name>nsFrameList</name>&amp;</type>    <name>aFrameList</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type>  <name>rv</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>absoluteList</name></name> == <name>aListName</name></expr>)</condition><then>
    <return>return <expr><call><name><name>mAbsoluteContainer</name>.<name>AppendFrames</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aListName</name></expr></argument>, <argument><expr><name>aFrameList</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aListName</name></expr></argument>, <argument><expr>"unexpected child list name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><call><name><name>mFrames</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"already have a child frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aListName</name></expr>)</condition><then> <block>{
    <comment type="line">// We only support unnamed principal child list</comment>
    <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_INVALID_ARG</name></expr>;</expr_stmt>

  }</block></then> <else>else <if>if <condition>(<expr>!<call><name><name>mFrames</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// We only allow a single child frame</comment>
    <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_FAILURE</name></expr>;</expr_stmt>

  }</block></then> <else>else <block>{
    <comment type="line">// Insert the new frames</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aFrameList</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call> == <call><name><name>aFrameList</name>.<name>LastChild</name></name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"Only one principal child frame allowed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>nsFrame</name>::<name>VerifyDirtyBitSet</name></name><argument_list>(<argument><expr><name>aFrameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name><name>mFrames</name>.<name>AppendFrames</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aFrameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call>-&gt;
           <call><name>FrameNeedsReflow</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>nsIPresShell</name>::<name>eTreeChange</name></name></expr></argument>,
                            <argument><expr><name>NS_FRAME_HAS_DIRTY_CHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasFrame</name>::<name>InsertFrames</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type>        <name>aListName</name></decl></param>,
                          <param><decl><type><name>nsIFrame</name>*</type>       <name>aPrevFrame</name></decl></param>,
                          <param><decl><type><name>nsFrameList</name>&amp;</type>    <name>aFrameList</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type>  <name>rv</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>absoluteList</name></name> == <name>aListName</name></expr>)</condition><then>
    <return>return <expr><call><name><name>mAbsoluteContainer</name>.<name>InsertFrames</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aListName</name></expr></argument>, <argument><expr><name>aPrevFrame</name></expr></argument>, <argument><expr><name>aFrameList</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="line">// Because we only support a single child frame inserting is the same</comment>
  <comment type="line">// as appending</comment>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>aPrevFrame</name></expr></argument>, <argument><expr>"unexpected previous sibling frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aPrevFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_UNEXPECTED</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>rv</name> = <call><name>AppendFrames</name><argument_list>(<argument><expr><name>aListName</name></expr></argument>, <argument><expr><name>aFrameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasFrame</name>::<name>RemoveFrame</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type>        <name>aListName</name></decl></param>,
                         <param><decl><type><name>nsIFrame</name>*</type>       <name>aOldFrame</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type>  <name>rv</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>absoluteList</name></name> == <name>aListName</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mAbsoluteContainer</name>.<name>RemoveFrame</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aListName</name></expr></argument>, <argument><expr><name>aOldFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aListName</name></expr></argument>, <argument><expr>"unexpected child list name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aListName</name></expr>)</condition><then> <block>{
    <comment type="line">// We only support the unnamed principal child list</comment>
    <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_INVALID_ARG</name></expr>;</expr_stmt>
  
  }</block></then> <else>else <if>if <condition>(<expr><name>aOldFrame</name> == <call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// It's our one and only child frame</comment>
    <comment type="line">// Damage the area occupied by the deleted frame</comment>
    <comment type="line">// The child of the canvas probably can't have an outline, but why bother</comment>
    <comment type="line">// thinking about that?</comment>
    <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><call><name><name>aOldFrame</name>-&gt;<name>GetOverflowRect</name></name><argument_list>()</argument_list></call> + <call><name><name>aOldFrame</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Remove the frame and destroy it</comment>
    <expr_stmt><expr><call><name><name>mFrames</name>.<name>DestroyFrame</name></name><argument_list>(<argument><expr><name>aOldFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call>-&gt;
           <call><name>FrameNeedsReflow</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>nsIPresShell</name>::<name>eTreeChange</name></name></expr></argument>,
                            <argument><expr><name>NS_FRAME_HAS_DIRTY_CHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_FAILURE</name></expr>;</expr_stmt>
  }</block></else></if></else></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsIAtom</name>*</type>
<name><name>nsCanvasFrame</name>::<name>GetAdditionalChildListName</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aIndex</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr><name>CANVAS_ABS_POS_CHILD_LIST</name> == <name>aIndex</name></expr>)</condition><then>
    <return>return <expr><name><name>nsGkAtoms</name>::<name>absoluteList</name></name></expr>;</return></then></if>

  <return>return <expr><call><name><name>nsHTMLContainerFrame</name>::<name>GetAdditionalChildListName</name></name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsFrameList</name></type>
<name><name>nsCanvasFrame</name>::<name>GetChildList</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type> <name>aListName</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>absoluteList</name></name> == <name>aListName</name></expr>)</condition><then>
    <return>return <expr><call><name><name>mAbsoluteContainer</name>.<name>GetChildList</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

  <return>return <expr><call><name><name>nsHTMLContainerFrame</name>::<name>GetChildList</name></name><argument_list>(<argument><expr><name>aListName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsRect</name></type> <name><name>nsCanvasFrame</name>::<name>CanvasArea</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <decl_stmt><decl><type><name>nsRect</name></type> <name>result</name><argument_list>(<argument><expr><call><name>GetOverflowRect</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIScrollableFrame</name> *</type><name>scrollableFrame</name> <init>= <expr><call><name>do_QueryFrame</name><argument_list>(<argument><expr><call><name>GetParent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>scrollableFrame</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>portRect</name> <init>= <expr><call><name><name>scrollableFrame</name>-&gt;<name>GetScrollPortRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>result</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>portRect</name>.<name>Size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Override nsDisplayBackground methods so that we pass aBGClipRect to
 * PaintBackground, covering the whole overflow area.
 */</comment>
<class>class <name>nsDisplayCanvasBackground</name> <super>: <specifier>public</specifier> <name>nsDisplayBackground</name></super> <block>{<private type="default">
</private><public>public:
  <constructor><name>nsDisplayCanvasBackground</name><parameter_list>(<param><decl><type><name>nsIFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>
    <member_list>: <call><name>nsDisplayBackground</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call>
  </member_list><block>{
  }</block></constructor>

  <function><type><specifier>virtual</specifier> <name>nsRect</name></type> <name>GetBounds</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list>
  <block>{
    <decl_stmt><decl><type><name>nsCanvasFrame</name>*</type> <name>frame</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsCanvasFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>frame</name>-&gt;<name>CanvasArea</name></name><argument_list>()</argument_list></call> + <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                     <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list>
  <block>{
    <decl_stmt><decl><type><name>nsCanvasFrame</name>*</type> <name>frame</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsCanvasFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsPoint</name></type> <name>offset</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>bgClipRect</name> <init>= <expr><call><name><name>frame</name>-&gt;<name>CanvasArea</name></name><argument_list>()</argument_list></call> + <name>offset</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>PaintBackground</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>*<name>aCtx</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>,
                                    <argument><expr><name>mVisibleRect</name></expr></argument>,
                                    <argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name><name>aBuilder</name>-&gt;<name>GetBackgroundPaintFlags</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr>&amp;<name>bgClipRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"CanvasBackground"</argument>)</argument_list></macro>
</public>}</block>;</class>

<comment type="block" format="doxygen">/**
 * A display item to paint the focus ring for the document.
 *
 * The only reason this can't use nsDisplayGeneric is overriding GetBounds.
 */</comment>
<class>class <name>nsDisplayCanvasFocus</name> <super>: <specifier>public</specifier> <name>nsDisplayItem</name></super> <block>{<private type="default">
</private><public>public:
  <constructor><name>nsDisplayCanvasFocus</name><parameter_list>(<param><decl><type><name>nsCanvasFrame</name> *</type><name>aFrame</name></decl></param>)</parameter_list>
    <member_list>: <call><name>nsDisplayItem</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call>
  </member_list><block>{
  }</block></constructor>

  <function><type><specifier>virtual</specifier> <name>nsRect</name></type> <name>GetBounds</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list>
  <block>{
    <comment type="line">// This is an overestimate, but that's not a problem.</comment>
    <decl_stmt><decl><type><name>nsCanvasFrame</name>*</type> <name>frame</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsCanvasFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>frame</name>-&gt;<name>CanvasArea</name></name><argument_list>()</argument_list></call> + <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                     <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list>
  <block>{
    <decl_stmt><decl><type><name>nsCanvasFrame</name>*</type> <name>frame</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsCanvasFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>frame</name>-&gt;<name>PaintFocus</name></name><argument_list>(<argument><expr>*<name>aCtx</name></expr></argument>, <argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <macro><name>NS_DISPLAY_DECL_NAME</name><argument_list>(<argument>"CanvasFocus"</argument>)</argument_list></macro>
</public>}</block>;</class>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasFrame</name>::<name>BuildDisplayList</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type>   <name>aBuilder</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type>           <name>aDirtyRect</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aLists</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>DisplayOverflowContainers</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aDirtyRect</name></expr></argument>, <argument><expr><name>aLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>aBuilder</name>-&gt;<name>MarkFramesForDisplayList</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name><name>mAbsoluteContainer</name>.<name>GetChildList</name></name><argument_list>()</argument_list></call></expr></argument>,
                                     <argument><expr><name>aDirtyRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// Force a background to be shown. We may have a background propagated to us,</comment>
  <comment type="line">// in which case GetStyleBackground wouldn't have the right background</comment>
  <comment type="line">// and the code in nsFrame::DisplayBorderBackgroundOutline might not give us</comment>
  <comment type="line">// a background.</comment>
  <comment type="line">// We don't have any border or outline, and our background draws over</comment>
  <comment type="line">// the overflow area, so just add nsDisplayCanvasBackground instead of</comment>
  <comment type="line">// calling DisplayBorderBackgroundOutline.</comment>
  <if>if <condition>(<expr><call><name>IsVisibleForPainting</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ 
    <expr_stmt><expr><name>rv</name> = <call><name><name>aLists</name>.<name>BorderBackground</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendNewToTop</name><argument_list>(<argument><expr>new (<name>aBuilder</name>)
           <call><name>nsDisplayCanvasBackground</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kid</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>kid</name> = <call><name>GetFirstChild</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>kid</name></expr>;</condition> <incr><expr><name>kid</name> = <call><name><name>kid</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <comment type="line">// Put our child into its own pseudo-stack.</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>BuildDisplayListForChild</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>kid</name></expr></argument>, <argument><expr><name>aDirtyRect</name></expr></argument>, <argument><expr><name>aLists</name></expr></argument>,
                                  <argument><expr><name>DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CANVAS_FOCUS</name></cpp:ifdef>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIContent</name></expr></argument>&gt;</argument_list></name></type> <name>focusContent</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aPresContext</name>-&gt;<name>EventStateManager</name></name><argument_list>()</argument_list></call>-&gt;
    <call><name>GetFocusedContent</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>focusContent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>hasFocus</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>container</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aPresContext</name>-&gt;<name>GetContainer</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShell</name></expr></argument>&gt;</argument_list></name></type> <name>docShell</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>docShell</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>docShell</name>-&gt;<name>GetHasFocus</name></name><argument_list>(<argument><expr>&amp;<name>hasFocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%p - nsCanvasFrame::Paint R:%d,%d,%d,%d  DR: %d,%d,%d,%d\n"</expr></argument>, <argument><expr><name>this</name></expr></argument>, 
            <argument><expr><name><name>mRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>mRect</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>mRect</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mRect</name>.<name>height</name></name></expr></argument>,
            <argument><expr><name><name>aDirtyRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aDirtyRect</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>aDirtyRect</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aDirtyRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%p - Focus: %s   c: %p  DoPaint:%s\n"</expr></argument>, <argument><expr><call><name><name>docShell</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hasFocus</name>?"Y":"N"</expr></argument>, 
         <argument><expr><call><name><name>focusContent</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mDoPaintFocus</name>?"Y":"N"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr>!<name>mDoPaintFocus</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  <comment type="line">// Only paint the focus if we're visible</comment>
  <if>if <condition>(<expr>!<call><name>GetStyleVisibility</name><argument_list>()</argument_list></call>-&gt;<call><name>IsVisible</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  
  <return>return <expr><call><name><name>aLists</name>.<name>Outlines</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendNewToTop</name><argument_list>(<argument><expr>new (<name>aBuilder</name>)
      <call><name>nsDisplayCanvasFocus</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsCanvasFrame</name>::<name>PaintFocus</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name>&amp;</type> <name>aRenderingContext</name></decl></param>, <param><decl><type><name>nsPoint</name></type> <name>aPt</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsRect</name></type> <name>focusRect</name><argument_list>(<argument><expr><name>aPt</name></expr></argument>, <argument><expr><call><name>GetSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIScrollableFrame</name> *</type><name>scrollableFrame</name> <init>= <expr><call><name>do_QueryFrame</name><argument_list>(<argument><expr><call><name>GetParent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>scrollableFrame</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>portRect</name> <init>= <expr><call><name><name>scrollableFrame</name>-&gt;<name>GetScrollPortRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>focusRect</name>.<name>width</name></name> = <name><name>portRect</name>.<name>width</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>focusRect</name>.<name>height</name></name> = <name><name>portRect</name>.<name>height</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>focusRect</name>.<name>MoveBy</name></name><argument_list>(<argument><expr><call><name><name>scrollableFrame</name>-&gt;<name>GetScrollPosition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

 <comment type="line">// XXX use the root frame foreground color, but should we find BODY frame</comment>
 <comment type="line">// for HTML documents?</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>root</name> <init>= <expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleColor</name>*</type> <name>color</name> <init>=
    <expr><name>root</name> ? <call><name><name>root</name>-&gt;<name>GetStyleContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetStyleColor</name><argument_list>()</argument_list></call> :
           <call><name><name>mStyleContext</name>-&gt;<name>GetStyleColor</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>color</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"current color cannot be found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>PaintFocus</name></name><argument_list>(<argument><expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aRenderingContext</name></expr></argument>,
                             <argument><expr><name>focusRect</name></expr></argument>, <argument><expr><name><name>color</name>-&gt;<name>mColor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>nscoord</name></type>
<name><name>nsCanvasFrame</name>::<name>GetMinWidth</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>result</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>DISPLAY_MIN_WIDTH</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name><name>mFrames</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>result</name> = <call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetMinWidth</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>nscoord</name></type>
<name><name>nsCanvasFrame</name>::<name>GetPrefWidth</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>result</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>DISPLAY_PREF_WIDTH</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name><name>mFrames</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>result</name> = <call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetPrefWidth</name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasFrame</name>::<name>Reflow</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type>           <name>aPresContext</name></decl></param>,
                    <param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type>     <name>aDesiredSize</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                    <param><decl><type><name>nsReflowStatus</name>&amp;</type>          <name>aStatus</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>DO_GLOBAL_REFLOW_COUNT</name><argument_list>(<argument><expr>"nsCanvasFrame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DISPLAY_REFLOW</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aDesiredSize</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_FRAME_TRACE_REFLOW_IN</name><argument_list>(<argument><expr>"nsCanvasFrame::Reflow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Initialize OUT parameter</comment>
  <expr_stmt><expr><name>aStatus</name> = <name>NS_FRAME_COMPLETE</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsCanvasFrame</name>*</type> <name>prevCanvasFrame</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsCanvasFrame</name>*</expr></argument>&gt;</argument_list></name>
                                               <argument_list>(<argument><expr><call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>prevCanvasFrame</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsAutoPtr</name><argument_list>&lt;<argument><expr><name>nsFrameList</name></expr></argument>&gt;</argument_list></name></type> <name>overflow</name><argument_list>(<argument><expr><call><name><name>prevCanvasFrame</name>-&gt;<name>StealOverflowFrames</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>overflow</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>overflow</name>-&gt;<name>OnlyChild</name></name><argument_list>()</argument_list></call></expr></argument>,
                   <argument><expr>"must have doc root as canvas frame's only child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>nsHTMLContainerFrame</name>::<name>ReparentFrameViewList</name></name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr>*<name>overflow</name></expr></argument>,
                                                  <argument><expr><name>prevCanvasFrame</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// Prepend overflow to the our child list. There may already be</comment>
      <comment type="line">// children placeholders for fixed-pos elements, which don't get</comment>
      <comment type="line">// reflowed but must not be lost until the canvas frame is destroyed.</comment>
      <expr_stmt><expr><call><name><name>mFrames</name>.<name>InsertFrames</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>*<name>overflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Reflow our one and only normal child frame. It's either the root</comment>
  <comment type="line">// element's frame or a placeholder for that frame, if the root element</comment>
  <comment type="line">// is abs-pos or fixed-pos. We may have additional children which</comment>
  <comment type="line">// are placeholders for continuations of fixed-pos content, but those</comment>
  <comment type="line">// don't need to be reflowed. The normal child is always comes before</comment>
  <comment type="line">// the fixed-pos placeholders, because we insert it at the start</comment>
  <comment type="line">// of the child list, above.</comment>
  <decl_stmt><decl><type><name>nsHTMLReflowMetrics</name></type> <name>kidDesiredSize</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>mFrames</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// We have no child frame, so return an empty size</comment>
    <expr_stmt><expr><name><name>aDesiredSize</name>.<name>width</name></name> = <name><name>aDesiredSize</name>.<name>height</name></name> = 0</expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kidFrame</name> <init>= <expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>oldKidRect</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>kidDirty</name> <init>= <expr>(<call><name><name>kidFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_IS_DIRTY</name>) != 0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsHTMLReflowState</name></type> <name>kidReflowState</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>kidFrame</name></expr></argument>,
                                     <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name><name>aReflowState</name>.<name>availableWidth</name></name></expr></argument>,
                                            <argument><expr><name><name>aReflowState</name>.<name>availableHeight</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>aReflowState</name>.<name>mFlags</name>.<name>mVResize</name></name> &amp;&amp;
        (<call><name><name>kidFrame</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_CONTAINS_RELATIVE_HEIGHT</name>)</expr>)</condition><then> <block>{
      <comment type="line">// Tell our kid it's being vertically resized too.  Bit of a</comment>
      <comment type="line">// hack for framesets.</comment>
      <expr_stmt><expr><name><name>kidReflowState</name>.<name>mFlags</name>.<name>mVResize</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

    <function_decl><type><name>nsPoint</name></type> <name>kidPt</name><parameter_list>(<param><decl><type><name><name>kidReflowState</name>.<name>mComputedMargin</name>.<name>left</name></name></type></decl></param>,
                  <param><decl><type><name><name>kidReflowState</name>.<name>mComputedMargin</name>.<name>top</name></name></type></decl></param>)</parameter_list>;</function_decl>
    <comment type="line">// Apply CSS relative positioning</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>styleDisp</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>NS_STYLE_POSITION_RELATIVE</name> == <name><name>styleDisp</name>-&gt;<name>mPosition</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>kidPt</name> += <call><name>nsPoint</name><argument_list>(<argument><expr><name><name>kidReflowState</name>.<name>mComputedOffsets</name>.<name>left</name></name></expr></argument>,
                       <argument><expr><name><name>kidReflowState</name>.<name>mComputedOffsets</name>.<name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Reflow the frame</comment>
    <expr_stmt><expr><call><name>ReflowChild</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>kidDesiredSize</name></expr></argument>, <argument><expr><name>kidReflowState</name></expr></argument>,
                <argument><expr><name><name>kidPt</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>kidPt</name>.<name>y</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Complete the reflow and position and size the child frame</comment>
    <expr_stmt><expr><call><name>FinishReflowChild</name><argument_list>(<argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>aPresContext</name></expr></argument>, <argument><expr>&amp;<name>kidReflowState</name></expr></argument>, <argument><expr><name>kidDesiredSize</name></expr></argument>,
                      <argument><expr><name><name>kidPt</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>kidPt</name>.<name>y</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>NS_FRAME_IS_FULLY_COMPLETE</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>nextFrame</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>nextFrame</name> || <name>aStatus</name> &amp; <name>NS_FRAME_REFLOW_NEXTINFLOW</name></expr></argument>,
        <argument><expr>"If it's incomplete and has no nif yet, it must flag a nif reflow."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>nextFrame</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>aPresContext</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call>-&gt;<call><name>FrameConstructor</name><argument_list>()</argument_list></call>-&gt;
          <call><name>CreateContinuingFrame</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>kidFrame</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr>&amp;<name>nextFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SetOverflowFrames</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><call><name>nsFrameList</name><argument_list>(<argument><expr><name>nextFrame</name></expr></argument>, <argument><expr><name>nextFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Root overflow containers will be normal children of</comment>
        <comment type="line">// the canvas frame, but that's ok because there</comment>
        <comment type="line">// aren't any other frames we need to isolate them from</comment>
        <comment type="line">// during reflow.</comment>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>NS_FRAME_OVERFLOW_IS_INCOMPLETE</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>nextFrame</name>-&gt;<name>AddStateBits</name></name><argument_list>(<argument><expr><name>NS_FRAME_IS_OVERFLOW_CONTAINER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <comment type="line">// If the child frame was just inserted, then we're responsible for making sure</comment>
    <comment type="line">// it repaints</comment>
    <if>if <condition>(<expr><name>kidDirty</name></expr>)</condition><then> <block>{
      <comment type="line">// But we have a new child, which will affect our background, so</comment>
      <comment type="line">// invalidate our whole rect.</comment>
      <comment type="line">// Note: Even though we request to be sized to our child's size, our</comment>
      <comment type="line">// scroll frame ensures that we are always the size of the viewport.</comment>
      <comment type="line">// Also note: GetPosition() on a CanvasFrame is always going to return</comment>
      <comment type="line">// (0, 0). We only want to invalidate GetRect() since GetOverflowRect()</comment>
      <comment type="line">// could also include overflow to our top and left (out of the viewport)</comment>
      <comment type="line">// which doesn't need to be painted.</comment>
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>viewport</name> <init>= <expr><call><name>PresContext</name><argument_list>()</argument_list></call>-&gt;<call><name>GetPresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>viewport</name>-&gt;<name>Invalidate</name></name><argument_list>(<argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>viewport</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <decl_stmt><decl><type><name>nsRect</name></type> <name>newKidRect</name> <init>= <expr><call><name><name>kidFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name><name>newKidRect</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call> == <call><name><name>oldKidRect</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>InvalidateRectDifference</name><argument_list>(<argument><expr><name>oldKidRect</name></expr></argument>, <argument><expr><call><name><name>kidFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>oldKidRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>newKidRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if>
    
    <comment type="line">// Return our desired size. Normally it's what we're told, but</comment>
    <comment type="line">// sometimes we can be given an unconstrained height (when a window</comment>
    <comment type="line">// is sizing-to-content), and we should compute our desired height.</comment>
    <expr_stmt><expr><name><name>aDesiredSize</name>.<name>width</name></name> = <call><name><name>aReflowState</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>aReflowState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call> == <name>NS_UNCONSTRAINEDSIZE</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>aDesiredSize</name>.<name>height</name></name> = <call><name><name>kidFrame</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call>.<name>height</name> +
        <call><name><name>kidReflowState</name>.<name>mComputedMargin</name>.<name>TopBottom</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name><name>aDesiredSize</name>.<name>height</name></name> = <call><name><name>aReflowState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name><name>aDesiredSize</name>.<name>mOverflowArea</name>.<name>UnionRect</name></name><argument_list>(
      <argument><expr><call><name>nsRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>aDesiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aDesiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name><name>kidDesiredSize</name>.<name>mOverflowArea</name></name> + <name>kidPt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>mAbsoluteContainer</name>.<name>HasAbsoluteFrames</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>widthChanged</name> <init>= <expr><name><name>aDesiredSize</name>.<name>width</name></name> != <name><name>mRect</name>.<name>width</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>heightChanged</name> <init>= <expr><name><name>aDesiredSize</name>.<name>height</name></name> != <name><name>mRect</name>.<name>height</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsRect</name></type> <name>absPosBounds</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>mAbsoluteContainer</name>.<name>Reflow</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>,
                                <argument><expr><name><name>aDesiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aDesiredSize</name>.<name>height</name></name></expr></argument>,
                                <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>widthChanged</name></expr></argument>, <argument><expr><name>heightChanged</name></expr></argument>,
                                <argument><expr>&amp;<name>absPosBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aDesiredSize</name>.<name>mOverflowArea</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name><name>aDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>, <argument><expr><name>absPosBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Handle invalidating fixed-attachment backgrounds propagated to the</comment>
    <comment type="line">// canvas when the canvas size (and therefore the background positioning</comment>
    <comment type="line">// area's size) changes.  Such backgrounds are not invalidated in the</comment>
    <comment type="line">// normal manner because the size of the original frame for that background</comment>
    <comment type="line">// may not have changed.</comment>
    <comment type="line">//</comment>
    <comment type="line">// This isn't the right fix for this issue, taken more generally.  In</comment>
    <comment type="line">// particular, this doesn't handle fixed-attachment backgrounds that are *not*</comment>
    <comment type="line">// propagated.  If a layer with the characteristics tested for below exists</comment>
    <comment type="line">// in a non-propagated background, we should invalidate the "corresponding"</comment>
    <comment type="line">// frame (which subsumes this special case if defined broadly).  For now,</comment>
    <comment type="line">// however, this addresses the most common case.  Given that this behavior has</comment>
    <comment type="line">// long been broken (non-zero percent background-size may be a new instance,</comment>
    <comment type="line">// but non-zero percent background-position is longstanding), we defer a</comment>
    <comment type="line">// fully correct fix until later.</comment>
    <if>if <condition>(<expr><call><name>nsSize</name><argument_list>(<argument><expr><name><name>aDesiredSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aDesiredSize</name>.<name>height</name></name></expr></argument>)</argument_list></call> != <call><name>GetSize</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>rootElementFrame</name> <init>=
        <expr><call><name><name>aPresContext</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call>-&gt;<call><name>FrameConstructor</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRootElementStyleFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleBackground</name>*</type> <name>bg</name> <init>=
        <expr><call><name><name>nsCSSRendering</name>::<name>FindCanvasBackground</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>rootElementFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<call><name><name>bg</name>-&gt;<name>IsTransparent</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <macro><name>NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT</name><argument_list>(<argument>i</argument>, <argument>bg</argument>)</argument_list></macro> <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name><name>nsStyleBackground</name>::<name>Layer</name></name>&amp;</type> <name>layer</name> <init>= <expr><name><name>bg</name>-&gt;<name>mLayers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name><name>layer</name>.<name>mAttachment</name></name> == <name>NS_STYLE_BG_ATTACHMENT_FIXED</name> &amp;&amp;
              <call><name><name>layer</name>.<name>RenderingMightDependOnFrameSize</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block>
      }</block></then></if>
    }</block></then></if>
  }</block></else></if>

  <if>if <condition>(<expr><name>prevCanvasFrame</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ReflowOverflowContainerChildren</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>,
                                    <argument><expr><name><name>aDesiredSize</name>.<name>mOverflowArea</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                                    <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>FinishAndStoreOverflow</name><argument_list>(<argument><expr>&amp;<name>aDesiredSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_FRAME_TRACE_REFLOW_OUT</name><argument_list>(<argument><expr>"nsCanvasFrame::Reflow"</expr></argument>, <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_FRAME_SET_TRUNCATION</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aDesiredSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>PRIntn</name></type>
<name><name>nsCanvasFrame</name>::<name>GetSkipSides</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>nsIAtom</name>*</type>
<name><name>nsCanvasFrame</name>::<name>GetType</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name><name>nsGkAtoms</name>::<name>canvasFrame</name></name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> 
<name><name>nsCanvasFrame</name>::<name>GetContentForEvent</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type> <name>aPresContext</name></decl></param>,
                                <param><decl><type><name>nsEvent</name>*</type> <name>aEvent</name></decl></param>,
                                <param><decl><type><name>nsIContent</name>**</type> <name>aContent</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>nsFrame</name>::<name>GetContentForEvent</name></name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>,
                                            <argument><expr><name>aEvent</name></expr></argument>,
                                            <argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> || !*<name>aContent</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kid</name> <init>= <expr><call><name><name>mFrames</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>kid</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <call><name><name>kid</name>-&gt;<name>GetContentForEvent</name></name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>,
                                   <argument><expr><name>aEvent</name></expr></argument>,
                                   <argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsCanvasFrame</name>::<name>GetFrameName</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aResult</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><call><name>MakeFrameName</name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"Canvas"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
