<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="0034c5a7368ab3610b100f660c959545e9ed0fd9.h"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>jsparse_h___</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>jsparse_h___</name></cpp:macro></cpp:define>
<comment type="block">/*
 * JS parser definitions.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprvtd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspubtd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscan.h"</cpp:file></cpp:include>

<macro><name>JS_BEGIN_EXTERN_C</name></macro>

<comment type="block">/*
 * Parsing builds a tree of nodes that directs code generation.  This tree is
 * not a concrete syntax tree in all respects (for example, || and &amp;&amp; are left
 * associative, but (A &amp;&amp; B &amp;&amp; C) translates into the right-associated tree
 * &lt;A &amp;&amp; &lt;B &amp;&amp; C&gt;&gt; so that code generation can emit a left-associative branch
 * around &lt;B &amp;&amp; C&gt; when A is false).  Nodes are labeled by token type, with a
 * JSOp secondary label when needed:
 *
 * Label        Variant     Members
 * -----        -------     -------
 * &lt;Definitions&gt;
 * TOK_FUNCTION name        pn_funbox: ptr to JSFunctionBox holding function
 *                            object containing arg and var properties.  We
 *                            create the function object at parse (not emit)
 *                            time to specialize arg and var bytecodes early.
 *                          pn_body: TOK_UPVARS if the function's source body
 *                                   depends on outer names, else TOK_ARGSBODY
 *                                   if formal parameters, else TOK_LC node for
 *                                   function body statements
 *                          pn_cookie: static level and var index for function
 *                          pn_dflags: PND_* definition/use flags (see below)
 *                          pn_blockid: block id number
 * TOK_ARGSBODY list        list of formal parameters followed by TOK_LC node
 *                            for function body statements as final element
 *                          pn_count: 1 + number of formal parameters
 * TOK_UPVARS   nameset     pn_names: lexical dependencies (JSDefinitions)
 *                            defined in enclosing scopes, or ultimately not
 *                            defined (free variables, either global property
 *                            references or reference errors).
 *                          pn_tree: TOK_ARGSBODY or TOK_LC node
 *
 * &lt;Statements&gt;
 * TOK_LC       list        pn_head: list of pn_count statements
 * TOK_IF       ternary     pn_kid1: cond, pn_kid2: then, pn_kid3: else or null
 * TOK_SWITCH   binary      pn_left: discriminant
 *                          pn_right: list of TOK_CASE nodes, with at most one
 *                            TOK_DEFAULT node, or if there are let bindings
 *                            in the top level of the switch body's cases, a
 *                            TOK_LEXICALSCOPE node that contains the list of
 *                            TOK_CASE nodes.
 * TOK_CASE,    binary      pn_left: case expr or null if TOK_DEFAULT
 * TOK_DEFAULT              pn_right: TOK_LC node for this case's statements
 *                          pn_val: constant value if lookup or table switch
 * TOK_WHILE    binary      pn_left: cond, pn_right: body
 * TOK_DO       binary      pn_left: body, pn_right: cond
 * TOK_FOR      binary      pn_left: either
 *                            for/in loop: a binary TOK_IN node with
 *                              pn_left:  TOK_VAR or TOK_NAME to left of 'in'
 *                                if TOK_VAR, its pn_xflags may have PNX_POPVAR
 *                                and PNX_FORINVAR bits set
 *                              pn_right: object expr to right of 'in'
 *                            for(;;) loop: a ternary TOK_RESERVED node with
 *                              pn_kid1:  init expr before first ';'
 *                              pn_kid2:  cond expr before second ';'
 *                              pn_kid3:  update expr after second ';'
 *                              any kid may be null
 *                          pn_right: body
 * TOK_THROW    unary       pn_op: JSOP_THROW, pn_kid: exception
 * TOK_TRY      ternary     pn_kid1: try block
 *                          pn_kid2: null or TOK_RESERVED list of
 *                          TOK_LEXICALSCOPE nodes, each with pn_expr pointing
 *                          to a TOK_CATCH node
 *                          pn_kid3: null or finally block
 * TOK_CATCH    ternary     pn_kid1: TOK_NAME, TOK_RB, or TOK_RC catch var node
 *                                   (TOK_RB or TOK_RC if destructuring)
 *                          pn_kid2: null or the catch guard expression
 *                          pn_kid3: catch block statements
 * TOK_BREAK    name        pn_atom: label or null
 * TOK_CONTINUE name        pn_atom: label or null
 * TOK_WITH     binary      pn_left: head expr, pn_right: body
 * TOK_VAR      list        pn_head: list of TOK_NAME or TOK_ASSIGN nodes
 *                                   each name node has
 *                                     pn_used: false
 *                                     pn_atom: variable name
 *                                     pn_expr: initializer or null
 *                                   each assignment node has
 *                                     pn_left: TOK_NAME with pn_used true and
*                                               pn_lexdef (NOT pn_expr) set
 *                                     pn_right: initializer
 * TOK_RETURN   unary       pn_kid: return expr or null
 * TOK_SEMI     unary       pn_kid: expr or null statement
 * TOK_COLON    name        pn_atom: label, pn_expr: labeled statement
 *
 * &lt;Expressions&gt;
 * All left-associated binary trees of the same type are optimized into lists
 * to avoid recursion when processing expression chains.
 * TOK_COMMA    list        pn_head: list of pn_count comma-separated exprs
 * TOK_ASSIGN   binary      pn_left: lvalue, pn_right: rvalue
 *                          pn_op: JSOP_ADD for +=, etc.
 * TOK_HOOK     ternary     pn_kid1: cond, pn_kid2: then, pn_kid3: else
 * TOK_OR       binary      pn_left: first in || chain, pn_right: rest of chain
 * TOK_AND      binary      pn_left: first in &amp;&amp; chain, pn_right: rest of chain
 * TOK_BITOR    binary      pn_left: left-assoc | expr, pn_right: ^ expr
 * TOK_BITXOR   binary      pn_left: left-assoc ^ expr, pn_right: &amp; expr
 * TOK_BITAND   binary      pn_left: left-assoc &amp; expr, pn_right: EQ expr
 * TOK_EQOP     binary      pn_left: left-assoc EQ expr, pn_right: REL expr
 *                          pn_op: JSOP_EQ, JSOP_NE,
 *                                 JSOP_STRICTEQ, JSOP_STRICTNE
 * TOK_RELOP    binary      pn_left: left-assoc REL expr, pn_right: SH expr
 *                          pn_op: JSOP_LT, JSOP_LE, JSOP_GT, JSOP_GE
 * TOK_SHOP     binary      pn_left: left-assoc SH expr, pn_right: ADD expr
 *                          pn_op: JSOP_LSH, JSOP_RSH, JSOP_URSH
 * TOK_PLUS,    binary      pn_left: left-assoc ADD expr, pn_right: MUL expr
 *                          pn_xflags: if a left-associated binary TOK_PLUS
 *                            tree has been flattened into a list (see above
 *                            under &lt;Expressions&gt;), pn_xflags will contain
 *                            PNX_STRCAT if at least one list element is a
 *                            string literal (TOK_STRING); if such a list has
 *                            any non-string, non-number term, pn_xflags will
 *                            contain PNX_CANTFOLD.
 *                          pn_
 * TOK_MINUS                pn_op: JSOP_ADD, JSOP_SUB
 * TOK_STAR,    binary      pn_left: left-assoc MUL expr, pn_right: UNARY expr
 * TOK_DIVOP                pn_op: JSOP_MUL, JSOP_DIV, JSOP_MOD
 * TOK_UNARYOP  unary       pn_kid: UNARY expr, pn_op: JSOP_NEG, JSOP_POS,
 *                          JSOP_NOT, JSOP_BITNOT, JSOP_TYPEOF, JSOP_VOID
 * TOK_INC,     unary       pn_kid: MEMBER expr
 * TOK_DEC
 * TOK_NEW      list        pn_head: list of ctor, arg1, arg2, ... argN
 *                          pn_count: 1 + N (where N is number of args)
 *                          ctor is a MEMBER expr
 * TOK_DELETE   unary       pn_kid: MEMBER expr
 * TOK_DOT,     name        pn_expr: MEMBER expr to left of .
 * TOK_DBLDOT               pn_atom: name to right of .
 * TOK_LB       binary      pn_left: MEMBER expr to left of [
 *                          pn_right: expr between [ and ]
 * TOK_LP       list        pn_head: list of call, arg1, arg2, ... argN
 *                          pn_count: 1 + N (where N is number of args)
 *                          call is a MEMBER expr naming a callable object
 * TOK_RB       list        pn_head: list of pn_count array element exprs
 *                          [,,] holes are represented by TOK_COMMA nodes
 *                          pn_xflags: PN_ENDCOMMA if extra comma at end
 * TOK_RC       list        pn_head: list of pn_count binary TOK_COLON nodes
 * TOK_COLON    binary      key-value pair in object initializer or
 *                          destructuring lhs
 *                          pn_left: property id, pn_right: value
 *                          var {x} = object destructuring shorthand shares
 *                          PN_NAME node for x on left and right of TOK_COLON
 *                          node in TOK_RC's list, has PNX_DESTRUCT flag
 * TOK_DEFSHARP unary       pn_num: jsint value of n in #n=
 *                          pn_kid: primary function, paren, name, object or
 *                                  array literal expressions
 * TOK_USESHARP nullary     pn_num: jsint value of n in #n#
 * TOK_NAME,    name        pn_atom: name, string, or object atom
 * TOK_STRING,              pn_op: JSOP_NAME, JSOP_STRING, or JSOP_OBJECT, or
 *                                 JSOP_REGEXP
 * TOK_REGEXP               If JSOP_NAME, pn_op may be JSOP_*ARG or JSOP_*VAR
 *                          with pn_cookie telling (staticLevel, slot) (see
 *                          jsscript.h's UPVAR macros) and pn_dflags telling
 *                          const-ness and static analysis results
 * TOK_NAME     name        If pn_used, TOK_NAME uses the lexdef member instead
 *                          of the expr member it overlays
 * TOK_NUMBER   dval        pn_dval: double value of numeric literal
 * TOK_PRIMARY  nullary     pn_op: JSOp bytecode
 *
 * &lt;E4X node descriptions&gt;
 * TOK_ANYNAME  nullary     pn_op: JSOP_ANYNAME
 *                          pn_atom: cx-&gt;runtime-&gt;atomState.starAtom
 * TOK_AT       unary       pn_op: JSOP_TOATTRNAME; pn_kid attribute id/expr
 * TOK_DBLCOLON binary      pn_op: JSOP_QNAME
 *                          pn_left: TOK_ANYNAME or TOK_NAME node
 *                          pn_right: TOK_STRING "*" node, or expr within []
 *              name        pn_op: JSOP_QNAMECONST
 *                          pn_expr: TOK_ANYNAME or TOK_NAME left operand
 *                          pn_atom: name on right of ::
 * TOK_XMLELEM  list        XML element node
 *                          pn_head: start tag, content1, ... contentN, end tag
 *                          pn_count: 2 + N where N is number of content nodes
 *                                    N may be &gt; x.length() if {expr} embedded
 * TOK_XMLLIST  list        XML list node
 *                          pn_head: content1, ... contentN
 * TOK_XMLSTAGO, list       XML start, end, and point tag contents
 * TOK_XMLETAGC,            pn_head: tag name or {expr}, ... XML attrs ...
 * TOK_XMLPTAGO
 * TOK_XMLNAME  nullary     pn_atom: XML name, with no {expr} embedded
 * TOK_XMLNAME  list        pn_head: tag name or {expr}, ... name or {expr}
 * TOK_XMLATTR, nullary     pn_atom: attribute value string; pn_op: JSOP_STRING
 * TOK_XMLCDATA,
 * TOK_XMLCOMMENT
 * TOK_XMLPI    nullary     pn_atom: XML processing instruction target
 *                          pn_atom2: XML PI content, or null if no content
 * TOK_XMLTEXT  nullary     pn_atom: marked-up text, or null if empty string
 * TOK_LC       unary       {expr} in XML tag or content; pn_kid is expr
 *
 * So an XML tag with no {expr} and three attributes is a list with the form:
 *
 *    (tagname attrname1 attrvalue1 attrname2 attrvalue2 attrname2 attrvalue3)
 *
 * An XML tag with embedded expressions like so:
 *
 *    &lt;name1{expr1} name2{expr2}name3={expr3}&gt;
 *
 * would have the form:
 *
 *    ((name1 {expr1}) (name2 {expr2} name3) {expr3})
 *
 * where () bracket a list with elements separated by spaces, and {expr} is a
 * TOK_LC unary node with expr as its kid.
 *
 * Thus, the attribute name/value pairs occupy successive odd and even list
 * locations, where pn_head is the TOK_XMLNAME node at list location 0.  The
 * parser builds the same sort of structures for elements:
 *
 *    &lt;a x={x}&gt;Hi there!&lt;b y={y}&gt;How are you?&lt;/b&gt;&lt;answer&gt;{x + y}&lt;/answer&gt;&lt;/a&gt;
 *
 * translates to:
 *
 *    ((a x {x}) 'Hi there!' ((b y {y}) 'How are you?') ((answer) {x + y}))
 *
 * &lt;Non-E4X node descriptions, continued&gt;
 *
 * Label              Variant   Members
 * -----              -------   -------
 * TOK_LEXICALSCOPE   name      pn_op: JSOP_LEAVEBLOCK or JSOP_LEAVEBLOCKEXPR
 *                              pn_objbox: block object in JSObjectBox holder
 *                              pn_expr: block body
 * TOK_ARRAYCOMP      list      pn_head: list of pn_count (1 or 2) elements
 *                              if pn_count is 2, first element is #n=[...]
 *                                last element is block enclosing for loop(s)
 *                                and optionally if-guarded TOK_ARRAYPUSH
 * TOK_ARRAYPUSH      unary     pn_op: JSOP_ARRAYCOMP
 *                              pn_kid: array comprehension expression
 */</comment>
<typedef>typedef <type><enum>enum <name>JSParseNodeArity</name> <block>{
    <decl><name>PN_NULLARY</name></decl>,                         <comment type="block">/* 0 kids, only pn_atom/pn_dval/etc. */</comment>
    <decl><name>PN_UNARY</name></decl>,                           <comment type="block">/* one kid, plus a couple of scalars */</comment>
    <decl><name>PN_BINARY</name></decl>,                          <comment type="block">/* two kids, plus a couple of scalars */</comment>
    <decl><name>PN_TERNARY</name></decl>,                         <comment type="block">/* three kids */</comment>
    <decl><name>PN_FUNC</name></decl>,                            <comment type="block">/* function definition node */</comment>
    <decl><name>PN_LIST</name></decl>,                            <comment type="block">/* generic singly linked list */</comment>
    <decl><name>PN_NAME</name></decl>,                            <comment type="block">/* name use or definition node */</comment>
    <decl><name>PN_NAMESET</name></decl>                          <comment type="block">/* JSAtomList + JSParseNode ptr */</comment>
}</block></enum></type> <name>JSParseNodeArity</name>;</typedef>

<struct_decl>struct <name>JSDefinition</name>;</struct_decl>

<struct>struct <name>JSParseNode</name> <block>{
    <expr_stmt><expr><name>uint32</name>              <name>pn_type</name>:16</expr>,     <comment type="block">/* TOK_* type, see jsscan.h */</comment>
                        <expr><name>pn_op</name>:8</expr>,        <comment type="block">/* see JSOp enum and jsopcode.tbl */</comment>
                        <expr><name>pn_arity</name>:5</expr>,     <comment type="block">/* see JSParseNodeArity enum */</comment>
                        <expr><name>pn_parens</name>:1</expr>,    <comment type="block">/* this expr was enclosed in parens */</comment>
                        <expr><name>pn_used</name>:1</expr>,      <comment type="block">/* name node is on a use-chain */</comment>
                        <expr><name>pn_defn</name>:1</expr>;</expr_stmt>      <comment type="block">/* this node is a JSDefinition */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PN_OP</name><parameter_list>(<param><type><name>pn</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>((JSOp)(pn)-&gt;pn_op)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PN_TYPE</name><parameter_list>(<param><type><name>pn</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((JSTokenType)(pn)-&gt;pn_type)</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>JSTokenPos</name></type>          <name>pn_pos</name></decl>;</decl_stmt>         <comment type="block">/* two 16-bit pairs here, for 64 bits */</comment>
    <decl_stmt><decl><type><name>int32</name></type>               <name>pn_offset</name></decl>;</decl_stmt>      <comment type="block">/* first generated bytecode offset */</comment>
    <decl_stmt><decl><type><name>JSParseNode</name>         *</type><name>pn_next</name></decl>;</decl_stmt>       <comment type="block">/* intrinsic link in parent PN_LIST */</comment>
    <decl_stmt><decl><type><name>JSParseNode</name>         *</type><name>pn_link</name></decl>;</decl_stmt>       <comment type="block">/* def/use link (alignment freebie);
                                           also links JSFunctionBox::methods
                                           lists of would-be |this| methods */</comment>
    <union>union <block>{
        <struct>struct <block>{                        <comment type="block">/* list of next-linked nodes */</comment>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>head</name></decl>;</decl_stmt>          <comment type="block">/* first node in list */</comment>
            <decl_stmt><decl><type><name>JSParseNode</name> **</type><name>tail</name></decl>;</decl_stmt>         <comment type="block">/* ptr to ptr to last node in list */</comment>
            <decl_stmt><decl><type><name>uint32</name></type>      <name>count</name></decl>;</decl_stmt>          <comment type="block">/* number of nodes in list */</comment>
            <expr_stmt><expr><name>uint32</name>      <name>xflags</name>:12</expr>,      <comment type="block">/* extra flags, see below */</comment>
                        <expr><name>blockid</name>:20</expr>;</expr_stmt>     <comment type="block">/* see name variant below */</comment>
        }</block> <decl><name>list</name></decl>;</struct>
        <struct>struct <block>{                        <comment type="block">/* ternary: if, for(;;), ?: */</comment>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>kid1</name></decl>;</decl_stmt>          <comment type="block">/* condition, discriminant, etc. */</comment>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>kid2</name></decl>;</decl_stmt>          <comment type="block">/* then-part, case list, etc. */</comment>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>kid3</name></decl>;</decl_stmt>          <comment type="block">/* else-part, default case, etc. */</comment>
        }</block> <decl><name>ternary</name></decl>;</struct>
        <struct>struct <block>{                        <comment type="block">/* two kids if binary */</comment>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>left</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>right</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jsval</name></type>       <name>val</name></decl>;</decl_stmt>            <comment type="block">/* switch case value */</comment>
            <decl_stmt><decl><type><name>uintN</name></type>       <name>iflags</name></decl>;</decl_stmt>         <comment type="block">/* JSITER_* flags for TOK_FOR node */</comment>
        }</block> <decl><name>binary</name></decl>;</struct>
        <struct>struct <block>{                        <comment type="block">/* one kid if unary */</comment>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>kid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jsint</name></type>       <name>num</name></decl>;</decl_stmt>            <comment type="block">/* -1 or sharp variable number */</comment>
            <decl_stmt><decl><type><name>JSBool</name></type>      <name>hidden</name></decl>;</decl_stmt>         <comment type="block">/* hidden genexp-induced JSOP_YIELD */</comment>
        }</block> <decl><name>unary</name></decl>;</struct>
        <struct>struct <block>{                        <comment type="block">/* name, labeled statement, etc. */</comment>
            <union>union <block>{
                <decl_stmt><decl><type><name>JSAtom</name>        *</type><name>atom</name></decl>;</decl_stmt>    <comment type="block">/* lexical name or label atom */</comment>
                <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name></decl>;</decl_stmt>  <comment type="block">/* function object */</comment>
                <decl_stmt><decl><type><name>JSObjectBox</name>   *</type><name>objbox</name></decl>;</decl_stmt>  <comment type="block">/* block or regexp object */</comment>
            }</block>;</union>
            <union>union <block>{
                <decl_stmt><decl><type><name>JSParseNode</name>  *</type><name>expr</name></decl>;</decl_stmt>     <comment type="block">/* function body, var initializer, or
                                           base object of TOK_DOT */</comment>
                <decl_stmt><decl><type><name>JSDefinition</name> *</type><name>lexdef</name></decl>;</decl_stmt>   <comment type="block">/* lexical definition for this use */</comment>
            }</block>;</union>
            <decl_stmt><decl><type><name>uint32</name></type>      <name>cookie</name></decl>;</decl_stmt>         <comment type="block">/* upvar cookie with absolute frame
                                           level (not relative skip), possibly
                                           in current frame */</comment>
            <expr_stmt><expr><name>uint32</name>      <name>dflags</name>:12</expr>,      <comment type="block">/* definition/use flags, see below */</comment>
                        <expr><name>blockid</name>:20</expr>;</expr_stmt>     <comment type="block">/* block number, for subset dominance
                                           computation */</comment>
        }</block> <decl><name>name</name></decl>;</struct>
        <struct>struct <block>{                        <comment type="block">/* lexical dependencies + sub-tree */</comment>
            <decl_stmt><decl><type><name>JSAtomSet</name></type>   <name>names</name></decl>;</decl_stmt>          <comment type="block">/* set of names with JSDefinitions */</comment>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>tree</name></decl>;</decl_stmt>          <comment type="block">/* sub-tree containing name uses */</comment>
        }</block> <decl><name>nameset</name></decl>;</struct>
        <struct>struct <block>{                        <comment type="block">/* PN_NULLARY variant for E4X */</comment>
            <decl_stmt><decl><type><name>JSAtom</name>      *</type><name>atom</name></decl>;</decl_stmt>          <comment type="block">/* first atom in pair */</comment>
            <decl_stmt><decl><type><name>JSAtom</name>      *</type><name>atom2</name></decl>;</decl_stmt>         <comment type="block">/* second atom in pair or null */</comment>
        }</block> <decl><name>apair</name></decl>;</struct>
        <decl_stmt><decl><type><name>jsdouble</name></type>        <name>dval</name></decl>;</decl_stmt>           <comment type="block">/* aligned numeric literal value */</comment>
    }</block> <decl><name>pn_u</name></decl>;</union>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_funbox</name></cpp:macro>       <cpp:value>pn_u.name.funbox</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_body</name></cpp:macro>         <cpp:value>pn_u.name.expr</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_cookie</name></cpp:macro>       <cpp:value>pn_u.name.cookie</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_dflags</name></cpp:macro>       <cpp:value>pn_u.name.dflags</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_blockid</name></cpp:macro>      <cpp:value>pn_u.name.blockid</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_index</name></cpp:macro>        <cpp:value>pn_u.name.blockid</cpp:value></cpp:define> <comment type="block">/* reuse as object table index */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_head</name></cpp:macro>         <cpp:value>pn_u.list.head</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_tail</name></cpp:macro>         <cpp:value>pn_u.list.tail</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_count</name></cpp:macro>        <cpp:value>pn_u.list.count</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_xflags</name></cpp:macro>       <cpp:value>pn_u.list.xflags</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_kid1</name></cpp:macro>         <cpp:value>pn_u.ternary.kid1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_kid2</name></cpp:macro>         <cpp:value>pn_u.ternary.kid2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_kid3</name></cpp:macro>         <cpp:value>pn_u.ternary.kid3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_left</name></cpp:macro>         <cpp:value>pn_u.binary.left</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_right</name></cpp:macro>        <cpp:value>pn_u.binary.right</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_val</name></cpp:macro>          <cpp:value>pn_u.binary.val</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_iflags</name></cpp:macro>       <cpp:value>pn_u.binary.iflags</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_kid</name></cpp:macro>          <cpp:value>pn_u.unary.kid</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_num</name></cpp:macro>          <cpp:value>pn_u.unary.num</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_hidden</name></cpp:macro>       <cpp:value>pn_u.unary.hidden</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_atom</name></cpp:macro>         <cpp:value>pn_u.name.atom</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_objbox</name></cpp:macro>       <cpp:value>pn_u.name.objbox</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_expr</name></cpp:macro>         <cpp:value>pn_u.name.expr</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_lexdef</name></cpp:macro>       <cpp:value>pn_u.name.lexdef</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_names</name></cpp:macro>        <cpp:value>pn_u.nameset.names</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_tree</name></cpp:macro>         <cpp:value>pn_u.nameset.tree</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_dval</name></cpp:macro>         <cpp:value>pn_u.dval</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pn_atom2</name></cpp:macro>        <cpp:value>pn_u.apair.atom2</cpp:value></cpp:define>

<label><name>protected</name>:</label>
    <function><type><name>void</name> <specifier>inline</specifier></type> <name>init</name><parameter_list>(<param><decl><type><name>JSTokenType</name></type> <name>type</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>JSParseNodeArity</name></type> <name>arity</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>pn_type</name> = <name>type</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_op</name> = <name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_arity</name> = <name>arity</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_parens</name> = <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>pn_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>pn_defn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_next</name> = <name>pn_link</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></function>

    <function_decl><type><specifier>static</specifier> <name>JSParseNode</name> *</type><name>create</name><parameter_list>(<param><decl><type><name>JSParseNodeArity</name></type> <name>arity</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
    <function_decl><type><specifier>static</specifier> <name>JSParseNode</name> *</type><name>newBinaryOrAppend</name><parameter_list>(<param><decl><type><name>JSTokenType</name></type> <name>tt</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>left</name></decl></param>,
                                          <param><decl><type><name>JSParseNode</name> *</type><name>right</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
     * The pn_expr and lexdef members are arms of an unsafe union. Unless you
     * know exactly what you're doing, use only the following methods to access
     * them. For less overhead and assertions for protection, use pn-&gt;expr()
     * and pn-&gt;lexdef(). Otherwise, use pn-&gt;maybeExpr() and pn-&gt;maybeLexDef().
     */</comment>
    <expr_stmt><expr><name>JSParseNode</name>  *<macro><name>expr</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>pn_used</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_arity</name> == <name>PN_NAME</name> || <name>pn_arity</name> == <name>PN_FUNC</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>pn_expr</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>JSDefinition</name> *<macro><name>lexdef</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_used</name> || <call><name>isDeoptimized</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_arity</name> == <name>PN_NAME</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>pn_lexdef</name></expr>;</return>
    }</block></expr></expr_stmt>

    <function><type><name>JSParseNode</name>  *</type><name>maybeExpr</name><parameter_list>()</parameter_list>   <block>{ <return>return <expr><name>pn_used</name> ? <name>NULL</name> : <call><name>expr</name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
    <function><type><name>JSDefinition</name> *</type><name>maybeLexDef</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>pn_used</name> ? <call><name>lexdef</name><argument_list>()</argument_list></call> : <name>NULL</name></expr>;</return> }</block></function>

<comment type="block">/* PN_FUNC and PN_NAME pn_dflags bits. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_LET</name></cpp:macro>         <cpp:value>0x01</cpp:value></cpp:define>            <comment type="block">/* let (block-scoped) binding */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_CONST</name></cpp:macro>       <cpp:value>0x02</cpp:value></cpp:define>            <comment type="block">/* const binding (orthogonal to let) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_INITIALIZED</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>            <comment type="block">/* initialized declaration */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_ASSIGNED</name></cpp:macro>    <cpp:value>0x08</cpp:value></cpp:define>            <comment type="block">/* set if ever LHS of assignment */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_TOPLEVEL</name></cpp:macro>    <cpp:value>0x10</cpp:value></cpp:define>            <comment type="block">/* function at top of body or prog */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_BLOCKCHILD</name></cpp:macro>  <cpp:value>0x20</cpp:value></cpp:define>            <comment type="block">/* use or def is direct block child */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_GVAR</name></cpp:macro>        <cpp:value>0x40</cpp:value></cpp:define>            <comment type="block">/* gvar binding, can't close over
                                           because it could be deleted */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_PLACEHOLDER</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define>            <comment type="block">/* placeholder definition for lexdep */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_FUNARG</name></cpp:macro>     <cpp:value>0x100</cpp:value></cpp:define>            <comment type="block">/* downward or upward funarg usage */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_BOUND</name></cpp:macro>      <cpp:value>0x200</cpp:value></cpp:define>            <comment type="block">/* bound to a stack or global slot */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_DEOPTIMIZED</name></cpp:macro> <cpp:value>0x400</cpp:value></cpp:define>           <comment type="block">/* former pn_used name node, pn_lexdef
                                           still valid, but this use no longer
                                           optimizable via an upvar opcode */</comment>

<comment type="block">/* Flags to propagate from uses to definition. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PND_USE2DEF_FLAGS</name></cpp:macro> <cpp:value>(PND_ASSIGNED | PND_FUNARG)</cpp:value></cpp:define>

<comment type="block">/* PN_LIST pn_xflags bits. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_STRCAT</name></cpp:macro>      <cpp:value>0x01</cpp:value></cpp:define>            <comment type="block">/* TOK_PLUS list has string term */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_CANTFOLD</name></cpp:macro>    <cpp:value>0x02</cpp:value></cpp:define>            <comment type="block">/* TOK_PLUS list has unfoldable term */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_POPVAR</name></cpp:macro>      <cpp:value>0x04</cpp:value></cpp:define>            <comment type="block">/* TOK_VAR last result needs popping */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_FORINVAR</name></cpp:macro>    <cpp:value>0x08</cpp:value></cpp:define>            <comment type="block">/* TOK_VAR is left kid of TOK_IN node,
                                           which is left kid of TOK_FOR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_ENDCOMMA</name></cpp:macro>    <cpp:value>0x10</cpp:value></cpp:define>            <comment type="block">/* array literal has comma at end */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_XMLROOT</name></cpp:macro>     <cpp:value>0x20</cpp:value></cpp:define>            <comment type="block">/* top-most node in XML literal tree */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_GROUPINIT</name></cpp:macro>   <cpp:value>0x40</cpp:value></cpp:define>            <comment type="block">/* var [a, b] = [c, d]; unit list */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_NEEDBRACES</name></cpp:macro>  <cpp:value>0x80</cpp:value></cpp:define>            <comment type="block">/* braces necessary due to closure */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_FUNCDEFS</name></cpp:macro>   <cpp:value>0x100</cpp:value></cpp:define>            <comment type="block">/* contains top-level function
                                           statements */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_DESTRUCT</name></cpp:macro>   <cpp:value>0x200</cpp:value></cpp:define>            <comment type="block">/* destructuring special cases:
                                           1. shorthand syntax used, at present
                                              object destructuring ({x,y}) only;
                                           2. the first child of function body
                                              is code evaluating destructuring
                                              arguments */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PNX_HOLEY</name></cpp:macro>      <cpp:value>0x400</cpp:value></cpp:define>            <comment type="block">/* array initialiser has holes */</comment>

    <expr_stmt><expr><name>uintN</name> <macro><name>frameLevel</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_arity</name> == <name>PN_FUNC</name> || <name>pn_arity</name> == <name>PN_NAME</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><call><name>UPVAR_FRAME_SKIP</name><argument_list>(<argument><expr><name>pn_cookie</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr><name>uintN</name> <macro><name>frameSlot</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_arity</name> == <name>PN_FUNC</name> || <name>pn_arity</name> == <name>PN_NAME</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><call><name>UPVAR_FRAME_SLOT</name><argument_list>(<argument><expr><name>pn_cookie</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <decl_stmt><decl><type><specifier>inline</specifier> <name>bool</name></type> <name>test</name><argument_list>(<argument><expr><name>uintN</name> <name>flag</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

    <expr_stmt><expr><name>bool</name> <macro><name>isLet</name><argument_list>()</argument_list></macro> const          <block>{ <return>return <expr><call><name>test</name><argument_list>(<argument><expr><name>PND_LET</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <expr_stmt><expr><name>bool</name> <macro><name>isConst</name><argument_list>()</argument_list></macro> const        <block>{ <return>return <expr><call><name>test</name><argument_list>(<argument><expr><name>PND_CONST</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <expr_stmt><expr><name>bool</name> <macro><name>isInitialized</name><argument_list>()</argument_list></macro> const  <block>{ <return>return <expr><call><name>test</name><argument_list>(<argument><expr><name>PND_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <expr_stmt><expr><name>bool</name> <macro><name>isTopLevel</name><argument_list>()</argument_list></macro> const     <block>{ <return>return <expr><call><name>test</name><argument_list>(<argument><expr><name>PND_TOPLEVEL</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <expr_stmt><expr><name>bool</name> <macro><name>isBlockChild</name><argument_list>()</argument_list></macro> const   <block>{ <return>return <expr><call><name>test</name><argument_list>(<argument><expr><name>PND_BLOCKCHILD</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <expr_stmt><expr><name>bool</name> <macro><name>isPlaceholder</name><argument_list>()</argument_list></macro> const  <block>{ <return>return <expr><call><name>test</name><argument_list>(<argument><expr><name>PND_PLACEHOLDER</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <expr_stmt><expr><name>bool</name> <macro><name>isDeoptimized</name><argument_list>()</argument_list></macro> const  <block>{ <return>return <expr><call><name>test</name><argument_list>(<argument><expr><name>PND_DEOPTIMIZED</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <expr_stmt><expr><name>bool</name> <macro><name>isAssigned</name><argument_list>()</argument_list></macro> const     <block>{ <return>return <expr><call><name>test</name><argument_list>(<argument><expr><name>PND_ASSIGNED</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
    <expr_stmt><expr><name>bool</name> <macro><name>isFunArg</name><argument_list>()</argument_list></macro> const       <block>{ <return>return <expr><call><name>test</name><argument_list>(<argument><expr><name>PND_FUNARG</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

    <comment type="block">/* Defined below, see after struct JSDefinition. */</comment>
    <function_decl><type><name>void</name></type> <name>setFunArg</name><parameter_list>()</parameter_list>;</function_decl>

    <function_decl><type><name>void</name></type> <name>become</name><parameter_list>(<param><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list>;</function_decl>

    <comment type="block">/* True if pn is a parsenode representing a literal constant. */</comment>
    <expr_stmt><expr><name>bool</name> <macro><name>isLiteral</name><argument_list>()</argument_list></macro> const <block>{
        <return>return <expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> == <name>TOK_NUMBER</name> ||
               <call><name>PN_TYPE</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> == <name>TOK_STRING</name> ||
               (<call><name>PN_TYPE</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> == <name>TOK_PRIMARY</name> &amp;&amp; <call><name>PN_OP</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> != <name>JSOP_THIS</name>)</expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="block">/*
     * True if this statement node could be a member of a Directive
     * Prologue.  Note that the prologue may contain strings that
     * cannot themselves be directives; that's a stricter test.
     * If Statement begins to simplify trees into this form, then
     * we'll need additional flags that we can test here.
     */</comment>
    <expr_stmt><expr><name>bool</name> <macro><name>isDirectivePrologueMember</name><argument_list>()</argument_list></macro> const <block>{
        <if>if <condition>(<expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> == <name>TOK_SEMI</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_arity</name> == <name>PN_UNARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>kid</name> <init>= <expr><name>pn_kid</name></expr></init></decl>;</decl_stmt>
            <return>return <expr><name>kid</name> &amp;&amp; <call><name>PN_TYPE</name><argument_list>(<argument><expr><name>kid</name></expr></argument>)</argument_list></call> == <name>TOK_STRING</name> &amp;&amp; !<name><name>kid</name>-&gt;<name>pn_parens</name></name></expr>;</return>
        <expr_stmt/></block></then></if>}</block></expr></expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    }</block>

    <comment type="block">/*
     * True if this node, known to be a Directive Prologue member,
     * could be a directive itself.
     */</comment>
    <decl><name>bool</name> <name>isDirective</name><argument_list>()</argument_list> const <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isDirectivePrologueMember</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>kid</name> <init>= <expr><name>pn_kid</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>kid</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Directives must contain no EscapeSequences or LineContinuations.
         * If the string's length in the source code is its length as a value,
         * accounting for the quotes, then it qualifies.
         */</comment>
        <return>return <expr>(<name><name>pn_pos</name>.<name>begin</name>.<name>lineno</name></name> == <name><name>pn_pos</name>.<name>end</name>.<name>lineno</name></name> &amp;&amp;
                <name><name>pn_pos</name>.<name>begin</name>.<name>index</name></name> + <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> + 2 == <name><name>pn_pos</name>.<name>end</name>.<name>index</name></name>)</expr>;</return>
    }</block></decl>

    <comment type="block">/*
     * Compute a pointer to the last element in a singly-linked list. NB: list
     * must be non-empty for correct PN_LAST usage -- this is asserted!
     */</comment>
    <decl><name>JSParseNode</name> *<name>last</name><argument_list>()</argument_list> const <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_arity</name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_count</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call>(<name>JSParseNode</name> *)<argument_list>(<argument><expr>(<name>char</name> *)<name>pn_tail</name> - <call><name>offsetof</name><argument_list>(<argument><expr><name>JSParseNode</name></expr></argument>, <argument><expr><name>pn_next</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></decl>

    <decl><name>void</name> <name>makeEmpty</name><argument_list>()</argument_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_arity</name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_head</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_tail</name> = &amp;<name>pn_head</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_count</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_xflags</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_blockid</name> = 0</expr>;</expr_stmt>
    }</block></decl>

    <decl><name>void</name> <name>initList</name><argument_list>(<argument><expr><name>JSParseNode</name> *<name>pn</name></expr></argument>)</argument_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_arity</name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_head</name> = <name>pn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_tail</name> = &amp;<name><name>pn</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_count</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_xflags</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_blockid</name> = 0</expr>;</expr_stmt>
    }</block></decl>

    <decl><name>void</name> <name>append</name><argument_list>(<argument><expr><name>JSParseNode</name> *<name>pn</name></expr></argument>)</argument_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_arity</name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>pn_tail</name> = <name>pn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_tail</name> = &amp;<name><name>pn</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn_count</name>++</expr>;</expr_stmt>
    }</block></decl>
<decl/></struct>};

<decl_stmt><decl><type><name>namespace</name></type> <name>js</name> <block>{

struct <label><name>NullaryNode</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSParseNode</name> <block>{
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>NullaryNode</name> *</type><name>create</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>NullaryNode</name> *)<name>JSParseNode</name>::<call><name>create</name><argument_list>(<argument><expr><name>PN_NULLARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

struct <label><name>UnaryNode</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSParseNode</name> <block>{
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>UnaryNode</name> *</type><name>create</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>UnaryNode</name> *)<name>JSParseNode</name>::<call><name>create</name><argument_list>(<argument><expr><name>PN_UNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

struct <label><name>BinaryNode</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSParseNode</name> <block>{
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>BinaryNode</name> *</type><name>create</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>BinaryNode</name> *)<name>JSParseNode</name>::<call><name>create</name><argument_list>(<argument><expr><name>PN_BINARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

struct <label><name>TernaryNode</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSParseNode</name> <block>{
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>TernaryNode</name> *</type><name>create</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>TernaryNode</name> *)<name>JSParseNode</name>::<call><name>create</name><argument_list>(<argument><expr><name>PN_TERNARY</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

struct <label><name>ListNode</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSParseNode</name> <block>{
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ListNode</name> *</type><name>create</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>ListNode</name> *)<name>JSParseNode</name>::<call><name>create</name><argument_list>(<argument><expr><name>PN_LIST</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

struct <label><name>FunctionNode</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSParseNode</name> <block>{
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>FunctionNode</name> *</type><name>create</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>FunctionNode</name> *)<name>JSParseNode</name>::<call><name>create</name><argument_list>(<argument><expr><name>PN_FUNC</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

struct <label><name>NameNode</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSParseNode</name> <block>{
    <function_decl><type><specifier>static</specifier> <name>NameNode</name> *</type><name>create</name><parameter_list>(<param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>void</name> <specifier>inline</specifier></type> <name>initCommon</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>;</function_decl>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

struct <label><name>NameSetNode</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSParseNode</name> <block>{
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>NameSetNode</name> *</type><name>create</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>NameSetNode</name> *)<name>JSParseNode</name>::<call><name>create</name><argument_list>(<argument><expr><name>PN_NAMESET</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

struct <label><name>LexicalScopeNode</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSParseNode</name> <block>{
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>LexicalScopeNode</name> *</type><name>create</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>LexicalScopeNode</name> *)<name>JSParseNode</name>::<call><name>create</name><argument_list>(<argument><expr><name>PN_NAME</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}</block></decl></decl_stmt> <comment type="block">/* namespace js */</comment>

<comment type="block">/*
 * JSDefinition is a degenerate subtype of the PN_FUNC and PN_NAME variants of
 * JSParseNode, allocated only for function, var, const, and let declarations
 * that define truly lexical bindings. This means that a child of a TOK_VAR
 * list may be a JSDefinition instead of a JSParseNode. The pn_defn bit is set
 * for all JSDefinitions, clear otherwise.
 *
 * Note that not all var declarations are definitions: JS allows multiple var
 * declarations in a function or script, but only the first creates the hoisted
 * binding. JS programmers do redeclare variables for good refactoring reasons,
 * for example:
 *
 *   function foo() {
 *       ...
 *       for (var i ...) ...;
 *       ...
 *       for (var i ...) ...;
 *       ...
 *   }
 *
 * Not all definitions bind lexical variables, alas. In global and eval code
 * var may re-declare a pre-existing property having any attributes, with or
 * without JSPROP_PERMANENT. In eval code, indeed, ECMA-262 Editions 1 through
 * 3 require function and var to bind deletable bindings. Global vars thus are
 * properties of the global object, so they can be aliased even if they can't
 * be deleted.
 *
 * Only bindings within function code may be treated as lexical, of course with
 * the caveat that hoisting means use before initialization is allowed. We deal
 * with use before declaration in one pass as follows (error checking elided):
 *
 *   for (each use of unqualified name x in parse order) {
 *       if (this use of x is a declaration) {
 *           if (x in tc-&gt;decls) {                          // redeclaring
 *               pn = allocate a PN_NAME JSParseNode;
 *           } else {                                       // defining
 *               dn = lookup x in tc-&gt;lexdeps;
 *               if (dn)                                    // use before def
 *                   remove x from tc-&gt;lexdeps;
 *               else                                       // def before use
 *                   dn = allocate a PN_NAME JSDefinition;
 *               map x to dn via tc-&gt;decls;
 *               pn = dn;
 *           }
 *           insert pn into its parent TOK_VAR list;
 *       } else {
 *           pn = allocate a JSParseNode for this reference to x;
 *           dn = lookup x in tc's lexical scope chain;
 *           if (!dn) {
 *               dn = lookup x in tc-&gt;lexdeps;
 *               if (!dn) {
 *                   dn = pre-allocate a JSDefinition for x;
 *                   map x to dn in tc-&gt;lexdeps;
 *               }
 *           }
 *           append pn to dn's use chain;
 *       }
 *   }
 *
 * See jsemit.h for JSTreeContext and its top*Stmt, decls, and lexdeps members.
 *
 * Notes:
 *
 *  0. To avoid bloating JSParseNode, we steal a bit from pn_arity for pn_defn
 *     and set it on a JSParseNode instead of allocating a JSDefinition.
 *
 *  1. Due to hoisting, a definition cannot be eliminated even if its "Variable
 *     statement" (ECMA-262 12.2) can be proven to be dead code. RecycleTree in
 *     jsparse.cpp will not recycle a node whose pn_defn bit is set.
 *
 *  2. "lookup x in tc's lexical scope chain" gives up on def/use chaining if a
 *     with statement is found along the the scope chain, which includes tc,
 *     tc-&gt;parent, etc. Thus we eagerly connect an inner function's use of an
 *     outer's var x if the var x was parsed before the inner function.
 *
 *  3. A use may be eliminated as dead by the constant folder, which therefore
 *     must remove the dead name node from its singly-linked use chain, which
 *     would mean hashing to find the definition node and searching to update
 *     the pn_link pointing at the use to be removed. This is costly, so as for
 *     dead definitions, we do not recycle dead pn_used nodes.
 *
 * At the end of parsing a function body or global or eval program, tc-&gt;lexdeps
 * holds the lexical dependencies of the parsed unit. The name to def/use chain
 * mappings are then merged into the parent tc-&gt;lexdeps.
 *
 * Thus if a later var x is parsed in the outer function satisfying an earlier
 * inner function's use of x, we will remove dn from tc-&gt;lexdeps and re-use it
 * as the new definition node in the outer function's parse tree.
 *
 * When the compiler unwinds from the outermost tc, tc-&gt;lexdeps contains the
 * definition nodes with use chains for all free variables. These are either
 * global variables or reference errors.
 *
 * We analyze whether a binding is initialized, whether the bound names is ever
 * assigned apart from its initializer, and if the bound name definition or use
 * is in a direct child of a block. These PND_* flags allow a subset dominance
 * computation telling whether an initialized var dominates its uses. An inner
 * function using only such outer vars (and formal parameters) can be optimized
 * into a flat closure. See JSOP_{GET,CALL}DSLOT.
 *
 * Another important subset dominance relation: ... { var x = ...; ... x ... }
 * where x is not assigned after initialization and not used outside the block.
 * This style is common in the absence of 'let'. Even though the var x is not
 * at top level, we can tell its initialization dominates all uses cheaply,
 * because the above one-pass algorithm sees the definition before any uses,
 * and because all uses are contained in the same block as the definition.
 *
 * We also analyze function uses to flag upward/downward funargs, optimizing
 * Algol-like (not passed as funargs, only ever called) lightweight functions
 * using cx-&gt;display. See JSOP_{GET,CALL}UPVAR.
 *
 * This means that closure optimizations may be frustrated by with, eval, or
 * assignment to an outer var. Such hard cases require heavyweight functions
 * and JSOP_NAME, etc.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dn_uses</name></cpp:macro>         <cpp:value>pn_link</cpp:value></cpp:define>

struct <label><name>JSDefinition</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSParseNode</name>
<block>{
    <comment type="block">/*
     * We store definition pointers in PN_NAMESET JSAtomLists in the AST, but
     * due to redefinition these nodes may become uses of other definitions.
     * This is unusual, so we simply chase the pn_lexdef link to find the final
     * definition node. See methods called from JSCompiler::analyzeFunctions.
     *
     * FIXME: MakeAssignment mutates for want of a parent link...
     */</comment>
    <function><type><name>JSDefinition</name> *</type><name>resolve</name><parameter_list>()</parameter_list> <block>{
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr><name>this</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_defn</name></name></expr>)</condition> <block>{
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>pn</name> = <call><name><name>pn</name>-&gt;<name>lexdef</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr>(<name>JSDefinition</name> *) <name>pn</name></expr>;</return>
    }</block></function>

    <expr_stmt><expr><name>bool</name> <macro><name>isFreeVar</name><argument_list>()</argument_list></macro> const <block>{
        <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_defn</name></expr></argument>)</argument_list></call></expr>;
        <return>return <expr><name>pn_cookie</name> == <name>FREE_UPVAR_COOKIE</name> || <call><name>test</name><argument_list>(<argument><expr><name>PND_GVAR</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></expr></expr_stmt>

    <comment type="line">// Grr, windows.h or something under it #defines CONST...</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CONST</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>CONST</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <enum>enum <name>Kind</name> <block>{ <decl><name>VAR</name></decl>, <decl><name>CONST</name></decl>, <decl><name>LET</name></decl>, <decl><name>FUNCTION</name></decl>, <decl><name>ARG</name></decl>, <decl><name>UNKNOWN</name></decl> }</block>;</enum>

    <function><type><name>bool</name></type> <name>isBindingForm</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name>int</name><argument_list>(<argument><expr><call><name>kind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> &lt;= <call><name>int</name><argument_list>(<argument><expr><name>LET</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

    <function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>kindString</name><parameter_list>(<param><decl><type><name>Kind</name></type> <name>kind</name></decl></param>)</parameter_list>;</function_decl>

    <function><type><name>Kind</name></type> <name>kind</name><parameter_list>()</parameter_list> <block>{
        <if>if <condition>(<expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> == <name>TOK_FUNCTION</name></expr>)</condition><then>
            <return>return <expr><name>FUNCTION</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>PN_TYPE</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> == <name>JSOP_NOP</name></expr>)</condition><then>
            <return>return <expr><name>UNKNOWN</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> == <name>JSOP_GETARG</name></expr>)</condition><then>
            <return>return <expr><name>ARG</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>isConst</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>CONST</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>isLet</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>LET</name></expr>;</return></then></if>
        <return>return <expr><name>VAR</name></expr>;</return>
    }</block></function>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr>inline <name>bool</name>
<name>JSParseNode</name>::<macro><name>test</name><argument_list>(<argument>uintN flag</argument>)</argument_list></macro> const
<block>{
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn_defn</name> || <name>pn_arity</name> == <name>PN_FUNC</name> || <name>pn_arity</name> == <name>PN_NAME</name></expr></argument>)</argument_list></call></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if>if <condition>(<expr>(<name>flag</name> &amp; (<name>PND_ASSIGNED</name> | <name>PND_FUNARG</name>)) &amp;&amp; <name>pn_defn</name> &amp;&amp; !(<name>pn_dflags</name> &amp; <name>flag</name>)</expr>)</condition><then> <block>{
        <for>for (<init><decl><type><name>JSParseNode</name> *</type><name>pn</name> <init>= <expr>((<name>JSDefinition</name> *) <name>this</name>)-&gt;<name>dn_uses</name></expr></init></decl>;</init> <condition><expr><name>pn</name></expr>;</condition> <incr><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_link</name></name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn</name>-&gt;<name>pn_defn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!(<name><name>pn</name>-&gt;<name>pn_dflags</name></name> &amp; <name>flag</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/></block></for></block></then></if>}</block></expr></expr_stmt>
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    return <expr_stmt><expr>!!(<name>pn_dflags</name> &amp; <name>flag</name>)</expr>;</expr_stmt>
}

inline <expr_stmt><expr><name>void</name>
<name>JSParseNode</name>::<macro><name>setFunArg</name><argument_list>()</argument_list></macro>
<block>{
    <comment type="block">/*
     * pn_defn NAND pn_used must be true, per this chart:
     *
     *   pn_defn pn_used
     *         0       0        anonymous function used implicitly, e.g. by
     *                          hidden yield in a genexp
     *         0       1        a use of a definition or placeholder
     *         1       0        a definition or placeholder
     *         1       1        error: this case must not be possible
     */</comment>
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!(<name>pn_defn</name> &amp; <name>pn_used</name>)</expr></argument>)</argument_list></call></expr>;
    <if>if <condition>(<expr><name>pn_used</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>pn_lexdef</name>-&gt;<name>pn_dflags</name></name> |= <name>PND_FUNARG</name></expr>;</expr_stmt></then></if>
    <name>pn_dflags</name> |= <name>PND_FUNARG</name></block></expr>;</expr_stmt>
}

struct <macro><name>JSObjectBox</name></macro> <block>{
    <decl_stmt><decl><type><name>JSObjectBox</name>         *</type><name>traceLink</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObjectBox</name>         *</type><name>emitLink</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>object</name></decl>;</decl_stmt>
}</block><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSFB_LEVEL_BITS</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>

struct <label><name>JSFunctionBox</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>JSObjectBox</name>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name>         *</type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunctionBox</name>       *</type><name>siblings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunctionBox</name>       *</type><name>kids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunctionBox</name>       *</type><name>parent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name>         *</type><name>methods</name></decl>;</decl_stmt>               <comment type="block">/* would-be methods set on this;
                                                   these nodes are linked via
                                                   pn_link, since lambdas are
                                                   neither definitions nor uses
                                                   of a binding */</comment>
    <expr_stmt><expr><name>uint32</name>              <name>queued</name>:1</expr>,
                        <expr><name>inLoop</name>:1</expr>,               <comment type="block">/* in a loop in parent function */</comment>
                        <expr><name>level</name>:<name>JSFB_LEVEL_BITS</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>tcflags</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bool</name> <macro><name>joinable</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>

    <comment type="block">/*
     * Unbrand an object being initialized or constructed if any method cannot
     * be joined to one compiler-created null closure shared among N different
     * closure environments.
     *
     * We despecialize from caching function objects, caching slots or sprops
     * instead, because an unbranded object may still have joined methods (for
     * which sprop-&gt;isMethod), since js_FillPropertyCache gives precedence to
     * joined methods over branded methods.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>shouldUnbrand</name><argument_list>(<argument><expr><name>uintN</name> <name>methods</name></expr></argument>, <argument><expr><name>uintN</name> <name>slowMethods</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<struct>struct <name>JSFunctionBoxQueue</name> <block>{
    <decl_stmt><decl><type><name>JSFunctionBox</name>       **</type><name>vector</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>head</name></decl>, <decl><type ref="prev"/><name>tail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>lengthMask</name></decl>;</decl_stmt>

    <function><type><name>size_t</name></type> <name>count</name><parameter_list>()</parameter_list>  <block>{ <return>return <expr><name>head</name> - <name>tail</name></expr>;</return> }</block></function>
    <function><type><name>size_t</name></type> <name>length</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>lengthMask</name> + 1</expr>;</return> }</block></function>

    <expr_stmt><expr><call><name>JSFunctionBoxQueue</name><argument_list>()</argument_list></call>
      : <call><name>vector</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>head</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><call><name>tail</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <macro><name>lengthMask</name><argument_list>(<argument>0</argument>)</argument_list></macro> <expr><block>{ }</block>

    <name>bool</name> <macro><name>init</name><argument_list>(<argument>uint32 count</argument>)</argument_list></macro> <block>{
        <expr><name>lengthMask</name> = <call><name>JS_BITMASK</name><argument_list>(<argument><expr><call><name>JS_CeilingLog2</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <expr><name>vector</name> = <name>new</name> <name><name>JSFunctionBox</name>*<index>[<expr><call><name>length</name><argument_list>()</argument_list></call></expr>]</index></name></expr>;
        <return>return <expr>!!<name>vector</name></expr>;</return>
    }</block></expr></expr_stmt>

    <expr_stmt><expr>~<macro><name>JSFunctionBoxQueue</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>delete</name><index>[]</index></name> <name>vector</name></expr>; }</block>

    <name>void</name> <macro><name>push</name><argument_list>(<argument>JSFunctionBox *funbox</argument>)</argument_list></macro> <block>{
        <if>if <condition>(<expr>!<name><name>funbox</name>-&gt;<name>queued</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>count</name><argument_list>()</argument_list></call> &lt; <call><name>length</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vector</name><index>[<expr><name>head</name>++ &amp; <name>lengthMask</name></expr>]</index></name> = <name>funbox</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>funbox</name>-&gt;<name>queued</name></name> = <name>true</name></expr>;</expr_stmt>
        <expr_stmt/></block></then></if>}</block></expr></expr_stmt>
    }</block>

    <decl><name>JSFunctionBox</name> *<name>pull</name><argument_list>()</argument_list> <block>{
        <if>if <condition>(<expr><name>tail</name> == <name>head</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tail</name> &lt; <name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>JSFunctionBox</name> *</type><name>funbox</name> <init>= <expr><name><name>vector</name><index>[<expr><name>tail</name>++ &amp; <name>lengthMask</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>funbox</name>-&gt;<name>queued</name></name> = <name>false</name></expr>;</expr_stmt>
        <return>return <expr><name>funbox</name></expr>;</return>
    }</block></decl>
<decl/></struct>};

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_TEMP_FREELISTS</name></cpp:macro>      <cpp:value>6U</cpp:value></cpp:define>      <comment type="block">/* 32 to 2048 byte size classes (32 bit) */</comment>

<decl_stmt><decl><type><name>class</name></type> <name>JSTreeContext</name></decl>;</decl_stmt>

<typedef>typedef <type>struct <name>BindData</name></type> <name>BindData</name>;</typedef>

struct <label><name>JSCompiler</name> :</label> <expr_stmt><expr><name>private</name> <name>js</name>::<name>AutoGCRooter</name> <block>{
    <expr><name>JSContext</name>           * const <name>context</name></expr>; <comment type="block">/* FIXME Bug 551291: use AutoGCRooter::context? */</comment>
    <expr><name>JSAtomListElement</name>   *<name>aleFreeList</name></expr>;
    <expr><name>void</name>                *<name><name>tempFreeList</name><index>[<expr><name>NUM_TEMP_FREELISTS</name></expr>]</index></name></expr>;
    <expr><name>JSTokenStream</name>       <name>tokenStream</name></expr>;
    <expr><name>void</name>                *<name>tempPoolMark</name></expr>;  <comment type="block">/* initial JSContext.tempPool mark */</comment>
    <expr><name>JSPrincipals</name>        *<name>principals</name></expr>;    <comment type="block">/* principals associated with source */</comment>
    <expr><name>JSStackFrame</name> *const <name>callerFrame</name></expr>;    <comment type="block">/* scripted caller frame for eval and dbgapi */</comment>
    <expr><name>JSObject</name>     *const <name>callerVarObj</name></expr>;   <comment type="block">/* callerFrame's varObj */</comment>
    <expr><name>JSParseNode</name>         *<name>nodeList</name></expr>;      <comment type="block">/* list of recyclable parse-node structs */</comment>
    <expr><name>uint32</name>              <name>functionCount</name></expr>;  <comment type="block">/* number of functions in current unit */</comment>
    <expr><name>JSObjectBox</name>         *<name>traceListHead</name></expr>; <comment type="block">/* list of parsed object for GC tracing */</comment>
    <expr><name>JSTreeContext</name>       *<name>tc</name></expr>;            <comment type="block">/* innermost tree context (stack-allocated) */</comment>

    <expr><call><name>JSCompiler</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr><name>JSPrincipals</name> *<name>prin</name> = <name>NULL</name></expr></argument>, <argument><expr><name>JSStackFrame</name> *<name>cfp</name> = <name>NULL</name></expr></argument>)</argument_list></call>
      : <name>js</name>::<call><name>AutoGCRooter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>COMPILER</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>context</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>aleFreeList</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>tokenStream</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>principals</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>callerFrame</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>callerVarObj</name><argument_list>(<argument><expr><name>cfp</name> ? <call><name><name>cfp</name>-&gt;<name>varobj</name></name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>containingCallStack</name></name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> : <name>NULL</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>nodeList</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>functionCount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><call><name>traceListHead</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>, <macro><name>tc</name><argument_list>(<argument>NULL</argument>)</argument_list></macro>
    <expr><block>{
        <expr><name>js</name>::<call><name>PodArrayZero</name><argument_list>(<argument><expr><name>tempFreeList</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>setPrincipals</name><argument_list>(<argument><expr><name>prin</name></expr></argument>)</argument_list></call></expr>;
        <expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>script</name></name></expr></argument>)</argument_list></call></expr>;
    }</block>

    ~<call><name>JSCompiler</name><argument_list>()</argument_list></call></expr>;

    <expr><name>friend</name> <name>void</name> <name>js</name>::<name>AutoGCRooter</name>::<call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>friend</name> <name>class</name> <name>JSTreeContext</name></expr>;

    <comment type="block">/*
     * Initialize a compiler. Parameters are passed on to init tokenStream.
     * The compiler owns the arena pool "tops-of-stack" space above the current
     * JSContext.tempPool mark. This means you cannot allocate from tempPool
     * and save the pointer beyond the next JSCompiler destructor invocation.
     */</comment>
    <expr><name>bool</name> <macro><name>init</name><argument_list>(<argument>const jschar *base</argument>, <argument>size_t length</argument>,
              <argument>FILE *fp</argument>, <argument>const char *filename</argument>, <argument>uintN lineno</argument>)</argument_list></macro></expr>;

    <expr><name>void</name> <call><name>setPrincipals</name><argument_list>(<argument><expr><name>JSPrincipals</name> *<name>prin</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/*
     * Parse a top-level JS script.
     */</comment>
    <expr><name>JSParseNode</name> *<call><name>parse</name><argument_list>(<argument><expr><name>JSObject</name> *<name>chain</name></expr></argument>)</argument_list></call></expr>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
    <expr><name>JSParseNode</name> *<macro><name>parseXMLText</name><argument_list>(<argument>JSObject *chain</argument>, <argument>bool allowList</argument>)</argument_list></macro></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Allocate a new parsed object or function container from cx-&gt;tempPool.
     */</comment>
    <expr><name>JSObjectBox</name> *<call><name>newObjectBox</name><argument_list>(<argument><expr><name>JSObject</name> *<name>obj</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>JSFunctionBox</name> *<call><name>newFunctionBox</name><argument_list>(<argument><expr><name>JSObject</name> *<name>obj</name></expr></argument>, <argument><expr><name>JSParseNode</name> *<name>fn</name></expr></argument>, <argument><expr><name>JSTreeContext</name> *<name>tc</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/*
     * Create a new function object given tree context (tc), optional name
     * (atom may be null) and lambda flag (JSFUN_LAMBDA or 0).
     */</comment>
    <expr><name>JSFunction</name> *<macro><name>newFunction</name><argument_list>(<argument>JSTreeContext *tc</argument>, <argument>JSAtom *atom</argument>, <argument>uintN lambda</argument>)</argument_list></macro></expr>;

    <comment type="block">/*
     * Analyze the tree of functions nested within a single compilation unit,
     * starting at funbox, recursively walking its kids, then following its
     * siblings, their kids, etc.
     */</comment>
    <expr><name>bool</name> <call><name>analyzeFunctions</name><argument_list>(<argument><expr><name>JSFunctionBox</name> *<name>funbox</name></expr></argument>, <argument><expr><name>uint32</name>&amp; <name>tcflags</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>bool</name> <macro><name>markFunArgs</name><argument_list>(<argument>JSFunctionBox *funbox</argument>, <argument>uintN tcflags</argument>)</argument_list></macro></expr>;
    <expr><name>void</name> <call><name>setFunctionKinds</name><argument_list>(<argument><expr><name>JSFunctionBox</name> *<name>funbox</name></expr></argument>, <argument><expr><name>uint32</name>&amp; <name>tcflags</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>void</name> <call><name>trace</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>)</argument_list></call></expr>;

<expr><name>private</name>:
    <comment type="block">/*
     * JS parsers, from lowest to highest precedence.
     *
     * Each parser must be called during the dynamic scope of a JSTreeContext
     * object, pointed to by this-&gt;tc.
     *
     * Each returns a parse node tree or null on error.
     */</comment>
    <name>JSParseNode</name> *<call><name>functionStmt</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>functionExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>statements</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>statement</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<macro><name>variables</name><argument_list>(<argument>bool inLetHead</argument>)</argument_list></macro></expr>;
    <expr><name>JSParseNode</name> *<call><name>expr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>assignExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>condExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>orExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>andExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>bitOrExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>bitXorExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>bitAndExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>eqExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>relExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>shiftExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>addExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>mulExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>unaryExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<macro><name>memberExpr</name><argument_list>(<argument>JSBool allowCallSyntax</argument>)</argument_list></macro></expr>;
    <expr><name>JSParseNode</name> *<macro><name>primaryExpr</name><argument_list>(<argument>JSTokenType tt</argument>, <argument>JSBool afterDot</argument>)</argument_list></macro></expr>;
    <expr><name>JSParseNode</name> *<call><name>parenExpr</name><argument_list>(<argument><expr><name>JSParseNode</name> *<name>pn1</name></expr></argument>, <argument><expr><name>JSBool</name> *<name>genexp</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/*
     * Additional JS parsers.
     */</comment>
    <expr><name>bool</name> <call><name>recognizeDirectivePrologue</name><argument_list>(<argument><expr><name>JSParseNode</name> *<name>pn</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>functionBody</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<macro><name>functionDef</name><argument_list>(<argument>uintN lambda</argument>)</argument_list></macro></expr>;
    <expr><name>JSParseNode</name> *<call><name>condition</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<macro><name>comprehensionTail</name><argument_list>(<argument>JSParseNode *kid</argument>, <argument>uintN blockid</argument>,
                                   <argument>JSTokenType type = TOK_SEMI</argument>, <argument>JSOp op = JSOP_NOP</argument>)</argument_list></macro></expr>;
    <expr><name>JSParseNode</name> *<call><name>generatorExpr</name><argument_list>(<argument><expr><name>JSParseNode</name> *<name>pn</name></expr></argument>, <argument><expr><name>JSParseNode</name> *<name>kid</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>JSBool</name> <call><name>argumentList</name><argument_list>(<argument><expr><name>JSParseNode</name> *<name>listNode</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>bracketedExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<macro><name>letBlock</name><argument_list>(<argument>JSBool statement</argument>)</argument_list></macro></expr>;
    <expr><name>JSParseNode</name> *<macro><name>returnOrYield</name><argument_list>(<argument>bool useAssignExpr</argument>)</argument_list></macro></expr>;
    <expr><name>JSParseNode</name> *<macro><name>destructuringExpr</name><argument_list>(<argument>BindData *data</argument>, <argument>JSTokenType tt</argument>)</argument_list></macro></expr>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
    <expr><name>JSParseNode</name> *<call><name>endBracketedExpr</name><argument_list>()</argument_list></call></expr>;

    <expr><name>JSParseNode</name> *<call><name>propertySelector</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>qualifiedSuffix</name><argument_list>(<argument><expr><name>JSParseNode</name> *<name>pn</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>qualifiedIdentifier</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>attributeIdentifier</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<macro><name>xmlExpr</name><argument_list>(<argument>JSBool inTag</argument>)</argument_list></macro></expr>;
    <expr><name>JSParseNode</name> *<call><name>xmlAtomNode</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<call><name>xmlNameExpr</name><argument_list>()</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<macro><name>xmlTagContent</name><argument_list>(<argument>JSTokenType tagtype</argument>, <argument>JSAtom **namep</argument>)</argument_list></macro></expr>;
    <expr><name>JSBool</name> <call><name>xmlElementContent</name><argument_list>(<argument><expr><name>JSParseNode</name> *<name>pn</name></expr></argument>)</argument_list></call></expr>;
    <expr><name>JSParseNode</name> *<macro><name>xmlElementOrList</name><argument_list>(<argument>JSBool allowList</argument>)</argument_list></macro></expr>;
    <expr><name>JSParseNode</name> *<macro><name>xmlElementOrListRoot</name><argument_list>(<argument>JSBool allowList</argument>)</argument_list></macro></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XML_SUPPORT */</comment>

<expr><name>public</name>:
    static <name>bool</name>
    <macro><name>compileFunctionBody</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSFunction *fun</argument>, <argument>JSPrincipals *principals</argument>,
                        <argument>const jschar *chars</argument>, <argument>size_t length</argument>,
                        <argument>const char *filename</argument>, <argument>uintN lineno</argument>)</argument_list></macro></expr>;

    <expr>static <name>JSScript</name> *
    <macro><name>compileScript</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSObject *scopeChain</argument>, <argument>JSStackFrame *callerFrame</argument>,
                  <argument>JSPrincipals *principals</argument>, <argument>uint32 tcflags</argument>,
                  <argument>const jschar *chars</argument>, <argument>size_t length</argument>,
                  <argument>FILE *file</argument>, <argument>const char *filename</argument>, <argument>uintN lineno</argument>,
                  <argument>JSString *source = NULL</argument>,
                  <argument>unsigned staticLevel = 0</argument>)</argument_list></macro></expr>;
}</block></expr>;</expr_stmt>

<comment type="block">/*
 * Convenience macro to access JSCompiler.tokenStream as a pointer.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TS</name><parameter_list>(<param><type><name>jsc</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(&amp;(jsc)-&gt;tokenStream)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_FoldConstants</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>,
                 <param><decl><type><name>bool</name></type> <name>inCond</name> <init>= <expr><name>false</name></expr></init></decl></param>)</parameter_list>;</function_decl>

<macro><name>JS_END_EXTERN_C</name></macro>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* jsparse_h___ */</comment>
</unit>
