<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="005fa30a29413143027db30bac60b01be0cb0fe8.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set sw=4 ts=8 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * JS regular expressions, after Perl.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstdint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarena.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbuiltins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsfun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsregexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstaticcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsvector.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstracer.h"</cpp:file></cpp:include>
<using>using namespace <name>avmplus</name>;</using>
<using>using namespace <name>nanojit</name>;</using>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<using>using namespace <name>js</name>;</using>

<typedef>typedef <type><enum>enum <name>REOp</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REOP_DEF</name><parameter_list>(<param><type><name>opcode</name></type></param>, <param><type><name>name</name></type></param>)</parameter_list></cpp:macro> <cpp:value>opcode,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsreops.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>REOP_DEF</name></cpp:undef>
    <decl><name>REOP_LIMIT</name></decl> <comment type="block">/* META: no operator &gt;= to this */</comment>
}</block></enum></type> <name>REOp</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REOP_IS_SIMPLE</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((op) &lt;= REOP_NCLASS)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REGEXP_DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>reop_names</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REOP_DEF</name><parameter_list>(<param><type><name>opcode</name></type></param>, <param><type><name>name</name></type></param>)</parameter_list></cpp:macro> <cpp:value>name,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsreops.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>REOP_DEF</name></cpp:undef>
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>
<name>re_debug</name><argument_list>(<argument><expr>const <name>char</name> *<name>fmt</name></expr></argument>, <argument>...<expr/></argument>)</argument_list> <name>__attribute__</name> <argument_list>(<argument><expr>(<call><name>format</name><argument_list>(<argument><expr><name>printf</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REGEXP_DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>re_debug</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>retval</name> = <call><name>vprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>retval</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>re_debug_chars</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chrs</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" \""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr>*<name>chrs</name> &amp;&amp; <name>i</name>++ &lt; <name>length</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr>(<name>char</name>)*<name>chrs</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* !REGEXP_DEBUG */</comment>
<comment type="block">/* This should be optimized to a no-op by our tier-1 compilers. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>re_debug</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>re_debug_chars</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chrs</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !REGEXP_DEBUG */</comment>

<struct>struct <name>RENode</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>REOp</name></type>            <name>op</name></decl>;</decl_stmt>         <comment type="block">/* r.e. op bytecode */</comment>
    <decl_stmt><decl><type><name>RENode</name>          *</type><name>next</name></decl>;</decl_stmt>      <comment type="block">/* next in concatenation order */</comment>
    <decl_stmt><decl><type><name>void</name>            *</type><name>kid</name></decl>;</decl_stmt>       <comment type="block">/* first operand */</comment>
    <union>union <block>{<public type="default">
        <decl_stmt><decl><type><name>void</name>        *</type><name>kid2</name></decl>;</decl_stmt>      <comment type="block">/* second operand */</comment>
        <decl_stmt><decl><type><name>jsint</name></type>       <name>num</name></decl>;</decl_stmt>        <comment type="block">/* could be a number */</comment>
        <decl_stmt><decl><type><name>size_t</name></type>      <name>parenIndex</name></decl>;</decl_stmt> <comment type="block">/* or a parenthesis index */</comment>
        <struct>struct <block>{<public type="default">                <comment type="block">/* or a quantifier range */</comment>
            <decl_stmt><decl><type><name>uintN</name></type>  <name>min</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uintN</name></type>  <name>max</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSPackedBool</name></type> <name>greedy</name></decl>;</decl_stmt>
        </public>}</block> <decl><name>range</name></decl>;</struct>
        <struct>struct <block>{<public type="default">                <comment type="block">/* or a character class */</comment>
            <decl_stmt><decl><type><name>size_t</name></type>  <name>startIndex</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type>  <name>kidlen</name></decl>;</decl_stmt>     <comment type="block">/* length of string at kid, in jschars */</comment>
            <decl_stmt><decl><type><name>size_t</name></type>  <name>index</name></decl>;</decl_stmt>      <comment type="block">/* index into class list */</comment>
            <decl_stmt><decl><type><name>uint16</name></type>  <name>bmsize</name></decl>;</decl_stmt>     <comment type="block">/* bitmap size, based on max char code */</comment>
            <decl_stmt><decl><type><name>JSPackedBool</name></type> <name>sense</name></decl>;</decl_stmt>
        </public>}</block> <decl><name>ucclass</name></decl>;</struct>
        <struct>struct <block>{<public type="default">                <comment type="block">/* or a literal sequence */</comment>
            <decl_stmt><decl><type><name>jschar</name></type>  <name>chr</name></decl>;</decl_stmt>        <comment type="block">/* of one character */</comment>
            <decl_stmt><decl><type><name>size_t</name></type>  <name>length</name></decl>;</decl_stmt>     <comment type="block">/* or many (via the kid) */</comment>
        </public>}</block> <decl><name>flat</name></decl>;</struct>
        <struct>struct <block>{<public type="default">
            <decl_stmt><decl><type><name>RENode</name>  *</type><name>kid2</name></decl>;</decl_stmt>      <comment type="block">/* second operand from ALT */</comment>
            <decl_stmt><decl><type><name>jschar</name></type>  <name>ch1</name></decl>;</decl_stmt>        <comment type="block">/* match char for ALTPREREQ */</comment>
            <decl_stmt><decl><type><name>jschar</name></type>  <name>ch2</name></decl>;</decl_stmt>        <comment type="block">/* ditto, or class index for ALTPREREQ2 */</comment>
        </public>}</block> <decl><name>altprereq</name></decl>;</struct>
    </public>}</block> <decl><name>u</name></decl>;</union>
</public>}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_IS_LETTER</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>(((c &gt;= 'A') &amp;&amp; (c &lt;= 'Z')) ||                    \
                             ((c &gt;= 'a') &amp;&amp; (c &lt;= 'z')) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_IS_LINE_TERM</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((c == '\n') || (c == '\r') ||                    \
                             (c == LINE_SEPARATOR) || (c == PARA_SEPARATOR))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_CACHE_SIZE</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>CompilerState</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSContext</name>       *</type><name>context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenStream</name>   *</type><name>tokenStream</name></decl>;</decl_stmt> <comment type="block">/* For reporting errors */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name>    *</type><name>cpbegin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name>    *</type><name>cpend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name>    *</type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>          <name>parenCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>          <name>classCount</name></decl>;</decl_stmt>   <comment type="block">/* number of [] encountered */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>          <name>treeDepth</name></decl>;</decl_stmt>    <comment type="block">/* maximum depth of parse tree */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>          <name>progLength</name></decl>;</decl_stmt>   <comment type="block">/* estimated bytecode length */</comment>
    <decl_stmt><decl><type><name>RENode</name>          *</type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>          <name>classBitmapsMem</name></decl>;</decl_stmt> <comment type="block">/* memory to hold all class bitmaps */</comment>
    <struct>struct <block>{<public type="default">
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>start</name></decl>;</decl_stmt>        <comment type="block">/* small cache of class strings */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>;</decl_stmt>              <comment type="block">/* since they're often the same */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>index</name></decl>;</decl_stmt>
    </public>}</block> <decl><name><name>classCache</name><index>[<expr><name>CLASS_CACHE_SIZE</name></expr>]</index></name></decl>;</struct>
    <decl_stmt><decl><type><name>uint16</name></type>          <name>flags</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>CompilerState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>EmitStateStackEntry</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>jsbytecode</name>      *</type><name>altHead</name></decl>;</decl_stmt>       <comment type="block">/* start of REOP_ALT* opcode */</comment>
    <decl_stmt><decl><type><name>jsbytecode</name>      *</type><name>nextAltFixup</name></decl>;</decl_stmt>  <comment type="block">/* fixup pointer to next-alt offset */</comment>
    <decl_stmt><decl><type><name>jsbytecode</name>      *</type><name>nextTermFixup</name></decl>;</decl_stmt> <comment type="block">/* fixup ptr. to REOP_JUMP offset */</comment>
    <decl_stmt><decl><type><name>jsbytecode</name>      *</type><name>endTermFixup</name></decl>;</decl_stmt>  <comment type="block">/* fixup ptr. to REOPT_ALTPREREQ* offset */</comment>
    <decl_stmt><decl><type><name>RENode</name>          *</type><name>continueNode</name></decl>;</decl_stmt>  <comment type="block">/* original REOP_ALT* node being stacked */</comment>
    <decl_stmt><decl><type><name>jsbytecode</name></type>      <name>continueOp</name></decl>;</decl_stmt>     <comment type="block">/* REOP_JUMP or REOP_ENDALT continuation */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>    <name>jumpToJumpFlag</name></decl>;</decl_stmt> <comment type="block">/* true if we've patched jump-to-jump to
                                       avoid 16-bit unsigned offset overflow */</comment>
</public>}</block></struct></type> <name>EmitStateStackEntry</name>;</typedef>

<comment type="block">/*
 * Immediate operand sizes and getter/setters.  Unlike the ones in jsopcode.h,
 * the getters and setters take the pc of the offset, not of the opcode before
 * the offset.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_LEN</name></cpp:macro>             <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ARG</name><parameter_list>(<param><type><name>pc</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>((uint16)(((pc)[0] &lt;&lt; 8) | (pc)[1]))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_ARG</name><parameter_list>(<param><type><name>pc</name></type></param>, <param><type><name>arg</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>((pc)[0] = (jsbytecode) ((arg) &gt;&gt; 8),       \
                             (pc)[1] = (jsbytecode) (arg))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET_LEN</name></cpp:macro>          <cpp:value>ARG_LEN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET_MAX</name></cpp:macro>          <cpp:value>(JS_BIT(ARG_LEN * 8) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_OFFSET</name><parameter_list>(<param><type><name>pc</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>GET_ARG(pc)</cpp:value></cpp:define>

<comment type="block">/*
 * Maximum supported tree depth is maximum size of EmitStateStackEntry stack.
 * For sanity, we limit it to 2^24 bytes.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREE_DEPTH_MAX</name></cpp:macro>  <cpp:value>(JS_BIT(24) / sizeof(EmitStateStackEntry))</cpp:value></cpp:define>

<comment type="block">/*
 * The maximum memory that can be allocated for class bitmaps.
 * For sanity, we limit it to 2^24 bytes.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLASS_BITMAPS_MEM_LIMIT</name></cpp:macro> <cpp:value>JS_BIT(24)</cpp:value></cpp:define>

<comment type="block">/*
 * Functions to get size and write/read bytecode that represent small indexes
 * compactly.
 * Each byte in the code represent 7-bit chunk of the index. 8th bit when set
 * indicates that the following byte brings more bits to the index. Otherwise
 * this is the last byte in the index bytecode representing highest index bits.
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>GetCompactIndexWidth</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>width</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>width</name> = 1</expr>;</init> <condition><expr>(<name>index</name> &gt;&gt;= 7) != 0</expr>;</condition> <incr><expr>++<name>width</name></expr></incr>) <block>{ }</block></for>
    <return>return <expr><name>width</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>jsbytecode</name> *</type>
<name>WriteCompactIndex</name><parameter_list>(<param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>next</name></decl>;</decl_stmt>

    <while>while <condition>(<expr>(<name>next</name> = <name>index</name> &gt;&gt; 7) != 0</expr>)</condition> <block>{
        <expr_stmt><expr>*<name>pc</name>++ = <call>(<name>jsbytecode</name>)<argument_list>(<argument><expr><name>index</name> | 0x80</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>index</name> = <name>next</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr>*<name>pc</name>++ = (<name>jsbytecode</name>)<name>index</name></expr>;</expr_stmt>
    <return>return <expr><name>pc</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>jsbytecode</name> *</type>
<name>ReadCompactIndex</name><parameter_list>(<param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>size_t</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>nextByte</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nextByte</name> = *<name>pc</name>++</expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>nextByte</name> &amp; 0x80) == 0</expr>)</condition><then> <block>{
        <comment type="block">/*
         * Short-circuit the most common case when compact index &lt;= 127.
         */</comment>
        <expr_stmt><expr>*<name>result</name> = <name>nextByte</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>shift</name> <init>= <expr>7</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*<name>result</name> = 0x7F &amp; <name>nextByte</name></expr>;</expr_stmt>
        <do>do <block>{
            <expr_stmt><expr><name>nextByte</name> = *<name>pc</name>++</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>result</name> |= (<name>nextByte</name> &amp; 0x7F) &lt;&lt; <name>shift</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>shift</name> += 7</expr>;</expr_stmt>
        }</block> while <condition>(<expr>(<name>nextByte</name> &amp; 0x80) != 0</expr>)</condition>;</do>
    }</block></else></if>
    <return>return <expr><name>pc</name></expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <name>RECapture</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>index</name></decl>;</decl_stmt>           <comment type="block">/* start of contents, -1 for empty  */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>;</decl_stmt>             <comment type="block">/* length of capture */</comment>
</public>}</block></struct></type> <name>RECapture</name>;</typedef>

<typedef>typedef <type><struct>struct <name>REMatchState</name> <block>{<public type="default">
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RECapture</name></type> <name><name>parens</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* first of 're-&gt;parenCount' captures,
                                 allocated at end of this struct */</comment>
</public>}</block></struct></type> <name>REMatchState</name>;</typedef>

<struct_decl>struct <name>REBackTrackData</name>;</struct_decl>

<typedef>typedef <type><struct>struct <name>REProgState</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>continue_pc</name></decl>;</decl_stmt>        <comment type="block">/* current continuation data */</comment>
    <decl_stmt><decl><type><name>jsbytecode</name></type> <name>continue_op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>index</name></decl>;</decl_stmt>                <comment type="block">/* progress in text */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>parenSoFar</name></decl>;</decl_stmt>              <comment type="block">/* highest indexed paren started */</comment>
    <union>union <block>{<public type="default">
        <struct>struct <block>{<public type="default">
            <decl_stmt><decl><type><name>uintN</name></type> <name>min</name></decl>;</decl_stmt>             <comment type="block">/* current quantifier limits */</comment>
            <decl_stmt><decl><type><name>uintN</name></type> <name>max</name></decl>;</decl_stmt>
        </public>}</block> <decl><name>quantifier</name></decl>;</struct>
        <struct>struct <block>{<public type="default">
            <decl_stmt><decl><type><name>size_t</name></type> <name>top</name></decl>;</decl_stmt>             <comment type="block">/* backtrack stack state */</comment>
            <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
        </public>}</block> <decl><name>assertion</name></decl>;</struct>
    </public>}</block> <decl><name>u</name></decl>;</union>
</public>}</block></struct></type> <name>REProgState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>REBackTrackData</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>                      <comment type="block">/* size of previous stack entry */</comment>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>backtrack_pc</name></decl>;</decl_stmt>       <comment type="block">/* where to backtrack to */</comment>
    <decl_stmt><decl><type><name>jsbytecode</name></type> <name>backtrack_op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>cp</name></decl>;</decl_stmt>               <comment type="block">/* index in text of match at backtrack */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>parenIndex</name></decl>;</decl_stmt>              <comment type="block">/* start index of saved paren contents */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>parenCount</name></decl>;</decl_stmt>              <comment type="block">/* # of saved paren contents */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>saveStateStackTop</name></decl>;</decl_stmt>       <comment type="block">/* number of parent states */</comment>
    <comment type="block">/* saved parent states follow */</comment>
    <comment type="block">/* saved paren contents follow */</comment>
</public>}</block></struct></type> <name>REBackTrackData</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_STATESTACK</name></cpp:macro>  <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_BACKTRACK</name></cpp:macro>   <cpp:value>8000</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>REGlobalData</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>regexp</name></decl>;</decl_stmt>               <comment type="block">/* the RE in execution */</comment>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>                      <comment type="block">/* runtime error (out_of_memory only?) */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>start</name></decl>;</decl_stmt>                   <comment type="block">/* offset to start at */</comment>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>skipped</name></decl>;</decl_stmt>              <comment type="block">/* chars skipped anchoring this r.e. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name>    *</type><name>cpbegin</name></decl>;</decl_stmt>       <comment type="block">/* text base address */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name>    *</type><name>cpend</name></decl>;</decl_stmt>         <comment type="block">/* text limit address */</comment>

    <decl_stmt><decl><type><name>REProgState</name> *</type><name>stateStack</name></decl>;</decl_stmt>        <comment type="block">/* stack of state of current parents */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>stateStackTop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>stateStackLimit</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>REBackTrackData</name> *</type><name>backTrackStack</name></decl>;</decl_stmt><comment type="block">/* stack of matched-so-far positions */</comment>
    <decl_stmt><decl><type><name>REBackTrackData</name> *</type><name>backTrackSP</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>backTrackStackSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cursz</name></decl>;</decl_stmt>                   <comment type="block">/* size of current stack entry */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>backTrackCount</name></decl>;</decl_stmt>          <comment type="block">/* how many times we've backtracked */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>backTrackLimit</name></decl>;</decl_stmt>          <comment type="block">/* upper limit on backtrack states */</comment>
</public>}</block></struct></type> <name>REGlobalData</name>;</typedef>

<comment type="block">/*
 * 1. If IgnoreCase is false, return ch.
 * 2. Let u be ch converted to upper case as if by calling
 *    String.prototype.toUpperCase on the one-character string ch.
 * 3. If u does not consist of a single character, return ch.
 * 4. Let cu be u's character.
 * 5. If ch's code point value is greater than or equal to decimal 128 and cu's
 *    code point value is less than decimal 128, then return ch.
 * 6. Return cu.
 */</comment>
<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>uintN</name></type>
<name>upcase</name><parameter_list>(<param><decl><type><name>uintN</name></type> <name>ch</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>cu</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>uintN</name>) (<name>jschar</name>) <name>ch</name> == <name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ch</name> &lt; 128</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>ch</name> - (<name>uintN</name>) 'a' &lt;= <call>(<name>uintN</name>) <argument_list>(<argument><expr>'z' - 'a'</expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>ch</name> -= <call>(<name>uintN</name>) <argument_list>(<argument><expr>'a' - 'A'</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><name>ch</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>cu</name> = <call><name>JS_TOUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>cu</name> &lt; 128) ? <name>ch</name> : <name>cu</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Return the 'canonical' inverse upcase of |ch|. That is the character
 * |lch| such that |upcase(lch) == ch| and (|lch| is the lower-case form
 * of |ch| or is |ch|).
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>jschar</name></type> <name>inverse_upcase</name><parameter_list>(<param><decl><type><name>jschar</name></type> <name>ch</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jschar</name></type> <name>lch</name> <init>= <expr><call><name>JS_TOLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr>(<call><name>upcase</name><argument_list>(<argument><expr><name>lch</name></expr></argument>)</argument_list></call> == <name>ch</name>) ? <name>lch</name> : <name>ch</name></expr>;</return>       
}</block></function>

<comment type="block">/* Construct and initialize an RENode, returning NULL for out-of-memory */</comment>
<function><type><specifier>static</specifier> <name>RENode</name> *</type>
<name>NewRENode</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>, <param><decl><type><name>REOp</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RENode</name> *</type><name>ren</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cx</name> = <name><name>state</name>-&gt;<name>context</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><name>ren</name></expr></argument>, <argument><expr><name>RENode</name> *</expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr>sizeof *<name>ren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ren</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>ren</name>-&gt;<name>op</name></name> = <name>op</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ren</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ren</name>-&gt;<name>kid</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>ren</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Validates and converts hex ascii value.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>isASCIIHexDigit</name><parameter_list>(<param><decl><type><name>jschar</name></type> <name>c</name></decl></param>, <param><decl><type><name>uintN</name> *</type><name>digit</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>cv</name> <init>= <expr><name>c</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>cv</name> &lt; '0'</expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>cv</name> &lt;= '9'</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>digit</name> = <name>cv</name> - '0'</expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>cv</name> |= 0x20</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cv</name> &gt;= 'a' &amp;&amp; <name>cv</name> &lt;= 'f'</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>digit</name> = <name>cv</name> - 'a' + 10</expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>


<typedef>typedef <type><struct>struct <block>{<public type="default">
    <decl_stmt><decl><type><name>REOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>errPos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>parenIndex</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>REOpData</name>;</typedef>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ReportRegExpErrorHelper</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>errorNumber</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>tokenStream</name></name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>tokenStream</name></name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSREPORT_UC</name> | <name>flags</name></expr></argument>,
                                           <argument><expr><name>errorNumber</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>JS_ReportErrorFlagsAndNumberUC</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>context</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
                                          <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>errorNumber</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ReportRegExpError</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>errorNumber</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>ReportRegExpErrorHelper</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>errorNumber</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Process the op against the two top operands, reducing them to a single
 * operand in the penultimate slot. Update progLength and treeDepth.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ProcessOp</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>, <param><decl><type><name>REOpData</name> *</type><name>opData</name></decl></param>, <param><decl><type><name>RENode</name> **</type><name>operandStack</name></decl></param>,
          <param><decl><type><name>intN</name></type> <name>operandSP</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>RENode</name> *</type><name>result</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>opData</name>-&gt;<name>op</name></name></expr>)</condition> <block>{
      <case>case <expr><name>REOP_ALT</name></expr>:
        <expr_stmt><expr><name>result</name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>result</name>-&gt;<name>kid</name></name> = <name><name>operandStack</name><index>[<expr><name>operandSP</name> - 2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name>-&gt;<name>u</name>.<name>kid2</name></name> = <name><name>operandStack</name><index>[<expr><name>operandSP</name> - 1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>operandStack</name><index>[<expr><name>operandSP</name> - 2</expr>]</index></name> = <name>result</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>state</name>-&gt;<name>treeDepth</name></name> == <name>TREE_DEPTH_MAX</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_REGEXP_TOO_COMPLEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr>++<name><name>state</name>-&gt;<name>treeDepth</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Look at both alternates to see if there's a FLAT or a CLASS at
         * the start of each. If so, use a prerequisite match.
         */</comment>
        <if>if <condition>(<expr>((<name>RENode</name> *) <name><name>result</name>-&gt;<name>kid</name></name>)-&gt;<name>op</name> == <name>REOP_FLAT</name> &amp;&amp;
            ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>u</name>.<name>kid2</name></name>)-&gt;<name>op</name> == <name>REOP_FLAT</name> &amp;&amp;
            (<name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name>) == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>result</name>-&gt;<name>op</name></name> = <name>REOP_ALTPREREQ</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>u</name>.<name>altprereq</name>.<name>ch1</name></name> = ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>kid</name></name>)-&gt;<name><name>u</name>.<name>flat</name>.<name>chr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>u</name>.<name>altprereq</name>.<name>ch2</name></name> = ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>u</name>.<name>kid2</name></name>)-&gt;<name><name>u</name>.<name>flat</name>.<name>chr</name></name></expr>;</expr_stmt>
            <comment type="block">/* ALTPREREQ, &lt;end&gt;, uch1, uch2, &lt;next&gt;, ...,
                                            JUMP, &lt;end&gt; ... ENDALT */</comment>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 13</expr>;</expr_stmt>
        }</block></then>
        <else>else
        <if>if <condition>(<expr>((<name>RENode</name> *) <name><name>result</name>-&gt;<name>kid</name></name>)-&gt;<name>op</name> == <name>REOP_CLASS</name> &amp;&amp;
            ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>kid</name></name>)-&gt;<name><name>u</name>.<name>ucclass</name>.<name>index</name></name> &lt; 256 &amp;&amp;
            ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>u</name>.<name>kid2</name></name>)-&gt;<name>op</name> == <name>REOP_FLAT</name> &amp;&amp;
            (<name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name>) == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>result</name>-&gt;<name>op</name></name> = <name>REOP_ALTPREREQ2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>u</name>.<name>altprereq</name>.<name>ch1</name></name> = ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>u</name>.<name>kid2</name></name>)-&gt;<name><name>u</name>.<name>flat</name>.<name>chr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>u</name>.<name>altprereq</name>.<name>ch2</name></name> = ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>kid</name></name>)-&gt;<name><name>u</name>.<name>ucclass</name>.<name>index</name></name></expr>;</expr_stmt>
            <comment type="block">/* ALTPREREQ2, &lt;end&gt;, uch1, uch2, &lt;next&gt;, ...,
                                            JUMP, &lt;end&gt; ... ENDALT */</comment>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 13</expr>;</expr_stmt>
        }</block></then>
        <else>else
        <if>if <condition>(<expr>((<name>RENode</name> *) <name><name>result</name>-&gt;<name>kid</name></name>)-&gt;<name>op</name> == <name>REOP_FLAT</name> &amp;&amp;
            ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>u</name>.<name>kid2</name></name>)-&gt;<name>op</name> == <name>REOP_CLASS</name> &amp;&amp;
            ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>u</name>.<name>kid2</name></name>)-&gt;<name><name>u</name>.<name>ucclass</name>.<name>index</name></name> &lt; 256 &amp;&amp;
            (<name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name>) == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>result</name>-&gt;<name>op</name></name> = <name>REOP_ALTPREREQ2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>u</name>.<name>altprereq</name>.<name>ch1</name></name> = ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>kid</name></name>)-&gt;<name><name>u</name>.<name>flat</name>.<name>chr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>u</name>.<name>altprereq</name>.<name>ch2</name></name> =
                ((<name>RENode</name> *) <name><name>result</name>-&gt;<name>u</name>.<name>kid2</name></name>)-&gt;<name><name>u</name>.<name>ucclass</name>.<name>index</name></name></expr>;</expr_stmt>
            <comment type="block">/* ALTPREREQ2, &lt;end&gt;, uch1, uch2, &lt;next&gt;, ...,
                                          JUMP, &lt;end&gt; ... ENDALT */</comment>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 13</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* ALT, &lt;next&gt;, ..., JUMP, &lt;end&gt; ... ENDALT */</comment>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 7</expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>
        <break>break;</break>

      </case><case>case <expr><name>REOP_CONCAT</name></expr>:
        <expr_stmt><expr><name>result</name> = <name><name>operandStack</name><index>[<expr><name>operandSP</name> - 2</expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>result</name>-&gt;<name>next</name></name></expr>)</condition>
            <expr_stmt><expr><name>result</name> = <name><name>result</name>-&gt;<name>next</name></name></expr>;</expr_stmt></while>
        <expr_stmt><expr><name><name>result</name>-&gt;<name>next</name></name> = <name><name>operandStack</name><index>[<expr><name>operandSP</name> - 1</expr>]</index></name></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>REOP_ASSERT</name></expr>:
      </case><case>case <expr><name>REOP_ASSERT_NOT</name></expr>:
      </case><case>case <expr><name>REOP_LPARENNON</name></expr>:
      </case><case>case <expr><name>REOP_LPAREN</name></expr>:
        <comment type="block">/* These should have been processed by a close paren. */</comment>
        <expr_stmt><expr><call><name>ReportRegExpErrorHelper</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_MISSING_PAREN</name></expr></argument>,
                                <argument><expr><name><name>opData</name>-&gt;<name>errPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>

      </case><default>default:<empty_stmt>;</empty_stmt>
    </default>}</block></switch>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Parser forward declarations.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>ParseTerm</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>ParseQuantifier</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>intN</name></type> <name>ParseMinMaxQuantifier</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>ignoreValues</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Top-down regular expression grammar, based closely on Perl4.
 *
 *  regexp:     altern                  A regular expression is one or more
 *              altern '|' regexp       alternatives separated by vertical bar.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_STACK_SIZE</name></cpp:macro>  <cpp:value>128</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ParseRegExp</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>parenIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RENode</name> *</type><name>operand</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>REOpData</name> *</type><name>operatorStack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RENode</name> **</type><name>operandStack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>REOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>intN</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>result</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>intN</name></type> <name>operatorSP</name> <init>= <expr>0</expr></init>, <name>operatorStackSize</name> <init>= <expr><name>INITIAL_STACK_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>intN</name></type> <name>operandSP</name> <init>= <expr>0</expr></init>, <name>operandStackSize</name> <init>= <expr><name>INITIAL_STACK_SIZE</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Watch out for empty regexp */</comment>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> == <name><name>state</name>-&gt;<name>cpend</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name><name>state</name>-&gt;<name>result</name></name> != <name>NULL</name>)</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>operatorStack</name> = (<name>REOpData</name> *)
        <call><name><name>state</name>-&gt;<name>context</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>REOpData</name></expr></argument>)</argument_list></sizeof> * <name>operatorStackSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>operatorStack</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>operandStack</name> = (<name>RENode</name> **)
        <call><name><name>state</name>-&gt;<name>context</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RENode</name> *</expr></argument>)</argument_list></sizeof> * <name>operandStackSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>operandStack</name></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr><name>parenIndex</name> = <name><name>state</name>-&gt;<name>parenCount</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> == <name><name>state</name>-&gt;<name>cpend</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If we are at the end of the regexp and we're short one or more
             * operands, the regexp must have the form /x|/ or some such, with
             * left parentheses making us short more than one operand.
             */</comment>
            <if>if <condition>(<expr><name>operatorSP</name> &gt;= <name>operandSP</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>operand</name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>operand</name></expr>)</condition><then>
                    <goto>goto <name>out</name>;</goto></then></if>
                <goto>goto <name>pushOperand</name>;</goto>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <switch>switch <condition>(<expr>*<name><name>state</name>-&gt;<name>cp</name></name></expr>)</condition> <block>{
              <case>case <expr>'('</expr>:
                <expr_stmt><expr>++<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> + 1 &lt; <name><name>state</name>-&gt;<name>cpend</name></name> &amp;&amp;
                    *<name><name>state</name>-&gt;<name>cp</name></name> == '?' &amp;&amp;
                    (<name><name>state</name>-&gt;<name>cp</name><index>[<expr>1</expr>]</index></name> == '=' ||
                     <name><name>state</name>-&gt;<name>cp</name><index>[<expr>1</expr>]</index></name> == '!' ||
                     <name><name>state</name>-&gt;<name>cp</name><index>[<expr>1</expr>]</index></name> == ':')</expr>)</condition><then> <block>{
                    <switch>switch <condition>(<expr><name><name>state</name>-&gt;<name>cp</name><index>[<expr>1</expr>]</index></name></expr>)</condition> <block>{
                      <case>case <expr>'='</expr>:
                        <expr_stmt><expr><name>op</name> = <name>REOP_ASSERT</name></expr>;</expr_stmt>
                        <comment type="block">/* ASSERT, &lt;next&gt;, ... ASSERTTEST */</comment>
                        <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 4</expr>;</expr_stmt>
                        <break>break;</break>
                      </case><case>case <expr>'!'</expr>:
                        <expr_stmt><expr><name>op</name> = <name>REOP_ASSERT_NOT</name></expr>;</expr_stmt>
                        <comment type="block">/* ASSERTNOT, &lt;next&gt;, ... ASSERTNOTTEST */</comment>
                        <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 4</expr>;</expr_stmt>
                        <break>break;</break>
                      </case><default>default:
                        <expr_stmt><expr><name>op</name> = <name>REOP_LPARENNON</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </default>}</block></switch>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>cp</name></name> += 2</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>op</name> = <name>REOP_LPAREN</name></expr>;</expr_stmt>
                    <comment type="block">/* LPAREN, &lt;index&gt;, ... RPAREN, &lt;index&gt; */</comment>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name>
                        += 2 * (1 + <call><name>GetCompactIndexWidth</name><argument_list>(<argument><expr><name>parenIndex</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>parenCount</name></name>++</expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>parenCount</name></name> == 65535</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                          <argument><expr><name>JSMSG_TOO_MANY_PARENS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>out</name>;</goto>
                    }</block></then></if>
                }</block></else></if>
                <goto>goto <name>pushOperator</name>;</goto>

              </case><case>case <expr>')'</expr>:
                <comment type="block">/*
                 * If there's no stacked open parenthesis, throw syntax error.
                 */</comment>
                <for>for (<init><expr><name>i</name> = <name>operatorSP</name> - 1</expr>;</init> <condition>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
                    <if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                          <argument><expr><name>JSMSG_UNMATCHED_RIGHT_PAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>out</name>;</goto>
                    }</block></then></if>
                    <if>if <condition>(<expr><name><name>operatorStack</name><index>[<expr><name>i</name></expr>]</index></name>.<name>op</name> == <name>REOP_ASSERT</name> ||
                        <name><name>operatorStack</name><index>[<expr><name>i</name></expr>]</index></name>.<name>op</name> == <name>REOP_ASSERT_NOT</name> ||
                        <name><name>operatorStack</name><index>[<expr><name>i</name></expr>]</index></name>.<name>op</name> == <name>REOP_LPARENNON</name> ||
                        <name><name>operatorStack</name><index>[<expr><name>i</name></expr>]</index></name>.<name>op</name> == <name>REOP_LPAREN</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                }</block></for>
                <comment type="block">/* FALL THROUGH */</comment>

              </case><case>case <expr>'|'</expr>:
                <comment type="block">/* Expected an operand before these, so make an empty one */</comment>
                <expr_stmt><expr><name>operand</name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>operand</name></expr>)</condition><then>
                    <goto>goto <name>out</name>;</goto></then></if>
                <goto>goto <name>pushOperand</name>;</goto>

              </case><default>default:
                <if>if <condition>(<expr>!<call><name>ParseTerm</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>out</name>;</goto></then></if>
                <expr_stmt><expr><name>operand</name> = <name><name>state</name>-&gt;<name>result</name></name></expr>;</expr_stmt>
<label><name>pushOperand</name>:</label>
                <if>if <condition>(<expr><name>operandSP</name> == <name>operandStackSize</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>RENode</name> **</type><name>tmp</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>operandStackSize</name> += <name>operandStackSize</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tmp</name> = (<name>RENode</name> **)
                        <call><name><name>state</name>-&gt;<name>context</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>operandStack</name></expr></argument>,
                                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RENode</name> *</expr></argument>)</argument_list></sizeof> * <name>operandStackSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
                        <goto>goto <name>out</name>;</goto></then></if>
                    <expr_stmt><expr><name>operandStack</name> = <name>tmp</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name><name>operandStack</name><index>[<expr><name>operandSP</name>++</expr>]</index></name> = <name>operand</name></expr>;</expr_stmt>
                <break>break;</break>
            </default>}</block></switch>
        }</block></else></if>

        <comment type="block">/* At the end; process remaining operators. */</comment>
<label><name>restartOperator</name>:</label>
        <if>if <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> == <name><name>state</name>-&gt;<name>cpend</name></name></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>operatorSP</name></expr>)</condition> <block>{
                <expr_stmt><expr>--<name>operatorSP</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>ProcessOp</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr>&amp;<name><name>operatorStack</name><index>[<expr><name>operatorSP</name></expr>]</index></name></expr></argument>,
                               <argument><expr><name>operandStack</name></expr></argument>, <argument><expr><name>operandSP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>out</name>;</goto></then></if>
                <expr_stmt><expr>--<name>operandSP</name></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>operandSP</name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <name><name>operandStack</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        }</block></then></if>

        <switch>switch <condition>(<expr>*<name><name>state</name>-&gt;<name>cp</name></name></expr>)</condition> <block>{
          <case>case <expr>'|'</expr>:
            <comment type="block">/* Process any stacked 'concat' operators */</comment>
            <expr_stmt><expr>++<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>operatorSP</name> &amp;&amp;
                   <name><name>operatorStack</name><index>[<expr><name>operatorSP</name> - 1</expr>]</index></name>.<name>op</name> == <name>REOP_CONCAT</name></expr>)</condition> <block>{
                <expr_stmt><expr>--<name>operatorSP</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>ProcessOp</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr>&amp;<name><name>operatorStack</name><index>[<expr><name>operatorSP</name></expr>]</index></name></expr></argument>,
                               <argument><expr><name>operandStack</name></expr></argument>, <argument><expr><name>operandSP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <goto>goto <name>out</name>;</goto>
                }</block></then></if>
                <expr_stmt><expr>--<name>operandSP</name></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><name>op</name> = <name>REOP_ALT</name></expr>;</expr_stmt>
            <goto>goto <name>pushOperator</name>;</goto>

          </case><case>case <expr>')'</expr>:
            <comment type="block">/*
             * If there's no stacked open parenthesis, throw syntax error.
             */</comment>
            <for>for (<init><expr><name>i</name> = <name>operatorSP</name> - 1</expr>;</init> <condition>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
                <if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                      <argument><expr><name>JSMSG_UNMATCHED_RIGHT_PAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>out</name>;</goto>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>operatorStack</name><index>[<expr><name>i</name></expr>]</index></name>.<name>op</name> == <name>REOP_ASSERT</name> ||
                    <name><name>operatorStack</name><index>[<expr><name>i</name></expr>]</index></name>.<name>op</name> == <name>REOP_ASSERT_NOT</name> ||
                    <name><name>operatorStack</name><index>[<expr><name>i</name></expr>]</index></name>.<name>op</name> == <name>REOP_LPARENNON</name> ||
                    <name><name>operatorStack</name><index>[<expr><name>i</name></expr>]</index></name>.<name>op</name> == <name>REOP_LPAREN</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr>++<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>

            <comment type="block">/* Process everything on the stack until the open parenthesis. */</comment>
            <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>operatorSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>--<name>operatorSP</name></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name><name>operatorStack</name><index>[<expr><name>operatorSP</name></expr>]</index></name>.<name>op</name></expr>)</condition> <block>{
                  <case>case <expr><name>REOP_ASSERT</name></expr>:
                  </case><case>case <expr><name>REOP_ASSERT_NOT</name></expr>:
                  </case><case>case <expr><name>REOP_LPAREN</name></expr>:
                    <expr_stmt><expr><name>operand</name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>operatorStack</name><index>[<expr><name>operatorSP</name></expr>]</index></name>.<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>operand</name></expr>)</condition><then>
                        <goto>goto <name>out</name>;</goto></then></if>
                    <expr_stmt><expr><name><name>operand</name>-&gt;<name>u</name>.<name>parenIndex</name></name> =
                        <name><name>operatorStack</name><index>[<expr><name>operatorSP</name></expr>]</index></name>.<name>parenIndex</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>operandSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>operand</name>-&gt;<name>kid</name></name> = <name><name>operandStack</name><index>[<expr><name>operandSP</name> - 1</expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>operandStack</name><index>[<expr><name>operandSP</name> - 1</expr>]</index></name> = <name>operand</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>treeDepth</name></name> == <name>TREE_DEPTH_MAX</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                          <argument><expr><name>JSMSG_REGEXP_TOO_COMPLEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>out</name>;</goto>
                    }</block></then></if>
                    <expr_stmt><expr>++<name><name>state</name>-&gt;<name>treeDepth</name></name></expr>;</expr_stmt>
                    <comment type="block">/* FALL THROUGH */</comment>

                  </case><case>case <expr><name>REOP_LPARENNON</name></expr>:
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <name><name>operandStack</name><index>[<expr><name>operandSP</name> - 1</expr>]</index></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>ParseQuantifier</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <goto>goto <name>out</name>;</goto></then></if>
                    <expr_stmt><expr><name><name>operandStack</name><index>[<expr><name>operandSP</name> - 1</expr>]</index></name> = <name><name>state</name>-&gt;<name>result</name></name></expr>;</expr_stmt>
                    <goto>goto <name>restartOperator</name>;</goto>
                  </case><default>default:
                    <if>if <condition>(<expr>!<call><name>ProcessOp</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr>&amp;<name><name>operatorStack</name><index>[<expr><name>operatorSP</name></expr>]</index></name></expr></argument>,
                                   <argument><expr><name>operandStack</name></expr></argument>, <argument><expr><name>operandSP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <goto>goto <name>out</name>;</goto></then></if>
                    <expr_stmt><expr>--<name>operandSP</name></expr>;</expr_stmt>
                    <break>break;</break>
                </default>}</block></switch>
            }</block></for>
            <break>break;</break>

          </case><case>case <expr>'{'</expr>:
          <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>errp</name> <init>= <expr><name><name>state</name>-&gt;<name>cp</name></name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name>ParseMinMaxQuantifier</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <comment type="block">/*
                 * This didn't even scan correctly as a quantifier, so we should
                 * treat it as flat.
                 */</comment>
                <expr_stmt><expr><name>op</name> = <name>REOP_CONCAT</name></expr>;</expr_stmt>
                <goto>goto <name>pushOperator</name>;</goto>
            }</block></then></if>

            <expr_stmt><expr><name><name>state</name>-&gt;<name>cp</name></name> = <name>errp</name></expr>;</expr_stmt>
            <comment type="block">/* FALL THROUGH */</comment>
          }</block>

          </case><case>case <expr>'+'</expr>:
          </case><case>case <expr>'*'</expr>:
          </case><case>case <expr>'?'</expr>:
            <expr_stmt><expr><call><name>ReportRegExpErrorHelper</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_BAD_QUANTIFIER</name></expr></argument>,
                                    <argument><expr><name><name>state</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>

          </case><default>default:
            <comment type="block">/* Anything else is the start of the next term. */</comment>
            <expr_stmt><expr><name>op</name> = <name>REOP_CONCAT</name></expr>;</expr_stmt>
<label><name>pushOperator</name>:</label>
            <if>if <condition>(<expr><name>operatorSP</name> == <name>operatorStackSize</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>REOpData</name> *</type><name>tmp</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>operatorStackSize</name> += <name>operatorStackSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tmp</name> = (<name>REOpData</name> *)
                    <call><name><name>state</name>-&gt;<name>context</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>operatorStack</name></expr></argument>,
                                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>REOpData</name></expr></argument>)</argument_list></sizeof> * <name>operatorStackSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then>
                    <goto>goto <name>out</name>;</goto></then></if>
                <expr_stmt><expr><name>operatorStack</name> = <name>tmp</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>operatorStack</name><index>[<expr><name>operatorSP</name></expr>]</index></name>.<name>op</name> = <name>op</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>operatorStack</name><index>[<expr><name>operatorSP</name></expr>]</index></name>.<name>errPos</name> = <name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>operatorStack</name><index>[<expr><name>operatorSP</name>++</expr>]</index></name>.<name>parenIndex</name> = <name>parenIndex</name></expr>;</expr_stmt>
            <break>break;</break>
        </default>}</block></switch>
    }</block></for>
<label><name>out</name>:</label>
    <if>if <condition>(<expr><name>operatorStack</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>state</name>-&gt;<name>context</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>operatorStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>operandStack</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>state</name>-&gt;<name>context</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>operandStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Hack two bits in CompilerState.flags, for use within FindParenCount to flag
 * its being on the stack, and to propagate errors to its callers.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSREG_FIND_PAREN_COUNT</name></cpp:macro>  <cpp:value>0x8000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSREG_FIND_PAREN_ERROR</name></cpp:macro>  <cpp:value>0x4000</cpp:value></cpp:define>

<comment type="block">/*
 * Magic return value from FindParenCount and GetDecimalValue, to indicate
 * overflow beyond GetDecimalValue's max parameter, or a computed maximum if
 * its findMax parameter is non-null.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVERFLOW_VALUE</name></cpp:macro>          <cpp:value>((uintN)-1)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>uintN</name></type>
<name>FindParenCount</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>CompilerState</name></type> <name>temp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FIND_PAREN_COUNT</name></expr>)</condition><then>
        <return>return <expr><name>OVERFLOW_VALUE</name></expr>;</return></then></if>

    <comment type="block">/*
     * Copy state into temp, flag it so we never report an invalid backref,
     * and reset its members to parse the entire regexp.  This is obviously
     * suboptimal, but GetDecimalValue calls us only if a backref appears to
     * refer to a forward parenthetical, which is rare.
     */</comment>
    <expr_stmt><expr><name>temp</name> = *<name>state</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp</name>.<name>flags</name></name> |= <name>JSREG_FIND_PAREN_COUNT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp</name>.<name>cp</name></name> = <name><name>temp</name>.<name>cpbegin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp</name>.<name>parenCount</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp</name>.<name>classCount</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp</name>.<name>progLength</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp</name>.<name>treeDepth</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp</name>.<name>classBitmapsMem</name></name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>CLASS_CACHE_SIZE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>temp</name>.<name>classCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>start</name> = <name>NULL</name></expr>;</expr_stmt></for>

    <if>if <condition>(<expr>!<call><name>ParseRegExp</name><argument_list>(<argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>state</name>-&gt;<name>flags</name></name> |= <name>JSREG_FIND_PAREN_ERROR</name></expr>;</expr_stmt>
        <return>return <expr><name>OVERFLOW_VALUE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name><name>temp</name>.<name>parenCount</name></name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Extract and return a decimal value at state-&gt;cp.  The initial character c
 * has already been read.  Return OVERFLOW_VALUE if the result exceeds max.
 * Callers who pass a non-null findMax should test JSREG_FIND_PAREN_ERROR in
 * state-&gt;flags to discover whether an error occurred under findMax.
 */</comment>
<function><type><specifier>static</specifier> <name>uintN</name></type>
<name>GetDecimalValue</name><parameter_list>(<param><decl><type><name>jschar</name></type> <name>c</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>max</name></decl></param>, <param><function_decl><type><name>uintN</name></type> (*<name>findMax</name>)<parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>)</parameter_list></function_decl></param>,
                <param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>value</name> <init>= <expr><call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>overflow</name> <init>= <expr>(<name>value</name> &gt; <name>max</name> &amp;&amp; (!<name>findMax</name> || <name>value</name> &gt; <call><name>findMax</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call>))</expr></init></decl>;</decl_stmt>

    <comment type="block">/* The following restriction allows simpler overflow checks. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>max</name> &lt;= ((<name>uintN</name>)-1 - 9) / 10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> &lt; <name><name>state</name>-&gt;<name>cpend</name></name></expr>)</condition> <block>{
        <expr_stmt><expr><name>c</name> = *<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>JS7_ISDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <break>break;</break></then></if>
        <expr_stmt><expr><name>value</name> = 10 * <name>value</name> + <call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>overflow</name> &amp;&amp; <name>value</name> &gt; <name>max</name> &amp;&amp; (!<name>findMax</name> || <name>value</name> &gt; <call><name>findMax</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
            <expr_stmt><expr><name>overflow</name> = <name>JS_TRUE</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr>++<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>overflow</name> ? <name>OVERFLOW_VALUE</name> : <name>value</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Calculate the total size of the bitmap required for a class expression.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>CalculateBitmapSize</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>, <param><decl><type><name>RENode</name> *</type><name>target</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>src</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>end</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>max</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>inRange</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>rangeStart</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>digit</name></decl>, <decl><type ref="prev"/><name>nDigits</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>target</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>bmsize</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>target</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>sense</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>src</name> == <name>end</name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <if>if <condition>(<expr>*<name>src</name> == '^'</expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name>src</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>sense</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    }</block></then></if>

    <while>while <condition>(<expr><name>src</name> != <name>end</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>JSBool</name></type> <name>canStartRange</name> <init>= <expr><name>JS_TRUE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uintN</name></type> <name>localMax</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr>*<name>src</name></expr>)</condition> <block>{
          <case>case <expr>'\\'</expr>:
            <expr_stmt><expr>++<name>src</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> = *<name>src</name>++</expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
              <case>case <expr>'b'</expr>:
                <expr_stmt><expr><name>localMax</name> = 0x8</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'f'</expr>:
                <expr_stmt><expr><name>localMax</name> = 0xC</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'n'</expr>:
                <expr_stmt><expr><name>localMax</name> = 0xA</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'r'</expr>:
                <expr_stmt><expr><name>localMax</name> = 0xD</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'t'</expr>:
                <expr_stmt><expr><name>localMax</name> = 0x9</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'v'</expr>:
                <expr_stmt><expr><name>localMax</name> = 0xB</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'c'</expr>:
                <if>if <condition>(<expr><name>src</name> &lt; <name>end</name> &amp;&amp; <call><name>RE_IS_LETTER</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>localMax</name> = <call>(<name>uintN</name>) <argument_list>(<argument><expr>*<name>src</name>++</expr></argument>)</argument_list></call> &amp; 0x1F</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr>--<name>src</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>localMax</name> = '\\'</expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>
              </case><case>case <expr>'x'</expr>:
                <expr_stmt><expr><name>nDigits</name> = 2</expr>;</expr_stmt>
                <goto>goto <name>lexHex</name>;</goto>
              </case><case>case <expr>'u'</expr>:
                <expr_stmt><expr><name>nDigits</name> = 4</expr>;</expr_stmt>
<label><name>lexHex</name>:</label>
                <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr>(<name>i</name> &lt; <name>nDigits</name>) &amp;&amp; (<name>src</name> &lt; <name>end</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>c</name> = *<name>src</name>++</expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>isASCIIHexDigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>&amp;<name>digit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="block">/*
                         * Back off to accepting the original
                         *'\' as a literal.
                         */</comment>
                        <expr_stmt><expr><name>src</name> -= <name>i</name> + 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name>n</name> = '\\'</expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 4) | <name>digit</name></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><name>localMax</name> = <name>n</name></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'d'</expr>:
                <expr_stmt><expr><name>canStartRange</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>inRange</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>context</name></name></expr></argument>,
                                         <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>JSMSG_BAD_CLASS_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>localMax</name> = '9'</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'D'</expr>:
              </case><case>case <expr>'s'</expr>:
              </case><case>case <expr>'S'</expr>:
              </case><case>case <expr>'w'</expr>:
              </case><case>case <expr>'W'</expr>:
                <expr_stmt><expr><name>canStartRange</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>inRange</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>context</name></name></expr></argument>,
                                         <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>JSMSG_BAD_CLASS_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>max</name> = 65535</expr>;</expr_stmt>

                <comment type="block">/*
                 * If this is the start of a range, ensure that it's less than
                 * the end.
                 */</comment>
                <expr_stmt><expr><name>localMax</name> = 0</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'0'</expr>:
              </case><case>case <expr>'1'</expr>:
              </case><case>case <expr>'2'</expr>:
              </case><case>case <expr>'3'</expr>:
              </case><case>case <expr>'4'</expr>:
              </case><case>case <expr>'5'</expr>:
              </case><case>case <expr>'6'</expr>:
              </case><case>case <expr>'7'</expr>:
                <comment type="block">/*
                 *  This is a non-ECMA extension - decimal escapes (in this
                 *  case, octal!) are supposed to be an error inside class
                 *  ranges, but supported here for backwards compatibility.
                 *
                 */</comment>
                <expr_stmt><expr><name>n</name> = <call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>c</name> = *<name>src</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>'0' &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= '7'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>src</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name>n</name> = 8 * <name>n</name> + <call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>c</name> = *<name>src</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>'0' &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= '7'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>src</name>++</expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> = 8 * <name>n</name> + <call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>i</name> &lt;= 0377</expr>)</condition><then>
                            <expr_stmt><expr><name>n</name> = <name>i</name></expr>;</expr_stmt></then>
                        <else>else
                            <expr_stmt><expr><name>src</name>--</expr>;</expr_stmt></else></if>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>localMax</name> = <name>n</name></expr>;</expr_stmt>
                <break>break;</break>

              </case><default>default:
                <expr_stmt><expr><name>localMax</name> = <name>c</name></expr>;</expr_stmt>
                <break>break;</break>
            </default>}</block></switch>
            <break>break;</break>
          </case><default>default:
            <expr_stmt><expr><name>localMax</name> = *<name>src</name>++</expr>;</expr_stmt>
            <break>break;</break>
        </default>}</block></switch>

        <if>if <condition>(<expr><name>inRange</name></expr>)</condition><then> <block>{
            <comment type="block">/* Throw a SyntaxError here, per ECMA-262, 15.10.2.15. */</comment>
            <if>if <condition>(<expr><name>rangeStart</name> &gt; <name>localMax</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>context</name></name></expr></argument>,
                                     <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>JSMSG_BAD_CLASS_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>inRange</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>canStartRange</name> &amp;&amp; <name>src</name> &lt; <name>end</name> - 1</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>*<name>src</name> == '-'</expr>)</condition><then> <block>{
                    <expr_stmt><expr>++<name>src</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inRange</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rangeStart</name> = (<name>jschar</name>)<name>localMax</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name></expr>)</condition><then>
                <expr_stmt><expr><name>rangeStart</name> = <name>localMax</name></expr>;</expr_stmt></then></if>   <comment type="block">/* one run of the uc/dc loop below */</comment>
        }</block></else></if>

        <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jschar</name></type> <name>maxch</name> <init>= <expr><name>localMax</name></expr></init></decl>;</decl_stmt>

            <for>for (<init><expr><name>i</name> = <name>rangeStart</name></expr>;</init> <condition><expr><name>i</name> &lt;= <name>localMax</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>jschar</name></type> <name>uch</name></decl>, <decl><type ref="prev"/><name>dch</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>uch</name> = <call><name>upcase</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dch</name> = <call><name>inverse_upcase</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>maxch</name> = <call><name>JS_MAX</name><argument_list>(<argument><expr><name>maxch</name></expr></argument>, <argument><expr><name>uch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>maxch</name> = <call><name>JS_MAX</name><argument_list>(<argument><expr><name>maxch</name></expr></argument>, <argument><expr><name>dch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><name>localMax</name> = <name>maxch</name></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>localMax</name> &gt; <name>max</name></expr>)</condition><then>
            <expr_stmt><expr><name>max</name> = <name>localMax</name></expr>;</expr_stmt></then></if>
    }</block></while>
    <expr_stmt><expr><name><name>target</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>bmsize</name></name> = <name>max</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 *  item:       assertion               An item is either an assertion or
 *              quantatom               a quantified atom.
 *
 *  assertion:  '^'                     Assertions match beginning of string
 *                                      (or line if the class static property
 *                                      RegExp.multiline is true).
 *              '$'                     End of string (or line if the class
 *                                      static property RegExp.multiline is
 *                                      true).
 *              '\b'                    Word boundary (between \w and \W).
 *              '\B'                    Word non-boundary.
 *
 *  quantatom:  atom                    An unquantified atom.
 *              quantatom '{' n ',' m '}'
 *                                      Atom must occur between n and m times.
 *              quantatom '{' n ',' '}' Atom must occur at least n times.
 *              quantatom '{' n '}'     Atom must occur exactly n times.
 *              quantatom '*'           Zero or more times (same as {0,}).
 *              quantatom '+'           One or more times (same as {1,}).
 *              quantatom '?'           Zero or one time (same as {0,1}).
 *
 *              any of which can be optionally followed by '?' for ungreedy
 *
 *  atom:       '(' regexp ')'          A parenthesized regexp (what matched
 *                                      can be addressed using a backreference,
 *                                      see '\' n below).
 *              '.'                     Matches any char except '\n'.
 *              '[' classlist ']'       A character class.
 *              '[' '^' classlist ']'   A negated character class.
 *              '\f'                    Form Feed.
 *              '\n'                    Newline (Line Feed).
 *              '\r'                    Carriage Return.
 *              '\t'                    Horizontal Tab.
 *              '\v'                    Vertical Tab.
 *              '\d'                    A digit (same as [0-9]).
 *              '\D'                    A non-digit.
 *              '\w'                    A word character, [0-9a-z_A-Z].
 *              '\W'                    A non-word character.
 *              '\s'                    A whitespace character, [ \b\f\n\r\t\v].
 *              '\S'                    A non-whitespace character.
 *              '\' n                   A backreference to the nth (n decimal
 *                                      and positive) parenthesized expression.
 *              '\' octal               An octal escape sequence (octal must be
 *                                      two or three digits long, unless it is
 *                                      0 for the null character).
 *              '\x' hex                A hex escape (hex must be two digits).
 *              '\u' unicode            A unicode escape (must be four digits).
 *              '\c' ctrl               A control character, ctrl is a letter.
 *              '\' literalatomchar     Any character except one of the above
 *                                      that follow '\' in an atom.
 *              otheratomchar           Any character not first among the other
 *                                      atom right-hand sides.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ParseTerm</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jschar</name></type> <name>c</name> <init>= <expr>*<name><name>state</name>-&gt;<name>cp</name></name>++</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>nDigits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>termStart</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
    <comment type="block">/* assertions and atoms */</comment>
      <case>case <expr>'^'</expr>:
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_BOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name>++</expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
      </case><case>case <expr>'$'</expr>:
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_EOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name>++</expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
      </case><case>case <expr>'\\'</expr>:
        <if>if <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> &gt;= <name><name>state</name>-&gt;<name>cpend</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* a trailing '\' is an error */</comment>
            <expr_stmt><expr><call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_TRAILING_SLASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>c</name> = *<name><name>state</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
        <comment type="block">/* assertion escapes */</comment>
          <case>case <expr>'b'</expr> :
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_WBDRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name>++</expr>;</expr_stmt>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
          </case><case>case <expr>'B'</expr>:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_WNONBDRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name>++</expr>;</expr_stmt>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
          <comment type="block">/* Decimal escape */</comment>
          </case><case>case <expr>'0'</expr>:
            <comment type="block">/* Give a strict warning. See also the note below. */</comment>
            <if>if <condition>(<expr>!<call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_WARNING</name> | <name>JSREPORT_STRICT</name></expr></argument>,
                                   <argument><expr><name>JSMSG_INVALID_BACKREF</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
     <label><name>doOctal</name>:</label>
            <expr_stmt><expr><name>num</name> = 0</expr>;</expr_stmt>
            <while>while <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> &lt; <name><name>state</name>-&gt;<name>cpend</name></name></expr>)</condition> <block>{
                <expr_stmt><expr><name>c</name> = *<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>c</name> &lt; '0' || '7' &lt; <name>c</name></expr>)</condition><then>
                    <break>break;</break></then></if>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>tmp</name> = 8 * <name>num</name> + (<name>uintN</name>)<call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>tmp</name> &gt; 0377</expr>)</condition><then>
                    <break>break;</break></then></if>
                <expr_stmt><expr><name>num</name> = <name>tmp</name></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><name>c</name> = (<name>jschar</name>)<name>num</name></expr>;</expr_stmt>
    <label><name>doFlat</name>:</label>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_FLAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name> = <name>c</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 3</expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr>'1'</expr>:
          </case><case>case <expr>'2'</expr>:
          </case><case>case <expr>'3'</expr>:
          </case><case>case <expr>'4'</expr>:
          </case><case>case <expr>'5'</expr>:
          </case><case>case <expr>'6'</expr>:
          </case><case>case <expr>'7'</expr>:
          </case><case>case <expr>'8'</expr>:
          </case><case>case <expr>'9'</expr>:
            <expr_stmt><expr><name>termStart</name> = <name><name>state</name>-&gt;<name>cp</name></name> - 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>num</name> = <call><name>GetDecimalValue</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>parenCount</name></name></expr></argument>, <argument><expr><name>FindParenCount</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FIND_PAREN_ERROR</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name>num</name> == <name>OVERFLOW_VALUE</name></expr>)</condition><then> <block>{
                <comment type="block">/* Give a strict mode warning. */</comment>
                <if>if <condition>(<expr>!<call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
                                       <argument><expr><name>JSREPORT_WARNING</name> | <name>JSREPORT_STRICT</name></expr></argument>,
                                       <argument><expr>(<name>c</name> &gt;= '8')
                                       ? <name>JSMSG_INVALID_BACKREF</name>
                                       : <name>JSMSG_BAD_BACKREF</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>

                <comment type="block">/*
                 * Note: ECMA 262, 15.10.2.9 says that we should throw a syntax
                 * error here. However, for compatibility with IE, we treat the
                 * whole backref as flat if the first character in it is not a
                 * valid octal character, and as an octal escape otherwise.
                 */</comment>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>cp</name></name> = <name>termStart</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>c</name> &gt;= '8'</expr>)</condition><then> <block>{
                    <comment type="block">/* Treat this as flat. termStart - 1 is the \. */</comment>
                    <expr_stmt><expr><name>c</name> = '\\'</expr>;</expr_stmt>
                    <goto>goto <name>asFlat</name>;</goto>
                }</block></then></if>

                <comment type="block">/* Treat this as an octal escape. */</comment>
                <goto>goto <name>doOctal</name>;</goto>
            }</block></then></if>

            <comment type="block">/*
             * When FindParenCount calls the regex parser recursively (to find
             * the number of backrefs) num can be arbitrary and the maximum
             * supported number of backrefs does not bound it.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!(<name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FIND_PAREN_COUNT</name>)</expr></argument>,
                         <argument><expr>1 &lt;= <name>num</name> &amp;&amp; <name>num</name> &lt;= 0x10000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_BACKREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>parenIndex</name></name> = <name>num</name> - 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name>
                += 1 + <call><name>GetCompactIndexWidth</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>parenIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          <comment type="block">/* Control escape */</comment>
          </case><case>case <expr>'f'</expr>:
            <expr_stmt><expr><name>c</name> = 0xC</expr>;</expr_stmt>
            <goto>goto <name>doFlat</name>;</goto>
          </case><case>case <expr>'n'</expr>:
            <expr_stmt><expr><name>c</name> = 0xA</expr>;</expr_stmt>
            <goto>goto <name>doFlat</name>;</goto>
          </case><case>case <expr>'r'</expr>:
            <expr_stmt><expr><name>c</name> = 0xD</expr>;</expr_stmt>
            <goto>goto <name>doFlat</name>;</goto>
          </case><case>case <expr>'t'</expr>:
            <expr_stmt><expr><name>c</name> = 0x9</expr>;</expr_stmt>
            <goto>goto <name>doFlat</name>;</goto>
          </case><case>case <expr>'v'</expr>:
            <expr_stmt><expr><name>c</name> = 0xB</expr>;</expr_stmt>
            <goto>goto <name>doFlat</name>;</goto>
          <comment type="block">/* Control letter */</comment>
          </case><case>case <expr>'c'</expr>:
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> &lt; <name><name>state</name>-&gt;<name>cpend</name></name> &amp;&amp; <call><name>RE_IS_LETTER</name><argument_list>(<argument><expr>*<name><name>state</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>c</name> = <call>(<name>jschar</name>) <argument_list>(<argument><expr>*<name><name>state</name>-&gt;<name>cp</name></name>++ &amp; 0x1F</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <comment type="block">/* back off to accepting the original '\' as a literal */</comment>
                <expr_stmt><expr>--<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>c</name> = '\\'</expr>;</expr_stmt>
            }</block></else></if>
            <goto>goto <name>doFlat</name>;</goto>
          <comment type="block">/* HexEscapeSequence */</comment>
          </case><case>case <expr>'x'</expr>:
            <expr_stmt><expr><name>nDigits</name> = 2</expr>;</expr_stmt>
            <goto>goto <name>lexHex</name>;</goto>
          <comment type="block">/* UnicodeEscapeSequence */</comment>
          </case><case>case <expr>'u'</expr>:
            <expr_stmt><expr><name>nDigits</name> = 4</expr>;</expr_stmt>
<label><name>lexHex</name>:</label>
            <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nDigits</name> &amp;&amp; <name><name>state</name>-&gt;<name>cp</name></name> &lt; <name><name>state</name>-&gt;<name>cpend</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><name>uintN</name></type> <name>digit</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>c</name> = *<name><name>state</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>isASCIIHexDigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>&amp;<name>digit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * Back off to accepting the original 'u' or 'x' as a
                     * literal.
                     */</comment>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>cp</name></name> -= <name>i</name> + 2</expr>;</expr_stmt>
                    <expr_stmt><expr><name>n</name> = *<name><name>state</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 4) | <name>digit</name></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><name>c</name> = (<name>jschar</name>) <name>n</name></expr>;</expr_stmt>
            <goto>goto <name>doFlat</name>;</goto>
          <comment type="block">/* Character class escapes */</comment>
          </case><case>case <expr>'d'</expr>:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_DIGIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>doSimple</name>:</label>
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name>++</expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr>'D'</expr>:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_NONDIGIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>doSimple</name>;</goto>
          </case><case>case <expr>'s'</expr>:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_SPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>doSimple</name>;</goto>
          </case><case>case <expr>'S'</expr>:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_NONSPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>doSimple</name>;</goto>
          </case><case>case <expr>'w'</expr>:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_ALNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>doSimple</name>;</goto>
          </case><case>case <expr>'W'</expr>:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_NONALNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>doSimple</name>;</goto>
          <comment type="block">/* IdentityEscape */</comment>
          </case><default>default:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_FLAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name> = <name>c</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>kid</name></name> = (<name>void</name> *) (<name><name>state</name>-&gt;<name>cp</name></name> - 1)</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 3</expr>;</expr_stmt>
            <break>break;</break>
        </default>}</block></switch>
        <break>break;</break>
      </case><case>case <expr>'['</expr>:
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>termStart</name> = <name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>startIndex</name></name> = <name>termStart</name> - <name><name>state</name>-&gt;<name>cpbegin</name></name></expr>;</expr_stmt>
        <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> == <name><name>state</name>-&gt;<name>cpend</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ReportRegExpErrorHelper</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_UNTERM_CLASS</name></expr></argument>, <argument><expr><name>termStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr>*<name><name>state</name>-&gt;<name>cp</name></name> == '\\'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>state</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> != <name><name>state</name>-&gt;<name>cpend</name></name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>state</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt></then></if>
                <continue>continue;</continue>
            }</block></then></if>
            <if>if <condition>(<expr>*<name><name>state</name>-&gt;<name>cp</name></name> == ']'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>kidlen</name></name> = <name><name>state</name>-&gt;<name>cp</name></name> - <name>termStart</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></for>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>CLASS_CACHE_SIZE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>classCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>start</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>state</name>-&gt;<name>classCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>start</name> = <name>termStart</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>classCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name> = <name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>kidlen</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name>-&gt;<name>classCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>index</name> = <name><name>state</name>-&gt;<name>classCount</name></name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>state</name>-&gt;<name>classCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name> ==
                <name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>kidlen</name></name></expr>)</condition><then> <block>{
                <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
                    <if>if <condition>(<expr><name>n</name> == <name><name>state</name>-&gt;<name>classCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>length</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>index</name></name>
                            = <name><name>state</name>-&gt;<name>classCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>index</name></expr>;</expr_stmt>
                        <goto>goto <name>claim</name>;</goto>
                    }</block></then></if>
                    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>classCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>start</name><index>[<expr><name>n</name></expr>]</index></name> != <name><name>termStart</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition><then>
                        <break>break;</break></then></if>
                }</block></for>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>index</name></name> = <name><name>state</name>-&gt;<name>classCount</name></name>++</expr>;</expr_stmt>

    <label><name>claim</name>:</label>
        <comment type="block">/*
         * Call CalculateBitmapSize now as we want any errors it finds
         * to be reported during the parse phase, not at execution.
         */</comment>
        <if>if <condition>(<expr>!<call><name>CalculateBitmapSize</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>result</name></name></expr></argument>, <argument><expr><name>termStart</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>cp</name></name>++</expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <comment type="block">/*
         * Update classBitmapsMem with number of bytes to hold bmsize bits,
         * which is (bitsCount + 7) / 8 or (highest_bit + 1 + 7) / 8
         * or highest_bit / 8 + 1 where highest_bit is u.ucclass.bmsize.
         */</comment>
        <expr_stmt><expr><name>n</name> = (<name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>bmsize</name></name> &gt;&gt; 3) + 1</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>n</name> &gt; <name>CLASS_BITMAPS_MEM_LIMIT</name> - <name><name>state</name>-&gt;<name>classBitmapsMem</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_REGEXP_TOO_COMPLEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>classBitmapsMem</name></name> += <name>n</name></expr>;</expr_stmt>
        <comment type="block">/* CLASS, &lt;index&gt; */</comment>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name>
            += 1 + <call><name>GetCompactIndexWidth</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr>'.'</expr>:
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_DOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>doSimple</name>;</goto>

      </case><case>case <expr>'{'</expr>:
      <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>errp</name> <init>= <expr><name><name>state</name>-&gt;<name>cp</name></name>--</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>intN</name></type> <name>err</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>err</name> = <call><name>ParseMinMaxQuantifier</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>cp</name></name> = <name>errp</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
            <goto>goto <name>asFlat</name>;</goto></then></if>

        <comment type="block">/* FALL THROUGH */</comment>
      }</block>
      </case><case>case <expr>'*'</expr>:
      </case><case>case <expr>'+'</expr>:
      </case><case>case <expr>'?'</expr>:
        <expr_stmt><expr><call><name>ReportRegExpErrorHelper</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                <argument><expr><name>JSMSG_BAD_QUANTIFIER</name></expr></argument>, <argument><expr><name><name>state</name>-&gt;<name>cp</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
      </case><default>default:
<label><name>asFlat</name>:</label>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_FLAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name> = <name>c</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>kid</name></name> = (<name>void</name> *) (<name><name>state</name>-&gt;<name>cp</name></name> - 1)</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 3</expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>
    <return>return <expr><call><name>ParseQuantifier</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ParseQuantifier</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>RENode</name> *</type><name>term</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>term</name> = <name><name>state</name>-&gt;<name>result</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> &lt; <name><name>state</name>-&gt;<name>cpend</name></name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr>*<name><name>state</name>-&gt;<name>cp</name></name></expr>)</condition> <block>{
          <case>case <expr>'+'</expr>:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_QUANT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> = (<name>uintN</name>)-1</expr>;</expr_stmt>
            <comment type="block">/* &lt;PLUS&gt;, &lt;next&gt; ... &lt;ENDCHILD&gt; */</comment>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 4</expr>;</expr_stmt>
            <goto>goto <name>quantifier</name>;</goto>
          </case><case>case <expr>'*'</expr>:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_QUANT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> = (<name>uintN</name>)-1</expr>;</expr_stmt>
            <comment type="block">/* &lt;STAR&gt;, &lt;next&gt; ... &lt;ENDCHILD&gt; */</comment>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 4</expr>;</expr_stmt>
            <goto>goto <name>quantifier</name>;</goto>
          </case><case>case <expr>'?'</expr>:
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_QUANT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> = 1</expr>;</expr_stmt>
            <comment type="block">/* &lt;OPT&gt;, &lt;next&gt; ... &lt;ENDCHILD&gt; */</comment>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += 4</expr>;</expr_stmt>
            <goto>goto <name>quantifier</name>;</goto>
          </case><case>case <expr>'{'</expr>:       <comment type="block">/* balance '}' */</comment>
          <block>{
            <decl_stmt><decl><type><name>intN</name></type> <name>err</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>errp</name> <init>= <expr><name><name>state</name>-&gt;<name>cp</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>err</name> = <call><name>ParseMinMaxQuantifier</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
                <goto>goto <name>quantifier</name>;</goto></then></if>
            <if>if <condition>(<expr><name>err</name> == -1</expr>)</condition><then>
                <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

            <expr_stmt><expr><call><name>ReportRegExpErrorHelper</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>errp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
          }</block>
          </case><default>default:<empty_stmt>;</empty_stmt>
        </default>}</block></switch>
    }</block></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>

<label><name>quantifier</name>:</label>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>treeDepth</name></name> == <name>TREE_DEPTH_MAX</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_REGEXP_TOO_COMPLEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>++<name><name>state</name>-&gt;<name>treeDepth</name></name></expr>;</expr_stmt>
    <expr_stmt><expr>++<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>kid</name></name> = <name>term</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>cp</name></name> &lt; <name><name>state</name>-&gt;<name>cpend</name></name> &amp;&amp; *<name><name>state</name>-&gt;<name>cp</name></name> == '?'</expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>range</name>.<name>greedy</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>range</name>.<name>greedy</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>intN</name></type>
<name>ParseMinMaxQuantifier</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>ignoreValues</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>errp</name> <init>= <expr><name><name>state</name>-&gt;<name>cp</name></name>++</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>c</name> = *<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>JS7_ISDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>min</name> = <call><name>GetDecimalValue</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>0xFFFF</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> = *<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>ignoreValues</name> &amp;&amp; <name>min</name> == <name>OVERFLOW_VALUE</name></expr>)</condition><then>
            <return>return <expr><name>JSMSG_MIN_TOO_BIG</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name>c</name> == ','</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>c</name> = *++<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>JS7_ISDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>++<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>max</name> = <call><name>GetDecimalValue</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>0xFFFF</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>c</name> = *<name><name>state</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ignoreValues</name> &amp;&amp; <name>max</name> == <name>OVERFLOW_VALUE</name></expr>)</condition><then>
                    <return>return <expr><name>JSMSG_MAX_TOO_BIG</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<name>ignoreValues</name> &amp;&amp; <name>min</name> &gt; <name>max</name></expr>)</condition><then>
                    <return>return <expr><name>JSMSG_OUT_OF_ORDER</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>max</name> = (<name>uintN</name>)-1</expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>max</name> = <name>min</name></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><name>c</name> == '}'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REOP_QUANT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>result</name></name></expr>)</condition><then>
                <return>return <expr><name>JSMSG_OUT_OF_MEMORY</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> = <name>min</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>result</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> = <name>max</name></expr>;</expr_stmt>
            <comment type="block">/*
             * QUANT, &lt;min&gt;, &lt;max&gt;, &lt;next&gt; ... &lt;ENDCHILD&gt;
             * where &lt;max&gt; is written as compact(max+1) to make
             * (uintN)-1 sentinel to occupy 1 byte, not width_of(max)+1.
             */</comment>
            <expr_stmt><expr><name><name>state</name>-&gt;<name>progLength</name></name> += (1 + <call><name>GetCompactIndexWidth</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call>
                                  + <call><name>GetCompactIndexWidth</name><argument_list>(<argument><expr><name>max</name> + 1</expr></argument>)</argument_list></call>
                                  +3)</expr>;</expr_stmt>
            <return>return <expr>0</expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>state</name>-&gt;<name>cp</name></name> = <name>errp</name></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>SetForwardJumpOffset</name><parameter_list>(<param><decl><type><name>jsbytecode</name> *</type><name>jump</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>target</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name> <init>= <expr><name>target</name> - <name>jump</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check that target really points forward. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>offset</name> &gt;= 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>size_t</name>)<name>offset</name> &gt; <name>OFFSET_MAX</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>jump</name><index>[<expr>0</expr>]</index></name> = <call><name>JUMP_OFFSET_HI</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jump</name><index>[<expr>1</expr>]</index></name> = <call><name>JUMP_OFFSET_LO</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/* Copy the charset data from a character class node to the charset list
 * in the regexp object. */</comment>
<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>RECharSet</name> *</type>
<name>InitNodeCharSet</name><parameter_list>(<param><decl><type><name>JSRegExp</name> *</type><name>re</name></decl></param>, <param><decl><type><name>RENode</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>RECharSet</name> *</type><name>charSet</name> <init>= <expr>&amp;<name><name>re</name>-&gt;<name>classList</name><index>[<expr><name><name>node</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>index</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>charSet</name>-&gt;<name>converted</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>charSet</name>-&gt;<name>length</name></name> = <name><name>node</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>bmsize</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>charSet</name>-&gt;<name>u</name>.<name>src</name>.<name>startIndex</name></name> = <name><name>node</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>startIndex</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>charSet</name>-&gt;<name>u</name>.<name>src</name>.<name>length</name></name> = <name><name>node</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>kidlen</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>charSet</name>-&gt;<name>sense</name></name> = <name><name>node</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>sense</name></name></expr>;</expr_stmt>
    <return>return <expr><name>charSet</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Generate bytecode for the tree rooted at t using an explicit stack instead
 * of recursion.
 */</comment>
<function><type><specifier>static</specifier> <name>jsbytecode</name> *</type>
<name>EmitREBytecode</name><parameter_list>(<param><decl><type><name>CompilerState</name> *</type><name>state</name></decl></param>, <param><decl><type><name>JSRegExp</name> *</type><name>re</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>treeDepth</name></decl></param>,
               <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>RENode</name> *</type><name>t</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EmitStateStackEntry</name> *</type><name>emitStateSP</name></decl>, *<decl><type ref="prev"/><name>emitStateStack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>REOp</name></type> <name>op</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>treeDepth</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>emitStateStack</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>emitStateStack</name> =
            (<name>EmitStateStackEntry</name> *)
            <call><name><name>state</name>-&gt;<name>context</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EmitStateStackEntry</name></expr></argument>)</argument_list></sizeof> * <name>treeDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>emitStateStack</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></else></if>
    <expr_stmt><expr><name>emitStateSP</name> = <name>emitStateStack</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> = <name><name>t</name>-&gt;<name>op</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> &lt; <name>REOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr>*<name>pc</name>++ = <name>op</name></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
          <case>case <expr><name>REOP_EMPTY</name></expr>:
            <expr_stmt><expr>--<name>pc</name></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr><name>REOP_ALTPREREQ2</name></expr>:
          </case><case>case <expr><name>REOP_ALTPREREQ</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>emitStateSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>altHead</name></name> = <name>pc</name> - 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>endTermFixup</name></name> = <name>pc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>OFFSET_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET_ARG</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name>-&gt;<name>u</name>.<name>altprereq</name>.<name>ch1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET_ARG</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name>-&gt;<name>u</name>.<name>altprereq</name>.<name>ch2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>nextAltFixup</name></name> = <name>pc</name></expr>;</expr_stmt>    <comment type="block">/* offset to next alternate */</comment>
            <expr_stmt><expr><name>pc</name> += <name>OFFSET_LEN</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueNode</name></name> = <name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueOp</name></name> = <name>REOP_JUMP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>jumpToJumpFlag</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>emitStateSP</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>emitStateSP</name> - <name>emitStateStack</name></expr></argument>)</argument_list></call> &lt;= <name>treeDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> = (<name>RENode</name> *) <name><name>t</name>-&gt;<name>kid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = <name><name>t</name>-&gt;<name>op</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> &lt; <name>REOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>

          </case><case>case <expr><name>REOP_JUMP</name></expr>:
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>nextTermFixup</name></name> = <name>pc</name></expr>;</expr_stmt>    <comment type="block">/* offset to following term */</comment>
            <expr_stmt><expr><name>pc</name> += <name>OFFSET_LEN</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>SetForwardJumpOffset</name><argument_list>(<argument><expr><name><name>emitStateSP</name>-&gt;<name>nextAltFixup</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>jump_too_big</name>;</goto></then></if>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueOp</name></name> = <name>REOP_ENDALT</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>emitStateSP</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>emitStateSP</name> - <name>emitStateStack</name></expr></argument>)</argument_list></call> &lt;= <name>treeDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> = (<name>RENode</name> *) <name><name>t</name>-&gt;<name>u</name>.<name>kid2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = <name><name>t</name>-&gt;<name>op</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> &lt; <name>REOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>

          </case><case>case <expr><name>REOP_ENDALT</name></expr>:
            <comment type="block">/*
             * If we already patched emitStateSP-&gt;nextTermFixup to jump to
             * a nearer jump, to avoid 16-bit immediate offset overflow, we
             * are done here.
             */</comment>
            <if>if <condition>(<expr><name><name>emitStateSP</name>-&gt;<name>jumpToJumpFlag</name></name></expr>)</condition><then>
                <break>break;</break></then></if>

            <comment type="block">/*
             * Fix up the REOP_JUMP offset to go to the op after REOP_ENDALT.
             * REOP_ENDALT is executed only on successful match of the last
             * alternate in a group.
             */</comment>
            <if>if <condition>(<expr>!<call><name>SetForwardJumpOffset</name><argument_list>(<argument><expr><name><name>emitStateSP</name>-&gt;<name>nextTermFixup</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>jump_too_big</name>;</goto></then></if>
            <if>if <condition>(<expr><name><name>t</name>-&gt;<name>op</name></name> != <name>REOP_ALT</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>SetForwardJumpOffset</name><argument_list>(<argument><expr><name><name>emitStateSP</name>-&gt;<name>endTermFixup</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>jump_too_big</name>;</goto></then></if>
            }</block></then></if>

            <comment type="block">/*
             * If the program is bigger than the REOP_JUMP offset range, then
             * we must check for alternates before this one that are part of
             * the same group, and fix up their jump offsets to target jumps
             * close enough to fit in a 16-bit unsigned offset immediate.
             */</comment>
            <if>if <condition>(<expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>pc</name> - <name><name>re</name>-&gt;<name>program</name></name></expr></argument>)</argument_list></call> &gt; <name>OFFSET_MAX</name> &amp;&amp;
                <name>emitStateSP</name> &gt; <name>emitStateStack</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>EmitStateStackEntry</name> *</type><name>esp</name></decl>, *<decl><type ref="prev"/><name>esp2</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>alt</name></decl>, *<decl><type ref="prev"/><name>jump</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>span</name></decl>, <decl><type ref="prev"/><name>header</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>esp2</name> = <name>emitStateSP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>alt</name> = <name><name>esp2</name>-&gt;<name>altHead</name></name></expr>;</expr_stmt>
                <for>for (<init><expr><name>esp</name> = <name>esp2</name> - 1</expr>;</init> <condition><expr><name>esp</name> &gt;= <name>emitStateStack</name></expr>;</condition> <incr><expr>--<name>esp</name></expr></incr>) <block>{
                    <if>if <condition>(<expr><name><name>esp</name>-&gt;<name>continueOp</name></name> == <name>REOP_ENDALT</name> &amp;&amp;
                        !<name><name>esp</name>-&gt;<name>jumpToJumpFlag</name></name> &amp;&amp;
                        <name><name>esp</name>-&gt;<name>nextTermFixup</name></name> + <name>OFFSET_LEN</name> == <name>alt</name> &amp;&amp;
                        <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>pc</name> - ((<name><name>esp</name>-&gt;<name>continueNode</name>-&gt;<name>op</name></name> != <name>REOP_ALT</name>)
                                       ? <name><name>esp</name>-&gt;<name>endTermFixup</name></name>
                                       : <name><name>esp</name>-&gt;<name>nextTermFixup</name></name>)</expr></argument>)</argument_list></call> &gt; <name>OFFSET_MAX</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>alt</name> = <name><name>esp</name>-&gt;<name>altHead</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>jump</name> = <name><name>esp</name>-&gt;<name>nextTermFixup</name></name></expr>;</expr_stmt>

                        <comment type="block">/*
                         * The span must be 1 less than the distance from
                         * jump offset to jump offset, so we actually jump
                         * to a REOP_JUMP bytecode, not to its offset!
                         */</comment>
                        <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
                            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>jump</name> &lt; <name><name>esp2</name>-&gt;<name>nextTermFixup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>span</name> = <name><name>esp2</name>-&gt;<name>nextTermFixup</name></name> - <name>jump</name> - 1</expr>;</expr_stmt>
                            <if>if <condition>(<expr>(<name>size_t</name>)<name>span</name> &lt;= <name>OFFSET_MAX</name></expr>)</condition><then>
                                <break>break;</break></then></if>
                            <do>do <block>{
                                <if>if <condition>(<expr>--<name>esp2</name> == <name>esp</name></expr>)</condition><then>
                                    <goto>goto <name>jump_too_big</name>;</goto></then></if>
                            }</block> while <condition>(<expr><name><name>esp2</name>-&gt;<name>continueOp</name></name> != <name>REOP_ENDALT</name></expr>)</condition>;</do>
                        }</block></for>

                        <expr_stmt><expr><name><name>jump</name><index>[<expr>0</expr>]</index></name> = <call><name>JUMP_OFFSET_HI</name><argument_list>(<argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>jump</name><index>[<expr>1</expr>]</index></name> = <call><name>JUMP_OFFSET_LO</name><argument_list>(<argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if>if <condition>(<expr><name><name>esp</name>-&gt;<name>continueNode</name>-&gt;<name>op</name></name> != <name>REOP_ALT</name></expr>)</condition><then> <block>{
                            <comment type="block">/*
                             * We must patch the offset at esp-&gt;endTermFixup
                             * as well, for the REOP_ALTPREREQ{,2} opcodes.
                             * If we're unlucky and endTermFixup is more than
                             * OFFSET_MAX bytes from its target, we cheat by
                             * jumping 6 bytes to the jump whose offset is at
                             * esp-&gt;nextTermFixup, which has the same target.
                             */</comment>
                            <expr_stmt><expr><name>jump</name> = <name><name>esp</name>-&gt;<name>endTermFixup</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>header</name> = <name><name>esp</name>-&gt;<name>nextTermFixup</name></name> - <name>jump</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>span</name> += <name>header</name></expr>;</expr_stmt>
                            <if>if <condition>(<expr>(<name>size_t</name>)<name>span</name> &gt; <name>OFFSET_MAX</name></expr>)</condition><then>
                                <expr_stmt><expr><name>span</name> = <name>header</name></expr>;</expr_stmt></then></if>

                            <expr_stmt><expr><name><name>jump</name><index>[<expr>0</expr>]</index></name> = <call><name>JUMP_OFFSET_HI</name><argument_list>(<argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>jump</name><index>[<expr>1</expr>]</index></name> = <call><name>JUMP_OFFSET_LO</name><argument_list>(<argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <expr_stmt><expr><name><name>esp</name>-&gt;<name>jumpToJumpFlag</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></then></if>
            <break>break;</break>

          </case><case>case <expr><name>REOP_ALT</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>emitStateSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>altHead</name></name> = <name>pc</name> - 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>nextAltFixup</name></name> = <name>pc</name></expr>;</expr_stmt>     <comment type="block">/* offset to next alternate */</comment>
            <expr_stmt><expr><name>pc</name> += <name>OFFSET_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueNode</name></name> = <name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueOp</name></name> = <name>REOP_JUMP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>jumpToJumpFlag</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>emitStateSP</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>emitStateSP</name> - <name>emitStateStack</name></expr></argument>)</argument_list></call> &lt;= <name>treeDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> = (<name>RENode</name> *) <name><name>t</name>-&gt;<name>kid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = <name><name>t</name>-&gt;<name>op</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> &lt; <name>REOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>

          </case><case>case <expr><name>REOP_FLAT</name></expr>:
            <comment type="block">/*
             * Coalesce FLATs if possible and if it would not increase bytecode
             * beyond preallocated limit. The latter happens only when bytecode
             * size for coalesced string with offset p and length 2 exceeds 6
             * bytes preallocated for 2 single char nodes, i.e. when
             * 1 + GetCompactIndexWidth(p) + GetCompactIndexWidth(2) &gt; 6 or
             * GetCompactIndexWidth(p) &gt; 4.
             * Since when GetCompactIndexWidth(p) &lt;= 4 coalescing of 3 or more
             * nodes strictly decreases bytecode size, the check has to be
             * done only for the first coalescing.
             */</comment>
            <if>if <condition>(<expr><name><name>t</name>-&gt;<name>kid</name></name> &amp;&amp;
                <call><name>GetCompactIndexWidth</name><argument_list>(<argument><expr>(<name>jschar</name> *)<name><name>t</name>-&gt;<name>kid</name></name> - <name><name>state</name>-&gt;<name>cpbegin</name></name></expr></argument>)</argument_list></call> &lt;= 4</expr>)</condition><then>
            <block>{
                <while>while <condition>(<expr><name><name>t</name>-&gt;<name>next</name></name> &amp;&amp;
                       <name><name>t</name>-&gt;<name>next</name>-&gt;<name>op</name></name> == <name>REOP_FLAT</name> &amp;&amp;
                       (<name>jschar</name>*)<name><name>t</name>-&gt;<name>kid</name></name> + <name><name>t</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> ==
                       (<name>jschar</name>*)<name><name>t</name>-&gt;<name>next</name>-&gt;<name>kid</name></name></expr>)</condition> <block>{
                    <expr_stmt><expr><name><name>t</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> += <name><name>t</name>-&gt;<name>next</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>t</name>-&gt;<name>next</name></name> = <name><name>t</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
                }</block></while>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>t</name>-&gt;<name>kid</name></name> &amp;&amp; <name><name>t</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> &gt; 1</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pc</name><index>[<expr>-1</expr>]</index></name> = (<name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name>) ? <name>REOP_FLATi</name> : <name>REOP_FLAT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> = <call><name>WriteCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>(<name>jschar</name> *)<name><name>t</name>-&gt;<name>kid</name></name> - <name><name>state</name>-&gt;<name>cpbegin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> = <call><name>WriteCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>t</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name> &lt; 256</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pc</name><index>[<expr>-1</expr>]</index></name> = (<name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name>) ? <name>REOP_FLAT1i</name> : <name>REOP_FLAT1</name></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>pc</name>++ = (<name>jsbytecode</name>) <name><name>t</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name><name>pc</name><index>[<expr>-1</expr>]</index></name> = (<name><name>state</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name>)
                         ? <name>REOP_UCFLAT1i</name>
                         : <name>REOP_UCFLAT1</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SET_ARG</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>
            }</block></else></if></else></if>
            <break>break;</break>

          </case><case>case <expr><name>REOP_LPAREN</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>emitStateSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> = <call><name>WriteCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name>-&gt;<name>u</name>.<name>parenIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueNode</name></name> = <name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueOp</name></name> = <name>REOP_RPAREN</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>emitStateSP</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>emitStateSP</name> - <name>emitStateStack</name></expr></argument>)</argument_list></call> &lt;= <name>treeDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> = (<name>RENode</name> *) <name><name>t</name>-&gt;<name>kid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = <name><name>t</name>-&gt;<name>op</name></name></expr>;</expr_stmt>
            <continue>continue;</continue>

          </case><case>case <expr><name>REOP_RPAREN</name></expr>:
            <expr_stmt><expr><name>pc</name> = <call><name>WriteCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name>-&gt;<name>u</name>.<name>parenIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr><name>REOP_BACKREF</name></expr>:
            <expr_stmt><expr><name>pc</name> = <call><name>WriteCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name>-&gt;<name>u</name>.<name>parenIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr><name>REOP_ASSERT</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>emitStateSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>nextTermFixup</name></name> = <name>pc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>OFFSET_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueNode</name></name> = <name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueOp</name></name> = <name>REOP_ASSERTTEST</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>emitStateSP</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>emitStateSP</name> - <name>emitStateStack</name></expr></argument>)</argument_list></call> &lt;= <name>treeDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> = (<name>RENode</name> *) <name><name>t</name>-&gt;<name>kid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = <name><name>t</name>-&gt;<name>op</name></name></expr>;</expr_stmt>
            <continue>continue;</continue>

          </case><case>case <expr><name>REOP_ASSERTTEST</name></expr>:
          </case><case>case <expr><name>REOP_ASSERTNOTTEST</name></expr>:
            <if>if <condition>(<expr>!<call><name>SetForwardJumpOffset</name><argument_list>(<argument><expr><name><name>emitStateSP</name>-&gt;<name>nextTermFixup</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>jump_too_big</name>;</goto></then></if>
            <break>break;</break>

          </case><case>case <expr><name>REOP_ASSERT_NOT</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>emitStateSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>nextTermFixup</name></name> = <name>pc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>OFFSET_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueNode</name></name> = <name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueOp</name></name> = <name>REOP_ASSERTNOTTEST</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>emitStateSP</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>emitStateSP</name> - <name>emitStateStack</name></expr></argument>)</argument_list></call> &lt;= <name>treeDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> = (<name>RENode</name> *) <name><name>t</name>-&gt;<name>kid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = <name><name>t</name>-&gt;<name>op</name></name></expr>;</expr_stmt>
            <continue>continue;</continue>

          </case><case>case <expr><name>REOP_QUANT</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>emitStateSP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> == 0 &amp;&amp; <name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> == (<name>uintN</name>)-1</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pc</name><index>[<expr>-1</expr>]</index></name> = (<name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>greedy</name></name>) ? <name>REOP_STAR</name> : <name>REOP_MINIMALSTAR</name></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> == 0 &amp;&amp; <name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> == 1</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pc</name><index>[<expr>-1</expr>]</index></name> = (<name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>greedy</name></name>) ? <name>REOP_OPT</name> : <name>REOP_MINIMALOPT</name></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> == 1 &amp;&amp; <name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> == (<name>uintN</name>) -1</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pc</name><index>[<expr>-1</expr>]</index></name> = (<name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>greedy</name></name>) ? <name>REOP_PLUS</name> : <name>REOP_MINIMALPLUS</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!<name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>greedy</name></name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>pc</name><index>[<expr>-1</expr>]</index></name> = <name>REOP_MINIMALQUANT</name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>pc</name> = <call><name>WriteCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * Write max + 1 to avoid using size_t(max) + 1 bytes
                 * for (uintN)-1 sentinel.
                 */</comment>
                <expr_stmt><expr><name>pc</name> = <call><name>WriteCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if></else></if>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>nextTermFixup</name></name> = <name>pc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>OFFSET_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueNode</name></name> = <name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>emitStateSP</name>-&gt;<name>continueOp</name></name> = <name>REOP_ENDCHILD</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>emitStateSP</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>emitStateSP</name> - <name>emitStateStack</name></expr></argument>)</argument_list></call> &lt;= <name>treeDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> = (<name>RENode</name> *) <name><name>t</name>-&gt;<name>kid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = <name><name>t</name>-&gt;<name>op</name></name></expr>;</expr_stmt>
            <continue>continue;</continue>

          </case><case>case <expr><name>REOP_ENDCHILD</name></expr>:
            <if>if <condition>(<expr>!<call><name>SetForwardJumpOffset</name><argument_list>(<argument><expr><name><name>emitStateSP</name>-&gt;<name>nextTermFixup</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>jump_too_big</name>;</goto></then></if>
            <break>break;</break>

          </case><case>case <expr><name>REOP_CLASS</name></expr>:
            <if>if <condition>(<expr>!<name><name>t</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>sense</name></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>pc</name><index>[<expr>-1</expr>]</index></name> = <name>REOP_NCLASS</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>pc</name> = <call><name>WriteCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>InitNodeCharSet</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><default>default:
            <break>break;</break>
        </default>}</block></switch>

        <expr_stmt><expr><name>t</name> = <name><name>t</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>t</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>op</name> = <name><name>t</name>-&gt;<name>op</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>emitStateSP</name> == <name>emitStateStack</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr>--<name>emitStateSP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> = <name><name>emitStateSP</name>-&gt;<name>continueNode</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = (<name>REOp</name>) <name><name>emitStateSP</name>-&gt;<name>continueOp</name></name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>

  <label><name>cleanup</name>:</label>
    <if>if <condition>(<expr><name>emitStateStack</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>state</name>-&gt;<name>context</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>emitStateStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>pc</name></expr>;</return>

  <label><name>jump_too_big</name>:</label>
    <expr_stmt><expr><call><name>ReportRegExpError</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>, <argument><expr><name>JSMSG_REGEXP_TOO_COMPLEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> = <name>NULL</name></expr>;</expr_stmt>
    <goto>goto <name>cleanup</name>;</goto>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>CompileRegExpToAST</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name>*</type> <name>ts</name></decl></param>,
                   <param><decl><type><name>JSString</name>*</type> <name>str</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><name>CompilerState</name>&amp;</type> <name>state</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>len</name> = <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>state</name>.<name>context</name></name> = <name>cx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>tokenStream</name></name> = <name>ts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>cp</name></name> = <call><name>js_UndependString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>state</name>.<name>cp</name></name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>state</name>.<name>cpbegin</name></name> = <name><name>state</name>.<name>cp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>cpend</name></name> = <name><name>state</name>.<name>cp</name></name> + <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>flags</name></name> = <name>flags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>parenCount</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>classCount</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>progLength</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>treeDepth</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>classBitmapsMem</name></name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>CLASS_CACHE_SIZE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>state</name>.<name>classCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>start</name> = <name>NULL</name></expr>;</expr_stmt></for>

    <if>if <condition>(<expr><name>len</name> != 0 &amp;&amp; (<name>flags</name> &amp; <name>JSREG_FLAT</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>state</name>.<name>result</name></name> = <call><name>NewRENode</name><argument_list>(<argument><expr>&amp;<name>state</name></expr></argument>, <argument><expr><name>REOP_FLAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>state</name>.<name>result</name></name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>state</name>.<name>result</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name> = *<name><name>state</name>.<name>cpbegin</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>.<name>result</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> = <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name>.<name>result</name>-&gt;<name>kid</name></name> = (<name>void</name> *) <name><name>state</name>.<name>cpbegin</name></name></expr>;</expr_stmt>
        <comment type="block">/* Flat bytecode: REOP_FLAT compact(string_offset) compact(len). */</comment>
        <expr_stmt><expr><name><name>state</name>.<name>progLength</name></name> += 1 + <call><name>GetCompactIndexWidth</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
                          + <call><name>GetCompactIndexWidth</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>ParseRegExp</name><argument_list>(<argument><expr>&amp;<name>state</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
<typedef>typedef <type><name><name>js</name>::<name><name>Vector</name><argument_list>&lt;<argument><expr><name>LIns</name> *</expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name><name>js</name>::<name>ContextAllocPolicy</name></name></expr></argument>&gt;</argument_list></name></name></type> <name>LInsList</name>;</typedef>

<namespace>namespace <name>js</name> <block>{

<struct>struct <name>REFragment</name> <super>: <specifier>public</specifier> <name><name>nanojit</name>::<name>Fragment</name></name></super>
<block>{<public type="default">
    <macro><name>REFragment</name><argument_list>(<argument>const void* _ip verbose_only(, uint32_t profFragID)</argument>)</argument_list></macro>
      : <constructor><name><name>nanojit</name>::<name>Fragment</name></name><parameter_list>(<param><function_decl><type><name>ip</name></type> <name>verbose_only</name><parameter_list>(<param/>, <param><decl><type><name>profFragID</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
    <block>{}</block></constructor>
</public>}</block>;</struct>

}</block></namespace> <comment type="block">/* namespace js */</comment>

<comment type="block">/* Return the cached fragment for the given regexp, or create one. */</comment>
<function><type><specifier>static</specifier> <name>Fragment</name>*</type>
<name>LookupNativeRegExp</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>uint16</name></type> <name>re_flags</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>jschar</name>*</type> <name>re_chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>re_length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceMonitor</name> *</type><name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMAllocator</name> &amp;</type><name>alloc</name> <init>= <expr>*<name><name>tm</name>-&gt;<name>dataAlloc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>REHashMap</name> &amp;</type><name>table</name> <init>= <expr>*<name><name>tm</name>-&gt;<name>reFragments</name></name></expr></init></decl>;</decl_stmt>

    <function_decl><type><name>REHashKey</name></type> <name>k</name><parameter_list>(<param><decl><type><name>re_length</name></type></decl></param>, <param><decl><type><name>re_flags</name></type></decl></param>, <param><decl><type><name>re_chars</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>REFragment</name> *</type><name>frag</name> <init>= <expr><call><name><name>table</name>.<name>get</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>frag</name></expr>)</condition><then> <block>{
        <macro><name>verbose_only</name><argument_list>(
        <argument>uint32_t profFragID = (LogController.lcbits &amp; LC_FragProfile)
                              ? (++(tm-&gt;lastFragID)) : 0;</argument>
        )</argument_list></macro>
        <expr_stmt><expr><name>frag</name> = new (<name>alloc</name>) <call><name>REFragment</name><argument_list>(<argument><expr>0 <call><name>verbose_only</name><argument_list>(, <argument><expr><name>profFragID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Copy the re_chars portion of the hash key into the Allocator, so
         * its lifecycle is disconnected from the lifecycle of the
         * underlying regexp.
         */</comment>
        <expr_stmt><expr><name><name>k</name>.<name>re_chars</name></name> = (const <name>jschar</name>*) new (<name>alloc</name>) <name><name>jschar</name><index>[<expr><name>re_length</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>void</name>*) <name><name>k</name>.<name>re_chars</name></name></expr></argument>, <argument><expr><name>re_chars</name></expr></argument>, <argument><expr><name>re_length</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>table</name>.<name>put</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>frag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>frag</name></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ProcessCharSet</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSRegExp</name> *</type><name>re</name></decl></param>, <param><decl><type><name>RECharSet</name> *</type><name>charSet</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Utilities for the RegExpNativeCompiler */</comment>

<namespace>namespace <block>{
  <comment type="block">/*
   * An efficient way to simultaneously statically guard that the sizeof(bool) is a
   * small power of 2 and take its log2.
   */</comment>
  <template>template <parameter_list>&lt;<param><type><name>int</name></type></param>&gt;</parameter_list> <struct>struct <name>StaticLog2</name> <block>{<public type="default"/>}</block>;</struct></template>
  <template>template <parameter_list>&lt;&gt;</parameter_list> <struct>struct <name><name>StaticLog2</name><argument_list>&lt;<argument><expr>1</expr></argument>&gt;</argument_list></name> <block>{<public type="default"> <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> </public>}</block>;</struct></template>
  <template>template <parameter_list>&lt;&gt;</parameter_list> <struct>struct <name><name>StaticLog2</name><argument_list>&lt;<argument><expr>2</expr></argument>&gt;</argument_list></name> <block>{<public type="default"> <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>result</name> <init>= <expr>1</expr></init></decl>;</decl_stmt> </public>}</block>;</struct></template>
  <template>template <parameter_list>&lt;&gt;</parameter_list> <struct>struct <name><name>StaticLog2</name><argument_list>&lt;<argument><expr>4</expr></argument>&gt;</argument_list></name> <block>{<public type="default"> <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>result</name> <init>= <expr>2</expr></init></decl>;</decl_stmt> </public>}</block>;</struct></template>
  <template>template <parameter_list>&lt;&gt;</parameter_list> <struct>struct <name><name>StaticLog2</name><argument_list>&lt;<argument><expr>8</expr></argument>&gt;</argument_list></name> <block>{<public type="default"> <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>result</name> <init>= <expr>3</expr></init></decl>;</decl_stmt> </public>}</block>;</struct></template>
}</block></namespace>

<comment type="block">/*
 * This table allows efficient testing for the ASCII portion of \s during a
 * trace. ECMA-262 15.10.2.12 defines the following characters below 128 to be
 * whitespace: 0x9 (0), 0xA (10), 0xB (11), 0xC (12), 0xD (13), 0x20 (32). The
 * index must be &lt;= 32.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>js_ws</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/*       0      1      2      3      4      5      5      7      8      9      */</comment>
<comment type="block">/*  0 */</comment> <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>true</expr>,
<comment type="block">/*  1 */</comment> <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>true</expr>,  <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>,
<comment type="block">/*  2 */</comment> <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>, <expr>false</expr>,
<comment type="block">/*  3 */</comment> <expr>false</expr>, <expr>false</expr>, <expr>true</expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Sets of characters are described in terms of individuals and classes. */</comment>
<class>class <name>CharSet</name> <block>{<private type="default">
  </private><public>public:
    <constructor><name>CharSet</name><parameter_list>()</parameter_list> <member_list>: <call><name>charEnd</name><argument_list>(<argument><expr><name>charBuf</name></expr></argument>)</argument_list></call>, <call><name>classes</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uintN</name></type> <name>sBufSize</name> <init>= <expr>8</expr></init></decl>;</decl_stmt>

    <function><type><name>bool</name></type> <name>full</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>charEnd</name> == <name>charBuf</name> + <name>sBufSize</name></expr>;</return> }</block></function>

    <comment type="block">/* Add a single char to the set. */</comment>
    <function><type><name>bool</name></type> <name>addChar</name><parameter_list>(<param><decl><type><name>jschar</name></type> <name>c</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name>full</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr>*<name>charEnd</name>++ = <name>c</name></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <enum>enum <name>Class</name> <block>{
        <decl><name>LineTerms</name>  <init>= <expr>1 &lt;&lt; 0</expr></init></decl>,  <comment type="block">/* Line Terminators (E262 7.3) */</comment>
        <decl><name>OtherSpace</name> <init>= <expr>1 &lt;&lt; 1</expr></init></decl>,  <comment type="block">/* \s (E262 15.10.2.12) - LineTerms */</comment>
        <decl><name>Digit</name>      <init>= <expr>1 &lt;&lt; 2</expr></init></decl>,  <comment type="block">/* \d (E262 15.10.2.12) */</comment>
        <decl><name>OtherAlnum</name> <init>= <expr>1 &lt;&lt; 3</expr></init></decl>,  <comment type="block">/* \w (E262 15,10.2.12) - Digit */</comment>
        <decl><name>Other</name>      <init>= <expr>1 &lt;&lt; 4</expr></init></decl>,  <comment type="block">/* all other characters */</comment>
        <decl><name>All</name>        <init>= <expr><name>LineTerms</name> | <name>OtherSpace</name> | <name>Digit</name> | <name>OtherAlnum</name> | <name>Other</name></expr></init></decl>,

        <decl><name>Space</name> <init>= <expr><name>LineTerms</name> | <name>OtherSpace</name></expr></init></decl>,
        <decl><name>AlNum</name> <init>= <expr><name>Digit</name> | <name>OtherAlnum</name></expr></init></decl>,
        <decl><name>Dot</name>   <init>= <expr><name>All</name> &amp; ~<name>LineTerms</name></expr></init></decl>
    }</block>;</enum>

    <comment type="block">/* Add a set of chars to the set. */</comment>
    <function><type><name>void</name></type> <name>addClass</name><parameter_list>(<param><decl><type><name>Class</name></type> <name>c</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>classes</name> |= <name>c</name></expr>;</expr_stmt> }</block></function>

    <comment type="block">/* Return whether two sets of chars are disjoint. */</comment>
    <function_decl><type><name>bool</name></type> <name>disjoint</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>CharSet</name> &amp;</decl></param>)</parameter_list> <specifier>const</specifier>;</function_decl>

  </public><private>private:
    <function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>disjoint</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>beg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>end</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>classes</name></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><specifier>mutable</specifier> <name>jschar</name></type> <name><name>charBuf</name><index>[<expr><name>sBufSize</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>charEnd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>classes</name></decl>;</decl_stmt>
</private>}</block>;</class>

<comment type="block">/* Appease the type checker. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>CharSet</name>::<name>Class</name></name></type>
<name>operator|</name><parameter_list>(<param><decl><type><name><name>CharSet</name>::<name>Class</name></name></type> <name>c1</name></decl></param>, <param><decl><type><name><name>CharSet</name>::<name>Class</name></name></type> <name>c2</name></decl></param>)</parameter_list> <block>{
    <return>return <expr><call>(<name><name>CharSet</name>::<name>Class</name></name>)<argument_list>(<argument><expr>((<name>int</name>)<name>c1</name>) | ((<name>int</name>)<name>c2</name>)</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>CharSet</name>::<name>Class</name></name></type>
<name>operator~</name><parameter_list>(<param><decl><type><name><name>CharSet</name>::<name>Class</name></name></type> <name>c</name></decl></param>)</parameter_list> <block>{
    <return>return <expr><call>(<name><name>CharSet</name>::<name>Class</name></name>)<argument_list>(<argument><expr>~(<name>int</name>)<name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Return whether the characters in the range [beg, end) fall within any of the
 * classes with a bit set in 'classes'.
 */</comment>
<function><type><name>bool</name></type>
<name><name>CharSet</name>::<name>disjoint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>beg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>end</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>classes</name></decl></param>)</parameter_list>
<block>{
    <for>for (<init><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>p</name> <init>= <expr><name>beg</name></expr></init></decl>;</init> <condition><expr><name>p</name> != <name>end</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>JS7_ISDEC</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>classes</name> &amp; <name>Digit</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>JS_ISWORD</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>classes</name> &amp; <name>OtherAlnum</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>RE_IS_LINE_TERM</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>classes</name> &amp; <name>LineTerms</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>JS_ISSPACE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>classes</name> &amp; <name>OtherSpace</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>classes</name> &amp; <name>Other</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></else></if></else></if></else></if></else></if>
    }</block></for>
    <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/*
 * Predicate version of the STL's set_intersection. Assumes both ranges are
 * sorted and thus runs in linear time.
 *
 * FIXME: This is a reusable algorithm, perhaps it should be put somewhere.
 */</comment>
<template>template <parameter_list>&lt;<param><type><name>class</name></type> <name>InputIterator1</name></param>, <param><type><name>class</name></type> <name>InputIterator2</name></param>&gt;</parameter_list>
<function><type><name>bool</name></type>
<name>set_disjoint</name><parameter_list>(<param><decl><type><name>InputIterator1</name></type> <name>p1</name></decl></param>, <param><decl><type><name>InputIterator1</name></type> <name>end1</name></decl></param>,
             <param><decl><type><name>InputIterator2</name></type> <name>p2</name></decl></param>, <param><decl><type><name>InputIterator2</name></type> <name>end2</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>p1</name> == <name>end1</name> || <name>p2</name> == <name>end2</name></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>
    <while>while <condition>(<expr>*<name>p1</name> != *<name>p2</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>*<name>p1</name> &lt; *<name>p2</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>++<name>p1</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>p1</name> == <name>end1</name></expr>)</condition><then>
                <return>return <expr>true</expr>;</return></then></if>
        }</block></then> <else>else <if>if <condition>(<expr>*<name>p2</name> &lt; *<name>p1</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>++<name>p2</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>p2</name> == <name>end2</name></expr>)</condition><then>
                <return>return <expr>true</expr>;</return></then></if>
        }</block></then></if></else></if>
    }</block></while>
    <return>return <expr>false</expr>;</return>
}</block></function></template>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>CharCmp</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>arg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>a</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>b</name></decl></param>, <param><decl><type><name>int</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jschar</name></type> <name>ca</name> <init>= <expr>*(<name>jschar</name> *)<name>a</name></expr></init>, <name>cb</name> <init>= <expr>*(<name>jschar</name> *)<name>b</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>result</name> = <name>ca</name> - <name>cb</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>bool</name></type>
<name><name>CharSet</name>::<name>disjoint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CharSet</name> &amp;</type><name>other</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <comment type="block">/* Check overlap between classes. */</comment>
    <if>if <condition>(<expr><name>classes</name> &amp; <name><name>other</name>.<name>classes</name></name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <comment type="block">/*
     * Check char-class overlap. Compare this-&gt;charBuf with other.classes and
     * vice versa with a loop.
     */</comment>
    <if>if <condition>(<expr>!<call><name>disjoint</name><argument_list>(<argument><expr><name><name>this</name>-&gt;<name>charBuf</name></name></expr></argument>, <argument><expr><name><name>this</name>-&gt;<name>charEnd</name></name></expr></argument>, <argument><expr><name><name>other</name>.<name>classes</name></name></expr></argument>)</argument_list></call> ||
        !<call><name>disjoint</name><argument_list>(<argument><expr><name><name>other</name>.<name>charBuf</name></name></expr></argument>, <argument><expr><name><name>other</name>.<name>charEnd</name></name></expr></argument>, <argument><expr><name><name>this</name>-&gt;<name>classes</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <comment type="block">/* Check char-char overlap. */</comment>
    <decl_stmt><decl><type><name>jschar</name></type> <name><name>tmp</name><index>[<expr><name><name>CharSet</name>::<name>sBufSize</name></name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>js_MergeSort</name><argument_list>(<argument><expr><name>charBuf</name></expr></argument>, <argument><expr><name>charEnd</name> - <name>charBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                 <argument><expr><name>CharCmp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_MergeSort</name><argument_list>(<argument><expr><name><name>other</name>.<name>charBuf</name></name></expr></argument>, <argument><expr><name><name>other</name>.<name>charEnd</name></name> - <name><name>other</name>.<name>charBuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                 <argument><expr><name>CharCmp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>set_disjoint</name><argument_list>(<argument><expr><name>charBuf</name></expr></argument>, <argument><expr><name>charEnd</name></expr></argument>, <argument><expr><name><name>other</name>.<name>charBuf</name></name></expr></argument>, <argument><expr><name><name>other</name>.<name>charEnd</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Return true if the given subexpression may match the empty string. The
 * conservative answer is |true|. If |next| is true, then the subexpression is
 * considered to be |node| followed by the rest of |node-&gt;next|. Otherwise, the
 * subexpression is considered to be |node| by itself.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>mayMatchEmpty</name><parameter_list>(<param><decl><type><name>RENode</name> *</type><name>node</name></decl></param>, <param><decl><type><name>bool</name></type> <name>next</name> <init>= <expr>true</expr></init></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>node</name></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>
    <switch>switch <condition>(<expr><name><name>node</name>-&gt;<name>op</name></name></expr>)</condition> <block>{
      <case>case <expr><name>REOP_EMPTY</name></expr>:  <return>return <expr>true</expr>;</return>
      </case><case>case <expr><name>REOP_FLAT</name></expr>:   <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>REOP_CLASS</name></expr>:  <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>REOP_ALNUM</name></expr>:  <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>REOP_ALT</name></expr>:    <return>return <expr>(<call><name>mayMatchEmpty</name><argument_list>(<argument><expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>kid</name></name></expr></argument>)</argument_list></call> ||
                                <call><name>mayMatchEmpty</name><argument_list>(<argument><expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>u</name>.<name>kid2</name></name></expr></argument>)</argument_list></call>) &amp;&amp;
                               (!<name>next</name> || <call><name>mayMatchEmpty</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>next</name></name></expr></argument>)</argument_list></call>)</expr>;</return>
      </case><case>case <expr><name>REOP_QUANT</name></expr>:  <return>return <expr>(<name><name>node</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> == 0 ||
                                <call><name>mayMatchEmpty</name><argument_list>(<argument><expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>kid</name></name></expr></argument>)</argument_list></call>) &amp;&amp;
                               (!<name>next</name> || <call><name>mayMatchEmpty</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>next</name></name></expr></argument>)</argument_list></call>)</expr>;</return>
      </case><default>default:          <return>return <expr>true</expr>;</return>
    </default>}</block></switch>
}</block></function>

<comment type="block">/*
 * Enumerate the set of characters that may be consumed next by the given
 * subexpression in isolation. Return whether the enumeration was successful.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>enumerateNextChars</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>RENode</name> *</type><name>node</name></decl></param>, <param><decl><type><name>CharSet</name> &amp;</type><name>set</name></decl></param>)</parameter_list>
<block>{
    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return JS_FALSE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <if>if <condition>(<expr>!<name>node</name></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>

    <switch>switch <condition>(<expr><name><name>node</name>-&gt;<name>op</name></name></expr>)</condition> <block>{
      <comment type="block">/* Record as bitflags. */</comment>
      <case>case <expr><name>REOP_DOT</name></expr>:       <expr_stmt><expr><call><name><name>set</name>.<name>addClass</name></name><argument_list>(<argument><expr><name><name>CharSet</name>::<name>Dot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     <return>return <expr>true</expr>;</return>
      </case><case>case <expr><name>REOP_DIGIT</name></expr>:     <expr_stmt><expr><call><name><name>set</name>.<name>addClass</name></name><argument_list>(<argument><expr><name><name>CharSet</name>::<name>Digit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <return>return <expr>true</expr>;</return>
      </case><case>case <expr><name>REOP_NONDIGIT</name></expr>:  <expr_stmt><expr><call><name><name>set</name>.<name>addClass</name></name><argument_list>(<argument><expr>~<name><name>CharSet</name>::<name>Digit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <return>return <expr>true</expr>;</return>
      </case><case>case <expr><name>REOP_ALNUM</name></expr>:     <expr_stmt><expr><call><name><name>set</name>.<name>addClass</name></name><argument_list>(<argument><expr><name><name>CharSet</name>::<name>AlNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <return>return <expr>true</expr>;</return>
      </case><case>case <expr><name>REOP_NONALNUM</name></expr>:  <expr_stmt><expr><call><name><name>set</name>.<name>addClass</name></name><argument_list>(<argument><expr>~<name><name>CharSet</name>::<name>AlNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <return>return <expr>true</expr>;</return>
      </case><case>case <expr><name>REOP_SPACE</name></expr>:     <expr_stmt><expr><call><name><name>set</name>.<name>addClass</name></name><argument_list>(<argument><expr><name><name>CharSet</name>::<name>Space</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <return>return <expr>true</expr>;</return>
      </case><case>case <expr><name>REOP_NONSPACE</name></expr>:  <expr_stmt><expr><call><name><name>set</name>.<name>addClass</name></name><argument_list>(<argument><expr>~<name><name>CharSet</name>::<name>Space</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <return>return <expr>true</expr>;</return>

      <comment type="block">/* Record as individual characters. */</comment>
      </case><case>case <expr><name>REOP_FLAT</name></expr>:
        <return>return <expr><call><name><name>set</name>.<name>addChar</name></name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name></expr></argument>)</argument_list></call></expr>;</return>

      <comment type="block">/* Control structures. */</comment>
      </case><case>case <expr><name>REOP_EMPTY</name></expr>:
        <return>return <expr>true</expr>;</return>
      </case><case>case <expr><name>REOP_ALT</name></expr>:
      </case><case>case <expr><name>REOP_ALTPREREQ</name></expr>:
        <return>return <expr><call><name>enumerateNextChars</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>kid</name></name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call> &amp;&amp;
               <call><name>enumerateNextChars</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>u</name>.<name>kid2</name></name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call> &amp;&amp;
               (!<call><name>mayMatchEmpty</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call> ||
                <call><name>enumerateNextChars</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call>)</expr>;</return>
      </case><case>case <expr><name>REOP_QUANT</name></expr>:
        <return>return <expr><call><name>enumerateNextChars</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>kid</name></name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call> &amp;&amp;
               (!<call><name>mayMatchEmpty</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call> ||
                <call><name>enumerateNextChars</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call>)</expr>;</return>

      <comment type="block">/* Arbitrary character classes and oddities. */</comment>
      </case><default>default:
        <return>return <expr>false</expr>;</return>
    </default>}</block></switch>
}</block></function>

<class>class <name>RegExpNativeCompiler</name> <block>{<private type="default">
 </private><private>private:
    <decl_stmt><decl><type><name>VMAllocator</name>&amp;</type>     <name>tempAlloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name>*</type>       <name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRegExp</name>*</type>        <name>re</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CompilerState</name>*</type>   <name>cs</name></decl>;</decl_stmt>            <comment type="block">/* RegExp to compile */</comment>
    <decl_stmt><decl><type><name>Fragment</name>*</type>        <name>fragment</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LirWriter</name>*</type>       <name>lir</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>LirWriter</name>*</type>       <name>validate_writer</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NJ_VERBOSE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>LirWriter</name>*</type>       <name>verbose_filter</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>LirBufWriter</name>*</type>    <name>lirBufWriter</name></decl>;</decl_stmt>  <comment type="block">/* for skip */</comment>

    <decl_stmt><decl><type><name>LIns</name>*</type>            <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type>            <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type>            <name>cpend</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>LirBuffer</name>* <specifier>const</specifier></type> <name>lirbuf</name></decl>;</decl_stmt>

    <function><type><name>bool</name></type> <name>outOfMemory</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><call><name><name>tempAlloc</name>.<name>outOfMemory</name></name><argument_list>()</argument_list></call> || <call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<call><name><name>dataAlloc</name>-&gt;<name>outOfMemory</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><name>JSBool</name></type> <name>isCaseInsensitive</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr>(<name><name>cs</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name>) != 0</expr>;</return> }</block></function>

    <function><type><name>void</name></type> <name>targetCurrentPoint</name><parameter_list>(<param><decl><type><name>LIns</name> *</type><name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>ins</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>targetCurrentPoint</name><parameter_list>(<param><decl><type><name>LInsList</name> &amp;</type><name>fails</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>LIns</name> *</type><name>fail</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>fails</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <expr_stmt><expr><name><name>fails</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<call><name>setTarget</name><argument_list>(<argument><expr><name>fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>fails</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     * These functions return the new position after their match operation,
     * or NULL if there was an error.
     */</comment>
    <function><type><name>LIns</name>*</type> <name>compileEmpty</name><parameter_list>(<param><decl><type><name>RENode</name>*</type> <name>node</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>pos</name></decl></param>, <param><decl><type><name>LInsList</name>&amp;</type> <name>fails</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><name>pos</name></expr>;</return>
    }</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AVMPLUS_ARM</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>AVMPLUS_SPARC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* We can't do this on ARM or SPARC, since it relies on doing a 32-bit load from
 * a pointer which is only 2-byte aligned.
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>USE_DOUBLE_CHAR_MATCH</name></cpp:undef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_DOUBLE_CHAR_MATCH</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><name>LIns</name>*</type> <name>compileFlatSingleChar</name><parameter_list>(<param><decl><type><name>jschar</name></type> <name>ch</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>pos</name></decl></param>, <param><decl><type><name>LInsList</name>&amp;</type> <name>fails</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>to_fail</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_plt</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>cpend</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><name>to_fail</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>text_ch</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldcs</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Extra characters that need to be compared against when doing folding.</comment>
        <struct>struct <name>extra</name> <block>{<public type="default">
            <decl_stmt><decl><type><name>jschar</name></type> <name>ch</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name>   *</type><name>match</name></decl>;</decl_stmt>
        </public>}</block>;</struct>
        <decl_stmt><decl><type><name>extra</name></type> <name><name>extras</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>   <name>nextras</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>cs</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ch</name> = <call><name>JS_TOUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>jschar</name></type> <name>lch</name> <init>= <expr><call><name>inverse_upcase</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>ch</name> != <name>lch</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>L'A' &lt;= <name>ch</name> &amp;&amp; <name>ch</name> &lt;= L'Z'</expr>)</condition><then> <block>{
                    <comment type="line">// Fast conversion of text character to lower case by OR-ing with 32.</comment>
                    <expr_stmt><expr><name>text_ch</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_or</name></expr></argument>, <argument><expr><name>text_ch</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// These ASCII letters have 2 lower-case forms. We put the ASCII one in</comment>
                    <comment type="line">// |extras| so it is tested first, because we expect that to be the common</comment>
                    <comment type="line">// case. Note that the code points of the non-ASCII forms both have the</comment>
                    <comment type="line">// 32 bit set, so it is OK to compare against the OR-32-converted text char.</comment>
                    <expr_stmt><expr><name>ch</name> = <name>lch</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>ch</name> == L'i'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = <name>ch</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ch</name> = 0x131</expr>;</expr_stmt>
                    }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == L's'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = <name>ch</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ch</name> = 0x17f</expr>;</expr_stmt>
                    }</block></then></if></else></if>
                    <goto>goto <name>gen</name>;</goto>
                }</block></then> <else>else <if>if <condition>(<expr>0x01c4 &lt;= <name>ch</name> &amp;&amp; <name>ch</name> &lt;= 0x1e60</expr>)</condition><then> <block>{
                    <comment type="line">// The following group of conditionals handles characters that have 1 or 2</comment>
                    <comment type="line">// lower-case forms in addition to JS_TOLOWER(ch).</comment>
                    <if>if <condition>(<expr><name>ch</name> &lt;= 0x1f1</expr>)</condition><then> <block>{                 <comment type="line">// DZ,LJ,NJ</comment>
                        <if>if <condition>(<expr><name>ch</name> == 0x01c4</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x01c5</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x01c7</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x01c8</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x01ca</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x01cb</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x01f1</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x01f2</expr>;</expr_stmt>
                        }</block></then></if></else></if></else></if></else></if>
                    }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> &lt; 0x0392</expr>)</condition><then> <block>{          <comment type="line">// no extra lower-case forms in this range</comment>
                    }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> &lt;= 0x03a6</expr>)</condition><then> <block>{         <comment type="line">// Greek</comment>
                        <if>if <condition>(<expr><name>ch</name> == 0x0392</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x03d0</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x0395</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x03f5</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x0398</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x03d1</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x0399</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x0345</expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x1fbe</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x039a</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x03f0</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x039c</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0xb5</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x03a0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x03d6</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x03a1</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x03f1</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x03a3</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x03c2</expr>;</expr_stmt>
                        }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x03a6</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x03d5</expr>;</expr_stmt>
                        }</block></then></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
                    }</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == 0x1e60</expr>)</condition><then> <block>{         <comment type="line">// S with dot above</comment>
                        <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = 0x1e9b</expr>;</expr_stmt>
                    }</block></then></if></else></if></else></if></else></if>
                }</block></then></if></else></if>

                <expr_stmt><expr><name><name>extras</name><index>[<expr><name>nextras</name>++</expr>]</index></name>.<name>ch</name> = <name>lch</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

    <label><name>gen</name>:</label>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>nextras</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>LIns</name> *</type><name>test</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>text_ch</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name><name>extras</name><index>[<expr><name>i</name></expr>]</index></name>.<name>ch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>branch</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>extras</name><index>[<expr><name>i</name></expr>]</index></name>.<name>match</name> = <name>branch</name></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>text_ch</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>nextras</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
            <expr_stmt><expr><call><name>targetCurrentPoint</name><argument_list>(<argument><expr><name><name>extras</name><index>[<expr><name>i</name></expr>]</index></name>.<name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmWord</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><name>JS_INLINE</name> <name>bool</name></type> <name>hasCases</name><parameter_list>(<param><decl><type><name>jschar</name></type> <name>ch</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>JS_TOLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> != <call><name>JS_TOUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><name>LIns</name>*</type> <name>compileFlatDoubleChar</name><parameter_list>(<param><decl><type><name>jschar</name></type> <name>ch1</name></decl></param>, <param><decl><type><name>jschar</name></type> <name>ch2</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>pos</name></decl></param>, <param><decl><type><name>LInsList</name>&amp;</type> <name>fails</name></decl></param>)</parameter_list>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IS_BIG_ENDIAN</name></cpp:ifdef>
        <decl_stmt><decl><type><name>uint32</name></type> <name>word</name> <init>= <expr>(<name>ch1</name> &lt;&lt; 16) | <name>ch2</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <decl_stmt><decl><type><name>uint32</name></type> <name>word</name> <init>= <expr>(<name>ch2</name> &lt;&lt; 16) | <name>ch1</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Fast case-insensitive test for ASCII letters: convert text
         * char to lower case by bit-or-ing in 32 and compare.
         */</comment>
        <decl_stmt><decl><type><name>JSBool</name></type> <name>useFastCI</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>
        <union>union <block>{<public type="default"> <decl_stmt><decl><type><name>jschar</name></type> <name><name>c</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt> <decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt> </public>}</block> <decl><name>mask</name></decl>;</union>
        <if>if <condition>(<expr><name><name>cs</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jschar</name></type> <name>uch1</name> <init>= <expr><call><name>JS_TOUPPER</name><argument_list>(<argument><expr><name>ch1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jschar</name></type> <name>uch2</name> <init>= <expr><call><name>JS_TOUPPER</name><argument_list>(<argument><expr><name>ch2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSBool</name></type> <name>mask1</name> <init>= <expr>(L'A' &lt;= <name>uch1</name> &amp;&amp; <name>uch1</name> &lt;= L'Z' &amp;&amp; <name>uch1</name> != L'I' &amp;&amp; <name>uch1</name> != L'S')</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSBool</name></type> <name>mask2</name> <init>= <expr>(L'A' &lt;= <name>uch2</name> &amp;&amp; <name>uch2</name> &lt;= L'Z' &amp;&amp; <name>uch2</name> != L'I' &amp;&amp; <name>uch2</name> != L'S')</expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>(!<name>mask1</name> &amp;&amp; <call><name>hasCases</name><argument_list>(<argument><expr><name>ch1</name></expr></argument>)</argument_list></call>) || (!<name>mask2</name> &amp;&amp; <call><name>hasCases</name><argument_list>(<argument><expr><name>ch2</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pos</name> = <call><name>compileFlatSingleChar</name><argument_list>(<argument><expr><name>ch1</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pos</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
                <return>return <expr><call><name>compileFlatSingleChar</name><argument_list>(<argument><expr><name>ch2</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name><name>mask</name>.<name>c</name><index>[<expr>0</expr>]</index></name> = <name>mask1</name> ? 0x0020 : 0x0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mask</name>.<name>c</name><index>[<expr>1</expr>]</index></name> = <name>mask2</name> ? 0x0020 : 0x0</expr>;</expr_stmt>

            <if>if <condition>(<expr><name><name>mask</name>.<name>i</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>word</name> |= <name><name>mask</name>.<name>i</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>useFastCI</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>to_fail</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>,
                                       <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_plt</name></expr></argument>,
                                                 <argument><expr><name>pos</name></expr></argument>,
                                                 <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>,
                                                           <argument><expr><name>cpend</name></expr></argument>,
                                                           <argument><expr><call><name><name>lir</name>-&gt;<name>insImmWord</name></name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><name>to_fail</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>text_word</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>comp_word</name> <init>= <expr><name>useFastCI</name> ?
            <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_or</name></expr></argument>, <argument><expr><name>text_word</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name><name>mask</name>.<name>i</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> :
            <name>text_word</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>comp_word</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <return>return <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmWord</name></name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><name>LIns</name>*</type> <name>compileFlat</name><parameter_list>(<param><decl><type><name>RENode</name> *&amp;</type><name>node</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>pos</name></decl></param>, <param><decl><type><name>LInsList</name>&amp;</type> <name>fails</name></decl></param>)</parameter_list>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DOUBLE_CHAR_MATCH</name></cpp:ifdef>
        <if>if <condition>(<expr><name><name>node</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> == 1</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>node</name>-&gt;<name>next</name></name> &amp;&amp; <name><name>node</name>-&gt;<name>next</name>-&gt;<name>op</name></name> == <name>REOP_FLAT</name> &amp;&amp;
                <name><name>node</name>-&gt;<name>next</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> == 1</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pos</name> = <call><name>compileFlatDoubleChar</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name></expr></argument>,
                                            <argument><expr><name><name>node</name>-&gt;<name>next</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name></expr></argument>,
                                            <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>pos</name> = <call><name>compileFlatSingleChar</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <return>return <expr><name>pos</name></expr>;</return>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>node</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> - 1</expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
                <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <return>return <expr>0</expr>;</return></then></if>
                <expr_stmt><expr><name>pos</name> = <call><name>compileFlatDoubleChar</name><argument_list>(<argument><expr>((<name>jschar</name>*) <name><name>node</name>-&gt;<name>kid</name></name>)<index>[<expr><name>i</name></expr>]</index></expr></argument>,
                                            <argument><expr>((<name>jschar</name>*) <name><name>node</name>-&gt;<name>kid</name></name>)<index>[<expr><name>i</name>+1</expr>]</index></expr></argument>,
                                            <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pos</name></expr>)</condition><then>
                    <return>return <expr>0</expr>;</return></then></if>
            }</block></for>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pos</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>i</name> == <name><name>node</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> - 1</expr>)</condition><then>
                <expr_stmt><expr><name>pos</name> = <call><name>compileFlatSingleChar</name><argument_list>(<argument><expr>((<name>jschar</name>*) <name><name>node</name>-&gt;<name>kid</name></name>)<index>[<expr><name>i</name></expr>]</index></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <return>return <expr><name>pos</name></expr>;</return>
        }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if>if <condition>(<expr><name><name>node</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name> == 1</expr>)</condition><then> <block>{
            <return>return <expr><call><name>compileFlatSingleChar</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>u</name>.<name>flat</name>.<name>chr</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>node</name>-&gt;<name>u</name>.<name>flat</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <return>return <expr>0</expr>;</return></then></if>
                <expr_stmt><expr><name>pos</name> = <call><name>compileFlatSingleChar</name><argument_list>(<argument><expr>((<name>jschar</name>*) <name><name>node</name>-&gt;<name>kid</name></name>)<index>[<expr><name>i</name></expr>]</index></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>pos</name></expr>)</condition><then>
                    <return>return <expr>0</expr>;</return></then></if>
            }</block></for>
            <return>return <expr><name>pos</name></expr>;</return>
        }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></function>

    <function><type><name>LIns</name>*</type> <name>compileClass</name><parameter_list>(<param><decl><type><name>RENode</name>*</type> <name>node</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>pos</name></decl></param>, <param><decl><type><name>LInsList</name>&amp;</type> <name>fails</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<name><name>node</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>sense</name></name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <comment type="block">/*
         * If we share generated native code, we need to make a copy
         * of the bitmap because the original regexp's copy is destroyed when
         * that regexp is.
         */</comment>
        <decl_stmt><decl><type><name>RECharSet</name> *</type><name>charSet</name> <init>= <expr>&amp;<name><name>re</name>-&gt;<name>classList</name><index>[<expr><name><name>node</name>-&gt;<name>u</name>.<name>ucclass</name>.<name>index</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>bitmapLen</name> <init>= <expr>(<name><name>charSet</name>-&gt;<name>length</name></name> &gt;&gt; 3) + 1</expr></init></decl>;</decl_stmt>
        <comment type="block">/* Arbitrary size limit on bitmap. */</comment>
        <if>if <condition>(<expr><name>bitmapLen</name> &gt; 1024</expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <decl_stmt><decl><type><name>Allocator</name> &amp;</type><name>alloc</name> <init>= <expr>*<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>dataAlloc</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* The following line allocates charSet.u.bits if successful. */</comment>
        <if>if <condition>(<expr>!<name><name>charSet</name>-&gt;<name>converted</name></name> &amp;&amp; !<call><name>ProcessCharSet</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>charSet</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <decl_stmt><decl><type><name>void</name>*</type> <name>bitmapData</name> <init>= <expr><call><name><name>alloc</name>.<name>alloc</name></name><argument_list>(<argument><expr><name>bitmapLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bitmapData</name></expr></argument>, <argument><expr><name><name>charSet</name>-&gt;<name>u</name>.<name>bits</name></name></expr></argument>, <argument><expr><name>bitmapLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>to_fail</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_plt</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>cpend</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><name>to_fail</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>text_ch</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldcs</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>,
                                         <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_le</name></expr></argument>, <argument><expr><name>text_ch</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name><name>charSet</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>byteIndex</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins_i2p</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_rsh</name></expr></argument>, <argument><expr><name>text_ch</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>bitmap</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insImmPtr</name></name><argument_list>(<argument><expr><name>bitmapData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>byte</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldcb</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>bitmap</name></expr></argument>, <argument><expr><name>byteIndex</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>int</name>) 0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>bitMask</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_lsh</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_and</name></expr></argument>, <argument><expr><name>text_ch</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x7</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>test</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_and</name></expr></argument>, <argument><expr><name>byte</name></expr></argument>, <argument><expr><name>bitMask</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>to_next</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><name>to_next</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <return>return <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmWord</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/* Factor out common code to index js_alnum. */</comment>
    <function><type><name>LIns</name> *</type><name>compileTableRead</name><parameter_list>(<param><decl><type><name>LIns</name> *</type><name>chr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>bool</name> *</type><name>tbl</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> != 1</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name> *</type><name>sizeLog2</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>StaticLog2</name>&lt;<sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof>&gt;<name>::<name>result</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>chr</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_lsh</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><name>sizeLog2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>addr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmPtr</name></name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_u2p</name></name><argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldcb</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/* Compile a builtin character class. */</comment>
    <function><type><name>LIns</name> *</type><name>compileBuiltinClass</name><parameter_list>(<param><decl><type><name>RENode</name> *</type><name>node</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>pos</name></decl></param>, <param><decl><type><name>LInsList</name> &amp;</type><name>fails</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/* All the builtins checked below consume one character. */</comment>
        <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_plt</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>cpend</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>chr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldcs</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>node</name>-&gt;<name>op</name></name></expr>)</condition> <block>{
          <case>case <expr><name>REOP_DOT</name></expr>:
          <block>{
            <comment type="block">/* Accept any character except those in ECMA-262 15.10.2.8. */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq1</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>'\n'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq2</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>'\r'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq3</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>LINE_SEPARATOR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq3</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq4</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>PARA_SEPARATOR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq4</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <break>break;</break>
          }</block>
          </case><case>case <expr><name>REOP_DIGIT</name></expr>:
          <block>{
            <decl_stmt><decl><type><name>LIns</name> *</type><name>ge</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ge</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>'0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><name>ge</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>le</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_le</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>'9'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><name>le</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <break>break;</break>
          }</block>
          </case><case>case <expr><name>REOP_NONDIGIT</name></expr>:
          <block>{
            <comment type="block">/* Use 'and' to give a predictable branch for success path. */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>ge</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ge</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>'0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>le</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_le</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>'9'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>both</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_and</name></expr></argument>, <argument><expr><name>ge</name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>both</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <break>break;</break>
          }</block>
          </case><case>case <expr><name>REOP_ALNUM</name></expr>:
          <block>{
            <comment type="block">/*
             * Compile the condition:
             *   ((uint)*cp) &lt; 128 &amp;&amp; js_alnum[(uint)*cp]
             */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>rangeCnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ult</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>128</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><name>rangeCnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>tableVal</name> <init>= <expr><call><name>compileTableRead</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name>js_alnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>tableVal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <break>break;</break>
          }</block>
          </case><case>case <expr><name>REOP_NONALNUM</name></expr>:
          <block>{
            <comment type="block">/*
             * Compile the condition:
             *   ((uint)*cp) &gt;= 128 || !js_alnum[(uint)*cp]
             */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>rangeCnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_uge</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>128</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>rangeBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>rangeCnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>tableVal</name> <init>= <expr><call><name>compileTableRead</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name>js_alnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>tableVal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>success</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>rangeBr</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          }</block>
          </case><case>case <expr><name>REOP_SPACE</name></expr>:
          </case><case>case <expr><name>REOP_NONSPACE</name></expr>:
          <block>{
            <comment type="block">/*
             * ECMA-262 7.2, 7.3, and 15.10.2.12 define a bunch of Unicode code
             * points for whitespace. We optimize here for the common case of
             * ASCII characters using a table lookup for the lower block that
             * can actually contain spaces. For the rest, use a (more or less)
             * binary search to minimize tests.
             *
             *   [0000,0020]: 9, A, B, C, D, 20
             *   (0020,00A0): none
             *   [00A0,2000): A0, 1680, 180E
             *   [2000,200A]: all
             *   (200A, max): 2028, 2029, 202F, 205F, 3000
             */</comment>
            <comment type="block">/* Below 0x20? */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>tableRangeCnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ule</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x20</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>tableRangeBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>tableRangeCnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Fall through means *chr &gt; 0x20. */</comment>

            <comment type="block">/* Handle (0x20,0xA0). */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>asciiCnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ult</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0xA0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>asciiMissBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>asciiCnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Fall through means *chr &gt;= 0xA0. */</comment>

            <comment type="block">/* Partition around [0x2000,0x200A]. */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>belowCnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ult</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x2000</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>belowBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>belowCnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>aboveCnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ugt</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x200A</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>aboveBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>aboveCnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>intervalMatchBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Handle [0xA0,0x2000). */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>belowLbl</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>belowBr</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>belowLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq1Cnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0xA0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq1Br</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq1Cnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq2Cnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x1680</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq2Br</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq2Cnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq3Cnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x180E</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq3Br</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq3Cnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>belowMissBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Handle (0x200A, max). */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>aboveLbl</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>aboveBr</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>aboveLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq4Cnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x2028</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq4Br</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq4Cnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq5Cnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x2029</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq5Br</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq5Cnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq6Cnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x202F</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq6Br</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq6Cnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq7Cnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x205F</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq7Br</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq7Cnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq8Cnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0x3000</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eq8Br</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eq8Cnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>aboveMissBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Handle [0,0x20]. */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>tableLbl</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>tableRangeBr</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>tableLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>tableVal</name> <init>= <expr><call><name>compileTableRead</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name>js_ws</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>tableCnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>tableVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>tableMatchBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><name>tableCnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Collect misses. */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>missLbl</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>asciiMissBr</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>missLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>belowMissBr</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>missLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>aboveMissBr</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>missLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>missBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>node</name>-&gt;<name>op</name></name> == <name>REOP_SPACE</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><name>missBr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></then></if>

            <comment type="block">/* Collect matches. */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>matchLbl</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>intervalMatchBr</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>matchLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tableMatchBr</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>matchLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>eq1Br</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>matchLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name><name>eq2Br</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>matchLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>eq3Br</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>matchLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name><name>eq4Br</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>matchLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>eq5Br</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>matchLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name><name>eq6Br</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>matchLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>eq7Br</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>matchLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name><name>eq8Br</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>matchLbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>node</name>-&gt;<name>op</name></name> == <name>REOP_NONSPACE</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>LIns</name> *</type><name>matchBr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name><name>fails</name>.<name>append</name></name><argument_list>(<argument><expr><name>matchBr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></then></if>
            <comment type="block">/* Fall through means match == success. */</comment>

            <comment type="block">/* Collect successes to fall through. */</comment>
            <decl_stmt><decl><type><name>LIns</name> *</type><name>success</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>node</name>-&gt;<name>op</name></name> == <name>REOP_NONSPACE</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>missBr</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <break>break;</break>
          }</block>
          </case><default>default:
            <return>return <expr><name>NULL</name></expr>;</return>
        </default>}</block></switch>

        <return>return <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmWord</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><name>LIns</name> *</type><name>compileAlt</name><parameter_list>(<param><decl><type><name>RENode</name> *</type><name>node</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>pos</name></decl></param>, <param><decl><type><name>bool</name></type> <name>atEnd</name></decl></param>, <param><decl><type><name>LInsList</name> &amp;</type><name>fails</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>RENode</name> *</type><name>leftRe</name> <init>= <expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>kid</name></name></expr></init>, *<name>rightRe</name> <init>= <expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>u</name>.<name>kid2</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If the RE continues after the alternative, we need to ensure that no
         * backtracking is required. Recursive calls to compileNode will fail
         * on capturing parens, so the only thing we have to check here is that,
         * if the left subexpression matches, we can keep going without later
         * deciding we need to try the right subexpression.
         */</comment>
        <if>if <condition>(<expr>!<name>atEnd</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If there is no character overlap between left and right, then
             * there is only one possible path through the alternative.
             */</comment>
            <decl_stmt><decl><type><name>CharSet</name></type> <name>leftSet</name></decl>, <decl><type ref="prev"/><name>rightSet</name></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name>enumerateNextChars</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>leftRe</name></expr></argument>, <argument><expr><name>leftSet</name></expr></argument>)</argument_list></call> ||
                !<call><name>enumerateNextChars</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>rightRe</name></expr></argument>, <argument><expr><name>rightSet</name></expr></argument>)</argument_list></call> ||
                !<call><name><name>leftSet</name>.<name>disjoint</name></name><argument_list>(<argument><expr><name>rightSet</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <comment type="block">/*
             * If there is an empty path through either subexpression, the above
             * check is incomplete; we need to include |node-&gt;next| as well.
             */</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>epsLeft</name> <init>= <expr><call><name>mayMatchEmpty</name><argument_list>(<argument><expr><name>leftRe</name></expr></argument>)</argument_list></call></expr></init>,
                 <name>epsRight</name> <init>= <expr><call><name>mayMatchEmpty</name><argument_list>(<argument><expr><name>rightRe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>epsRight</name> &amp;&amp; <name>epsLeft</name></expr>)</condition><then> <block>{
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then> <else>else <if>if <condition>(<expr><name>epsLeft</name> || <name>epsRight</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>CharSet</name></type> <name>nextSet</name></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name>enumerateNextChars</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>nextSet</name></expr></argument>)</argument_list></call> ||
                    (<name>epsLeft</name> &amp;&amp; !<call><name><name>nextSet</name>.<name>disjoint</name></name><argument_list>(<argument><expr><name>rightSet</name></expr></argument>)</argument_list></call>) ||
                    (<name>epsRight</name> &amp;&amp; !<call><name><name>nextSet</name>.<name>disjoint</name></name><argument_list>(<argument><expr><name>leftSet</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                    <return>return <expr><name>NULL</name></expr>;</return>
                }</block></then></if>
            }</block></then></if></else></if>
        }</block></then></if>

        <comment type="block">/* Try left branch. */</comment>
        <function_decl><type><name>LInsList</name></type> <name>kidFails</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>branchEnd</name> <init>= <expr><call><name>compileNode</name><argument_list>(<argument><expr><name>leftRe</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>atEnd</name></expr></argument>, <argument><expr><name>kidFails</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>branchEnd</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <comment type="block">/*
         * Since there are no phis, simulate by writing to and reading from
         * memory (REGlobalData::stateStack, since it is unused).
         */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>branchEnd</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                       <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>stateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>leftSuccess</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Try right branch. */</comment>
        <expr_stmt><expr><call><name>targetCurrentPoint</name><argument_list>(<argument><expr><name>kidFails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!(<name>branchEnd</name> = <call><name>compileNode</name><argument_list>(<argument><expr><name>rightRe</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>atEnd</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>branchEnd</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                       <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>stateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Land success on the left branch. */</comment>
        <expr_stmt><expr><call><name>targetCurrentPoint</name><argument_list>(<argument><expr><name>leftSuccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>addName</name><argument_list>(<argument><expr><name><name>fragment</name>-&gt;<name>lirbuf</name></name></expr></argument>,
                       <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                    <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>stateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr>"pos"</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><name>LIns</name> *</type><name>compileOpt</name><parameter_list>(<param><decl><type><name>RENode</name> *</type><name>node</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>pos</name></decl></param>, <param><decl><type><name>bool</name></type> <name>atEnd</name></decl></param>, <param><decl><type><name>LInsList</name> &amp;</type><name>fails</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/*
         * Since there are no phis, simulate by writing to and reading from
         * memory (REGlobalData::stateStack, since it is unused).
         */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>stateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Try ? body. */</comment>
        <function_decl><type><name>LInsList</name></type> <name>kidFails</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
        <if>if <condition>(<expr>!(<name>pos</name> = <call><name>compileNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>atEnd</name></expr></argument>, <argument><expr><name>kidFails</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>stateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Join success and failure and get new position. */</comment>
        <expr_stmt><expr><call><name>targetCurrentPoint</name><argument_list>(<argument><expr><name>kidFails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pos</name> = <call><name>addName</name><argument_list>(<argument><expr><name><name>fragment</name>-&gt;<name>lirbuf</name></name></expr></argument>,
                      <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>stateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr>"pos"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>pos</name></expr>;</return>
    }</block></function>

    <function><type><name>LIns</name> *</type><name>compileQuant</name><parameter_list>(<param><decl><type><name>RENode</name> *</type><name>node</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>pos</name></decl></param>, <param><decl><type><name>bool</name></type> <name>atEnd</name></decl></param>, <param><decl><type><name>LInsList</name> &amp;</type><name>fails</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/* Only support greedy *, +, ?. */</comment>
        <if>if <condition>(<expr>!<name><name>node</name>-&gt;<name>u</name>.<name>range</name>.<name>greedy</name></name> ||
            <name><name>node</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> &gt; 1 ||
            (<name><name>node</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> &gt; 1 &amp;&amp; <name><name>node</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> &lt; (<name>uintN</name>)-1)</expr>)</condition><then> <block>{
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>RENode</name> *</type><name>bodyRe</name> <init>= <expr>(<name>RENode</name> *)<name><name>node</name>-&gt;<name>kid</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If the RE continues after the alternative, we need to ensure that no
         * backtracking is required. Recursive calls to compileNode will fail
         * on capturing parens, so the only thing we have to check here is that,
         * if the quantifier body matches, we can continue matching the body
         * without later deciding we need to undo the body matches.
         */</comment>
        <if>if <condition>(<expr>!<name>atEnd</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If there is no character overlap between the body and
             * |node-&gt;next|, then all possible body matches are used.
             */</comment>
            <decl_stmt><decl><type><name>CharSet</name></type> <name>bodySet</name></decl>, <decl><type ref="prev"/><name>nextSet</name></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name>enumerateNextChars</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>bodyRe</name></expr></argument>, <argument><expr><name>bodySet</name></expr></argument>)</argument_list></call> ||
                !<call><name>enumerateNextChars</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>nextSet</name></expr></argument>)</argument_list></call> ||
                !<call><name><name>bodySet</name>.<name>disjoint</name></name><argument_list>(<argument><expr><name>nextSet</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/* Fork off ? and {1,1}. */</comment>
        <if>if <condition>(<expr><name><name>node</name>-&gt;<name>u</name>.<name>range</name>.<name>max</name></name> == 1</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>node</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> == 1</expr>)</condition><then>
                <return>return <expr><call><name>compileNode</name><argument_list>(<argument><expr><name>bodyRe</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>atEnd</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</return></then>
            <else>else
                <return>return <expr><call><name>compileOpt</name><argument_list>(<argument><expr><name>bodyRe</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>atEnd</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
        }</block></then></if>

        <comment type="block">/* For +, compile a copy of the body where failure is real failure. */</comment>
        <if>if <condition>(<expr><name><name>node</name>-&gt;<name>u</name>.<name>range</name>.<name>min</name></name> == 1</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!(<name>pos</name> = <call><name>compileNode</name><argument_list>(<argument><expr><name>bodyRe</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>atEnd</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then></if>

        <comment type="block">/*
         * Since there are no phis, simulate by writing to and reading from
         * memory (REGlobalData::stateStack, since it is unused).
         */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>stateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Begin iteration: load loop variables. */</comment>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>loopTop</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>iterBegin</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><name><name>fragment</name>-&gt;<name>lirbuf</name></name></expr></argument>,
                                  <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                               <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>stateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr>"pos"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Match quantifier body. */</comment>
        <function_decl><type><name>LInsList</name></type> <name>kidFails</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>iterEnd</name> <init>= <expr><call><name>compileNode</name><argument_list>(<argument><expr><name>bodyRe</name></expr></argument>, <argument><expr><name>iterBegin</name></expr></argument>, <argument><expr><name>atEnd</name></expr></argument>, <argument><expr><name>kidFails</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>iterEnd</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <comment type="block">/*
         * If there is an epsilon path through the body then, when it is taken,
         * we need to abort the loop or else we will loop forever.
         */</comment>
        <if>if <condition>(<expr><call><name>mayMatchEmpty</name><argument_list>(<argument><expr><name>bodyRe</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name> *</type><name>eqCnd</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>iterBegin</name></expr></argument>, <argument><expr><name>iterEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>kidFails</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><name>eqCnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then></if>

        <comment type="block">/* End iteration: store loop variables, increment, jump */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>iterEnd</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>stateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>loopTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Using '+' as branch, the intended control flow is:
         *
         *     ...
         * A -&gt; |
         *      |&lt;---.
         * B -&gt; |    |
         *      +--. |
         * C -&gt; |  | |
         *      +--. |
         * D -&gt; |  | |
         *      +--|-'
         * X -&gt; |  |
         *      |&lt;-'
         * E -&gt; |
         *     ...
         *
         * We are currently at point X. Since the regalloc makes a single,
         * linear, backwards sweep over the IR (going from E to A), point X
         * must tell the regalloc what LIR insns are live at the end of D.
         * Thus, we need to report *all* insns defined *before* the end of D
         * that may be used *after* D. This means insns defined in A, B, C, or
         * D and used in B, C, D, or E. Since insns in B, C, and D are
         * conditionally executed, and we (currently) don't have real phi
         * nodes, we need only consider insns defined in A and used in E.
         */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_plive</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_plive</name></expr></argument>, <argument><expr><name>cpend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_plive</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* After the loop: reload 'pos' from memory and continue. */</comment>
        <expr_stmt><expr><call><name>targetCurrentPoint</name><argument_list>(<argument><expr><name>kidFails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>iterBegin</name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * Compile the regular expression rooted at 'node'. Return 0 on failed
     * compilation. Otherwise, generate code that falls through on success (the
     * returned LIns* is the current 'pos') and jumps to the end on failure (by
     * adding the guard LIns to 'fails').
     */</comment>
    <function><type><name>LIns</name> *</type><name>compileNode</name><parameter_list>(<param><decl><type><name>RENode</name> *</type><name>node</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>pos</name></decl></param>, <param><decl><type><name>bool</name></type> <name>atEnd</name></decl></param>, <param><decl><type><name>LInsList</name> &amp;</type><name>fails</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init>;</init> <condition><expr><name>pos</name> &amp;&amp; <name>node</name></expr>;</condition> <incr><expr><name>node</name> = <name><name>node</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <decl_stmt><decl><type><name>bool</name></type> <name>childNextIsEnd</name> <init>= <expr><name>atEnd</name> &amp;&amp; !<name><name>node</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name><name>node</name>-&gt;<name>op</name></name></expr>)</condition> <block>{
              <case>case <expr><name>REOP_EMPTY</name></expr>:
                <expr_stmt><expr><name>pos</name> = <call><name>compileEmpty</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr><name>REOP_FLAT</name></expr>:
                <expr_stmt><expr><name>pos</name> = <call><name>compileFlat</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr><name>REOP_ALT</name></expr>:
              </case><case>case <expr><name>REOP_ALTPREREQ</name></expr>:
                <expr_stmt><expr><name>pos</name> = <call><name>compileAlt</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>childNextIsEnd</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr><name>REOP_QUANT</name></expr>:
                <expr_stmt><expr><name>pos</name> = <call><name>compileQuant</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>childNextIsEnd</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr><name>REOP_CLASS</name></expr>:
                <expr_stmt><expr><name>pos</name> = <call><name>compileClass</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr><name>REOP_DOT</name></expr>:
              </case><case>case <expr><name>REOP_DIGIT</name></expr>:
              </case><case>case <expr><name>REOP_NONDIGIT</name></expr>:
              </case><case>case <expr><name>REOP_ALNUM</name></expr>:
              </case><case>case <expr><name>REOP_NONALNUM</name></expr>:
              </case><case>case <expr><name>REOP_SPACE</name></expr>:
              </case><case>case <expr><name>REOP_NONSPACE</name></expr>:
                <expr_stmt><expr><name>pos</name> = <call><name>compileBuiltinClass</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><default>default:
                <return>return <expr><name>NULL</name></expr>;</return>
            </default>}</block></switch>
        }</block></for>
        <return>return <expr><name>pos</name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * This function kicks off recursive compileNode compilation, finishes the
     * success path, and lets the failed-match path fall through.
     */</comment>
    <function><type><name>bool</name></type> <name>compileRootNode</name><parameter_list>(<param><decl><type><name>RENode</name> *</type><name>root</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>pos</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>anchorFail</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/* Compile the regular expression body. */</comment>
        <function_decl><type><name>LInsList</name></type> <name>fails</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
        <expr_stmt><expr><name>pos</name> = <call><name>compileNode</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pos</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <comment type="block">/* Fall-through from compileNode means success. */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>stateStack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_regfence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_ret</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Stick return here so we don't have to jump over it every time. */</comment>
        <if>if <condition>(<expr><name>anchorFail</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>targetCurrentPoint</name><argument_list>(<argument><expr><name>anchorFail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_regfence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_ret</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Target failed matches. */</comment>
        <expr_stmt><expr><call><name>targetCurrentPoint</name><argument_list>(<argument><expr><name>fails</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="block">/* Compile a regular expressions that can only match on the first char. */</comment>
    <function><type><name>bool</name></type> <name>compileSticky</name><parameter_list>(<param><decl><type><name>RENode</name> *</type><name>root</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>start</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<call><name>compileRootNode</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <comment type="block">/* Failed to match on first character, so fail whole match. */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_regfence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_ret</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>!<call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/* Compile normal regular expressions that can match starting at any char. */</comment>
    <function><type><name>bool</name></type> <name>compileAnchoring</name><parameter_list>(<param><decl><type><name>RENode</name> *</type><name>root</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>start</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/* Guard outer anchoring loop. Use &lt;= to allow empty regexp match. */</comment>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>anchorFail</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ple</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>cpend</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>compileRootNode</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>anchorFail</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <comment type="block">/* Outer loop increment. */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmWord</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                       <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr>!<call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>inline</specifier> <name>LIns</name>*</type>
    <name>addName</name><parameter_list>(<param><decl><type><name>LirBuffer</name>*</type> <name>lirbuf</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>ins</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>name</name></decl></param>)</parameter_list>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NJ_VERBOSE</name></cpp:ifdef>
        <macro><name>debug_only_stmt</name><argument_list>(<argument>lirbuf-&gt;names-&gt;addName(ins, name);</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>ins</name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * Insert the side exit and guard record for a compiled regexp. Most
     * of the fields are not used. The important part is the regexp source
     * and flags, which we use as the fragment lookup key.
     */</comment>
    <function><type><name>GuardRecord</name>*</type> <name>insertGuard</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>loopLabel</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name>*</type> <name>re_chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>re_length</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>loopLabel</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>loopLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>LirBuffer</name>*</type> <name>lirbuf</name> <init>= <expr><name><name>fragment</name>-&gt;<name>lirbuf</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_plive</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_plive</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>param1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>Allocator</name> &amp;</type><name>alloc</name> <init>= <expr>*<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>dataAlloc</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Must only create a VMSideExit; see StackFilter::getTops. */</comment>
        <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr>(<sizeof>sizeof<argument_list>(<argument><expr><name>GuardRecord</name></expr></argument>)</argument_list></sizeof> +
                      <sizeof>sizeof<argument_list>(<argument><expr><name>VMSideExit</name></expr></argument>)</argument_list></sizeof> +
                      (<name>re_length</name>-1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof>)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GuardRecord</name>*</type> <name>guard</name> <init>= <expr>(<name>GuardRecord</name> *) <call><name><name>alloc</name>.<name>alloc</name></name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr>(<name>VMSideExit</name>*)(<name>guard</name>+1)</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>guard</name>-&gt;<name>exit</name></name> = <name>exit</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>guard</name>-&gt;<name>exit</name>-&gt;<name>target</name></name> = <name>fragment</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fragment</name>-&gt;<name>lastIns</name></name> = <call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_x</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>guard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// guard-&gt;profCount is calloc'd to zero</comment>
        <macro><name>verbose_only</name><argument_list>(
            <argument>guard-&gt;profGuardID = fragment-&gt;guardNumberer++;
            guard-&gt;nextInFrag = fragment-&gt;guardsForFrag;
            fragment-&gt;guardsForFrag = guard;</argument>
        )</argument_list></macro>
        <return>return <expr><name>guard</name></expr>;</return>
    }</block></function>

 </private><public>public:
    <constructor><name>RegExpNativeCompiler</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSRegExp</name>*</type> <name>re</name></decl></param>, <param><decl><type><name>CompilerState</name>*</type> <name>cs</name></decl></param>, <param><decl><type><name>Fragment</name>*</type> <name>fragment</name></decl></param>)</parameter_list>
        <member_list>: <call><name>tempAlloc</name><argument_list>(<argument><expr>*<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>reTempAlloc</name></expr></argument>)</argument_list></call>, <call><name>cx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>,
          <call><name>re</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call>, <call><name>cs</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call>, <call><name>fragment</name><argument_list>(<argument><expr><name>fragment</name></expr></argument>)</argument_list></call>, <call><name>lir</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>, <call><name>lirBufWriter</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
          <call><name>lirbuf</name><argument_list>(<argument><expr>new (<name>tempAlloc</name>) <call><name>LirBuffer</name><argument_list>(<argument><expr><name>tempAlloc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
    </member_list><block>{
        <expr_stmt><expr><name><name>fragment</name>-&gt;<name>lirbuf</name></name> = <name>lirbuf</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>LabelMap</name>*</type> <name>labels</name> <init>= <expr>new (<name>tempAlloc</name>) <call><name>LabelMap</name><argument_list>(<argument><expr><name>tempAlloc</name></expr></argument>, <argument><expr>&amp;<name>LogController</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>lirbuf</name>-&gt;<name>names</name></name> = new (<name>tempAlloc</name>) <call><name>LirNameMap</name><argument_list>(<argument><expr><name>tempAlloc</name></expr></argument>, <argument><expr><name>labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></constructor>

    <destructor><name>~<name>RegExpNativeCompiler</name></name><parameter_list>()</parameter_list> <block>{
        <comment type="block">/* Purge the tempAlloc used during recording. */</comment>
        <expr_stmt><expr><call><name><name>tempAlloc</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></destructor>

    <function><type><name>JSBool</name></type> <name>compile</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>GuardRecord</name>*</type> <name>guard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name>*</type> <name>re_chars</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>re_length</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Assembler</name> *</type><name>assm</name> <init>= <expr><name><name>tm</name>-&gt;<name>assembler</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>loopLabel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call> || <call><name>OverfullJITCache</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name><name>re</name>-&gt;<name>source</name>-&gt;<name>getCharsAndLength</name></name><argument_list>(<argument><expr><name>re_chars</name></expr></argument>, <argument><expr><name>re_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * If the regexp is too long nanojit will assert when we
         * try to insert the guard record.
         */</comment>
        <if>if <condition>(<expr><name>re_length</name> &gt; 1024</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>re</name>-&gt;<name>flags</name></name> |= <name>JSREG_NOCOMPILE</name></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* At this point we have an empty fragment. */</comment>
        <decl_stmt><decl><type><name>LirBuffer</name>*</type> <name>lirbuf</name> <init>= <expr><name><name>fragment</name>-&gt;<name>lirbuf</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <goto>goto <name>fail</name>;</goto></then></if>
        <comment type="block">/* FIXME Use bug 463260 smart pointer when available. */</comment>
        <expr_stmt><expr><name>lir</name> = <name>lirBufWriter</name> = new <call><name>LirBufWriter</name><argument_list>(<argument><expr><name>lirbuf</name></expr></argument>, <argument><expr><name><name>nanojit</name>::<name>AvmCore</name>::<name>config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* FIXME Use bug 463260 smart pointer when available. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NJ_VERBOSE</name></cpp:ifdef>
        <macro><name>debug_only_stmt</name><argument_list>(
            <argument>if (LogController.lcbits &amp; LC_TMRegexp) {
                lir = verbose_filter = new VerboseWriter(tempAlloc, lir, lirbuf-&gt;names,
                                                         &amp;LogController);
            }</argument>
        )</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name>lir</name> = <name>validate_writer</name> = new <call><name>ValidateWriter</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr>"regexp writer pipeline"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Although we could just load REGlobalData::cpend from 'state', by
         * passing it as a parameter, we avoid loading it every iteration.
         */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NumSavedRegs</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insParam</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NumSavedRegs</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
            <expr_stmt><expr><call><name>addName</name><argument_list>(<argument><expr><name>lirbuf</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>savedRegs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>regNames</name><index>[<expr><name><name>Assembler</name>::<name>savedRegs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name><name>lirbuf</name>-&gt;<name>state</name></name> = <name>state</name> = <call><name>addName</name><argument_list>(<argument><expr><name>lirbuf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insParam</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lirbuf</name>-&gt;<name>param1</name></name> = <name>cpend</name> = <call><name>addName</name><argument_list>(<argument><expr><name>lirbuf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insParam</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"cpend"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>loopLabel</name> = <call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// If profiling, record where the loop label is, so that the</comment>
        <comment type="line">// assembler can insert a frag-entry-counter increment at that</comment>
        <comment type="line">// point</comment>
        <macro><name>verbose_only</name><argument_list>( <argument>if (LogController.lcbits &amp; LC_FragProfile) {
            NanoAssert(!fragment-&gt;loopLabel);
            fragment-&gt;loopLabel = loopLabel;
        }</argument>)</argument_list></macro>

        <expr_stmt><expr><name>start</name> = <call><name>addName</name><argument_list>(<argument><expr><name>lirbuf</name></expr></argument>,
                      <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REGlobalData</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr>"start"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>cs</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_STICKY</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>compileSticky</name><argument_list>(<argument><expr><name><name>cs</name>-&gt;<name>result</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>fail</name>;</goto></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>compileAnchoring</name><argument_list>(<argument><expr><name><name>cs</name>-&gt;<name>result</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>fail</name>;</goto></then></if>
        }</block></else></if>

        <expr_stmt><expr><name>guard</name> = <call><name>insertGuard</name><argument_list>(<argument><expr><name>loopLabel</name></expr></argument>, <argument><expr><name>re_chars</name></expr></argument>, <argument><expr><name>re_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <goto>goto <name>fail</name>;</goto></then></if>

        <comment type="block">/*
         * Deep in the nanojit compiler, the StackFilter is trying to throw
         * away stores above the VM interpreter/native stacks. We have no such
         * stacks, so rely on the fact that lirbuf-&gt;sp and lirbuf-&gt;rp are null
         * to ensure our stores are ignored.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>lirbuf</name>-&gt;<name>sp</name></name> &amp;&amp; !<name><name>lirbuf</name>-&gt;<name>rp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>assm</name>-&gt;<name>compile</name></name><argument_list>(<argument><expr><name>fragment</name></expr></argument>, <argument><expr><name>tempAlloc</name></expr></argument>, <comment type="block">/*optimize*/</comment><argument><expr>true
                      <call><name>verbose_only</name><argument_list>(, <argument><expr><name><name>lirbuf</name>-&gt;<name>names</name>-&gt;<name>labels</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>assm</name>-&gt;<name>error</name></name><argument_list>()</argument_list></call> != <name><name>nanojit</name>::<name>None</name></name></expr>)</condition><then>
            <goto>goto <name>fail</name>;</goto></then></if>

        <expr_stmt><expr>delete <name>lirBufWriter</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr>delete <name>validate_writer</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NJ_VERBOSE</name></cpp:ifdef>
        <macro><name>debug_only_stmt</name><argument_list>( <argument>if (LogController.lcbits &amp; LC_TMRegexp)
                             delete verbose_filter;</argument> )</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    <label><name>fail</name>:</label>
        <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call> || <call><name>OverfullJITCache</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>delete <name>lirBufWriter</name></expr>;</expr_stmt>
            <comment type="line">// recover profiling data from expiring Fragments</comment>
            <macro><name>verbose_only</name><argument_list>(
                <argument>REHashMap::Iter iter(*(tm-&gt;reFragments));
                while (iter.next()) {
                    nanojit::Fragment* frag = iter.value();
                    FragProfiling_FragFinalizer(frag, tm);
                }</argument>
            )</argument_list></macro>
            <expr_stmt><expr><call><name>FlushJITCache</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<name>guard</name></expr>)</condition><then> <expr_stmt><expr><call><name>insertGuard</name><argument_list>(<argument><expr><name>loopLabel</name></expr></argument>, <argument><expr><name>re_chars</name></expr></argument>, <argument><expr><name>re_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name><name>re</name>-&gt;<name>flags</name></name> |= <name>JSREG_NOCOMPILE</name></expr>;</expr_stmt>
            <expr_stmt><expr>delete <name>lirBufWriter</name></expr>;</expr_stmt>
        }</block></else></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr>delete <name>validate_writer</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NJ_VERBOSE</name></cpp:ifdef>
        <macro><name>debug_only_stmt</name><argument_list>( <argument>if (LogController.lcbits &amp; LC_TMRegexp)
                             delete lir;</argument> )</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></function>
</public>}</block>;</class>

<comment type="block">/*
 * Compile a regexp to native code in the given fragment.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>JSBool</name></type>
<name>CompileRegExpToNative</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSRegExp</name>*</type> <name>re</name></decl></param>, <param><decl><type><name>Fragment</name>*</type> <name>fragment</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>rv</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>*</type> <name>mark</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CompilerState</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RegExpNativeCompiler</name></type> <name>rc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr>&amp;<name>state</name></expr></argument>, <argument><expr><name>fragment</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>fragment</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>CompileRegExpToAST</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>re</name>-&gt;<name>source</name></name></expr></argument>, <argument><expr><name><name>re</name>-&gt;<name>flags</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>rv</name> = <call><name><name>rc</name>.<name>compile</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 <label><name>out</name>:</label>
    <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="block">/* Function type for a compiled native regexp. */</comment>
<typedef>typedef <function_decl><type><name>void</name> *</type>(<name>FASTCALL</name> *<name>NativeRegExp</name>)<parameter_list>(<param><decl><type><name>REGlobalData</name>*</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>jschar</name> *</decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/*
 * Return a compiled native regexp if one already exists or can be created
 * now, or NULL otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>NativeRegExp</name></type>
<name>GetNativeRegExp</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSRegExp</name>*</type> <name>re</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>re_chars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>re_length</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>re</name>-&gt;<name>source</name>-&gt;<name>getCharsAndLength</name></name><argument_list>(<argument><expr><name>re_chars</name></expr></argument>, <argument><expr><name>re_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>Fragment</name> *</type><name>fragment</name> <init>= <expr><call><name>LookupNativeRegExp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>re</name>-&gt;<name>flags</name></name></expr></argument>, <argument><expr><name>re_chars</name></expr></argument>, <argument><expr><name>re_length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>fragment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>fragment</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>fragment</name>-&gt;<name>recordAttempts</name></name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>fragment</name>-&gt;<name>recordAttempts</name></name>++</expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>CompileRegExpToNative</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>fragment</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>
    <union>union <block>{<public type="default"> <decl_stmt><decl><type><name>NIns</name> *</type><name>code</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>NativeRegExp</name></type> <name>func</name></decl>;</decl_stmt> </public>}</block> <decl><name>u</name></decl>;</union>
    <expr_stmt><expr><name><name>u</name>.<name>code</name></name> = <call><name><name>fragment</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>u</name>.<name>func</name></name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>JSRegExp</name> *</type>
<name>js_NewRegExp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>,
             <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>flat</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>re</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>mark</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CompilerState</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>resize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>endPC</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>re</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Parsing the string as flat is now expressed internally using
     * a flag, so that we keep this information in the JSRegExp, but
     * we keep the 'flat' parameter for now for compatibility.
     */</comment>
    <if>if <condition>(<expr><name>flat</name></expr>)</condition><then> <expr_stmt><expr><name>flags</name> |= <name>JSREG_FLAT</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>!<call><name>CompileRegExpToAST</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>

    <expr_stmt><expr><name>resize</name> = <call><name>offsetof</name><argument_list>(<argument><expr><name>JSRegExp</name></expr></argument>, <argument><expr><name>program</name></expr></argument>)</argument_list></call> + <name><name>state</name>.<name>progLength</name></name> + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>re</name> = (<name>JSRegExp</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>resize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>re</name></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>

    <expr_stmt><expr><name><name>re</name>-&gt;<name>nrefs</name></name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>state</name>.<name>classBitmapsMem</name></name> &lt;= <name>CLASS_BITMAPS_MEM_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>re</name>-&gt;<name>classCount</name></name> = <name><name>state</name>.<name>classCount</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>re</name>-&gt;<name>classCount</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>re</name>-&gt;<name>classList</name></name> = (<name>RECharSet</name> *)
            <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name><name>re</name>-&gt;<name>classCount</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>RECharSet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>re</name>-&gt;<name>classList</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_DestroyRegExp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>re</name> = <name>NULL</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        }</block></then></if>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>re</name>-&gt;<name>classCount</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><name><name>re</name>-&gt;<name>classList</name><index>[<expr><name>i</name></expr>]</index></name>.<name>converted</name> = <name>JS_FALSE</name></expr>;</expr_stmt></for>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>re</name>-&gt;<name>classList</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Compile the bytecode version. */</comment>
    <expr_stmt><expr><name>endPC</name> = <call><name>EmitREBytecode</name><argument_list>(<argument><expr>&amp;<name>state</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>state</name>.<name>treeDepth</name></name></expr></argument>, <argument><expr><name><name>re</name>-&gt;<name>program</name></name></expr></argument>, <argument><expr><name><name>state</name>.<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>endPC</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_DestroyRegExp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>re</name> = <name>NULL</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr>*<name>endPC</name>++ = <name>REOP_END</name></expr>;</expr_stmt>
    <comment type="block">/*
     * Check whether size was overestimated and shrink using realloc.
     * This is safe since no pointers to newly parsed regexp or its parts
     * besides re exist here.
     */</comment>
    <if>if <condition>(<expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>endPC</name> - <name><name>re</name>-&gt;<name>program</name></name></expr></argument>)</argument_list></call> != <name><name>state</name>.<name>progLength</name></name> + 1</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>tmp</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>endPC</name> - <name><name>re</name>-&gt;<name>program</name></name></expr></argument>)</argument_list></call> &lt; <name><name>state</name>.<name>progLength</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>resize</name> = <call><name>offsetof</name><argument_list>(<argument><expr><name>JSRegExp</name></expr></argument>, <argument><expr><name>program</name></expr></argument>)</argument_list></call> + (<name>endPC</name> - <name><name>re</name>-&gt;<name>program</name></name>)</expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> = (<name>JSRegExp</name> *) <call><name><name>cx</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>resize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tmp</name></expr>)</condition><then>
            <expr_stmt><expr><name>re</name> = <name>tmp</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>re</name>-&gt;<name>flags</name></name> = <name>flags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>re</name>-&gt;<name>parenCount</name></name> = <name><name>state</name>.<name>parenCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>re</name>-&gt;<name>source</name></name> = <name>str</name></expr>;</expr_stmt>

<label><name>out</name>:</label>
    <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>re</name></expr>;</return>
}</block></function>

<function><type><name>JSRegExp</name> *</type>
<name>js_NewRegExpOpt</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>opt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>flat</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>charBuf</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>flags</name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>opt</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>opt</name>-&gt;<name>getCharsAndLength</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HANDLE_FLAG</name><parameter_list>(<param><type><name>name</name></type></param>)</parameter_list></cpp:macro>                                                     \
            <cpp:value>JS_BEGIN_MACRO                                                    \
                if (flags &amp; (name))                                           \
                    goto bad_flag;                                            \
                flags |= (name);                                              \
            JS_END_MACRO</cpp:value></cpp:define>
            <switch>switch <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{
              <case>case <expr>'g'</expr>:
                <expr_stmt><expr><call><name>HANDLE_FLAG</name><argument_list>(<argument><expr><name>JSREG_GLOB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'i'</expr>:
                <expr_stmt><expr><call><name>HANDLE_FLAG</name><argument_list>(<argument><expr><name>JSREG_FOLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'m'</expr>:
                <expr_stmt><expr><call><name>HANDLE_FLAG</name><argument_list>(<argument><expr><name>JSREG_MULTILINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'y'</expr>:
                <expr_stmt><expr><call><name>HANDLE_FLAG</name><argument_list>(<argument><expr><name>JSREG_STICKY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><default>default:
              <label><name>bad_flag</name>:</label>
                <expr_stmt><expr><name><name>charBuf</name><index>[<expr>0</expr>]</index></name> = (<name>char</name>)<name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>charBuf</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ReportErrorFlagsAndNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                             <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                             <argument><expr><name>JSMSG_BAD_REGEXP_FLAG</name></expr></argument>, <argument><expr><name>charBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </default>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HANDLE_FLAG</name></cpp:undef>
        }</block></for>
    }</block></then></if>
    <return>return <expr><call><name>js_NewRegExp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>flat</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Save the current state of the match - the position in the input
 * text as well as the position in the bytecode. The state of any
 * parent expressions is also saved (preceding state).
 * Contents of parenCount parentheses from parenIndex are also saved.
 */</comment>
<function><type><specifier>static</specifier> <name>REBackTrackData</name> *</type>
<name>PushBackTrackState</name><parameter_list>(<param><decl><type><name>REGlobalData</name> *</type><name>gData</name></decl></param>, <param><decl><type><name>REOp</name></type> <name>op</name></decl></param>,
                   <param><decl><type><name>jsbytecode</name> *</type><name>target</name></decl></param>, <param><decl><type><name>REMatchState</name> *</type><name>x</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>cp</name></decl></param>,
                   <param><decl><type><name>size_t</name></type> <name>parenIndex</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>parenCount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>REBackTrackData</name> *</type><name>result</name> <init>=
        <expr>(<name>REBackTrackData</name> *) ((<name>char</name> *)<name><name>gData</name>-&gt;<name>backTrackSP</name></name> + <name><name>gData</name>-&gt;<name>cursz</name></name>)</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>REBackTrackData</name></expr></argument>)</argument_list></sizeof> +
                <name><name>gData</name>-&gt;<name>stateStackTop</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>REProgState</name></expr></argument>)</argument_list></sizeof> +
                <name>parenCount</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>RECapture</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>btsize</name> <init>= <expr><name><name>gData</name>-&gt;<name>backTrackStackSize</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>btincr</name> <init>= <expr>((<name>char</name> *)<name>result</name> + <name>sz</name>) -
                       ((<name>char</name> *)<name><name>gData</name>-&gt;<name>backTrackStack</name></name> + <name>btsize</name>)</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>"\tBT_Push: %lu,%lu"</expr></argument>,
             <argument><expr>(<name>unsigned</name> <name>long</name>) <name>parenIndex</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>) <name>parenCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>btincr</name> &gt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name> <init>= <expr>(<name>char</name> *)<name>result</name> - (<name>char</name> *)<name><name>gData</name>-&gt;<name>backTrackStack</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>btincr</name> = <call><name>JS_ROUNDUP</name><argument_list>(<argument><expr><name>btincr</name></expr></argument>, <argument><expr><name>btsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ARENA_GROW_CAST</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>backTrackStack</name></name></expr></argument>, <argument><expr><name>REBackTrackData</name> *</expr></argument>,
                           <argument><expr>&amp;<name><name>gData</name>-&gt;<name>cx</name>-&gt;<name>regexpPool</name></name></expr></argument>, <argument><expr><name>btsize</name></expr></argument>, <argument><expr><name>btincr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>gData</name>-&gt;<name>backTrackStack</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>cx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>gData</name>-&gt;<name>ok</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackStackSize</name></name> = <name>btsize</name> + <name>btincr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> = (<name>REBackTrackData</name> *) ((<name>char</name> *)<name><name>gData</name>-&gt;<name>backTrackStack</name></name> + <name>offset</name>)</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackSP</name></name> = <name>result</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>sz</name></name> = <name><name>gData</name>-&gt;<name>cursz</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>-&gt;<name>cursz</name></name> = <name>sz</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name>-&gt;<name>backtrack_op</name></name> = <name>op</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>backtrack_pc</name></name> = <name>target</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name> = <name>cp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>parenCount</name></name> = <name>parenCount</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>parenIndex</name></name> = <name>parenIndex</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name>-&gt;<name>saveStateStackTop</name></name> = <name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name> + 1</expr></argument>, <argument><expr><name><name>gData</name>-&gt;<name>stateStack</name></name></expr></argument>,
           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>REProgState</name></expr></argument>)</argument_list></sizeof> * <name><name>result</name>-&gt;<name>saveStateStackTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>parenCount</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)(<name>result</name> + 1) +
               <sizeof>sizeof<argument_list>(<argument><expr><name>REProgState</name></expr></argument>)</argument_list></sizeof> * <name><name>result</name>-&gt;<name>saveStateStackTop</name></name></expr></argument>,
               <argument><expr>&amp;<name><name>x</name>-&gt;<name>parens</name><index>[<expr><name>parenIndex</name></expr>]</index></name></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RECapture</name></expr></argument>)</argument_list></sizeof> * <name>parenCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <name>parenCount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><name><name>x</name>-&gt;<name>parens</name><index>[<expr><name>parenIndex</name> + <name>i</name></expr>]</index></name>.<name>index</name> = -1</expr>;</expr_stmt></for>
    }</block></then></if>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>


<comment type="block">/*
 *   Consecutive literal characters.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static REMatchState *
FlatNMatcher(REGlobalData *gData, REMatchState *x, jschar *matchChars,
             size_t length)
{
    size_t i;
    if (length &gt; gData-&gt;cpend - x-&gt;cp)
        return NULL;
    for (i = 0; i != length; i++) {
        if (matchChars[i] != x-&gt;cp[i])
            return NULL;
    }
    x-&gt;cp += length;
    return x;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>REMatchState</name> *</type>
<name>FlatNIMatcher</name><parameter_list>(<param><decl><type><name>REGlobalData</name> *</type><name>gData</name></decl></param>, <param><decl><type><name>REMatchState</name> *</type><name>x</name></decl></param>, <param><decl><type><name>jschar</name> *</type><name>matchChars</name></decl></param>,
              <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>cpend</name></name> &gt;= <name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>length</name> &gt; <call>(<name>size_t</name>)<argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>cpend</name></name> - <name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <name>length</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>upcase</name><argument_list>(<argument><expr><name><name>matchChars</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> != <call><name>upcase</name><argument_list>(<argument><expr><name><name>x</name>-&gt;<name>cp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></for>
    <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> += <name>length</name></expr>;</expr_stmt>
    <return>return <expr><name>x</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * 1. Evaluate DecimalEscape to obtain an EscapeValue E.
 * 2. If E is not a character then go to step 6.
 * 3. Let ch be E's character.
 * 4. Let A be a one-element RECharSet containing the character ch.
 * 5. Call CharacterSetMatcher(A, false) and return its Matcher result.
 * 6. E must be an integer. Let n be that integer.
 * 7. If n=0 or n&gt;NCapturingParens then throw a SyntaxError exception.
 * 8. Return an internal Matcher closure that takes two arguments, a State x
 *    and a Continuation c, and performs the following:
 *     1. Let cap be x's captures internal array.
 *     2. Let s be cap[n].
 *     3. If s is undefined, then call c(x) and return its result.
 *     4. Let e be x's endIndex.
 *     5. Let len be s's length.
 *     6. Let f be e+len.
 *     7. If f&gt;InputLength, return failure.
 *     8. If there exists an integer i between 0 (inclusive) and len (exclusive)
 *        such that Canonicalize(s[i]) is not the same character as
 *        Canonicalize(Input [e+i]), then return failure.
 *     9. Let y be the State (f, cap).
 *     10. Call c(y) and return its result.
 */</comment>
<function><type><specifier>static</specifier> <name>REMatchState</name> *</type>
<name>BackrefMatcher</name><parameter_list>(<param><decl><type><name>REGlobalData</name> *</type><name>gData</name></decl></param>, <param><decl><type><name>REMatchState</name> *</type><name>x</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>parenIndex</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>parenContent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RECapture</name> *</type><name>cap</name> <init>= <expr>&amp;<name><name>x</name>-&gt;<name>parens</name><index>[<expr><name>parenIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>cap</name>-&gt;<name>index</name></name> == -1</expr>)</condition><then>
        <return>return <expr><name>x</name></expr>;</return></then></if>

    <expr_stmt><expr><name>len</name> = <name><name>cap</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> + <name>len</name> &gt; <name><name>gData</name>-&gt;<name>cpend</name></name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>parenContent</name> = &amp;<name><name>gData</name>-&gt;<name>cpbegin</name><index>[<expr><name><name>cap</name>-&gt;<name>index</name></name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name></expr>)</condition><then> <block>{
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name>upcase</name><argument_list>(<argument><expr><name><name>parenContent</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> != <call><name>upcase</name><argument_list>(<argument><expr><name><name>x</name>-&gt;<name>cp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></for>
    }</block></then> <else>else <block>{
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>parenContent</name><index>[<expr><name>i</name></expr>]</index></name> != <name><name>x</name>-&gt;<name>cp</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></for>
    }</block></else></if>
    <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> += <name>len</name></expr>;</expr_stmt>
    <return>return <expr><name>x</name></expr>;</return>
}</block></function>


<comment type="block">/* Add a single character to the RECharSet */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddCharacterToCharSet</name><parameter_list>(<param><decl><type><name>RECharSet</name> *</type><name>cs</name></decl></param>, <param><decl><type><name>jschar</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>byteIndex</name> <init>= <expr><call>(<name>uintN</name>)<argument_list>(<argument><expr><name>c</name> &gt;&gt; 3</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>c</name> &lt;= <name><name>cs</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cs</name>-&gt;<name>u</name>.<name>bits</name><index>[<expr><name>byteIndex</name></expr>]</index></name> |= 1 &lt;&lt; (<name>c</name> &amp; 0x7)</expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Add a character range, c1 to c2 (inclusive) to the RECharSet */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddCharacterRangeToCharSet</name><parameter_list>(<param><decl><type><name>RECharSet</name> *</type><name>cs</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>c1</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>c2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>uintN</name></type> <name>byteIndex1</name> <init>= <expr><name>c1</name> &gt;&gt; 3</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>byteIndex2</name> <init>= <expr><name>c2</name> &gt;&gt; 3</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>c2</name> &lt;= <name><name>cs</name>-&gt;<name>length</name></name> &amp;&amp; <name>c1</name> &lt;= <name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>c1</name> &amp;= 0x7</expr>;</expr_stmt>
    <expr_stmt><expr><name>c2</name> &amp;= 0x7</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>byteIndex1</name> == <name>byteIndex2</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>cs</name>-&gt;<name>u</name>.<name>bits</name><index>[<expr><name>byteIndex1</name></expr>]</index></name> |= ((<name>uint8</name>)0xFF &gt;&gt; (7 - (<name>c2</name> - <name>c1</name>))) &lt;&lt; <name>c1</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>cs</name>-&gt;<name>u</name>.<name>bits</name><index>[<expr><name>byteIndex1</name></expr>]</index></name> |= 0xFF &lt;&lt; <name>c1</name></expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = <name>byteIndex1</name> + 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>byteIndex2</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><name><name>cs</name>-&gt;<name>u</name>.<name>bits</name><index>[<expr><name>i</name></expr>]</index></name> = 0xFF</expr>;</expr_stmt></for>
        <expr_stmt><expr><name><name>cs</name>-&gt;<name>u</name>.<name>bits</name><index>[<expr><name>byteIndex2</name></expr>]</index></name> |= (<name>uint8</name>)0xFF &gt;&gt; (7 - <name>c2</name>)</expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<struct>struct <name>CharacterRange</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>jschar</name></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name>end</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<comment type="block">/*
 * The following characters are taken from the ECMA-262 standard, section 7.2
 * and 7.3, and the Unicode 3 standard, Table 6-1.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CharacterRange</name></type> <name><name>WhiteSpaceRanges</name><index>[]</index></name> <init>= <expr><block>{
    <comment type="block">/* TAB, LF, VT, FF, CR */</comment>
    <expr><block>{ <expr>0x0009</expr>, <expr>0x000D</expr> }</block></expr>,
    <comment type="block">/* SPACE */</comment>
    <expr><block>{ <expr>0x0020</expr>, <expr>0x0020</expr> }</block></expr>,
    <comment type="block">/* NO-BREAK SPACE */</comment>
    <expr><block>{ <expr>0x00A0</expr>, <expr>0x00A0</expr> }</block></expr>,
    <comment type="block">/*
     * EN QUAD, EM QUAD, EN SPACE, EM SPACE, THREE-PER-EM SPACE, FOUR-PER-EM
     * SPACE, SIX-PER-EM SPACE, FIGURE SPACE, PUNCTUATION SPACE, THIN SPACE,
     * HAIR SPACE, ZERO WIDTH SPACE
     */</comment>
    <expr><block>{ <expr>0x2000</expr>, <expr>0x200B</expr> }</block></expr>,
    <comment type="block">/* LS, PS */</comment>
    <expr><block>{ <expr>0x2028</expr>, <expr>0x2029</expr> }</block></expr>,
    <comment type="block">/* NARROW NO-BREAK SPACE */</comment>
    <expr><block>{ <expr>0x202F</expr>, <expr>0x202F</expr> }</block></expr>,
    <comment type="block">/* IDEOGRAPHIC SPACE */</comment>
    <expr><block>{ <expr>0x3000</expr>, <expr>0x3000</expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ECMA-262 standard, section 15.10.2.6. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CharacterRange</name></type> <name><name>WordRanges</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><call><name>jschar</name><argument_list>(<argument><expr>'0'</expr></argument>)</argument_list></call></expr>, <macro><name>jschar</name><argument_list>(<argument>'9'</argument>)</argument_list></macro> }</block></expr>,
    <expr><block>{ <expr><call><name>jschar</name><argument_list>(<argument><expr>'A'</expr></argument>)</argument_list></call></expr>, <macro><name>jschar</name><argument_list>(<argument>'Z'</argument>)</argument_list></macro> }</block></expr>,
    <expr><block>{ <expr><call><name>jschar</name><argument_list>(<argument><expr>'_'</expr></argument>)</argument_list></call></expr>, <macro><name>jschar</name><argument_list>(<argument>'_'</argument>)</argument_list></macro> }</block></expr>,
    <expr><block>{ <expr><call><name>jschar</name><argument_list>(<argument><expr>'a'</expr></argument>)</argument_list></call></expr>, <macro><name>jschar</name><argument_list>(<argument>'z'</argument>)</argument_list></macro> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddCharacterRanges</name><parameter_list>(<param><decl><type><name>RECharSet</name> *</type><name>charSet</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>CharacterRange</name> *</type><name>range</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>CharacterRange</name> *</type><name>end</name></decl></param>)</parameter_list>
<block>{
    <for>for (<init>;</init> <condition><expr><name>range</name> &lt; <name>end</name></expr>;</condition> <incr><expr>++<name>range</name></expr></incr>)
        <expr_stmt><expr><call><name>AddCharacterRangeToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddInvertedCharacterRanges</name><parameter_list>(<param><decl><type><name>RECharSet</name> *</type><name>charSet</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>CharacterRange</name> *</type><name>range</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>CharacterRange</name> *</type><name>end</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint16</name></type> <name>previous</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init> <condition><expr><name>range</name> &lt; <name>end</name></expr>;</condition> <incr><expr>++<name>range</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name>AddCharacterRangeToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>start</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>previous</name> = <name><name>range</name>-&gt;<name>end</name></name> + 1</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>AddCharacterRangeToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>, <argument><expr><name><name>charSet</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Compile the source of the class into a RECharSet */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ProcessCharSet</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSRegExp</name> *</type><name>re</name></decl></param>, <param><decl><type><name>RECharSet</name> *</type><name>charSet</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>src</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>inRange</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name>rangeStart</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>byteLength</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>thisCh</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>intN</name></type> <name>nDigits</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>charSet</name>-&gt;<name>converted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Assert that startIndex and length points to chars inside [] inside
     * source string.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>1 &lt;= <name><name>charSet</name>-&gt;<name>u</name>.<name>src</name>.<name>startIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>charSet</name>-&gt;<name>u</name>.<name>src</name>.<name>startIndex</name></name> &lt; <call><name><name>re</name>-&gt;<name>source</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>charSet</name>-&gt;<name>u</name>.<name>src</name>.<name>length</name></name> &lt;= <call><name><name>re</name>-&gt;<name>source</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call>
                                       - 1 - <name><name>charSet</name>-&gt;<name>u</name>.<name>src</name>.<name>startIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>charSet</name>-&gt;<name>converted</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>src</name> = <call><name><name>re</name>-&gt;<name>source</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <name><name>charSet</name>-&gt;<name>u</name>.<name>src</name>.<name>startIndex</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>src</name> + <name><name>charSet</name>-&gt;<name>u</name>.<name>src</name>.<name>length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>src</name><index>[<expr>-1</expr>]</index></name> == '['</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>end</name><index>[<expr>0</expr>]</index></name> == ']'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>byteLength</name> = (<name><name>charSet</name>-&gt;<name>length</name></name> &gt;&gt; 3) + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>charSet</name>-&gt;<name>u</name>.<name>bits</name></name> = (<name>uint8</name> *)<call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>byteLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>charSet</name>-&gt;<name>u</name>.<name>bits</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>charSet</name>-&gt;<name>u</name>.<name>bits</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>byteLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>src</name> == <name>end</name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <if>if <condition>(<expr>*<name>src</name> == '^'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>charSet</name>-&gt;<name>sense</name></name> == <name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>src</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>charSet</name>-&gt;<name>sense</name></name> == <name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <while>while <condition>(<expr><name>src</name> != <name>end</name></expr>)</condition> <block>{
        <switch>switch <condition>(<expr>*<name>src</name></expr>)</condition> <block>{
          <case>case <expr>'\\'</expr>:
            <expr_stmt><expr>++<name>src</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> = *<name>src</name>++</expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
              <case>case <expr>'b'</expr>:
                <expr_stmt><expr><name>thisCh</name> = 0x8</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'f'</expr>:
                <expr_stmt><expr><name>thisCh</name> = 0xC</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'n'</expr>:
                <expr_stmt><expr><name>thisCh</name> = 0xA</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'r'</expr>:
                <expr_stmt><expr><name>thisCh</name> = 0xD</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'t'</expr>:
                <expr_stmt><expr><name>thisCh</name> = 0x9</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'v'</expr>:
                <expr_stmt><expr><name>thisCh</name> = 0xB</expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'c'</expr>:
                <if>if <condition>(<expr><name>src</name> &lt; <name>end</name> &amp;&amp; <call><name>JS_ISWORD</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>thisCh</name> = <call>(<name>jschar</name>)<argument_list>(<argument><expr>*<name>src</name>++ &amp; 0x1F</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr>--<name>src</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>thisCh</name> = '\\'</expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>
              </case><case>case <expr>'x'</expr>:
                <expr_stmt><expr><name>nDigits</name> = 2</expr>;</expr_stmt>
                <goto>goto <name>lexHex</name>;</goto>
              </case><case>case <expr>'u'</expr>:
                <expr_stmt><expr><name>nDigits</name> = 4</expr>;</expr_stmt>
            <label><name>lexHex</name>:</label>
                <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr>(<name>i</name> &lt; <name>nDigits</name>) &amp;&amp; (<name>src</name> &lt; <name>end</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>uintN</name></type> <name>digit</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>c</name> = *<name>src</name>++</expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>isASCIIHexDigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>&amp;<name>digit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="block">/*
                         * Back off to accepting the original '\'
                         * as a literal
                         */</comment>
                        <expr_stmt><expr><name>src</name> -= <name>i</name> + 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name>n</name> = '\\'</expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 4) | <name>digit</name></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><name>thisCh</name> = (<name>jschar</name>)<name>n</name></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr>'0'</expr>:
              </case><case>case <expr>'1'</expr>:
              </case><case>case <expr>'2'</expr>:
              </case><case>case <expr>'3'</expr>:
              </case><case>case <expr>'4'</expr>:
              </case><case>case <expr>'5'</expr>:
              </case><case>case <expr>'6'</expr>:
              </case><case>case <expr>'7'</expr>:
                <comment type="block">/*
                 *  This is a non-ECMA extension - decimal escapes (in this
                 *  case, octal!) are supposed to be an error inside class
                 *  ranges, but supported here for backwards compatibility.
                 */</comment>
                <expr_stmt><expr><name>n</name> = <call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>c</name> = *<name>src</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>'0' &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= '7'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>src</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name>n</name> = 8 * <name>n</name> + <call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>c</name> = *<name>src</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>'0' &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= '7'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>src</name>++</expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> = 8 * <name>n</name> + <call><name>JS7_UNDEC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>i</name> &lt;= 0377</expr>)</condition><then>
                            <expr_stmt><expr><name>n</name> = <name>i</name></expr>;</expr_stmt></then>
                        <else>else
                            <expr_stmt><expr><name>src</name>--</expr>;</expr_stmt></else></if>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>thisCh</name> = (<name>jschar</name>)<name>n</name></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr>'d'</expr>:
                <expr_stmt><expr><call><name>AddCharacterRangeToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr>'0'</expr></argument>, <argument><expr>'9'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>   <comment type="block">/* don't need range processing */</comment>
              </case><case>case <expr>'D'</expr>:
                <expr_stmt><expr><call><name>AddCharacterRangeToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>'0' - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>AddCharacterRangeToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>,
                                           <argument><expr><call>(<name>jschar</name>)<argument_list>(<argument><expr>'9' + 1</expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr>(<name>jschar</name>)<name><name>charSet</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
              </case><case>case <expr>'s'</expr>:
                <expr_stmt><expr><call><name>AddCharacterRanges</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>WhiteSpaceRanges</name></expr></argument>,
                                   <argument><expr><name>WhiteSpaceRanges</name> + <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>WhiteSpaceRanges</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
              </case><case>case <expr>'S'</expr>:
                <expr_stmt><expr><call><name>AddInvertedCharacterRanges</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>WhiteSpaceRanges</name></expr></argument>,
                                           <argument><expr><name>WhiteSpaceRanges</name> + <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>WhiteSpaceRanges</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
              </case><case>case <expr>'w'</expr>:
                <expr_stmt><expr><call><name>AddCharacterRanges</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>WordRanges</name></expr></argument>,
                                   <argument><expr><name>WordRanges</name> + <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>WordRanges</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
              </case><case>case <expr>'W'</expr>:
                <expr_stmt><expr><call><name>AddInvertedCharacterRanges</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>WordRanges</name></expr></argument>,
                                           <argument><expr><name>WordRanges</name> + <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>WordRanges</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
              </case><default>default:
                <expr_stmt><expr><name>thisCh</name> = <name>c</name></expr>;</expr_stmt>
                <break>break;</break>

            </default>}</block></switch>
            <break>break;</break>

          </case><default>default:
            <expr_stmt><expr><name>thisCh</name> = *<name>src</name>++</expr>;</expr_stmt>
            <break>break;</break>

        </default>}</block></switch>
        <if>if <condition>(<expr><name>inRange</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>rangeStart</name> &lt;= <name>thisCh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for (<init><expr><name>i</name> = <name>rangeStart</name></expr>;</init> <condition><expr><name>i</name> &lt;= <name>thisCh</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <decl_stmt><decl><type><name>jschar</name></type> <name>uch</name></decl>, <decl><type ref="prev"/><name>dch</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>AddCharacterToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>uch</name> = <call><name>upcase</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>dch</name> = <call><name>inverse_upcase</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>i</name> != <name>uch</name></expr>)</condition><then>
                        <expr_stmt><expr><call><name>AddCharacterToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>uch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <if>if <condition>(<expr><name>i</name> != <name>dch</name></expr>)</condition><then>
                        <expr_stmt><expr><call><name>AddCharacterToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>dch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></for>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>AddCharacterRangeToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>rangeStart</name></expr></argument>, <argument><expr><name>thisCh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>inRange</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>AddCharacterToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><call><name>upcase</name><argument_list>(<argument><expr><name>thisCh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>AddCharacterToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><call><name>inverse_upcase</name><argument_list>(<argument><expr><name>thisCh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>AddCharacterToCharSet</name><argument_list>(<argument><expr><name>charSet</name></expr></argument>, <argument><expr><name>thisCh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <if>if <condition>(<expr><name>src</name> &lt; <name>end</name> - 1</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>*<name>src</name> == '-'</expr>)</condition><then> <block>{
                    <expr_stmt><expr>++<name>src</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inRange</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rangeStart</name> = <name>thisCh</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></else></if>
    }</block></while>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>JSBool</name></type>
<name>MatcherProcessCharSet</name><parameter_list>(<param><decl><type><name>REGlobalData</name> *</type><name>gData</name></decl></param>, <param><decl><type><name>RECharSet</name> *</type><name>charSet</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>rv</name> <init>= <expr><call><name>ProcessCharSet</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>cx</name></name></expr></argument>, <argument><expr><name><name>gData</name>-&gt;<name>regexp</name></name></expr></argument>, <argument><expr><name>charSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>rv</name></expr>)</condition><then> <expr_stmt><expr><name><name>gData</name>-&gt;<name>ok</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_DestroyRegExp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSRegExp</name> *</type><name>re</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>JS_ATOMIC_DECREMENT</name><argument_list>(<argument><expr>&amp;<name><name>re</name>-&gt;<name>nrefs</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>re</name>-&gt;<name>classList</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>re</name>-&gt;<name>classCount</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>re</name>-&gt;<name>classList</name><index>[<expr><name>i</name></expr>]</index></name>.<name>converted</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name><name>re</name>-&gt;<name>classList</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>u</name>.<name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name><name>re</name>-&gt;<name>classList</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>u</name>.<name>bits</name></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name><name>re</name>-&gt;<name>classList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ReallocStateStack</name><parameter_list>(<param><decl><type><name>REGlobalData</name> *</type><name>gData</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>limit</name> <init>= <expr><name><name>gData</name>-&gt;<name>stateStackLimit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>REProgState</name></expr></argument>)</argument_list></sizeof> * <name>limit</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ARENA_GROW_CAST</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>stateStack</name></name></expr></argument>, <argument><expr><name>REProgState</name> *</expr></argument>,
                       <argument><expr>&amp;<name><name>gData</name>-&gt;<name>cx</name>-&gt;<name>regexpPool</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>gData</name>-&gt;<name>stateStack</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>cx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gData</name>-&gt;<name>ok</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>gData</name>-&gt;<name>stateStackLimit</name></name> = <name>limit</name> + <name>limit</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH_STATE_STACK</name><parameter_list>(<param><type><name>data</name></type></param>)</parameter_list></cpp:macro>                                                \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        ++(data)-&gt;stateStackTop;                                              \
        if ((data)-&gt;stateStackTop == (data)-&gt;stateStackLimit &amp;&amp;               \
            !ReallocStateStack((data))) {                                     \
            return NULL;                                                      \
        }                                                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<comment type="block">/*
 * Apply the current op against the given input to see if it's going to match
 * or fail. Return false if we don't get a match, true if we do. If updatecp is
 * true, then update the current state's cp. Always update startpc to the next
 * op.
 */</comment>
<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>REMatchState</name> *</type>
<name>SimpleMatch</name><parameter_list>(<param><decl><type><name>REGlobalData</name> *</type><name>gData</name></decl></param>, <param><decl><type><name>REMatchState</name> *</type><name>x</name></decl></param>, <param><decl><type><name>REOp</name></type> <name>op</name></decl></param>,
            <param><decl><type><name>jsbytecode</name> **</type><name>startpc</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>updatecp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>REMatchState</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name>matchCh</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>parenIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>length</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name> <init>= <expr>*<name>startpc</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* pc has already been incremented past op */</comment>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>source</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>startcp</name> <init>= <expr><name><name>x</name>-&gt;<name>cp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name></type> <name>ch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RECharSet</name> *</type><name>charSet</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REGEXP_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>opname</name> <init>= <expr><name><name>reop_names</name><index>[<expr><name>op</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>"\n%06d: %*s%s"</expr></argument>, <argument><expr><name>pc</name> - <name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>program</name></name></expr></argument>,
             <argument><expr><name><name>gData</name>-&gt;<name>stateStackTop</name></name> * 2</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
      <case>case <expr><name>REOP_EMPTY</name></expr>:
        <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>REOP_BOL</name></expr>:
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpbegin</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name><name>gData</name>-&gt;<name>cx</name>-&gt;<name>regExpStatics</name>.<name>multiline</name></name> &amp;&amp;
                !(<name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_MULTILINE</name>)</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>RE_IS_LINE_TERM</name><argument_list>(<argument><expr><name><name>x</name>-&gt;<name>cp</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <break>break;</break></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>REOP_EOL</name></expr>:
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name><name>gData</name>-&gt;<name>cx</name>-&gt;<name>regExpStatics</name>.<name>multiline</name></name> &amp;&amp;
                !(<name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_MULTILINE</name>)</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>RE_IS_LINE_TERM</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <break>break;</break></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>REOP_WBDRY</name></expr>:
        <if>if <condition>(<expr>(<name><name>x</name>-&gt;<name>cp</name></name> == <name><name>gData</name>-&gt;<name>cpbegin</name></name> || !<call><name>JS_ISWORD</name><argument_list>(<argument><expr><name><name>x</name>-&gt;<name>cp</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call>) ^
            !(<name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; <call><name>JS_ISWORD</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_WNONBDRY</name></expr>:
        <if>if <condition>(<expr>(<name><name>x</name>-&gt;<name>cp</name></name> == <name><name>gData</name>-&gt;<name>cpbegin</name></name> || !<call><name>JS_ISWORD</name><argument_list>(<argument><expr><name><name>x</name>-&gt;<name>cp</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call>) ^
            (<name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; <call><name>JS_ISWORD</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_DOT</name></expr>:
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; !<call><name>RE_IS_LINE_TERM</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_DIGIT</name></expr>:
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; <call><name>JS7_ISDEC</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_NONDIGIT</name></expr>:
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; !<call><name>JS7_ISDEC</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_ALNUM</name></expr>:
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; <call><name>JS_ISWORD</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_NONALNUM</name></expr>:
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; !<call><name>JS_ISWORD</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_SPACE</name></expr>:
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; <call><name>JS_ISSPACE</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_NONSPACE</name></expr>:
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; !<call><name>JS_ISSPACE</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_BACKREF</name></expr>:
        <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>parenIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>parenIndex</name> &lt; <name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>parenCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> = <call><name>BackrefMatcher</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>parenIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>REOP_FLAT</name></expr>:
        <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>offset</name> &lt; <call><name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>source</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>1 &lt;= <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>length</name> &lt;= <call><name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>source</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> - <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>length</name> &lt;= <call>(<name>size_t</name>)<argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>cpend</name></name> - <name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>source</name> = <call><name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>source</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call> + <name>offset</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>re_debug_chars</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name>index</name> != <name>length</name></expr>;</condition> <incr><expr><name>index</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>source</name><index>[<expr><name>index</name></expr>]</index></name> != <name><name>x</name>-&gt;<name>cp</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then>
                    <return>return <expr><name>NULL</name></expr>;</return></then></if>
            }</block></for>
            <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> += <name>length</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_FLAT1</name></expr>:
        <expr_stmt><expr><name>matchCh</name> = *<name>pc</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>" '%c' == '%c'"</expr></argument>, <argument><expr>(<name>char</name>)<name>matchCh</name></expr></argument>, <argument><expr>(<name>char</name>)*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; *<name><name>x</name>-&gt;<name>cp</name></name> == <name>matchCh</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_FLATi</name></expr>:
        <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>offset</name> &lt; <call><name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>source</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>1 &lt;= <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>length</name> &lt;= <call><name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>source</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> - <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>source</name> = <call><name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>source</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> = <call><name>FlatNIMatcher</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>source</name> + <name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>REOP_FLAT1i</name></expr>:
        <expr_stmt><expr><name>matchCh</name> = *<name>pc</name>++</expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; <call><name>upcase</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call> == <call><name>upcase</name><argument_list>(<argument><expr><name>matchCh</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_UCFLAT1</name></expr>:
        <expr_stmt><expr><name>matchCh</name> = <call><name>GET_ARG</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>" '%c' == '%c'"</expr></argument>, <argument><expr>(<name>char</name>)<name>matchCh</name></expr></argument>, <argument><expr>(<name>char</name>)*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; *<name><name>x</name>-&gt;<name>cp</name></name> == <name>matchCh</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_UCFLAT1i</name></expr>:
        <expr_stmt><expr><name>matchCh</name> = <call><name>GET_ARG</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name> &amp;&amp; <call><name>upcase</name><argument_list>(<argument><expr>*<name><name>x</name>-&gt;<name>cp</name></name></expr></argument>)</argument_list></call> == <call><name>upcase</name><argument_list>(<argument><expr><name>matchCh</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_CLASS</name></expr>:
        <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>index</name> &lt; <name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>classCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>charSet</name> = &amp;<name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>classList</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>charSet</name>-&gt;<name>converted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ch</name> = *<name><name>x</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>index</name> = <name>ch</name> &gt;&gt; 3</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ch</name> &lt;= <name><name>charSet</name>-&gt;<name>length</name></name> &amp;&amp;
                (<name><name>charSet</name>-&gt;<name>u</name>.<name>bits</name><index>[<expr><name>index</name></expr>]</index></name> &amp; (1 &lt;&lt; (<name>ch</name> &amp; 0x7)))</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>REOP_NCLASS</name></expr>:
        <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>index</name> &lt; <name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>classCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>charSet</name> = &amp;<name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>classList</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>charSet</name>-&gt;<name>converted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ch</name> = *<name><name>x</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>index</name> = <name>ch</name> &gt;&gt; 3</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ch</name> &gt; <name><name>charSet</name>-&gt;<name>length</name></name> ||
                !(<name><name>charSet</name>-&gt;<name>u</name>.<name>bits</name><index>[<expr><name>index</name></expr>]</index></name> &amp; (1 &lt;&lt; (<name>ch</name> &amp; 0x7)))</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <break>break;</break>

      </case><default>default:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>
    <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>updatecp</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> = <name>startcp</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr>*<name>startpc</name> = <name>pc</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>" * "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> = <name>startcp</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>REMatchState</name> *</type>
<name>ExecuteREBytecode</name><parameter_list>(<param><decl><type><name>REGlobalData</name> *</type><name>gData</name></decl></param>, <param><decl><type><name>REMatchState</name> *</type><name>x</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>REMatchState</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>REBackTrackData</name> *</type><name>backTrackData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>nextpc</name></decl>, *<decl><type ref="prev"/><name>testpc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>REOp</name></type> <name>nextop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RECapture</name> *</type><name>cap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>REProgState</name> *</type><name>curState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>startcp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>parenIndex</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>parenSoFar</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>jschar</name></type> <name>matchCh1</name></decl>, <decl><type ref="prev"/><name>matchCh2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RECharSet</name> *</type><name>charSet</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSBool</name></type> <name>anchor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name> <init>= <expr><name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>program</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>REOp</name></type> <name>op</name> <init>= <expr>(<name>REOp</name>) *<name>pc</name>++</expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If the first node is a simple match, step the index into the string
     * until that match is made, or fail if it can't be found at all.
     */</comment>
    <if>if <condition>(<expr><call><name>REOP_IS_SIMPLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> &amp;&amp; !(<name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_STICKY</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>anchor</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> &lt;= <name><name>gData</name>-&gt;<name>cpend</name></name></expr>)</condition> <block>{
            <expr_stmt><expr><name>nextpc</name> = <name>pc</name></expr>;</expr_stmt>    <comment type="block">/* reset back to start each time */</comment>
            <expr_stmt><expr><name>result</name> = <call><name>SimpleMatch</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>nextpc</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>anchor</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>x</name> = <name>result</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> = <name>nextpc</name></expr>;</expr_stmt>    <comment type="block">/* accept skip to next opcode */</comment>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> &lt; <name>REOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name><name>gData</name>-&gt;<name>skipped</name></name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name>++</expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr>!<name>anchor</name></expr>)</condition><then>
            <goto>goto <name>bad</name>;</goto></then></if>
    }</block></then></if>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REGEXP_DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>opname</name> <init>= <expr><name><name>reop_names</name><index>[<expr><name>op</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>"\n%06d: %*s%s"</expr></argument>, <argument><expr><name>pc</name> - <name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>program</name></name></expr></argument>,
                 <argument><expr><name><name>gData</name>-&gt;<name>stateStackTop</name></name> * 2</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr><call><name>REOP_IS_SIMPLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <call><name>SimpleMatch</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>pc</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>curState</name> = &amp;<name><name>gData</name>-&gt;<name>stateStack</name><index>[<expr><name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr>]</index></name></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
              <case>case <expr><name>REOP_END</name></expr>:
                <goto>goto <name>good</name>;</goto>
              </case><case>case <expr><name>REOP_ALTPREREQ2</name></expr>:
                <expr_stmt><expr><name>nextpc</name> = <name>pc</name> + <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* start of next op */</comment>
                <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchCh2</name> = <call><name>GET_ARG</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>k</name> = <call><name>GET_ARG</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>

                <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> != <name><name>gData</name>-&gt;<name>cpend</name></name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>*<name><name>x</name>-&gt;<name>cp</name></name> == <name>matchCh2</name></expr>)</condition><then>
                        <goto>goto <name>doAlt</name>;</goto></then></if>

                    <expr_stmt><expr><name>charSet</name> = &amp;<name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>classList</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name><name>charSet</name>-&gt;<name>converted</name></name> &amp;&amp; !<call><name>MatcherProcessCharSet</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>charSet</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <goto>goto <name>bad</name>;</goto></then></if>
                    <expr_stmt><expr><name>matchCh1</name> = *<name><name>x</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>k</name> = <name>matchCh1</name> &gt;&gt; 3</expr>;</expr_stmt>
                    <if>if <condition>(<expr>(<name>matchCh1</name> &gt; <name><name>charSet</name>-&gt;<name>length</name></name> ||
                         !(<name><name>charSet</name>-&gt;<name>u</name>.<name>bits</name><index>[<expr><name>k</name></expr>]</index></name> &amp; (1 &lt;&lt; (<name>matchCh1</name> &amp; 0x7)))) ^
                        <name><name>charSet</name>-&gt;<name>sense</name></name></expr>)</condition><then> <block>{
                        <goto>goto <name>doAlt</name>;</goto>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
                <break>break;</break>

              </case><case>case <expr><name>REOP_ALTPREREQ</name></expr>:
                <expr_stmt><expr><name>nextpc</name> = <name>pc</name> + <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* start of next op */</comment>
                <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchCh1</name> = <call><name>GET_ARG</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>matchCh2</name> = <call><name>GET_ARG</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>x</name>-&gt;<name>cp</name></name> == <name><name>gData</name>-&gt;<name>cpend</name></name> ||
                    (*<name><name>x</name>-&gt;<name>cp</name></name> != <name>matchCh1</name> &amp;&amp; *<name><name>x</name>-&gt;<name>cp</name></name> != <name>matchCh2</name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <comment type="block">/* else false thru... */</comment>

              </case><case>case <expr><name>REOP_ALT</name></expr>:
              <label><name>doAlt</name>:</label>
                <expr_stmt><expr><name>nextpc</name> = <name>pc</name> + <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* start of next alternate */</comment>
                <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>                  <comment type="block">/* start of this alternate */</comment>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>parenSoFar</name></name> = <name>parenSoFar</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PUSH_STATE_STACK</name><argument_list>(<argument><expr><name>gData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>startcp</name> = <name><name>x</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>REOP_IS_SIMPLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>SimpleMatch</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>pc</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>nextpc</name>++</expr>;</expr_stmt>
                        <expr_stmt><expr><name>pc</name> = <name>nextpc</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>
                    <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>nextop</name> = (<name>REOp</name>) *<name>nextpc</name>++</expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>PushBackTrackState</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>nextop</name></expr></argument>, <argument><expr><name>nextpc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>startcp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>bad</name>;</goto></then></if>
                <continue>continue;</continue>

              <comment type="block">/*
               * Occurs at (successful) end of REOP_ALT,
               */</comment>
              </case><case>case <expr><name>REOP_JUMP</name></expr>:
                <comment type="block">/*
                 * If we have not gotten a result here, it is because of an
                 * empty match.  Do the same thing REOP_EMPTY would do.
                 */</comment>
                <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
                    <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt></then></if>

                <expr_stmt><expr>--<name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                <continue>continue;</continue>

              <comment type="block">/*
               * Occurs at last (successful) end of REOP_ALT,
               */</comment>
              </case><case>case <expr><name>REOP_ENDALT</name></expr>:
                <comment type="block">/*
                 * If we have not gotten a result here, it is because of an
                 * empty match.  Do the same thing REOP_EMPTY would do.
                 */</comment>
                <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
                    <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt></then></if>

                <expr_stmt><expr>--<name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                <continue>continue;</continue>

              </case><case>case <expr><name>REOP_LPAREN</name></expr>:
                <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>parenIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>"[ %lu ]"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>) <name>parenIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>parenIndex</name> &lt; <name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>parenCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>parenIndex</name> + 1 &gt; <name>parenSoFar</name></expr>)</condition><then>
                    <expr_stmt><expr><name>parenSoFar</name> = <name>parenIndex</name> + 1</expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name><name>x</name>-&gt;<name>parens</name><index>[<expr><name>parenIndex</name></expr>]</index></name>.<name>index</name> = <name><name>x</name>-&gt;<name>cp</name></name> - <name><name>gData</name>-&gt;<name>cpbegin</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name>-&gt;<name>parens</name><index>[<expr><name>parenIndex</name></expr>]</index></name>.<name>length</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                <continue>continue;</continue>

              </case><case>case <expr><name>REOP_RPAREN</name></expr>:
              <block>{
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>delta</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>parenIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>parenIndex</name> &lt; <name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>parenCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>cap</name> = &amp;<name><name>x</name>-&gt;<name>parens</name><index>[<expr><name>parenIndex</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>delta</name> = <name><name>x</name>-&gt;<name>cp</name></name> - (<name><name>gData</name>-&gt;<name>cpbegin</name></name> + <name><name>cap</name>-&gt;<name>index</name></name>)</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cap</name>-&gt;<name>length</name></name> = (<name>delta</name> &lt; 0) ? 0 : (<name>size_t</name>) <name>delta</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>

                <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
                    <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt></then></if>
                <continue>continue;</continue>
              }</block>
              </case><case>case <expr><name>REOP_ASSERT</name></expr>:
                <expr_stmt><expr><name>nextpc</name> = <name>pc</name> + <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* start of term after ASSERT */</comment>
                <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>                 <comment type="block">/* start of ASSERT child */</comment>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>testpc</name> = <name>pc</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>REOP_IS_SIMPLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> &amp;&amp;
                    !<call><name>SimpleMatch</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>testpc</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>assertion</name>.<name>top</name></name> =
                    (<name>char</name> *)<name><name>gData</name>-&gt;<name>backTrackSP</name></name> - (<name>char</name> *)<name><name>gData</name>-&gt;<name>backTrackStack</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>assertion</name>.<name>sz</name></name> = <name><name>gData</name>-&gt;<name>cursz</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>index</name></name> = <name><name>x</name>-&gt;<name>cp</name></name> - <name><name>gData</name>-&gt;<name>cpbegin</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>parenSoFar</name></name> = <name>parenSoFar</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PUSH_STATE_STACK</name><argument_list>(<argument><expr><name>gData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>PushBackTrackState</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>REOP_ASSERTTEST</name></expr></argument>,
                                        <argument><expr><name>nextpc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>x</name>-&gt;<name>cp</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <goto>goto <name>bad</name>;</goto>
                }</block></then></if>
                <continue>continue;</continue>

              </case><case>case <expr><name>REOP_ASSERT_NOT</name></expr>:
                <expr_stmt><expr><name>nextpc</name> = <name>pc</name> + <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <name>ARG_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>testpc</name> = <name>pc</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>REOP_IS_SIMPLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <comment type="block">/* Note - fail to fail! */</comment> &amp;&amp;
                    <call><name>SimpleMatch</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>testpc</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call> &amp;&amp;
                    *<name>testpc</name> == <name>REOP_ASSERTNOTTEST</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>assertion</name>.<name>top</name></name>
                    = (<name>char</name> *)<name><name>gData</name>-&gt;<name>backTrackSP</name></name> -
                      (<name>char</name> *)<name><name>gData</name>-&gt;<name>backTrackStack</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>assertion</name>.<name>sz</name></name> = <name><name>gData</name>-&gt;<name>cursz</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>index</name></name> = <name><name>x</name>-&gt;<name>cp</name></name> - <name><name>gData</name>-&gt;<name>cpbegin</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>parenSoFar</name></name> = <name>parenSoFar</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PUSH_STATE_STACK</name><argument_list>(<argument><expr><name>gData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>PushBackTrackState</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>REOP_ASSERTNOTTEST</name></expr></argument>,
                                        <argument><expr><name>nextpc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>x</name>-&gt;<name>cp</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <goto>goto <name>bad</name>;</goto>
                }</block></then></if>
                <continue>continue;</continue>

              </case><case>case <expr><name>REOP_ASSERTTEST</name></expr>:
                <expr_stmt><expr>--<name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr>;</expr_stmt>
                <expr_stmt><expr>--<name>curState</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> = <name><name>gData</name>-&gt;<name>cpbegin</name></name> + <name><name>curState</name>-&gt;<name>index</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackSP</name></name> =
                    (<name>REBackTrackData</name> *) ((<name>char</name> *)<name><name>gData</name>-&gt;<name>backTrackStack</name></name> +
                                         <name><name>curState</name>-&gt;<name>u</name>.<name>assertion</name>.<name>top</name></name>)</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gData</name>-&gt;<name>cursz</name></name> = <name><name>curState</name>-&gt;<name>u</name>.<name>assertion</name>.<name>sz</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>result</name></expr>)</condition><then>
                    <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt></then></if>
                <break>break;</break>

              </case><case>case <expr><name>REOP_ASSERTNOTTEST</name></expr>:
                <expr_stmt><expr>--<name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr>;</expr_stmt>
                <expr_stmt><expr>--<name>curState</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> = <name><name>gData</name>-&gt;<name>cpbegin</name></name> + <name><name>curState</name>-&gt;<name>index</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackSP</name></name> =
                    (<name>REBackTrackData</name> *) ((<name>char</name> *)<name><name>gData</name>-&gt;<name>backTrackStack</name></name> +
                                         <name><name>curState</name>-&gt;<name>u</name>.<name>assertion</name>.<name>top</name></name>)</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gData</name>-&gt;<name>cursz</name></name> = <name><name>curState</name>-&gt;<name>u</name>.<name>assertion</name>.<name>sz</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> = (!<name>result</name>) ? <name>x</name> : <name>NULL</name></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr><name>REOP_STAR</name></expr>:
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> = (<name>uintN</name>)-1</expr>;</expr_stmt>
                <goto>goto <name>quantcommon</name>;</goto>
              </case><case>case <expr><name>REOP_PLUS</name></expr>:
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> = (<name>uintN</name>)-1</expr>;</expr_stmt>
                <goto>goto <name>quantcommon</name>;</goto>
              </case><case>case <expr><name>REOP_OPT</name></expr>:
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> = 1</expr>;</expr_stmt>
                <goto>goto <name>quantcommon</name>;</goto>
              </case><case>case <expr><name>REOP_QUANT</name></expr>:
                <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> = <name>k</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* max is k - 1 to use one byte for (uintN)-1 sentinel. */</comment>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> = <name>k</name> - 1</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name>
                          &lt;= <name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>quantcommon</name>:</label>
                <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> == 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pc</name> = <name>pc</name> + <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>
                <comment type="block">/* Step over &lt;next&gt; */</comment>
                <expr_stmt><expr><name>nextpc</name> = <name>pc</name> + <name>ARG_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>nextpc</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>startcp</name> = <name><name>x</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>REOP_IS_SIMPLE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>SimpleMatch</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>nextpc</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> == 0</expr>)</condition><then>
                            <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt></then>
                        <else>else
                            <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
                        <expr_stmt><expr><name>pc</name> = <name>pc</name> + <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>nextpc</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>index</name></name> = <name>startcp</name> - <name><name>gData</name>-&gt;<name>cpbegin</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>continue_op</name></name> = <name>REOP_REPEAT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>continue_pc</name></name> = <name>pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>parenSoFar</name></name> = <name>parenSoFar</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PUSH_STATE_STACK</name><argument_list>(<argument><expr><name>gData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> == 0 &amp;&amp;
                    !<call><name>PushBackTrackState</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>REOP_REPEAT</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>startcp</name></expr></argument>,
                                        <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <goto>goto <name>bad</name>;</goto>
                }</block></then></if>
                <expr_stmt><expr><name>pc</name> = <name>nextpc</name></expr>;</expr_stmt>
                <continue>continue;</continue>

              </case><case>case <expr><name>REOP_ENDCHILD</name></expr>: <comment type="block">/* marks the end of a quantifier child */</comment>
                <expr_stmt><expr><name>pc</name> = <name><name>curState</name><index>[<expr>-1</expr>]</index></name>.<name>continue_pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) <name><name>curState</name><index>[<expr>-1</expr>]</index></name>.<name>continue_op</name></expr>;</expr_stmt>

                <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
                    <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt></then></if>
                <continue>continue;</continue>

              </case><case>case <expr><name>REOP_REPEAT</name></expr>:
                <expr_stmt><expr>--<name>curState</name></expr>;</expr_stmt>
                <do>do <block>{
                    <expr_stmt><expr>--<name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
                        <comment type="block">/* Failed, see if we have enough children. */</comment>
                        <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> == 0</expr>)</condition><then>
                            <goto>goto <name>repeatDone</name>;</goto></then></if>
                        <goto>goto <name>break_switch</name>;</goto>
                    }</block></then></if>
                    <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> == 0 &amp;&amp;
                        <name><name>x</name>-&gt;<name>cp</name></name> == <name><name>gData</name>-&gt;<name>cpbegin</name></name> + <name><name>curState</name>-&gt;<name>index</name></name></expr>)</condition><then> <block>{
                        <comment type="block">/* matched an empty string, that'll get us nowhere */</comment>
                        <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
                        <goto>goto <name>break_switch</name>;</goto>
                    }</block></then></if>
                    <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> != 0</expr>)</condition><then>
                        <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name>--</expr>;</expr_stmt></then></if>
                    <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> != (<name>uintN</name>) -1</expr>)</condition><then>
                        <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name>--</expr>;</expr_stmt></then></if>
                    <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> == 0</expr>)</condition><then>
                        <goto>goto <name>repeatDone</name>;</goto></then></if>
                    <expr_stmt><expr><name>nextpc</name> = <name>pc</name> + <name>ARG_LEN</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>nextop</name> = (<name>REOp</name>) *<name>nextpc</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>startcp</name> = <name><name>x</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name>REOP_IS_SIMPLE</name><argument_list>(<argument><expr><name>nextop</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>nextpc</name>++</expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<call><name>SimpleMatch</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>nextop</name></expr></argument>, <argument><expr>&amp;<name>nextpc</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> == 0</expr>)</condition><then>
                                <goto>goto <name>repeatDone</name>;</goto></then></if>
                            <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
                            <goto>goto <name>break_switch</name>;</goto>
                        }</block></then></if>
                        <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name><name>curState</name>-&gt;<name>index</name></name> = <name>startcp</name> - <name><name>gData</name>-&gt;<name>cpbegin</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>PUSH_STATE_STACK</name><argument_list>(<argument><expr><name>gData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> == 0 &amp;&amp;
                        !<call><name>PushBackTrackState</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>REOP_REPEAT</name></expr></argument>,
                                            <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>startcp</name></expr></argument>,
                                            <argument><expr><name><name>curState</name>-&gt;<name>parenSoFar</name></name></expr></argument>,
                                            <argument><expr><name>parenSoFar</name> -
                                            <name><name>curState</name>-&gt;<name>parenSoFar</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <goto>goto <name>bad</name>;</goto>
                    }</block></then></if>
                }</block> while <condition>(<expr>*<name>nextpc</name> == <name>REOP_ENDCHILD</name></expr>)</condition>;</do>
                <expr_stmt><expr><name>pc</name> = <name>nextpc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>parenSoFar</name> = <name><name>curState</name>-&gt;<name>parenSoFar</name></name></expr>;</expr_stmt>
                <continue>continue;</continue>

              <label><name>repeatDone</name>:</label>
                <expr_stmt><expr><name>result</name> = <name>x</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> += <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>break_switch</name>;</goto>

              </case><case>case <expr><name>REOP_MINIMALSTAR</name></expr>:
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> = (<name>uintN</name>)-1</expr>;</expr_stmt>
                <goto>goto <name>minimalquantcommon</name>;</goto>
              </case><case>case <expr><name>REOP_MINIMALPLUS</name></expr>:
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> = (<name>uintN</name>)-1</expr>;</expr_stmt>
                <goto>goto <name>minimalquantcommon</name>;</goto>
              </case><case>case <expr><name>REOP_MINIMALOPT</name></expr>:
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> = 1</expr>;</expr_stmt>
                <goto>goto <name>minimalquantcommon</name>;</goto>
              </case><case>case <expr><name>REOP_MINIMALQUANT</name></expr>:
                <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> = <name>k</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> = <call><name>ReadCompactIndex</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* See REOP_QUANT comments about k - 1. */</comment>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> = <name>k</name> - 1</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name>
                          &lt;= <name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>minimalquantcommon</name>:</label>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>index</name></name> = <name><name>x</name>-&gt;<name>cp</name></name> - <name><name>gData</name>-&gt;<name>cpbegin</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>parenSoFar</name></name> = <name>parenSoFar</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PUSH_STATE_STACK</name><argument_list>(<argument><expr><name>gData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> != 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>curState</name>-&gt;<name>continue_op</name></name> = <name>REOP_MINIMALREPEAT</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>curState</name>-&gt;<name>continue_pc</name></name> = <name>pc</name></expr>;</expr_stmt>
                    <comment type="block">/* step over &lt;next&gt; */</comment>
                    <expr_stmt><expr><name>pc</name> += <name>OFFSET_LEN</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr>!<call><name>PushBackTrackState</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>REOP_MINIMALREPEAT</name></expr></argument>,
                                            <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>x</name>-&gt;<name>cp</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <goto>goto <name>bad</name>;</goto>
                    }</block></then></if>
                    <expr_stmt><expr>--<name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>pc</name> = <name>pc</name> + <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                }</block></else></if>
                <continue>continue;</continue>

              </case><case>case <expr><name>REOP_MINIMALREPEAT</name></expr>:
                <expr_stmt><expr>--<name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr>;</expr_stmt>
                <expr_stmt><expr>--<name>curState</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>"{%d,%d}"</expr></argument>, <argument><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name></expr></argument>,
                         <argument><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREPARE_REPEAT</name><parameter_list>()</parameter_list></cpp:macro>                                                      \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        curState-&gt;index = x-&gt;cp - gData-&gt;cpbegin;                             \
        curState-&gt;continue_op = REOP_MINIMALREPEAT;                           \
        curState-&gt;continue_pc = pc;                                           \
        pc += ARG_LEN;                                                        \
        for (k = curState-&gt;parenSoFar; k &lt; parenSoFar; k++)                   \
            x-&gt;parens[k].index = -1;                                          \
        PUSH_STATE_STACK(gData);                                              \
        op = (REOp) *pc++;                                                    \
        JS_ASSERT(op &lt; REOP_LIMIT);                                           \
    JS_END_MACRO</cpp:value></cpp:define>

                <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>" - "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/*
                     * Non-greedy failure - try to consume another child.
                     */</comment>
                    <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> == (<name>uintN</name>) -1 ||
                        <name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> &gt; 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>PREPARE_REPEAT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>
                    <comment type="block">/* Don't need to adjust pc since we're going to pop. */</comment>
                    <break>break;</break>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> == 0 &amp;&amp;
                    <name><name>x</name>-&gt;<name>cp</name></name> == <name><name>gData</name>-&gt;<name>cpbegin</name></name> + <name><name>curState</name>-&gt;<name>index</name></name></expr>)</condition><then> <block>{
                    <comment type="block">/* Matched an empty string, that'll get us nowhere. */</comment>
                    <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> != 0</expr>)</condition><then>
                    <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name>--</expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name> != (<name>uintN</name>) -1</expr>)</condition><then>
                    <expr_stmt><expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>max</name></name>--</expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr><name><name>curState</name>-&gt;<name>u</name>.<name>quantifier</name>.<name>min</name></name> != 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>PREPARE_REPEAT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>index</name></name> = <name><name>x</name>-&gt;<name>cp</name></name> - <name><name>gData</name>-&gt;<name>cpbegin</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curState</name>-&gt;<name>parenSoFar</name></name> = <name>parenSoFar</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PUSH_STATE_STACK</name><argument_list>(<argument><expr><name>gData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>PushBackTrackState</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>REOP_MINIMALREPEAT</name></expr></argument>,
                                        <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>x</name>-&gt;<name>cp</name></name></expr></argument>,
                                        <argument><expr><name><name>curState</name>-&gt;<name>parenSoFar</name></name></expr></argument>,
                                        <argument><expr><name>parenSoFar</name> - <name><name>curState</name>-&gt;<name>parenSoFar</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <goto>goto <name>bad</name>;</goto>
                }</block></then></if>
                <expr_stmt><expr>--<name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> = <name>pc</name> + <call><name>GET_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>REOp</name>) *<name>pc</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> &lt; <name>REOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
              </case><default>default:
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
            </default>}</block></switch>
          <label><name>break_switch</name>:</label><empty_stmt>;</empty_stmt>
        }</block></else></if>

        <comment type="block">/*
         *  If the match failed and there's a backtrack option, take it.
         *  Otherwise this is a complete and utter failure.
         */</comment>
        <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>gData</name>-&gt;<name>cursz</name></name> == 0</expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>JS_CHECK_OPERATION_LIMIT</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>cx</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>gData</name>-&gt;<name>ok</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Potentially detect explosive regex here. */</comment>
            <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackCount</name></name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>gData</name>-&gt;<name>backTrackLimit</name></name> &amp;&amp;
                <name><name>gData</name>-&gt;<name>backTrackCount</name></name> &gt;= <name><name>gData</name>-&gt;<name>backTrackLimit</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>cx</name></name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>JSMSG_REGEXP_TOO_COMPLEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gData</name>-&gt;<name>ok</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>backTrackData</name> = <name><name>gData</name>-&gt;<name>backTrackSP</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>gData</name>-&gt;<name>cursz</name></name> = <name><name>backTrackData</name>-&gt;<name>sz</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackSP</name></name> =
                (<name>REBackTrackData</name> *) ((<name>char</name> *)<name>backTrackData</name> - <name><name>backTrackData</name>-&gt;<name>sz</name></name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> = <name><name>backTrackData</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> = <name><name>backTrackData</name>-&gt;<name>backtrack_pc</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = (<name>REOp</name>) <name><name>backTrackData</name>-&gt;<name>backtrack_op</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> &lt; <name>REOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>gData</name>-&gt;<name>stateStackTop</name></name> = <name><name>backTrackData</name>-&gt;<name>saveStateStackTop</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>stateStackTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>stateStack</name></name></expr></argument>, <argument><expr><name>backTrackData</name> + 1</expr></argument>,
                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>REProgState</name></expr></argument>)</argument_list></sizeof> * <name><name>backTrackData</name>-&gt;<name>saveStateStackTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>curState</name> = &amp;<name><name>gData</name>-&gt;<name>stateStack</name><index>[<expr><name><name>gData</name>-&gt;<name>stateStackTop</name></name> - 1</expr>]</index></name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name><name>backTrackData</name>-&gt;<name>parenCount</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name>-&gt;<name>parens</name><index>[<expr><name><name>backTrackData</name>-&gt;<name>parenIndex</name></name></expr>]</index></name></expr></argument>,
                       <argument><expr>(<name>char</name> *)(<name>backTrackData</name> + 1) +
                       <sizeof>sizeof<argument_list>(<argument><expr><name>REProgState</name></expr></argument>)</argument_list></sizeof> * <name><name>backTrackData</name>-&gt;<name>saveStateStackTop</name></name></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RECapture</name></expr></argument>)</argument_list></sizeof> * <name><name>backTrackData</name>-&gt;<name>parenCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>parenSoFar</name> = <name><name>backTrackData</name>-&gt;<name>parenIndex</name></name> + <name><name>backTrackData</name>-&gt;<name>parenCount</name></name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <for>for (<init><expr><name>k</name> = <name><name>curState</name>-&gt;<name>parenSoFar</name></name></expr>;</init> <condition><expr><name>k</name> &lt; <name>parenSoFar</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>)
                    <expr_stmt><expr><name><name>x</name>-&gt;<name>parens</name><index>[<expr><name>k</name></expr>]</index></name>.<name>index</name> = -1</expr>;</expr_stmt></for>
                <expr_stmt><expr><name>parenSoFar</name> = <name><name>curState</name>-&gt;<name>parenSoFar</name></name></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>"\tBT_Pop: %ld,%ld"</expr></argument>,
                     <argument><expr>(<name>unsigned</name> <name>long</name>) <name><name>backTrackData</name>-&gt;<name>parenIndex</name></name></expr></argument>,
                     <argument><expr>(<name>unsigned</name> <name>long</name>) <name><name>backTrackData</name>-&gt;<name>parenCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>
        <expr_stmt><expr><name>x</name> = <name>result</name></expr>;</expr_stmt>

        <comment type="block">/*
         *  Continue with the expression.
         */</comment>
        <expr_stmt><expr><name>op</name> = (<name>REOp</name>)*<name>pc</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> &lt; <name>REOP_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

<label><name>bad</name>:</label>
    <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>

<label><name>good</name>:</label>
    <expr_stmt><expr><call><name>re_debug</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>x</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>REMatchState</name> *</type>
<name>MatchRegExp</name><parameter_list>(<param><decl><type><name>REGlobalData</name> *</type><name>gData</name></decl></param>, <param><decl><type><name>REMatchState</name> *</type><name>x</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>cpOrig</name> <init>= <expr><name><name>x</name>-&gt;<name>cp</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>NativeRegExp</name></type> <name>native</name></decl>;</decl_stmt>

    <comment type="block">/* Run with native regexp if possible. */</comment>
    <if>if <condition>(<expr><call><name>TRACING_ENABLED</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>cx</name></name></expr></argument>)</argument_list></call> &amp;&amp;
        !(<name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_NOCOMPILE</name>) &amp;&amp;
        (<name>native</name> = <call><name>GetNativeRegExp</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>cx</name></name></expr></argument>, <argument><expr><name><name>gData</name>-&gt;<name>regexp</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{

        <comment type="block">/*
         * For efficient native execution, store offset as a direct pointer into
         * the buffer and convert back after execution finishes.
         */</comment>
        <expr_stmt><expr><name><name>gData</name>-&gt;<name>skipped</name></name> = (<name>ptrdiff_t</name>)<name>cpOrig</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
        <macro><name>debug_only_stmt</name><argument_list>(<argument>{
            VOUCH_DOES_NOT_REQUIRE_STACK();
            JSStackFrame *caller = (JS_ON_TRACE(gData-&gt;cx))
                                   ? NULL
                                   : js_GetScriptedCaller(gData-&gt;cx, NULL);
            debug_only_printf(LC_TMRegexp,
                              "entering REGEXP trace at %s:%u@%u, code: %p\n",
                              caller ? caller-&gt;script-&gt;filename : "&lt;unknown&gt;",
                              caller ? js_FramePCToLineNumber(gData-&gt;cx, caller) : 0,
                              caller ? FramePCOffset(caller) : 0,
                              JS_FUNC_TO_DATA_PTR(void *, native));
        }</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <decl_stmt><decl><type><name>void</name> *</type><name>result</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JS_NO_FASTCALL</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>NANOJIT_IA32</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <comment type="block">/*
         * Although a NativeRegExp takes one argument and SIMULATE_FASTCALL is
         * passing two, the second goes into 'edx' and can safely be ignored.
         */</comment>
        <expr_stmt><expr><call><name>SIMULATE_FASTCALL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>gData</name></expr></argument>, <argument><expr><name><name>gData</name>-&gt;<name>cpend</name></name></expr></argument>, <argument><expr><name>native</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>result</name> = <call><name>native</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name><name>gData</name>-&gt;<name>cpend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMRegexp</name></expr></argument>, <argument><expr>"leaving REGEXP trace\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <comment type="block">/* Restore REGlobalData::skipped and fill REMatchState. */</comment>
        <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> = (const <name>jschar</name> *)<name><name>gData</name>-&gt;<name>stateStack</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gData</name>-&gt;<name>skipped</name></name> = (const <name>jschar</name> *)<name><name>gData</name>-&gt;<name>skipped</name></name> - <name>cpOrig</name></expr>;</expr_stmt>
        <return>return <expr><name>x</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Have to include the position beyond the last character
     * in order to detect end-of-input/line condition.
     */</comment>
    <for>for (<init><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>p</name> <init>= <expr><name>cpOrig</name></expr></init></decl>;</init> <condition><expr><name>p</name> &lt;= <name><name>gData</name>-&gt;<name>cpend</name></name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>gData</name>-&gt;<name>skipped</name></name> = <name>p</name> - <name>cpOrig</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> = <name>p</name></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>uintN</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>parenCount</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
            <expr_stmt><expr><name><name>x</name>-&gt;<name>parens</name><index>[<expr><name>j</name></expr>]</index></name>.<name>index</name> = -1</expr>;</expr_stmt></for>
        <decl_stmt><decl><type><name>REMatchState</name> *</type><name>result</name> <init>= <expr><call><name>ExecuteREBytecode</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name><name>gData</name>-&gt;<name>ok</name></name> || <name>result</name> || (<name><name>gData</name>-&gt;<name>regexp</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_STICKY</name>)</expr>)</condition><then>
            <return>return <expr><name>result</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackSP</name></name> = <name><name>gData</name>-&gt;<name>backTrackStack</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gData</name>-&gt;<name>cursz</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gData</name>-&gt;<name>stateStackTop</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> = <name>cpOrig</name> + <name><name>gData</name>-&gt;<name>skipped</name></name></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_BACKTRACK_LIMIT</name></cpp:macro> <cpp:value>400000</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>REMatchState</name> *</type>
<name>InitMatch</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>REGlobalData</name> *</type><name>gData</name></decl></param>, <param><decl><type><name>JSRegExp</name> *</type><name>re</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>REMatchState</name> *</type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackStackSize</name></name> = <name>INITIAL_BACKTRACK</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>backTrackStack</name></name></expr></argument>, <argument><expr><name>REBackTrackData</name> *</expr></argument>,
                           <argument><expr>&amp;<name><name>cx</name>-&gt;<name>regexpPool</name></name></expr></argument>,
                           <argument><expr><name>INITIAL_BACKTRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>gData</name>-&gt;<name>backTrackStack</name></name></expr>)</condition><then>
        <goto>goto <name>bad</name>;</goto></then></if>

    <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackSP</name></name> = <name><name>gData</name>-&gt;<name>backTrackStack</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>-&gt;<name>cursz</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackCount</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackLimit</name></name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>JS_GetOptions</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> &amp; <name>JSOPTION_RELIMIT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackLimit</name></name> = <name>length</name> * <name>length</name> * <name>length</name></expr>;</expr_stmt> <comment type="block">/* O(n^3) */</comment>
        <if>if <condition>(<expr><name><name>gData</name>-&gt;<name>backTrackLimit</name></name> &lt; <name>MIN_BACKTRACK_LIMIT</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>gData</name>-&gt;<name>backTrackLimit</name></name> = <name>MIN_BACKTRACK_LIMIT</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>gData</name>-&gt;<name>stateStackLimit</name></name> = <name>INITIAL_STATESTACK</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><name><name>gData</name>-&gt;<name>stateStack</name></name></expr></argument>, <argument><expr><name>REProgState</name> *</expr></argument>,
                           <argument><expr>&amp;<name><name>cx</name>-&gt;<name>regexpPool</name></name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>REProgState</name></expr></argument>)</argument_list></sizeof> * <name>INITIAL_STATESTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>gData</name>-&gt;<name>stateStack</name></name></expr>)</condition><then>
        <goto>goto <name>bad</name>;</goto></then></if>

    <expr_stmt><expr><name><name>gData</name>-&gt;<name>stateStackTop</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>-&gt;<name>cx</name></name> = <name>cx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>-&gt;<name>regexp</name></name> = <name>re</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>-&gt;<name>ok</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>REMatchState</name> *</expr></argument>,
                           <argument><expr>&amp;<name><name>cx</name>-&gt;<name>regexpPool</name></name></expr></argument>,
                           <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>REMatchState</name></expr></argument>, <argument><expr><name>parens</name></expr></argument>)</argument_list></call>
                           + <name><name>re</name>-&gt;<name>parenCount</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>RECapture</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
        <goto>goto <name>bad</name>;</goto></then></if>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>re</name>-&gt;<name>classCount</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr>!<name><name>re</name>-&gt;<name>classList</name><index>[<expr><name>i</name></expr>]</index></name>.<name>converted</name> &amp;&amp;
            !<call><name>MatcherProcessCharSet</name><argument_list>(<argument><expr><name>gData</name></expr></argument>, <argument><expr>&amp;<name><name>re</name>-&gt;<name>classList</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
    }</block></for>

    <return>return <expr><name>result</name></expr>;</return>

<label><name>bad</name>:</label>
    <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>-&gt;<name>ok</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_ExecuteRegExp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSRegExp</name> *</type><name>re</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><name>size_t</name> *</type><name>indexp</name></decl></param>,
                 <param><decl><type><name>JSBool</name></type> <name>test</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>REGlobalData</name></type> <name>gData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>REMatchState</name> *</type><name>x</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>cp</name></decl>, *<decl><type ref="prev"/><name>ep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>length</name></decl>, <decl><type ref="prev"/><name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSubString</name> *</type><name>morepar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRegExpStatics</name> *</type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>matchlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>morenum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>parstr</name></decl>, *<decl><type ref="prev"/><name>matchstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>RECapture</name> *</type><name>parsub</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>mark</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name> *</type><name>timestamp</name></decl>;</decl_stmt>

    <comment type="block">/*
     * It's safe to load from cp because JSStrings have a zero at the end,
     * and we never let cp get beyond cpend.
     */</comment>
    <expr_stmt><expr><name>start</name> = *<name>indexp</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>str</name>-&gt;<name>getCharsAndLength</name></name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>start</name> &gt; <name>length</name></expr>)</condition><then>
        <expr_stmt><expr><name>start</name> = <name>length</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>gData</name>.<name>cpbegin</name></name> = <name>cp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>.<name>cpend</name></name> = <name>cp</name> + <name>length</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cp</name> += <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>.<name>start</name></name> = <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gData</name>.<name>skipped</name></name> = 0</expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>cx</name>-&gt;<name>regexpPool</name>.<name>first</name>.<name>next</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * The first arena in the regexpPool must have a timestamp at its base.
         */</comment>
        <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>int64</name> *</expr></argument>,
                               <argument><expr>&amp;<name><name>cx</name>-&gt;<name>regexpPool</name></name></expr></argument>, <argument><expr>sizeof *<name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>timestamp</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr>*<name>timestamp</name> = <call><name>JS_Now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>regexpPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>x</name> = <call><name>InitMatch</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>gData</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>x</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name><name>x</name>-&gt;<name>cp</name></name> = <name>cp</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Call the recursive matcher to do the real work.  Return null on mismatch
     * whether testing or not.  On match, return an extended Array object.
     */</comment>
    <expr_stmt><expr><name>result</name> = <call><name>MatchRegExp</name><argument_list>(<argument><expr>&amp;<name>gData</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <name><name>gData</name>.<name>ok</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>
    <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>rval</name> = <name>JSVAL_NULL</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>cp</name> = <name><name>result</name>-&gt;<name>cp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> = <name>cp</name> - <name><name>gData</name>.<name>cpbegin</name></name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>indexp</name> = <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>matchlen</name> = <name>i</name> - (<name>start</name> + <name><name>gData</name>.<name>skipped</name></name>)</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>matchlen</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ep</name> = <name>cp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cp</name> -= <name>matchlen</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>test</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Testing for a match and updating cx-&gt;regExpStatics: don't allocate
         * an array object, do return true.
         */</comment>
        <expr_stmt><expr>*<name>rval</name> = <name>JSVAL_TRUE</name></expr>;</expr_stmt>

        <comment type="block">/* Avoid warning.  (gcc doesn't detect that obj is needed iff !test); */</comment>
        <expr_stmt><expr><name>obj</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * The array returned on match has element 0 bound to the matched
         * string, elements 1 through state.parenCount bound to the paren
         * matches, an index property telling the length of the left context,
         * and an input property referring to the input string.
         */</comment>
        <expr_stmt><expr><name>obj</name> = <call><name>js_NewSlowArrayObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr>*<name>rval</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFVAL</name><parameter_list>(<param><type><name>val</name></type></param>, <param><type><name>id</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{                                                     \
    ok = js_DefineProperty(cx, obj, id, val,                                  \
                           JS_PropertyStub, JS_PropertyStub,                  \
                           JSPROP_ENUMERATE);                                 \
    if (!ok)                                                                  \
        goto out;                                                             \
}</cpp:value></cpp:define>

        <expr_stmt><expr><name>matchstr</name> = <call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>cp</name> - <call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>,
                                         <argument><expr><name>matchlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>matchstr</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><call><name>DEFVAL</name><argument_list>(<argument><expr><call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>matchstr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT_TO_JSID</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name>res</name> = &amp;<name><name>cx</name>-&gt;<name>regExpStatics</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res</name>-&gt;<name>input</name></name> = <name>str</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res</name>-&gt;<name>parenCount</name></name> = <name><name>re</name>-&gt;<name>parenCount</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>re</name>-&gt;<name>parenCount</name></name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>res</name>-&gt;<name>lastParen</name></name> = <name>js_EmptySubString</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <for>for (<init><expr><name>num</name> = 0</expr>;</init> <condition><expr><name>num</name> &lt; <name><name>re</name>-&gt;<name>parenCount</name></name></expr>;</condition> <incr><expr><name>num</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>parsub</name> = &amp;<name><name>result</name>-&gt;<name>parens</name><index>[<expr><name>num</name></expr>]</index></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>num</name> &lt; 9</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>parsub</name>-&gt;<name>index</name></name> == -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>res</name>-&gt;<name>parens</name><index>[<expr><name>num</name></expr>]</index></name>.<name>chars</name> = <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>res</name>-&gt;<name>parens</name><index>[<expr><name>num</name></expr>]</index></name>.<name>length</name> = 0</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name><name>res</name>-&gt;<name>parens</name><index>[<expr><name>num</name></expr>]</index></name>.<name>chars</name> = <name><name>gData</name>.<name>cpbegin</name></name> + <name><name>parsub</name>-&gt;<name>index</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>res</name>-&gt;<name>parens</name><index>[<expr><name>num</name></expr>]</index></name>.<name>length</name> = <name><name>parsub</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>morenum</name> = <name>num</name> - 9</expr>;</expr_stmt>
                <expr_stmt><expr><name>morepar</name> = <name><name>res</name>-&gt;<name>moreParens</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>morepar</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>res</name>-&gt;<name>moreLength</name></name> = 10</expr>;</expr_stmt>
                    <expr_stmt><expr><name>morepar</name> = (<name>JSSubString</name>*)
                        <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>10 * <sizeof>sizeof<argument_list>(<argument><expr><name>JSSubString</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>morenum</name> &gt;= <name><name>res</name>-&gt;<name>moreLength</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>res</name>-&gt;<name>moreLength</name></name> += 10</expr>;</expr_stmt>
                    <expr_stmt><expr><name>morepar</name> = (<name>JSSubString</name>*)
                        <call><name><name>cx</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>morepar</name></expr></argument>,
                                    <argument><expr><name><name>res</name>-&gt;<name>moreLength</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>JSSubString</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></else></if>
                <if>if <condition>(<expr>!<name>morepar</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                    <goto>goto <name>out</name>;</goto>
                }</block></then></if>
                <expr_stmt><expr><name><name>res</name>-&gt;<name>moreParens</name></name> = <name>morepar</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>parsub</name>-&gt;<name>index</name></name> == -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>morepar</name><index>[<expr><name>morenum</name></expr>]</index></name>.<name>chars</name> = <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>morepar</name><index>[<expr><name>morenum</name></expr>]</index></name>.<name>length</name> = 0</expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name><name>morepar</name><index>[<expr><name>morenum</name></expr>]</index></name>.<name>chars</name> = <name><name>gData</name>.<name>cpbegin</name></name> + <name><name>parsub</name>-&gt;<name>index</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>morepar</name><index>[<expr><name>morenum</name></expr>]</index></name>.<name>length</name> = <name><name>parsub</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if>
            <if>if <condition>(<expr><name>test</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <if>if <condition>(<expr><name><name>parsub</name>-&gt;<name>index</name></name> == -1</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>ok</name> = <call><name>js_DefineProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>INT_TO_JSID</name><argument_list>(<argument><expr><name>num</name> + 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>JSVAL_VOID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name>JSPROP_ENUMERATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>parstr</name> = <call><name>js_NewDependentString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,
                                               <argument><expr><name><name>gData</name>.<name>cpbegin</name></name> + <name><name>parsub</name>-&gt;<name>index</name></name> -
                                               <call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>,
                                               <argument><expr><name><name>parsub</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>parstr</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                    <goto>goto <name>out</name>;</goto>
                }</block></then></if>
                <expr_stmt><expr><name>ok</name> = <call><name>js_DefineProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>INT_TO_JSID</name><argument_list>(<argument><expr><name>num</name> + 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>parstr</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSPROP_ENUMERATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                <goto>goto <name>out</name>;</goto></then></if>
        }</block></for>
        <if>if <condition>(<expr><name><name>parsub</name>-&gt;<name>index</name></name> == -1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>res</name>-&gt;<name>lastParen</name></name> = <name>js_EmptySubString</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>res</name>-&gt;<name>lastParen</name>.<name>chars</name></name> = <name><name>gData</name>.<name>cpbegin</name></name> + <name><name>parsub</name>-&gt;<name>index</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>res</name>-&gt;<name>lastParen</name>.<name>length</name></name> = <name><name>parsub</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>

    <if>if <condition>(<expr>!<name>test</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Define the index and input properties last for better for/in loop
         * order (so they come after the elements).
         */</comment>
        <expr_stmt><expr><call><name>DEFVAL</name><argument_list>(<argument><expr><call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><name>start</name> + <name><name>gData</name>.<name>skipped</name></name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>indexAtom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DEFVAL</name><argument_list>(<argument><expr><call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>inputAtom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEFVAL</name></cpp:undef>

    <expr_stmt><expr><name><name>res</name>-&gt;<name>lastMatch</name>.<name>chars</name></name> = <name>cp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res</name>-&gt;<name>lastMatch</name>.<name>length</name></name> = <name>matchlen</name></expr>;</expr_stmt>

    <comment type="block">/*
     * For JS1.3 and ECMAv2, emulate Perl5 exactly:
     *
     * js1.3        "hi", "hi there"            "hihitherehi therebye"
     */</comment>
    <expr_stmt><expr><name><name>res</name>-&gt;<name>leftContext</name>.<name>chars</name></name> = <call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res</name>-&gt;<name>leftContext</name>.<name>length</name></name> = <name>start</name> + <name><name>gData</name>.<name>skipped</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res</name>-&gt;<name>rightContext</name>.<name>chars</name></name> = <name>ep</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res</name>-&gt;<name>rightContext</name>.<name>length</name></name> = <name><name>gData</name>.<name>cpend</name></name> - <name>ep</name></expr>;</expr_stmt>

<label><name>out</name>:</label>
    <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>regexpPool</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>jsdouble</name></type>
<name>GetRegExpLastIndex</name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> == &amp;<name>js_RegExpClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name> <init>= <expr><name><name>obj</name>-&gt;<name>fslots</name><index>[<expr><name>JSSLOT_REGEXP_LAST_INDEX</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>*<call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>jsval</name></type>
<name>GetRegExpLastIndexValue</name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> == &amp;<name>js_RegExpClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>obj</name>-&gt;<name>fslots</name><index>[<expr><name>JSSLOT_REGEXP_LAST_INDEX</name></expr>]</index></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>SetRegExpLastIndex</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>jsdouble</name></type> <name>lastIndex</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> == &amp;<name>js_RegExpClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>JS_NewNumberValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>lastIndex</name></expr></argument>,
                             <argument><expr>&amp;<name><name>obj</name>-&gt;<name>fslots</name><index>[<expr><name>JSSLOT_REGEXP_LAST_INDEX</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_getProperty</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>id</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsint</name></type> <name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>re</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    <while>while <condition>(<expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> != &amp;<name>js_RegExpClass</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>obj</name> = <call><name>OBJ_GET_PROTO</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    }</block></while>
    <expr_stmt><expr><name>slot</name> = <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>slot</name> == <name>REGEXP_LAST_INDEX</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>vp</name> = <call><name>GetRegExpLastIndexValue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_LOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>re</name> = (<name>JSRegExp</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>re</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name>slot</name></expr>)</condition> <block>{
          <case>case <expr><name>REGEXP_SOURCE</name></expr>:
            <expr_stmt><expr>*<name>vp</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name><name>re</name>-&gt;<name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>REGEXP_GLOBAL</name></expr>:
            <expr_stmt><expr>*<name>vp</name> = <call><name>BOOLEAN_TO_JSVAL</name><argument_list>(<argument><expr>(<name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_GLOB</name>) != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>REGEXP_IGNORE_CASE</name></expr>:
            <expr_stmt><expr>*<name>vp</name> = <call><name>BOOLEAN_TO_JSVAL</name><argument_list>(<argument><expr>(<name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name>) != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>REGEXP_MULTILINE</name></expr>:
            <expr_stmt><expr>*<name>vp</name> = <call><name>BOOLEAN_TO_JSVAL</name><argument_list>(<argument><expr>(<name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_MULTILINE</name>) != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>REGEXP_STICKY</name></expr>:
            <expr_stmt><expr>*<name>vp</name> = <call><name>BOOLEAN_TO_JSVAL</name><argument_list>(<argument><expr>(<name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_STICKY</name>) != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case>}</block></switch>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_setProperty</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>id</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>lastIndex</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>ok</name></expr>;</return></then></if>
    <while>while <condition>(<expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> != &amp;<name>js_RegExpClass</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>obj</name> = <call><name>OBJ_GET_PROTO</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    }</block></while>
    <expr_stmt><expr><name>slot</name> = <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>slot</name> == <name>REGEXP_LAST_INDEX</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>JS_ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>*<name>vp</name></expr></argument>, <argument><expr>&amp;<name>lastIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>lastIndex</name> = <call><name>js_DoubleToInteger</name><argument_list>(<argument><expr><name>lastIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <call><name>SetRegExpLastIndex</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>lastIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGEXP_PROP_ATTRS</name></cpp:macro>     <cpp:value>(JSPROP_PERMANENT | JSPROP_SHARED)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RO_REGEXP_PROP_ATTRS</name></cpp:macro>  <cpp:value>(REGEXP_PROP_ATTRS | JSPROP_READONLY)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>G</name></cpp:macro> <cpp:value>regexp_getProperty</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S</name></cpp:macro> <cpp:value>regexp_setProperty</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSPropertySpec</name></type> <name><name>regexp_props</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"source"</expr>,     <expr><name>REGEXP_SOURCE</name></expr>,      <expr><name>RO_REGEXP_PROP_ATTRS</name></expr>,<expr><name>G</name></expr>,<expr><name>S</name></expr>}</block></expr>,
    <expr><block>{<expr>"global"</expr>,     <expr><name>REGEXP_GLOBAL</name></expr>,      <expr><name>RO_REGEXP_PROP_ATTRS</name></expr>,<expr><name>G</name></expr>,<expr><name>S</name></expr>}</block></expr>,
    <expr><block>{<expr>"ignoreCase"</expr>, <expr><name>REGEXP_IGNORE_CASE</name></expr>, <expr><name>RO_REGEXP_PROP_ATTRS</name></expr>,<expr><name>G</name></expr>,<expr><name>S</name></expr>}</block></expr>,
    <expr><block>{<expr>"lastIndex"</expr>,  <expr><name>REGEXP_LAST_INDEX</name></expr>,  <expr><name>REGEXP_PROP_ATTRS</name></expr>,<expr><name>G</name></expr>,<expr><name>S</name></expr>}</block></expr>,
    <expr><block>{<expr>"multiline"</expr>,  <expr><name>REGEXP_MULTILINE</name></expr>,   <expr><name>RO_REGEXP_PROP_ATTRS</name></expr>,<expr><name>G</name></expr>,<expr><name>S</name></expr>}</block></expr>,
    <expr><block>{<expr>"sticky"</expr>,     <expr><name>REGEXP_STICKY</name></expr>,      <expr><name>RO_REGEXP_PROP_ATTRS</name></expr>,<expr><name>G</name></expr>,<expr><name>S</name></expr>}</block></expr>,
    <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>G</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S</name></cpp:undef>

<comment type="block">/*
 * RegExp class static properties and their Perl counterparts:
 *
 *  RegExp.input                $_
 *  RegExp.multiline            $*
 *  RegExp.lastMatch            $&amp;
 *  RegExp.lastParen            $+
 *  RegExp.leftContext          $`
 *  RegExp.rightContext         $'
 */</comment>
<enum>enum <name>regexp_static_tinyid</name> <block>{
    <decl><name>REGEXP_STATIC_INPUT</name>         <init>= <expr>-1</expr></init></decl>,
    <decl><name>REGEXP_STATIC_MULTILINE</name>     <init>= <expr>-2</expr></init></decl>,
    <decl><name>REGEXP_STATIC_LAST_MATCH</name>    <init>= <expr>-3</expr></init></decl>,
    <decl><name>REGEXP_STATIC_LAST_PAREN</name>    <init>= <expr>-4</expr></init></decl>,
    <decl><name>REGEXP_STATIC_LEFT_CONTEXT</name>  <init>= <expr>-5</expr></init></decl>,
    <decl><name>REGEXP_STATIC_RIGHT_CONTEXT</name> <init>= <expr>-6</expr></init></decl>
}</block>;</enum>

<function><type><name>void</name></type>
<name>js_InitRegExpStatics</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * To avoid multiple allocations in InitMatch(), the arena size parameter
     * should be at least as big as:
     *   INITIAL_BACKTRACK
     *   + (sizeof(REProgState) * INITIAL_STATESTACK)
     *   + (offsetof(REMatchState, parens) + avgParanSize * sizeof(RECapture))
     */</comment>
    <expr_stmt><expr><call><name>JS_InitArenaPool</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>regexpPool</name></name></expr></argument>, <argument><expr>"regexp"</expr></argument>,
                     <argument><expr>12 * 1024 - 40</expr></argument>,  <comment type="block">/* FIXME: bug 421435 */</comment>
                     <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>scriptStackQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ClearRegExpStatics</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>js_SaveAndClearRegExpStatics</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSRegExpStatics *statics</argument>,
                             <argument>JSTempValueRooter *tvr</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr>*<name>statics</name> = <name><name>cx</name>-&gt;<name>regExpStatics</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_PUSH_TEMP_ROOT_STRING</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>statics</name>-&gt;<name>input</name></name></expr></argument>, <argument><expr><name>tvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Prevent JS_ClearRegExpStatics from freeing moreParens, since we've only
     * moved it elsewhere (into statics-&gt;moreParens).
     */</comment>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>regExpStatics</name>.<name>moreParens</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ClearRegExpStatics</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>js_RestoreRegExpStatics</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSRegExpStatics *statics</argument>,
                        <argument>JSTempValueRooter *tvr</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* Clear/free any new JSRegExpStatics data before clobbering. */</comment>
    <expr_stmt><expr><call><name>JS_ClearRegExpStatics</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>regExpStatics</name></name> = *<name>statics</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_POP_TEMP_ROOT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<function><type><name>void</name></type>
<name>js_TraceRegExpStatics</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>acx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRegExpStatics</name> *</type><name>res</name> <init>= <expr>&amp;<name><name>acx</name>-&gt;<name>regExpStatics</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>res</name>-&gt;<name>input</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_CALL_STRING_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>input</name></name></expr></argument>, <argument><expr>"res-&gt;input"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>js_FreeRegExpStatics</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ClearRegExpStatics</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_FinishArenaPool</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>regexpPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_static_getProperty</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>id</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsint</name></type> <name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRegExpStatics</name> *</type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSubString</name> *</type><name>sub</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> = &amp;<name><name>cx</name>-&gt;<name>regExpStatics</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>slot</name> = <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>slot</name></expr>)</condition> <block>{
      <case>case <expr><name>REGEXP_STATIC_INPUT</name></expr>:
        <expr_stmt><expr>*<name>vp</name> = <name><name>res</name>-&gt;<name>input</name></name> ? <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name><name>res</name>-&gt;<name>input</name></name></expr></argument>)</argument_list></call>
                         : <call><name>JS_GetEmptyStringValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
      </case><case>case <expr><name>REGEXP_STATIC_MULTILINE</name></expr>:
        <expr_stmt><expr>*<name>vp</name> = <call><name>BOOLEAN_TO_JSVAL</name><argument_list>(<argument><expr><name><name>res</name>-&gt;<name>multiline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
      </case><case>case <expr><name>REGEXP_STATIC_LAST_MATCH</name></expr>:
        <expr_stmt><expr><name>sub</name> = &amp;<name><name>res</name>-&gt;<name>lastMatch</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>REGEXP_STATIC_LAST_PAREN</name></expr>:
        <expr_stmt><expr><name>sub</name> = &amp;<name><name>res</name>-&gt;<name>lastParen</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>REGEXP_STATIC_LEFT_CONTEXT</name></expr>:
        <expr_stmt><expr><name>sub</name> = &amp;<name><name>res</name>-&gt;<name>leftContext</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>REGEXP_STATIC_RIGHT_CONTEXT</name></expr>:
        <expr_stmt><expr><name>sub</name> = &amp;<name><name>res</name>-&gt;<name>rightContext</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <expr_stmt><expr><name>sub</name> = <call><name>REGEXP_PAREN_SUBSTRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>
    <expr_stmt><expr><name>str</name> = <call><name>js_NewStringCopyN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>sub</name>-&gt;<name>chars</name></name></expr></argument>, <argument><expr><name><name>sub</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr>*<name>vp</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_static_setProperty</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>id</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRegExpStatics</name> *</type><name>res</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>res</name> = &amp;<name><name>cx</name>-&gt;<name>regExpStatics</name></name></expr>;</expr_stmt>
    <comment type="block">/* XXX use if-else rather than switch to keep MSVC1.52 from crashing */</comment>
    <if>if <condition>(<expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call> == <name>REGEXP_STATIC_INPUT</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> &amp;&amp;
            !<call><name>JS_ConvertValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>*<name>vp</name></expr></argument>, <argument><expr><name>JSTYPE_STRING</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>res</name>-&gt;<name>input</name></name> = <call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call> == <name>REGEXP_STATIC_MULTILINE</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_BOOLEAN</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> &amp;&amp;
            !<call><name>JS_ConvertValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>*<name>vp</name></expr></argument>, <argument><expr><name>JSTYPE_BOOLEAN</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>res</name>-&gt;<name>multiline</name></name> = <call><name>JSVAL_TO_BOOLEAN</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGEXP_STATIC_PROP_ATTRS</name></cpp:macro>    <cpp:value>(REGEXP_PROP_ATTRS | JSPROP_ENUMERATE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RO_REGEXP_STATIC_PROP_ATTRS</name></cpp:macro> <cpp:value>(REGEXP_STATIC_PROP_ATTRS | JSPROP_READONLY)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSPropertySpec</name></type> <name><name>regexp_static_props</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>"input"</expr>,
     <expr><name>REGEXP_STATIC_INPUT</name></expr>,
     <expr><name>REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_setProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"multiline"</expr>,
     <expr><name>REGEXP_STATIC_MULTILINE</name></expr>,
     <expr><name>REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_setProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"lastMatch"</expr>,
     <expr><name>REGEXP_STATIC_LAST_MATCH</name></expr>,
     <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"lastParen"</expr>,
     <expr><name>REGEXP_STATIC_LAST_PAREN</name></expr>,
     <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"leftContext"</expr>,
     <expr><name>REGEXP_STATIC_LEFT_CONTEXT</name></expr>,
     <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"rightContext"</expr>,
     <expr><name>REGEXP_STATIC_RIGHT_CONTEXT</name></expr>,
     <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,

    <comment type="block">/* XXX should have block scope and local $1, etc. */</comment>
    <expr><block>{<expr>"$1"</expr>, <expr>0</expr>, <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"$2"</expr>, <expr>1</expr>, <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"$3"</expr>, <expr>2</expr>, <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"$4"</expr>, <expr>3</expr>, <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"$5"</expr>, <expr>4</expr>, <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"$6"</expr>, <expr>5</expr>, <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"$7"</expr>, <expr>6</expr>, <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"$8"</expr>, <expr>7</expr>, <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,
    <expr><block>{<expr>"$9"</expr>, <expr>8</expr>, <expr><name>RO_REGEXP_STATIC_PROP_ATTRS</name></expr>,
     <expr><name>regexp_static_getProperty</name></expr>,    <expr><name>regexp_static_getProperty</name></expr>}</block></expr>,

    <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>regexp_finalize</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>re</name> <init>= <expr>(<name>JSRegExp</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>re</name></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><call><name>js_DestroyRegExp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Forward static prototype. */</comment>
<function_decl><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_exec_sub</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>,
                <param><decl><type><name>JSBool</name></type> <name>test</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_call</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>regexp_exec_sub</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>,
                           <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XDR</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsxdrapi.h"</cpp:file></cpp:include>

<function><type><name>JSBool</name></type>
<name>js_XDRRegExpObject</name><parameter_list>(<param><decl><type><name>JSXDRState</name> *</type><name>xdr</name></decl></param>, <param><decl><type><name>JSObject</name> **</type><name>objp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>re</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>source</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>flagsword</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_ENCODE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>re</name> = (<name>JSRegExp</name> *) <call><name>(*<name>objp</name>)-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>re</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>source</name> = <name><name>re</name>-&gt;<name>source</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>flagsword</name> = (<name>uint32</name>)<name><name>re</name>-&gt;<name>flags</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>JS_XDRString</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>source</name></expr></argument>)</argument_list></call> ||
        !<call><name>JS_XDRUint32</name><argument_list>(<argument><expr><name>xdr</name></expr></argument>, <argument><expr>&amp;<name>flagsword</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>xdr</name>-&gt;<name>mode</name></name> == <name>JSXDR_DECODE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>obj</name> = <call><name>js_NewObject</name><argument_list>(<argument><expr><name><name>xdr</name>-&gt;<name>cx</name></name></expr></argument>, <argument><expr>&amp;<name>js_RegExpClass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>STOBJ_CLEAR_PARENT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>STOBJ_CLEAR_PROTO</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>re</name> = <call><name>js_NewRegExp</name><argument_list>(<argument><expr><name><name>xdr</name>-&gt;<name>cx</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr>(<name>uint8</name>)<name>flagsword</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>re</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>obj</name>-&gt;<name>setPrivate</name></name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_ClearRegExpLastIndex</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>objp</name> = <name>obj</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* !JS_HAS_XDR */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_XDRRegExpObject</name></cpp:macro> <cpp:value>NULL</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !JS_HAS_XDR */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>regexp_trace</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>re</name> <init>= <expr>(<name>JSRegExp</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>re</name> &amp;&amp; <name><name>re</name>-&gt;<name>source</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_CALL_STRING_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>re</name>-&gt;<name>source</name></name></expr></argument>, <argument><expr>"source"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<decl_stmt><decl><type><name>JSClass</name></type> <name>js_RegExpClass</name> <init>= <expr><block>{
    <expr><name>js_RegExp_str</name></expr>,
    <expr><name>JSCLASS_HAS_PRIVATE</name> |
    <call><name>JSCLASS_HAS_RESERVED_SLOTS</name><argument_list>(<argument><expr><name>REGEXP_CLASS_FIXED_RESERVED_SLOTS</name></expr></argument>)</argument_list></call> |
    <name>JSCLASS_MARK_IS_TRACE</name> | <call><name>JSCLASS_HAS_CACHED_PROTO</name><argument_list>(<argument><expr><name>JSProto_RegExp</name></expr></argument>)</argument_list></call></expr>,
    <expr><name>JS_PropertyStub</name></expr>,    <expr><name>JS_PropertyStub</name></expr>,
    <expr><name>JS_PropertyStub</name></expr>,    <expr><name>JS_PropertyStub</name></expr>,
    <expr><name>JS_EnumerateStub</name></expr>,   <expr><name>JS_ResolveStub</name></expr>,
    <expr><name>JS_ConvertStub</name></expr>,     <expr><name>regexp_finalize</name></expr>,
    <expr><name>NULL</name></expr>,               <expr><name>NULL</name></expr>,
    <expr><name>regexp_call</name></expr>,        <expr><name>NULL</name></expr>,
    <expr><name>js_XDRRegExpObject</name></expr>, <expr><name>NULL</name></expr>,
    <expr><call><name>JS_CLASS_TRACE</name><argument_list>(<argument><expr><name>regexp_trace</name></expr></argument>)</argument_list></call></expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>jschar</name></type> <name><name>empty_regexp_ucstr</name><index>[]</index></name> <init>= <expr><block>{<expr>'('</expr>, <expr>'?'</expr>, <expr>':'</expr>, <expr>')'</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><name>JSBool</name></type>
<name>js_regexp_toString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>re</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>source</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>chars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>nflags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>JS_InstanceOf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>js_RegExpClass</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_LOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>re</name> = (<name>JSRegExp</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>re</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>vp</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>re</name>-&gt;<name>source</name>-&gt;<name>getCharsAndLength</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>length</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>source</name> = <name>empty_regexp_ucstr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> = <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>empty_regexp_ucstr</name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>length</name> += 2</expr>;</expr_stmt>
    <expr_stmt><expr><name>nflags</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>flags</name> = <name><name>re</name>-&gt;<name>flags</name></name></expr>;</init> <condition><expr><name>flags</name> != 0</expr>;</condition> <incr><expr><name>flags</name> &amp;= <name>flags</name> - 1</expr></incr>)
        <expr_stmt><expr><name>nflags</name>++</expr>;</expr_stmt></for>
    <expr_stmt><expr><name>chars</name> = (<name>jschar</name>*) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr>(<name>length</name> + <name>nflags</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>chars</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>chars</name><index>[<expr>0</expr>]</index></name> = '/'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr>&amp;<name><name>chars</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>length</name> - 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>chars</name><index>[<expr><name>length</name>-1</expr>]</index></name> = '/'</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>nflags</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_GLOB</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>chars</name><index>[<expr><name>length</name>++</expr>]</index></name> = 'g'</expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>chars</name><index>[<expr><name>length</name>++</expr>]</index></name> = 'i'</expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_MULTILINE</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>chars</name><index>[<expr><name>length</name>++</expr>]</index></name> = 'm'</expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_STICKY</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>chars</name><index>[<expr><name>length</name>++</expr>]</index></name> = 'y'</expr>;</expr_stmt></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>chars</name><index>[<expr><name>length</name></expr>]</index></name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name>str</name> = <call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>vp</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_toString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>obj</name> = <call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>obj</name> &amp;&amp; <call><name>js_regexp_toString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_compile_sub</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>,
                   <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>opt</name></decl>, *<decl><type ref="prev"/><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>oldre</name></decl>, *<decl><type ref="prev"/><name>re</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>cp</name></decl>, *<decl><type ref="prev"/><name>start</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jschar</name> *</type><name>nstart</name></decl>, *<decl><type ref="prev"/><name>ncp</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>JS_InstanceOf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>js_RegExpClass</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>opt</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>emptyString</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If we get passed in a RegExp object we construct a new
             * RegExp that is a duplicate of it by re-compiling the
             * original source code. ECMA requires that it be an error
             * here if the flags are specified. (We must use the flags
             * from the original RegExp also).
             */</comment>
            <expr_stmt><expr><name>obj2</name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>obj2</name> &amp;&amp; <call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>)</argument_list></call> == &amp;<name>js_RegExpClass</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>argc</name> &gt;= 2 &amp;&amp; !<call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="block">/* 'flags' passed */</comment>
                    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>JSMSG_NEWREGEXP_FLAGGED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><call><name>JS_LOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>re</name> = (<name>JSRegExp</name> *) <call><name><name>obj2</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>re</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>re</name> = <call><name>js_NewRegExp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>re</name>-&gt;<name>source</name></name></expr></argument>, <argument><expr><name><name>re</name>-&gt;<name>flags</name></name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>created</name>;</goto>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>str</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>argc</name> &gt; 1</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>opt</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>opt</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>opt</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>

        <comment type="block">/* Escape any naked slashes in the regexp source. */</comment>
        <expr_stmt><expr><call><name><name>str</name>-&gt;<name>getCharsAndLength</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>end</name> = <name>start</name> + <name>length</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nstart</name> = <name>ncp</name> = <name>NULL</name></expr>;</expr_stmt>
        <for>for (<init><expr><name>cp</name> = <name>start</name></expr>;</init> <condition><expr><name>cp</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>cp</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>*<name>cp</name> == '/' &amp;&amp; (<name>cp</name> == <name>start</name> || <name><name>cp</name><index>[<expr>-1</expr>]</index></name> != '\\')</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>nbytes</name> = (++<name>length</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jschar</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>nstart</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>nstart</name> = (<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>malloc</name></name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>nstart</name></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>ncp</name> = <name>nstart</name> + (<name>cp</name> - <name>start</name>)</expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>js_strncpy</name><argument_list>(<argument><expr><name>nstart</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>cp</name> - <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>tmp</name> = (<name>jschar</name> *) <call><name><name>cx</name>-&gt;<name>realloc</name></name><argument_list>(<argument><expr><name>nstart</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>tmp</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>nstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return>
                    }</block></then></if>
                    <expr_stmt><expr><name>ncp</name> = <name>tmp</name> + (<name>ncp</name> - <name>nstart</name>)</expr>;</expr_stmt>
                    <expr_stmt><expr><name>nstart</name> = <name>tmp</name></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr>*<name>ncp</name>++ = '\\'</expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>nstart</name></expr>)</condition><then>
                <expr_stmt><expr>*<name>ncp</name>++ = *<name>cp</name></expr>;</expr_stmt></then></if>
        }</block></for>

        <if>if <condition>(<expr><name>nstart</name></expr>)</condition><then> <block>{
            <comment type="block">/* Don't forget to store the backstop after the new string. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call>(<name>size_t</name>)<argument_list>(<argument><expr><name>ncp</name> - <name>nstart</name></expr></argument>)</argument_list></call> == <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>ncp</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>str</name> = <call><name>js_NewString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>nstart</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>nstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

    <expr_stmt><expr><name>re</name> = <call><name>js_NewRegExpOpt</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>created</name>:</label>
    <if>if <condition>(<expr>!<name>re</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_LOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldre</name> = (<name>JSRegExp</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>obj</name>-&gt;<name>setPrivate</name></name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_ClearRegExpLastIndex</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>oldre</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_DestroyRegExp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>oldre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr>*<name>rval</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_compile</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>obj</name> = <call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>obj</name> &amp;&amp; <call><name>regexp_compile_sub</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_exec_sub</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>,
                <param><decl><type><name>JSBool</name></type> <name>test</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>, <decl><type ref="prev"/><name>sticky</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>re</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>lastIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ok</name> = <call><name>JS_InstanceOf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>js_RegExpClass</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_LOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>re</name> = (<name>JSRegExp</name> *) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>re</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* NB: we must reach out: after this paragraph, in order to drop re. */</comment>
    <expr_stmt><expr><call><name>HOLD_REGEXP</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sticky</name> = (<name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_STICKY</name>) != 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>lastIndex</name> = (<name><name>re</name>-&gt;<name>flags</name></name> &amp; (<name>JSREG_GLOB</name> | <name>JSREG_STICKY</name>))
                ? <call><name>GetRegExpLastIndex</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>
                : 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNLOCK_OBJ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now that obj is unlocked, it's safe to (potentially) grab the GC lock. */</comment>
    <if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>str</name> = <name><name>cx</name>-&gt;<name>regExpStatics</name>.<name>input</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bytes</name> <init>= <expr><call><name>js_GetStringBytes</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>re</name>-&gt;<name>source</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>bytes</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>JSMSG_NO_INPUT</name></expr></argument>,
                                     <argument><expr><name>bytes</name></expr></argument>,
                                     <argument><expr>(<name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_GLOB</name>) ? "g" : ""</expr></argument>,
                                     <argument><expr>(<name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_FOLD</name>) ? "i" : ""</expr></argument>,
                                     <argument><expr>(<name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_MULTILINE</name>) ? "m" : ""</expr></argument>,
                                     <argument><expr>(<name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_STICKY</name>) ? "y" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>str</name> = <call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>lastIndex</name> &lt; 0 || <call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> &lt; <name>lastIndex</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ClearRegExpLastIndex</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>rval</name> = <name>JSVAL_NULL</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>i</name> = (<name>size_t</name>) <name>lastIndex</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <call><name>js_ExecuteRegExp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>ok</name> &amp;&amp;
            ((<name><name>re</name>-&gt;<name>flags</name></name> &amp; <name>JSREG_GLOB</name>) || (*<name>rval</name> != <name>JSVAL_NULL</name> &amp;&amp; <name>sticky</name>))</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>*<name>rval</name> == <name>JSVAL_NULL</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>js_ClearRegExpLastIndex</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><name>ok</name> = <call><name>SetRegExpLastIndex</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></else></if>

<label><name>out</name>:</label>
    <expr_stmt><expr><call><name>DROP_REGEXP</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_exec</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>regexp_exec_sub</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>,
                           <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>regexp_test</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>regexp_exec_sub</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr>*<name>vp</name> != <name>JSVAL_TRUE</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>vp</name> = <name>JSVAL_FALSE</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSFunctionSpec</name></type> <name><name>regexp_methods</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_TOSOURCE</name></expr></cpp:if>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_toSource_str</name></expr></argument>,  <argument><expr><name>regexp_toString</name></expr></argument>,    <argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_toString_str</name></expr></argument>,  <argument><expr><name>regexp_toString</name></expr></argument>,    <argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"compile"</expr></argument>,        <argument><expr><name>regexp_compile</name></expr></argument>,     <argument><expr>2</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"exec"</expr></argument>,           <argument><expr><name>regexp_exec</name></expr></argument>,        <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr>"test"</expr></argument>,           <argument><expr><name>regexp_test</name></expr></argument>,        <argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><name>JS_FS_END</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>RegExp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>argv</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>rval</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>JS_IsConstructing</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If first arg is regexp and no flags are given, just return the arg.
         * (regexp_compile_sub detects the regexp + flags case and throws a
         * TypeError.)  See 10.15.3.1.
         */</comment>
        <if>if <condition>(<expr>(<name>argc</name> &lt; 2 || <call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>) &amp;&amp;
            !<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == &amp;<name>js_RegExpClass</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>rval</name> = <name><name>argv</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Otherwise, replace obj with a new RegExp object. */</comment>
        <expr_stmt><expr><name>obj</name> = <call><name>js_NewObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>js_RegExpClass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/*
         * regexp_compile_sub does not use rval to root its temporaries so we
         * can use it to root obj.
         */</comment>
        <expr_stmt><expr>*<name>rval</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><call><name>regexp_compile_sub</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSObject</name> *</type>
<name>js_InitRegExpClass</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>proto</name> <init>= <expr><call><name>js_InitClass</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>js_RegExpClass</name></expr></argument>, <argument><expr><name>RegExp</name></expr></argument>, <argument><expr>1</expr></argument>,
                                   <argument><expr><name>regexp_props</name></expr></argument>, <argument><expr><name>regexp_methods</name></expr></argument>,
                                   <argument><expr><name>regexp_static_props</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>proto</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSObject</name> *</type><name>ctor</name> <init>= <expr><call><name>JS_GetConstructor</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>ctor</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Give RegExp.prototype private data so it matches the empty string. */</comment>
    <decl_stmt><decl><type><name>jsval</name></type> <name>rval</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>JS_AliasProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ctor</name></expr></argument>, <argument><expr>"input"</expr></argument>,        <argument><expr>"$_"</expr></argument>)</argument_list></call> ||
        !<call><name>JS_AliasProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ctor</name></expr></argument>, <argument><expr>"multiline"</expr></argument>,    <argument><expr>"$*"</expr></argument>)</argument_list></call> ||
        !<call><name>JS_AliasProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ctor</name></expr></argument>, <argument><expr>"lastMatch"</expr></argument>,    <argument><expr>"$&amp;"</expr></argument>)</argument_list></call> ||
        !<call><name>JS_AliasProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ctor</name></expr></argument>, <argument><expr>"lastParen"</expr></argument>,    <argument><expr>"$+"</expr></argument>)</argument_list></call> ||
        !<call><name>JS_AliasProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ctor</name></expr></argument>, <argument><expr>"leftContext"</expr></argument>,  <argument><expr>"$`"</expr></argument>)</argument_list></call> ||
        !<call><name>JS_AliasProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ctor</name></expr></argument>, <argument><expr>"rightContext"</expr></argument>, <argument><expr>"$'"</expr></argument>)</argument_list></call> ||
        !<call><name>regexp_compile_sub</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>rval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>proto</name></expr>;</return>
}</block></function>

<function><type><name>JSObject</name> *</type>
<name>js_NewRegExpObject</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl></param>,
                   <param><decl><type><name>jschar</name> *</type><name>chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>re</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>str</name> = <call><name>js_NewStringCopyN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <function_decl><type><name>JSAutoTempValueRooter</name></type> <name>tvr</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>str</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>re</name> = <call><name>js_NewRegExp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>,  <argument><expr><name>str</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>re</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>obj</name> = <call><name>js_NewObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>js_RegExpClass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_DestroyRegExp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>obj</name>-&gt;<name>setPrivate</name></name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_ClearRegExpLastIndex</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>obj</name></expr>;</return>
}</block></function>

<function><type><name>JSObject</name> * <name>JS_FASTCALL</name></type>
<name>js_CloneRegExpObject</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> == &amp;<name>js_RegExpClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>clone</name> <init>= <expr><call><name>js_NewObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>js_RegExpClass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>clone</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>JSRegExp</name> *</type><name>re</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>JSRegExp</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>clone</name>-&gt;<name>setPrivate</name></name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_ClearRegExpLastIndex</name><argument_list>(<argument><expr><name>clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HOLD_REGEXP</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>clone</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
<macro><name>JS_DEFINE_CALLINFO_2</name><argument_list>(<argument>extern</argument>, <argument>OBJECT</argument>, <argument>js_CloneRegExpObject</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>0</argument>, <argument>0</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type>
<name>js_ContainsRegExpMetaChars</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>jschar</name> *</type><name>chars</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>length</name></decl></param>)</parameter_list>
<block>{
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>jschar</name></type> <name>c</name> <init>= <expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
          <comment type="block">/* Taken from the PatternCharacter production in 15.10.1. */</comment>
          <case>case <expr>'^'</expr>: </case><case>case <expr>'$'</expr>: </case><case>case <expr>'\\'</expr>: </case><case>case <expr>'.'</expr>: </case><case>case <expr>'*'</expr>: </case><case>case <expr>'+'</expr>:
          </case><case>case <expr>'?'</expr>: </case><case>case <expr>'('</expr>: </case><case>case <expr>')'</expr>: </case><case>case <expr>'['</expr>: </case><case>case <expr>']'</expr>: </case><case>case <expr>'{'</expr>:
          </case><case>case <expr>'}'</expr>: </case><case>case <expr>'|'</expr>:
            <return>return <expr>true</expr>;</return>
          </case><default>default:<empty_stmt>;</empty_stmt>
        </default>}</block></switch>
    }</block></for>
    <return>return <expr>false</expr>;</return>
}</block></function>
</unit>
