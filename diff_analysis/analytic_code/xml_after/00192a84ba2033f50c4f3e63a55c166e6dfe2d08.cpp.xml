<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="00192a84ba2033f50c4f3e63a55c166e6dfe2d08.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=2 sw=2 et tw=78:
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Novell code.
 *
 * The Initial Developer of the Original Code is Novell Corporation.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *     robert@ocallahan.org
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK *****
 */</comment>

<comment type="block">/*
 * structures that represent things to be painted (ordered in z-order),
 * used during painting and hit testing
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDisplayList.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSRendering.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISelectionController.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPresShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRegion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleStructInlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleTransformMatrix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxMatrix.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSVGIntegrationUtils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutUtils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"imgIContainer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIInterfaceRequestorUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"BasicLayers.h"</cpp:file></cpp:include>

<using>using namespace <name>mozilla</name>;</using>
<using>using namespace <name><name>mozilla</name>::<name>layers</name></name>;</using>

<constructor><name><name>nsDisplayListBuilder</name>::<name>nsDisplayListBuilder</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aReferenceFrame</name></decl></param>,
    <param><decl><type><name>PRBool</name></type> <name>aIsForEvents</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aBuildCaret</name></decl></param>)</parameter_list>
    <member_list>: <call><name>mReferenceFrame</name><argument_list>(<argument><expr><name>aReferenceFrame</name></expr></argument>)</argument_list></call>,
      <call><name>mMovingFrame</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
      <call><name>mIgnoreScrollFrame</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
      <call><name>mCurrentTableItem</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
      <call><name>mBuildCaret</name><argument_list>(<argument><expr><name>aBuildCaret</name></expr></argument>)</argument_list></call>,
      <call><name>mEventDelivery</name><argument_list>(<argument><expr><name>aIsForEvents</name></expr></argument>)</argument_list></call>,
      <call><name>mIsAtRootOfPseudoStackingContext</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
      <call><name>mSelectedFramesOnly</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
      <call><name>mAccurateVisibleRegions</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
      <call><name>mInTransform</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
      <call><name>mSyncDecodeImages</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
      <call><name>mIsPaintingToWindow</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call> </member_list><block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PL_InitArenaPool</name><argument_list>(<argument><expr>&amp;<name>mPool</name></expr></argument>, <argument><expr>"displayListArena"</expr></argument>, <argument><expr>1024</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>pc</name> <init>= <expr><call><name><name>aReferenceFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>shell</name> <init>= <expr><call><name><name>pc</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>mIsBackgroundOnly</name> = <call><name><name>shell</name>-&gt;<name>IsPaintingSuppressed</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name><name>pc</name>-&gt;<name>IsRenderingOnlySelection</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISelectionController</name></expr></argument>&gt;</argument_list></name></type> <name>selcon</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>shell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>selcon</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>selcon</name>-&gt;<name>GetSelection</name></name><argument_list>(<argument><expr><name><name>nsISelectionController</name>::<name>SELECTION_NORMAL</name></name></expr></argument>,
                           <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mBoundingSelection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>mIsBackgroundOnly</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mBuildCaret</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></constructor>

<function><type><specifier>static</specifier> <name>void</name></type> <name>MarkFrameForDisplay</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aStopAtFrame</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsFrameManager</name>*</type> <name>frameManager</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call>-&gt;<call><name>FrameManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><name>aFrame</name></expr></init></decl>;</init> <condition><expr><name>f</name></expr>;</condition>
       <incr><expr><name>f</name> = <call><name><name>nsLayoutUtils</name>::<name>GetParentOrPlaceholderFor</name></name><argument_list>(<argument><expr><name>frameManager</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
    <if>if <condition>(<expr><call><name><name>f</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO</name></expr>)</condition><then>
      <return>return;</return></then></if>
    <expr_stmt><expr><call><name><name>f</name>-&gt;<name>AddStateBits</name></name><argument_list>(<argument><expr><name>NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>f</name> == <name>aStopAtFrame</name></expr>)</condition><then> <block>{
      <comment type="line">// we've reached a frame that we know will be painted, so we can stop.</comment>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>MarkOutOfFlowFrameForDisplay</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aDirtyFrame</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsRect</name></type> <name>dirty</name> <init>= <expr><name>aDirtyRect</name> - <call><name><name>aFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><name>aDirtyFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>overflowRect</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetOverflowRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>dirty</name>.<name>IntersectRect</name></name><argument_list>(<argument><expr><name>dirty</name></expr></argument>, <argument><expr><name>overflowRect</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>
  <expr_stmt><expr><call><name><name>aFrame</name>-&gt;<name>Properties</name></name><argument_list>()</argument_list></call>.<call><name>Set</name><argument_list>(<argument><expr><call><name><name>nsDisplayListBuilder</name>::<name>OutOfFlowDirtyRectProperty</name></name><argument_list>()</argument_list></call></expr></argument>,
                           <argument><expr>new <call><name>nsRect</name><argument_list>(<argument><expr><name>dirty</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>MarkFrameForDisplay</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aDirtyFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>UnmarkFrameForDisplay</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>presContext</name>-&gt;<name>PropertyTable</name></name><argument_list>()</argument_list></call>-&gt;
    <call><name>Delete</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><call><name><name>nsDisplayListBuilder</name>::<name>OutOfFlowDirtyRectProperty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsFrameManager</name>*</type> <name>frameManager</name> <init>= <expr><call><name><name>presContext</name>-&gt;<name>PresShell</name></name><argument_list>()</argument_list></call>-&gt;<call><name>FrameManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><name>aFrame</name></expr></init></decl>;</init> <condition><expr><name>f</name></expr>;</condition>
       <incr><expr><name>f</name> = <call><name><name>nsLayoutUtils</name>::<name>GetParentOrPlaceholderFor</name></name><argument_list>(<argument><expr><name>frameManager</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
    <if>if <condition>(<expr>!(<call><name><name>f</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO</name>)</expr>)</condition><then>
      <return>return;</return></then></if>
    <expr_stmt><expr><call><name><name>f</name>-&gt;<name>RemoveStateBits</name></name><argument_list>(<argument><expr><name>NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<destructor><name><name>nsDisplayListBuilder</name>::~<name>nsDisplayListBuilder</name></name><parameter_list>()</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mFramesMarkedForDisplay</name>.<name>Length</name></name><argument_list>()</argument_list></call> == 0</expr></argument>,
               <argument><expr>"All frames should have been unmarked"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mPresShellStates</name>.<name>Length</name></name><argument_list>()</argument_list></call> == 0</expr></argument>,
               <argument><expr>"All presshells should have been exited"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mCurrentTableItem</name></expr></argument>, <argument><expr>"No table item should be active"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PL_FreeArenaPool</name><argument_list>(<argument><expr>&amp;<name>mPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PL_FinishArenaPool</name><argument_list>(<argument><expr>&amp;<name>mPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayListBuilder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>PRUint32</name></type>
<name><name>nsDisplayListBuilder</name>::<name>GetBackgroundPaintFlags</name></name><parameter_list>()</parameter_list> <block>{
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mSyncDecodeImages</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>flags</name> |= <name><name>nsCSSRendering</name>::<name>PAINTBG_SYNC_DECODE_IMAGES</name></name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>flags</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayListBuilder</name>::<name>SubtractFromVisibleRegion</name></name><parameter_list>(<param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                                <param><decl><type><specifier>const</specifier> <name>nsRegion</name>&amp;</type> <name>aRegion</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsRegion</name></type> <name>tmp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>tmp</name>.<name>Sub</name></name><argument_list>(<argument><expr>*<name>aVisibleRegion</name></expr></argument>, <argument><expr><name>aRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Don't let *aVisibleRegion get too complex, but don't let it fluff out</comment>
  <comment type="line">// to its bounds either, which can be very bad (see bug 516740).</comment>
  <if>if <condition>(<expr><call><name>GetAccurateVisibleRegions</name><argument_list>()</argument_list></call> || <call><name><name>tmp</name>.<name>GetNumRects</name></name><argument_list>()</argument_list></call> &lt;= 15</expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aVisibleRegion</name> = <name>tmp</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayListBuilder</name>::<name>IsMovingFrame</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>mMovingFrame</name> &amp;&amp;
     <call><name><name>nsLayoutUtils</name>::<name>IsAncestorFrameCrossDoc</name></name><argument_list>(<argument><expr><name>mMovingFrame</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>mReferenceFrame</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsCaret</name> *</type>
<name><name>nsDisplayListBuilder</name>::<name>GetCaret</name></name><parameter_list>()</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCaret</name></expr></argument>&gt;</argument_list></name></type> <name>caret</name> <init>= <expr><call><name>CurrentPresShellState</name><argument_list>()</argument_list></call>-&gt;<call><name><name>mPresShell</name>-&gt;<name>GetCaret</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>caret</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayListBuilder</name>::<name>EnterPresShell</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aReferenceFrame</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>PresShellState</name>*</type> <name>state</name> <init>= <expr><call><name><name>mPresShellStates</name>.<name>AppendElement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>state</name></expr>)</condition><then>
    <return>return;</return></then></if>
  <expr_stmt><expr><name><name>state</name>-&gt;<name>mPresShell</name></name> = <call><name><name>aReferenceFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name>-&gt;<name>mCaretFrame</name></name> = <name>nsnull</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name>-&gt;<name>mFirstFrameMarkedForDisplay</name></name> = <call><name><name>mFramesMarkedForDisplay</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>state</name>-&gt;<name>mPresShell</name>-&gt;<name>UpdateCanvasBackground</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mIsPaintingToWindow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>state</name>-&gt;<name>mPresShell</name>-&gt;<name>IncrementPaintCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>mBuildCaret</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsCaret</name></expr></argument>&gt;</argument_list></name></type> <name>caret</name> <init>= <expr><call><name><name>state</name>-&gt;<name>mPresShell</name>-&gt;<name>GetCaret</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>state</name>-&gt;<name>mCaretFrame</name></name> = <call><name><name>caret</name>-&gt;<name>GetCaretFrame</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>state</name>-&gt;<name>mCaretFrame</name></name></expr>)</condition><then> <block>{
    <comment type="line">// Check if the dirty rect intersects with the caret's dirty rect.</comment>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>caretRect</name> <init>=
      <expr><call><name><name>caret</name>-&gt;<name>GetCaretRect</name></name><argument_list>()</argument_list></call> + <call><name><name>state</name>-&gt;<name>mCaretFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><name>aReferenceFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>caretRect</name>.<name>Intersects</name></name><argument_list>(<argument><expr><name>aDirtyRect</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Okay, our rects intersect, let's mark the frame and all of its ancestors.</comment>
      <expr_stmt><expr><call><name><name>mFramesMarkedForDisplay</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>mCaretFrame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>MarkFrameForDisplay</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>mCaretFrame</name></name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayListBuilder</name>::<name>LeavePresShell</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aReferenceFrame</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><call><name>CurrentPresShellState</name><argument_list>()</argument_list></call>-&gt;<name>mPresShell</name> != <call><name><name>aReferenceFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>PresShell</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Must have not allocated a state for this presshell, presumably due</comment>
    <comment type="line">// to OOM.</comment>
    <return>return;</return>
  }</block></then></if>

  <comment type="line">// Unmark and pop off the frames marked for display in this pres shell.</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>firstFrameForShell</name> <init>= <expr><call><name>CurrentPresShellState</name><argument_list>()</argument_list></call>-&gt;<name>mFirstFrameMarkedForDisplay</name></expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr><name>firstFrameForShell</name></expr></init></decl>;</init>
       <condition><expr><name>i</name> &lt; <call><name><name>mFramesMarkedForDisplay</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name>UnmarkFrameForDisplay</name><argument_list>(<argument><expr><name><name>mFramesMarkedForDisplay</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name><name>mFramesMarkedForDisplay</name>.<name>SetLength</name></name><argument_list>(<argument><expr><name>firstFrameForShell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mPresShellStates</name>.<name>SetLength</name></name><argument_list>(<argument><expr><call><name><name>mPresShellStates</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayListBuilder</name>::<name>MarkFramesForDisplayList</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aDirtyFrame</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>nsFrameList</name>&amp;</type> <name>aFrames</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDirtyRect</name></decl></param>)</parameter_list> <block>{
  <for>for (<init><expr><name><name>nsFrameList</name>::<name>Enumerator</name></name> <call><name>e</name><argument_list>(<argument><expr><name>aFrames</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr>!<call><name><name>e</name>.<name>AtEnd</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><call><name><name>e</name>.<name>Next</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <expr_stmt><expr><call><name><name>mFramesMarkedForDisplay</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><call><name><name>e</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MarkOutOfFlowFrameForDisplay</name><argument_list>(<argument><expr><name>aDirtyFrame</name></expr></argument>, <argument><expr><call><name><name>e</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aDirtyRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>void</name>*</type>
<name><name>nsDisplayListBuilder</name>::<name>Allocate</name></name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>aSize</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>tmp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PL_ARENA_ALLOCATE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr>&amp;<name>mPool</name></expr></argument>, <argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>tmp</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplayListSet</name>::<name>MoveTo</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aDestination</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name><name>aDestination</name>.<name>BorderBackground</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name>BorderBackground</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aDestination</name>.<name>BlockBorderBackgrounds</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name>BlockBorderBackgrounds</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aDestination</name>.<name>Floats</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name>Floats</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aDestination</name>.<name>Content</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name>Content</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aDestination</name>.<name>PositionedDescendants</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name>PositionedDescendants</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aDestination</name>.<name>Outlines</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name>Outlines</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayList</name>::<name>FlattenTo</name></name><parameter_list>(<param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsDisplayItem</name>*</expr></argument>&gt;</argument_list></name>*</type> <name>aElements</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>item</name></decl>;</decl_stmt>
  <while>while <condition>(<expr>(<name>item</name> = <call><name>RemoveBottom</name><argument_list>()</argument_list></call>) != <name>nsnull</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><call><name><name>item</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name><name>nsDisplayItem</name>::<name>TYPE_WRAP_LIST</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>item</name>-&gt;<name>GetList</name></name><argument_list>()</argument_list></call>-&gt;<call><name>FlattenTo</name><argument_list>(<argument><expr><name>aElements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>item</name>-&gt;~<name>nsDisplayItem</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name><name>aElements</name>-&gt;<name>AppendElement</name></name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></while>
}</block></function>

<function><type><name>nsRect</name></type>
<name><name>nsDisplayList</name>::<name>GetBounds</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <specifier>const</specifier> <block>{
  <decl_stmt><decl><type><name>nsRect</name></type> <name>bounds</name></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>nsDisplayItem</name>*</type> <name>i</name> <init>= <expr><call><name>GetBottom</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> != <name>nsnull</name></expr>;</condition> <incr><expr><name>i</name> = <call><name><name>i</name>-&gt;<name>GetAbove</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <expr_stmt><expr><call><name><name>bounds</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>bounds</name></expr></argument>, <argument><expr><call><name><name>i</name>-&gt;<name>GetBounds</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>bounds</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayList</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                 <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                 <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aVisibleRegionBeforeMove</name></expr></argument>, <argument><expr>"Not supported anymore"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mVisibleRect</name> = <call><name><name>aVisibleRegion</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>anyVisible</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>nsDisplayItem</name>*</expr></argument>, <argument><expr>512</expr></argument>&gt;</argument_list></name></type> <name>elements</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>FlattenTo</name><argument_list>(<argument><expr>&amp;<name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr><call><name><name>elements</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>item</name> <init>= <expr><name><name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>belowItem</name> <init>= <expr><name>i</name> &lt; 1 ? <name>nsnull</name> : <name><name>elements</name><index>[<expr><name>i</name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>belowItem</name> &amp;&amp; <call><name><name>item</name>-&gt;<name>TryMerge</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>belowItem</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>belowItem</name>-&gt;~<name>nsDisplayItem</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>elements</name>.<name>ReplaceElementsAt</name></name><argument_list>(<argument><expr><name>i</name> - 1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsRect</name></type> <name>bounds</name> <init>= <expr><call><name><name>item</name>-&gt;<name>GetBounds</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsRegion</name></type> <name>itemVisible</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>itemVisible</name>.<name>And</name></name><argument_list>(<argument><expr>*<name>aVisibleRegion</name></expr></argument>, <argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name>-&gt;<name>mVisibleRect</name></name> = <call><name><name>itemVisible</name>.<name>GetBounds</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>item</name>-&gt;<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aVisibleRegion</name></expr></argument>, <argument><expr><name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>anyVisible</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><call><name><name>item</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name><name>item</name>-&gt;<name>IsOpaque</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call> &amp;&amp; <name>f</name></expr>)</condition><then> <block>{
        <comment type="line">// Subtract opaque item from the visible region</comment>
        <expr_stmt><expr><call><name><name>aBuilder</name>-&gt;<name>SubtractFromVisibleRegion</name></name><argument_list>(<argument><expr><name>aVisibleRegion</name></expr></argument>, <argument><expr><call><name>nsRegion</name><argument_list>(<argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>AppendToBottom</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <expr_stmt><expr><name>mIsOpaque</name> = <call><name><name>aVisibleRegion</name>-&gt;<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>mDidComputeVisibility</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>anyVisible</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplayList</name>::<name>PaintRoot</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                              <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>,
                              <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>)</parameter_list> <specifier>const</specifier> <block>{
  <expr_stmt><expr><call><name>PaintForFrame</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aCtx</name></expr></argument>, <argument><expr><call><name><name>aBuilder</name>-&gt;<name>ReferenceFrame</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block" format="doxygen">/**
 * We paint by executing a layer manager transaction, constructing a
 * single layer representing the display list, and then making it the
 * root of the layer manager, drawing into the ThebesLayers.
 */</comment>
<function><type><name>void</name></type> <name><name>nsDisplayList</name>::<name>PaintForFrame</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                  <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>,
                                  <param><decl><type><name>nsIFrame</name>*</type> <name>aForFrame</name></decl></param>,
                                  <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>)</parameter_list> <specifier>const</specifier> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mDidComputeVisibility</name></expr></argument>,
               <argument><expr>"Must call ComputeVisibility before calling Paint"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>LayerManager</name></expr></argument>&gt;</argument_list></name></type> <name>layerManager</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aFlags</name> &amp; <name>PAINT_USE_WIDGET_LAYERS</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>referenceFrame</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>ReferenceFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>referenceFrame</name> == <call><name><name>nsLayoutUtils</name>::<name>GetDisplayRootFrame</name></name><argument_list>(<argument><expr><name>referenceFrame</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr>"Reference frame must be a display root for us to use the layer manager"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsIWidget</name>*</type> <name>window</name> <init>= <expr><call><name><name>referenceFrame</name>-&gt;<name>GetNearestWidget</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>window</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>layerManager</name> = <call><name><name>window</name>-&gt;<name>GetLayerManager</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>layerManager</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aBuilder</name>-&gt;<name>LayerBuilder</name></name><argument_list>()</argument_list></call>-&gt;<call><name>BeginUpdatingRetainedLayers</name><argument_list>(<argument><expr><name>layerManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <if>if <condition>(<expr>!<name>layerManager</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<name>aCtx</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Nowhere to paint into"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><name>layerManager</name> = new <call><name>BasicLayerManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>layerManager</name></expr>)</condition><then>
      <return>return;</return></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>aFlags</name> &amp; <name>PAINT_FLUSH_LAYERS</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>FrameLayerBuilder</name>::<name>InvalidateAllLayers</name></name><argument_list>(<argument><expr><name>layerManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>aCtx</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>layerManager</name>-&gt;<name>BeginTransactionWithTarget</name></name><argument_list>(<argument><expr><call><name><name>aCtx</name>-&gt;<name>ThebesContext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name><name>layerManager</name>-&gt;<name>BeginTransaction</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>Layer</name></expr></argument>&gt;</argument_list></name></type> <name>root</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>LayerBuilder</name></name><argument_list>()</argument_list></call>-&gt;
    <call><name>BuildContainerLayerFor</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>layerManager</name></expr></argument>, <argument><expr><name>aForFrame</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>*<name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>root</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>visible</name> <init>=
    <expr><call><name><name>mVisibleRect</name>.<name>ToNearestPixels</name></name><argument_list>(<argument><expr><call><name><name>aForFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppUnitsPerDevPixel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>root</name>-&gt;<name>SetVisibleRegion</name></name><argument_list>(<argument><expr><call><name>nsIntRegion</name><argument_list>(<argument><expr><name>visible</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>layerManager</name>-&gt;<name>SetRoot</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>layerManager</name>-&gt;<name>EndTransaction</name></name><argument_list>(<argument><expr><name><name>FrameLayerBuilder</name>::<name>DrawThebesLayer</name></name></expr></argument>,
                               <argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aBuilder</name>-&gt;<name>LayerBuilder</name></name><argument_list>()</argument_list></call>-&gt;<call><name>DidEndTransaction</name><argument_list>(<argument><expr><name>layerManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>aFlags</name> &amp; <name>PAINT_FLUSH_LAYERS</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>FrameLayerBuilder</name>::<name>InvalidateAllLayers</name></name><argument_list>(<argument><expr><name>layerManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>DidPaint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRUint32</name></type> <name><name>nsDisplayList</name>::<name>Count</name></name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>nsDisplayItem</name>*</type> <name>i</name> <init>= <expr><call><name>GetBottom</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name> = <call><name><name>i</name>-&gt;<name>GetAbove</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <expr_stmt><expr>++<name>count</name></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>count</name></expr>;</return>
}</block></function>

<function><type><name>nsDisplayItem</name>*</type> <name><name>nsDisplayList</name>::<name>RemoveBottom</name></name><parameter_list>()</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>item</name> <init>= <expr><name><name>mSentinel</name>.<name>mAbove</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>item</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>
  <expr_stmt><expr><name><name>mSentinel</name>.<name>mAbove</name></name> = <name><name>item</name>-&gt;<name>mAbove</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>item</name> == <name>mTop</name></expr>)</condition><then> <block>{
    <comment type="line">// must have been the only item</comment>
    <expr_stmt><expr><name>mTop</name> = &amp;<name>mSentinel</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>mAbove</name></name> = <name>nsnull</name></expr>;</expr_stmt>
  <return>return <expr><name>item</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplayList</name>::<name>DeleteAll</name></name><parameter_list>()</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>item</name></decl>;</decl_stmt>
  <while>while <condition>(<expr>(<name>item</name> = <call><name>RemoveBottom</name><argument_list>()</argument_list></call>) != <name>nsnull</name></expr>)</condition> <block>{
    <expr_stmt><expr><call><name><name>item</name>-&gt;~<name>nsDisplayItem</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></while>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplayList</name>::<name>HitTest</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>,
                            <param><decl><type><name><name>nsDisplayItem</name>::<name>HitTestState</name></name>*</type> <name>aState</name></decl></param>,
                            <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsIFrame</name>*</expr></argument>&gt;</argument_list></name> *</type><name>aOutFrames</name></decl></param>)</parameter_list> <specifier>const</specifier> <block>{
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>itemBufferStart</name> <init>= <expr><call><name><name>aState</name>-&gt;<name>mItemBuffer</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>item</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>item</name> = <call><name>GetBottom</name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>item</name></expr>;</condition> <incr><expr><name>item</name> = <call><name><name>item</name>-&gt;<name>GetAbove</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <expr_stmt><expr><call><name><name>aState</name>-&gt;<name>mItemBuffer</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr><call><name><name>aState</name>-&gt;<name>mItemBuffer</name>.<name>Length</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= <name>itemBufferStart</name></expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
    <comment type="line">// Pop element off the end of the buffer. We want to shorten the buffer</comment>
    <comment type="line">// so that recursive calls to HitTest have more buffer space.</comment>
    <expr_stmt><expr><name>item</name> = <name><name>aState</name>-&gt;<name>mItemBuffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aState</name>-&gt;<name>mItemBuffer</name>.<name>SetLength</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>aRect</name>.<name>Intersects</name></name><argument_list>(<argument><expr><call><name><name>item</name>-&gt;<name>GetBounds</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsIFrame</name>*</expr></argument>&gt;</argument_list></name></type> <name>outFrames</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>item</name>-&gt;<name>HitTest</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aRect</name></expr></argument>, <argument><expr><name>aState</name></expr></argument>, <argument><expr>&amp;<name>outFrames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for (<init><decl><type><name>PRUint32</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <call><name><name>outFrames</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>f</name> <init>= <expr><call><name><name>outFrames</name>.<name>ElementAt</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// Handle the XUL 'mousethrough' feature and 'pointer-events'.</comment>
        <if>if <condition>(<expr>!<call><name><name>f</name>-&gt;<name>GetMouseThrough</name></name><argument_list>()</argument_list></call> &amp;&amp;
            <call><name><name>f</name>-&gt;<name>GetStyleVisibility</name></name><argument_list>()</argument_list></call>-&gt;<name>mPointerEvents</name> != <name>NS_STYLE_POINTER_EVENTS_NONE</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>aOutFrames</name>-&gt;<name>AppendElement</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>

    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aState</name>-&gt;<name>mItemBuffer</name>.<name>Length</name></name><argument_list>()</argument_list></call> == <call><name>PRUint32</name><argument_list>(<argument><expr><name>itemBufferStart</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr>"How did we forget to pop some elements?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>Sort</name><parameter_list>(<param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aCount</name></decl></param>, <param><decl><type><name><name>nsDisplayList</name>::<name>SortLEQ</name></name></type> <name>aCmp</name></decl></param>,
                 <param><decl><type><name>void</name>*</type> <name>aClosure</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><name>aCount</name> &lt; 2</expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>nsDisplayList</name></type> <name>list1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayList</name></type> <name>list2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>half</name> <init>= <expr><name>aCount</name>/2</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>sorted</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>prev</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>aCount</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>item</name> <init>= <expr><call><name><name>aList</name>-&gt;<name>RemoveBottom</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>(<name>i</name> &lt; <name>half</name> ? &amp;<name>list1</name> : &amp;<name>list2</name>)-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>sorted</name> &amp;&amp; <name>prev</name> &amp;&amp; !<call><name>aCmp</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>sorted</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>prev</name> = <name>item</name></expr>;</expr_stmt>
  }</block></for>
  <if>if <condition>(<expr><name>sorted</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aList</name>-&gt;<name>AppendToTop</name></name><argument_list>(<argument><expr>&amp;<name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aList</name>-&gt;<name>AppendToTop</name></name><argument_list>(<argument><expr>&amp;<name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  
  <expr_stmt><expr><call><name>Sort</name><argument_list>(<argument><expr>&amp;<name>list1</name></expr></argument>, <argument><expr><name>half</name></expr></argument>, <argument><expr><name>aCmp</name></expr></argument>, <argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Sort</name><argument_list>(<argument><expr>&amp;<name>list2</name></expr></argument>, <argument><expr><name>aCount</name> - <name>half</name></expr></argument>, <argument><expr><name>aCmp</name></expr></argument>, <argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>aCount</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <if>if <condition>(<expr><call><name><name>list1</name>.<name>GetBottom</name></name><argument_list>()</argument_list></call> &amp;&amp;
        (!<call><name><name>list2</name>.<name>GetBottom</name></name><argument_list>()</argument_list></call> ||
         <call><name>aCmp</name><argument_list>(<argument><expr><call><name><name>list1</name>.<name>GetBottom</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>list2</name>.<name>GetBottom</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aClosure</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aList</name>-&gt;<name>AppendToTop</name></name><argument_list>(<argument><expr><call><name><name>list1</name>.<name>RemoveBottom</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name><name>aList</name>-&gt;<name>AppendToTop</name></name><argument_list>(<argument><expr><call><name><name>list2</name>.<name>RemoveBottom</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>IsContentLEQ</name><parameter_list>(<param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem1</name></decl></param>, <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem2</name></decl></param>,
                           <param><decl><type><name>void</name>*</type> <name>aClosure</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// These GetUnderlyingFrame calls return non-null because we're only used</comment>
  <comment type="line">// in sorting</comment>
  <return>return <expr><call><name><name>nsLayoutUtils</name>::<name>CompareTreePosition</name></name><argument_list>(
      <argument><expr><call><name><name>aItem1</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetContent</name><argument_list>()</argument_list></call></expr></argument>,
      <argument><expr><call><name><name>aItem2</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetContent</name><argument_list>()</argument_list></call></expr></argument>,
      <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIContent</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;= 0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>IsZOrderLEQ</name><parameter_list>(<param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem1</name></decl></param>, <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem2</name></decl></param>,
                          <param><decl><type><name>void</name>*</type> <name>aClosure</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// These GetUnderlyingFrame calls return non-null because we're only used</comment>
  <comment type="line">// in sorting.  Note that we can't just take the difference of the two</comment>
  <comment type="line">// z-indices here, because that might overflow a 32-bit int.</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>index1</name> <init>= <expr><call><name><name>nsLayoutUtils</name>::<name>GetZIndex</name></name><argument_list>(<argument><expr><call><name><name>aItem1</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>index2</name> <init>= <expr><call><name><name>nsLayoutUtils</name>::<name>GetZIndex</name></name><argument_list>(<argument><expr><call><name><name>aItem2</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>index1</name> == <name>index2</name></expr>)</condition><then>
    <return>return <expr><call><name>IsContentLEQ</name><argument_list>(<argument><expr><name>aItem1</name></expr></argument>, <argument><expr><name>aItem2</name></expr></argument>, <argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <return>return <expr><name>index1</name> &lt; <name>index2</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplayList</name>::<name>ExplodeAnonymousChildLists</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// See if there's anything to do</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>anyAnonymousItems</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>i</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = <call><name>GetBottom</name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>i</name> != <name>nsnull</name></expr>;</condition> <incr><expr><name>i</name> = <call><name><name>i</name>-&gt;<name>GetAbove</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <if>if <condition>(<expr>!<call><name><name>i</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>anyAnonymousItems</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
  <if>if <condition>(<expr>!<name>anyAnonymousItems</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>nsDisplayList</name></type> <name>tmp</name></decl>;</decl_stmt>
  <while>while <condition>(<expr>(<name>i</name> = <call><name>RemoveBottom</name><argument_list>()</argument_list></call>) != <name>nsnull</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><call><name><name>i</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>tmp</name>.<name>AppendToTop</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <decl_stmt><decl><type><name>nsDisplayList</name>*</type> <name>list</name> <init>= <expr><call><name><name>i</name>-&gt;<name>GetList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr>"leaf items can't be anonymous"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>list</name>-&gt;<name>ExplodeAnonymousChildLists</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>j</name></decl>;</decl_stmt>
      <while>while <condition>(<expr>(<name>j</name> = <call><name><name>list</name>-&gt;<name>RemoveBottom</name></name><argument_list>()</argument_list></call>) != <name>nsnull</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name><name>tmp</name>.<name>AppendToTop</name></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDisplayWrapList</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>-&gt;
            <call><name>WrapWithClone</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <expr_stmt><expr><call><name><name>i</name>-&gt;~<name>nsDisplayItem</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></while>
  
  <expr_stmt><expr><call><name>AppendToTop</name><argument_list>(<argument><expr>&amp;<name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplayList</name>::<name>SortByZOrder</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                 <param><decl><type><name>nsIContent</name>*</type> <name>aCommonAncestor</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>Sort</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>IsZOrderLEQ</name></expr></argument>, <argument><expr><name>aCommonAncestor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplayList</name>::<name>SortByContentOrder</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                       <param><decl><type><name>nsIContent</name>*</type> <name>aCommonAncestor</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>Sort</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>IsContentLEQ</name></expr></argument>, <argument><expr><name>aCommonAncestor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplayList</name>::<name>Sort</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                         <param><decl><type><name>SortLEQ</name></type> <name>aCmp</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>aClosure</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>ExplodeAnonymousChildLists</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>Sort</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>Count</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aCmp</name></expr></argument>, <argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplayItem</name>::<name>RecomputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                          <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsRect</name></type> <name>bounds</name> <init>= <expr><call><name>GetBounds</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsRegion</name></type> <name>itemVisible</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>itemVisible</name>.<name>And</name></name><argument_list>(<argument><expr>*<name>aVisibleRegion</name></expr></argument>, <argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mVisibleRect</name> = <call><name><name>itemVisible</name>.<name>GetBounds</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>ComputeVisibility</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aVisibleRegion</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>IsOpaque</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aVisibleRegion</name>-&gt;<name>Sub</name></name><argument_list>(<argument><expr>*<name>aVisibleRegion</name></expr></argument>, <argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplaySolidColor</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name><name>aCtx</name>-&gt;<name>SetColor</name></name><argument_list>(<argument><expr><name>mColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aCtx</name>-&gt;<name>FillRect</name></name><argument_list>(<argument><expr><name>mVisibleRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Returns TRUE if aContainedRect is guaranteed to be contained in</comment>
<comment type="line">// the rounded rect defined by aRoundedRect and aRadii. Complex cases are</comment>
<comment type="line">// handled conservatively by returning FALSE in some situations where</comment>
<comment type="line">// a more thorough analysis could return TRUE.</comment>
<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>RoundedRectContainsRect</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRoundedRect</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>nscoord</name></type> <name><name>aRadii</name><index>[<expr>8</expr>]</index></name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aContainedRect</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// rectFullHeight and rectFullWidth together will approximately contain</comment>
  <comment type="line">// the total area of the frame minus the rounded corners.</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>rectFullHeight</name> <init>= <expr><name>aRoundedRect</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>xDiff</name> <init>= <expr><call><name>NS_MAX</name><argument_list>(<argument><expr><name><name>aRadii</name><index>[<expr><name>NS_CORNER_TOP_LEFT_X</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>aRadii</name><index>[<expr><name>NS_CORNER_BOTTOM_LEFT_X</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>rectFullHeight</name>.<name>x</name></name> += <name>xDiff</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rectFullHeight</name>.<name>width</name></name> -= <call><name>NS_MAX</name><argument_list>(<argument><expr><name><name>aRadii</name><index>[<expr><name>NS_CORNER_TOP_RIGHT_X</name></expr>]</index></name></expr></argument>,
                                 <argument><expr><name><name>aRadii</name><index>[<expr><name>NS_CORNER_BOTTOM_RIGHT_X</name></expr>]</index></name></expr></argument>)</argument_list></call> + <name>xDiff</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name><name>rectFullHeight</name>.<name>Contains</name></name><argument_list>(<argument><expr><name>aContainedRect</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsRect</name></type> <name>rectFullWidth</name> <init>= <expr><name>aRoundedRect</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>yDiff</name> <init>= <expr><call><name>NS_MAX</name><argument_list>(<argument><expr><name><name>aRadii</name><index>[<expr><name>NS_CORNER_TOP_LEFT_Y</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>aRadii</name><index>[<expr><name>NS_CORNER_TOP_RIGHT_Y</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>rectFullWidth</name>.<name>y</name></name> += <name>yDiff</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rectFullWidth</name>.<name>height</name></name> -= <call><name>NS_MAX</name><argument_list>(<argument><expr><name><name>aRadii</name><index>[<expr><name>NS_CORNER_BOTTOM_LEFT_Y</name></expr>]</index></name></expr></argument>,
                                 <argument><expr><name><name>aRadii</name><index>[<expr><name>NS_CORNER_BOTTOM_RIGHT_Y</name></expr>]</index></name></expr></argument>)</argument_list></call> + <name>yDiff</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name><name>rectFullWidth</name>.<name>Contains</name></name><argument_list>(<argument><expr><name>aContainedRect</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayBackground</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                       <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                       <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name><name>nsDisplayItem</name>::<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aVisibleRegion</name></expr></argument>,
                                        <argument><expr><name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <comment type="line">// Return false if the background was propagated away from this</comment>
  <comment type="line">// frame. We don't want this display item to show up and confuse</comment>
  <comment type="line">// anything.</comment>
  <decl_stmt><decl><type><name>nsStyleContext</name>*</type> <name>bgSC</name></decl>;</decl_stmt>
  <return>return <expr><name>mIsThemed</name> ||
    <call><name><name>nsCSSRendering</name>::<name>FindBackground</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>, <argument><expr>&amp;<name>bgSC</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayBackground</name>::<name>IsOpaque</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// theme background overrides any other background</comment>
  <if>if <condition>(<expr><name>mIsThemed</name></expr>)</condition><then>
    <return>return <expr><name>mThemeTransparency</name> == <name><name>nsITheme</name>::<name>eOpaque</name></name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsStyleContext</name>*</type> <name>bgSC</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>nsCSSRendering</name>::<name>FindBackground</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>, <argument><expr>&amp;<name>bgSC</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleBackground</name>*</type> <name>bg</name> <init>= <expr><call><name><name>bgSC</name>-&gt;<name>GetStyleBackground</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name><name>nsStyleBackground</name>::<name>Layer</name></name>&amp;</type> <name>bottomLayer</name> <init>= <expr><call><name><name>bg</name>-&gt;<name>BottomLayer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// bottom layer's clip is used for the color</comment>
  <if>if <condition>(<expr><name><name>bottomLayer</name>.<name>mClip</name></name> != <name>NS_STYLE_BG_CLIP_BORDER</name> ||
      <call><name><name>nsLayoutUtils</name>::<name>HasNonZeroCorner</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>GetStyleBorder</name></name><argument_list>()</argument_list></call>-&gt;<name>mBorderRadius</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>NS_GET_A</name><argument_list>(<argument><expr><name><name>bg</name>-&gt;<name>mBackgroundColor</name></name></expr></argument>)</argument_list></call> == 255 &amp;&amp;
      !<call><name><name>nsCSSRendering</name>::<name>IsCanvasFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <return>return <expr><name><name>bottomLayer</name>.<name>mRepeat</name></name> == <name>NS_STYLE_BG_REPEAT_XY</name> &amp;&amp;
         <call><name><name>bottomLayer</name>.<name>mImage</name>.<name>IsOpaque</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayBackground</name>::<name>IsUniform</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nscolor</name>*</type> <name>aColor</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// theme background overrides any other background</comment>
  <if>if <condition>(<expr><name>mIsThemed</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsStyleContext</name> *</type><name>bgSC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>hasBG</name> <init>=
    <expr><call><name><name>nsCSSRendering</name>::<name>FindBackground</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>, <argument><expr>&amp;<name>bgSC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>hasBG</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aColor</name> = <call><name>NS_RGBA</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleBackground</name>*</type> <name>bg</name> <init>= <expr><call><name><name>bgSC</name>-&gt;<name>GetStyleBackground</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>bg</name>-&gt;<name>BottomLayer</name></name><argument_list>()</argument_list></call>.<call><name><name>mImage</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp;
      <name><name>bg</name>-&gt;<name>mImageCount</name></name> == 1 &amp;&amp;
      !<call><name><name>nsLayoutUtils</name>::<name>HasNonZeroCorner</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>GetStyleBorder</name></name><argument_list>()</argument_list></call>-&gt;<name>mBorderRadius</name></expr></argument>)</argument_list></call> &amp;&amp;
      <call><name><name>bg</name>-&gt;<name>BottomLayer</name></name><argument_list>()</argument_list></call>.<name>mClip</name> == <name>NS_STYLE_BG_CLIP_BORDER</name></expr>)</condition><then> <block>{
    <comment type="line">// Canvas frames don't actually render their background color, since that</comment>
    <comment type="line">// gets propagated to the solid color of the viewport</comment>
    <comment type="line">// (see nsCSSRendering::PaintBackgroundWithSC)</comment>
    <expr_stmt><expr>*<name>aColor</name> = <call><name><name>nsCSSRendering</name>::<name>IsCanvasFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call> ? <call><name>NS_RGBA</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call>
        : <name><name>bg</name>-&gt;<name>mBackgroundColor</name></name></expr>;</expr_stmt>
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayBackground</name>::<name>IsVaryingRelativeToMovingFrame</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aBuilder</name>-&gt;<name>IsMovingFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr>"IsVaryingRelativeToMovingFrame called on non-moving frame!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsStyleContext</name> *</type><name>bgSC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>hasBG</name> <init>=
    <expr><call><name><name>nsCSSRendering</name>::<name>FindBackground</name></name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>, <argument><expr>&amp;<name>bgSC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>hasBG</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleBackground</name>*</type> <name>bg</name> <init>= <expr><call><name><name>bgSC</name>-&gt;<name>GetStyleBackground</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>bg</name>-&gt;<name>HasFixedBackground</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>movingFrame</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>GetRootMovingFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// movingFrame is the frame that is going to be moved. It must be equal</comment>
  <comment type="line">// to mFrame or some ancestor of mFrame, see assertion above.</comment>
  <comment type="line">// If mFrame is in the same document as movingFrame, then mFrame</comment>
  <comment type="line">// will move relative to its viewport, which means this display item will</comment>
  <comment type="line">// change when it is moved. If they are in different documents, we do not</comment>
  <comment type="line">// want to return true because mFrame won't move relative to its viewport.</comment>
  <return>return <expr><call><name><name>movingFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call> == <name>presContext</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayBackground</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                           <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>offset</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>flags</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>GetBackgroundPaintFlags</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>nextItem</name> <init>= <expr><call><name>GetAbove</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>nextItem</name> &amp;&amp; <call><name><name>nextItem</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call> == <name>mFrame</name> &amp;&amp;
      <call><name><name>nextItem</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> == <name>TYPE_BORDER</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>flags</name> |= <name><name>nsCSSRendering</name>::<name>PAINTBG_WILL_PAINT_BORDER</name></name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>PaintBackground</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>*<name>aCtx</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>,
                                  <argument><expr><name>mVisibleRect</name></expr></argument>,
                                  <argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsRect</name></type>
<name><name>nsDisplayBackground</name>::<name>GetBounds</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><name>mIsThemed</name></expr>)</condition><then>
    <return>return <expr><call><name><name>mFrame</name>-&gt;<name>GetOverflowRect</name></name><argument_list>()</argument_list></call> + <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><call><name>nsRect</name><argument_list>(<argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsRect</name></type>
<name><name>nsDisplayOutline</name>::<name>GetBounds</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
  <return>return <expr><call><name><name>mFrame</name>-&gt;<name>GetOverflowRect</name></name><argument_list>()</argument_list></call> + <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayOutline</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                        <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// TODO join outlines together</comment>
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>offset</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>PaintOutline</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>*<name>aCtx</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>,
                               <argument><expr><name>mVisibleRect</name></expr></argument>,
                               <argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetStyleContext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayOutline</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                    <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                    <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aVisibleRegionBeforeMove</name></expr></argument>, <argument><expr>"not supported anymore"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name><name>nsDisplayItem</name>::<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aVisibleRegion</name></expr></argument>,
                                        <argument><expr><name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleOutline</name>*</type> <name>outline</name> <init>= <expr><call><name><name>mFrame</name>-&gt;<name>GetStyleOutline</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>borderBox</name><argument_list>(<argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>borderBox</name>.<name>Contains</name></name><argument_list>(<argument><expr><call><name><name>aVisibleRegion</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
      (!<name>aVisibleRegionBeforeMove</name> ||
       <call><name><name>borderBox</name>.<name>Contains</name></name><argument_list>(<argument><expr><call><name><name>aVisibleRegionBeforeMove</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>) &amp;&amp;
      !<call><name><name>nsLayoutUtils</name>::<name>HasNonZeroCorner</name></name><argument_list>(<argument><expr><name><name>outline</name>-&gt;<name>mOutlineRadius</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name><name>outline</name>-&gt;<name>mOutlineOffset</name></name> &gt;= 0</expr>)</condition><then> <block>{
      <comment type="line">// the visible region is entirely inside the border-rect, and the outline</comment>
      <comment type="line">// isn't rendered inside the border-rect, so the outline is not visible</comment>
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayCaret</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                      <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// Note: Because we exist, we know that the caret is visible, so we don't</comment>
  <comment type="line">// need to check for the caret's visibility.</comment>
  <expr_stmt><expr><call><name><name>mCaret</name>-&gt;<name>PaintCaret</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aCtx</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>, <argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayBorder</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                   <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                   <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aVisibleRegionBeforeMove</name></expr></argument>, <argument><expr>"not supported anymore"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name><name>nsDisplayItem</name>::<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aVisibleRegion</name></expr></argument>,
                                        <argument><expr><name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsRect</name></type> <name>paddingRect</name> <init>= <expr><call><name><name>mFrame</name>-&gt;<name>GetPaddingRect</name></name><argument_list>()</argument_list></call> - <call><name><name>mFrame</name>-&gt;<name>GetPosition</name></name><argument_list>()</argument_list></call> +
    <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleBorder</name> *</type><name>styleBorder</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>paddingRect</name>.<name>Contains</name></name><argument_list>(<argument><expr><call><name><name>aVisibleRegion</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
      (!<name>aVisibleRegionBeforeMove</name> ||
       <call><name><name>paddingRect</name>.<name>Contains</name></name><argument_list>(<argument><expr><call><name><name>aVisibleRegionBeforeMove</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>) &amp;&amp;
      !(<name>styleBorder</name> = <call><name><name>mFrame</name>-&gt;<name>GetStyleBorder</name></name><argument_list>()</argument_list></call>)-&gt;<call><name>IsBorderImageLoaded</name><argument_list>()</argument_list></call> &amp;&amp;
      !<call><name><name>nsLayoutUtils</name>::<name>HasNonZeroCorner</name></name><argument_list>(<argument><expr><name><name>styleBorder</name>-&gt;<name>mBorderRadius</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// the visible region is entirely inside the content rect, and no part</comment>
    <comment type="line">// of the border is rendered inside the content rect, so we are not</comment>
    <comment type="line">// visible</comment>
    <comment type="line">// Skip this if there's a border-image (which draws a background</comment>
    <comment type="line">// too) or if there is a border-radius (which makes the border draw</comment>
    <comment type="line">// further in).</comment>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayBorder</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                       <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>offset</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>PaintBorder</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>*<name>aCtx</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>,
                              <argument><expr><name>mVisibleRect</name></expr></argument>,
                              <argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetStyleContext</name></name><argument_list>()</argument_list></call></expr></argument>,
                              <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetSkipSides</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Given a region, compute a conservative approximation to it as a list</comment>
<comment type="line">// of rectangles that aren't vertically adjacent (i.e., vertically</comment>
<comment type="line">// adjacent or overlapping rectangles are combined).</comment>
<comment type="line">// Right now this is only approximate, some vertically overlapping rectangles</comment>
<comment type="line">// aren't guaranteed to be combined.</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ComputeDisjointRectangles</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRegion</name>&amp;</type> <name>aRegion</name></decl></param>,
                          <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsRect</name></expr></argument>&gt;</argument_list></name>*</type> <name>aRects</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nscoord</name></type> <name>accumulationMargin</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>CSSPixelsToAppUnits</name></name><argument_list>(<argument><expr>25</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>accumulated</name></decl>;</decl_stmt>
  <function_decl><type><name>nsRegionRectIterator</name></type> <name>iter</name><parameter_list>(<param><decl><type><name>aRegion</name></type></decl></param>)</parameter_list>;</function_decl>
  <while>while <condition>(<expr><name>PR_TRUE</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsRect</name>*</type> <name>r</name> <init>= <expr><call><name><name>iter</name>.<name>Next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>r</name> &amp;&amp; !<call><name><name>accumulated</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp;
        <call><name><name>accumulated</name>.<name>YMost</name></name><argument_list>()</argument_list></call> &gt;= <name><name>r</name>-&gt;<name>y</name></name> - <name>accumulationMargin</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>accumulated</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>accumulated</name></expr></argument>, <argument><expr>*<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name><name>accumulated</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aRects</name>-&gt;<name>AppendElement</name></name><argument_list>(<argument><expr><name>accumulated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>accumulated</name>.<name>Empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>r</name></expr>)</condition><then>
      <break>break;</break></then></if>

    <expr_stmt><expr><name>accumulated</name> = *<name>r</name></expr>;</expr_stmt>
  }</block></while>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayBoxShadowOuter</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                               <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>offset</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>borderRect</name> <init>= <expr><call><name>nsRect</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>nsRect</name></expr></argument>,<argument><expr>10</expr></argument>&gt;</argument_list></name></type> <name>rects</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ComputeDisjointRectangles</name><argument_list>(<argument><expr><name>mVisibleRegion</name></expr></argument>, <argument><expr>&amp;<name>rects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>rects</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name><name>aCtx</name>-&gt;<name>PushState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aCtx</name>-&gt;<name>SetClipRect</name></name><argument_list>(<argument><expr><name><name>rects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nsClipCombine_kIntersect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>PaintBoxShadowOuter</name></name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr>*<name>aCtx</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>,
                                        <argument><expr><name>borderRect</name></expr></argument>, <argument><expr><name><name>rects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aCtx</name>-&gt;<name>PopState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>nsRect</name></type>
<name><name>nsDisplayBoxShadowOuter</name>::<name>GetBounds</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
  <return>return <expr><call><name><name>mFrame</name>-&gt;<name>GetOverflowRect</name></name><argument_list>()</argument_list></call> + <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayBoxShadowOuter</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                           <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                           <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aVisibleRegionBeforeMove</name></expr></argument>, <argument><expr>"not supported anymore"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name><name>nsDisplayItem</name>::<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aVisibleRegion</name></expr></argument>,
                                        <argument><expr><name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <comment type="line">// Store the actual visible region</comment>
  <expr_stmt><expr><call><name><name>mVisibleRegion</name>.<name>And</name></name><argument_list>(<argument><expr>*<name>aVisibleRegion</name></expr></argument>, <argument><expr><name>mVisibleRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsPoint</name></type> <name>origin</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>visibleBounds</name> <init>= <expr><call><name><name>aVisibleRegion</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aVisibleRegionBeforeMove</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>visibleBounds</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>visibleBounds</name></expr></argument>, <argument><expr><call><name><name>aVisibleRegionBeforeMove</name>-&gt;<name>GetBounds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>frameRect</name><argument_list>(<argument><expr><name>origin</name></expr></argument>, <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>frameRect</name>.<name>Contains</name></name><argument_list>(<argument><expr><name>visibleBounds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <comment type="line">// the visible region is entirely inside the border-rect, and box shadows</comment>
  <comment type="line">// never render within the border-rect (unless there's a border radius).</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name><name>twipsRadii</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>hasBorderRadii</name> <init>=
     <expr><call><name><name>nsCSSRendering</name>::<name>GetBorderRadiusTwips</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>GetStyleBorder</name></name><argument_list>()</argument_list></call>-&gt;<name>mBorderRadius</name></expr></argument>,
                                          <argument><expr><name><name>frameRect</name>.<name>width</name></name></expr></argument>,
                                          <argument><expr><name>twipsRadii</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>hasBorderRadii</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <return>return <expr>!<call><name>RoundedRectContainsRect</name><argument_list>(<argument><expr><name>frameRect</name></expr></argument>, <argument><expr><name>twipsRadii</name></expr></argument>, <argument><expr><name>visibleBounds</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplayBoxShadowInner</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                               <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>offset</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>borderRect</name> <init>= <expr><call><name>nsRect</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name><name>mFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>nsRect</name></expr></argument>,<argument><expr>10</expr></argument>&gt;</argument_list></name></type> <name>rects</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ComputeDisjointRectangles</name><argument_list>(<argument><expr><name>mVisibleRegion</name></expr></argument>, <argument><expr>&amp;<name>rects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>rects</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <expr_stmt><expr><call><name><name>aCtx</name>-&gt;<name>PushState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aCtx</name>-&gt;<name>SetClipRect</name></name><argument_list>(<argument><expr><name><name>rects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nsClipCombine_kIntersect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>nsCSSRendering</name>::<name>PaintBoxShadowInner</name></name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr>*<name>aCtx</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>,
                                        <argument><expr><name>borderRect</name></expr></argument>, <argument><expr><name><name>rects</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aCtx</name>-&gt;<name>PopState</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayBoxShadowInner</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                           <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                           <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aVisibleRegionBeforeMove</name></expr></argument>, <argument><expr>"not supported anymore"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name><name>nsDisplayItem</name>::<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aVisibleRegion</name></expr></argument>,
                                        <argument><expr><name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <comment type="line">// Store the actual visible region</comment>
  <expr_stmt><expr><call><name><name>mVisibleRegion</name>.<name>And</name></name><argument_list>(<argument><expr>*<name>aVisibleRegion</name></expr></argument>, <argument><expr><name>mVisibleRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<constructor><name><name>nsDisplayWrapList</name>::<name>nsDisplayWrapList</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>)</parameter_list>
  <member_list>: <call><name>nsDisplayItem</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call> </member_list><block>{
  <expr_stmt><expr><call><name><name>mList</name>.<name>AppendToTop</name></name><argument_list>(<argument><expr><name>aList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<constructor><name><name>nsDisplayWrapList</name>::<name>nsDisplayWrapList</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list>
  <member_list>: <call><name>nsDisplayItem</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call> </member_list><block>{
  <expr_stmt><expr><call><name><name>mList</name>.<name>AppendToTop</name></name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>nsDisplayWrapList</name>::~<name>nsDisplayWrapList</name></name><parameter_list>()</parameter_list> <block>{
  <expr_stmt><expr><call><name><name>mList</name>.<name>DeleteAll</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>void</name></type>
<name><name>nsDisplayWrapList</name>::<name>HitTest</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>,
                           <param><decl><type><name>HitTestState</name>*</type> <name>aState</name></decl></param>, <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsIFrame</name>*</expr></argument>&gt;</argument_list></name> *</type><name>aOutFrames</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name><name>mList</name>.<name>HitTest</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aRect</name></expr></argument>, <argument><expr><name>aState</name></expr></argument>, <argument><expr><name>aOutFrames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsRect</name></type>
<name><name>nsDisplayWrapList</name>::<name>GetBounds</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
  <return>return <expr><call><name><name>mList</name>.<name>GetBounds</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayWrapList</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                     <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                     <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list> <block>{
  <return>return <expr><call><name><name>mList</name>.<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aVisibleRegion</name></expr></argument>, <argument><expr><name>aVisibleRegionBeforeMove</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayWrapList</name>::<name>IsOpaque</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// We could try to do something but let's conservatively just return PR_FALSE.</comment>
  <comment type="line">// We reimplement ComputeVisibility and that's what really matters</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplayWrapList</name>::<name>IsUniform</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nscolor</name>*</type> <name>aColor</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// We could try to do something but let's conservatively just return PR_FALSE.</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplayWrapList</name>::<name>IsVaryingRelativeToMovingFrame</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// The only existing consumer of IsVaryingRelativeToMovingFrame is</comment>
  <comment type="line">// nsLayoutUtils::ComputeRepaintRegionForCopy, which refrains from calling</comment>
  <comment type="line">// this on wrapped lists.</comment>
  <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"nsDisplayWrapList::IsVaryingRelativeToMovingFrame called unexpectedly"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// We could try to do something but let's conservatively just return PR_TRUE.</comment>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplayWrapList</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                              <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"nsDisplayWrapList should have been flattened away for painting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplayWrapList</name>::<name>ChildrenCanBeInactive</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                                <param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>,
                                                <param><decl><type><specifier>const</specifier> <name>nsDisplayList</name>&amp;</type> <name>aList</name></decl></param>,
                                                <param><decl><type><name>nsIFrame</name>*</type> <name>aActiveScrolledRoot</name></decl></param>)</parameter_list> <block>{
  <for>for (<init><decl><type><name>nsDisplayItem</name>*</type> <name>i</name> <init>= <expr><call><name><name>aList</name>.<name>GetBottom</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name> = <call><name><name>i</name>-&gt;<name>GetAbove</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><call><name><name>i</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>f</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>activeScrolledRoot</name> <init>=
        <expr><call><name><name>nsLayoutUtils</name>::<name>GetActiveScrolledRootFor</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>activeScrolledRoot</name> != <name>aActiveScrolledRoot</name></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>LayerState</name></type> <name>state</name> <init>= <expr><call><name><name>i</name>-&gt;<name>GetLayerState</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aManager</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>state</name> == <name>LAYER_ACTIVE</name></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>state</name> == <name>LAYER_NONE</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsDisplayList</name>*</type> <name>list</name> <init>= <expr><call><name><name>i</name>-&gt;<name>GetList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>list</name> &amp;&amp; !<call><name>ChildrenCanBeInactive</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aManager</name></expr></argument>, <argument><expr>*<name>list</name></expr></argument>, <argument><expr><name>aActiveScrolledRoot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>WrapDisplayList</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                <param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>, <param><decl><type><name>nsDisplayWrapper</name>*</type> <name>aWrapper</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr>!<call><name><name>aList</name>-&gt;<name>GetTop</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>aBuilder</name>-&gt;<name>HasMovingFrames</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>item</name> <init>= <expr><call><name><name>aWrapper</name>-&gt;<name>WrapList</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>item</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
  <comment type="line">// aList was emptied</comment>
  <expr_stmt><expr><call><name><name>aList</name>-&gt;<name>AppendToTop</name></name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>WrapEachDisplayItem</name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                    <param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>, <param><decl><type><name>nsDisplayWrapper</name>*</type> <name>aWrapper</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsDisplayList</name></type> <name>newList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsDisplayItem</name>*</type> <name>item</name></decl>;</decl_stmt>
  <while>while <condition>(<expr>(<name>item</name> = <call><name><name>aList</name>-&gt;<name>RemoveBottom</name></name><argument_list>()</argument_list></call>)</expr>)</condition> <block>{
    <expr_stmt><expr><name>item</name> = <call><name><name>aWrapper</name>-&gt;<name>WrapItem</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>item</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>newList</name>.<name>AppendToTop</name></name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <comment type="line">// aList was emptied</comment>
  <expr_stmt><expr><call><name><name>aList</name>-&gt;<name>AppendToTop</name></name><argument_list>(<argument><expr>&amp;<name>newList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsDisplayWrapper</name>::<name>WrapLists</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
    <param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aIn</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aOut</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>WrapListsInPlace</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>&amp;<name>aOut</name> == &amp;<name>aIn</name></expr>)</condition><then>
    <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name><name>aOut</name>.<name>BorderBackground</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name><name>aIn</name>.<name>BorderBackground</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aOut</name>.<name>BlockBorderBackgrounds</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name><name>aIn</name>.<name>BlockBorderBackgrounds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aOut</name>.<name>Floats</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name><name>aIn</name>.<name>Floats</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aOut</name>.<name>Content</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name><name>aIn</name>.<name>Content</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aOut</name>.<name>PositionedDescendants</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name><name>aIn</name>.<name>PositionedDescendants</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aOut</name>.<name>Outlines</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppendToTop</name><argument_list>(<argument><expr><call><name><name>aIn</name>.<name>Outlines</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsDisplayWrapper</name>::<name>WrapListsInPlace</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
    <param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsDisplayListSet</name>&amp;</type> <name>aLists</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>WrapBorderBackground</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Our border-backgrounds are in-flow</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>WrapDisplayList</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><call><name><name>aLists</name>.<name>BorderBackground</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <comment type="line">// Our block border-backgrounds are in-flow</comment>
  <expr_stmt><expr><name>rv</name> = <call><name>WrapDisplayList</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><call><name><name>aLists</name>.<name>BlockBorderBackgrounds</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// The floats are not in flow</comment>
  <expr_stmt><expr><name>rv</name> = <call><name>WrapEachDisplayItem</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><call><name><name>aLists</name>.<name>Floats</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Our child content is in flow</comment>
  <expr_stmt><expr><name>rv</name> = <call><name>WrapDisplayList</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>, <argument><expr><call><name><name>aLists</name>.<name>Content</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// The positioned descendants may not be in-flow</comment>
  <expr_stmt><expr><name>rv</name> = <call><name>WrapEachDisplayItem</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><call><name><name>aLists</name>.<name>PositionedDescendants</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// The outlines may not be in-flow</comment>
  <return>return <expr><call><name>WrapEachDisplayItem</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><call><name><name>aLists</name>.<name>Outlines</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<constructor><name><name>nsDisplayOpacity</name>::<name>nsDisplayOpacity</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>)</parameter_list>
    <member_list>: <call><name>nsDisplayWrapList</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aList</name></expr></argument>)</argument_list></call> </member_list><block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
<destructor><name><name>nsDisplayOpacity</name>::~<name>nsDisplayOpacity</name></name><parameter_list>()</parameter_list> <block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PRBool</name></type> <name><name>nsDisplayOpacity</name>::<name>IsOpaque</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// We are never opaque, if our opacity was &lt; 1 then we wouldn't have</comment>
  <comment type="line">// been created.</comment>
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<comment type="line">// nsDisplayOpacity uses layers for rendering</comment>
<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>Layer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>nsDisplayOpacity</name>::<name>BuildLayer</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                             <param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>Layer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>LayerBuilder</name></name><argument_list>()</argument_list></call>-&gt;
    <call><name>BuildContainerLayerFor</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aManager</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>mList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>layer</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name><name>layer</name>-&gt;<name>SetOpacity</name></name><argument_list>(<argument><expr><call><name><name>mFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call>-&gt;<name>mOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>nsDisplayItem</name>::<name>LayerState</name></name></type>
<name><name>nsDisplayOpacity</name>::<name>GetLayerState</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                <param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><call><name><name>mFrame</name>-&gt;<name>AreLayersMarkedActive</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>LAYER_ACTIVE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>activeScrolledRoot</name> <init>=
    <expr><call><name><name>nsLayoutUtils</name>::<name>GetActiveScrolledRootFor</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr>!<call><name>ChildrenCanBeInactive</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aManager</name></expr></argument>, <argument><expr><name>mList</name></expr></argument>, <argument><expr><name>activeScrolledRoot</name></expr></argument>)</argument_list></call>
      ? <name>LAYER_ACTIVE</name> : <name>LAYER_INACTIVE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplayOpacity</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                           <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                           <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aVisibleRegionBeforeMove</name></expr></argument>, <argument><expr>"not supported anymore"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Our children are translucent so we should not allow them to subtract</comment>
  <comment type="line">// area from aVisibleRegion. We do need to find out what is visible under</comment>
  <comment type="line">// our children in the temporary compositing buffer, because if our children</comment>
  <comment type="line">// paint our entire bounds opaquely then we don't need an alpha channel in</comment>
  <comment type="line">// the temporary compositing buffer.</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>bounds</name> <init>= <expr><call><name>GetBounds</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRegion</name></type> <name>visibleUnderChildren</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>visibleUnderChildren</name>.<name>And</name></name><argument_list>(<argument><expr>*<name>aVisibleRegion</name></expr></argument>, <argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsRegion</name></type> <name>visibleUnderChildrenBeforeMove</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aVisibleRegionBeforeMove</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>visibleUnderChildrenBeforeMove</name>.<name>And</name></name><argument_list>(<argument><expr>*<name>aVisibleRegionBeforeMove</name></expr></argument>, <argument><expr><name>bounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return
    <expr><call><name><name>nsDisplayWrapList</name>::<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr>&amp;<name>visibleUnderChildren</name></expr></argument>,
      <argument><expr><name>aVisibleRegionBeforeMove</name> ? &amp;<name>visibleUnderChildrenBeforeMove</name> : <name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplayOpacity</name>::<name>TryMerge</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><call><name><name>aItem</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> != <name>TYPE_OPACITY</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <comment type="line">// items for the same content element should be merged into a single</comment>
  <comment type="line">// compositing group</comment>
  <comment type="line">// aItem-&gt;GetUnderlyingFrame() returns non-null because it's nsDisplayOpacity</comment>
  <if>if <condition>(<expr><call><name><name>aItem</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetContent</name><argument_list>()</argument_list></call> != <call><name><name>mFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name><name>mList</name>.<name>AppendToBottom</name></name><argument_list>(<argument><expr>&amp;<call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDisplayOpacity</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call>-&gt;<name>mList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<constructor><name><name>nsDisplayOwnLayer</name>::<name>nsDisplayOwnLayer</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>)</parameter_list>
    <member_list>: <call><name>nsDisplayWrapList</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aList</name></expr></argument>)</argument_list></call> </member_list><block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayOwnLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
<destructor><name><name>nsDisplayOwnLayer</name>::~<name>nsDisplayOwnLayer</name></name><parameter_list>()</parameter_list> <block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayOwnLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// nsDisplayOpacity uses layers for rendering</comment>
<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>Layer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>nsDisplayOwnLayer</name>::<name>BuildLayer</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                              <param><decl><type><name>LayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>Layer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>LayerBuilder</name></name><argument_list>()</argument_list></call>-&gt;
    <call><name>BuildContainerLayerFor</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aManager</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>mList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<constructor><name><name>nsDisplayClip</name>::<name>nsDisplayClip</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aClippingFrame</name></decl></param>,
        <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list>
   <member_list>: <call><name>nsDisplayWrapList</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aItem</name></expr></argument>)</argument_list></call>,
     <call><name>mClippingFrame</name><argument_list>(<argument><expr><name>aClippingFrame</name></expr></argument>)</argument_list></call>, <call><name>mClip</name><argument_list>(<argument><expr><name>aRect</name></expr></argument>)</argument_list></call> </member_list><block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayClip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<constructor><name><name>nsDisplayClip</name>::<name>nsDisplayClip</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aClippingFrame</name></decl></param>,
        <param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list>
   <member_list>: <call><name>nsDisplayWrapList</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aList</name></expr></argument>)</argument_list></call>,
     <call><name>mClippingFrame</name><argument_list>(<argument><expr><name>aClippingFrame</name></expr></argument>)</argument_list></call>, <call><name>mClip</name><argument_list>(<argument><expr><name>aRect</name></expr></argument>)</argument_list></call> </member_list><block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplayClip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<function><type><name>nsRect</name></type> <name><name>nsDisplayClip</name>::<name>GetBounds</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsRect</name></type> <name>r</name> <init>= <expr><call><name><name>nsDisplayWrapList</name>::<name>GetBounds</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>r</name>.<name>IntersectRect</name></name><argument_list>(<argument><expr><name>mClip</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>r</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
<destructor><name><name>nsDisplayClip</name>::~<name>nsDisplayClip</name></name><parameter_list>()</parameter_list> <block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplayClip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name><name>nsDisplayClip</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                          <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"nsDisplayClip should have been flattened away for painting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplayClip</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                        <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                        <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aVisibleRegionBeforeMove</name></expr></argument>, <argument><expr>"not supported anymore"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsRegion</name></type> <name>clipped</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>clipped</name>.<name>And</name></name><argument_list>(<argument><expr>*<name>aVisibleRegion</name></expr></argument>, <argument><expr><name>mClip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsRegion</name></type> <name>clippedBeforeMove</name></decl>;</decl_stmt>

  <function_decl><type><name>nsRegion</name></type> <name>finalClipped</name><parameter_list>(<param><decl><type><name>clipped</name></type></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>nsRegion</name></type> <name>finalClippedBeforeMove</name><parameter_list>(<param><decl><type><name>clippedBeforeMove</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>anyVisible</name> <init>=
    <expr><call><name><name>nsDisplayWrapList</name>::<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr>&amp;<name>finalClipped</name></expr></argument>,
      <argument><expr><name>aVisibleRegionBeforeMove</name> ? &amp;<name>finalClippedBeforeMove</name> : <name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsRegion</name></type> <name>removed</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>removed</name>.<name>Sub</name></name><argument_list>(<argument><expr><name>clipped</name></expr></argument>, <argument><expr><name>finalClipped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aBuilder</name>-&gt;<name>SubtractFromVisibleRegion</name></name><argument_list>(<argument><expr><name>aVisibleRegion</name></expr></argument>, <argument><expr><name>removed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>anyVisible</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplayClip</name>::<name>TryMerge</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                               <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><call><name><name>aItem</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> != <name>TYPE_CLIP</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsDisplayClip</name>*</type> <name>other</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDisplayClip</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>other</name>-&gt;<name>mClip</name></name> != <name>mClip</name> || <name><name>other</name>-&gt;<name>mClippingFrame</name></name> != <name>mClippingFrame</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name><name>mList</name>.<name>AppendToBottom</name></name><argument_list>(<argument><expr>&amp;<name><name>other</name>-&gt;<name>mList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>nsDisplayWrapList</name>*</type> <name><name>nsDisplayClip</name>::<name>WrapWithClone</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                                <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list> <block>{
  <return>return <expr>new (<name>aBuilder</name>)
    <call><name>nsDisplayClip</name><argument_list>(<argument><expr><call><name><name>aItem</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mClippingFrame</name></expr></argument>, <argument><expr><name>aItem</name></expr></argument>, <argument><expr><name>mClip</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<comment type="line" format="doxygen">///////////////////////////////////////////////////</comment>
<comment type="line">// nsDisplayTransform Implementation</comment>
<comment type="line">//</comment>

<comment type="line">// Write #define UNIFIED_CONTINUATIONS here to have the transform property try</comment>
<comment type="line">// to transform content with continuations as one unified block instead of</comment>
<comment type="line">// several smaller ones.  This is currently disabled because it doesn't work</comment>
<comment type="line">// correctly, since when the frames are initially being reflowed, their</comment>
<comment type="line">// continuations all compute their bounding rects independently of each other</comment>
<comment type="line">// and consequently get the wrong value.  Write #define DEBUG_HIT here to have</comment>
<comment type="line">// the nsDisplayTransform class dump out a bunch of information about hit</comment>
<comment type="line">// detection.</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>UNIFIED_CONTINUATIONS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>DEBUG_HIT</name></cpp:undef>

<comment type="block">/* Returns the bounds of a frame as defined for transforms.  If
 * UNIFIED_CONTINUATIONS is not defined, this is simply the frame's bounding
 * rectangle, translated to the origin. Otherwise, returns the smallest
 * rectangle containing a frame and all of its continuations.  For example, if
 * there is a &lt;span&gt; element with several continuations split over several
 * lines, this function will return the rectangle containing all of those
 * continuations.  This rectangle is relative to the origin of the frame's local
 * coordinate space.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNIFIED_CONTINUATIONS</name></cpp:ifndef>

<function><type><name>nsRect</name></type>
<name><name>nsDisplayTransform</name>::<name>GetFrameBoundsForTransform</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>"Can't get the bounds of a nonexistent frame!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>nsRect</name><argument_list>(<argument><expr><call><name>nsPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>aFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><name>nsRect</name></type>
<name><name>nsDisplayTransform</name>::<name>GetFrameBoundsForTransform</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>"Can't get the bounds of a nonexistent frame!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsRect</name></type> <name>result</name></decl>;</decl_stmt>
  
  <comment type="block">/* Iterate through the continuation list, unioning together all the
   * bounding rects.
   */</comment>
  <for>for (<init><decl><type><specifier>const</specifier> <name>nsIFrame</name> *</type><name>currFrame</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetFirstContinuation</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
       <condition><expr><name>currFrame</name> != <name>nsnull</name></expr>;</condition>
       <incr><expr><name>currFrame</name> = <call><name><name>currFrame</name>-&gt;<name>GetNextContinuation</name></name><argument_list>()</argument_list></call></expr></incr>)
    <block>{
      <comment type="block">/* Get the frame rect in local coordinates, then translate back to the
       * original coordinates.
       */</comment>
      <expr_stmt><expr><call><name><name>result</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>nsRect</name><argument_list>(<argument><expr><call><name><name>currFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name><name>currFrame</name>-&gt;<name>GetSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Returns the delta specified by the -moz-transform-origin property.
 * This is a positive delta, meaning that it indicates the direction to move
 * to get from (0, 0) of the frame to the transform origin.
 */</comment>
<function><type><specifier>static</specifier>
<name>gfxPoint</name></type> <name>GetDeltaToMozTransformOrigin</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                      <param><decl><type><name>float</name></type> <name>aFactor</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>nsRect</name>*</type> <name>aBoundsOverride</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>"Can't get delta for a null frame!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><call><name><name>aFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call>-&gt;<call><name>HasTransform</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"Can't get a delta for an untransformed frame!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* For both of the coordinates, if the value of -moz-transform is a
   * percentage, it's relative to the size of the frame.  Otherwise, if it's
   * a distance, it's already computed for us!
   */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>display</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>boundingRect</name> <init>= <expr>(<name>aBoundsOverride</name> ? *<name>aBoundsOverride</name> :
                         <call><name><name>nsDisplayTransform</name>::<name>GetFrameBoundsForTransform</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Allows us to access named variables by index. */</comment>
  <decl_stmt><decl><type><name>gfxPoint</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>gfxFloat</name>*</type> <name><name>coords</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{<expr>&amp;<name><name>result</name>.<name>x</name></name></expr>, <expr>&amp;<name><name>result</name>.<name>y</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nscoord</name>*</type> <name><name>dimensions</name><index>[<expr>2</expr>]</index></name> <init>=
    <expr><block>{<expr>&amp;<name><name>boundingRect</name>.<name>width</name></name></expr>, <expr>&amp;<name><name>boundingRect</name>.<name>height</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

  <for>for (<init><decl><type><name>PRUint8</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>index</name> &lt; 2</expr>;</condition> <incr><expr>++<name>index</name></expr></incr>) <block>{
    <comment type="block">/* If the -moz-transform-origin specifies a percentage, take the percentage
     * of the size of the box.
     */</comment>
    <if>if <condition>(<expr><name><name>display</name>-&gt;<name>mTransformOrigin</name><index>[<expr><name>index</name></expr>]</index></name>.<call><name>GetUnit</name><argument_list>()</argument_list></call> == <name>eStyleUnit_Percent</name></expr>)</condition><then>
      <expr_stmt><expr>*<name><name>coords</name><index>[<expr><name>index</name></expr>]</index></name> = <call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr>*<name><name>dimensions</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>aFactor</name></expr></argument>)</argument_list></call> *
        <name><name>display</name>-&gt;<name>mTransformOrigin</name><index>[<expr><name>index</name></expr>]</index></name>.<call><name>GetPercentValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
    
    <comment type="block">/* Otherwise, it's a length. */</comment>
    <else>else
      <expr_stmt><expr>*<name><name>coords</name><index>[<expr><name>index</name></expr>]</index></name> =
        <call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>display</name>-&gt;
                                <name>mTransformOrigin</name><index>[<expr><name>index</name></expr>]</index></name>.<call><name>GetCoordValue</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><name>aFactor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  }</block></for>
  
  <comment type="block">/* Adjust based on the origin of the rectangle. */</comment>
  <expr_stmt><expr><name><name>result</name>.<name>x</name></name> += <call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>boundingRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name>aFactor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>result</name>.<name>y</name></name> += <call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>boundingRect</name>.<name>y</name></name></expr></argument>, <argument><expr><name>aFactor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Wraps up the -moz-transform matrix in a change-of-basis matrix pair that
 * translates from local coordinate space to transform coordinate space, then
 * hands it back.
 */</comment>
<function><type><name>gfxMatrix</name></type>
<name><name>nsDisplayTransform</name>::<name>GetResultingTransformMatrix</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                                <param><decl><type><specifier>const</specifier> <name>nsPoint</name> &amp;</type><name>aOrigin</name></decl></param>,
                                                <param><decl><type><name>float</name></type> <name>aFactor</name></decl></param>,
                                                <param><decl><type><specifier>const</specifier> <name>nsRect</name>*</type> <name>aBoundsOverride</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>"Cannot get transform matrix for a null frame!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><call><name><name>aFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call>-&gt;<call><name>HasTransform</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"Cannot get transform matrix if frame isn't transformed!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Account for the -moz-transform-origin property by translating the
   * coordinate space to the new origin.
   */</comment>
  <decl_stmt><decl><type><name>gfxPoint</name></type> <name>toMozOrigin</name> <init>= <expr><call><name>GetDeltaToMozTransformOrigin</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aFactor</name></expr></argument>, <argument><expr><name>aBoundsOverride</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>gfxPoint</name></type> <name>newOrigin</name> <init>= <expr><call><name>gfxPoint</name><argument_list>(<argument><expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>aOrigin</name>.<name>x</name></name></expr></argument>, <argument><expr><name>aFactor</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>aOrigin</name>.<name>y</name></name></expr></argument>, <argument><expr><name>aFactor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get the underlying transform matrix.  This requires us to get the
   * bounds of the frame.
   */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>disp</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>bounds</name> <init>= <expr>(<name>aBoundsOverride</name> ? *<name>aBoundsOverride</name> :
                   <call><name><name>nsDisplayTransform</name>::<name>GetFrameBoundsForTransform</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get the matrix, then change its basis to factor in the origin. */</comment>
  <return>return <expr><call><name><name>nsLayoutUtils</name>::<name>ChangeMatrixBasis</name></name>
    <argument_list>(<argument><expr><name>newOrigin</name> + <name>toMozOrigin</name></expr></argument>, <argument><expr><call><name><name>disp</name>-&gt;<name>mTransform</name>.<name>GetThebesMatrix</name></name><argument_list>(<argument><expr><name>bounds</name></expr></argument>, <argument><expr><name>aFactor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Painting applies the transform, paints the sublist, then unapplies
 * the transform.
 */</comment>
<function><type><name>void</name></type> <name><name>nsDisplayTransform</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>,
                               <param><decl><type><name>nsIRenderingContext</name> *</type><name>aCtx</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Get the local transform matrix with which we'll transform all wrapped
   * elements.  If this matrix is singular, we shouldn't display anything
   * and can abort.
   */</comment>
  <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>newTransformMatrix</name> <init>=
    <expr><call><name>GetResultingTransformMatrix</name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>, <argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name><name>mFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call>-&gt;<call><name>AppUnitsPerDevPixel</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>newTransformMatrix</name>.<name>IsSingular</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="block">/* Get the context and automatically save and restore it. */</comment>
  <decl_stmt><decl><type><name>gfxContext</name>*</type> <name>gfx</name> <init>= <expr><call><name><name>aCtx</name>-&gt;<name>ThebesContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>gfxContextAutoSaveRestore</name></type> <name>autoRestorer</name><parameter_list>(<param><decl><type><name>gfx</name></type></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* Get the new CTM by applying this transform after all of the
   * transforms preceding it.
   */</comment>
  <expr_stmt><expr><call><name><name>newTransformMatrix</name>.<name>Multiply</name></name><argument_list>(<argument><expr><call><name><name>gfx</name>-&gt;<name>CurrentMatrix</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the matrix for the transform based on the old matrix and the new
   * transform data.
   */</comment>
  <expr_stmt><expr><call><name><name>gfx</name>-&gt;<name>SetMatrix</name></name><argument_list>(<argument><expr><name>newTransformMatrix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now, send the paint call down.
   */</comment>    
  <expr_stmt><expr><call><name><name>mStoredList</name>.<name>GetList</name></name><argument_list>()</argument_list></call>-&gt;
      <call><name>PaintForFrame</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aCtx</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>, <argument><expr><name><name>nsDisplayList</name>::<name>PAINT_DEFAULT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The AutoSaveRestore object will clean things up. */</comment>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplayTransform</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>,
                                             <param><decl><type><name>nsRegion</name> *</type><name>aVisibleRegion</name></decl></param>,
                                             <param><decl><type><name>nsRegion</name> *</type><name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aVisibleRegionBeforeMove</name></expr></argument>, <argument><expr>"not supported anymore"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* As we do this, we need to be sure to
   * untransform the visible rect, since we want everything that's painting to
   * think that it's painting in its original rectangular coordinate space. */</comment>
  <decl_stmt><decl><type><name>nsRegion</name></type> <name>untransformedVisible</name> <init>=
    <expr><call><name>UntransformRect</name><argument_list>(<argument><expr><name>mVisibleRect</name></expr></argument>, <argument><expr><name>mFrame</name></expr></argument>, <argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsRegion</name></type> <name>untransformedVisibleBeforeMove</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>aVisibleRegionBeforeMove</name></expr>)</condition><then> <block>{
    <comment type="line">// mVisibleRect contains areas visible before and after the move, so it's</comment>
    <comment type="line">// OK (although conservative) to just use the same regions here.</comment>
    <expr_stmt><expr><name>untransformedVisibleBeforeMove</name> = <name>untransformedVisible</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>mStoredList</name>.<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr>&amp;<name>untransformedVisible</name></expr></argument>,
                                <argument><expr><name>aVisibleRegionBeforeMove</name>
                                  ? &amp;<name>untransformedVisibleBeforeMove</name>
                                  : <name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_HIT</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* HitTest does some fun stuff with matrix transforms to obtain the answer. */</comment>
<function><type><name>void</name></type> <name><name>nsDisplayTransform</name>::<name>HitTest</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>,
                                 <param><decl><type><name>HitTestState</name> *</type><name>aState</name></decl></param>,
                                 <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsIFrame</name>*</expr></argument>&gt;</argument_list></name> *</type><name>aOutFrames</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Here's how this works:
   * 1. Get the matrix.  If it's singular, abort (clearly we didn't hit
   *    anything).
   * 2. Invert the matrix.
   * 3. Use it to transform the rect into the correct space.
   * 4. Pass that rect down through to the list's version of HitTest.
   */</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>factor</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>matrix</name> <init>=
    <expr><call><name>GetResultingTransformMatrix</name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>, <argument><expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>factor</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>matrix</name>.<name>IsSingular</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="block">/* We want to go from transformed-space to regular space.
   * Thus we have to invert the matrix, which normally does
   * the reverse operation (e.g. regular-&gt;transformed)
   */</comment>
  <expr_stmt><expr><call><name><name>matrix</name>.<name>Invert</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now, apply the transform and pass it down the channel. */</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>resultingRect</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>aRect</name>.<name>width</name></name> == 1 &amp;&amp; <name><name>aRect</name>.<name>height</name></name> == 1</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>gfxPoint</name></type> <name>point</name> <init>= <expr><call><name><name>matrix</name>.<name>Transform</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>y</name></name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>resultingRect</name> = <call><name>nsRect</name><argument_list>(<argument><expr><call><name>NSFloatPixelsToAppUnits</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><name><name>point</name>.<name>x</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>NSFloatPixelsToAppUnits</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><name><name>point</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>gfxRect</name></type> <name>originalRect</name><argument_list>(<argument><expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>y</name></name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>width</name></name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>NSAppUnitsToFloatPixels</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>height</name></name></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>gfxRect</name></type> <name>rect</name> <init>= <expr><call><name><name>matrix</name>.<name>TransformBounds</name></name><argument_list>(<argument><expr><name>originalRect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>resultingRect</name> = <call><name>nsRect</name><argument_list>(<argument><expr><call><name>NSFloatPixelsToAppUnits</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name><name>rect</name>.<name>X</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>NSFloatPixelsToAppUnits</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name><name>rect</name>.<name>Y</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>NSFloatPixelsToAppUnits</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name><name>rect</name>.<name>Width</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>NSFloatPixelsToAppUnits</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name><name>rect</name>.<name>Height</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_HIT</name></cpp:ifdef>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Frame: %p\n"</expr></argument>, <argument><expr><call><name><name>dynamic_cast</name><argument_list>&lt;<argument><expr><name>void</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  Untransformed point: (%f, %f)\n"</expr></argument>, <argument><expr><call><name><name>resultingRect</name>.<name>X</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>resultingRect</name>.<name>Y</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>originalFrameCount</name> <init>= <expr><call><name><name>aOutFrames</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name><name>mStoredList</name>.<name>HitTest</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>resultingRect</name></expr></argument>, <argument><expr><name>aState</name></expr></argument>, <argument><expr><name>aOutFrames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_HIT</name></cpp:ifdef>
  <if>if <condition>(<expr><name>originalFrameCount</name> != <call><name><name>aOutFrames</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  Hit! Time: %f, first frame: %p\n"</expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>clock</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name><name>dynamic_cast</name><argument_list>&lt;<argument><expr><name>void</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>aOutFrames</name>.<name>ElementAt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"=== end of hit test ===\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></function>

<comment type="block">/* The bounding rectangle for the object is the overflow rectangle translated
 * by the reference point.
 */</comment>
<function><type><name>nsRect</name></type> <name><name>nsDisplayTransform</name>::<name>GetBounds</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mFrame</name>-&gt;<name>GetOverflowRect</name></name><argument_list>()</argument_list></call> + <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mFrame</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* The transform is opaque iff the transform consists solely of scales and
 * transforms and if the underlying content is opaque.  Thus if the transform
 * is of the form
 *
 * |a c e|
 * |b d f|
 * |0 0 1|
 *
 * We need b and c to be zero.
 */</comment>
<function><type><name>PRBool</name></type> <name><name>nsDisplayTransform</name>::<name>IsOpaque</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>disp</name> <init>= <expr><call><name><name>mFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>disp</name>-&gt;<name>mTransform</name>.<name>GetMainMatrixEntry</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call> == 0.0f &amp;&amp;
    <call><name><name>disp</name>-&gt;<name>mTransform</name>.<name>GetMainMatrixEntry</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call> == 0.0f &amp;&amp;
    <call><name><name>mStoredList</name>.<name>IsOpaque</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* The transform is uniform if it fills the entire bounding rect and the
 * wrapped list is uniform.  See IsOpaque for discussion of why this
 * works.
 */</comment>
<function><type><name>PRBool</name></type> <name><name>nsDisplayTransform</name>::<name>IsUniform</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>, <param><decl><type><name>nscolor</name>*</type> <name>aColor</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>disp</name> <init>= <expr><call><name><name>mFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>disp</name>-&gt;<name>mTransform</name>.<name>GetMainMatrixEntry</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call> == 0.0f &amp;&amp;
    <call><name><name>disp</name>-&gt;<name>mTransform</name>.<name>GetMainMatrixEntry</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call> == 0.0f &amp;&amp;
    <call><name><name>mStoredList</name>.<name>IsUniform</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aColor</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* If UNIFIED_CONTINUATIONS is defined, we can merge two display lists that
 * share the same underlying content.  Otherwise, doing so results in graphical
 * glitches.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNIFIED_CONTINUATIONS</name></cpp:ifndef>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayTransform</name>::<name>TryMerge</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>,
                             <param><decl><type><name>nsDisplayItem</name> *</type><name>aItem</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><name>PRBool</name></type>
<name><name>nsDisplayTransform</name>::<name>TryMerge</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name> *</type><name>aBuilder</name></decl></param>,
                             <param><decl><type><name>nsDisplayItem</name> *</type><name>aItem</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aItem</name></expr></argument>, <argument><expr>"Why did you try merging with a null item?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr>"Why did you try merging with a null builder?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure that we're dealing with two transforms. */</comment>
  <if>if <condition>(<expr><call><name><name>aItem</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> != <name>TYPE_TRANSFORM</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <comment type="block">/* Check to see that both frames are part of the same content. */</comment>
  <if>if <condition>(<expr><call><name><name>aItem</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetContent</name><argument_list>()</argument_list></call> != <call><name><name>mFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <comment type="block">/* Now, move everything over to this frame and signal that
   * we merged things!
   */</comment>
  <expr_stmt><expr><call><name><name>mStoredList</name>.<name>GetList</name></name><argument_list>()</argument_list></call>-&gt;
    <call><name>AppendToBottom</name><argument_list>(<argument><expr>&amp;<call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDisplayTransform</name> *</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call>-&gt;<name>mStoredList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* TransformRect takes in as parameters a rectangle (in app space) and returns
 * the smallest rectangle (in app space) containing the transformed image of
 * that rectangle.  That is, it takes the four corners of the rectangle,
 * transforms them according to the matrix associated with the specified frame,
 * then returns the smallest rectangle containing the four transformed points.
 *
 * @param aUntransformedBounds The rectangle (in app units) to transform.
 * @param aFrame The frame whose transformation should be applied.
 * @param aOrigin The delta from the frame origin to the coordinate space origin
 * @param aBoundsOverride (optional) Force the frame bounds to be the
 *        specified bounds.
 * @return The smallest rectangle containing the image of the transformed
 *         rectangle.
 */</comment>
<function><type><name>nsRect</name></type> <name><name>nsDisplayTransform</name>::<name>TransformRect</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name> &amp;</type><name>aUntransformedBounds</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>nsPoint</name> &amp;</type><name>aOrigin</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>nsRect</name>*</type> <name>aBoundsOverride</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>"Can't take the transform based on a null frame!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><call><name><name>aFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call>-&gt;<call><name>HasTransform</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"Cannot transform a rectangle if there's no transformation!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>float</name></type> <name>factor</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>nsLayoutUtils</name>::<name>MatrixTransformRect</name></name>
    <argument_list>(<argument><expr><name>aUntransformedBounds</name></expr></argument>,
     <argument><expr><call><name>GetResultingTransformMatrix</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aOrigin</name></expr></argument>, <argument><expr><name>factor</name></expr></argument>, <argument><expr><name>aBoundsOverride</name></expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsRect</name></type> <name><name>nsDisplayTransform</name>::<name>UntransformRect</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name> &amp;</type><name>aUntransformedBounds</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>nsPoint</name> &amp;</type><name>aOrigin</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>"Can't take the transform based on a null frame!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><call><name><name>aFrame</name>-&gt;<name>GetStyleDisplay</name></name><argument_list>()</argument_list></call>-&gt;<call><name>HasTransform</name><argument_list>()</argument_list></call></expr></argument>,
                  <argument><expr>"Cannot transform a rectangle if there's no transformation!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Grab the matrix.  If the transform is degenerate, just hand back the
   * empty rect.
   */</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>factor</name> <init>= <expr><call><name><name>nsPresContext</name>::<name>AppUnitsPerCSSPixel</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>matrix</name> <init>= <expr><call><name>GetResultingTransformMatrix</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aOrigin</name></expr></argument>, <argument><expr><name>factor</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>matrix</name>.<name>IsSingular</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>nsRect</name><argument_list>()</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* We want to untransform the matrix, so invert the transformation first! */</comment>
  <expr_stmt><expr><call><name><name>matrix</name>.<name>Invert</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>nsLayoutUtils</name>::<name>MatrixTransformRect</name></name><argument_list>(<argument><expr><name>aUntransformedBounds</name></expr></argument>, <argument><expr><name>matrix</name></expr></argument>,
                                            <argument><expr><name>factor</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_SVG</name></cpp:ifdef>
<constructor><name><name>nsDisplaySVGEffects</name>::<name>nsDisplaySVGEffects</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsDisplayList</name>*</type> <name>aList</name></decl></param>)</parameter_list>
    <member_list>: <call><name>nsDisplayWrapList</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr><name>aList</name></expr></argument>)</argument_list></call>, <call><name>mEffectsFrame</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call>,
      <call><name>mBounds</name><argument_list>(<argument><expr><call><name><name>aFrame</name>-&gt;<name>GetOverflowRectRelativeToSelf</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>nsDisplaySVGEffects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_BUILD_REFCNT_LOGGING</name></cpp:ifdef>
<destructor><name><name>nsDisplaySVGEffects</name>::~<name>nsDisplaySVGEffects</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>nsDisplaySVGEffects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PRBool</name></type> <name><name>nsDisplaySVGEffects</name>::<name>IsOpaque</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsDisplaySVGEffects</name>::<name>HitTest</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aRect</name></decl></param>,
                             <param><decl><type><name>HitTestState</name>*</type> <name>aState</name></decl></param>, <param><decl><type><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>nsIFrame</name>*</expr></argument>&gt;</argument_list></name> *</type><name>aOutFrames</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsPoint</name></type> <name>rectCenter</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>x</name></name> + <name><name>aRect</name>.<name>width</name></name> / 2</expr></argument>, <argument><expr><name><name>aRect</name>.<name>y</name></name> + <name><name>aRect</name>.<name>height</name></name> / 2</expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>nsSVGIntegrationUtils</name>::<name>HitTestFrameForEffects</name></name><argument_list>(<argument><expr><name>mEffectsFrame</name></expr></argument>,
      <argument><expr><name>rectCenter</name> - <call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mEffectsFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mList</name>.<name>HitTest</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr><name>aRect</name></expr></argument>, <argument><expr><name>aState</name></expr></argument>, <argument><expr><name>aOutFrames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name><name>nsDisplaySVGEffects</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                <param><decl><type><name>nsIRenderingContext</name>*</type> <name>aCtx</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>nsSVGIntegrationUtils</name>::<name>PaintFramesWithEffects</name></name><argument_list>(<argument><expr><name>aCtx</name></expr></argument>,
          <argument><expr><name>mEffectsFrame</name></expr></argument>, <argument><expr><name>mVisibleRect</name></expr></argument>, <argument><expr><name>aBuilder</name></expr></argument>, <argument><expr>&amp;<name>mList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplaySVGEffects</name>::<name>ComputeVisibility</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>,
                                              <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegion</name></decl></param>,
                                              <param><decl><type><name>nsRegion</name>*</type> <name>aVisibleRegionBeforeMove</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aVisibleRegionBeforeMove</name></expr></argument>, <argument><expr>"not supported anymore"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsPoint</name></type> <name>offset</name> <init>= <expr><call><name><name>aBuilder</name>-&gt;<name>ToReferenceFrame</name></name><argument_list>(<argument><expr><name>mEffectsFrame</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>dirtyRect</name> <init>=
    <expr><call><name><name>nsSVGIntegrationUtils</name>::<name>GetRequiredSourceForInvalidArea</name></name><argument_list>(<argument><expr><name>mEffectsFrame</name></expr></argument>,
                                                           <argument><expr><name>mVisibleRect</name> - <name>offset</name></expr></argument>)</argument_list></call> +
    <name>offset</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Our children may be made translucent or arbitrarily deformed so we should</comment>
  <comment type="line">// not allow them to subtract area from aVisibleRegion.</comment>
  <function_decl><type><name>nsRegion</name></type> <name>childrenVisible</name><parameter_list>(<param><decl><type><name>dirtyRect</name></type></decl></param>)</parameter_list>;</function_decl>
  <comment type="line">// mVisibleRect contains areas visible before and after the move, so it's</comment>
  <comment type="line">// OK (although conservative) to just use the same regions here.</comment>
  <function_decl><type><name>nsRegion</name></type> <name>childrenVisibleBeforeMove</name><parameter_list>(<param><decl><type><name>dirtyRect</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>nsDisplayWrapList</name>::<name>ComputeVisibility</name></name><argument_list>(<argument><expr><name>aBuilder</name></expr></argument>, <argument><expr>&amp;<name>childrenVisible</name></expr></argument>,
    <argument><expr><name>aVisibleRegionBeforeMove</name> ? &amp;<name>childrenVisibleBeforeMove</name> : <name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsDisplaySVGEffects</name>::<name>TryMerge</name></name><parameter_list>(<param><decl><type><name>nsDisplayListBuilder</name>*</type> <name>aBuilder</name></decl></param>, <param><decl><type><name>nsDisplayItem</name>*</type> <name>aItem</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>aItem</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call> != <name>TYPE_SVG_EFFECTS</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <comment type="line">// items for the same content element should be merged into a single</comment>
  <comment type="line">// compositing group</comment>
  <comment type="line">// aItem-&gt;GetUnderlyingFrame() returns non-null because it's nsDisplaySVGEffects</comment>
  <if>if <condition>(<expr><call><name><name>aItem</name>-&gt;<name>GetUnderlyingFrame</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetContent</name><argument_list>()</argument_list></call> != <call><name><name>mFrame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>nsDisplaySVGEffects</name>*</type> <name>other</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsDisplaySVGEffects</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aItem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>mList</name>.<name>AppendToBottom</name></name><argument_list>(<argument><expr>&amp;<name><name>other</name>-&gt;<name>mList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mBounds</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>mBounds</name></expr></argument>,
    <argument><expr><name><name>other</name>-&gt;<name>mBounds</name></name> + <call><name><name>other</name>-&gt;<name>mEffectsFrame</name>-&gt;<name>GetOffsetTo</name></name><argument_list>(<argument><expr><name>mEffectsFrame</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
