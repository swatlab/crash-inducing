<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0016ce036cd125dd870737d9eb371cfeab618324.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</comment>
<comment type="block">/* vim:set expandtab ts=4 sw=4 sts=4 cin: */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications.
 * Portions created by the Initial Developer are Copyright (C) 2001
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Darin Fisher &lt;darin@meer.net&gt; (original author)
 *   Christian Biesinger &lt;cbiesinger@web.de&gt;
 *   Google Inc.
 *   Jan Wrobel &lt;wrobel@blues.ath.cx&gt;
 *   Jan Odvarko &lt;odvarko@gmail.com&gt;
 *   Dave Camp &lt;dcamp@mozilla.com&gt;
 *   Honza Bambas &lt;honzab@firemni.cz&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHttpChannel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHttpTransaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHttpConnection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHttpHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHttpAuthCache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHttpResponseHead.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHttp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIHttpAuthenticator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIApplicationCacheService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIApplicationCacheContainer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAuthInformation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAuthPrompt2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAuthPromptProvider.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIStringBundle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXPCOM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISupportsPrimitives.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIURL.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIIDNService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIStreamListenerTee.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISeekableStream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsMimeTypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNetUtil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPrintfCString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsReadableUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsUnicharUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plstr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsEscape.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICookieService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIResumableChannel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsInt64.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIVariant.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsChannelProperties.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStreamUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIOService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAuthInformationHolder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICacheService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDNSPrefetch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsChannelClassifier.h"</cpp:file></cpp:include>

<comment type="line">// True if the local cache should be bypassed when processing a request.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYPASS_LOCAL_CACHE</name><parameter_list>(<param><type><name>loadFlags</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>(loadFlags &amp; (nsIRequest::LOAD_BYPASS_CACHE | \
                      nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE))</cpp:value></cpp:define>

<expr_stmt><expr>static <call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>kStreamListenerTeeCID</name></expr></argument>, <argument><expr><name>NS_STREAMLISTENERTEE_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel &lt;public&gt;</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<constructor><name><name>nsHttpChannel</name>::<name>nsHttpChannel</name></name><parameter_list>()</parameter_list>
    <member_list>: <call><name>mResponseHead</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    , <call><name>mTransaction</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    , <call><name>mConnectionInfo</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    , <call><name>mLoadFlags</name><argument_list>(<argument><expr><name>LOAD_NORMAL</name></expr></argument>)</argument_list></call>
    , <call><name>mStatus</name><argument_list>(<argument><expr><name>NS_OK</name></expr></argument>)</argument_list></call>
    , <call><name>mLogicalOffset</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
    , <call><name>mCaps</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
    , <call><name>mPriority</name><argument_list>(<argument><expr><name>PRIORITY_NORMAL</name></expr></argument>)</argument_list></call>
    , <call><name>mCachedResponseHead</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    , <call><name>mCacheAccess</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
    , <call><name>mPostID</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
    , <call><name>mRequestTime</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
    , <call><name>mProxyAuthContinuationState</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    , <call><name>mAuthContinuationState</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    , <call><name>mStartPos</name><argument_list>(<argument><expr><name>LL_MAXUINT</name></expr></argument>)</argument_list></call>
    , <call><name>mPendingAsyncCallOnResume</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
    , <call><name>mSuspendCount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
    , <call><name>mRedirectionLimit</name><argument_list>(<argument><expr><call><name><name>gHttpHandler</name>-&gt;<name>RedirectionLimit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
    , <call><name>mIsPending</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mWasOpened</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mApplyConversion</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>
    , <call><name>mAllowPipelining</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>
    , <call><name>mCachedContentIsValid</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mCachedContentIsPartial</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mResponseHeadersModified</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mCanceled</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mTransactionReplaced</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mUploadStreamHasHeaders</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mAuthRetryPending</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mProxyAuth</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mTriedProxyAuth</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mTriedHostAuth</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mSuppressDefensiveAuth</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mResuming</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mInitedCacheEntry</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mCacheForOfflineUse</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mCachingOpportunistically</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mFallbackChannel</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mInheritApplicationCache</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>
    , <call><name>mChooseApplicationCache</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mLoadedFromApplicationCache</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mTracingEnabled</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>
    , <call><name>mForceAllowThirdPartyCookie</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
    , <call><name>mCustomConditionalRequest</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
</member_list><block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Creating nsHttpChannel [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// grab a reference to the handler to ensure that it doesn't go away.</comment>
    <decl_stmt><decl><type><name>nsHttpHandler</name> *</type><name>handler</name> <init>= <expr><name>gHttpHandler</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>nsHttpChannel</name>::~<name>nsHttpChannel</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Destroying nsHttpChannel [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mConnectionInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mTransaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mProxyAuthContinuationState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mAuthContinuationState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr>delete <name>mResponseHead</name></expr>;</expr_stmt>
    <expr_stmt><expr>delete <name>mCachedResponseHead</name></expr>;</expr_stmt>

    <comment type="line">// release our reference to the handler</comment>
    <decl_stmt><decl><type><name>nsHttpHandler</name> *</type><name>handler</name> <init>= <expr><name>gHttpHandler</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>Init</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> *</type><name>uri</name></decl></param>,
                    <param><decl><type><name>PRUint8</name></type> <name>caps</name></decl></param>,
                    <param><decl><type><name>nsProxyInfo</name> *</type><name>proxyInfo</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::Init [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"null uri"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>nsHashPropertyBag</name>::<name>Init</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mURI</name> = <name>uri</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mOriginalURI</name> = <name>uri</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mDocumentURI</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCaps</name> = <name>caps</name></expr>;</expr_stmt>

    <comment type="line">//</comment>
    <comment type="line">// Construct connection info object</comment>
    <comment type="line">//</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>host</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>port</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>usingSSL</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>SchemeIs</name></name><argument_list>(<argument><expr>"https"</expr></argument>, <argument><expr>&amp;<name>usingSSL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetAsciiHost</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// reject the URL if it doesn't specify a host</comment>
    <if>if <condition>(<expr><call><name><name>host</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_MALFORMED_URI</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetPort</name></name><argument_list>(<argument><expr>&amp;<name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("host=%s port=%d\n", <call><name><name>host</name>.<name>get</name></name><argument_list>()</argument_list></call>, <name>port</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetAsciiSpec</name></name><argument_list>(<argument><expr><name>mSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("uri=%s\n", <call><name><name>mSpec</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mConnectionInfo</name> = new <call><name>nsHttpConnectionInfo</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>,
                                               <argument><expr><name>proxyInfo</name></expr></argument>, <argument><expr><name>usingSSL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mConnectionInfo</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>mConnectionInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Set default request method</comment>
    <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetMethod</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Get</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//</comment>
    <comment type="line">// Set request headers</comment>
    <comment type="line">//</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>hostLine</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>nsHttpHandler</name>::<name>GenerateHostPort</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>hostLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Host</name></name></expr></argument>, <argument><expr><name>hostLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;
        <name>AddStandardRequestHeaders</name></name><argument_list>(<argument><expr>&amp;<call><name><name>mRequestHead</name>.<name>Headers</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>caps</name></expr></argument>,
                                  <argument><expr>!<call><name><name>mConnectionInfo</name>-&gt;<name>UsingSSL</name></name><argument_list>()</argument_list></call> &amp;&amp;
                                  <call><name><name>mConnectionInfo</name>-&gt;<name>UsingHttpProxy</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel &lt;private&gt;</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>AsyncCall</name></name><parameter_list>(<param><decl><type><name>nsAsyncCallback</name></type> <name>funcPtr</name></decl></param>,
                         <param><decl><type><name><name>nsRunnableMethod</name><argument_list>&lt;<argument><expr><name>nsHttpChannel</name></expr></argument>&gt;</argument_list></name> **</type><name>retval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>nsRunnableMethod</name><argument_list>&lt;<argument><expr><name>nsHttpChannel</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>event</name> <init>=
        <expr><call><name>NS_NewRunnableMethod</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>funcPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>NS_DispatchToCurrentThread</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>retval</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>retval</name> = <name>event</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>Connect</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>firstTime</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::Connect [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// ensure that we are using a valid hostname</comment>
    <if>if <condition>(<expr>!<call><name>net_IsValidHostName</name><argument_list>(<argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><call><name><name>mConnectionInfo</name>-&gt;<name>Host</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_UNKNOWN_HOST</name></expr>;</return></then></if>

    <comment type="line">// true when called from AsyncOpen</comment>
    <if>if <condition>(<expr><name>firstTime</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>delayed</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// are we offline?</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>offline</name> <init>= <expr><call><name><name>gIOService</name>-&gt;<name>IsOffline</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>offline</name></expr>)</condition><then>
            <expr_stmt><expr><name>mLoadFlags</name> |= <name>LOAD_ONLY_FROM_CACHE</name></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><call><name>PL_strcmp</name><argument_list>(<argument><expr><call><name><name>mConnectionInfo</name>-&gt;<name>ProxyType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"unknown"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><call><name>ResolveProxy</name><argument_list>()</argument_list></call></expr>;</return></then></if></else></if>  <comment type="line">// Lazily resolve proxy info</comment>

        <comment type="line">// Don't allow resuming when cache must be used</comment>
        <if>if <condition>(<expr><name>mResuming</name> &amp;&amp; (<name>mLoadFlags</name> &amp; <name>LOAD_ONLY_FROM_CACHE</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Resuming from cache is not supported yet")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_DOCUMENT_NOT_CACHED</name></expr>;</return>
        }</block></then></if>

        <comment type="line">// open a cache entry for this channel...</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>OpenCacheEntry</name><argument_list>(<argument><expr><name>offline</name></expr></argument>, <argument><expr>&amp;<name>delayed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("OpenCacheEntry failed [rv=%x]\n", <name>rv</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// if this channel is only allowed to pull from the cache, then</comment>
            <comment type="line">// we must fail if we were unable to open a cache entry.</comment>
            <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_ONLY_FROM_CACHE</name></expr>)</condition><then> <block>{
                <comment type="line">// If we have a fallback URI (and we're not already</comment>
                <comment type="line">// falling back), process the fallback asynchronously.</comment>
                <if>if <condition>(<expr>!<name>mFallbackChannel</name> &amp;&amp; !<call><name><name>mFallbackKey</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><call><name>AsyncCall</name><argument_list>(<argument><expr>&amp;<name><name>nsHttpChannel</name>::<name>HandleAsyncFallback</name></name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
                <return>return <expr><name>NS_ERROR_DOCUMENT_NOT_CACHED</name></expr>;</return>
            }</block></then></if>
            <comment type="line">// otherwise, let's just proceed without using the cache.</comment>
        }</block></then></if>

        <comment type="line">// if cacheForOfflineUse has been set, open up an offline cache</comment>
        <comment type="line">// entry to update</comment>
        <if>if <condition>(<expr><name>mCacheForOfflineUse</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>OpenOfflineCacheEntryForWriting</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
        }</block></then></if>

        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>delayed</name></expr>)</condition><then>
            <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
    }</block></then></if>

    <comment type="line">// we may or may not have a cache entry at this point</comment>
    <if>if <condition>(<expr><name>mCacheEntry</name></expr>)</condition><then> <block>{
        <comment type="line">// inspect the cache entry to determine whether or not we need to go</comment>
        <comment type="line">// out to net to validate it.  this call sets mCachedContentIsValid</comment>
        <comment type="line">// and may set request headers as required for cache validation.</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>CheckCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"cache check failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// read straight from the cache if possible...</comment>
        <if>if <condition>(<expr><name>mCachedContentIsValid</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsRunnableMethod</name><argument_list>&lt;<argument><expr><name>nsHttpChannel</name></expr></argument>&gt;</argument_list></name> *</type><name>event</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>mCachedContentIsPartial</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>AsyncCall</name><argument_list>(<argument><expr>&amp;<name><name>nsHttpChannel</name>::<name>AsyncOnExamineCachedResponse</name></name></expr></argument>, <argument><expr>&amp;<name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>rv</name> = <call><name>ReadFromCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>event</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>event</name>-&gt;<name>Revoke</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_ONLY_FROM_CACHE</name></expr>)</condition><then> <block>{
            <comment type="line">// the cache contains the requested resource, but it must be </comment>
            <comment type="line">// validated before we can reuse it.  since we are not allowed</comment>
            <comment type="line">// to hit the net, there's nothing more to do.  the document</comment>
            <comment type="line">// is effectively not in the cache.</comment>
            <return>return <expr><name>NS_ERROR_DOCUMENT_NOT_CACHED</name></expr>;</return>
        }</block></then></if></else></if>
    }</block></then></if>

    <comment type="line">// check to see if authorization headers should be included</comment>
    <expr_stmt><expr><call><name>AddAuthorizationHeaders</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_NO_NETWORK_IO</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NS_ERROR_DOCUMENT_NOT_CACHED</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// hit the net...</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>SetupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;<name>InitiateTransaction</name></name><argument_list>(<argument><expr><name>mTransaction</name></expr></argument>, <argument><expr><name>mPriority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><call><name><name>mTransactionPump</name>-&gt;<name>AsyncRead</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// called when Connect fails</comment>
<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>AsyncAbort</name></name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>status</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::AsyncAbort [this=%p status=%x]\n", <name>this</name>, <name>status</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mStatus</name> = <name>status</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mIsPending</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>AsyncCall</name><argument_list>(<argument><expr>&amp;<name><name>nsHttpChannel</name>::<name>HandleAsyncNotifyListener</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// And if that fails?  Callers ignore our return value anyway....</comment>
    
    <comment type="line">// finally remove ourselves from the load group.</comment>
    <if>if <condition>(<expr><name>mLoadGroup</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>RemoveRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>HandleAsyncNotifyListener</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mPendingAsyncCallOnResume</name></expr></argument>, <argument><expr>"How did that happen?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name>mSuspendCount</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Waiting until resume to do async notification [this=%p]\n",
             <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mPendingAsyncCallOnResume</name> = &amp;<name><name>nsHttpChannel</name>::<name>HandleAsyncNotifyListener</name></name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>DoNotifyListener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>DoNotifyListener</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mListener</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mListener</name>-&gt;<name>OnStartRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mListener</name>-&gt;<name>OnStopRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>, <argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mListener</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>mListenerContext</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// We have to make sure to drop the reference to the callbacks too</comment>
    <expr_stmt><expr><name>mCallbacks</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mProgressSink</name> = <name>nsnull</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>HandleAsyncRedirect</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mPendingAsyncCallOnResume</name></expr></argument>, <argument><expr>"How did that happen?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name>mSuspendCount</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Waiting until resume to do async redirect [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mPendingAsyncCallOnResume</name> = &amp;<name><name>nsHttpChannel</name>::<name>HandleAsyncRedirect</name></name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::HandleAsyncRedirect [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// since this event is handled asynchronously, it is possible that this</comment>
    <comment type="line">// channel could have been canceled, in which case there would be no point</comment>
    <comment type="line">// in processing the redirect.</comment>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>ProcessRedirection</name><argument_list>(<argument><expr><call><name><name>mResponseHead</name>-&gt;<name>Status</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// If ProcessRedirection fails, then we have to send out the</comment>
            <comment type="line">// OnStart/OnStop notifications.</comment>
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("ProcessRedirection failed [rv=%x]\n", <name>rv</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mStatus</name> = <name>rv</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DoNotifyListener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// close the cache entry.  Blow it away if we couldn't process the redirect</comment>
    <comment type="line">// for some reason (the cache entry might be corrupt).</comment>
    <if>if <condition>(<expr><name>mCacheEntry</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mCacheEntry</name>-&gt;<name>Doom</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>CloseCacheEntry</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>mIsPending</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mLoadGroup</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>RemoveRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>HandleAsyncNotModified</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mPendingAsyncCallOnResume</name></expr></argument>, <argument><expr>"How did that happen?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name>mSuspendCount</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Waiting until resume to do async not-modified [this=%p]\n",
             <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mPendingAsyncCallOnResume</name> = &amp;<name><name>nsHttpChannel</name>::<name>HandleAsyncNotModified</name></name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>
    
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::HandleAsyncNotModified [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DoNotifyListener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CloseCacheEntry</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mIsPending</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mLoadGroup</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>RemoveRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>HandleAsyncFallback</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mPendingAsyncCallOnResume</name></expr></argument>, <argument><expr>"How did that happen?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mSuspendCount</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Waiting until resume to do async fallback [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mPendingAsyncCallOnResume</name> = &amp;<name><name>nsHttpChannel</name>::<name>HandleAsyncFallback</name></name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::HandleAsyncFallback [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// since this event is handled asynchronously, it is possible that this</comment>
    <comment type="line">// channel could have been canceled, in which case there would be no point</comment>
    <comment type="line">// in processing the fallback.</comment>
    <if>if <condition>(<expr>!<name>mCanceled</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>fallingBack</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>ProcessFallback</name><argument_list>(<argument><expr>&amp;<name>fallingBack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> || !<name>fallingBack</name></expr>)</condition><then> <block>{
            <comment type="line">// If ProcessFallback fails, then we have to send out the</comment>
            <comment type="line">// OnStart/OnStop notifications.</comment>
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("ProcessFallback failed [rv=%x, %d]\n", <name>rv</name>, <name>fallingBack</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mStatus</name> = <call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> ? <name>rv</name> : <name>NS_ERROR_DOCUMENT_NOT_CACHED</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>DoNotifyListener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>mIsPending</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mLoadGroup</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>RemoveRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>SetupTransaction</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::SetupTransaction [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mTransaction</name></expr></argument>, <argument><expr><name>NS_ERROR_ALREADY_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>mCaps</name> &amp; <name>NS_HTTP_ALLOW_PIPELINING</name></expr>)</condition><then> <block>{
        <comment type="line">//</comment>
        <comment type="line">// disable pipelining if:</comment>
        <comment type="line">//   (1) pipelining has been explicitly disabled</comment>
        <comment type="line">//   (2) request corresponds to a top-level document load (link click)</comment>
        <comment type="line">//   (3) request method is non-idempotent</comment>
        <comment type="line">//</comment>
        <comment type="line">// XXX does the toplevel document check really belong here?  or, should</comment>
        <comment type="line">//     we push it out entirely to necko consumers?</comment>
        <comment type="line">//</comment>
        <if>if <condition>(<expr>!<name>mAllowPipelining</name> || (<name>mLoadFlags</name> &amp; <name>LOAD_INITIAL_DOCUMENT_URI</name>) ||
            !(<call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Get</name></name> ||
              <call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Head</name></name> ||
              <call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Propfind</name></name> ||
              <call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Proppatch</name></name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  pipelining disallowed\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mCaps</name> &amp;= ~<name>NS_HTTP_ALLOW_PIPELINING</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// use the URI path if not proxying (transparent proxying such as SSL proxy</comment>
    <comment type="line">// does not count here). also, figure out what version we should be speaking.</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>buf</name></decl>, <decl><type ref="prev"/><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCString</name>*</type> <name>requestURI</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>mConnectionInfo</name>-&gt;<name>UsingSSL</name></name><argument_list>()</argument_list></call> || !<call><name><name>mConnectionInfo</name>-&gt;<name>UsingHttpProxy</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetPath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
        <comment type="line">// path may contain UTF-8 characters, so ensure that they're escaped.</comment>
        <if>if <condition>(<expr><call><name>NS_EscapeURL</name><argument_list>(<argument><expr><call><name><name>path</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>path</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>esc_OnlyNonASCII</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>requestURI</name> = &amp;<name>buf</name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>requestURI</name> = &amp;<name>path</name></expr>;</expr_stmt></else></if>
        <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetVersion</name></name><argument_list>(<argument><expr><call><name><name>gHttpHandler</name>-&gt;<name>HttpVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetUserPass</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name><name>buf</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; ((<call><name>strncmp</name><argument_list>(<argument><expr><call><name><name>mSpec</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"http:"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call> == 0) ||
                                <call><name>strncmp</name><argument_list>(<argument><expr><call><name><name>mSpec</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"https:"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>tempURI</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>Clone</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>tempURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
            <expr_stmt><expr><name>rv</name> = <call><name><name>tempURI</name>-&gt;<name>SetUserPass</name></name><argument_list>(<argument><expr><call><name>EmptyCString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
            <expr_stmt><expr><name>rv</name> = <call><name><name>tempURI</name>-&gt;<name>GetAsciiSpec</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
            <expr_stmt><expr><name>requestURI</name> = &amp;<name>path</name></expr>;</expr_stmt>
        }</block></then>
        <else>else
            <expr_stmt><expr><name>requestURI</name> = &amp;<name>mSpec</name></expr>;</expr_stmt></else></if>
        <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetVersion</name></name><argument_list>(<argument><expr><call><name><name>gHttpHandler</name>-&gt;<name>ProxyHttpVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="line">// trim off the #ref portion if any...</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>ref</name> <init>= <expr><call><name><name>requestURI</name>-&gt;<name>FindChar</name></name><argument_list>(<argument><expr>'#'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>ref</name> != <name>kNotFound</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>requestURI</name>-&gt;<name>SetLength</name></name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetRequestURI</name></name><argument_list>(<argument><expr>*<name>requestURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// set the request time for cache expiration calculations</comment>
    <expr_stmt><expr><name>mRequestTime</name> = <call><name>NowInSeconds</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// if doing a reload, force end-to-end</comment>
    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_BYPASS_CACHE</name></expr>)</condition><then> <block>{
        <comment type="line">// We need to send 'Pragma:no-cache' to inhibit proxy caching even if</comment>
        <comment type="line">// no proxy is configured since we might be talking with a transparent</comment>
        <comment type="line">// proxy, i.e. one that operates at the network level.  See bug #14772.</comment>
        <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Pragma</name></name></expr></argument>, <argument><expr><call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr>"no-cache"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// If we're configured to speak HTTP/1.1 then also send 'Cache-control:</comment>
        <comment type="line">// no-cache'</comment>
        <if>if <condition>(<expr><call><name><name>mRequestHead</name>.<name>Version</name></name><argument_list>()</argument_list></call> &gt;= <name>NS_HTTP_VERSION_1_1</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Cache_Control</name></name></expr></argument>, <argument><expr><call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr>"no-cache"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr>(<name>mLoadFlags</name> &amp; <name>VALIDATE_ALWAYS</name>) &amp;&amp; (<name>mCacheAccess</name> &amp; <name><name>nsICache</name>::<name>ACCESS_READ</name></name>)</expr>)</condition><then> <block>{
        <comment type="line">// We need to send 'Cache-Control: max-age=0' to force each cache along</comment>
        <comment type="line">// the path to the origin server to revalidate its own entry, if any,</comment>
        <comment type="line">// with the next cache or server.  See bug #84847.</comment>
        <comment type="line">//</comment>
        <comment type="line">// If we're configured to speak HTTP/1.0 then just send 'Pragma: no-cache'</comment>
        <if>if <condition>(<expr><call><name><name>mRequestHead</name>.<name>Version</name></name><argument_list>()</argument_list></call> &gt;= <name>NS_HTTP_VERSION_1_1</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Cache_Control</name></name></expr></argument>, <argument><expr><call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr>"max-age=0"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Pragma</name></name></expr></argument>, <argument><expr><call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr>"no-cache"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><name>mResuming</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>byteRange</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PR_snprintf</name><argument_list>(<argument><expr><name>byteRange</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>byteRange</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"bytes=%llu-"</expr></argument>, <argument><expr><name>mStartPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Range</name></name></expr></argument>, <argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><name>byteRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<call><name><name>mEntityID</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// Also, we want an error if this resource changed in the meantime</comment>
            <comment type="line">// Format of the entity id is: escaped_etag/size/lastmod</comment>
            <decl_stmt><decl><type><name><name>nsCString</name>::<name>const_iterator</name></name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>slash</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>mEntityID</name>.<name>BeginReading</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mEntityID</name>.<name>EndReading</name></name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mEntityID</name>.<name>BeginReading</name></name><argument_list>(<argument><expr><name>slash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name>FindCharInReadable</name><argument_list>(<argument><expr>'/'</expr></argument>, <argument><expr><name>slash</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>ifMatch</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_Match</name></name></expr></argument>,
                        <argument><expr><call><name>NS_UnescapeURL</name><argument_list>(<argument><expr><call><name>Substring</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>slash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ifMatch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr>++<name>slash</name></expr>;</expr_stmt> <comment type="line">// Incrementing, so that searching for '/' won't find</comment>
                         <comment type="line">// the same slash again</comment>
            }</block></then></if>

            <if>if <condition>(<expr><call><name>FindCharInReadable</name><argument_list>(<argument><expr>'/'</expr></argument>, <argument><expr><name>slash</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_Unmodified_Since</name></name></expr></argument>,
                        <argument><expr><call><name>Substring</name><argument_list>(<argument><expr>++<name>slash</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// create wrapper for this channel's notification callbacks</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIInterfaceRequestor</name></expr></argument>&gt;</argument_list></name></type> <name>callbacks</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_NewNotificationCallbacksAggregation</name><argument_list>(<argument><expr><name>mCallbacks</name></expr></argument>, <argument><expr><name>mLoadGroup</name></expr></argument>,
                                           <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>callbacks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>callbacks</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <comment type="line">// create the transaction object</comment>
    <expr_stmt><expr><name>mTransaction</name> = new <call><name>nsHttpTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mTransaction</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>mTransaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// See bug #466080. Transfer LOAD_ANONYMOUS flag to socket-layer.</comment>
    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_ANONYMOUS</name></expr>)</condition><then>
        <expr_stmt><expr><name>mCaps</name> |= <name>NS_HTTP_LOAD_ANONYMOUS</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name><name>mConnectionInfo</name>-&gt;<name>SetAnonymous</name></name><argument_list>(<argument><expr>(<name>mLoadFlags</name> &amp; <name>LOAD_ANONYMOUS</name>) != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAsyncInputStream</name></expr></argument>&gt;</argument_list></name></type> <name>responseStream</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mTransaction</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>mCaps</name></expr></argument>, <argument><expr><name>mConnectionInfo</name></expr></argument>, <argument><expr>&amp;<name>mRequestHead</name></expr></argument>,
                            <argument><expr><name>mUploadStream</name></expr></argument>, <argument><expr><name>mUploadStreamHasHeaders</name></expr></argument>,
                            <argument><expr><call><name>NS_GetCurrentThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>callbacks</name></expr></argument>, <argument><expr><name>this</name></expr></argument>,
                            <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>responseStream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>mTransaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>nsInputStreamPump</name>::<name>Create</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mTransactionPump</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>responseStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>AddCookiesToRequest</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_ANONYMOUS</name></expr>)</condition><then> <block>{
      <return>return;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsXPIDLCString</name></type> <name>cookie</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsICookieService</name> *</type><name>cs</name> <init>= <expr><call><name><name>gHttpHandler</name>-&gt;<name>GetCookieService</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>cs</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cs</name>-&gt;<name>GetCookieStringFromHttp</name></name><argument_list>(<argument><expr><name>mURI</name></expr></argument>,
                                    <argument><expr><name>mDocumentURI</name> ? <name>mDocumentURI</name> : <name>mOriginalURI</name></expr></argument>,
                                    <argument><expr><name>this</name></expr></argument>,
                                    <argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>cookie</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name><name>cookie</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>cookie</name> = <name>mUserSetCookieHeader</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr>!<call><name><name>mUserSetCookieHeader</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cookie</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr>"; "</expr></argument>)</argument_list></call> + <name>mUserSetCookieHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

    <comment type="line">// overwrite any existing cookie headers.  be sure to clear any</comment>
    <comment type="line">// existing cookies if we have no cookies to set or if the cookie</comment>
    <comment type="line">// service is unavailable.</comment>
    <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Cookie</name></name></expr></argument>, <argument><expr><name>cookie</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ApplyContentConversions</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ApplyContentConversions [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>mApplyConversion</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("not applying conversion per mApplyConversion\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr><call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Encoding</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>gHttpHandler</name>-&gt;<name>IsAcceptableEncoding</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStreamConverterService</name></expr></argument>&gt;</argument_list></name></type> <name>serv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>gHttpHandler</name>-&gt;
                <name>GetStreamConverterService</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>serv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// we won't fail to load the page just because we couldn't load the</comment>
        <comment type="line">// stream converter service.. carry on..</comment>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStreamListener</name></expr></argument>&gt;</argument_list></name></type> <name>converter</name></decl>;</decl_stmt>
            <function_decl><type><name>nsCAutoString</name></type> <name>from</name><parameter_list>(<param><decl><type><name>val</name></type></decl></param>)</parameter_list>;</function_decl>
            <expr_stmt><expr><call><name>ToLowerCase</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name><name>serv</name>-&gt;<name>AsyncConvertData</name></name><argument_list>(<argument><expr><call><name><name>from</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr>"uncompressed"</expr></argument>,
                                        <argument><expr><name>mListener</name></expr></argument>,
                                        <argument><expr><name>mListenerContext</name></expr></argument>,
                                        <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>converter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("converter installed from \'%s\' to \'uncompressed\'\n", <name>val</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>mListener</name> = <name>converter</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then> <else>else <if>if <condition>(<expr><name>val</name> != <name>nsnull</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Unknown content encoding '%s', ignoring\n", <name>val</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// NOTE: This function duplicates code from nsBaseChannel. This will go away</comment>
<comment type="line">// once HTTP uses nsBaseChannel (part of bug 312760)</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CallTypeSniffers</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>aClosure</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>PRUint8</name> *</type><name>aData</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aCount</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIChannel</name> *</type><name>chan</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIChannel</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name><name>nsCOMArray</name><argument_list>&lt;<argument><expr><name>nsIContentSniffer</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>sniffers</name> <init>=
    <expr><call><name><name>gIOService</name>-&gt;<name>GetContentSniffers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>length</name> <init>= <expr><call><name><name>sniffers</name>.<name>Count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>PRUint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>newType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>=
      <expr><name><name>sniffers</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<call><name>GetMIMETypeFromContent</name><argument_list>(<argument><expr><name>chan</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>aCount</name></expr></argument>, <argument><expr><name>newType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>newType</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>chan</name>-&gt;<name>SetContentType</name></name><argument_list>(<argument><expr><name>newType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>CallOnStartRequest</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>mTracingEnabled</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mResponseHead</name> &amp;&amp; <call><name><name>mResponseHead</name>-&gt;<name>ContentType</name></name><argument_list>()</argument_list></call>.<call><name>IsEmpty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name><name>mContentTypeHint</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mResponseHead</name>-&gt;<name>SetContentType</name></name><argument_list>(<argument><expr><name>mContentTypeHint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <block>{
            <comment type="line">// Uh-oh.  We had better find out what type we are!</comment>

            <comment type="line">// XXX This does not work with content-encodings...  but</comment>
            <comment type="line">// neither does applying the conversion from the URILoader</comment>

            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStreamConverterService</name></expr></argument>&gt;</argument_list></name></type> <name>serv</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>gHttpHandler</name>-&gt;
                <name>GetStreamConverterService</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>serv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// If we failed, we just fall through to the "normal" case</comment>
            <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStreamListener</name></expr></argument>&gt;</argument_list></name></type> <name>converter</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>rv</name> = <call><name><name>serv</name>-&gt;<name>AsyncConvertData</name></name><argument_list>(<argument><expr><name>UNKNOWN_CONTENT_TYPE</name></expr></argument>,
                                            <argument><expr>"*/*"</expr></argument>,
                                            <argument><expr><name>mListener</name></expr></argument>,
                                            <argument><expr><name>mListenerContext</name></expr></argument>,
                                            <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>converter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>mListener</name> = <name>converter</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>mResponseHead</name> &amp;&amp; <call><name><name>mResponseHead</name>-&gt;<name>ContentCharset</name></name><argument_list>()</argument_list></call>.<call><name>IsEmpty</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mResponseHead</name>-&gt;<name>SetContentCharset</name></name><argument_list>(<argument><expr><name>mContentCharsetHint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>mResponseHead</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SetPropertyAsInt64</name><argument_list>(<argument><expr><name>NS_CHANNEL_PROP_CONTENT_LENGTH</name></expr></argument>,
                           <argument><expr><call><name><name>mResponseHead</name>-&gt;<name>ContentLength</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// Allow consumers to override our content type</comment>
    <if>if <condition>(<expr>(<name>mLoadFlags</name> &amp; <name>LOAD_CALL_CONTENT_SNIFFERS</name>) &amp;&amp;
        <call><name><name>gIOService</name>-&gt;<name>GetContentSniffers</name></name><argument_list>()</argument_list></call>.<call><name>Count</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
        <comment type="line">// NOTE: We can have both a txn pump and a cache pump when the cache</comment>
        <comment type="line">// content is partial. In that case, we need to read from the cache,</comment>
        <comment type="line">// because that's the one that has the initial contents. If that fails</comment>
        <comment type="line">// then give the transaction pump a shot.</comment>

        <decl_stmt><decl><type><name>nsIChannel</name>*</type> <name>thisChannel</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIChannel</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>PRBool</name></type> <name>typeSniffersCalled</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>mCachePump</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>typeSniffersCalled</name> =
            <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>mCachePump</name>-&gt;<name>PeekStream</name></name><argument_list>(<argument><expr><name>CallTypeSniffers</name></expr></argument>, <argument><expr><name>thisChannel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        
        <if>if <condition>(<expr>!<name>typeSniffersCalled</name> &amp;&amp; <name>mTransactionPump</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>mTransactionPump</name>-&gt;<name>PeekStream</name></name><argument_list>(<argument><expr><name>CallTypeSniffers</name></expr></argument>, <argument><expr><name>thisChannel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  calling mListener-&gt;OnStartRequest\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mListener</name>-&gt;<name>OnStartRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// install stream converter if required</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>ApplyContentConversions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<name>mCanceled</name></expr>)</condition><then> <block>{
        <comment type="line">// create offline cache entry if offline caching was requested</comment>
        <if>if <condition>(<expr><name>mCacheForOfflineUse</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PRBool</name></type> <name>shouldCacheForOfflineUse</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>ShouldUpdateOfflineCacheEntry</name><argument_list>(<argument><expr>&amp;<name>shouldCacheForOfflineUse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
            
            <if>if <condition>(<expr><name>shouldCacheForOfflineUse</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("writing to the offline cache")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rv</name> = <call><name>InitOfflineCacheEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
                
                <if>if <condition>(<expr><name>mOfflineCacheEntry</name></expr>)</condition><then> <block>{
                  <expr_stmt><expr><name>rv</name> = <call><name>InstallOfflineCacheListener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("offline cache is up to date, not updating")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CloseOfflineCacheEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ProcessFailedSSLConnect</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>httpStatus</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Failure to set up SSL proxy tunnel means one of the following:</comment>
    <comment type="line">// 1) Proxy wants authorization, or forbids.</comment>
    <comment type="line">// 2) DNS at proxy couldn't resolve target URL.</comment>
    <comment type="line">// 3) Proxy connection to target failed or timed out.</comment>
    <comment type="line">// 4) Eve noticed our proxy CONNECT, and is replying with malicious HTML.</comment>
    <comment type="line">// </comment>
    <comment type="line">// Our current architecture will parse response content with the</comment>
    <comment type="line">// permission of the target URL!  Given #4, we must avoid rendering the</comment>
    <comment type="line">// body of the reply, and instead give the user a (hopefully helpful) </comment>
    <comment type="line">// boilerplate error page, based on just the HTTP status of the reply.</comment>

    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name><name>mConnectionInfo</name>-&gt;<name>UsingSSL</name></name><argument_list>()</argument_list></call></expr></argument>,
                      <argument><expr>"SSL connect failed but not using SSL?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>httpStatus</name></expr>)</condition> 
    <block>{
    <case>case <expr>300</expr>: </case><case>case <expr>301</expr>: </case><case>case <expr>302</expr>: </case><case>case <expr>303</expr>: </case><case>case <expr>307</expr>:
        <comment type="line">// Bad redirect: not top-level, or it's a POST, bad/missing Location,</comment>
        <comment type="line">// or ProcessRedirect() failed for some other reason.  Legal</comment>
        <comment type="line">// redirects that fail because site not available, etc., are handled</comment>
        <comment type="line">// elsewhere, in the regular codepath.</comment>
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_CONNECTION_REFUSED</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr>403</expr>: <comment type="line">// HTTP/1.1: "Forbidden"</comment>
    </case><case>case <expr>407</expr>: <comment type="line">// ProcessAuthentication() failed</comment>
    </case><case>case <expr>501</expr>: <comment type="line">// HTTP/1.1: "Not Implemented"</comment>
        <comment type="line">// user sees boilerplate Mozilla "Proxy Refused Connection" page.</comment>
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_PROXY_CONNECTION_REFUSED</name></expr>;</expr_stmt> 
        <break>break;</break>
    <comment type="line">// Squid sends 404 if DNS fails (regular 404 from target is tunneled)</comment>
    </case><case>case <expr>404</expr>: <comment type="line">// HTTP/1.1: "Not Found"</comment>
    <comment type="line">// RFC 2616: "some deployed proxies are known to return 400 or 500 when</comment>
    <comment type="line">// DNS lookups time out."  (Squid uses 500 if it runs out of sockets: so</comment>
    <comment type="line">// we have a conflict here).</comment>
    </case><case>case <expr>400</expr>: <comment type="line">// HTTP/1.1 "Bad Request"</comment>
    </case><case>case <expr>500</expr>: <comment type="line">// HTTP/1.1: "Internal Server Error"</comment>
        <comment type="block">/* User sees: "Address Not Found: Firefox can't find the server at
         * www.foo.com."
         */</comment>
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_UNKNOWN_HOST</name></expr>;</expr_stmt> 
        <break>break;</break>
    </case><case>case <expr>502</expr>: <comment type="line">// HTTP/1.1: "Bad Gateway" (invalid resp from target server)</comment>
    <comment type="line">// Squid returns 503 if target request fails for anything but DNS.</comment>
    </case><case>case <expr>503</expr>: <comment type="line">// HTTP/1.1: "Service Unavailable"</comment>
        <comment type="block">/* User sees: "Failed to Connect:
         *  Firefox can't establish a connection to the server at
         *  www.foo.com.  Though the site seems valid, the browser
         *  was unable to establish a connection."
         */</comment>
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_CONNECTION_REFUSED</name></expr>;</expr_stmt>
        <break>break;</break>
    <comment type="line">// RFC 2616 uses 504 for both DNS and target timeout, so not clear what to</comment>
    <comment type="line">// do here: picking target timeout, as DNS covered by 400/404/500</comment>
    </case><case>case <expr>504</expr>: <comment type="line">// HTTP/1.1: "Gateway Timeout" </comment>
        <comment type="line">// user sees: "Network Timeout: The server at www.foo.com</comment>
        <comment type="line">//              is taking too long to respond."</comment>
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_NET_TIMEOUT</name></expr>;</expr_stmt>
        <break>break;</break>
    <comment type="line">// Confused proxy server or malicious response</comment>
    </case><default>default:
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_PROXY_CONNECTION_REFUSED</name></expr>;</expr_stmt> 
        <break>break;</break>
    </default>}</block></switch>
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Cancelling failed SSL proxy connection [this=%p httpStatus=%u]\n",
         <name>this</name>, <name>httpStatus</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CallOnStartRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsHttpChannel</name>::<name>ShouldSSLProxyResponseContinue</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>httpStatus</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// When SSL connect has failed, allow proxy reply to continue only if it's</comment>
    <comment type="line">// an auth request, or a redirect of a non-POST top-level document load.</comment>
    <switch>switch <condition>(<expr><name>httpStatus</name></expr>)</condition> <block>{
    <case>case <expr>407</expr>:
        <return>return <expr><name>PR_TRUE</name></expr>;</return>
    </case><case>case <expr>300</expr>: </case><case>case <expr>301</expr>: </case><case>case <expr>302</expr>: </case><case>case <expr>303</expr>: </case><case>case <expr>307</expr>:
      <block>{
        <return>return <expr>( (<name>mLoadFlags</name> &amp; <name><name>nsIChannel</name>::<name>LOAD_DOCUMENT_URI</name></name>) &amp;&amp;
                 <name>mURI</name> == <name>mDocumentURI</name> &amp;&amp;
                 <call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> != <name><name>nsHttp</name>::<name>Post</name></name>)</expr>;</return>
      }</block>
    </case>}</block></switch>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ProcessResponse</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>httpStatus</name> <init>= <expr><call><name><name>mResponseHead</name>-&gt;<name>Status</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ProcessResponse [this=%p httpStatus=%u]\n",
        <name>this</name>, <name>httpStatus</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>mTransaction</name>-&gt;<name>SSLConnectFailed</name></name><argument_list>()</argument_list></call> &amp;&amp;
        !<call><name>ShouldSSLProxyResponseContinue</name><argument_list>(<argument><expr><name>httpStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>ProcessFailedSSLConnect</name><argument_list>(<argument><expr><name>httpStatus</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="line">// notify "http-on-examine-response" observers</comment>
    <expr_stmt><expr><call><name><name>gHttpHandler</name>-&gt;<name>OnExamineResponse</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// set cookies, if any exist; done after OnExamineResponse to allow those</comment>
    <comment type="line">// observers to modify the cookie response headers</comment>
    <expr_stmt><expr><call><name>SetCookie</name><argument_list>(<argument><expr><call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Set_Cookie</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// handle unused username and password in url (see bug 232567)</comment>
    <if>if <condition>(<expr><name>httpStatus</name> != 401 &amp;&amp; <name>httpStatus</name> != 407</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>CheckForSuperfluousAuth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>mCanceled</name></expr>)</condition><then>
            <return>return <expr><call><name>CallOnStartRequest</name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <if>if <condition>(<expr><name>mAuthContinuationState</name></expr>)</condition><then> <block>{
            <comment type="line">// reset the current continuation state because our last</comment>
            <comment type="line">// authentication attempt has been completed successfully</comment>
            <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>mAuthContinuationState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  continuation state has been reset")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// handle different server response categories.  Note that we handle</comment>
    <comment type="line">// caching or not caching of error pages in</comment>
    <comment type="line">// nsHttpResponseHead::MustValidate; if you change this switch, update that</comment>
    <comment type="line">// one</comment>
    <switch>switch <condition>(<expr><name>httpStatus</name></expr>)</condition> <block>{
    <case>case <expr>200</expr>:
    </case><case>case <expr>203</expr>:
        <comment type="line">// Per RFC 2616, 14.35.2, "A server MAY ignore the Range header".</comment>
        <comment type="line">// So if a server does that and sends 200 instead of 206 that we</comment>
        <comment type="line">// expect, notify our caller.</comment>
        <comment type="line">// However, if we wanted to start from the beginning, let it go through</comment>
        <if>if <condition>(<expr><name>mResuming</name> &amp;&amp; <name>mStartPos</name> != 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Server ignored our Range header, cancelling [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_ERROR_NOT_RESUMABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>CallOnStartRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <comment type="line">// these can normally be cached</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>ProcessNormal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MaybeInvalidateCacheEntryForSubsequentGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr>206</expr>:
        <if>if <condition>(<expr><name>mCachedContentIsPartial</name></expr>)</condition><then> <comment type="line">// an internal byte range request...</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>ProcessPartialContent</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>rv</name> = <call><name>ProcessNormal</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
        <break>break;</break>
    </case><case>case <expr>300</expr>:
    </case><case>case <expr>301</expr>:
    </case><case>case <expr>302</expr>:
    </case><case>case <expr>307</expr>:
    </case><case>case <expr>303</expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
    case 305: <comment type="line">// disabled as a security measure (see bug 187996).</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="line">// don't store the response body for redirects</comment>
        <expr_stmt><expr><call><name>MaybeInvalidateCacheEntryForSubsequentGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>ProcessRedirection</name><argument_list>(<argument><expr><name>httpStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>InitCacheEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CloseCacheEntry</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>mCacheForOfflineUse</name></expr>)</condition><then> <block>{
                <comment type="line">// Store response in the offline cache</comment>
                <expr_stmt><expr><call><name>InitOfflineCacheEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CloseOfflineCacheEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>    
        <else>else <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("ProcessRedirection failed [rv=%x]\n", <name>rv</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>mTransaction</name>-&gt;<name>SSLConnectFailed</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr><call><name>ProcessFailedSSLConnect</name><argument_list>(<argument><expr><name>httpStatus</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
            <expr_stmt><expr><name>rv</name> = <call><name>ProcessNormal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
    </case><case>case <expr>304</expr>:
        <expr_stmt><expr><name>rv</name> = <call><name>ProcessNotModified</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("ProcessNotModified failed [rv=%x]\n", <name>rv</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>ProcessNormal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
    </case><case>case <expr>401</expr>:
    </case><case>case <expr>407</expr>:
        <expr_stmt><expr><name>rv</name> = <call><name>ProcessAuthentication</name><argument_list>(<argument><expr><name>httpStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("ProcessAuthentication failed [rv=%x]\n", <name>rv</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>mTransaction</name>-&gt;<name>SSLConnectFailed</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr><call><name>ProcessFailedSSLConnect</name><argument_list>(<argument><expr><name>httpStatus</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
            <expr_stmt><expr><call><name>CheckForSuperfluousAuth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>ProcessNormal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
    </case><default>default:
        <expr_stmt><expr><name>rv</name> = <call><name>ProcessNormal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MaybeInvalidateCacheEntryForSubsequentGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ProcessNormal</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ProcessNormal [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>succeeded</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>GetRequestSucceeded</name><argument_list>(<argument><expr>&amp;<name>succeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>succeeded</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>fallingBack</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>ProcessFallback</name><argument_list>(<argument><expr>&amp;<name>fallingBack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>DoNotifyListener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>fallingBack</name></expr>)</condition><then> <block>{
            <comment type="line">// Do not continue with normal processing, fallback is in</comment>
            <comment type="line">// progress now.</comment>
            <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// if we're here, then any byte-range requests failed to result in a partial</comment>
    <comment type="line">// response.  we must clear this flag to prevent BufferPartialContent from</comment>
    <comment type="line">// being called inside our OnDataAvailable (see bug 136678).</comment>
    <expr_stmt><expr><name>mCachedContentIsPartial</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ClearBogusContentEncodingIfNeeded</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// this must be called before firing OnStartRequest, since http clients,</comment>
    <comment type="line">// such as imagelib, expect our cache entry to already have the correct</comment>
    <comment type="line">// expiration time (bug 87710).</comment>
    <if>if <condition>(<expr><name>mCacheEntry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>InitCacheEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>CloseCacheEntry</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <comment type="line">// Check that the server sent us what we were asking for</comment>
    <if>if <condition>(<expr><name>mResuming</name></expr>)</condition><then> <block>{
        <comment type="line">// Create an entity id from the response</comment>
        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>id</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>GetEntityID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// If creating an entity id is not possible -&gt; error</comment>
            <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_ERROR_NOT_RESUMABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name><name>mResponseHead</name>-&gt;<name>Status</name></name><argument_list>()</argument_list></call> != 206 &amp;&amp;
                 <call><name><name>mResponseHead</name>-&gt;<name>Status</name></name><argument_list>()</argument_list></call> != 200</expr>)</condition><then> <block>{
            <comment type="line">// Probably 404 Not Found, 412 Precondition Failed or</comment>
            <comment type="line">// 416 Invalid Range -&gt; error</comment>
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Unexpected response status while resuming, aborting [this=%p]\n",
                 <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_ERROR_ENTITY_CHANGED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <comment type="line">// If we were passed an entity id, verify it's equal to the server's</comment>
        <else>else <if>if <condition>(<expr>!<call><name><name>mEntityID</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name><name>mEntityID</name>.<name>Equals</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Entity mismatch, expected '%s', got '%s', aborting [this=%p]",
                     <call><name><name>mEntityID</name>.<name>get</name></name><argument_list>()</argument_list></call>, <call><name><name>id</name>.<name>get</name></name><argument_list>()</argument_list></call>, <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_ERROR_ENTITY_CHANGED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></else></if></else></if>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>CallOnStartRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// install cache listener if we still have a cache entry open</comment>
    <if>if <condition>(<expr><name>mCacheEntry</name> &amp;&amp; (<name>mCacheAccess</name> &amp; <name><name>nsICache</name>::<name>ACCESS_WRITE</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>InstallCacheListener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>PromptTempRedirect</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name><name>gHttpHandler</name>-&gt;<name>PromptTempRedirect</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStringBundleService</name></expr></argument>&gt;</argument_list></name></type> <name>bundleService</name> <init>=
            <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_STRINGBUNDLE_CONTRACTID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStringBundle</name></expr></argument>&gt;</argument_list></name></type> <name>stringBundle</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>bundleService</name>-&gt;<name>CreateBundle</name></name><argument_list>(<argument><expr><name>NECKO_MSGS_URL</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>stringBundle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsXPIDLString</name></type> <name>messageString</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>stringBundle</name>-&gt;<name>GetStringFromName</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"RepostFormData"</expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>messageString</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// GetStringFromName can return NS_OK and NULL messageString.</comment>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>messageString</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>repost</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrompt</name></expr></argument>&gt;</argument_list></name></type> <name>prompt</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GetCallback</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>prompt</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_NO_INTERFACE</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name><name>prompt</name>-&gt;<name>Confirm</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>messageString</name></expr></argument>, <argument><expr>&amp;<name>repost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>repost</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    }</block></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ProxyFailover</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ProxyFailover [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIProtocolProxyService</name></expr></argument>&gt;</argument_list></name></type> <name>pps</name> <init>=
            <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_PROTOCOLPROXYSERVICE_CONTRACTID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIProxyInfo</name></expr></argument>&gt;</argument_list></name></type> <name>pi</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>pps</name>-&gt;<name>GetFailoverForProxy</name></name><argument_list>(<argument><expr><call><name><name>mConnectionInfo</name>-&gt;<name>ProxyInfo</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mURI</name></expr></argument>, <argument><expr><name>mStatus</name></expr></argument>,
                                  <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// XXXbz so where does this codepath remove us from the loadgroup,</comment>
    <comment type="line">// exactly?</comment>
    <return>return <expr><call><name>DoReplaceWithProxy</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>HandleAsyncReplaceWithProxy</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mPendingAsyncCallOnResume</name></expr></argument>, <argument><expr>"How did that happen?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mSuspendCount</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Waiting until resume to do async proxy replacement [this=%p]\n",
             <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mPendingAsyncCallOnResume</name> =
            &amp;<name><name>nsHttpChannel</name>::<name>HandleAsyncReplaceWithProxy</name></name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>status</name> <init>= <expr><name>mStatus</name></expr></init></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIProxyInfo</name></expr></argument>&gt;</argument_list></name></type> <name>pi</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pi</name>.<name>swap</name></name><argument_list>(<argument><expr><name>mTargetProxyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mCanceled</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>status</name> = <call><name>DoReplaceWithProxy</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>mLoadGroup</name> &amp;&amp; <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>RemoveRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>AsyncAbort</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>DoReplaceWithProxy</name></name><parameter_list>(<param><decl><type><name>nsIProxyInfo</name>*</type> <name>pi</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::DoReplaceWithProxy [this=%p pi=%p]", <name>this</name>, <name>pi</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIChannel</name></expr></argument>&gt;</argument_list></name></type> <name>newChannel</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;<name>NewProxiedChannel</name></name><argument_list>(<argument><expr><name>mURI</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>SetupReplacementChannel</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>, <argument><expr><name>newChannel</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// Inform consumers about this fake redirect</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>flags</name> <init>= <expr><name><name>nsIChannelEventSink</name>::<name>REDIRECT_INTERNAL</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;<name>OnChannelRedirect</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>newChannel</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// Make sure to do this _after_ calling OnChannelRedirect</comment>
    <expr_stmt><expr><call><name><name>newChannel</name>-&gt;<name>SetOriginalURI</name></name><argument_list>(<argument><expr><name>mOriginalURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// open new channel</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>newChannel</name>-&gt;<name>AsyncOpen</name></name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mStatus</name> = <name>NS_BINDING_REDIRECTED</name></expr>;</expr_stmt>

    <comment type="line">// disconnect from the old listeners...</comment>
    <expr_stmt><expr><name>mListener</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mListenerContext</name> = <name>nsnull</name></expr>;</expr_stmt>

    <comment type="line">// ...and the old callbacks</comment>
    <expr_stmt><expr><name>mCallbacks</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mProgressSink</name> = <name>nsnull</name></expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ResolveProxy</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ResolveProxy [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIProtocolProxyService</name></expr></argument>&gt;</argument_list></name></type> <name>pps</name> <init>=
            <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_PROTOCOLPROXYSERVICE_CONTRACTID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><call><name><name>pps</name>-&gt;<name>AsyncResolve</name></name><argument_list>(<argument><expr><name>mURI</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mProxyRequest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsHttpChannel</name>::<name>ResponseWouldVary</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>result</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>buf</name></decl>, <decl><type ref="prev"/><name>metaKey</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mCachedResponseHead</name>-&gt;<name>GetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Vary</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>buf</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_NAMED_LITERAL_CSTRING</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr>"request-"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// enumerate the elements of the Vary header...</comment>
        <decl_stmt><decl><type><name>char</name> *</type><name>val</name> <init>= <expr><call><name><name>buf</name>.<name>BeginWriting</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// going to munge buf</comment>
        <decl_stmt><decl><type><name>char</name> *</type><name>token</name> <init>= <expr><call><name><name>nsCRT</name>::<name>strtok</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>NS_HTTP_HEADER_SEPS</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>token</name></expr>)</condition> <block>{
            <comment type="line">//</comment>
            <comment type="line">// if "*", then assume response would vary.  technically speaking,</comment>
            <comment type="line">// "Vary: header, *" is not permitted, but we allow it anyways.</comment>
            <comment type="line">//</comment>
            <comment type="line">// if the response depends on the value of the "Cookie" header, then</comment>
            <comment type="line">// bail since we do not store cookies in the cache.  this is done</comment>
            <comment type="line">// for the following reasons:</comment>
            <comment type="line">//</comment>
            <comment type="line">//   1- cookies can be very large in size</comment>
            <comment type="line">//</comment>
            <comment type="line">//   2- cookies may contain sensitive information.  (for parity with</comment>
            <comment type="line">//      out policy of not storing Set-cookie headers in the cache</comment>
            <comment type="line">//      meta data, we likewise do not want to store cookie headers</comment>
            <comment type="line">//      here.)</comment>
            <comment type="line">//</comment>
            <comment type="line">// this implementation is obviously not fully standards compliant, but</comment>
            <comment type="line">// it is perhaps most prudent given the above issues.</comment>
            <comment type="line">//</comment>
            <if>if <condition>(<expr>(*<name>token</name> == '*') || (<call><name>PL_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"cookie"</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then>
            <else>else <block>{
                <comment type="line">// build cache meta data key...</comment>
                <expr_stmt><expr><name>metaKey</name> = <name>prefix</name> + <call><name>nsDependentCString</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// check the last value of the given request header to see if it has</comment>
                <comment type="line">// since changed.  if so, then indeed the cached response is invalid.</comment>
                <decl_stmt><decl><type><name>nsXPIDLCString</name></type> <name>lastVal</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>mCacheEntry</name>-&gt;<name>GetMetaDataElement</name></name><argument_list>(<argument><expr><call><name><name>metaKey</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>lastVal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>lastVal</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>nsHttpAtom</name></type> <name>atom</name> <init>= <expr><call><name><name>nsHttp</name>::<name>ResolveAtom</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>newVal</name> <init>= <expr><call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>newVal</name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>, <argument><expr><name>lastVal</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>result</name> = <name>PR_TRUE</name></expr>;</expr_stmt> <comment type="line">// yes, response would vary</comment>
                        <break>break;</break>
                    }</block></then></if>
                }</block></then></if>
                
                <comment type="line">// next token...</comment>
                <expr_stmt><expr><name>token</name> = <call><name><name>nsCRT</name>::<name>strtok</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>NS_HTTP_HEADER_SEPS</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>
    }</block></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel &lt;byte-range&gt;</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>SetupByteRangeRequest</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>partialLen</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// cached content has been found to be partial, add necessary request</comment>
    <comment type="line">// headers to complete cache entry.</comment>

    <comment type="line">// use strongest validator available...</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr><call><name><name>mCachedResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>ETag</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>val</name></expr>)</condition><then>
        <expr_stmt><expr><name>val</name> = <call><name><name>mCachedResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Last_Modified</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>!<name>val</name></expr>)</condition><then> <block>{
        <comment type="line">// if we hit this code it means mCachedResponseHead-&gt;IsResumable() is</comment>
        <comment type="line">// either broken or not being called.</comment>
        <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"no cache validator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PR_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"bytes=%u-"</expr></argument>, <argument><expr><name>partialLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Range</name></name></expr></argument>, <argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_Range</name></name></expr></argument>, <argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ProcessPartialContent</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// ok, we've just received a 206</comment>
    <comment type="line">//</comment>
    <comment type="line">// we need to stream whatever data is in the cache out first, and then</comment>
    <comment type="line">// pick up whatever data is on the wire, writing it into the cache.</comment>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ProcessPartialContent [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt> 

    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mCachedResponseHead</name></expr></argument>, <argument><expr><name>NS_ERROR_NOT_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mCacheEntry</name></expr></argument>, <argument><expr><name>NS_ERROR_NOT_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Make sure to clear bogus content-encodings before looking at the header</comment>
    <expr_stmt><expr><call><name>ClearBogusContentEncodingIfNeeded</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <comment type="line">// Check if the content-encoding we now got is different from the one we</comment>
    <comment type="line">// got before</comment>
    <if>if <condition>(<expr><call><name>PL_strcasecmp</name><argument_list>(<argument><expr><call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Encoding</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name><name>mCachedResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                      != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_ERROR_INVALID_CONTENT_ENCODING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>CallOnStartRequest</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>


    <comment type="line">// suspend the current transaction</comment>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mTransactionPump</name>-&gt;<name>Suspend</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// merge any new headers with the cached response headers</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCachedResponseHead</name>-&gt;<name>UpdateHeaders</name></name><argument_list>(<argument><expr><call><name><name>mResponseHead</name>-&gt;<name>Headers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// update the cached response head</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>head</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mCachedResponseHead</name>-&gt;<name>Flatten</name></name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>SetMetaDataElement</name></name><argument_list>(<argument><expr>"response-head"</expr></argument>, <argument><expr><call><name><name>head</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// make the cached response be the current response</comment>
    <expr_stmt><expr>delete <name>mResponseHead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mResponseHead</name> = <name>mCachedResponseHead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCachedResponseHead</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>UpdateExpirationTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// notify observers interested in looking at a response that has been</comment>
    <comment type="line">// merged with any cached headers (http-on-examine-merged-response).</comment>
    <expr_stmt><expr><call><name><name>gHttpHandler</name>-&gt;<name>OnExamineMergedResponse</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// the cached content is valid, although incomplete.</comment>
    <expr_stmt><expr><name>mCachedContentIsValid</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><call><name>ReadFromCache</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>OnDoneReadingPartialCacheEntry</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>streamDone</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::OnDoneReadingPartialCacheEntry [this=%p]", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// by default, assume we would have streamed all data or failed...</comment>
    <expr_stmt><expr>*<name>streamDone</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <comment type="line">// setup cache listener to append to cache entry</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>size</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>GetDataSize</name></name><argument_list>(<argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>InstallCacheListener</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// need to track the logical offset of the data being sent to our listener</comment>
    <expr_stmt><expr><name>mLogicalOffset</name> = <name>size</name></expr>;</expr_stmt>

    <comment type="line">// we're now completing the cached content, so we can clear this flag.</comment>
    <comment type="line">// this puts us in the state of a regular download.</comment>
    <expr_stmt><expr><name>mCachedContentIsPartial</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <comment type="line">// resume the transaction if it exists, otherwise the pipe contained the</comment>
    <comment type="line">// remaining part of the document and we've now streamed all of the data.</comment>
    <if>if <condition>(<expr><name>mTransactionPump</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>mTransactionPump</name>-&gt;<name>Resume</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*<name>streamDone</name> = <name>PR_FALSE</name></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else
        <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"no transaction"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel &lt;cache&gt;</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ProcessNotModified</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ProcessNotModified [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt> 

    <if>if <condition>(<expr><name>mCustomConditionalRequest</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Bypassing ProcessNotModified due to custom conditional headers")</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mCachedResponseHead</name></expr></argument>, <argument><expr><name>NS_ERROR_NOT_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mCacheEntry</name></expr></argument>, <argument><expr><name>NS_ERROR_NOT_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// merge any new headers with the cached response headers</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCachedResponseHead</name>-&gt;<name>UpdateHeaders</name></name><argument_list>(<argument><expr><call><name><name>mResponseHead</name>-&gt;<name>Headers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// update the cached response head</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>head</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mCachedResponseHead</name>-&gt;<name>Flatten</name></name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>SetMetaDataElement</name></name><argument_list>(<argument><expr>"response-head"</expr></argument>, <argument><expr><call><name><name>head</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// make the cached response be the current response</comment>
    <expr_stmt><expr>delete <name>mResponseHead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mResponseHead</name> = <name>mCachedResponseHead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCachedResponseHead</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>UpdateExpirationTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// notify observers interested in looking at a reponse that has been</comment>
    <comment type="line">// merged with any cached headers</comment>
    <expr_stmt><expr><call><name><name>gHttpHandler</name>-&gt;<name>OnExamineMergedResponse</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mCachedContentIsValid</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>ReadFromCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mTransactionReplaced</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ProcessFallback</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>fallingBack</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ProcessFallback [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>fallingBack</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <comment type="line">// At this point a load has failed (either due to network problems</comment>
    <comment type="line">// or an error returned on the server).  Perform an application</comment>
    <comment type="line">// cache fallback if we have a URI to fall back to.</comment>
    <if>if <condition>(<expr>!<name>mApplicationCache</name> || <call><name><name>mFallbackKey</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> || <name>mFallbackChannel</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  choosing not to fallback [%p,%s,%d]",
             <call><name><name>mApplicationCache</name>.<name>get</name></name><argument_list>()</argument_list></call>, <call><name><name>mFallbackKey</name>.<name>get</name></name><argument_list>()</argument_list></call>, <name>mFallbackChannel</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// Make sure the fallback entry hasn't been marked as a foreign</comment>
    <comment type="line">// entry.</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>fallbackEntryType</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mApplicationCache</name>-&gt;<name>GetTypes</name></name><argument_list>(<argument><expr><name>mFallbackKey</name></expr></argument>, <argument><expr>&amp;<name>fallbackEntryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>fallbackEntryType</name> &amp; <name><name>nsIApplicationCache</name>::<name>ITEM_FOREIGN</name></name></expr>)</condition><then> <block>{
        <comment type="line">// This cache points to a fallback that refers to a different</comment>
        <comment type="line">// manifest.  Refuse to fall back.</comment>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>fallbackEntryType</name> &amp; <name><name>nsIApplicationCache</name>::<name>ITEM_FALLBACK</name></name></expr></argument>,
                 <argument><expr>"Fallback entry not marked correctly!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Kill any opportunistic cache entry, and disable opportunistic</comment>
    <comment type="line">// caching for the fallback.</comment>
    <if>if <condition>(<expr><name>mOfflineCacheEntry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mOfflineCacheEntry</name>-&gt;<name>Doom</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mOfflineCacheEntry</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>mOfflineCacheAccess</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>mCacheForOfflineUse</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCachingOpportunistically</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mOfflineCacheClientID</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mOfflineCacheEntry</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>mOfflineCacheAccess</name> = 0</expr>;</expr_stmt>

    <comment type="line">// Close the current cache entry.</comment>
    <if>if <condition>(<expr><name>mCacheEntry</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>CloseCacheEntry</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// Create a new channel to load the fallback entry.</comment>
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsIChannel</name></expr></argument>&gt;</argument_list></name></type> <name>newChannel</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;<name>NewChannel</name></name><argument_list>(<argument><expr><name>mURI</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>SetupReplacementChannel</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>, <argument><expr><name>newChannel</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Make sure the new channel loads from the fallback key.</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIHttpChannelInternal</name></expr></argument>&gt;</argument_list></name></type> <name>httpInternal</name> <init>=
        <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name><name>httpInternal</name>-&gt;<name>SetupFallbackChannel</name></name><argument_list>(<argument><expr><call><name><name>mFallbackKey</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// ... and fallbacks should only load from the cache.</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>newLoadFlags</name> <init>= <expr><name>mLoadFlags</name> | <name>LOAD_REPLACE</name> | <name>LOAD_ONLY_FROM_CACHE</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>newChannel</name>-&gt;<name>SetLoadFlags</name></name><argument_list>(<argument><expr><name>newLoadFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Inform consumers about this fake redirect</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>redirectFlags</name> <init>= <expr><name><name>nsIChannelEventSink</name>::<name>REDIRECT_INTERNAL</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;<name>OnChannelRedirect</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>newChannel</name></expr></argument>, <argument><expr><name>redirectFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// Make sure to do this _after_ calling OnChannelRedirect</comment>
    <expr_stmt><expr><call><name><name>newChannel</name>-&gt;<name>SetOriginalURI</name></name><argument_list>(<argument><expr><name>mOriginalURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>rv</name> = <call><name><name>newChannel</name>-&gt;<name>AsyncOpen</name></name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// close down this channel</comment>
    <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_BINDING_REDIRECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// disconnect from our listener</comment>
    <expr_stmt><expr><name>mListener</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>mListenerContext</name> = 0</expr>;</expr_stmt>
    <comment type="line">// and from our callbacks</comment>
    <expr_stmt><expr><name>mCallbacks</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mProgressSink</name> = <name>nsnull</name></expr>;</expr_stmt>

    <expr_stmt><expr>*<name>fallingBack</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Determines if a request is a byte range request for a subrange,</comment>
<comment type="line">// i.e. is a byte range request, but not a 0- byte range request.</comment>
<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>IsSubRangeRequest</name><parameter_list>(<param><decl><type><name>nsHttpRequestHead</name> &amp;</type><name>aRequestHead</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name><name>aRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Range</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>byteRange</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aRequestHead</name>.<name>GetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Range</name></name></expr></argument>, <argument><expr><name>byteRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>!<call><name><name>byteRange</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"bytes=0-"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>OpenCacheEntry</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>offline</name></decl></param>, <param><decl><type><name>PRBool</name> *</type><name>delayed</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>delayed</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mLoadedFromApplicationCache</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::OpenCacheEntry [this=%p]", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// make sure we're not abusing this function</comment>
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mCacheEntry</name></expr></argument>, <argument><expr>"cache entry already open"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>cacheKey</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Post</name></name></expr>)</condition><then> <block>{
        <comment type="line">// If the post id is already set then this is an attempt to replay</comment>
        <comment type="line">// a post transaction via the cache.  Otherwise, we need a unique</comment>
        <comment type="line">// post id for this transaction.</comment>
        <if>if <condition>(<expr><name>mPostID</name> == 0</expr>)</condition><then>
            <expr_stmt><expr><name>mPostID</name> = <call><name><name>gHttpHandler</name>-&gt;<name>GenerateUniqueID</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr>(<call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> != <name><name>nsHttp</name>::<name>Get</name></name>) &amp;&amp;
             (<call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> != <name><name>nsHttp</name>::<name>Head</name></name>)</expr>)</condition><then> <block>{
        <comment type="line">// don't use the cache for other types of requests</comment>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><name>mResuming</name></expr>)</condition><then> <block>{
        <comment type="line">// We don't support caching for requests initiated</comment>
        <comment type="line">// via nsIResumableChannel.</comment>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// Don't cache byte range requests which are subranges, only cache 0-</comment>
    <comment type="line">// byte range requests.</comment>
    <if>if <condition>(<expr><call><name>IsSubRangeRequest</name><argument_list>(<argument><expr><name>mRequestHead</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>GenerateCacheKey</name><argument_list>(<argument><expr><name>mPostID</name></expr></argument>, <argument><expr><name>cacheKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Get a cache session with appropriate storage policy</comment>
    <decl_stmt><decl><type><name>nsCacheStoragePolicy</name></type> <name>storagePolicy</name> <init>= <expr><call><name>DetermineStoragePolicy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Set the desired cache access mode accordingly...</comment>
    <decl_stmt><decl><type><name>nsCacheAccessMode</name></type> <name>accessRequested</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>offline</name> || (<name>mLoadFlags</name> &amp; <name>INHIBIT_CACHING</name>)</expr>)</condition><then> <block>{
        <comment type="line">// If we have been asked to bypass the cache and not write to the</comment>
        <comment type="line">// cache, then don't use the cache at all.  Unless we're actually</comment>
        <comment type="line">// offline, which takes precedence over BYPASS_LOCAL_CACHE.</comment>
        <if>if <condition>(<expr><call><name>BYPASS_LOCAL_CACHE</name><argument_list>(<argument><expr><name>mLoadFlags</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>offline</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>accessRequested</name> = <name><name>nsICache</name>::<name>ACCESS_READ</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>BYPASS_LOCAL_CACHE</name><argument_list>(<argument><expr><name>mLoadFlags</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>accessRequested</name> = <name><name>nsICache</name>::<name>ACCESS_WRITE</name></name></expr>;</expr_stmt></then> <comment type="line">// replace cache entry</comment>
    <else>else
        <expr_stmt><expr><name>accessRequested</name> = <name><name>nsICache</name>::<name>ACCESS_READ_WRITE</name></name></expr>;</expr_stmt></else></if></else></if> <comment type="line">// normal browsing</comment>

    <if>if <condition>(<expr>!<name>mApplicationCache</name> &amp;&amp; <name>mInheritApplicationCache</name></expr>)</condition><then> <block>{
        <comment type="line">// Pick up an application cache from the notification</comment>
        <comment type="line">// callbacks if available</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIApplicationCacheContainer</name></expr></argument>&gt;</argument_list></name></type> <name>appCacheContainer</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GetCallback</name><argument_list>(<argument><expr><name>appCacheContainer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>appCacheContainer</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>appCacheContainer</name>-&gt;<name>GetApplicationCache</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mApplicationCache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>mApplicationCache</name> &amp;&amp;
        (<name>mChooseApplicationCache</name> || (<name>mLoadFlags</name> &amp; <name>LOAD_CHECK_OFFLINE_CACHE</name>))</expr>)</condition><then> <block>{
        <comment type="line">// We're supposed to load from an application cache, but</comment>
        <comment type="line">// one was not supplied by the load group.  Ask the</comment>
        <comment type="line">// application cache service to choose one for us.</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIApplicationCacheService</name></expr></argument>&gt;</argument_list></name></type> <name>appCacheService</name> <init>=
            <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_APPLICATIONCACHESERVICE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>appCacheService</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>appCacheService</name>-&gt;<name>ChooseApplicationCache</name></name>
                <argument_list>(<argument><expr><name>cacheKey</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mApplicationCache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICacheSession</name></expr></argument>&gt;</argument_list></name></type> <name>session</name></decl>;</decl_stmt>

    <comment type="line">// Will be set to true if we've found the right session, but need</comment>
    <comment type="line">// to open the cache entry asynchronously.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>waitingForValidation</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// If we have an application cache, we check it first.</comment>
    <if>if <condition>(<expr><name>mApplicationCache</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>appCacheClientID</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mApplicationCache</name>-&gt;<name>GetClientID</name></name><argument_list>(<argument><expr><name>appCacheClientID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICacheService</name></expr></argument>&gt;</argument_list></name></type> <name>serv</name> <init>=
            <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_CACHESERVICE_CONTRACTID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name><name>serv</name>-&gt;<name>CreateSession</name></name><argument_list>(<argument><expr><call><name><name>appCacheClientID</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                 <argument><expr><name><name>nsICache</name>::<name>STORE_OFFLINE</name></name></expr></argument>,
                                 <argument><expr><name><name>nsICache</name>::<name>STREAM_BASED</name></name></expr></argument>,
                                 <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// we'll try to synchronously open the cache entry... however,</comment>
        <comment type="line">// it may be in use and not yet validated, in which case we'll</comment>
        <comment type="line">// try asynchronously opening the cache entry.</comment>
        <comment type="line">//</comment>
        <comment type="line">// We open with ACCESS_READ only, because we don't want to</comment>
        <comment type="line">// overwrite the offline cache entry non-atomically.</comment>
        <comment type="line">// ACCESS_READ will prevent us from writing to the offline</comment>
        <comment type="line">// cache as a normal cache entry.</comment>
        <expr_stmt><expr><name>rv</name> = <call><name><name>session</name>-&gt;<name>OpenCacheEntry</name></name><argument_list>(<argument><expr><name>cacheKey</name></expr></argument>,
                                     <argument><expr><name><name>nsICache</name>::<name>ACCESS_READ</name></name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                     <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mCacheEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> == <name>NS_ERROR_CACHE_WAIT_FOR_VALIDATION</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>accessRequested</name> = <name><name>nsICache</name>::<name>ACCESS_READ</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>waitingForValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>mCacheForOfflineUse</name> &amp;&amp; !<name>mFallbackChannel</name></expr>)</condition><then> <block>{
            <comment type="line">// Check for namespace match.</comment>
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIApplicationCacheNamespace</name></expr></argument>&gt;</argument_list></name></type> <name>namespaceEntry</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name><name>mApplicationCache</name>-&gt;<name>GetMatchingNamespace</name></name>
                <argument_list>(<argument><expr><name>cacheKey</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>namespaceEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>PRUint32</name></type> <name>namespaceType</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>namespaceEntry</name> ||
                <call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name><name>namespaceEntry</name>-&gt;<name>GetItemType</name></name><argument_list>(<argument><expr>&amp;<name>namespaceType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> ||
                (<name>namespaceType</name> &amp;
                 (<name><name>nsIApplicationCacheNamespace</name>::<name>NAMESPACE_FALLBACK</name></name> |
                  <name><name>nsIApplicationCacheNamespace</name>::<name>NAMESPACE_OPPORTUNISTIC</name></name> |
                  <name><name>nsIApplicationCacheNamespace</name>::<name>NAMESPACE_BYPASS</name></name>)) == 0</expr>)</condition><then> <block>{
                <comment type="line">// When loading from an application cache, only items</comment>
                <comment type="line">// on the whitelist or matching a</comment>
                <comment type="line">// fallback/opportunistic namespace should hit the</comment>
                <comment type="line">// network...</comment>
                <expr_stmt><expr><name>mLoadFlags</name> |= <name>LOAD_ONLY_FROM_CACHE</name></expr>;</expr_stmt>

                <comment type="line">// ... and if there were an application cache entry,</comment>
                <comment type="line">// we would have found it earlier.</comment>
                <return>return <expr><name>NS_ERROR_CACHE_KEY_NOT_FOUND</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>namespaceType</name> &amp;
                <name><name>nsIApplicationCacheNamespace</name>::<name>NAMESPACE_FALLBACK</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name><name>namespaceEntry</name>-&gt;<name>GetData</name></name><argument_list>(<argument><expr><name>mFallbackKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr>(<name>namespaceType</name> &amp;
                 <name><name>nsIApplicationCacheNamespace</name>::<name>NAMESPACE_OPPORTUNISTIC</name></name>) &amp;&amp;
                <name>mLoadFlags</name> &amp; <name>LOAD_DOCUMENT_URI</name></expr>)</condition><then> <block>{
                <comment type="line">// Document loads for items in an opportunistic namespace</comment>
                <comment type="line">// should be placed in the offline cache.</comment>
                <decl_stmt><decl><type><name>nsCString</name></type> <name>clientID</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>mApplicationCache</name>-&gt;<name>GetClientID</name></name><argument_list>(<argument><expr><name>clientID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>mCacheForOfflineUse</name> = !<call><name><name>clientID</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SetOfflineCacheClientID</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>mCachingOpportunistically</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// We successfully opened an offline cache session and the entry,</comment>
            <comment type="line">// now indiciate we load from the offline cache.</comment>
            <expr_stmt><expr><name>mLoadedFromApplicationCache</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>mCacheEntry</name> &amp;&amp; !<name>waitingForValidation</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;<name>GetCacheSession</name></name><argument_list>(<argument><expr><name>storagePolicy</name></expr></argument>,
                                           <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name><name>session</name>-&gt;<name>OpenCacheEntry</name></name><argument_list>(<argument><expr><name>cacheKey</name></expr></argument>, <argument><expr><name>accessRequested</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                     <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mCacheEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> == <name>NS_ERROR_CACHE_WAIT_FOR_VALIDATION</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>waitingForValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <name>NS_OK</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>waitingForValidation</name></expr>)</condition><then> <block>{
        <comment type="line">// access to the cache entry has been denied (because the</comment>
        <comment type="line">// cache entry is probably in use by another channel).</comment>
        <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_BYPASS_LOCAL_CACHE_IF_BUSY</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("bypassing local cache since it is busy\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>rv</name> = <call><name><name>session</name>-&gt;<name>AsyncOpenCacheEntry</name></name><argument_list>(<argument><expr><name>cacheKey</name></expr></argument>, <argument><expr><name>accessRequested</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
        <comment type="line">// we'll have to wait for the cache entry</comment>
        <expr_stmt><expr>*<name>delayed</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mCacheEntry</name>-&gt;<name>GetAccessGranted</name></name><argument_list>(<argument><expr>&amp;<name>mCacheAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::OpenCacheEntry [this=%p grantedAccess=%d]", <name>this</name>, <name>mCacheAccess</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>OpenOfflineCacheEntryForWriting</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::OpenOfflineCacheEntryForWriting [this=%p]", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// make sure we're not abusing this function</comment>
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>!<name>mOfflineCacheEntry</name></expr></argument>, <argument><expr>"cache entry already open"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>offline</name> <init>= <expr><call><name><name>gIOService</name>-&gt;<name>IsOffline</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>offline</name></expr>)</condition><then> <block>{
        <comment type="line">// only put things in the offline cache while online</comment>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> != <name><name>nsHttp</name>::<name>Get</name></name></expr>)</condition><then> <block>{
        <comment type="line">// only cache complete documents offline</comment>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// Don't cache byte range requests which are subranges, only cache 0-</comment>
    <comment type="line">// byte range requests.</comment>
    <if>if <condition>(<expr><call><name>IsSubRangeRequest</name><argument_list>(<argument><expr><name>mRequestHead</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>cacheKey</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GenerateCacheKey</name><argument_list>(<argument><expr><name>mPostID</name></expr></argument>, <argument><expr><name>cacheKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<call><name><name>mOfflineCacheClientID</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></argument>,
                   <argument><expr><name>NS_ERROR_NOT_AVAILABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICacheSession</name></expr></argument>&gt;</argument_list></name></type> <name>session</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICacheService</name></expr></argument>&gt;</argument_list></name></type> <name>serv</name> <init>=
        <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_CACHESERVICE_CONTRACTID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>serv</name>-&gt;<name>CreateSession</name></name><argument_list>(<argument><expr><call><name><name>mOfflineCacheClientID</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                             <argument><expr><name><name>nsICache</name>::<name>STORE_OFFLINE</name></name></expr></argument>,
                             <argument><expr><name><name>nsICache</name>::<name>STREAM_BASED</name></name></expr></argument>,
                             <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>session</name>-&gt;<name>OpenCacheEntry</name></name><argument_list>(<argument><expr><name>cacheKey</name></expr></argument>, <argument><expr><name><name>nsICache</name>::<name>ACCESS_READ_WRITE</name></name></expr></argument>,
                                 <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mOfflineCacheEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>rv</name> == <name>NS_ERROR_CACHE_WAIT_FOR_VALIDATION</name></expr>)</condition><then> <block>{
        <comment type="line">// access to the cache entry has been denied (because the cache entry</comment>
        <comment type="line">// is probably in use by another channel).  Either the cache is being</comment>
        <comment type="line">// read from (we're offline) or it's being updated elsewhere.</comment>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mOfflineCacheEntry</name>-&gt;<name>GetAccessGranted</name></name><argument_list>(<argument><expr>&amp;<name>mOfflineCacheAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("got offline cache entry [access=%x]\n", <name>mOfflineCacheAccess</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>GenerateCacheKey</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>postID</name></decl></param>, <param><decl><type><name>nsACString</name> &amp;</type><name>cacheKey</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>cacheKey</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_ANONYMOUS</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>cacheKey</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"anon&amp;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>postID</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PR_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"id=%x&amp;"</expr></argument>, <argument><expr><name>postID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cacheKey</name>.<name>Append</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name><name>cacheKey</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>cacheKey</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>"uri="</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Strip any trailing #ref from the URL before using it as the key</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>spec</name> <init>= <expr><name>mFallbackChannel</name> ? <call><name><name>mFallbackKey</name>.<name>get</name></name><argument_list>()</argument_list></call> : <call><name><name>mSpec</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>spec</name></expr></argument>, <argument><expr>'#'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>p</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>cacheKey</name>.<name>Append</name></name><argument_list>(<argument><expr><name>spec</name></expr></argument>, <argument><expr><name>p</name> - <name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name><name>cacheKey</name>.<name>Append</name></name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// UpdateExpirationTime is called when a new response comes in from the server.</comment>
<comment type="line">// It updates the stored response-time and sets the expiration time on the</comment>
<comment type="line">// cache entry.  </comment>
<comment type="line">//</comment>
<comment type="line">// From section 13.2.4 of RFC2616, we compute expiration time as follows:</comment>
<comment type="line">//</comment>
<comment type="line">//    timeRemaining = freshnessLifetime - currentAge</comment>
<comment type="line">//    expirationTime = now + timeRemaining</comment>
<comment type="line">// </comment>
<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>UpdateExpirationTime</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mResponseHead</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>expirationTime</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>mResponseHead</name>-&gt;<name>MustValidate</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>freshnessLifetime</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name><name>mResponseHead</name>-&gt;<name>ComputeFreshnessLifetime</name></name><argument_list>(<argument><expr>&amp;<name>freshnessLifetime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name>freshnessLifetime</name> &gt; 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PRUint32</name></type> <name>now</name> <init>= <expr><call><name>NowInSeconds</name><argument_list>()</argument_list></call></expr></init>, <name>currentAge</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>rv</name> = <call><name><name>mResponseHead</name>-&gt;<name>ComputeCurrentAge</name></name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>mRequestTime</name></expr></argument>, <argument><expr>&amp;<name>currentAge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("freshnessLifetime = %u, currentAge = %u\n",
                <name>freshnessLifetime</name>, <name>currentAge</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>freshnessLifetime</name> &gt; <name>currentAge</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>PRUint32</name></type> <name>timeRemaining</name> <init>= <expr><name>freshnessLifetime</name> - <name>currentAge</name></expr></init></decl>;</decl_stmt>
                <comment type="line">// be careful... now + timeRemaining may overflow</comment>
                <if>if <condition>(<expr><name>now</name> + <name>timeRemaining</name> &lt; <name>now</name></expr>)</condition><then>
                    <expr_stmt><expr><name>expirationTime</name> = <call><name>PRUint32</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><name>expirationTime</name> = <name>now</name> + <name>timeRemaining</name></expr>;</expr_stmt></else></if>
            }</block></then>
            <else>else
                <expr_stmt><expr><name>expirationTime</name> = <name>now</name></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>SetExpirationTime</name></name><argument_list>(<argument><expr><name>expirationTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mOfflineCacheEntry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>mOfflineCacheEntry</name>-&gt;<name>SetExpirationTime</name></name><argument_list>(<argument><expr><name>expirationTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// CheckCache is called from Connect after a cache entry has been opened for</comment>
<comment type="line">// this URL but before going out to net.  It's purpose is to set or clear the </comment>
<comment type="line">// mCachedContentIsValid flag, and to configure an If-Modified-Since request</comment>
<comment type="line">// if validation is required.</comment>
<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>CheckCache</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHTTPChannel::CheckCache enter [this=%p entry=%p access=%d]",
        <name>this</name>, <call><name><name>mCacheEntry</name>.<name>get</name></name><argument_list>()</argument_list></call>, <name>mCacheAccess</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="line">// Be pessimistic: assume the cache entry has no useful data.</comment>
    <expr_stmt><expr><name>mCachedContentIsValid</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <comment type="line">// Don't proceed unless we have opened a cache entry for reading.</comment>
    <if>if <condition>(<expr>!<name>mCacheEntry</name> || !(<name>mCacheAccess</name> &amp; <name><name>nsICache</name>::<name>ACCESS_READ</name></name>)</expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsXPIDLCString</name></type> <name>buf</name></decl>;</decl_stmt>

    <comment type="line">// Get the method that was used to generate the cached response</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>GetMetaDataElement</name></name><argument_list>(<argument><expr>"request-method"</expr></argument>, <argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsHttpAtom</name></type> <name>method</name> <init>= <expr><call><name><name>nsHttp</name>::<name>ResolveAtom</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>method</name> == <name><name>nsHttp</name>::<name>Head</name></name></expr>)</condition><then> <block>{
        <comment type="line">// The cached response does not contain an entity.  We can only reuse</comment>
        <comment type="line">// the response if the current request is also HEAD.</comment>
        <if>if <condition>(<expr><call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> != <name><name>nsHttp</name>::<name>Head</name></name></expr>)</condition><then>
            <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>buf</name>.<name>Adopt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We'll need this value in later computations...</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>lastModifiedTime</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>GetLastModified</name></name><argument_list>(<argument><expr>&amp;<name>lastModifiedTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Determine if this is the first time that this cache entry</comment>
    <comment type="line">// has been accessed during this session.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>fromPreviousSession</name> <init>=
            <expr>(<call><name><name>gHttpHandler</name>-&gt;<name>SessionStartTime</name></name><argument_list>()</argument_list></call> &gt; <name>lastModifiedTime</name>)</expr></init></decl>;</decl_stmt>

    <comment type="line">// Get the cached HTTP response headers</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>GetMetaDataElement</name></name><argument_list>(<argument><expr>"response-head"</expr></argument>, <argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Parse the cached HTTP response headers</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mCachedResponseHead</name></expr></argument>, <argument><expr>"memory leak detected"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCachedResponseHead</name> = new <call><name>nsHttpResponseHead</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mCachedResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCachedResponseHead</name>-&gt;<name>Parse</name></name><argument_list>(<argument><expr>(<name>char</name> *) <call><name><name>buf</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>buf</name>.<name>Adopt</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Don't bother to validate items that are read-only,</comment>
    <comment type="line">// unless they are read-only because of INHIBIT_CACHING or because</comment>
    <comment type="line">// we're updating the offline cache.</comment>
    <comment type="line">// Don't bother to validate if this is a fallback entry.</comment>
    <if>if <condition>(<expr>!<name>mCacheForOfflineUse</name> &amp;&amp;
        (<name>mLoadedFromApplicationCache</name> ||
         (<name>mCacheAccess</name> == <name><name>nsICache</name>::<name>ACCESS_READ</name></name> &amp;&amp;
          !(<name>mLoadFlags</name> &amp; <name>INHIBIT_CACHING</name>)) ||
         <name>mFallbackChannel</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mCachedContentIsValid</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRUint16</name></type> <name>isCachedRedirect</name> <init>= <expr><call><name><name>mCachedResponseHead</name>-&gt;<name>Status</name></name><argument_list>()</argument_list></call>/100 == 3</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>method</name> != <name><name>nsHttp</name>::<name>Head</name></name> &amp;&amp; !<name>isCachedRedirect</name></expr>)</condition><then> <block>{
        <comment type="line">// If the cached content-length is set and it does not match the data</comment>
        <comment type="line">// size of the cached content, then the cached response is partial...</comment>
        <comment type="line">// either we need to issue a byte range request or we need to refetch</comment>
        <comment type="line">// the entire document.</comment>
        <decl_stmt><decl><type><name>nsInt64</name></type> <name>contentLength</name> <init>= <expr><call><name><name>mCachedResponseHead</name>-&gt;<name>ContentLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>contentLength</name> != <call><name>nsInt64</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PRUint32</name></type> <name>size</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>GetDataSize</name></name><argument_list>(<argument><expr>&amp;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name>nsInt64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> != <name>contentLength</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Cached data size does not match the Content-Length header "
                     "[content-length=%lld size=%u]\n", <call><name>PRInt64</name><argument_list>(<argument><expr><name>contentLength</name></expr></argument>)</argument_list></call>, <name>size</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>(<call><name>nsInt64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> &lt; <name>contentLength</name>) &amp;&amp; <call><name><name>mCachedResponseHead</name>-&gt;<name>IsResumable</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="line">// looks like a partial entry.</comment>
                    <expr_stmt><expr><name>rv</name> = <call><name>SetupByteRangeRequest</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>mCachedContentIsPartial</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
                }</block></then></if>
                <return>return <expr><name>NS_OK</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>doValidation</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>canAddImsHeader</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>mCustomConditionalRequest</name> = 
        <call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_Modified_Since</name></name></expr></argument>)</argument_list></call> ||
        <call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_None_Match</name></name></expr></argument>)</argument_list></call> ||
        <call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_Unmodified_Since</name></name></expr></argument>)</argument_list></call> ||
        <call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_Match</name></name></expr></argument>)</argument_list></call> ||
        <call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_Range</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If the LOAD_FROM_CACHE flag is set, any cached data can simply be used.</comment>
    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_FROM_CACHE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("NOT validating based on LOAD_FROM_CACHE load flag\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>doValidation</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    }</block></then>
    <comment type="line">// If the VALIDATE_ALWAYS flag is set, any cached data won't be used until</comment>
    <comment type="line">// it's revalidated with the server.</comment>
    <else>else <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>VALIDATE_ALWAYS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Validating based on VALIDATE_ALWAYS load flag\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>doValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then>
    <comment type="line">// Even if the VALIDATE_NEVER flag is set, there are still some cases in</comment>
    <comment type="line">// which we must validate the cached response with the server.</comment>
    <else>else <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>VALIDATE_NEVER</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("VALIDATE_NEVER set\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// if no-store or if no-cache and ssl, validate cached response (see</comment>
        <comment type="line">// bug 112564 for an explanation of this logic)</comment>
        <if>if <condition>(<expr><call><name><name>mCachedResponseHead</name>-&gt;<name>NoStore</name></name><argument_list>()</argument_list></call> ||
           (<call><name><name>mCachedResponseHead</name>-&gt;<name>NoCache</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>mConnectionInfo</name>-&gt;<name>UsingSSL</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Validating based on (no-store || (no-cache &amp;&amp; ssl)) logic\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>doValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("NOT validating based on VALIDATE_NEVER load flag\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>doValidation</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <comment type="line">// check if validation is strictly required...</comment>
    <else>else <if>if <condition>(<expr><call><name><name>mCachedResponseHead</name>-&gt;<name>MustValidate</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Validating based on MustValidate() returning TRUE\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>doValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then>

    <else>else <if>if <condition>(<expr><call><name>ResponseWouldVary</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Validating based on Vary headers returning TRUE\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>canAddImsHeader</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>doValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then>
    
    <else>else <if>if <condition>(<expr><call><name>MustValidateBasedOnQueryUrl</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Validating based on RFC 2616 section 13.9 "
             "(query-url w/o explicit expiration-time)\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>doValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then>
    <comment type="line">// Check if the cache entry has expired...</comment>
    <else>else <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>time</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">// a temporary variable for storing time values...</comment>

        <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>GetExpirationTime</name></name><argument_list>(<argument><expr>&amp;<name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>NowInSeconds</name><argument_list>()</argument_list></call> &lt;= <name>time</name></expr>)</condition><then>
            <expr_stmt><expr><name>doValidation</name> = <name>PR_FALSE</name></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><call><name><name>mCachedResponseHead</name>-&gt;<name>MustValidateIfExpired</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>doValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>VALIDATE_ONCE_PER_SESSION</name></expr>)</condition><then> <block>{
            <comment type="line">// If the cached response does not include expiration infor-</comment>
            <comment type="line">// mation, then we must validate the response, despite whether</comment>
            <comment type="line">// or not this is the first access this session.  This behavior</comment>
            <comment type="line">// is consistent with existing browsers and is generally expected</comment>
            <comment type="line">// by web authors.</comment>
            <expr_stmt><expr><name>rv</name> = <call><name><name>mCachedResponseHead</name>-&gt;<name>ComputeFreshnessLifetime</name></name><argument_list>(<argument><expr>&amp;<name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>time</name> == 0</expr>)</condition><then>
                <expr_stmt><expr><name>doValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><name>doValidation</name> = <name>fromPreviousSession</name></expr>;</expr_stmt></else></if>
        }</block></then>
        <else>else
            <expr_stmt><expr><name>doValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt></else></if></else></if></else></if>

        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("%salidating based on expiration time\n", <name>doValidation</name> ? "V" : "Not v")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if></else></if></else></if>

    <if>if <condition>(<expr>!<name>doValidation</name> &amp;&amp; <call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_Match</name></name></expr></argument>)</argument_list></call> &amp;&amp;
        (<name>method</name> == <name><name>nsHttp</name>::<name>Get</name></name> || <name>method</name> == <name><name>nsHttp</name>::<name>Head</name></name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>requestedETag</name></decl>, *<decl><type ref="prev"/><name>cachedETag</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>cachedETag</name> = <call><name><name>mCachedResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>ETag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>requestedETag</name> = <call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_Match</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>cachedETag</name> &amp;&amp; (!<call><name>strncmp</name><argument_list>(<argument><expr><name>cachedETag</name></expr></argument>, <argument><expr>"W/"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> ||
            <call><name>strcmp</name><argument_list>(<argument><expr><name>requestedETag</name></expr></argument>, <argument><expr><name>cachedETag</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <comment type="line">// User has defined If-Match header, if the cached entry is not </comment>
            <comment type="line">// matching the provided header value or the cached ETag is weak,</comment>
            <comment type="line">// force validation.</comment>
            <expr_stmt><expr><name>doValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>doValidation</name></expr>)</condition><then> <block>{
        <comment type="line">//</comment>
        <comment type="line">// Check the authorization headers used to generate the cache entry.</comment>
        <comment type="line">// We must validate the cache entry if:</comment>
        <comment type="line">//</comment>
        <comment type="line">// 1) the cache entry was generated prior to this session w/</comment>
        <comment type="line">//    credentials (see bug 103402).</comment>
        <comment type="line">// 2) the cache entry was generated w/o credentials, but would now</comment>
        <comment type="line">//    require credentials (see bug 96705).</comment>
        <comment type="line">//</comment>
        <comment type="line">// NOTE: this does not apply to proxy authentication.</comment>
        <comment type="line">//</comment>
        <expr_stmt><expr><call><name><name>mCacheEntry</name>-&gt;<name>GetMetaDataElement</name></name><argument_list>(<argument><expr>"auth"</expr></argument>, <argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>doValidation</name> =
            (<name>fromPreviousSession</name> &amp;&amp; !<call><name><name>buf</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call>) ||
            (<call><name><name>buf</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Authorization</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>doValidation</name></expr>)</condition><then> <block>{
        <comment type="line">// Sites redirect back to the original URI after setting a session/tracking</comment>
        <comment type="line">// cookie. In such cases, force revalidation so that we hit the net and do not</comment>
        <comment type="line">// cycle thru cached responses.</comment>
        <if>if <condition>(<expr><name>isCachedRedirect</name> &amp;&amp; <call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Cookie</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>doValidation</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>mCachedContentIsValid</name> = !<name>doValidation</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>doValidation</name></expr>)</condition><then> <block>{
        <comment type="line">//</comment>
        <comment type="line">// now, we are definitely going to issue a HTTP request to the server.</comment>
        <comment type="line">// make it conditional if possible.</comment>
        <comment type="line">//</comment>
        <comment type="line">// do not attempt to validate no-store content, since servers will not</comment>
        <comment type="line">// expect it to be cached.  (we only keep it in our cache for the</comment>
        <comment type="line">// purposes of back/forward, etc.)</comment>
        <comment type="line">//</comment>
        <comment type="line">// the request method MUST be either GET or HEAD (see bug 175641).</comment>
        <comment type="line">//</comment>
        <comment type="line">// do not override conditional headers when consumer has defined its own</comment>
        <if>if <condition>(<expr>!<call><name><name>mCachedResponseHead</name>-&gt;<name>NoStore</name></name><argument_list>()</argument_list></call> &amp;&amp;
            (<call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Get</name></name> ||
             <call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Head</name></name>) &amp;&amp;
             !<name>mCustomConditionalRequest</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl>;</decl_stmt>
            <comment type="line">// Add If-Modified-Since header if a Last-Modified was given</comment>
            <comment type="line">// and we are allowed to do this (see bugs 510359 and 269303)</comment>
            <if>if <condition>(<expr><name>canAddImsHeader</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>val</name> = <call><name><name>mCachedResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Last_Modified</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>val</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_Modified_Since</name></name></expr></argument>,
                                           <argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then></if>
            <comment type="line">// Add If-None-Match header if an ETag was given in the response</comment>
            <expr_stmt><expr><name>val</name> = <call><name><name>mCachedResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>ETag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>val</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>If_None_Match</name></name></expr></argument>,
                                       <argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHTTPChannel::CheckCache exit [this=%p doValidation=%d]\n", <name>this</name>, <name>doValidation</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsHttpChannel</name>::<name>MustValidateBasedOnQueryUrl</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// RFC 2616, section 13.9 states that GET-requests with a query-url</comment>
    <comment type="line">// MUST NOT be treated as fresh unless the server explicitly provides</comment>
    <comment type="line">// an expiration-time in the response. See bug #468594</comment>
    <comment type="line">// Section 13.2.1 (6th paragraph) defines "explicit expiration time"</comment>
    <if>if <condition>(<expr><call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Get</name></name></expr>)</condition><then>
    <block>{
        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>query</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURL</name></expr></argument>&gt;</argument_list></name></type> <name>url</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>url</name>-&gt;<name>GetQuery</name></name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>query</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PRUint32</name></type> <name>tmp</name></decl>;</decl_stmt> <comment type="line">// we don't need the value, just whether it's set</comment>
            <expr_stmt><expr><name>rv</name> = <call><name><name>mCachedResponseHead</name>-&gt;<name>GetExpiresValue</name></name><argument_list>(<argument><expr>&amp;<name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name><name>mCachedResponseHead</name>-&gt;<name>GetMaxAgeValue</name></name><argument_list>(<argument><expr>&amp;<name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>PR_TRUE</name></expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ShouldUpdateOfflineCacheEntry</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>shouldCacheForOfflineUse</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>shouldCacheForOfflineUse</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>mOfflineCacheEntry</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// if we're updating the cache entry, update the offline cache entry too</comment>
    <if>if <condition>(<expr><name>mCacheEntry</name> &amp;&amp; (<name>mCacheAccess</name> &amp; <name><name>nsICache</name>::<name>ACCESS_WRITE</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>shouldCacheForOfflineUse</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// if there's nothing in the offline cache, add it</comment>
    <if>if <condition>(<expr><name>mOfflineCacheEntry</name> &amp;&amp; (<name>mOfflineCacheAccess</name> == <name><name>nsICache</name>::<name>ACCESS_WRITE</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>shouldCacheForOfflineUse</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// if the document is newer than the offline entry, update it</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>docLastModifiedTime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mResponseHead</name>-&gt;<name>GetLastModifiedValue</name></name><argument_list>(<argument><expr>&amp;<name>docLastModifiedTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>shouldCacheForOfflineUse</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>offlineLastModifiedTime</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mOfflineCacheEntry</name>-&gt;<name>GetLastModified</name></name><argument_list>(<argument><expr>&amp;<name>offlineLastModifiedTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>docLastModifiedTime</name> &gt; <name>offlineLastModifiedTime</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>shouldCacheForOfflineUse</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// If the data in the cache hasn't expired, then there's no need to</comment>
<comment type="line">// talk with the server, not even to do an if-modified-since.  This</comment>
<comment type="line">// method creates a stream from the cache, synthesizing all the various</comment>
<comment type="line">// channel-related events.</comment>
<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ReadFromCache</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mCacheEntry</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mCachedContentIsValid</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ReadFromCache [this=%p] "
         "Using cached copy of: %s\n", <name>this</name>, <call><name><name>mSpec</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mCachedResponseHead</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mResponseHead</name></expr></argument>, <argument><expr>"memory leak"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mResponseHead</name> = <name>mCachedResponseHead</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mCachedResponseHead</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// if we don't already have security info, try to get it from the cache </comment>
    <comment type="line">// entry. there are two cases to consider here: 1) we are just reading</comment>
    <comment type="line">// from the cache, or 2) this may be due to a 304 not modified response,</comment>
    <comment type="line">// in which case we could have security info from a socket transport.</comment>
    <if>if <condition>(<expr>!<name>mSecurityInfo</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mCacheEntry</name>-&gt;<name>GetSecurityInfo</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mSecurityInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>(<name>mCacheAccess</name> &amp; <name><name>nsICache</name>::<name>ACCESS_WRITE</name></name>) &amp;&amp; !<name>mCachedContentIsPartial</name></expr>)</condition><then> <block>{
        <comment type="line">// We have write access to the cache, but we don't need to go to the</comment>
        <comment type="line">// server to validate at this time, so just mark the cache entry as</comment>
        <comment type="line">// valid in order to allow others access to this cache entry.</comment>
        <expr_stmt><expr><call><name><name>mCacheEntry</name>-&gt;<name>MarkValid</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// if this is a cached redirect, we must process the redirect asynchronously</comment>
    <comment type="line">// since AsyncOpen may not have returned yet.  Make sure there is a Location</comment>
    <comment type="line">// header, otherwise we'll have to treat this like a normal 200 response.</comment>
    <if>if <condition>(<expr><name>mResponseHead</name> &amp;&amp; (<call><name><name>mResponseHead</name>-&gt;<name>Status</name></name><argument_list>()</argument_list></call> / 100 == 3) 
                      &amp;&amp; (<call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Location</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>AsyncCall</name><argument_list>(<argument><expr>&amp;<name><name>nsHttpChannel</name>::<name>HandleAsyncRedirect</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="line">// have we been configured to skip reading from the cache?</comment>
    <if>if <condition>(<expr>(<name>mLoadFlags</name> &amp; <name>LOAD_ONLY_IF_MODIFIED</name>) &amp;&amp; !<name>mCachedContentIsPartial</name></expr>)</condition><then> <block>{
        <comment type="line">// if offline caching has been requested and the offline cache needs</comment>
        <comment type="line">// updating, complete the call even if the main cache entry is</comment>
        <comment type="line">// up-to-date</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>shouldUpdateOffline</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>mCacheForOfflineUse</name> ||
            <call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name>ShouldUpdateOfflineCacheEntry</name><argument_list>(<argument><expr>&amp;<name>shouldUpdateOffline</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> ||
            !<name>shouldUpdateOffline</name></expr>)</condition><then> <block>{

            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("skipping read from cache based on LOAD_ONLY_IF_MODIFIED "
                 "load flag\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>AsyncCall</name><argument_list>(<argument><expr>&amp;<name><name>nsHttpChannel</name>::<name>HandleAsyncNotModified</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// open input stream for reading...</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIInputStream</name></expr></argument>&gt;</argument_list></name></type> <name>stream</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>OpenInputStream</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>nsInputStreamPump</name>::<name>Create</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mCachePump</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>stream</name></expr></argument>, <argument><expr><call><name>nsInt64</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>nsInt64</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                   <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><call><name><name>mCachePump</name>-&gt;<name>AsyncRead</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>CloseCacheEntry</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>doomOnFailure</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mCacheEntry</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::CloseCacheEntry [this=%p] mStatus=%x mCacheAccess=%x",
         <name>this</name>, <name>mStatus</name>, <name>mCacheAccess</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If we have begun to create or replace a cache entry, and that cache</comment>
    <comment type="line">// entry is not complete and not resumable, then it needs to be doomed.</comment>
    <comment type="line">// Otherwise, CheckCache will make the mistake of thinking that the</comment>
    <comment type="line">// partial cache entry is complete.</comment>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>doom</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>mInitedCacheEntry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mResponseHead</name></expr></argument>, <argument><expr>"oops"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call> &amp;&amp; <name>doomOnFailure</name> &amp;&amp;
            (<name>mCacheAccess</name> &amp; <name><name>nsICache</name>::<name>ACCESS_WRITE</name></name>) &amp;&amp;
            !<call><name><name>mResponseHead</name>-&gt;<name>IsResumable</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>doom</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>mCacheAccess</name> == <name><name>nsICache</name>::<name>ACCESS_WRITE</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>doom</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if></else></if>

    <if>if <condition>(<expr><name>doom</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  dooming cache entry!!")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mCacheEntry</name>-&gt;<name>Doom</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>mCachedResponseHead</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name>mCachedResponseHead</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mCachedResponseHead</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>mCachePump</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>mCacheEntry</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>mCacheAccess</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>mInitedCacheEntry</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>CloseOfflineCacheEntry</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mOfflineCacheEntry</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::CloseOfflineCacheEntry [this=%p]", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mOfflineCacheEntry</name>-&gt;<name>Doom</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>succeeded</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name>GetRequestSucceeded</name><argument_list>(<argument><expr>&amp;<name>succeeded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; !<name>succeeded</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mOfflineCacheEntry</name>-&gt;<name>Doom</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

    <expr_stmt><expr><name>mOfflineCacheEntry</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>mOfflineCacheAccess</name> = 0</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mCachingOpportunistically</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIApplicationCacheService</name></expr></argument>&gt;</argument_list></name></type> <name>appCacheService</name> <init>=
            <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_APPLICATIONCACHESERVICE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>appCacheService</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>cacheKey</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>GenerateCacheKey</name><argument_list>(<argument><expr><name>mPostID</name></expr></argument>, <argument><expr><name>cacheKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>appCacheService</name>-&gt;<name>CacheOpportunistically</name></name><argument_list>(<argument><expr><name>mApplicationCache</name></expr></argument>,
                                                    <argument><expr><name>cacheKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
}</block></function>


<comment type="line">// Initialize the cache entry for writing.</comment>
<comment type="line">//  - finalize storage policy</comment>
<comment type="line">//  - store security info</comment>
<comment type="line">//  - update expiration time</comment>
<comment type="line">//  - store headers and other meta data</comment>
<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>InitCacheEntry</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mCacheEntry</name></expr></argument>, <argument><expr><name>NS_ERROR_UNEXPECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// if only reading, nothing to be done here.</comment>
    <if>if <condition>(<expr><name>mCacheAccess</name> == <name><name>nsICache</name>::<name>ACCESS_READ</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <comment type="line">// Don't cache the response again if already cached...</comment>
    <if>if <condition>(<expr><name>mCachedContentIsValid</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::InitCacheEntry [this=%p entry=%p]\n",
        <name>this</name>, <call><name><name>mCacheEntry</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// The no-store directive within the 'Cache-Control:' header indicates</comment>
    <comment type="line">// that we must not store the response in a persistent cache.</comment>
    <if>if <condition>(<expr><call><name><name>mResponseHead</name>-&gt;<name>NoStore</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>mLoadFlags</name> |= <name>INHIBIT_PERSISTENT_CACHING</name></expr>;</expr_stmt></then></if>

    <comment type="line">// Only cache SSL content on disk if the pref is set</comment>
    <if>if <condition>(<expr>!<call><name><name>gHttpHandler</name>-&gt;<name>IsPersistentHttpsCachingEnabled</name></name><argument_list>()</argument_list></call> &amp;&amp;
        <call><name><name>mConnectionInfo</name>-&gt;<name>UsingSSL</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>mLoadFlags</name> |= <name>INHIBIT_PERSISTENT_CACHING</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>INHIBIT_PERSISTENT_CACHING</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>SetStoragePolicy</name></name><argument_list>(<argument><expr><name><name>nsICache</name>::<name>STORE_IN_MEMORY</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>

    <comment type="line">// Set the expiration time for this cache entry</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>UpdateExpirationTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>AddCacheEntryHeaders</name><argument_list>(<argument><expr><name>mCacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mInitedCacheEntry</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>InitOfflineCacheEntry</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// This function can be called even when we fail to connect (bug 551990)</comment>

    <if>if <condition>(<expr>!<name>mOfflineCacheEntry</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>mResponseHead</name> &amp;&amp; <call><name><name>mResponseHead</name>-&gt;<name>NoStore</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>CloseOfflineCacheEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// This entry's expiration time should match the main entry's expiration</comment>
    <comment type="line">// time.  UpdateExpirationTime() will keep it in sync once the offline</comment>
    <comment type="line">// cache entry has been created.</comment>
    <if>if <condition>(<expr><name>mCacheEntry</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>expirationTime</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>mCacheEntry</name>-&gt;<name>GetExpirationTime</name></name><argument_list>(<argument><expr>&amp;<name>expirationTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>mOfflineCacheEntry</name>-&gt;<name>SetExpirationTime</name></name><argument_list>(<argument><expr><name>expirationTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><call><name>AddCacheEntryHeaders</name><argument_list>(<argument><expr><name>mOfflineCacheEntry</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>AddCacheEntryHeaders</name></name><parameter_list>(<param><decl><type><name>nsICacheEntryDescriptor</name> *</type><name>entry</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="line">// Store secure data in memory only</comment>
    <if>if <condition>(<expr><name>mSecurityInfo</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>entry</name>-&gt;<name>SetSecurityInfo</name></name><argument_list>(<argument><expr><name>mSecurityInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// Store the HTTP request method with the cache entry so we can distinguish</comment>
    <comment type="line">// for example GET and HEAD responses.</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>entry</name>-&gt;<name>SetMetaDataElement</name></name><argument_list>(<argument><expr>"request-method"</expr></argument>,
                                   <argument><expr><call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// Store the HTTP authorization scheme used if any...</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>StoreAuthorizationMetaData</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// Iterate over the headers listed in the Vary response header, and</comment>
    <comment type="line">// store the value of the corresponding request header so we can verify</comment>
    <comment type="line">// that it has not varied when we try to re-use the cached response at</comment>
    <comment type="line">// a later time.  Take care not to store "Cookie" headers though.  We</comment>
    <comment type="line">// take care of "Vary: cookie" in ResponseWouldVary.</comment>
    <comment type="line">//</comment>
    <comment type="line">// NOTE: if "Vary: accept, cookie", then we will store the "accept" header</comment>
    <comment type="line">// in the cache.  we could try to avoid needlessly storing the "accept"</comment>
    <comment type="line">// header in this case, but it doesn't seem worth the extra code to perform</comment>
    <comment type="line">// the check.</comment>
    <block>{
        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>buf</name></decl>, <decl><type ref="prev"/><name>metaKey</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mResponseHead</name>-&gt;<name>GetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Vary</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>buf</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NS_NAMED_LITERAL_CSTRING</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr>"request-"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
           
            <decl_stmt><decl><type><name>char</name> *</type><name>val</name> <init>= <expr><call><name><name>buf</name>.<name>BeginWriting</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// going to munge buf</comment>
            <decl_stmt><decl><type><name>char</name> *</type><name>token</name> <init>= <expr><call><name><name>nsCRT</name>::<name>strtok</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>NS_HTTP_HEADER_SEPS</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>token</name></expr>)</condition> <block>{
                <if>if <condition>(<expr>(*<name>token</name> != '*') &amp;&amp; (<call><name>PL_strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"cookie"</expr></argument>)</argument_list></call> != 0)</expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>nsHttpAtom</name></type> <name>atom</name> <init>= <expr><call><name><name>nsHttp</name>::<name>ResolveAtom</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>requestVal</name> <init>= <expr><call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>requestVal</name></expr>)</condition><then> <block>{
                        <comment type="line">// build cache meta data key and set meta data element...</comment>
                        <expr_stmt><expr><name>metaKey</name> = <name>prefix</name> + <call><name>nsDependentCString</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>entry</name>-&gt;<name>SetMetaDataElement</name></name><argument_list>(<argument><expr><call><name><name>metaKey</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>requestVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>token</name> = <call><name><name>nsCRT</name>::<name>strtok</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>NS_HTTP_HEADER_SEPS</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>
    }</block>


    <comment type="line">// Store the received HTTP head with the cache entry as an element of</comment>
    <comment type="line">// the meta data.</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>head</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mResponseHead</name>-&gt;<name>Flatten</name></name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>entry</name>-&gt;<name>SetMetaDataElement</name></name><argument_list>(<argument><expr>"response-head"</expr></argument>, <argument><expr><call><name><name>head</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>inline</specifier> <name>void</name></type>
<name>GetAuthType</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>challenge</name></decl></param>, <param><decl><type><name>nsCString</name> &amp;</type><name>authType</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>

    <comment type="line">// get the challenge type</comment>
    <if>if <condition>(<expr>(<name>p</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>challenge</name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call>) != <name>nsnull</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>authType</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>challenge</name></expr></argument>, <argument><expr><name>p</name> - <name>challenge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name><name>authType</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>challenge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>StoreAuthorizationMetaData</name></name><parameter_list>(<param><decl><type><name>nsICacheEntryDescriptor</name> *</type><name>entry</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Not applicable to proxy authorization...</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr><call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Authorization</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>val</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <comment type="line">// eg. [Basic realm="wally world"]</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>buf</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetAuthType</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>entry</name>-&gt;<name>SetMetaDataElement</name></name><argument_list>(<argument><expr>"auth"</expr></argument>, <argument><expr><call><name><name>buf</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Finalize the cache entry</comment>
<comment type="line">//  - may need to rewrite response headers if any headers changed</comment>
<comment type="line">//  - may need to recalculate the expiration time if any headers changed</comment>
<comment type="line">//  - called only for freshly written cache entries</comment>
<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>FinalizeCacheEntry</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::FinalizeCacheEntry [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mResponseHead</name> &amp;&amp; <name>mResponseHeadersModified</name></expr>)</condition><then> <block>{
        <comment type="line">// Set the expiration time for this cache entry</comment>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>UpdateExpirationTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">// Open an output stream to the cache entry and insert a listener tee into</comment>
<comment type="line">// the chain of response listeners.</comment>
<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>InstallCacheListener</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>offset</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Preparing to write data into the cache [uri=%s]\n", <call><name><name>mSpec</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mCacheEntry</name></expr></argument>, <argument><expr>"no cache entry"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr>"no listener"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIOutputStream</name></expr></argument>&gt;</argument_list></name></type> <name>out</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>OpenOutputStream</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// XXX disk cache does not support overlapped i/o yet</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
    <comment type="line">// Mark entry valid inorder to allow simultaneous reading...</comment>
    rv = mCacheEntry-&gt;MarkValid();
    if (NS_FAILED(rv)) return rv;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStreamListenerTee</name></expr></argument>&gt;</argument_list></name></type> <name>tee</name> <init>=
        <expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>kStreamListenerTeeCID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsCacheStoragePolicy</name></type> <name>policy</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mCacheEntry</name>-&gt;<name>GetStoragePolicy</name></name><argument_list>(<argument><expr>&amp;<name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>gHttpHandler</name>-&gt;<name>mCacheWriteThread</name></name> ||
         <call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> ||
         <name>policy</name> == <name><name>nsICache</name>::<name>STORE_ON_DISK_AS_FILE</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::InstallCacheListener sync tee %p\n", <call><name><name>tee</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>tee</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::InstallCacheListener async tee %p\n",
                <call><name><name>tee</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>tee</name>-&gt;<name>InitAsync</name></name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr><name><name>gHttpHandler</name>-&gt;<name>mCacheWriteThread</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
   
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    <expr_stmt><expr><name>mListener</name> = <name>tee</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>InstallOfflineCacheListener</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Preparing to write data into the offline cache [uri=%s]\n",
         <call><name><name>mSpec</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mOfflineCacheEntry</name></expr></argument>, <argument><expr>"no offline cache entry"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr>"no listener"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIOutputStream</name></expr></argument>&gt;</argument_list></name></type> <name>out</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mOfflineCacheEntry</name>-&gt;<name>OpenOutputStream</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStreamListenerTee</name></expr></argument>&gt;</argument_list></name></type> <name>tee</name> <init>=
        <expr><call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>kStreamListenerTeeCID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>tee</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mListener</name> = <name>tee</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>ClearBogusContentEncodingIfNeeded</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// For .gz files, apache sends both a Content-Type: application/x-gzip</comment>
    <comment type="line">// as well as Content-Encoding: gzip, which is completely wrong.  In</comment>
    <comment type="line">// this case, we choose to ignore the rogue Content-Encoding header. We</comment>
    <comment type="line">// must do this early on so as to prevent it from being seen up stream.</comment>
    <comment type="line">// The same problem exists for Content-Encoding: compress in default</comment>
    <comment type="line">// Apache installs.</comment>
    <if>if <condition>(<expr><call><name><name>mResponseHead</name>-&gt;<name>HasHeaderValue</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Encoding</name></name></expr></argument>, <argument><expr>"gzip"</expr></argument>)</argument_list></call> &amp;&amp; (
        <call><name><name>mResponseHead</name>-&gt;<name>ContentType</name></name><argument_list>()</argument_list></call>.<call><name>EqualsLiteral</name><argument_list>(<argument><expr><name>APPLICATION_GZIP</name></expr></argument>)</argument_list></call> ||
        <call><name><name>mResponseHead</name>-&gt;<name>ContentType</name></name><argument_list>()</argument_list></call>.<call><name>EqualsLiteral</name><argument_list>(<argument><expr><name>APPLICATION_GZIP2</name></expr></argument>)</argument_list></call> ||
        <call><name><name>mResponseHead</name>-&gt;<name>ContentType</name></name><argument_list>()</argument_list></call>.<call><name>EqualsLiteral</name><argument_list>(<argument><expr><name>APPLICATION_GZIP3</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <comment type="line">// clear the Content-Encoding header</comment>
        <expr_stmt><expr><call><name><name>mResponseHead</name>-&gt;<name>ClearHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name><name>mResponseHead</name>-&gt;<name>HasHeaderValue</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Encoding</name></name></expr></argument>, <argument><expr>"compress"</expr></argument>)</argument_list></call> &amp;&amp; (
             <call><name><name>mResponseHead</name>-&gt;<name>ContentType</name></name><argument_list>()</argument_list></call>.<call><name>EqualsLiteral</name><argument_list>(<argument><expr><name>APPLICATION_COMPRESS</name></expr></argument>)</argument_list></call> ||
             <call><name><name>mResponseHead</name>-&gt;<name>ContentType</name></name><argument_list>()</argument_list></call>.<call><name>EqualsLiteral</name><argument_list>(<argument><expr><name>APPLICATION_COMPRESS2</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <comment type="line">// clear the Content-Encoding header</comment>
        <expr_stmt><expr><call><name><name>mResponseHead</name>-&gt;<name>ClearHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel &lt;redirect&gt;</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><specifier>static</specifier> <name>PLDHashOperator</name></type>
<name>CopyProperties</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aKey</name></decl></param>, <param><decl><type><name>nsIVariant</name> *</type><name>aData</name></decl></param>, <param><decl><type><name>void</name> *</type><name>aClosure</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsIWritablePropertyBag</name>*</type> <name>bag</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIWritablePropertyBag</name>*</expr></argument>&gt;</argument_list></name>
                                             <argument_list>(<argument><expr><name>aClosure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>bag</name>-&gt;<name>SetProperty</name></name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PL_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>SetupReplacementChannel</name></name><parameter_list>(<param><decl><type><name>nsIURI</name>       *</type><name>newURI</name></decl></param>, 
                                       <param><decl><type><name>nsIChannel</name>   *</type><name>newChannel</name></decl></param>,
                                       <param><decl><type><name>PRBool</name></type>        <name>preserveMethod</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::SetupReplacementChannel "
         "[this=%p newChannel=%p preserveMethod=%d]",
         <name>this</name>, <name>newChannel</name>, <name>preserveMethod</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>newLoadFlags</name> <init>= <expr><name>mLoadFlags</name> | <name>LOAD_REPLACE</name></expr></init></decl>;</decl_stmt>
    <comment type="line">// if the original channel was using SSL and this channel is not using</comment>
    <comment type="line">// SSL, then no need to inhibit persistent caching.  however, if the</comment>
    <comment type="line">// original channel was not using SSL and has INHIBIT_PERSISTENT_CACHING</comment>
    <comment type="line">// set, then allow the flag to apply to the redirected channel as well.</comment>
    <comment type="line">// since we force set INHIBIT_PERSISTENT_CACHING on all HTTPS channels,</comment>
    <comment type="line">// we only need to check if the original channel was using SSL.</comment>
    <if>if <condition>(<expr><call><name><name>mConnectionInfo</name>-&gt;<name>UsingSSL</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>newLoadFlags</name> &amp;= ~<name>INHIBIT_PERSISTENT_CACHING</name></expr>;</expr_stmt></then></if>

    <comment type="line">// Do not pass along LOAD_CHECK_OFFLINE_CACHE</comment>
    <expr_stmt><expr><name>newLoadFlags</name> &amp;= ~<name>LOAD_CHECK_OFFLINE_CACHE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>newChannel</name>-&gt;<name>SetLoadGroup</name></name><argument_list>(<argument><expr><name>mLoadGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name><name>newChannel</name>-&gt;<name>SetNotificationCallbacks</name></name><argument_list>(<argument><expr><name>mCallbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>newChannel</name>-&gt;<name>SetLoadFlags</name></name><argument_list>(<argument><expr><name>newLoadFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIHttpChannel</name></expr></argument>&gt;</argument_list></name></type> <name>httpChannel</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>httpChannel</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if> <comment type="line">// no other options to set</comment>

    <if>if <condition>(<expr><name>preserveMethod</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIUploadChannel</name></expr></argument>&gt;</argument_list></name></type> <name>uploadChannel</name> <init>=
            <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>httpChannel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIUploadChannel2</name></expr></argument>&gt;</argument_list></name></type> <name>uploadChannel2</name> <init>=
            <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>httpChannel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>mUploadStream</name> &amp;&amp; (<name>uploadChannel2</name> || <name>uploadChannel</name>)</expr>)</condition><then> <block>{
            <comment type="line">// rewind upload stream</comment>
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISeekableStream</name></expr></argument>&gt;</argument_list></name></type> <name>seekable</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mUploadStream</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>seekable</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>seekable</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <comment type="line">// replicate original call to SetUploadStream...</comment>
            <if>if <condition>(<expr><name>uploadChannel2</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ctype</name> <init>= <expr><call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>ctype</name></expr>)</condition><then>
                    <expr_stmt><expr><name>ctype</name> = ""</expr>;</expr_stmt></then></if>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>clen</name>  <init>= <expr><call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PRInt64</name></type> <name>len</name> <init>= <expr><name>clen</name> ? <call><name><name>nsCRT</name>::<name>atoll</name></name><argument_list>(<argument><expr><name>clen</name></expr></argument>)</argument_list></call> : -1</expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>uploadChannel2</name>-&gt;<name>ExplicitSetUploadStream</name></name><argument_list>(
                        <argument><expr><name>mUploadStream</name></expr></argument>,
                        <argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>len</name></expr></argument>,
                        <argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>mUploadStreamHasHeaders</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <if>if <condition>(<expr><name>mUploadStreamHasHeaders</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>uploadChannel</name>-&gt;<name>SetUploadStream</name></name><argument_list>(<argument><expr><name>mUploadStream</name></expr></argument>, <argument><expr><call><name>EmptyCString</name><argument_list>()</argument_list></call></expr></argument>,
                                                   <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <block>{
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ctype</name> <init>=
                        <expr><call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>clen</name> <init>=
                        <expr><call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<name>ctype</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>ctype</name> = "application/octet-stream"</expr>;</expr_stmt>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>clen</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name><name>uploadChannel</name>-&gt;<name>SetUploadStream</name></name><argument_list>(<argument><expr><name>mUploadStream</name></expr></argument>,
                                                       <argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>
            }</block></else></if>
        }</block></then></if>
        <comment type="line">// since preserveMethod is true, we need to ensure that the appropriate </comment>
        <comment type="line">// request method gets set on the channel, regardless of whether or not </comment>
        <comment type="line">// we set the upload stream above. This means SetRequestMethod() will</comment>
        <comment type="line">// be called twice if ExplicitSetUploadStream() gets called above.</comment>

        <expr_stmt><expr><call><name><name>httpChannel</name>-&gt;<name>SetRequestMethod</name></name><argument_list>(<argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// convey the referrer if one was used for this channel to the next one</comment>
    <if>if <condition>(<expr><name>mReferrer</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>httpChannel</name>-&gt;<name>SetReferrer</name></name><argument_list>(<argument><expr><name>mReferrer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <comment type="line">// convey the mAllowPipelining flag</comment>
    <expr_stmt><expr><call><name><name>httpChannel</name>-&gt;<name>SetAllowPipelining</name></name><argument_list>(<argument><expr><name>mAllowPipelining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// convey the new redirection limit</comment>
    <expr_stmt><expr><call><name><name>httpChannel</name>-&gt;<name>SetRedirectionLimit</name></name><argument_list>(<argument><expr><name>mRedirectionLimit</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIHttpChannelInternal</name></expr></argument>&gt;</argument_list></name></type> <name>httpInternal</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>httpInternal</name></expr>)</condition><then> <block>{
        <comment type="line">// convey the mForceAllowThirdPartyCookie flag</comment>
        <expr_stmt><expr><call><name><name>httpInternal</name>-&gt;<name>SetForceAllowThirdPartyCookie</name></name><argument_list>(<argument><expr><name>mForceAllowThirdPartyCookie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// update the DocumentURI indicator since we are being redirected.</comment>
        <comment type="line">// if this was a top-level document channel, then the new channel</comment>
        <comment type="line">// should have its mDocumentURI point to newURI; otherwise, we</comment>
        <comment type="line">// just need to pass along our mDocumentURI to the new channel.</comment>
        <if>if <condition>(<expr><name>newURI</name> &amp;&amp; (<name>mURI</name> == <name>mDocumentURI</name>)</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>httpInternal</name>-&gt;<name>SetDocumentURI</name></name><argument_list>(<argument><expr><name>newURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>httpInternal</name>-&gt;<name>SetDocumentURI</name></name><argument_list>(<argument><expr><name>mDocumentURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if> 
    
    <comment type="line">// convey the mApplyConversion flag (bug 91862)</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIEncodedChannel</name></expr></argument>&gt;</argument_list></name></type> <name>encodedChannel</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>httpChannel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>encodedChannel</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>encodedChannel</name>-&gt;<name>SetApplyConversion</name></name><argument_list>(<argument><expr><name>mApplyConversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// transfer the resume information</comment>
    <if>if <condition>(<expr><name>mResuming</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIResumableChannel</name></expr></argument>&gt;</argument_list></name></type> <name>resumableChannel</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>resumableChannel</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Got asked to resume, but redirected to non-resumable channel!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_NOT_RESUMABLE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>resumableChannel</name>-&gt;<name>ResumeAt</name></name><argument_list>(<argument><expr><name>mStartPos</name></expr></argument>, <argument><expr><name>mEntityID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// transfer application cache information</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIApplicationCacheChannel</name></expr></argument>&gt;</argument_list></name></type> <name>appCacheChannel</name> <init>=
        <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>appCacheChannel</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>appCacheChannel</name>-&gt;<name>SetApplicationCache</name></name><argument_list>(<argument><expr><name>mApplicationCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>appCacheChannel</name>-&gt;<name>SetInheritApplicationCache</name></name><argument_list>(<argument><expr><name>mInheritApplicationCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// We purposely avoid transfering mChooseApplicationCache.</comment>
    }</block></then></if>

    <comment type="line">// transfer any properties</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIWritablePropertyBag</name></expr></argument>&gt;</argument_list></name></type> <name>bag</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>bag</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mPropertyHash</name>.<name>EnumerateRead</name></name><argument_list>(<argument><expr><name>CopyProperties</name></expr></argument>, <argument><expr><call><name><name>bag</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ProcessRedirection</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>redirectType</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ProcessRedirection [this=%p type=%u]\n",
        <name>this</name>, <name>redirectType</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>location</name> <init>= <expr><call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Location</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// if a location header was not given, then we can't perform the redirect,</comment>
    <comment type="line">// so just carry on as though this were a normal response.</comment>
    <if>if <condition>(<expr>!<name>location</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <comment type="line">// make sure non-ASCII characters in the location header are escaped.</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>locationBuf</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_EscapeURL</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>esc_OnlyNonASCII</name></expr></argument>, <argument><expr><name>locationBuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>location</name> = <call><name><name>locationBuf</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>mRedirectionLimit</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("redirection limit reached!\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// this error code is fatal, and should be conveyed to our listener.</comment>
        <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_ERROR_REDIRECT_LOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_REDIRECT_LOOP</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("redirecting to: %s [redirection-limit=%u]\n",
        <name>location</name>, <call><name>PRUint32</name><argument_list>(<argument><expr><name>mRedirectionLimit</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIChannel</name></expr></argument>&gt;</argument_list></name></type> <name>newChannel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>newURI</name></decl>;</decl_stmt>

    <comment type="line">// create a new URI using the location header and the current URL</comment>
    <comment type="line">// as a base...</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIIOService</name></expr></argument>&gt;</argument_list></name></type> <name>ioService</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;<name>GetIOService</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>ioService</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// the new uri should inherit the origin charset of the current uri</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>originCharset</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetOriginCharset</name></name><argument_list>(<argument><expr><name>originCharset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>originCharset</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>ioService</name>-&gt;<name>NewURI</name></name><argument_list>(<argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>originCharset</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mURI</name></expr></argument>,
                           <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>newURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>mApplicationCache</name></expr>)</condition><then> <block>{
        <comment type="line">// if we are redirected to a different origin check if there is a fallback</comment>
        <comment type="line">// cache entry to fall back to. we don't care about file strict </comment>
        <comment type="line">// checking, at least mURI is not a file URI.</comment>
        <if>if <condition>(<expr>!<call><name>NS_SecurityCompareURIs</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>, <argument><expr><name>newURI</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PRBool</name></type> <name>fallingBack</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>ProcessFallback</name><argument_list>(<argument><expr>&amp;<name>fallingBack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>fallingBack</name></expr>)</condition><then> <block>{
                <comment type="line">// do not continue with redirect processing, fallback is in</comment>
                <comment type="line">// progress now.</comment>
                <return>return <expr><name>NS_OK</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// Kill the current cache entry if we are redirecting</comment>
    <comment type="line">// back to ourself.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>redirectingBackToSameURI</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>mCacheEntry</name> &amp;&amp; (<name>mCacheAccess</name> &amp; <name><name>nsICache</name>::<name>ACCESS_WRITE</name></name>) &amp;&amp;
        <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>mURI</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><name>newURI</name></expr></argument>, <argument><expr>&amp;<name>redirectingBackToSameURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
        <name>redirectingBackToSameURI</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mCacheEntry</name>-&gt;<name>Doom</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// move the reference of the old location to the new one if the new</comment>
    <comment type="line">// one has none.</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURL</name></expr></argument>&gt;</argument_list></name></type> <name>newURL</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>newURI</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>newURL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>ref</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>newURL</name>-&gt;<name>GetRef</name></name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>ref</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURL</name></expr></argument>&gt;</argument_list></name></type> <name>baseURL</name><argument_list>(<argument><expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>baseURL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>baseURL</name>-&gt;<name>GetRef</name></name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name><name>ref</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>newURL</name>-&gt;<name>SetRef</name></name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// if we need to re-send POST data then be sure to ask the user first.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>preserveMethod</name> <init>= <expr>(<name>redirectType</name> == 307)</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>preserveMethod</name> &amp;&amp; <name>mUploadStream</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>PromptTempRedirect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>ioService</name>-&gt;<name>NewChannelFromURI</name></name><argument_list>(<argument><expr><name>newURI</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>SetupReplacementChannel</name><argument_list>(<argument><expr><name>newURI</name></expr></argument>, <argument><expr><name>newChannel</name></expr></argument>, <argument><expr><name>preserveMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>redirectFlags</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>redirectType</name> == 301</expr>)</condition><then> <comment type="line">// Moved Permanently</comment>
        <expr_stmt><expr><name>redirectFlags</name> = <name><name>nsIChannelEventSink</name>::<name>REDIRECT_PERMANENT</name></name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>redirectFlags</name> = <name><name>nsIChannelEventSink</name>::<name>REDIRECT_TEMPORARY</name></name></expr>;</expr_stmt></else></if>

    <comment type="line">// verify that this is a legal redirect</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;<name>OnChannelRedirect</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>newChannel</name></expr></argument>, <argument><expr><name>redirectFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// Make sure to do this _after_ calling OnChannelRedirect</comment>
    <expr_stmt><expr><call><name><name>newChannel</name>-&gt;<name>SetOriginalURI</name></name><argument_list>(<argument><expr><name>mOriginalURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <comment type="line">// And now, the deprecated way</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIHttpEventSink</name></expr></argument>&gt;</argument_list></name></type> <name>httpEventSink</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetCallback</name><argument_list>(<argument><expr><name>httpEventSink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>httpEventSink</name></expr>)</condition><then> <block>{
        <comment type="line">// NOTE: nsIHttpEventSink is only used for compatibility with pre-1.8</comment>
        <comment type="line">// versions.</comment>
        <expr_stmt><expr><name>rv</name> = <call><name><name>httpEventSink</name>-&gt;<name>OnRedirect</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>newChannel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then></if>
    <comment type="line">// XXX we used to talk directly with the script security manager, but that</comment>
    <comment type="line">// should really be handled by the event sink implementation.</comment>

    <comment type="line">// begin loading the new channel</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>newChannel</name>-&gt;<name>AsyncOpen</name></name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// close down this channel</comment>
    <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_BINDING_REDIRECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="line">// disconnect from our listener</comment>
    <expr_stmt><expr><name>mListener</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>mListenerContext</name> = 0</expr>;</expr_stmt>
    <comment type="line">// and from our callbacks</comment>
    <expr_stmt><expr><name>mCallbacks</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mProgressSink</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel &lt;auth&gt;</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<comment type="line">// buf contains "domain\user"</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseUserDomain</name><parameter_list>(<param><decl><type><name>PRUnichar</name> *</type><name>buf</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>PRUnichar</name> **</type><name>user</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>PRUnichar</name> **</type><name>domain</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PRUnichar</name> *</type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr>*<name>p</name> &amp;&amp; *<name>p</name> != '\\'</expr>)</condition> <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt></while>
    <if>if <condition>(<expr>!*<name>p</name></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>domain</name> = <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>user</name> = <name>p</name> + 1</expr>;</expr_stmt>
}</block></function>

<comment type="line">// helper function for setting identity from raw user:pass</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetIdent</name><parameter_list>(<param><decl><type><name>nsHttpAuthIdentity</name> &amp;</type><name>ident</name></decl></param>,
         <param><decl><type><name>PRUint32</name></type> <name>authFlags</name></decl></param>,
         <param><decl><type><name>PRUnichar</name> *</type><name>userBuf</name></decl></param>,
         <param><decl><type><name>PRUnichar</name> *</type><name>passBuf</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name>user</name> <init>= <expr><name>userBuf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name>domain</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>authFlags</name> &amp; <name><name>nsIHttpAuthenticator</name>::<name>IDENTITY_INCLUDES_DOMAIN</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>ParseUserDomain</name><argument_list>(<argument><expr><name>userBuf</name></expr></argument>, <argument><expr>&amp;<name>user</name></expr></argument>, <argument><expr>&amp;<name>domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name><name>ident</name>.<name>Set</name></name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>passBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// helper function for getting an auth prompt from an interface requestor</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetAuthPrompt</name><parameter_list>(<param><decl><type><name>nsIInterfaceRequestor</name> *</type><name>ifreq</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>proxyAuth</name></decl></param>,
              <param><decl><type><name>nsIAuthPrompt2</name> **</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>ifreq</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>promptReason</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>proxyAuth</name></expr>)</condition><then>
        <expr_stmt><expr><name>promptReason</name> = <name><name>nsIAuthPromptProvider</name>::<name>PROMPT_PROXY</name></name></expr>;</expr_stmt></then>
    <else>else 
        <expr_stmt><expr><name>promptReason</name> = <name><name>nsIAuthPromptProvider</name>::<name>PROMPT_NORMAL</name></name></expr>;</expr_stmt></else></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAuthPromptProvider</name></expr></argument>&gt;</argument_list></name></type> <name>promptProvider</name> <init>= <expr><call><name>do_GetInterface</name><argument_list>(<argument><expr><name>ifreq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>promptProvider</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>promptProvider</name>-&gt;<name>GetAuthPrompt</name></name><argument_list>(<argument><expr><name>promptReason</name></expr></argument>,
                                      <argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIAuthPrompt2</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>void</name>**</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name>NS_QueryAuthPrompt2</name><argument_list>(<argument><expr><name>ifreq</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>

<comment type="line">// generate credentials for the given challenge, and update the auth cache.</comment>
<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>GenCredsAndSetEntry</name></name><parameter_list>(<param><decl><type><name>nsIHttpAuthenticator</name> *</type><name>auth</name></decl></param>,
                                   <param><decl><type><name>PRBool</name></type> <name>proxyAuth</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>scheme</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host</name></decl></param>,
                                   <param><decl><type><name>PRInt32</name></type> <name>port</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>directory</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>realm</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>challenge</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>nsHttpAuthIdentity</name> &amp;</type><name>ident</name></decl></param>,
                                   <param><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name> &amp;</type><name>sessionState</name></decl></param>,
                                   <param><decl><type><name>char</name> **</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>authFlags</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name><name>auth</name>-&gt;<name>GetAuthFlags</name></name><argument_list>(<argument><expr>&amp;<name>authFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsISupports</name> *</type><name>ss</name> <init>= <expr><name>sessionState</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// set informations that depend on whether</comment>
    <comment type="line">// we're authenticating against a proxy</comment>
    <comment type="line">// or a webserver</comment>
    <decl_stmt><decl><type><name>nsISupports</name> **</type><name>continuationState</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>proxyAuth</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>continuationState</name> = &amp;<name>mProxyAuthContinuationState</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>continuationState</name> = &amp;<name>mAuthContinuationState</name></expr>;</expr_stmt>
    }</block></else></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>generateFlags</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>auth</name>-&gt;<name>GenerateCredentials</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>,
                                   <argument><expr><name>challenge</name></expr></argument>,
                                   <argument><expr><name>proxyAuth</name></expr></argument>,
                                   <argument><expr><call><name><name>ident</name>.<name>Domain</name></name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><call><name><name>ident</name>.<name>User</name></name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><call><name><name>ident</name>.<name>Password</name></name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr>&amp;<name>ss</name></expr></argument>,
                                   <argument><expr>&amp;*<name>continuationState</name></expr></argument>,
                                   <argument><expr>&amp;<name>generateFlags</name></expr></argument>,
                                   <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>sessionState</name>.<name>swap</name></name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// don't log this in release build since it could contain sensitive info.</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef> 
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("generated creds: %s\n", *<name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// find out if this authenticator allows reuse of credentials and/or</comment>
    <comment type="line">// challenge.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>saveCreds</name> <init>=
        <expr>0 != (<name>authFlags</name> &amp; <name><name>nsIHttpAuthenticator</name>::<name>REUSABLE_CREDENTIALS</name></name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>saveChallenge</name> <init>=
        <expr>0 != (<name>authFlags</name> &amp; <name><name>nsIHttpAuthenticator</name>::<name>REUSABLE_CHALLENGE</name></name>)</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>saveIdentity</name> <init>=
        <expr>0 == (<name>generateFlags</name> &amp; <name><name>nsIHttpAuthenticator</name>::<name>USING_INTERNAL_IDENTITY</name></name>)</expr></init></decl>;</decl_stmt>

    <comment type="line">// this getter never fails</comment>
    <decl_stmt><decl><type><name>nsHttpAuthCache</name> *</type><name>authCache</name> <init>= <expr><call><name><name>gHttpHandler</name>-&gt;<name>AuthCache</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// create a cache entry.  we do this even though we don't yet know that</comment>
    <comment type="line">// these credentials are valid b/c we need to avoid prompting the user</comment>
    <comment type="line">// more than once in case the credentials are valid.</comment>
    <comment type="line">//</comment>
    <comment type="line">// if the credentials are not reusable, then we don't bother sticking</comment>
    <comment type="line">// them in the auth cache.</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>authCache</name>-&gt;<name>SetAuthEntry</name></name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>realm</name></expr></argument>,
                                 <argument><expr><name>saveCreds</name> ? *<name>result</name> : <name>nsnull</name></expr></argument>,
                                 <argument><expr><name>saveChallenge</name> ? <name>challenge</name> : <name>nsnull</name></expr></argument>,
                                 <argument><expr><name>saveIdentity</name> ? &amp;<name>ident</name> : <name>nsnull</name></expr></argument>,
                                 <argument><expr><name>sessionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ProcessAuthentication</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>httpStatus</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ProcessAuthentication [this=%p code=%u]\n",
        <name>this</name>, <name>httpStatus</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_ANONYMOUS</name></expr>)</condition><then> <block>{
      <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>challenges</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>mProxyAuth</name> = (<name>httpStatus</name> == 407)</expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>PrepareForAuthentication</name><argument_list>(<argument><expr><name>mProxyAuth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>mProxyAuth</name></expr>)</condition><then> <block>{
        <comment type="line">// only allow a proxy challenge if we have a proxy server configured.</comment>
        <comment type="line">// otherwise, we could inadvertantly expose the user's proxy</comment>
        <comment type="line">// credentials to an origin server.  We could attempt to proceed as</comment>
        <comment type="line">// if we had received a 401 from the server, but why risk flirting</comment>
        <comment type="line">// with trouble?  IE similarly rejects 407s when a proxy server is</comment>
        <comment type="line">// not configured, so there's no reason not to do the same.</comment>
        <if>if <condition>(<expr>!<call><name><name>mConnectionInfo</name>-&gt;<name>UsingHttpProxy</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("rejecting 407 when proxy server not configured!\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>mConnectionInfo</name>-&gt;<name>UsingSSL</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>mTransaction</name>-&gt;<name>SSLConnectFailed</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// we need to verify that this challenge came from the proxy</comment>
            <comment type="line">// server itself, and not some server on the other side of the</comment>
            <comment type="line">// SSL tunnel.</comment>
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("rejecting 407 from origin server!\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_UNEXPECTED</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>challenges</name> = <call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Proxy_Authenticate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
        <expr_stmt><expr><name>challenges</name> = <call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>WWW_Authenticate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>challenges</name></expr></argument>, <argument><expr><name>NS_ERROR_UNEXPECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>creds</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>GetCredentials</name><argument_list>(<argument><expr><name>challenges</name></expr></argument>, <argument><expr><name>mProxyAuth</name></expr></argument>, <argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> == <name>NS_ERROR_IN_PROGRESS</name></expr>)</condition><then>  <block>{
        <comment type="line">// authentication prompt has been invoked and result</comment>
        <comment type="line">// is expected asynchronously</comment>
        <expr_stmt><expr><name>mAuthRetryPending</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <comment type="line">// suspend the transaction pump to stop receiving the</comment>
        <comment type="line">// unauthenticated content data. We will throw that data</comment>
        <comment type="line">// away when user provides credentials or resume the pump</comment>
        <comment type="line">// when user refuses to authenticate.</comment>
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Suspending the transaction, asynchronously prompting for credentials")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mTransactionPump</name>-&gt;<name>Suspend</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("unable to authenticate\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <block>{
        <comment type="line">// set the authentication credentials</comment>
        <if>if <condition>(<expr><name>mProxyAuth</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Proxy_Authorization</name></name></expr></argument>, <argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Authorization</name></name></expr></argument>, <argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

        <expr_stmt><expr><name>mAuthRetryPending</name> = <name>PR_TRUE</name></expr>;</expr_stmt> <comment type="line">// see DoAuthRetry</comment>
    }</block></else></if></else></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>PrepareForAuthentication</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>proxyAuth</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::PrepareForAuthentication [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>proxyAuth</name></expr>)</condition><then> <block>{
        <comment type="line">// reset the current proxy continuation state because our last</comment>
        <comment type="line">// authentication attempt was completed successfully.</comment>
        <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>mProxyAuthContinuationState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  proxy continuation state has been reset")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name><name>mConnectionInfo</name>-&gt;<name>UsingHttpProxy</name></name><argument_list>()</argument_list></call> || <call><name><name>mProxyAuthType</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <comment type="line">// We need to remove any Proxy_Authorization header left over from a</comment>
    <comment type="line">// non-request based authentication handshake (e.g., for NTLM auth).</comment>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>contractId</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>contractId</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>NS_HTTP_AUTHENTICATOR_CONTRACTID_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>contractId</name>.<name>Append</name></name><argument_list>(<argument><expr><name>mProxyAuthType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIHttpAuthenticator</name></expr></argument>&gt;</argument_list></name></type> <name>precedingAuth</name> <init>=
        <expr><call><name>do_GetService</name><argument_list>(<argument><expr><call><name><name>contractId</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>precedingAuthFlags</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>precedingAuth</name>-&gt;<name>GetAuthFlags</name></name><argument_list>(<argument><expr>&amp;<name>precedingAuthFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!(<name>precedingAuthFlags</name> &amp; <name><name>nsIHttpAuthenticator</name>::<name>REQUEST_BASED</name></name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>challenges</name> <init>=
                <expr><call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Proxy_Authenticate</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>challenges</name></expr>)</condition><then> <block>{
            <comment type="line">// delete the proxy authorization header because we weren't</comment>
            <comment type="line">// asked to authenticate</comment>
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>ClearHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Proxy_Authorization</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  cleared proxy authorization header")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>GetCredentials</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>challenges</name></decl></param>,
                              <param><decl><type><name>PRBool</name></type> <name>proxyAuth</name></decl></param>,
                              <param><decl><type><name>nsAFlatCString</name> &amp;</type><name>creds</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIHttpAuthenticator</name></expr></argument>&gt;</argument_list></name></type> <name>auth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>challenge</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsCString</name></type> <name>authType</name></decl>;</decl_stmt> <comment type="line">// force heap allocation to enable string sharing since</comment>
                        <comment type="line">// we'll be assigning this value into mAuthType.</comment>

    <comment type="line">// set informations that depend on whether we're authenticating against a</comment>
    <comment type="line">// proxy or a webserver</comment>
    <decl_stmt><decl><type><name>nsISupports</name> **</type><name>currentContinuationState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCString</name> *</type><name>currentAuthType</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>proxyAuth</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>currentContinuationState</name> = &amp;<name>mProxyAuthContinuationState</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentAuthType</name> = &amp;<name>mProxyAuthType</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>currentContinuationState</name> = &amp;<name>mAuthContinuationState</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>currentAuthType</name> = &amp;<name>mAuthType</name></expr>;</expr_stmt>
    }</block></else></if>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>gotCreds</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    
    <comment type="line">// figure out which challenge we can handle and which authenticator to use.</comment>
    <for>for (<init><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol</name> <init>= <expr><name>challenges</name> - 1</expr></init></decl>;</init> <condition><expr><name>eol</name></expr>;</condition> <incr/>) <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>eol</name> + 1</expr></init></decl>;</decl_stmt>

        <comment type="line">// get the challenge string (LF separated -- see nsHttpHeaderArray)</comment>
        <if>if <condition>(<expr>(<name>eol</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>'\n'</expr></argument>)</argument_list></call>) != <name>nsnull</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>challenge</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>eol</name> - <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>challenge</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

        <expr_stmt><expr><name>rv</name> = <call><name>GetAuthenticator</name><argument_list>(<argument><expr><call><name><name>challenge</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>authType</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>auth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">//</comment>
            <comment type="line">// if we've already selected an auth type from a previous challenge</comment>
            <comment type="line">// received while processing this channel, then skip others until</comment>
            <comment type="line">// we find a challenge corresponding to the previously tried auth</comment>
            <comment type="line">// type.</comment>
            <comment type="line">//</comment>
            <if>if <condition>(<expr>!<call><name><name>currentAuthType</name>-&gt;<name>IsEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>authType</name> != *<name>currentAuthType</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>

            <comment type="line">//</comment>
            <comment type="line">// we allow the routines to run all the way through before we</comment>
            <comment type="line">// decide if they are valid.</comment>
            <comment type="line">//</comment>
            <comment type="line">// we don't worry about the auth cache being altered because that</comment>
            <comment type="line">// would have been the last step, and if the error is from updating</comment>
            <comment type="line">// the authcache it wasn't really altered anyway. -CTN </comment>
            <comment type="line">//</comment>
            <comment type="line">// at this point the code is really only useful for client side</comment>
            <comment type="line">// errors (it will not automatically fail over to do a different</comment>
            <comment type="line">// auth type if the server keeps rejecting what is being sent, even</comment>
            <comment type="line">// if a particular auth method only knows 1 thing, like a</comment>
            <comment type="line">// non-identity based authentication method)</comment>
            <comment type="line">//</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>GetCredentialsForChallenge</name><argument_list>(<argument><expr><call><name><name>challenge</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>authType</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                                            <argument><expr><name>proxyAuth</name></expr></argument>, <argument><expr><name>auth</name></expr></argument>, <argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>gotCreds</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>currentAuthType</name> = <name>authType</name></expr>;</expr_stmt>

                <break>break;</break>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>rv</name> == <name>NS_ERROR_IN_PROGRESS</name></expr>)</condition><then> <block>{
                <comment type="line">// authentication prompt has been invoked and result is</comment>
                <comment type="line">// expected asynchronously, save current challenge being</comment>
                <comment type="line">// processed and all remaining challenges to use later in</comment>
                <comment type="line">// OnAuthAvailable and now immediately return</comment>
                <expr_stmt><expr><name>mCurrentChallenge</name> = <name>challenge</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>mRemainingChallenges</name> = <name>eol</name> ? <name>eol</name>+1 : <name>nsnull</name></expr>;</expr_stmt>
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if></else></if>

            <comment type="line">// reset the auth type and continuation state</comment>
            <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr>*<name>currentContinuationState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>currentAuthType</name>-&gt;<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr>!<name>gotCreds</name> &amp;&amp; !<call><name><name>currentAuthType</name>-&gt;<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// looks like we never found the auth type we were looking for.</comment>
        <comment type="line">// reset the auth type and continuation state, and try again.</comment>
        <expr_stmt><expr><call><name><name>currentAuthType</name>-&gt;<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr>*<name>currentContinuationState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name>GetCredentials</name><argument_list>(<argument><expr><name>challenges</name></expr></argument>, <argument><expr><name>proxyAuth</name></expr></argument>, <argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>GetAuthorizationMembers</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>proxyAuth</name></decl></param>,
                                       <param><decl><type><name>nsCSubstring</name>&amp;</type> <name>scheme</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name>*&amp;</type> <name>host</name></decl></param>,
                                       <param><decl><type><name>PRInt32</name>&amp;</type> <name>port</name></decl></param>,
                                       <param><decl><type><name>nsCSubstring</name>&amp;</type> <name>path</name></decl></param>,
                                       <param><decl><type><name>nsHttpAuthIdentity</name>*&amp;</type> <name>ident</name></decl></param>,
                                       <param><decl><type><name>nsISupports</name>**&amp;</type> <name>continuationState</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>proxyAuth</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name> <argument_list>(<argument><expr><call><name><name>mConnectionInfo</name>-&gt;<name>UsingHttpProxy</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"proxyAuth is true, but no HTTP proxy is configured!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>host</name> = <call><name><name>mConnectionInfo</name>-&gt;<name>ProxyHost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>port</name> = <call><name><name>mConnectionInfo</name>-&gt;<name>ProxyPort</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ident</name> = &amp;<name>mProxyIdent</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>scheme</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr>"http"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>continuationState</name> = &amp;<name>mProxyAuthContinuationState</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>host</name> = <call><name><name>mConnectionInfo</name>-&gt;<name>Host</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>port</name> = <call><name><name>mConnectionInfo</name>-&gt;<name>Port</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ident</name> = &amp;<name>mIdent</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>GetCurrentPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetScheme</name></name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>continuationState</name> = &amp;<name>mAuthContinuationState</name></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>GetCredentialsForChallenge</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>challenge</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>authType</name></decl></param>,
                                          <param><decl><type><name>PRBool</name></type> <name>proxyAuth</name></decl></param>,
                                          <param><decl><type><name>nsIHttpAuthenticator</name> *</type><name>auth</name></decl></param>,
                                          <param><decl><type><name>nsAFlatCString</name> &amp;</type><name>creds</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::GetCredentialsForChallenge [this=%p proxyAuth=%d challenges=%s]\n",
        <name>this</name>, <name>proxyAuth</name>, <name>challenge</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// this getter never fails</comment>
    <decl_stmt><decl><type><name>nsHttpAuthCache</name> *</type><name>authCache</name> <init>= <expr><call><name><name>gHttpHandler</name>-&gt;<name>AuthCache</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>authFlags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>auth</name>-&gt;<name>GetAuthFlags</name></name><argument_list>(<argument><expr>&amp;<name>authFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>realm</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ParseRealm</name><argument_list>(<argument><expr><name>challenge</name></expr></argument>, <argument><expr><name>realm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// if no realm, then use the auth type as the realm.  ToUpperCase so the</comment>
    <comment type="line">// ficticious realm stands out a bit more.</comment>
    <comment type="line">// XXX this will cause some single signon misses!</comment>
    <comment type="line">// XXX this was meant to be used with NTLM, which supplies no realm.</comment>
    <comment type="block">/*
    if (realm.IsEmpty()) {
        realm = authType;
        ToUpperCase(realm);
    }
    */</comment>

    <comment type="line">// set informations that depend on whether</comment>
    <comment type="line">// we're authenticating against a proxy</comment>
    <comment type="line">// or a webserver</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsHttpAuthIdentity</name> *</type><name>ident</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>path</name></decl>, <decl><type ref="prev"/><name>scheme</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>identFromURI</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsISupports</name> **</type><name>continuationState</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>GetAuthorizationMembers</name><argument_list>(<argument><expr><name>proxyAuth</name></expr></argument>, <argument><expr><name>scheme</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ident</name></expr></argument>, <argument><expr><name>continuationState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<name>proxyAuth</name></expr>)</condition><then> <block>{
        <comment type="line">// if this is the first challenge, then try using the identity</comment>
        <comment type="line">// specified in the URL.</comment>
        <if>if <condition>(<expr><call><name><name>mIdent</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>GetIdentityFromURI</name><argument_list>(<argument><expr><name>authFlags</name></expr></argument>, <argument><expr><name>mIdent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>identFromURI</name> = !<call><name><name>mIdent</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">//</comment>
    <comment type="line">// if we already tried some credentials for this transaction, then</comment>
    <comment type="line">// we need to possibly clear them from the cache, unless the credentials</comment>
    <comment type="line">// in the cache have changed, in which case we'd want to give them a</comment>
    <comment type="line">// try instead.</comment>
    <comment type="line">//</comment>
    <decl_stmt><decl><type><name>nsHttpAuthEntry</name> *</type><name>entry</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>authCache</name>-&gt;<name>GetAuthEntryForDomain</name></name><argument_list>(<argument><expr><call><name><name>scheme</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><call><name><name>realm</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// hold reference to the auth session state (in case we clear our</comment>
    <comment type="line">// reference to the entry).</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>sessionStateGrip</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>entry</name></expr>)</condition><then>
        <expr_stmt><expr><name>sessionStateGrip</name> = <name><name>entry</name>-&gt;<name>mMetaData</name></name></expr>;</expr_stmt></then></if>

    <comment type="line">// for digest auth, maybe our cached nonce value simply timed out...</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>identityInvalid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsISupports</name> *</type><name>sessionState</name> <init>= <expr><name>sessionStateGrip</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>auth</name>-&gt;<name>ChallengeReceived</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>,
                                 <argument><expr><name>challenge</name></expr></argument>,
                                 <argument><expr><name>proxyAuth</name></expr></argument>,
                                 <argument><expr>&amp;<name>sessionState</name></expr></argument>,
                                 <argument><expr>&amp;*<name>continuationState</name></expr></argument>,
                                 <argument><expr>&amp;<name>identityInvalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>sessionStateGrip</name>.<name>swap</name></name><argument_list>(<argument><expr><name>sessionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  identity invalid = %d\n", <name>identityInvalid</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>identityInvalid</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>entry</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>ident</name>-&gt;<name>Equals</name></name><argument_list>(<argument><expr><call><name><name>entry</name>-&gt;<name>Identity</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  clearing bad auth cache entry\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// ok, we've already tried this user identity, so clear the</comment>
                <comment type="line">// corresponding entry from the auth cache.</comment>
                <expr_stmt><expr><call><name><name>authCache</name>-&gt;<name>ClearAuthEntry</name></name><argument_list>(<argument><expr><call><name><name>scheme</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><call><name><name>realm</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>entry</name> = <name>nsnull</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>ident</name>-&gt;<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<name>identFromURI</name> || <call><name><name>nsCRT</name>::<name>strcmp</name></name><argument_list>(<argument><expr><call><name><name>ident</name>-&gt;<name>User</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name>-&gt;<name>Identity</name></name><argument_list>()</argument_list></call>.<call><name>User</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  taking identity from auth cache\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// the password from the auth cache is more likely to be</comment>
                <comment type="line">// correct than the one in the URL.  at least, we know that it</comment>
                <comment type="line">// works with the given username.  it is possible for a server</comment>
                <comment type="line">// to distinguish logons based on the supplied password alone,</comment>
                <comment type="line">// but that would be quite unusual... and i don't think we need</comment>
                <comment type="line">// to worry about such unorthodox cases.</comment>
                <expr_stmt><expr><call><name><name>ident</name>-&gt;<name>Set</name></name><argument_list>(<argument><expr><call><name><name>entry</name>-&gt;<name>Identity</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>identFromURI</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>entry</name>-&gt;<name>Creds</name></name><argument_list>()</argument_list></call><index>[<expr>0</expr>]</index> != '\0'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("    using cached credentials!\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>creds</name>.<name>Assign</name></name><argument_list>(<argument><expr><call><name><name>entry</name>-&gt;<name>Creds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name><name>entry</name>-&gt;<name>AddPath</name></name><argument_list>(<argument><expr><call><name><name>path</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
            }</block></then></if></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<name>identFromURI</name></expr>)</condition><then> <block>{
            <comment type="line">// hmm... identity invalid, but no auth entry!  the realm probably</comment>
            <comment type="line">// changed (see bug 201986).</comment>
            <expr_stmt><expr><call><name><name>ident</name>-&gt;<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>

        <if>if <condition>(<expr>!<name>entry</name> &amp;&amp; <call><name><name>ident</name>-&gt;<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>PRUint32</name></type> <name>level</name> <init>= <expr><name><name>nsIAuthPrompt2</name>::<name>LEVEL_NONE</name></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>scheme</name>.<name>EqualsLiteral</name></name><argument_list>(<argument><expr>"https"</expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>level</name> = <name><name>nsIAuthPrompt2</name>::<name>LEVEL_SECURE</name></name></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>authFlags</name> &amp; <name><name>nsIHttpAuthenticator</name>::<name>IDENTITY_ENCRYPTED</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>level</name> = <name><name>nsIAuthPrompt2</name>::<name>LEVEL_PW_ENCRYPTED</name></name></expr>;</expr_stmt></then></if></else></if>

            <comment type="line">// at this point we are forced to interact with the user to get</comment>
            <comment type="line">// their username and password for this domain.</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>PromptForIdentity</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><name>proxyAuth</name></expr></argument>, <argument><expr><call><name><name>realm</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, 
                                   <argument><expr><name>authType</name></expr></argument>, <argument><expr><name>authFlags</name></expr></argument>, <argument><expr>*<name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
            <expr_stmt><expr><name>identFromURI</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>identFromURI</name></expr>)</condition><then> <block>{
        <comment type="line">// Warn the user before automatically using the identity from the URL</comment>
        <comment type="line">// to automatically log them into a site (see bug 232567).</comment>
        <if>if <condition>(<expr>!<call><name>ConfirmAuth</name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"AutomaticAuth"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// calling cancel here sets our mStatus and aborts the HTTP</comment>
            <comment type="line">// transaction, which prevents OnDataAvailable events.</comment>
            <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// this return code alone is not equivalent to Cancel, since</comment>
            <comment type="line">// it only instructs our caller that authentication failed.</comment>
            <comment type="line">// without an explicit call to Cancel, our caller would just</comment>
            <comment type="line">// load the page that accompanies the HTTP auth challenge.</comment>
            <return>return <expr><name>NS_ERROR_ABORT</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">//</comment>
    <comment type="line">// get credentials for the given user:pass</comment>
    <comment type="line">//</comment>
    <comment type="line">// always store the credentials we're trying now so that they will be used</comment>
    <comment type="line">// on subsequent links.  This will potentially remove good credentials from</comment>
    <comment type="line">// the cache.  This is ok as we don't want to use cached credentials if the</comment>
    <comment type="line">// user specified something on the URI or in another manner.  This is so</comment>
    <comment type="line">// that we don't transparently authenticate as someone they're not</comment>
    <comment type="line">// expecting to authenticate as.</comment>
    <comment type="line">//</comment>
    <decl_stmt><decl><type><name>nsXPIDLCString</name></type> <name>result</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>GenCredsAndSetEntry</name><argument_list>(<argument><expr><name>auth</name></expr></argument>, <argument><expr><name>proxyAuth</name></expr></argument>, <argument><expr><call><name><name>scheme</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><call><name><name>path</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                             <argument><expr><call><name><name>realm</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>challenge</name></expr></argument>, <argument><expr>*<name>ident</name></expr></argument>, <argument><expr><name>sessionStateGrip</name></expr></argument>,
                             <argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>creds</name> = <name>result</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>GetAuthenticator</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>challenge</name></decl></param>,
                                <param><decl><type><name>nsCString</name> &amp;</type><name>authType</name></decl></param>,
                                <param><decl><type><name>nsIHttpAuthenticator</name> **</type><name>auth</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::GetAuthenticator [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GetAuthType</name><argument_list>(<argument><expr><name>challenge</name></expr></argument>, <argument><expr><name>authType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
    <comment type="line">// normalize to lowercase</comment>
    <expr_stmt><expr><call><name>ToLowerCase</name><argument_list>(<argument><expr><name>authType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>contractid</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>contractid</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>NS_HTTP_AUTHENTICATOR_CONTRACTID_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>contractid</name>.<name>Append</name></name><argument_list>(<argument><expr><name>authType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>CallGetService</name><argument_list>(<argument><expr><call><name><name>contractid</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>auth</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>GetIdentityFromURI</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>authFlags</name></decl></param>, <param><decl><type><name>nsHttpAuthIdentity</name> &amp;</type><name>ident</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::GetIdentityFromURI [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>userBuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>passBuf</name></decl>;</decl_stmt>

    <comment type="line">// XXX i18n</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>buf</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mURI</name>-&gt;<name>GetUsername</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>buf</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_UnescapeURL</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CopyASCIItoUTF16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>userBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mURI</name>-&gt;<name>GetPassword</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>buf</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NS_UnescapeURL</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CopyASCIItoUTF16</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>passBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name><name>userBuf</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SetIdent</name><argument_list>(<argument><expr><name>ident</name></expr></argument>, <argument><expr><name>authFlags</name></expr></argument>, <argument><expr>(<name>PRUnichar</name> *) <call><name><name>userBuf</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>PRUnichar</name> *) <call><name><name>passBuf</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>ParseRealm</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>challenge</name></decl></param>, <param><decl><type><name>nsACString</name> &amp;</type><name>realm</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">//</comment>
    <comment type="line">// From RFC2617 section 1.2, the realm value is defined as such:</comment>
    <comment type="line">//</comment>
    <comment type="line">//    realm       = "realm" "=" realm-value</comment>
    <comment type="line">//    realm-value = quoted-string</comment>
    <comment type="line">//</comment>
    <comment type="line">// but, we'll accept anything after the the "=" up to the first space, or</comment>
    <comment type="line">// end-of-line, if the string is not quoted.</comment>
    <comment type="line">//</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>PL_strcasestr</name><argument_list>(<argument><expr><name>challenge</name></expr></argument>, <argument><expr>"realm="</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>p</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>has_quote</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>p</name> += 6</expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>p</name> == '"'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>has_quote</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr>*<name>end</name> &amp;&amp; <name>has_quote</name></expr>)</condition> <block>{
           <comment type="line">// Loop through all the string characters to find the closing</comment>
           <comment type="line">// quote, ignoring escaped quotes.</comment>
            <if>if <condition>(<expr>*<name>end</name> == '"' &amp;&amp; <name><name>end</name><index>[<expr>-1</expr>]</index></name> != '\\'</expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr>++<name>end</name></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr>!<name>has_quote</name></expr>)</condition><then>
            <expr_stmt><expr><name>end</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> 
        <if>if <condition>(<expr><name>end</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>realm</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name> - <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>realm</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
}</block></function>


<class>class <name>nsHTTPAuthInformation</name> <super>: <specifier>public</specifier> <name>nsAuthInformationHolder</name></super> <block>{<private type="default">
</private><public>public:
    <constructor><name>nsHTTPAuthInformation</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsString</name>&amp;</type> <name>aRealm</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>nsCString</name>&amp;</type> <name>aAuthType</name></decl></param>)</parameter_list>
        <member_list>: <call><name>nsAuthInformationHolder</name><argument_list>(<argument><expr><name>aFlags</name></expr></argument>, <argument><expr><name>aRealm</name></expr></argument>, <argument><expr><name>aAuthType</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>

    <function_decl><type><name>void</name></type> <name>SetToHttpAuthIdentity</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>authFlags</name></decl></param>, <param><decl><type><name>nsHttpAuthIdentity</name>&amp;</type> <name>identity</name></decl></param>)</parameter_list>;</function_decl>
</public>}</block>;</class>

<function><type><name>void</name></type>
<name><name>nsHTTPAuthInformation</name>::<name>SetToHttpAuthIdentity</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>authFlags</name></decl></param>, <param><decl><type><name>nsHttpAuthIdentity</name>&amp;</type> <name>identity</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>identity</name>.<name>Set</name></name><argument_list>(<argument><expr><call><name>Domain</name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>User</name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>Password</name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>PromptForIdentity</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type>    <name>level</name></decl></param>,
                                 <param><decl><type><name>PRBool</name></type>      <name>proxyAuth</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>realm</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>authType</name></decl></param>,
                                 <param><decl><type><name>PRUint32</name></type> <name>authFlags</name></decl></param>,
                                 <param><decl><type><name>nsHttpAuthIdentity</name> &amp;</type><name>ident</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::PromptForIdentity [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIAuthPrompt2</name></expr></argument>&gt;</argument_list></name></type> <name>authPrompt</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetAuthPrompt</name><argument_list>(<argument><expr><name>mCallbacks</name></expr></argument>, <argument><expr><name>proxyAuth</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>authPrompt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>authPrompt</name> &amp;&amp; <name>mLoadGroup</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIInterfaceRequestor</name></expr></argument>&gt;</argument_list></name></type> <name>cbs</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>GetNotificationCallbacks</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>cbs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GetAuthPrompt</name><argument_list>(<argument><expr><name>cbs</name></expr></argument>, <argument><expr><name>proxyAuth</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>authPrompt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>authPrompt</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NO_INTERFACE</name></expr>;</return></then></if>

    <comment type="line">// XXX i18n: need to support non-ASCII realm strings (see bug 41489)</comment>
    <function_decl><type><name>NS_ConvertASCIItoUTF16</name></type> <name>realmU</name><parameter_list>(<param><decl><type><name>realm</name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="line">// prompt the user...</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>promptFlags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>proxyAuth</name></expr>)</condition><then>
    <block>{
        <expr_stmt><expr><name>promptFlags</name> |= <name><name>nsIAuthInformation</name>::<name>AUTH_PROXY</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>mTriedProxyAuth</name></expr>)</condition><then>
            <expr_stmt><expr><name>promptFlags</name> |= <name><name>nsIAuthInformation</name>::<name>PREVIOUS_FAILED</name></name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>mTriedProxyAuth</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>promptFlags</name> |= <name><name>nsIAuthInformation</name>::<name>AUTH_HOST</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>mTriedHostAuth</name></expr>)</condition><then>
            <expr_stmt><expr><name>promptFlags</name> |= <name><name>nsIAuthInformation</name>::<name>PREVIOUS_FAILED</name></name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>mTriedHostAuth</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>authFlags</name> &amp; <name><name>nsIHttpAuthenticator</name>::<name>IDENTITY_INCLUDES_DOMAIN</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>promptFlags</name> |= <name><name>nsIAuthInformation</name>::<name>NEED_DOMAIN</name></name></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsHTTPAuthInformation</name></expr></argument>&gt;</argument_list></name></type> <name>holder</name> <init>=
        <expr>new <call><name>nsHTTPAuthInformation</name><argument_list>(<argument><expr><name>promptFlags</name></expr></argument>, <argument><expr><name>realmU</name></expr></argument>,
                                  <argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><name>authType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>holder</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>authPrompt</name>-&gt;<name>AsyncPromptAuth</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>holder</name></expr></argument>,
                     <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mAsyncPromptAuthCancelable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// indicate using this error code that authentication prompt</comment>
        <comment type="line">// result is expected asynchronously</comment>
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_IN_PROGRESS</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="line">// Fall back to synchronous prompt</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>retval</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>authPrompt</name>-&gt;<name>PromptAuth</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>holder</name></expr></argument>, <argument><expr>&amp;<name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>

        <if>if <condition>(<expr>!<name>retval</name></expr>)</condition><then>
            <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_ABORT</name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>holder</name>-&gt;<name>SetToHttpAuthIdentity</name></name><argument_list>(<argument><expr><name>authFlags</name></expr></argument>, <argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></else></if>

    <comment type="line">// remember that we successfully showed the user an auth dialog</comment>
    <if>if <condition>(<expr>!<name>proxyAuth</name></expr>)</condition><then>
        <expr_stmt><expr><name>mSuppressDefensiveAuth</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsHttpChannel</name>::<name>OnAuthAvailable</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>aContext</name></decl></param>,
                                             <param><decl><type><name>nsIAuthInformation</name> *</type><name>aAuthInfo</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::OnAuthAvailable [this=%p]", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mAsyncPromptAuthCancelable</name> = <name>nsnull</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsHttpAuthIdentity</name> *</type><name>ident</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>path</name></decl>, <decl><type ref="prev"/><name>scheme</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsISupports</name> **</type><name>continuationState</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>GetAuthorizationMembers</name><argument_list>(<argument><expr><name>mProxyAuth</name></expr></argument>, <argument><expr><name>scheme</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ident</name></expr></argument>, <argument><expr><name>continuationState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>OnAuthCancelled</name><argument_list>(<argument><expr><name>aContext</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>realm</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ParseRealm</name><argument_list>(<argument><expr><call><name><name>mCurrentChallenge</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>realm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsHttpAuthCache</name> *</type><name>authCache</name> <init>= <expr><call><name><name>gHttpHandler</name>-&gt;<name>AuthCache</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsHttpAuthEntry</name> *</type><name>entry</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>authCache</name>-&gt;<name>GetAuthEntryForDomain</name></name><argument_list>(<argument><expr><call><name><name>scheme</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><call><name><name>realm</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupports</name></expr></argument>&gt;</argument_list></name></type> <name>sessionStateGrip</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>entry</name></expr>)</condition><then>
        <expr_stmt><expr><name>sessionStateGrip</name> = <name><name>entry</name>-&gt;<name>mMetaData</name></name></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>nsAuthInformationHolder</name>*</type> <name>holder</name> <init>=
            <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsAuthInformationHolder</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aAuthInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>ident</name>-&gt;<name>Set</name></name><argument_list>(<argument><expr><call><name><name>holder</name>-&gt;<name>Domain</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr><call><name><name>holder</name>-&gt;<name>User</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr><call><name><name>holder</name>-&gt;<name>Password</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>unused</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIHttpAuthenticator</name></expr></argument>&gt;</argument_list></name></type> <name>auth</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>GetAuthenticator</name><argument_list>(<argument><expr><call><name><name>mCurrentChallenge</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>auth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"GetAuthenticator failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OnAuthCancelled</name><argument_list>(<argument><expr><name>aContext</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsXPIDLCString</name></type> <name>creds</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>GenCredsAndSetEntry</name><argument_list>(<argument><expr><name>auth</name></expr></argument>, <argument><expr><name>mProxyAuth</name></expr></argument>,
                             <argument><expr><call><name><name>scheme</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><call><name><name>path</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                             <argument><expr><call><name><name>realm</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>mCurrentChallenge</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>*<name>ident</name></expr></argument>, <argument><expr><name>sessionStateGrip</name></expr></argument>,
                             <argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>mCurrentChallenge</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>OnAuthCancelled</name><argument_list>(<argument><expr><name>aContext</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>ContinueOnAuthAvailable</name><argument_list>(<argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsHttpChannel</name>::<name>OnAuthCancelled</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>aContext</name></decl></param>, 
                                             <param><decl><type><name>PRBool</name></type> <name>userCancel</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::OnAuthCancelled [this=%p]", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mAsyncPromptAuthCancelable</name> = <name>nsnull</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>userCancel</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name><name>mRemainingChallenges</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// there are still some challenges to process, do so</comment>
            <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>creds</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>GetCredentials</name><argument_list>(<argument><expr><call><name><name>mRemainingChallenges</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mProxyAuth</name></expr></argument>, <argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// GetCredentials loaded the credentials from the cache or</comment>
                <comment type="line">// some other way in a synchronous manner, process those</comment>
                <comment type="line">// credentials now</comment>
                <expr_stmt><expr><call><name><name>mRemainingChallenges</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>ContinueOnAuthAvailable</name><argument_list>(<argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>rv</name> == <name>NS_ERROR_IN_PROGRESS</name></expr>)</condition><then> <block>{
                <comment type="line">// GetCredentials successfully queued another authprompt for</comment>
                <comment type="line">// a challenge from the list, we are now waiting for the user</comment>
                <comment type="line">// to provide the credentials</comment>
                <return>return <expr><name>NS_OK</name></expr>;</return>
            }</block></then></if></else></if>

            <comment type="line">// otherwise, we failed...</comment>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>mRemainingChallenges</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// ensure call of OnStartRequest of the current listener here,</comment>
        <comment type="line">// it would not be called otherwise at all</comment>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>CallOnStartRequest</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// drop mAuthRetryPending flag and resume the transaction</comment>
        <comment type="line">// this resumes load of the unauthenticated content data</comment>
        <expr_stmt><expr><name>mAuthRetryPending</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Resuming the transaction, user cancelled the auth dialog")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mTransactionPump</name>-&gt;<name>Resume</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mTransactionPump</name>-&gt;<name>Cancel</name></name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>ContinueOnAuthAvailable</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCSubstring</name>&amp;</type> <name>creds</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mProxyAuth</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Proxy_Authorization</name></name></expr></argument>, <argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Authorization</name></name></expr></argument>, <argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <comment type="line">// drop our remaining list of challenges.  We don't need them, because we</comment>
    <comment type="line">// have now authenticated against a challenge and will be sending that</comment>
    <comment type="line">// information to the server (or proxy).  If it doesn't accept our</comment>
    <comment type="line">// authentication it'll respond with failure and resend the challenge list</comment>
    <expr_stmt><expr><call><name><name>mRemainingChallenges</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// setting mAuthRetryPending flag and resuming the transaction</comment>
    <comment type="line">// triggers process of throwing away the unauthenticated data already</comment>
    <comment type="line">// coming from the network</comment>
    <expr_stmt><expr><name>mAuthRetryPending</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Resuming the transaction, we got credentials from user")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mTransactionPump</name>-&gt;<name>Resume</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsHttpChannel</name>::<name>ConfirmAuth</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsString</name> &amp;</type><name>bundleKey</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>doYesNoPrompt</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// skip prompting the user if</comment>
    <comment type="line">//   1) we've already prompted the user</comment>
    <comment type="line">//   2) we're not a toplevel channel</comment>
    <comment type="line">//   3) the userpass length is less than the "phishy" threshold</comment>

    <if>if <condition>(<expr><name>mSuppressDefensiveAuth</name> || !(<name>mLoadFlags</name> &amp; <name>LOAD_INITIAL_DOCUMENT_URI</name>)</expr>)</condition><then>
        <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>userPass</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetUserPass</name></name><argument_list>(<argument><expr><name>userPass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> || (<call><name><name>userPass</name>.<name>Length</name></name><argument_list>()</argument_list></call> &lt; <call><name><name>gHttpHandler</name>-&gt;<name>PhishyUserPassLength</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

    <comment type="line">// we try to confirm by prompting the user.  if we cannot do so, then</comment>
    <comment type="line">// assume the user said ok.  this is done to keep things working in</comment>
    <comment type="line">// embedded builds, where the string bundle might not be present, etc.</comment>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStringBundleService</name></expr></argument>&gt;</argument_list></name></type> <name>bundleService</name> <init>=
            <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_STRINGBUNDLE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>bundleService</name></expr>)</condition><then>
        <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStringBundle</name></expr></argument>&gt;</argument_list></name></type> <name>bundle</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>bundleService</name>-&gt;<name>CreateBundle</name></name><argument_list>(<argument><expr><name>NECKO_MSGS_URL</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>bundle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>bundle</name></expr>)</condition><then>
        <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>host</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetHost</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>user</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetUsername</name></name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

    <function_decl><type><name>NS_ConvertUTF8toUTF16</name></type> <name>ucsHost</name><parameter_list>(<param><decl><type><name>host</name></type></decl></param>)</parameter_list>, <name>ucsUser</name><parameter_list>(<param><decl><type><name>user</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>strs</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{ <expr><call><name><name>ucsHost</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>, <macro><name>ucsUser</name></macro><expr>.<macro><name>get</name><argument_list>()</argument_list></macro></expr> }</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsXPIDLString</name></type> <name>msg</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>bundle</name>-&gt;<name>FormatStringFromName</name></name><argument_list>(<argument><expr><call><name><name>bundleKey</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>strs</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>msg</name></expr>)</condition><then>
        <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
    
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrompt</name></expr></argument>&gt;</argument_list></name></type> <name>prompt</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetCallback</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>prompt</name></expr>)</condition><then>
        <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

    <comment type="line">// do not prompt again</comment>
    <expr_stmt><expr><name>mSuppressDefensiveAuth</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>confirmed</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>doYesNoPrompt</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>choice</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>checkState</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>prompt</name>-&gt;<name>ConfirmEx</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>,
                               <argument><expr><name><name>nsIPrompt</name>::<name>BUTTON_POS_1_DEFAULT</name></name> +
                               <name><name>nsIPrompt</name>::<name>STD_YES_NO_BUTTONS</name></name></expr></argument>,
                               <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr>&amp;<name>checkState</name></expr></argument>, <argument><expr>&amp;<name>choice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

        <expr_stmt><expr><name>confirmed</name> = <name>choice</name> == 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>prompt</name>-&gt;<name>Confirm</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr>&amp;<name>confirmed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
    }</block></else></if>

    <return>return <expr><name>confirmed</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>CheckForSuperfluousAuth</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// we've been called because it has been determined that this channel is</comment>
    <comment type="line">// getting loaded without taking the userpass from the URL.  if the URL</comment>
    <comment type="line">// contained a userpass, then (provided some other conditions are true),</comment>
    <comment type="line">// we'll give the user an opportunity to abort the channel as this might be</comment>
    <comment type="line">// an attempt to spoof a different site (see bug 232567).</comment>
    <if>if <condition>(<expr>!<name>mAuthRetryPending</name></expr>)</condition><then> <block>{
        <comment type="line">// ask user...</comment>
        <if>if <condition>(<expr>!<call><name>ConfirmAuth</name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"SuperfluousAuth"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// calling cancel here sets our mStatus and aborts the HTTP</comment>
            <comment type="line">// transaction, which prevents OnDataAvailable events.</comment>
            <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_ERROR_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>SetAuthorizationHeader</name></name><parameter_list>(<param><decl><type><name>nsHttpAuthCache</name> *</type><name>authCache</name></decl></param>,
                                      <param><decl><type><name>nsHttpAtom</name></type> <name>header</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>scheme</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host</name></decl></param>,
                                      <param><decl><type><name>PRInt32</name></type> <name>port</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                      <param><decl><type><name>nsHttpAuthIdentity</name> &amp;</type><name>ident</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsHttpAuthEntry</name> *</type><name>entry</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="line">// set informations that depend on whether</comment>
    <comment type="line">// we're authenticating against a proxy</comment>
    <comment type="line">// or a webserver</comment>
    <decl_stmt><decl><type><name>nsISupports</name> **</type><name>continuationState</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>header</name> == <name><name>nsHttp</name>::<name>Proxy_Authorization</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>continuationState</name> = &amp;<name>mProxyAuthContinuationState</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>continuationState</name> = &amp;<name>mAuthContinuationState</name></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>authCache</name>-&gt;<name>GetAuthEntryForPath</name></name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// if we are trying to add a header for origin server auth and if the</comment>
        <comment type="line">// URL contains an explicit username, then try the given username first.</comment>
        <comment type="line">// we only want to do this, however, if we know the URL requires auth</comment>
        <comment type="line">// based on the presence of an auth cache entry for this URL (which is</comment>
        <comment type="line">// true since we are here).  but, if the username from the URL matches</comment>
        <comment type="line">// the username from the cache, then we should prefer the password</comment>
        <comment type="line">// stored in the cache since that is most likely to be valid.</comment>
        <if>if <condition>(<expr><name>header</name> == <name><name>nsHttp</name>::<name>Authorization</name></name> &amp;&amp; <call><name><name>entry</name>-&gt;<name>Domain</name></name><argument_list>()</argument_list></call><index>[<expr>0</expr>]</index> == '\0'</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>GetIdentityFromURI</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// if the usernames match, then clear the ident so we will pick</comment>
            <comment type="line">// up the one from the auth cache instead.</comment>
            <if>if <condition>(<expr><call><name><name>nsCRT</name>::<name>strcmp</name></name><argument_list>(<argument><expr><call><name><name>ident</name>.<name>User</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name>-&gt;<name>User</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
                <expr_stmt><expr><call><name><name>ident</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>identFromURI</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>ident</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>ident</name>.<name>Set</name></name><argument_list>(<argument><expr><call><name><name>entry</name>-&gt;<name>Identity</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>identFromURI</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        }</block></then>
        <else>else
            <expr_stmt><expr><name>identFromURI</name> = <name>PR_TRUE</name></expr>;</expr_stmt></else></if>

        <decl_stmt><decl><type><name>nsXPIDLCString</name></type> <name>temp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>creds</name>     <init>= <expr><call><name><name>entry</name>-&gt;<name>Creds</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>challenge</name> <init>= <expr><call><name><name>entry</name>-&gt;<name>Challenge</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// we can only send a preemptive Authorization header if we have either</comment>
        <comment type="line">// stored credentials or a stored challenge from which to derive</comment>
        <comment type="line">// credentials.  if the identity is from the URI, then we cannot use</comment>
        <comment type="line">// the stored credentials.</comment>
        <if>if <condition>(<expr>(!<name><name>creds</name><index>[<expr>0</expr>]</index></name> || <name>identFromURI</name>) &amp;&amp; <name><name>challenge</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIHttpAuthenticator</name></expr></argument>&gt;</argument_list></name></type> <name>auth</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>unused</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>GetAuthenticator</name><argument_list>(<argument><expr><name>challenge</name></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>auth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>PRBool</name></type> <name>proxyAuth</name> <init>= <expr>(<name>header</name> == <name><name>nsHttp</name>::<name>Proxy_Authorization</name></name>)</expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>rv</name> = <call><name>GenCredsAndSetEntry</name><argument_list>(<argument><expr><name>auth</name></expr></argument>, <argument><expr><name>proxyAuth</name></expr></argument>, <argument><expr><name>scheme</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                         <argument><expr><call><name><name>entry</name>-&gt;<name>Realm</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>challenge</name></expr></argument>, <argument><expr><name>ident</name></expr></argument>,
                                         <argument><expr><name><name>entry</name>-&gt;<name>mMetaData</name></name></expr></argument>, <argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name>creds</name> = <call><name><name>temp</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

                <comment type="line">// make sure the continuation state is null since we do not</comment>
                <comment type="line">// support mixing preemptive and 'multirequest' authentication.</comment>
                <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr>*<name>continuationState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>creds</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("   adding \"%s\" request header\n", <call><name><name>header</name>.<name>get</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><call><name>nsDependentCString</name><argument_list>(<argument><expr><name>creds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// suppress defensive auth prompting for this channel since we know</comment>
            <comment type="line">// that we already prompted at least once this session.  we only do</comment>
            <comment type="line">// this for non-proxy auth since the URL's userpass is not used for</comment>
            <comment type="line">// proxy auth.</comment>
            <if>if <condition>(<expr><name>header</name> == <name><name>nsHttp</name>::<name>Authorization</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>mSuppressDefensiveAuth</name> = <name>PR_TRUE</name></expr>;</expr_stmt></then></if>
        }</block></then>
        <else>else
            <expr_stmt><expr><call><name><name>ident</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if> <comment type="line">// don't remember the identity</comment>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>AddAuthorizationHeaders</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::AddAuthorizationHeaders? [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_ANONYMOUS</name></expr>)</condition><then> <block>{
      <return>return;</return>
    }</block></then></if>

    <comment type="line">// this getter never fails</comment>
    <decl_stmt><decl><type><name>nsHttpAuthCache</name> *</type><name>authCache</name> <init>= <expr><call><name><name>gHttpHandler</name>-&gt;<name>AuthCache</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// check if proxy credentials should be sent</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proxyHost</name> <init>= <expr><call><name><name>mConnectionInfo</name>-&gt;<name>ProxyHost</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>proxyHost</name> &amp;&amp; <call><name><name>mConnectionInfo</name>-&gt;<name>UsingHttpProxy</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SetAuthorizationHeader</name><argument_list>(<argument><expr><name>authCache</name></expr></argument>, <argument><expr><name><name>nsHttp</name>::<name>Proxy_Authorization</name></name></expr></argument>,
                               <argument><expr>"http"</expr></argument>, <argument><expr><name>proxyHost</name></expr></argument>, <argument><expr><call><name><name>mConnectionInfo</name>-&gt;<name>ProxyPort</name></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><name>nsnull</name></expr></argument>, <comment type="line">// proxy has no path</comment>
                               <argument><expr><name>mProxyIdent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// check if server credentials should be sent</comment>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>path</name></decl>, <decl><type ref="prev"/><name>scheme</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name>GetCurrentPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
        <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>mURI</name>-&gt;<name>GetScheme</name></name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetAuthorizationHeader</name><argument_list>(<argument><expr><name>authCache</name></expr></argument>, <argument><expr><name><name>nsHttp</name>::<name>Authorization</name></name></expr></argument>,
                               <argument><expr><call><name><name>scheme</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><call><name><name>mConnectionInfo</name>-&gt;<name>Host</name></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><call><name><name>mConnectionInfo</name>-&gt;<name>Port</name></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><call><name><name>path</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><name>mIdent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>GetCurrentPath</name></name><parameter_list>(<param><decl><type><name>nsACString</name> &amp;</type><name>path</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURL</name></expr></argument>&gt;</argument_list></name></type> <name>url</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>url</name></expr>)</condition><then>
        <expr_stmt><expr><name>rv</name> = <call><name><name>url</name>-&gt;<name>GetDirectory</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetPath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsISupports</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<macro><name>NS_IMPL_ADDREF_INHERITED</name><argument_list>(<argument>nsHttpChannel</argument>, <argument>nsHashPropertyBag</argument>)</argument_list></macro>
<macro><name>NS_IMPL_RELEASE_INHERITED</name><argument_list>(<argument>nsHttpChannel</argument>, <argument>nsHashPropertyBag</argument>)</argument_list></macro>

<macro><name>NS_INTERFACE_MAP_BEGIN</name><argument_list>(<argument>nsHttpChannel</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIRequest</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIChannel</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIRequestObserver</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIStreamListener</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIHttpChannel</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsICachingChannel</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIUploadChannel</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIUploadChannel2</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsICacheListener</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIEncodedChannel</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIHttpChannelInternal</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIResumableChannel</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsITransportEventSink</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsISupportsPriority</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIProtocolProxyCallback</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIProxiedChannel</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsITraceableChannel</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIApplicationCacheContainer</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIApplicationCacheChannel</argument>)</argument_list></macro>
    <macro><name>NS_INTERFACE_MAP_ENTRY</name><argument_list>(<argument>nsIAuthPromptCallback</argument>)</argument_list></macro>
<macro><name>NS_INTERFACE_MAP_END_INHERITING</name><argument_list>(<argument>nsHashPropertyBag</argument>)</argument_list></macro>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsIRequest</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetName</name></name><parameter_list>(<param><decl><type><name>nsACString</name> &amp;</type><name>aName</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>aName</name> = <name>mSpec</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>IsPending</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>value</name> = <name>mIsPending</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetStatus</name></name><parameter_list>(<param><decl><type><name>nsresult</name> *</type><name>aStatus</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>aStatus</name> = <name>mStatus</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>Cancel</name></name><parameter_list>(<param><decl><type><name>nsresult</name></type> <name>status</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::Cancel [this=%p status=%x]\n", <name>this</name>, <name>status</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mCanceled</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  ignoring; already canceled\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>mCanceled</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mStatus</name> = <name>status</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mProxyRequest</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mProxyRequest</name>-&gt;<name>Cancel</name></name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>mTransaction</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>gHttpHandler</name>-&gt;<name>CancelTransaction</name></name><argument_list>(<argument><expr><name>mTransaction</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>mTransactionPump</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mTransactionPump</name>-&gt;<name>Cancel</name></name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>mCachePump</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mCachePump</name>-&gt;<name>Cancel</name></name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>mAsyncPromptAuthCancelable</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mAsyncPromptAuthCancelable</name>-&gt;<name>Cancel</name></name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>Suspend</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mIsPending</name></expr></argument>, <argument><expr><name>NS_ERROR_NOT_AVAILABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::Suspend [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr>++<name>mSuspendCount</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mTransactionPump</name></expr>)</condition><then>
        <return>return <expr><call><name><name>mTransactionPump</name>-&gt;<name>Suspend</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><name>mCachePump</name></expr>)</condition><then>
        <return>return <expr><call><name><name>mCachePump</name>-&gt;<name>Suspend</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>Resume</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>mSuspendCount</name> &gt; 0</expr></argument>, <argument><expr><name>NS_ERROR_UNEXPECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::Resume [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    <if>if <condition>(<expr>--<name>mSuspendCount</name> == 0 &amp;&amp; <name>mPendingAsyncCallOnResume</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>AsyncCall</name><argument_list>(<argument><expr><name>mPendingAsyncCallOnResume</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>mPendingAsyncCallOnResume</name> = <name>nsnull</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>mTransactionPump</name></expr>)</condition><then>
        <return>return <expr><call><name><name>mTransactionPump</name>-&gt;<name>Resume</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><name>mCachePump</name></expr>)</condition><then>
        <return>return <expr><call><name><name>mCachePump</name>-&gt;<name>Resume</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetLoadGroup</name></name><parameter_list>(<param><decl><type><name>nsILoadGroup</name> **</type><name>aLoadGroup</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aLoadGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>aLoadGroup</name> = <name>mLoadGroup</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aLoadGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetLoadGroup</name></name><parameter_list>(<param><decl><type><name>nsILoadGroup</name> *</type><name>aLoadGroup</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mLoadGroup</name> = <name>aLoadGroup</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mProgressSink</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetLoadFlags</name></name><parameter_list>(<param><decl><type><name>nsLoadFlags</name> *</type><name>aLoadFlags</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aLoadFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>aLoadFlags</name> = <name>mLoadFlags</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetLoadFlags</name></name><parameter_list>(<param><decl><type><name>nsLoadFlags</name></type> <name>aLoadFlags</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mLoadFlags</name> = <name>aLoadFlags</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsIChannel</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetOriginalURI</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> **</type><name>originalURI</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>originalURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>originalURI</name> = <name>mOriginalURI</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>originalURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetOriginalURI</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> *</type><name>originalURI</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>originalURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mOriginalURI</name> = <name>originalURI</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetURI</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> **</type><name>URI</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>URI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>URI</name> = <name>mURI</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>URI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetOwner</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> **</type><name>owner</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>owner</name> = <name>mOwner</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetOwner</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>owner</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mOwner</name> = <name>owner</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetNotificationCallbacks</name></name><parameter_list>(<param><decl><type><name>nsIInterfaceRequestor</name> **</type><name>callbacks</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>callbacks</name> = <name>mCallbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetNotificationCallbacks</name></name><parameter_list>(<param><decl><type><name>nsIInterfaceRequestor</name> *</type><name>callbacks</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mCallbacks</name> = <name>callbacks</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mProgressSink</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetSecurityInfo</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> **</type><name>securityInfo</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>securityInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>securityInfo</name> = <name>mSecurityInfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>securityInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetContentType</name></name><parameter_list>(<param><decl><type><name>nsACString</name> &amp;</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then> <block>{
        <comment type="line">// We got no data, we got no headers, we got nothing</comment>
        <expr_stmt><expr><call><name><name>value</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name><name>mResponseHead</name>-&gt;<name>ContentType</name></name><argument_list>()</argument_list></call>.<call><name>IsEmpty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>value</name> = <call><name><name>mResponseHead</name>-&gt;<name>ContentType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    
    <expr_stmt><expr><call><name><name>value</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr><name>UNKNOWN_CONTENT_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetContentType</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mListener</name> || <name>mWasOpened</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>contentTypeBuf</name></decl>, <decl><type ref="prev"/><name>charsetBuf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>hadCharset</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>net_ParseContentType</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>contentTypeBuf</name></expr></argument>, <argument><expr><name>charsetBuf</name></expr></argument>, <argument><expr>&amp;<name>hadCharset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>mResponseHead</name>-&gt;<name>SetContentType</name></name><argument_list>(<argument><expr><name>contentTypeBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// take care not to stomp on an existing charset</comment>
        <if>if <condition>(<expr><name>hadCharset</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mResponseHead</name>-&gt;<name>SetContentCharset</name></name><argument_list>(<argument><expr><name>charsetBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then> <else>else <block>{
        <comment type="line">// We are being given a content-type hint.</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>dummy</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>net_ParseContentType</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>mContentTypeHint</name></expr></argument>, <argument><expr><name>mContentCharsetHint</name></expr></argument>,
                             <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetContentCharset</name></name><parameter_list>(<param><decl><type><name>nsACString</name> &amp;</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>value</name> = <call><name><name>mResponseHead</name>-&gt;<name>ContentCharset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetContentCharset</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mListener</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
            <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name><name>mResponseHead</name>-&gt;<name>SetContentCharset</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// Charset hint</comment>
        <expr_stmt><expr><name>mContentCharsetHint</name> = <name>value</name></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetContentLength</name></name><parameter_list>(<param><decl><type><name>PRInt32</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

    <comment type="line">// XXX truncates to 32 bit</comment>
    <expr_stmt><expr><call><name>LL_L2I</name><argument_list>(<argument><expr>*<name>value</name></expr></argument>, <argument><expr><call><name><name>mResponseHead</name>-&gt;<name>ContentLength</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetContentLength</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_NOTYETIMPLEMENTED</name><argument_list>(<argument><expr>"nsHttpChannel::SetContentLength"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>Open</name></name><parameter_list>(<param><decl><type><name>nsIInputStream</name> **</type><name>_retval</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mWasOpened</name></expr></argument>, <argument><expr><name>NS_ERROR_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>NS_ImplementChannelOpen</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>_retval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>AsyncOpen</name></name><parameter_list>(<param><decl><type><name>nsIStreamListener</name> *</type><name>listener</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>context</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::AsyncOpen [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mIsPending</name></expr></argument>, <argument><expr><name>NS_ERROR_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mWasOpened</name></expr></argument>, <argument><expr><name>NS_ERROR_ALREADY_OPENED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>NS_CheckPortSafety</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>rv</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!(<name>mConnectionInfo</name> &amp;&amp; <call><name><name>mConnectionInfo</name>-&gt;<name>UsingHttpProxy</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then> <block>{
        <comment type="line">// Start a DNS lookup very early in case the real open is queued the DNS can </comment>
        <comment type="line">// happen in parallel. Do not do so in the presence of an HTTP proxy as </comment>
        <comment type="line">// all lookups other than for the proxy itself are done by the proxy.</comment>
        <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsDNSPrefetch</name></expr></argument>&gt;</argument_list></name></type> <name>prefetch</name> <init>= <expr>new <call><name>nsDNSPrefetch</name><argument_list>(<argument><expr><name>mURI</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>prefetch</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>prefetch</name>-&gt;<name>PrefetchHigh</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    
    <comment type="line">// Remember the cookie header that was set, if any</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cookieHeader</name> <init>= <expr><call><name><name>mRequestHead</name>.<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Cookie</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>cookieHeader</name></expr>)</condition><then>
        <expr_stmt><expr><name>mUserSetCookieHeader</name> = <name>cookieHeader</name></expr>;</expr_stmt></then></if>

    <comment type="line">// fetch cookies, and add them to the request header</comment>
    <expr_stmt><expr><call><name>AddCookiesToRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// notify "http-on-modify-request" observers</comment>
    <expr_stmt><expr><call><name><name>gHttpHandler</name>-&gt;<name>OnModifyRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Adjust mCaps according to our request headers:</comment>
    <comment type="line">//  - If "Connection: close" is set as a request header, then do not bother</comment>
    <comment type="line">//    trying to establish a keep-alive connection.</comment>
    <if>if <condition>(<expr><call><name><name>mRequestHead</name>.<name>HasHeaderValue</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Connection</name></name></expr></argument>, <argument><expr>"close"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>mCaps</name> &amp;= ~(<name>NS_HTTP_ALLOW_KEEPALIVE</name> | <name>NS_HTTP_ALLOW_PIPELINING</name>)</expr>;</expr_stmt></then></if>
    
    <if>if <condition>(<expr>(<name>mLoadFlags</name> &amp; <name>VALIDATE_ALWAYS</name>) || 
        (<call><name>BYPASS_LOCAL_CACHE</name><argument_list>(<argument><expr><name>mLoadFlags</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <expr_stmt><expr><name>mCaps</name> |= <name>NS_HTTP_REFRESH_DNS</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>mIsPending</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mWasOpened</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>mListener</name> = <name>listener</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mListenerContext</name> = <name>context</name></expr>;</expr_stmt>

    <comment type="line">// add ourselves to the load group.  from this point forward, we'll report</comment>
    <comment type="line">// all failures asynchronously.</comment>
    <if>if <condition>(<expr><name>mLoadGroup</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>AddRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// We may have been cancelled already, either by on-modify-request</comment>
    <comment type="line">// listeners or by load group observers; in that case, we should</comment>
    <comment type="line">// not send the request to the server</comment>
    <if>if <condition>(<expr><name>mCanceled</name></expr>)</condition><then>
        <expr_stmt><expr><name>rv</name> = <name>mStatus</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>rv</name> = <call><name>Connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("Calling AsyncAbort [rv=%x mCanceled=%i]\n", <name>rv</name>, <name>mCanceled</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseCacheEntry</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AsyncAbort</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_CLASSIFY_URI</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsChannelClassifier</name></expr></argument>&gt;</argument_list></name></type> <name>classifier</name> <init>= <expr>new <call><name>nsChannelClassifier</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>classifier</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_OK</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name><name>classifier</name>-&gt;<name>Start</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Cancel</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsIHttpChannel</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetRequestMethod</name></name><parameter_list>(<param><decl><type><name>nsACString</name> &amp;</type><name>method</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>method</name> = <call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetRequestMethod</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>method</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mIsPending</name></expr></argument>, <argument><expr><name>NS_ERROR_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>nsCString</name> &amp;</type><name>flatMethod</name> <init>= <expr><call><name>PromiseFlatCString</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Method names are restricted to valid HTTP tokens.</comment>
    <if>if <condition>(<expr>!<call><name><name>nsHttp</name>::<name>IsValidToken</name></name><argument_list>(<argument><expr><name>flatMethod</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsHttpAtom</name></type> <name>atom</name> <init>= <expr><call><name><name>nsHttp</name>::<name>ResolveAtom</name></name><argument_list>(<argument><expr><call><name><name>flatMethod</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>atom</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetMethod</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetReferrer</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> **</type><name>referrer</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>referrer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>referrer</name> = <name>mReferrer</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>referrer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetReferrer</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> *</type><name>referrer</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mIsPending</name></expr></argument>, <argument><expr><name>NS_ERROR_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// clear existing referrer, if any</comment>
    <expr_stmt><expr><name>mReferrer</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>ClearHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Referer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>referrer</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <comment type="line">// check referrer blocking pref</comment>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>referrerLevel</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_INITIAL_DOCUMENT_URI</name></expr>)</condition><then>
        <expr_stmt><expr><name>referrerLevel</name> = 1</expr>;</expr_stmt></then> <comment type="line">// user action</comment>
    <else>else
        <expr_stmt><expr><name>referrerLevel</name> = 2</expr>;</expr_stmt></else></if> <comment type="line">// inline content</comment>
    <if>if <condition>(<expr><call><name><name>gHttpHandler</name>-&gt;<name>ReferrerLevel</name></name><argument_list>()</argument_list></call> &lt; <name>referrerLevel</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>referrerGrip</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>match</name></decl>;</decl_stmt>

    <comment type="line">//</comment>
    <comment type="line">// Strip off "wyciwyg://123/" from wyciwyg referrers.</comment>
    <comment type="line">//</comment>
    <comment type="line">// XXX this really belongs elsewhere since wyciwyg URLs aren't part of necko.</comment>
    <comment type="line">//     perhaps some sort of generic nsINestedURI could be used.  then, if an URI</comment>
    <comment type="line">//     fails the whitelist test, then we could check for an inner URI and try</comment>
    <comment type="line">//     that instead.  though, that might be too automatic.</comment>
    <comment type="line">// </comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>referrer</name>-&gt;<name>SchemeIs</name></name><argument_list>(<argument><expr>"wyciwyg"</expr></argument>, <argument><expr>&amp;<name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>match</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>path</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>referrer</name>-&gt;<name>GetPath</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>PRUint32</name></type> <name>pathLength</name> <init>= <expr><call><name><name>path</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pathLength</name> &lt;= 2</expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

        <comment type="line">// Path is of the form "//123/http://foo/bar", with a variable number of digits.</comment>
        <comment type="line">// To figure out where the "real" URL starts, search path for a '/', starting at </comment>
        <comment type="line">// the third character.</comment>
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>slashIndex</name> <init>= <expr><call><name><name>path</name>.<name>FindChar</name></name><argument_list>(<argument><expr>'/'</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>slashIndex</name> == <name>kNotFound</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

        <comment type="line">// Get the charset of the original URI so we can pass it to our fixed up URI.</comment>
        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>charset</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>referrer</name>-&gt;<name>GetOriginCharset</name></name><argument_list>(<argument><expr><name>charset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Replace |referrer| with a URI without wyciwyg://123/.</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>NS_NewURI</name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>referrerGrip</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name>Substring</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>slashIndex</name> + 1</expr></argument>, <argument><expr><name>pathLength</name> - <name>slashIndex</name> - 1</expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name><name>charset</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>referrer</name> = <call><name><name>referrerGrip</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">//</comment>
    <comment type="line">// block referrer if not on our white list...</comment>
    <comment type="line">//</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name><name>referrerWhiteList</name><index>[]</index></name> <init>= <expr><block>{
        <expr>"http"</expr>,
        <expr>"https"</expr>,
        <expr>"ftp"</expr>,
        <expr>"gopher"</expr>,
        <expr><name>nsnull</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>match</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *<specifier>const</specifier> *</type><name>scheme</name> <init>= <expr><name>referrerWhiteList</name></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init> <condition><expr>*<name>scheme</name> &amp;&amp; !<name>match</name></expr>;</condition> <incr><expr>++<name>scheme</name></expr></incr>) <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>referrer</name>-&gt;<name>SchemeIs</name></name><argument_list>(<argument><expr>*<name>scheme</name></expr></argument>, <argument><expr>&amp;<name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></for>
    <if>if <condition>(<expr>!<name>match</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if> <comment type="line">// kick out....</comment>

    <comment type="line">//</comment>
    <comment type="line">// Handle secure referrals.</comment>
    <comment type="line">//</comment>
    <comment type="line">// Support referrals from a secure server if this is a secure site</comment>
    <comment type="line">// and (optionally) if the host names are the same.</comment>
    <comment type="line">//</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>referrer</name>-&gt;<name>SchemeIs</name></name><argument_list>(<argument><expr>"https"</expr></argument>, <argument><expr>&amp;<name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>match</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>SchemeIs</name></name><argument_list>(<argument><expr>"https"</expr></argument>, <argument><expr>&amp;<name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<name>match</name></expr>)</condition><then>
            <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

        <if>if <condition>(<expr>!<call><name><name>gHttpHandler</name>-&gt;<name>SendSecureXSiteReferrer</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>referrerHost</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>host</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rv</name> = <call><name><name>referrer</name>-&gt;<name>GetAsciiHost</name></name><argument_list>(<argument><expr><name>referrerHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name><name>mURI</name>-&gt;<name>GetAsciiHost</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

            <comment type="line">// GetAsciiHost returns lowercase hostname.</comment>
            <if>if <condition>(<expr>!<call><name><name>referrerHost</name>.<name>Equals</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURI</name></expr></argument>&gt;</argument_list></name></type> <name>clone</name></decl>;</decl_stmt>
    <comment type="line">//</comment>
    <comment type="line">// we need to clone the referrer, so we can:</comment>
    <comment type="line">//  (1) modify it</comment>
    <comment type="line">//  (2) keep a reference to it after returning from this function</comment>
    <comment type="line">//</comment>
    <expr_stmt><expr><name>rv</name> = <call><name><name>referrer</name>-&gt;<name>Clone</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>clone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// strip away any userpass; we don't want to be giving out passwords ;-)</comment>
    <expr_stmt><expr><call><name><name>clone</name>-&gt;<name>SetUserPass</name></name><argument_list>(<argument><expr><call><name>EmptyCString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// strip away any fragment per RFC 2616 section 14.36</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIURL</name></expr></argument>&gt;</argument_list></name></type> <name>url</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>clone</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>url</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>url</name>-&gt;<name>SetRef</name></name><argument_list>(<argument><expr><call><name>EmptyCString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>spec</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>clone</name>-&gt;<name>GetAsciiSpec</name></name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// finally, remember the referrer URI and set the Referer header.</comment>
    <expr_stmt><expr><name>mReferrer</name> = <name>clone</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Referer</name></name></expr></argument>, <argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetRequestHeader</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>header</name></decl></param>, <param><decl><type><name>nsACString</name> &amp;</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// XXX might be better to search the header list directly instead of</comment>
    <comment type="line">// hitting the http atom hash table.</comment>

    <decl_stmt><decl><type><name>nsHttpAtom</name></type> <name>atom</name> <init>= <expr><call><name><name>nsHttp</name>::<name>ResolveAtom</name></name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>atom</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

    <return>return <expr><call><name><name>mRequestHead</name>.<name>GetHeader</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetRequestHeader</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>header</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>value</name></decl></param>,
                                <param><decl><type><name>PRBool</name></type> <name>merge</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mIsPending</name></expr></argument>, <argument><expr><name>NS_ERROR_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>nsCString</name> &amp;</type><name>flatHeader</name> <init>= <expr><call><name>PromiseFlatCString</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsCString</name> &amp;</type><name>flatValue</name>  <init>= <expr><call><name>PromiseFlatCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::SetRequestHeader [this=%p header=\"%s\" value=\"%s\" merge=%u]\n",
        <name>this</name>, <call><name><name>flatHeader</name>.<name>get</name></name><argument_list>()</argument_list></call>, <call><name><name>flatValue</name>.<name>get</name></name><argument_list>()</argument_list></call>, <name>merge</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Header names are restricted to valid HTTP tokens.</comment>
    <if>if <condition>(<expr>!<call><name><name>nsHttp</name>::<name>IsValidToken</name></name><argument_list>(<argument><expr><name>flatHeader</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>
    
    <comment type="line">// Header values MUST NOT contain line-breaks.  RFC 2616 technically</comment>
    <comment type="line">// permits CTL characters, including CR and LF, in header values provided</comment>
    <comment type="line">// they are quoted.  However, this can lead to problems if servers do not</comment>
    <comment type="line">// interpret quoted strings properly.  Disallowing CR and LF here seems</comment>
    <comment type="line">// reasonable and keeps things simple.  We also disallow a null byte.</comment>
    <if>if <condition>(<expr><call><name><name>flatValue</name>.<name>FindCharInSet</name></name><argument_list>(<argument><expr>"\r\n"</expr></argument>)</argument_list></call> != <name>kNotFound</name> ||
        <call><name><name>flatValue</name>.<name>Length</name></name><argument_list>()</argument_list></call> != <call><name>strlen</name><argument_list>(<argument><expr><call><name><name>flatValue</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_INVALID_ARG</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsHttpAtom</name></type> <name>atom</name> <init>= <expr><call><name><name>nsHttp</name>::<name>ResolveAtom</name></name><argument_list>(<argument><expr><call><name><name>flatHeader</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>atom</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"failed to resolve atom"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>flatValue</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>VisitRequestHeaders</name></name><parameter_list>(<param><decl><type><name>nsIHttpHeaderVisitor</name> *</type><name>visitor</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>mRequestHead</name>.<name>Headers</name></name><argument_list>()</argument_list></call>.<call><name>VisitHeaders</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetUploadStream</name></name><parameter_list>(<param><decl><type><name>nsIInputStream</name> **</type><name>stream</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>stream</name> = <name>mUploadStream</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetUploadStream</name></name><parameter_list>(<param><decl><type><name>nsIInputStream</name> *</type><name>stream</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>contentType</name></decl></param>,
                               <param><decl><type><name>PRInt32</name></type> <name>contentLength</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// NOTE: for backwards compatibility and for compatibility with old style</comment>
    <comment type="line">// plugins, |stream| may include headers, specifically Content-Type and</comment>
    <comment type="line">// Content-Length headers.  in this case, |contentType| and |contentLength|</comment>
    <comment type="line">// would be unspecified.  this is traditionally the case of a POST request,</comment>
    <comment type="line">// and so we select POST as the request method if contentType and</comment>
    <comment type="line">// contentLength are unspecified.</comment>
    
    <if>if <condition>(<expr><name>stream</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name><name>contentType</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>contentLength</name> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>stream</name>-&gt;<name>Available</name></name><argument_list>(<argument><expr>(<name>PRUint32</name> *) &amp;<name>contentLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>contentLength</name> &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"unable to determine content length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
                }</block></then></if>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Length</name></name></expr></argument>,
                                   <argument><expr><call><name>nsPrintfCString</name><argument_list>(<argument><expr>"%d"</expr></argument>, <argument><expr><name>contentLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Type</name></name></expr></argument>, <argument><expr><name>contentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mUploadStreamHasHeaders</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetMethod</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Put</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// PUT request</comment>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>mUploadStreamHasHeaders</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetMethod</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// POST request</comment>
        }</block></else></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>mUploadStreamHasHeaders</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetMethod</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Get</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// revert to GET request</comment>
    }</block></else></if>
    <expr_stmt><expr><name>mUploadStream</name> = <name>stream</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>ExplicitSetUploadStream</name></name><parameter_list>(<param><decl><type><name>nsIInputStream</name> *</type><name>aStream</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>aContentType</name></decl></param>,
                                       <param><decl><type><name>PRInt64</name></type> <name>aContentLength</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>aMethod</name></decl></param>,
                                       <param><decl><type><name>PRBool</name></type> <name>aStreamHasHeaders</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Ensure stream is set and method is valid </comment>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>aStream</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>aContentLength</name> &lt; 0 &amp;&amp; !<name>aStreamHasHeaders</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>streamLength</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>aStream</name>-&gt;<name>Available</name></name><argument_list>(<argument><expr>&amp;<name>streamLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aContentLength</name> = <name>streamLength</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>aContentLength</name> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"unable to determine content length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>SetRequestMethod</name><argument_list>(<argument><expr><name>aMethod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>aStreamHasHeaders</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Length</name></name></expr></argument>,
                               <argument><expr><call><name>nsPrintfCString</name><argument_list>(<argument><expr>"%lld"</expr></argument>, <argument><expr><name>aContentLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mRequestHead</name>.<name>SetHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Type</name></name></expr></argument>, <argument><expr><name>aContentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>mUploadStreamHasHeaders</name> = <name>aStreamHasHeaders</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mUploadStream</name> = <name>aStream</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetResponseStatus</name></name><parameter_list>(<param><decl><type><name>PRUint32</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <expr_stmt><expr>*<name>value</name> = <call><name><name>mResponseHead</name>-&gt;<name>Status</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetResponseStatusText</name></name><parameter_list>(<param><decl><type><name>nsACString</name> &amp;</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>value</name> = <call><name><name>mResponseHead</name>-&gt;<name>StatusText</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetRequestSucceeded</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"Don't ever pass a null arg to this function"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>status</name> <init>= <expr><call><name><name>mResponseHead</name>-&gt;<name>Status</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>value</name> = (<name>status</name> / 100 == 2)</expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetResponseHeader</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>header</name></decl></param>, <param><decl><type><name>nsACString</name> &amp;</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>nsHttpAtom</name></type> <name>atom</name> <init>= <expr><call><name><name>nsHttp</name>::<name>ResolveAtom</name></name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>atom</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <return>return <expr><call><name><name>mResponseHead</name>-&gt;<name>GetHeader</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetResponseHeader</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>header</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>value</name></decl></param>,
                                 <param><decl><type><name>PRBool</name></type> <name>merge</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::SetResponseHeader [this=%p header=\"%s\" value=\"%s\" merge=%u]\n",
        <name>this</name>, <call><name>PromiseFlatCString</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call>, <call><name>PromiseFlatCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call>, <name>merge</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>nsHttpAtom</name></type> <name>atom</name> <init>= <expr><call><name><name>nsHttp</name>::<name>ResolveAtom</name></name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>atom</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

    <comment type="line">// these response headers must not be changed </comment>
    <if>if <condition>(<expr><name>atom</name> == <name><name>nsHttp</name>::<name>Content_Type</name></name> ||
        <name>atom</name> == <name><name>nsHttp</name>::<name>Content_Length</name></name> ||
        <name>atom</name> == <name><name>nsHttp</name>::<name>Content_Encoding</name></name> ||
        <name>atom</name> == <name><name>nsHttp</name>::<name>Trailer</name></name> ||
        <name>atom</name> == <name><name>nsHttp</name>::<name>Transfer_Encoding</name></name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_ILLEGAL_VALUE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mResponseHeadersModified</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <return>return <expr><call><name><name>mResponseHead</name>-&gt;<name>SetHeader</name></name><argument_list>(<argument><expr><name>atom</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>VisitResponseHeaders</name></name><parameter_list>(<param><decl><type><name>nsIHttpHeaderVisitor</name> *</type><name>visitor</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <return>return <expr><call><name><name>mResponseHead</name>-&gt;<name>Headers</name></name><argument_list>()</argument_list></call>.<call><name>VisitHeaders</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>IsNoStoreResponse</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <expr_stmt><expr>*<name>value</name> = <call><name><name>mResponseHead</name>-&gt;<name>NoStore</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>IsNoCacheResponse</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <expr_stmt><expr>*<name>value</name> = <call><name><name>mResponseHead</name>-&gt;<name>NoCache</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!*<name>value</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>value</name> = <call><name><name>mResponseHead</name>-&gt;<name>ExpiresInPast</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetApplyConversion</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>value</name> = <name>mApplyConversion</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetApplyConversion</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::SetApplyConversion [this=%p value=%d]\n", <name>this</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mApplyConversion</name> = <name>value</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetAllowPipelining</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>value</name> = <name>mAllowPipelining</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetAllowPipelining</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mIsPending</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>mAllowPipelining</name> = <name>value</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetRedirectionLimit</name></name><parameter_list>(<param><decl><type><name>PRUint32</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>value</name> = <call><name>PRUint32</name><argument_list>(<argument><expr><name>mRedirectionLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetRedirectionLimit</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mRedirectionLimit</name> = <call><name>PR_MIN</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetContentEncodings</name></name><parameter_list>(<param><decl><type><name>nsIUTF8StringEnumerator</name>**</type> <name>aEncodings</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aEncodings</name></expr></argument>, <argument><expr>"Null out param"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>aEncodings</name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>
    
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr><call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Content_Encoding</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>encoding</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>aEncodings</name> = <name>nsnull</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>nsContentEncodings</name>*</type> <name>enumerator</name> <init>= <expr>new <call><name>nsContentEncodings</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>enumerator</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr>*<name>aEncodings</name> = <name>enumerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsIHttpChannelInternal</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetDocumentURI</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> **</type><name>aDocumentURI</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aDocumentURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>aDocumentURI</name> = <name>mDocumentURI</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aDocumentURI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetDocumentURI</name></name><parameter_list>(<param><decl><type><name>nsIURI</name> *</type><name>aDocumentURI</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mDocumentURI</name> = <name>aDocumentURI</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetForceAllowThirdPartyCookie</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aForceAllowThirdPartyCookie</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>aForceAllowThirdPartyCookie</name> = <name>mForceAllowThirdPartyCookie</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetForceAllowThirdPartyCookie</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForceAllowThirdPartyCookie</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mForceAllowThirdPartyCookie</name> = <name>aForceAllowThirdPartyCookie</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetRequestVersion</name></name><parameter_list>(<param><decl><type><name>PRUint32</name> *</type><name>major</name></decl></param>, <param><decl><type><name>PRUint32</name> *</type><name>minor</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>version</name> <init>= <expr><call><name><name>mRequestHead</name>.<name>Version</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>major</name></expr>)</condition><then> <block>{ <expr_stmt><expr>*<name>major</name> = <name>version</name> / 10</expr>;</expr_stmt> }</block></then></if>
  <if>if <condition>(<expr><name>minor</name></expr>)</condition><then> <block>{ <expr_stmt><expr>*<name>minor</name> = <name>version</name> % 10</expr>;</expr_stmt> }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetResponseVersion</name></name><parameter_list>(<param><decl><type><name>PRUint32</name> *</type><name>major</name></decl></param>, <param><decl><type><name>PRUint32</name> *</type><name>minor</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mResponseHead</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr>*<name>major</name> = *<name>minor</name> = 0</expr>;</expr_stmt>                   <comment type="line">// we should at least be kind about it</comment>
    <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>int</name></type> <name>version</name> <init>= <expr><call><name><name>mResponseHead</name>-&gt;<name>Version</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>major</name></expr>)</condition><then> <block>{ <expr_stmt><expr>*<name>major</name> = <name>version</name> / 10</expr>;</expr_stmt> }</block></then></if>
  <if>if <condition>(<expr><name>minor</name></expr>)</condition><then> <block>{ <expr_stmt><expr>*<name>minor</name> = <name>version</name> % 10</expr>;</expr_stmt> }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetCookie</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aCookieHeader</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>LOAD_ANONYMOUS</name></expr>)</condition><then> <block>{
      <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// empty header isn't an error</comment>
    <if>if <condition>(<expr>!(<name>aCookieHeader</name> &amp;&amp; *<name>aCookieHeader</name>)</expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>nsICookieService</name> *</type><name>cs</name> <init>= <expr><call><name><name>gHttpHandler</name>-&gt;<name>GetCookieService</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>NS_ERROR_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrompt</name></expr></argument>&gt;</argument_list></name></type> <name>prompt</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetCallback</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name><name>cs</name>-&gt;<name>SetCookieStringFromHttp</name></name><argument_list>(<argument><expr><name>mURI</name></expr></argument>,
                                       <argument><expr><name>mDocumentURI</name> ? <name>mDocumentURI</name> : <name>mOriginalURI</name></expr></argument>,
                                       <argument><expr><name>prompt</name></expr></argument>,
                                       <argument><expr><name>aCookieHeader</name></expr></argument>,
                                       <argument><expr><call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Date</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetupFallbackChannel</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aFallbackKey</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::SetupFallbackChannel [this=%p, key=%s]",
         <name>this</name>, <name>aFallbackKey</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mFallbackChannel</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mFallbackKey</name> = <name>aFallbackKey</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsISupportsPriority</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetPriority</name></name><parameter_list>(<param><decl><type><name>PRInt32</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>value</name> = <name>mPriority</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetPriority</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PRInt16</name></type> <name>newValue</name> <init>= <expr><call><name>NS_CLAMP</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>PR_INT16_MIN</name></expr></argument>, <argument><expr><name>PR_INT16_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>mPriority</name> == <name>newValue</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
    <expr_stmt><expr><name>mPriority</name> = <name>newValue</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mTransaction</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>gHttpHandler</name>-&gt;<name>RescheduleTransaction</name></name><argument_list>(<argument><expr><name>mTransaction</name></expr></argument>, <argument><expr><name>mPriority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>AdjustPriority</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>delta</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>SetPriority</name><argument_list>(<argument><expr><name>mPriority</name> + <name>delta</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsIProtocolProxyCallback</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>OnProxyAvailable</name></name><parameter_list>(<param><decl><type><name>nsICancelable</name> *</type><name>request</name></decl></param>, <param><decl><type><name>nsIURI</name> *</type><name>uri</name></decl></param>,
                                <param><decl><type><name>nsIProxyInfo</name> *</type><name>pi</name></decl></param>, <param><decl><type><name>nsresult</name></type> <name>status</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mProxyRequest</name> = <name>nsnull</name></expr>;</expr_stmt>

    <comment type="line">// If status is a failure code, then it means that we failed to resolve</comment>
    <comment type="line">// proxy info.  That is a non-fatal error assuming it wasn't because the</comment>
    <comment type="line">// request was canceled.  We just failover to DIRECT when proxy resolution</comment>
    <comment type="line">// fails (failure can mean that the PAC URL could not be loaded).</comment>
    
    <comment type="line">// Need to replace this channel with a new one.  It would be complex to try</comment>
    <comment type="line">// to change the value of mConnectionInfo since so much of our state may</comment>
    <comment type="line">// depend on its state.</comment>
    <expr_stmt><expr><name>mTargetProxyInfo</name> = <name>pi</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HandleAsyncReplaceWithProxy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsIProxiedChannel</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetProxyInfo</name></name><parameter_list>(<param><decl><type><name>nsIProxyInfo</name> **</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mConnectionInfo</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>result</name> = <name>nsnull</name></expr>;</expr_stmt></then>
    <else>else <block>{
        <expr_stmt><expr>*<name>result</name> = <call><name><name>mConnectionInfo</name>-&gt;<name>ProxyInfo</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsIRequestObserver</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>OnStartRequest</name></name><parameter_list>(<param><decl><type><name>nsIRequest</name> *</type><name>request</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>ctxt</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!(<name>mCanceled</name> || <call><name>NS_FAILED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <comment type="line">// capture the request's status, so our consumers will know ASAP of any</comment>
        <comment type="line">// connection failures, etc - bug 93581</comment>
        <expr_stmt><expr><call><name><name>request</name>-&gt;<name>GetStatus</name></name><argument_list>(<argument><expr>&amp;<name>mStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::OnStartRequest [this=%p request=%p status=%x]\n",
        <name>this</name>, <name>request</name>, <name>mStatus</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Make sure things are what we expect them to be...</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>request</name> == <name>mCachePump</name> || <name>request</name> == <name>mTransactionPump</name></expr></argument>,
                 <argument><expr>"Unexpected request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!(<name>mTransactionPump</name> &amp;&amp; <name>mCachePump</name>) || <name>mCachedContentIsPartial</name></expr></argument>,
                 <argument><expr>"If we have both pumps, the cache content must be partial"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>mSecurityInfo</name> &amp;&amp; !<name>mCachePump</name> &amp;&amp; <name>mTransaction</name></expr>)</condition><then> <block>{
        <comment type="line">// grab the security info from the connection object; the transaction</comment>
        <comment type="line">// is guaranteed to own a reference to the connection.</comment>
        <expr_stmt><expr><name>mSecurityInfo</name> = <call><name><name>mTransaction</name>-&gt;<name>SecurityInfo</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// don't enter this block if we're reading from the cache...</comment>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>mCachePump</name> &amp;&amp; <name>mTransaction</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mResponseHead</name> == <name>nsnull</name></expr></argument>, <argument><expr>"leaking mResponseHead"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// all of the response headers have been acquired, so we can take ownership</comment>
        <comment type="line">// of them from the transaction.</comment>
        <expr_stmt><expr><name>mResponseHead</name> = <call><name><name>mTransaction</name>-&gt;<name>TakeResponseHead</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// the response head may be null if the transaction was cancelled.  in</comment>
        <comment type="line">// which case we just need to call OnStartRequest/OnStopRequest.</comment>
        <if>if <condition>(<expr><name>mResponseHead</name></expr>)</condition><then>
            <return>return <expr><call><name>ProcessResponse</name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"No response head in OnStartRequest"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// avoid crashing if mListener happens to be null...</comment>
    <if>if <condition>(<expr>!<name>mListener</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"mListener is null"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// on proxy errors, try to failover</comment>
    <if>if <condition>(<expr><call><name><name>mConnectionInfo</name>-&gt;<name>ProxyInfo</name></name><argument_list>()</argument_list></call> &amp;&amp;
           (<name>mStatus</name> == <name>NS_ERROR_PROXY_CONNECTION_REFUSED</name> ||
            <name>mStatus</name> == <name>NS_ERROR_UNKNOWN_PROXY_HOST</name> ||
            <name>mStatus</name> == <name>NS_ERROR_NET_TIMEOUT</name>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name>ProxyFailover</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
    }</block></then></if>

    <comment type="line">// on other request errors, try to fall back</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>fallingBack</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call> &amp;&amp;
        <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name>ProcessFallback</name><argument_list>(<argument><expr>&amp;<name>fallingBack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp;
        <name>fallingBack</name></expr>)</condition><then> <block>{

        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>CallOnStartRequest</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>OnStopRequest</name></name><parameter_list>(<param><decl><type><name>nsIRequest</name> *</type><name>request</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>ctxt</name></decl></param>, <param><decl><type><name>nsresult</name></type> <name>status</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::OnStopRequest [this=%p request=%p status=%x]\n",
        <name>this</name>, <name>request</name>, <name>status</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// honor the cancelation status even if the underlying transaction completed.</comment>
    <if>if <condition>(<expr><name>mCanceled</name> || <call><name>NS_FAILED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>status</name> = <name>mStatus</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>mCachedContentIsPartial</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// mTransactionPump should be suspended</comment>
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>request</name> != <name>mTransactionPump</name></expr></argument>,
                <argument><expr>"byte-range transaction finished prematurely"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>request</name> == <name>mCachePump</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>PRBool</name></type> <name>streamDone</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>status</name> = <call><name>OnDoneReadingPartialCacheEntry</name><argument_list>(<argument><expr>&amp;<name>streamDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>streamDone</name></expr>)</condition><then>
                    <return>return <expr><name>status</name></expr>;</return></then></if>
                <comment type="line">// otherwise, fall through and fire OnStopRequest...</comment>
            }</block></then>
            <else>else
                <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"unexpected request"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>
        <comment type="line">// Do not to leave the transaction in a suspended state in error cases.</comment>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> &amp;&amp; <name>mTransaction</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>gHttpHandler</name>-&gt;<name>CancelTransaction</name></name><argument_list>(<argument><expr><name>mTransaction</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> 
    }</block></then></if>

    <if>if <condition>(<expr><name>mTransaction</name></expr>)</condition><then> <block>{
        <comment type="line">// determine if we should call DoAuthRetry</comment>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>authRetry</name> <init>= <expr><name>mAuthRetryPending</name> &amp;&amp; <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">//</comment>
        <comment type="line">// grab reference to connection in case we need to retry an</comment>
        <comment type="line">// authentication request over it.  this applies to connection based</comment>
        <comment type="line">// authentication schemes only.  for request based schemes, conn is not</comment>
        <comment type="line">// needed, so it may be null.</comment>
        <comment type="line">// </comment>
        <comment type="line">// this code relies on the code in nsHttpTransaction::Close, which</comment>
        <comment type="line">// tests for NS_HTTP_STICKY_CONNECTION to determine whether or not to</comment>
        <comment type="line">// keep the connection around after the transaction is finished.</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsAHttpConnection</name></expr></argument>&gt;</argument_list></name></type> <name>conn</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>authRetry</name> &amp;&amp; (<name>mCaps</name> &amp; <name>NS_HTTP_STICKY_CONNECTION</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>conn</name> = <call><name><name>mTransaction</name>-&gt;<name>Connection</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// This is so far a workaround to fix leak when reusing unpersistent</comment>
            <comment type="line">// connection for authentication retry. See bug 459620 comment 4</comment>
            <comment type="line">// for details.</comment>
            <if>if <condition>(<expr><name>conn</name> &amp;&amp; !<call><name><name>conn</name>-&gt;<name>IsPersistent</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>conn</name> = <name>nsnull</name></expr>;</expr_stmt></then></if>
        }</block></then></if>

        <comment type="line">// at this point, we're done with the transaction</comment>
        <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>mTransaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mTransactionPump</name> = 0</expr>;</expr_stmt>

        <comment type="line">// handle auth retry...</comment>
        <if>if <condition>(<expr><name>authRetry</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mAuthRetryPending</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <call><name>DoAuthRetry</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
        }</block></then></if>

        <comment type="line">// If DoAuthRetry failed, or if we have been cancelled since showing</comment>
        <comment type="line">// the auth. dialog, then we need to send OnStartRequest now</comment>
        <if>if <condition>(<expr><name>authRetry</name> || (<name>mAuthRetryPending</name> &amp;&amp; <call><name>NS_FAILED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"should have a failure code here"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// NOTE: since we have a failure status, we can ignore the return</comment>
            <comment type="line">// value from onStartRequest.</comment>
            <expr_stmt><expr><call><name><name>mListener</name>-&gt;<name>OnStartRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// if this transaction has been replaced, then bail.</comment>
        <if>if <condition>(<expr><name>mTransactionReplaced</name></expr>)</condition><then>
            <return>return <expr><name>NS_OK</name></expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>mIsPending</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mStatus</name> = <name>status</name></expr>;</expr_stmt>

    <comment type="line">// perform any final cache operations before we close the cache entry.</comment>
    <if>if <condition>(<expr><name>mCacheEntry</name> &amp;&amp; (<name>mCacheAccess</name> &amp; <name><name>nsICache</name>::<name>ACCESS_WRITE</name></name>)</expr>)</condition><then>
        <expr_stmt><expr><call><name>FinalizeCacheEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    
    <if>if <condition>(<expr><name>mListener</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("  calling OnStopRequest\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mListener</name>-&gt;<name>OnStopRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mListenerContext</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mListener</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>mListenerContext</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>mCacheEntry</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>CloseCacheEntry</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>mOfflineCacheEntry</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>CloseOfflineCacheEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>mLoadGroup</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mLoadGroup</name>-&gt;<name>RemoveRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>mCallbacks</name> = <name>nsnull</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mProgressSink</name> = <name>nsnull</name></expr>;</expr_stmt>
    
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsIStreamListener</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>OnDataAvailable</name></name><parameter_list>(<param><decl><type><name>nsIRequest</name> *</type><name>request</name></decl></param>, <param><decl><type><name>nsISupports</name> *</type><name>ctxt</name></decl></param>,
                               <param><decl><type><name>nsIInputStream</name> *</type><name>input</name></decl></param>,
                               <param><decl><type><name>PRUint32</name></type> <name>offset</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>count</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::OnDataAvailable [this=%p request=%p offset=%u count=%u]\n",
        <name>this</name>, <name>request</name>, <name>offset</name>, <name>count</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// don't send out OnDataAvailable notifications if we've been canceled.</comment>
    <if>if <condition>(<expr><name>mCanceled</name></expr>)</condition><then>
        <return>return <expr><name>mStatus</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mResponseHead</name></expr></argument>, <argument><expr>"No response head in ODA!!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!(<name>mCachedContentIsPartial</name> &amp;&amp; (<name>request</name> == <name>mTransactionPump</name>))</expr></argument>,
            <argument><expr>"transaction pump not suspended"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mAuthRetryPending</name> || (<name>request</name> == <name>mTransactionPump</name> &amp;&amp; <name>mTransactionReplaced</name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRUint32</name></type> <name>n</name></decl>;</decl_stmt>
        <return>return <expr><call><name><name>input</name>-&gt;<name>ReadSegments</name></name><argument_list>(<argument><expr><name>NS_DiscardSegment</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>mListener</name></expr>)</condition><then> <block>{
        <comment type="line">//</comment>
        <comment type="line">// synthesize transport progress event.  we do this here since we want</comment>
        <comment type="line">// to delay OnProgress events until we start streaming data.  this is</comment>
        <comment type="line">// crucially important since it impacts the lock icon (see bug 240053).</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>transportStatus</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>request</name> == <name>mCachePump</name></expr>)</condition><then>
            <expr_stmt><expr><name>transportStatus</name> = <name><name>nsITransport</name>::<name>STATUS_READING</name></name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>transportStatus</name> = <name><name>nsISocketTransport</name>::<name>STATUS_RECEIVING_FROM</name></name></expr>;</expr_stmt></else></if>

        <comment type="line">// mResponseHead may reference new or cached headers, but either way it</comment>
        <comment type="line">// holds our best estimate of the total content length.  Even in the case</comment>
        <comment type="line">// of a byte range request, the content length stored in the cached</comment>
        <comment type="line">// response headers is what we want to use here.</comment>

        <decl_stmt><decl><type><name>PRUint64</name></type> <name>progressMax</name><argument_list>(<argument><expr><call><name>PRUint64</name><argument_list>(<argument><expr><call><name><name>mResponseHead</name>-&gt;<name>ContentLength</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRUint64</name></type> <name>progress</name> <init>= <expr><name>mLogicalOffset</name> + <call><name>PRUint64</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>progress</name> &lt;= <name>progressMax</name></expr></argument>, <argument><expr>"unexpected progress values"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>OnTransportStatus</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>transportStatus</name></expr></argument>, <argument><expr><name>progress</name></expr></argument>, <argument><expr><name>progressMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//</comment>
        <comment type="line">// we have to manually keep the logical offset of the stream up-to-date.</comment>
        <comment type="line">// we cannot depend solely on the offset provided, since we may have </comment>
        <comment type="line">// already streamed some data from another source (see, for example,</comment>
        <comment type="line">// OnDoneReadingPartialCacheEntry).</comment>
        <comment type="line">//</comment>
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>=  <expr><call><name><name>mListener</name>-&gt;<name>OnDataAvailable</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>,
                                                  <argument><expr><name>mListenerContext</name></expr></argument>,
                                                  <argument><expr><name>input</name></expr></argument>,
                                                  <argument><expr><name>mLogicalOffset</name></expr></argument>,
                                                  <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>mLogicalOffset</name> = <name>progress</name></expr>;</expr_stmt></then></if>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NS_ERROR_ABORT</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsITransportEventSink</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>OnTransportStatus</name></name><parameter_list>(<param><decl><type><name>nsITransport</name> *</type><name>trans</name></decl></param>, <param><decl><type><name>nsresult</name></type> <name>status</name></decl></param>,
                                 <param><decl><type><name>PRUint64</name></type> <name>progress</name></decl></param>, <param><decl><type><name>PRUint64</name></type> <name>progressMax</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// cache the progress sink so we don't have to query for it each time.</comment>
    <if>if <condition>(<expr>!<name>mProgressSink</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>GetCallback</name><argument_list>(<argument><expr><name>mProgressSink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// block socket status event after Cancel or OnStopRequest has been called.</comment>
    <if>if <condition>(<expr><name>mProgressSink</name> &amp;&amp; <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call> &amp;&amp; <name>mIsPending</name> &amp;&amp; !(<name>mLoadFlags</name> &amp; <name>LOAD_BACKGROUND</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("sending status notification [this=%p status=%x progress=%llu/%llu]\n",
            <name>this</name>, <name>status</name>, <name>progress</name>, <name>progressMax</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>host</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mURI</name>-&gt;<name>GetHost</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mProgressSink</name>-&gt;<name>OnStatus</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>status</name></expr></argument>,
                                <argument><expr><call><name>NS_ConvertUTF8toUTF16</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>progress</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>progress</name> &lt;= <name>progressMax</name></expr></argument>, <argument><expr>"unexpected progress values"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mProgressSink</name>-&gt;<name>OnProgress</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>progress</name></expr></argument>, <argument><expr><name>progressMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <else>else
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("skipping status notification [this=%p sink=%p pending=%u background=%x]\n",
            <name>this</name>, <call><name><name>mProgressSink</name>.<name>get</name></name><argument_list>()</argument_list></call>, <name>mIsPending</name>, (<name>mLoadFlags</name> &amp; <name>LOAD_BACKGROUND</name>))</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function> 

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsICachingChannel</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetCacheToken</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> **</type><name>token</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mCacheEntry</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>mCacheEntry</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetCacheToken</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>token</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetOfflineCacheToken</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> **</type><name>token</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mOfflineCacheEntry</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>mOfflineCacheEntry</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetOfflineCacheToken</name></name><parameter_list>(<param><decl><type><name>nsISupports</name> *</type><name>token</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name>NS_ERROR_NOT_IMPLEMENTED</name></expr>;</return>
}</block></function>

<class>class <name>nsHttpChannelCacheKey</name> <super>: <specifier>public</specifier> <name>nsISupportsPRUint32</name>,
                              <specifier>public</specifier> <name>nsISupportsCString</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>NS_DECL_ISUPPORTS</name>

    <name>NS_DECL_NSISUPPORTSPRIMITIVE</name></type>
    <name>NS_FORWARD_NSISUPPORTSPRUINT32</name><argument_list>(<argument><expr><name><name>mSupportsPRUint32</name>-&gt;</name></expr></argument>)</argument_list>
    
    <comment type="line">// Both interfaces declares toString method with the same signature.</comment>
    <comment type="line">// Thus we have to delegate only to nsISupportsPRUint32 implementation.</comment>
    <name>NS_SCRIPTABLE</name> <name>NS_IMETHOD</name> <name>GetData</name><argument_list>(<argument><expr><name>nsACString</name> &amp; <name>aData</name></expr></argument>)</argument_list> 
    <argument_list>{ 
        return <argument><expr><call><name><name>mSupportsCString</name>-&gt;<name>GetData</name></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></argument>;
    }</argument_list>
    <name>NS_SCRIPTABLE</name> <name>NS_IMETHOD</name> <name>SetData</name><argument_list>(<argument><expr>const <name>nsACString</name> &amp; <name>aData</name></expr></argument>)</argument_list>
    <argument_list>{ 
        return <argument><expr><call><name><name>mSupportsCString</name>-&gt;<name>SetData</name></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr></argument>;
    }</argument_list>
    
public<range>:
    <expr><name>nsresult</name> <macro><name>SetData</name><argument_list>(<argument>PRUint32 aPostID</argument>, <argument>const nsACString&amp; aKey</argument>)</argument_list></macro></expr></range></decl>;</decl_stmt>

</private><protected>protected:
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupportsPRUint32</name></expr></argument>&gt;</argument_list></name></type> <name>mSupportsPRUint32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupportsCString</name></expr></argument>&gt;</argument_list></name></type> <name>mSupportsCString</name></decl>;</decl_stmt>
</protected>}</block>;</class>

<macro><name>NS_IMPL_ADDREF</name><argument_list>(<argument>nsHttpChannelCacheKey</argument>)</argument_list></macro>
<macro><name>NS_IMPL_RELEASE</name><argument_list>(<argument>nsHttpChannelCacheKey</argument>)</argument_list></macro>
<macro><name>NS_INTERFACE_TABLE_HEAD</name><argument_list>(<argument>nsHttpChannelCacheKey</argument>)</argument_list></macro>
<decl_stmt><decl><type><name>NS_INTERFACE_TABLE_BEGIN</name></type>
<name>NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS</name><argument_list>(<argument><expr><name>nsHttpChannelCacheKey</name></expr></argument>,
                                   <argument><expr><name>nsISupports</name></expr></argument>, <argument><expr><name>nsISupportsPRUint32</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS</name><argument_list>(<argument><expr><name>nsHttpChannelCacheKey</name></expr></argument>,
                                   <argument><expr><name>nsISupportsPrimitive</name></expr></argument>, <argument><expr><name>nsISupportsPRUint32</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_TABLE_ENTRY</name><argument_list>(<argument><expr><name>nsHttpChannelCacheKey</name></expr></argument>,
                         <argument><expr><name>nsISupportsPRUint32</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_TABLE_ENTRY</name><argument_list>(<argument><expr><name>nsHttpChannelCacheKey</name></expr></argument>,
                         <argument><expr><name>nsISupportsCString</name></expr></argument>)</argument_list>
<name>NS_INTERFACE_TABLE_END</name>
<name>NS_INTERFACE_TABLE_TAIL</name>

<name>NS_IMETHODIMP</name> <name><name>nsHttpChannelCacheKey</name>::<name>GetType</name></name><argument_list>(<argument><expr><name>PRUint16</name> *<name>aType</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr></argument>;

    <argument><expr>*<name>aType</name> = <name>TYPE_PRUINT32</name></expr></argument>;
    return <argument><expr><name>NS_OK</name></expr></argument>;
}</argument_list>

<name>nsresult</name> <name><name>nsHttpChannelCacheKey</name>::<name>SetData</name></name><argument_list>(<argument><expr><name>PRUint32</name> <name>aPostID</name></expr></argument>,
                                        <argument><expr>const <name>nsACString</name>&amp; <name>aKey</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name>nsresult</name> <name>rv</name></expr></argument>;

    <argument><expr><name>mSupportsCString</name> = 
        <call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>NS_SUPPORTS_CSTRING_CONTRACTID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></argument>;
    if <argument><expr>(<call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>)</expr></argument> <return>return <expr><name>rv</name></expr>;</return></argument_list></decl></decl_stmt>

    <expr_stmt><expr><call><name><name>mSupportsCString</name>-&gt;<name>SetData</name></name><argument_list>(<argument><expr><name>aKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mSupportsPRUint32</name> = 
        <call><name>do_CreateInstance</name><argument_list>(<argument><expr><name>NS_SUPPORTS_PRUINT32_CONTRACTID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>mSupportsPRUint32</name>-&gt;<name>SetData</name></name><argument_list>(<argument><expr><name>aPostID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsHttpChannel</name></macro><expr_stmt><expr><name>::<name>GetCacheKey</name></name>(<name>nsISupports</name> **<name>key</name>)
<block>{
    <expr><name>nsresult</name> <name>rv</name></expr>;
    <expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;

    <expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::GetCacheKey [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;

    <expr>*<name>key</name> = <name>nsnull</name></expr>;

    <expr><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsHttpChannelCacheKey</name></expr></argument>&gt;</argument_list></name> <name>container</name> =
        new <call><name>nsHttpChannelCacheKey</name><argument_list>()</argument_list></call></expr>;

    <if>if <condition>(<expr>!<name>container</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <name>nsCAutoString</name> <name>cacheKey</name></block></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>GenerateCacheKey</name><argument_list>(<argument><expr><name>mPostID</name></expr></argument>, <argument><expr><name>cacheKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>container</name>-&gt;<name>SetData</name></name><argument_list>(<argument><expr><name>mPostID</name></expr></argument>, <argument><expr><name>cacheKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><call><name><name>container</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsHttpChannel</name></macro><expr_stmt><expr><name>::<name>SetCacheKey</name></name>(<name>nsISupports</name> *<name>key</name>)
<block>{
    <expr><name>nsresult</name> <name>rv</name></expr>;

    <expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::SetCacheKey [this=%p key=%p]\n", <name>this</name>, <name>key</name>)</expr></argument>)</argument_list></call></expr>;

    <comment type="line">// can only set the cache key if a load is not in progress</comment>
    <expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mIsPending</name></expr></argument>, <argument><expr><name>NS_ERROR_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;

    <if>if <condition>(<expr>!<name>key</name></expr>)</condition><then>
        <expr_stmt><expr><name>mPostID</name> = 0</expr>;</expr_stmt></then>
    <else>else <block>{
        <comment type="line">// extract the post id</comment>
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISupportsPRUint32</name></expr></argument>&gt;</argument_list></name></type> <name>container</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name><name>container</name>-&gt;<name>GetData</name></name><argument_list>(<argument><expr>&amp;<name>mPostID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>
    <expr_stmt/></block></else></if>}</block></expr></expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsHttpChannel</name></macro><expr_stmt><expr><name>::<name>GetCacheAsFile</name></name>(<name>PRBool</name> *<name>value</name>)
<block>{
    <expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;
    <if>if <condition>(<expr>!<name>mCacheEntry</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <name>nsCacheStoragePolicy</name> <name>storagePolicy</name></block></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mCacheEntry</name>-&gt;<name>GetStoragePolicy</name></name><argument_list>(<argument><expr>&amp;<name>storagePolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>value</name> = (<name>storagePolicy</name> == <name><name>nsICache</name>::<name>STORE_ON_DISK_AS_FILE</name></name>)</expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}

NS_IMETHODIMP
<macro><name>nsHttpChannel</name></macro><expr_stmt><expr><name>::<name>SetCacheAsFile</name></name>(<name>PRBool</name> <name>value</name>)
<block>{
    <if>if <condition>(<expr>!<name>mCacheEntry</name> || <name>mLoadFlags</name> &amp; <name>INHIBIT_PERSISTENT_CACHING</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <name>nsCacheStoragePolicy</name> <name>policy</name></block></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>value</name></expr>)</condition><then>
        <expr_stmt><expr><name>policy</name> = <name><name>nsICache</name>::<name>STORE_ON_DISK_AS_FILE</name></name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>policy</name> = <name><name>nsICache</name>::<name>STORE_ANYWHERE</name></name></expr>;</expr_stmt></else></if>
    <return>return <expr><call><name><name>mCacheEntry</name>-&gt;<name>SetStoragePolicy</name></name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</return>
}


NS_IMETHODIMP
<macro><name>nsHttpChannel</name></macro><expr_stmt><expr><name>::<name>GetCacheForOfflineUse</name></name>(<name>PRBool</name> *<name>value</name>)
<block>{
    <expr>*<name>value</name> = <name>mCacheForOfflineUse</name></expr>;

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetCacheForOfflineUse</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mCacheForOfflineUse</name> = <name>value</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetOfflineCacheClientID</name></name><parameter_list>(<param><decl><type><name>nsACString</name> &amp;</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>value</name> = <name>mOfflineCacheClientID</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetOfflineCacheClientID</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>mOfflineCacheClientID</name> = <name>value</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetCacheFile</name></name><parameter_list>(<param><decl><type><name>nsIFile</name> **</type><name>cacheFile</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mCacheEntry</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>
    <return>return <expr><call><name><name>mCacheEntry</name>-&gt;<name>GetFile</name></name><argument_list>(<argument><expr><name>cacheFile</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>IsFromCache</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mIsPending</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

    <comment type="line">// return false if reading a partial cache entry; the data isn't entirely</comment>
    <comment type="line">// from the cache!</comment>

    <expr_stmt><expr>*<name>value</name> = (<name>mCachePump</name> || (<name>mLoadFlags</name> &amp; <name>LOAD_ONLY_IF_MODIFIED</name>)) &amp;&amp;
              <name>mCachedContentIsValid</name> &amp;&amp; !<name>mCachedContentIsPartial</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsIResumableChannel</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>ResumeAt</name></name><parameter_list>(<param><decl><type><name>PRUint64</name></type> <name>aStartPos</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>nsACString</name>&amp;</type> <name>aEntityID</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::ResumeAt [this=%p startPos=%llu id='%s']\n",
         <name>this</name>, <name>aStartPos</name>, <call><name>PromiseFlatCString</name><argument_list>(<argument><expr><name>aEntityID</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mEntityID</name> = <name>aEntityID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mStartPos</name> = <name>aStartPos</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mResuming</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetEntityID</name></name><parameter_list>(<param><decl><type><name>nsACString</name>&amp;</type> <name>aEntityID</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Don't return an entity ID for Non-GET requests which require</comment>
    <comment type="line">// additional data</comment>
    <if>if <condition>(<expr><call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> != <name><name>nsHttp</name>::<name>Get</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>NS_ERROR_NOT_RESUMABLE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// Don't return an entity if the server sent the following header:</comment>
    <comment type="line">// Accept-Ranges: none</comment>
    <comment type="line">// Not sending the Accept-Ranges header means we can still try</comment>
    <comment type="line">// sending range requests.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>acceptRanges</name> <init>=
        <expr><call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Accept_Ranges</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>acceptRanges</name> &amp;&amp;
        !<call><name><name>nsHttp</name>::<name>FindToken</name></name><argument_list>(<argument><expr><name>acceptRanges</name></expr></argument>, <argument><expr>"bytes"</expr></argument>, <argument><expr><name>HTTP_HEADER_VALUE_SEPS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NS_ERROR_NOT_RESUMABLE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRUint64</name></type> <name>size</name> <init>= <expr><name>LL_MAXUINT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>etag</name></decl>, <decl><type ref="prev"/><name>lastmod</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>mResponseHead</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>size</name> = <call><name><name>mResponseHead</name>-&gt;<name>TotalEntitySize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>cLastMod</name> <init>= <expr><call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>Last_Modified</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cLastMod</name></expr>)</condition><then>
            <expr_stmt><expr><name>lastmod</name> = <name>cLastMod</name></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>cEtag</name> <init>= <expr><call><name><name>mResponseHead</name>-&gt;<name>PeekHeader</name></name><argument_list>(<argument><expr><name><name>nsHttp</name>::<name>ETag</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cEtag</name></expr>)</condition><then>
            <expr_stmt><expr><name>etag</name> = <name>cEtag</name></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <decl_stmt><decl><type><name>nsCString</name></type> <name>entityID</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_EscapeURL</name><argument_list>(<argument><expr><call><name><name>etag</name>.<name>BeginReading</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>etag</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>esc_AlwaysCopy</name> |
            <name>esc_FileBaseName</name> | <name>esc_Forced</name></expr></argument>, <argument><expr><name>entityID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>entityID</name>.<name>Append</name></name><argument_list>(<argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>entityID</name>.<name>AppendInt</name></name><argument_list>(<argument><expr><call><name>PRInt64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>entityID</name>.<name>Append</name></name><argument_list>(<argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>entityID</name>.<name>Append</name></name><argument_list>(<argument><expr><name>lastmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// NOTE: Appending lastmod as the last part avoids having to escape it</comment>

    <expr_stmt><expr><name>aEntityID</name> = <name>entityID</name></expr>;</expr_stmt>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsICacheListener</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>OnCacheEntryAvailable</name></name><parameter_list>(<param><decl><type><name>nsICacheEntryDescriptor</name> *</type><name>entry</name></decl></param>,
                                     <param><decl><type><name>nsCacheAccessMode</name></type> <name>access</name></decl></param>,
                                     <param><decl><type><name>nsresult</name></type> <name>status</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::OnCacheEntryAvailable [this=%p entry=%p "
         "access=%x status=%x]\n", <name>this</name>, <name>entry</name>, <name>access</name>, <name>status</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// if the channel's already fired onStopRequest, then we should ignore</comment>
    <comment type="line">// this event.</comment>
    <if>if <condition>(<expr>!<name>mIsPending</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <comment type="line">// otherwise, we have to handle this event.</comment>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mCacheEntry</name> = <name>entry</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mCacheAccess</name> = <name>access</name></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>mCanceled</name> &amp;&amp; <call><name>NS_FAILED</name><argument_list>(<argument><expr><name>mStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("channel was canceled [this=%p status=%x]\n", <name>this</name>, <name>mStatus</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <name>mStatus</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>(<name>mLoadFlags</name> &amp; <name>LOAD_ONLY_FROM_CACHE</name>) &amp;&amp; <call><name>NS_FAILED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <comment type="line">// if this channel is only allowed to pull from the cache, then</comment>
        <comment type="line">// we must fail if we were unable to open a cache entry.</comment>
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_DOCUMENT_NOT_CACHED</name></expr>;</expr_stmt></then>
    <else>else
        <comment type="line">// advance to the next state...</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>Connect</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

    <comment type="line">// a failure from Connect means that we have to abort the channel.</comment>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>CloseCacheEntry</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AsyncAbort</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>DoAuthRetry</name></name><parameter_list>(<param><decl><type><name>nsAHttpConnection</name> *</type><name>conn</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("nsHttpChannel::DoAuthRetry [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>mTransaction</name></expr></argument>, <argument><expr>"should not have a transaction"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="line">// toggle mIsPending to allow nsIObserver implementations to modify</comment>
    <comment type="line">// the request headers (bug 95044).</comment>
    <expr_stmt><expr><name>mIsPending</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

    <comment type="line">// fetch cookies, and add them to the request header.</comment>
    <comment type="line">// the server response could have included cookies that must be sent with</comment>
    <comment type="line">// this authentication attempt (bug 84794).</comment>
    <expr_stmt><expr><call><name>AddCookiesToRequest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// notify "http-on-modify-request" observers</comment>
    <expr_stmt><expr><call><name><name>gHttpHandler</name>-&gt;<name>OnModifyRequest</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mIsPending</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <comment type="line">// get rid of the old response headers</comment>
    <expr_stmt><expr>delete <name>mResponseHead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mResponseHead</name> = <name>nsnull</name></expr>;</expr_stmt>

    <comment type="line">// set sticky connection flag and disable pipelining.</comment>
    <expr_stmt><expr><name>mCaps</name> |=  <name>NS_HTTP_STICKY_CONNECTION</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCaps</name> &amp;= ~<name>NS_HTTP_ALLOW_PIPELINING</name></expr>;</expr_stmt>
   
    <comment type="line">// and create a new one...</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>SetupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <comment type="line">// transfer ownership of connection to transaction</comment>
    <if>if <condition>(<expr><name>conn</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>mTransaction</name>-&gt;<name>SetConnection</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// rewind the upload stream</comment>
    <if>if <condition>(<expr><name>mUploadStream</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsISeekableStream</name></expr></argument>&gt;</argument_list></name></type> <name>seekable</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>mUploadStream</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>seekable</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>seekable</name>-&gt;<name>Seek</name></name><argument_list>(<argument><expr><name><name>nsISeekableStream</name>::<name>NS_SEEK_SET</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;<name>InitiateTransaction</name></name><argument_list>(<argument><expr><name>mTransaction</name></expr></argument>, <argument><expr><name>mPriority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

    <return>return <expr><call><name><name>mTransactionPump</name>-&gt;<name>AsyncRead</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsIApplicationCacheChannel</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>
<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetApplicationCache</name></name><parameter_list>(<param><decl><type><name>nsIApplicationCache</name> **</type><name>out</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>out</name> = <name>mApplicationCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetApplicationCache</name></name><parameter_list>(<param><decl><type><name>nsIApplicationCache</name> *</type><name>appCache</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mWasOpened</name></expr></argument>, <argument><expr><name>NS_ERROR_ALREADY_OPENED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mApplicationCache</name> = <name>appCache</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetLoadedFromApplicationCache</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aLoadedFromApplicationCache</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>aLoadedFromApplicationCache</name> = <name>mLoadedFromApplicationCache</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetInheritApplicationCache</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aInherit</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>aInherit</name> = <name>mInheritApplicationCache</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetInheritApplicationCache</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aInherit</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mWasOpened</name></expr></argument>, <argument><expr><name>NS_ERROR_ALREADY_OPENED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mInheritApplicationCache</name> = <name>aInherit</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>GetChooseApplicationCache</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aChoose</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>aChoose</name> = <name>mChooseApplicationCache</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetChooseApplicationCache</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aChoose</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>!<name>mWasOpened</name></expr></argument>, <argument><expr><name>NS_ERROR_ALREADY_OPENED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mChooseApplicationCache</name> = <name>aChoose</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsContentEncodings &lt;public&gt;</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<constructor><name><name>nsHttpChannel</name>::<name>nsContentEncodings</name>::<name>nsContentEncodings</name></name><parameter_list>(<param><decl><type><name>nsIHttpChannel</name>*</type> <name>aChannel</name></decl></param>,
                                                          <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aEncodingHeader</name></decl></param>)</parameter_list> <member_list>:
    <call><name>mEncodingHeader</name><argument_list>(<argument><expr><name>aEncodingHeader</name></expr></argument>)</argument_list></call>, <call><name>mChannel</name><argument_list>(<argument><expr><name>aChannel</name></expr></argument>)</argument_list></call>, <call><name>mReady</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
</member_list><block>{
    <expr_stmt><expr><name>mCurEnd</name> = <name>aEncodingHeader</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>aEncodingHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCurStart</name> = <name>mCurEnd</name></expr>;</expr_stmt>
}</block></constructor>
    
<destructor><name><name>nsHttpChannel</name>::<name>nsContentEncodings</name>::~<name>nsContentEncodings</name></name><parameter_list>()</parameter_list>
<block>{
}</block></destructor>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsContentEncodings::nsISimpleEnumerator</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>nsContentEncodings</name>::<name>HasMore</name></name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>aMoreEncodings</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mReady</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>aMoreEncodings</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></then></if>
    
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>PrepareForNext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>aMoreEncodings</name> = <call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>nsContentEncodings</name>::<name>GetNext</name></name><parameter_list>(<param><decl><type><name>nsACString</name>&amp;</type> <name>aNextEncoding</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>aNextEncoding</name>.<name>Truncate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>mReady</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>PrepareForNext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type> <name>encoding</name> <init>= <expr><call><name>Substring</name><argument_list>(<argument><expr><name>mCurStart</name></expr></argument>, <argument><expr><name>mCurEnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>nsACString</name>::<name>const_iterator</name></name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>encoding</name>.<name>BeginReading</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>encoding</name>.<name>EndReading</name></name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>haveType</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>CaseInsensitiveFindInReadable</name><argument_list>(<argument><expr><call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr>"gzip"</expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>start</name></expr></argument>,
                                      <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aNextEncoding</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr><name>APPLICATION_GZIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>haveType</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>haveType</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>encoding</name>.<name>BeginReading</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>CaseInsensitiveFindInReadable</name><argument_list>(<argument><expr><call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr>"compress"</expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>start</name></expr></argument>,
                                          <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>aNextEncoding</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr><name>APPLICATION_COMPRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                           
            <expr_stmt><expr><name>haveType</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    
    <if>if <condition>(<expr>! <name>haveType</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>encoding</name>.<name>BeginReading</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>CaseInsensitiveFindInReadable</name><argument_list>(<argument><expr><call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr>"deflate"</expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>start</name></expr></argument>,
                                          <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>aNextEncoding</name>.<name>AssignLiteral</name></name><argument_list>(<argument><expr><name>APPLICATION_ZIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>haveType</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="line">// Prepare to fetch the next encoding</comment>
    <expr_stmt><expr><name>mCurEnd</name> = <name>mCurStart</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mReady</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name>haveType</name></expr>)</condition><then>
        <return>return <expr><name>NS_OK</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Unknown encoding type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsContentEncodings::nsISupports</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<macro><name>NS_IMPL_ISUPPORTS1</name><argument_list>(<argument>nsHttpChannel::nsContentEncodings</argument>, <argument>nsIUTF8StringEnumerator</argument>)</argument_list></macro>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsContentEncodings &lt;private&gt;</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>nsresult</name></type>
<name><name>nsHttpChannel</name>::<name>nsContentEncodings</name>::<name>PrepareForNext</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>mCurStart</name> == <name>mCurEnd</name></expr></argument>, <argument><expr>"Indeterminate state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="line">// At this point both mCurStart and mCurEnd point to somewhere</comment>
    <comment type="line">// past the end of the next thing we want to return</comment>
    
    <while>while <condition>(<expr><name>mCurEnd</name> != <name>mEncodingHeader</name></expr>)</condition> <block>{
        <expr_stmt><expr>--<name>mCurEnd</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>mCurEnd</name> != ',' &amp;&amp; !<call><name><name>nsCRT</name>::<name>IsAsciiSpace</name></name><argument_list>(<argument><expr>*<name>mCurEnd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <break>break;</break></then></if>
    }</block></while>
    <if>if <condition>(<expr><name>mCurEnd</name> == <name>mEncodingHeader</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if> <comment type="line">// no more encodings</comment>
    <expr_stmt><expr>++<name>mCurEnd</name></expr>;</expr_stmt>
        
    <comment type="line">// At this point mCurEnd points to the first char _after_ the</comment>
    <comment type="line">// header we want.  Furthermore, mCurEnd - 1 != mEncodingHeader</comment>
    
    <expr_stmt><expr><name>mCurStart</name> = <name>mCurEnd</name> - 1</expr>;</expr_stmt>
    <while>while <condition>(<expr><name>mCurStart</name> != <name>mEncodingHeader</name> &amp;&amp;
           *<name>mCurStart</name> != ',' &amp;&amp; !<call><name><name>nsCRT</name>::<name>IsAsciiSpace</name></name><argument_list>(<argument><expr>*<name>mCurStart</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>--<name>mCurStart</name></expr>;</expr_stmt></while>
    <if>if <condition>(<expr>*<name>mCurStart</name> == ',' || <call><name><name>nsCRT</name>::<name>IsAsciiSpace</name></name><argument_list>(<argument><expr>*<name>mCurStart</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>++<name>mCurStart</name></expr>;</expr_stmt></then></if> <comment type="line">// we stopped because of a weird char, so move up one</comment>
        
    <comment type="line">// At this point mCurStart and mCurEnd bracket the encoding string</comment>
    <comment type="line">// we want.  Check that it's not "identity"</comment>
    <if>if <condition>(<expr><call><name>Substring</name><argument_list>(<argument><expr><name>mCurStart</name></expr></argument>, <argument><expr><name>mCurEnd</name></expr></argument>)</argument_list></call>.<call><name>Equals</name><argument_list>(<argument><expr>"identity"</expr></argument>,
                                             <argument><expr><call><name>nsCaseInsensitiveCStringComparator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mCurEnd</name> = <name>mCurStart</name></expr>;</expr_stmt>
        <return>return <expr><call><name>PrepareForNext</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>
        
    <expr_stmt><expr><name>mReady</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsStreamListenerWrapper &lt;private&gt;</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<comment type="line">// Wrapper class to make replacement of nsHttpChannel's listener</comment>
<comment type="line">// from JavaScript possible. It is workaround for bug 433711.</comment>
<class>class <name>nsStreamListenerWrapper</name> <super>: <specifier>public</specifier> <name>nsIStreamListener</name></super>
<block>{<private type="default">
</private><public>public:
    <constructor_decl><name>nsStreamListenerWrapper</name><parameter_list>(<param><decl><type><name>nsIStreamListener</name> *</type><name>listener</name></decl></param>)</parameter_list>;</constructor_decl>

    <decl_stmt><decl><type><name>NS_DECL_ISUPPORTS</name></type>
    <name>NS_FORWARD_NSIREQUESTOBSERVER</name><argument_list>(<argument><expr><name><name>mListener</name>-&gt;</name></expr></argument>)</argument_list>
    <name>NS_FORWARD_NSISTREAMLISTENER</name><argument_list>(<argument><expr><name><name>mListener</name>-&gt;</name></expr></argument>)</argument_list>

private<range>:
    <expr>~<macro><name>nsStreamListenerWrapper</name><argument_list>()</argument_list></macro> <block>{}</block>
    <name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStreamListener</name></expr></argument>&gt;</argument_list></name> <name>mListener</name></expr></range></decl>;</decl_stmt>
</public>}</block>;</class>

<constructor><name><name>nsStreamListenerWrapper</name>::<name>nsStreamListenerWrapper</name></name><parameter_list>(<param><decl><type><name>nsIStreamListener</name> *</type><name>listener</name></decl></param>)</parameter_list>
    <member_list>: <call><name>mListener</name><argument_list>(<argument><expr><name>listener</name></expr></argument>)</argument_list></call> 
</member_list><block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mListener</name></expr></argument>, <argument><expr>"no stream listener specified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<macro><name>NS_IMPL_ISUPPORTS2</name><argument_list>(<argument>nsStreamListenerWrapper</argument>,
                   <argument>nsIStreamListener</argument>,
                   <argument>nsIRequestObserver</argument>)</argument_list></macro>

<comment type="line">//-----------------------------------------------------------------------------</comment>
<comment type="line">// nsHttpChannel::nsITraceableChannel</comment>
<comment type="line">//-----------------------------------------------------------------------------</comment>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsHttpChannel</name>::<name>SetNewListener</name></name><parameter_list>(<param><decl><type><name>nsIStreamListener</name> *</type><name>aListener</name></decl></param>, <param><decl><type><name>nsIStreamListener</name> **</type><name>_retval</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mTracingEnabled</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>aListener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIStreamListener</name></expr></argument>&gt;</argument_list></name></type> <name>wrapper</name> <init>= 
        <expr>new <call><name>nsStreamListenerWrapper</name><argument_list>(<argument><expr><name>mListener</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>wrapper</name></expr>)</condition><then>
        <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>wrapper</name>.<name>forget</name></name><argument_list>(<argument><expr><name>_retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mListener</name> = <name>aListener</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>MaybeInvalidateCacheEntryForSubsequentGet</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// See RFC 2616 section 5.1.1. These are considered valid</comment>
    <comment type="line">// methods which DO NOT invalidate cache-entries for the</comment>
    <comment type="line">// referred resource. POST, PUT and DELETE as well as any</comment>
    <comment type="line">// other method not listed here will potentially invalidate</comment>
    <comment type="line">// any cached copy of the resource</comment>
    <if>if <condition>(<expr><call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Options</name></name> ||
       <call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Get</name></name> ||
       <call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Head</name></name> ||
       <call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Trace</name></name> ||
       <call><name><name>mRequestHead</name>.<name>Method</name></name><argument_list>()</argument_list></call> == <name><name>nsHttp</name>::<name>Connect</name></name></expr>)</condition><then>
        <return>return;</return></then></if>
        
    <comment type="line">// NOTE:</comment>
    <comment type="line">// Following comments 24,32 and 33 in bug #327765, we only care about</comment>
    <comment type="line">// the cache in the protocol-handler.</comment>
    <comment type="line">// The logic below deviates from the original logic in OpenCacheEntry on</comment>
    <comment type="line">// one point by using only READ_ONLY access-policy. I think this is safe.</comment>
    <expr_stmt><expr><call><name>LOG</name><argument_list>(<argument><expr>("MaybeInvalidateCacheEntryForSubsequentGet [this=%p]\n", <name>this</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>tmpCacheKey</name></decl>;</decl_stmt>
    <comment type="line">// passing 0 in first param gives the cache-key for a GET to my resource</comment>
    <expr_stmt><expr><call><name>GenerateCacheKey</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tmpCacheKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Now, find the session holding the cache-entry</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICacheSession</name></expr></argument>&gt;</argument_list></name></type> <name>session</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsCacheStoragePolicy</name></type> <name>storagePolicy</name> <init>= <expr><call><name>DetermineStoragePolicy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>gHttpHandler</name>-&gt;<name>GetCacheSession</name></name><argument_list>(<argument><expr><name>storagePolicy</name></expr></argument>,
                                       <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return;</return></then></if>

    <comment type="line">// Finally, find the actual cache-entry</comment>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICacheEntryDescriptor</name></expr></argument>&gt;</argument_list></name></type> <name>tmpCacheEntry</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>session</name>-&gt;<name>OpenCacheEntry</name></name><argument_list>(<argument><expr><name>tmpCacheKey</name></expr></argument>, <argument><expr><name><name>nsICache</name>::<name>ACCESS_READ</name></name></expr></argument>,
                                 <argument><expr><name>PR_FALSE</name></expr></argument>,
                                 <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>tmpCacheEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="line">// If entry was found, set its expiration-time = 0</comment>
    <if>if<condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
       <expr_stmt><expr><call><name><name>tmpCacheEntry</name>-&gt;<name>SetExpirationTime</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>nsCacheStoragePolicy</name></type>
<name><name>nsHttpChannel</name>::<name>DetermineStoragePolicy</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>nsCacheStoragePolicy</name></type> <name>policy</name> <init>= <expr><name><name>nsICache</name>::<name>STORE_ANYWHERE</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>mLoadFlags</name> &amp; <name>INHIBIT_PERSISTENT_CACHING</name></expr>)</condition><then>
        <expr_stmt><expr><name>policy</name> = <name><name>nsICache</name>::<name>STORE_IN_MEMORY</name></name></expr>;</expr_stmt></then></if>

    <return>return <expr><name>policy</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsHttpChannel</name>::<name>AsyncOnExamineCachedResponse</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>gHttpHandler</name>-&gt;<name>OnExamineCachedResponse</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
