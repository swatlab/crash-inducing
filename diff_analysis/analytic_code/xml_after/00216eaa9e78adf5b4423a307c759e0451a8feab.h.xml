<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="00216eaa9e78adf5b4423a307c759e0451a8feab.h"><comment type="line">// Copyright (c) 2006, Google Inc.</comment>
<comment type="line">// All rights reserved.</comment>
<comment type="line">//</comment>
<comment type="line">// Redistribution and use in source and binary forms, with or without</comment>
<comment type="line">// modification, are permitted provided that the following conditions are</comment>
<comment type="line">// met:</comment>
<comment type="line">//</comment>
<comment type="line">//     * Redistributions of source code must retain the above copyright</comment>
<comment type="line">// notice, this list of conditions and the following disclaimer.</comment>
<comment type="line">//     * Redistributions in binary form must reproduce the above</comment>
<comment type="line">// copyright notice, this list of conditions and the following disclaimer</comment>
<comment type="line">// in the documentation and/or other materials provided with the</comment>
<comment type="line">// distribution.</comment>
<comment type="line">//     * Neither the name of Google Inc. nor the names of its</comment>
<comment type="line">// contributors may be used to endorse or promote products derived from</comment>
<comment type="line">// this software without specific prior written permission.</comment>
<comment type="line">//</comment>
<comment type="line">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</comment>
<comment type="line">// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</comment>
<comment type="line">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</comment>
<comment type="line">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</comment>
<comment type="line">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</comment>
<comment type="line">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</comment>
<comment type="line">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</comment>
<comment type="line">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</comment>
<comment type="line">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</comment>
<comment type="line">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</comment>
<comment type="line">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</comment>

<comment type="line">// BasicSourceLineResolver implements SourceLineResolverInterface, using</comment>
<comment type="line">// address map files produced by a compatible writer, e.g. PDBSourceLineWriter.</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>GOOGLE_BREAKPAD_PROCESSOR_BASIC_SOURCE_LINE_RESOLVER_H__</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GOOGLE_BREAKPAD_PROCESSOR_BASIC_SOURCE_LINE_RESOLVER_H__</name></cpp:macro></cpp:define>

<comment type="line">// TODO: Platforms that have no hash_map can use map, at the likely cost of</comment>
<comment type="line">// performance.</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUNPRO_CC</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BSLR_NO_HASH_MAP</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// __SUNPRO_CC</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BSLR_NO_HASH_MAP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="line">// BSLR_NO_HASH_MAP</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ext/hash_map&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// BSLR_NO_HASH_MAP</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"google_breakpad/processor/source_line_resolver_interface.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>google_breakpad</name> <block>{

<expr_stmt><expr><name>using</name> <name>std</name>::<name>string</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BSLR_NO_HASH_MAP</name></cpp:ifdef>
<expr_stmt><expr><name>using</name> <name>std</name>::<name>map</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="line">// BSLR_NO_HASH_MAP</comment>
<expr_stmt><expr><name>using</name> <name>__gnu_cxx</name>::<name>hash_map</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// BSLR_NO_HASH_MAP</comment>

<expr_stmt><expr><name>class</name> <name>BasicSourceLineResolver</name> : <name>public</name> <name>SourceLineResolverInterface</name> <block>{
 <expr><name>public</name>:
  <call><name>BasicSourceLineResolver</name><argument_list>()</argument_list></call></expr>;
  <expr><name>virtual</name> ~<call><name>BasicSourceLineResolver</name><argument_list>()</argument_list></call></expr>;

  <comment type="line">// SourceLineResolverInterface methods, see source_line_resolver_interface.h</comment>
  <comment type="line">// for more details.</comment>

  <comment type="line">// Adds a module to this resolver, returning true on success.</comment>
  <comment type="line">// The given map_file is read into memory, and its symbols will be</comment>
  <comment type="line">// retained until the BasicSourceLineResolver is destroyed.</comment>
  <expr><name>virtual</name> <name>bool</name> <call><name>LoadModule</name><argument_list>(<argument><expr>const <name>string</name> &amp;<name>module_name</name></expr></argument>, <argument><expr>const <name>string</name> &amp;<name>map_file</name></expr></argument>)</argument_list></call></expr>;

  <expr><name>virtual</name> <name>bool</name> <macro><name>HasModule</name><argument_list>(<argument>const string &amp;module_name</argument>)</argument_list></macro> const</expr>;

  <expr><name>virtual</name> <name>StackFrameInfo</name>* <macro><name>FillSourceLineInfo</name><argument_list>(<argument>StackFrame *frame</argument>)</argument_list></macro> const</expr>;

 <expr><name>private</name>:
  <name>template</name>&lt;<name>class</name> <name>T</name>&gt; <name>class</name> <name>MemAddrMap</name></expr>;
  struct <expr><name>Line</name></expr>;
  struct <expr><name>Function</name></expr>;
  struct <expr><name>PublicSymbol</name></expr>;
  struct <expr><name>File</name></expr>;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BSLR_NO_HASH_MAP</name></cpp:ifdef>
  struct <expr><name>CompareString</name> <block>{
    <expr><name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro>(const <name>string</name> &amp;<name>s1</name>, const <name>string</name> &amp;<name>s2</name>) const</expr>;
  }</block></expr>;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="line">// BSLR_NO_HASH_MAP</comment>
  struct <expr><name>HashString</name> <block>{
    <expr><name>size_t</name> <macro><name>operator</name><argument_list>()</argument_list></macro>(const <name>string</name> &amp;<name>s</name>) const</expr>;
  }</block></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// BSLR_NO_HASH_MAP</comment>
  <expr><name>class</name> <name>Module</name></expr>;

  <comment type="line">// All of the modules we've loaded</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BSLR_NO_HASH_MAP</name></cpp:ifdef>
  <typedef>typedef <expr_stmt><expr><name>map</name>&lt;<name>string</name></expr>, <expr><name>Module</name>*</expr>, <expr><name>CompareString</name>&gt; <name>ModuleMap</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="line">// BSLR_NO_HASH_MAP</comment>
  <typedef>typedef <expr_stmt><expr><name>hash_map</name>&lt;<name>string</name></expr>, <expr><name>Module</name>*</expr>, <expr><name>HashString</name>&gt; <name>ModuleMap</name></expr>;</expr_stmt></typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// BSLR_NO_HASH_MAP</comment>
  <decl_stmt><decl><type><name>ModuleMap</name> *</type><name>modules_</name></decl>;</decl_stmt>

  <comment type="line">// Disallow unwanted copy ctor and assignment operator</comment>
  <expr_stmt><expr><call><name>BasicSourceLineResolver</name><argument_list>(<argument><expr>const <name>BasicSourceLineResolver</name>&amp;</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr>(const <name>BasicSourceLineResolver</name>&amp;)</expr></init></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}  <comment type="line">// namespace google_breakpad</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// GOOGLE_BREAKPAD_PROCESSOR_BASIC_SOURCE_LINE_RESOLVER_H__</comment>
</unit>
