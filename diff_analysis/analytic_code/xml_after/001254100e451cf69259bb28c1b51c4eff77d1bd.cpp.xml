<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="001254100e451cf69259bb28c1b51c4eff77d1bd.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="line">// vim:cindent:ts=2:et:sw=2:</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Steve Clark &lt;buster@netscape.com&gt;
 *   Robert O'Callahan &lt;roc+moz@cs.cmu.edu&gt;
 *   L. David Baron &lt;dbaron@dbaron.org&gt;
 *   IBM Corporation
 *   Mats Palmgren &lt;mats.palmgren@bredband.net&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * rendering object for CSS display:block and display:list-item objects,
 * also used inside table cells
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCOMPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBlockFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBlockReflowContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBlockReflowState.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBlockBandData.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBulletFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLineBox.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsInlineFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLineLayout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPlaceholderFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleConsts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPresContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPresShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIView.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIFontMetrics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHTMLParts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGkAtoms.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGenericHTMLElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStyleChangeList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsFrameSelection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSpaceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIntervalSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prenv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plstr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGUIEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutErrors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIServiceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIScrollableFrame.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLDocument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIAccessibilityService.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsLayoutUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBoxLayoutState.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDisplayList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsContentErrors.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSAnonBoxes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCSSRendering.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBidiPresUtils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// IBMBIDI</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLBodyElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDOMHTMLHtmlElement.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>MIN_LINES_NEEDING_CURSOR</name> <init>= <expr>20</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPrintfCString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBlockDebugFlags.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsBlockFrame</name>::<name>gLamePaintMetrics</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsBlockFrame</name>::<name>gLameReflowMetrics</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsBlockFrame</name>::<name>gNoisy</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsBlockFrame</name>::<name>gNoisyDamageRepair</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsBlockFrame</name>::<name>gNoisyIntrinsic</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsBlockFrame</name>::<name>gNoisyReflow</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsBlockFrame</name>::<name>gReallyNoisyReflow</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsBlockFrame</name>::<name>gNoisySpaceManager</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsBlockFrame</name>::<name>gVerifyLines</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsBlockFrame</name>::<name>gDisableResizeOpt</name></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PRInt32</name></type> <name><name>nsBlockFrame</name>::<name>gNoiseIndent</name></name></decl>;</decl_stmt>

<struct>struct <name>BlockDebugFlags</name> <block>{<public type="default">
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name>*</type> <name>on</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>BlockDebugFlags</name></type> <name><name>gFlags</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr>"reflow"</expr>, <expr>&amp;<name><name>nsBlockFrame</name>::<name>gNoisyReflow</name></name></expr> }</block></expr>,
  <expr><block>{ <expr>"really-noisy-reflow"</expr>, <expr>&amp;<name><name>nsBlockFrame</name>::<name>gReallyNoisyReflow</name></name></expr> }</block></expr>,
  <expr><block>{ <expr>"intrinsic"</expr>, <expr>&amp;<name><name>nsBlockFrame</name>::<name>gNoisyIntrinsic</name></name></expr> }</block></expr>,
  <expr><block>{ <expr>"space-manager"</expr>, <expr>&amp;<name><name>nsBlockFrame</name>::<name>gNoisySpaceManager</name></name></expr> }</block></expr>,
  <expr><block>{ <expr>"verify-lines"</expr>, <expr>&amp;<name><name>nsBlockFrame</name>::<name>gVerifyLines</name></name></expr> }</block></expr>,
  <expr><block>{ <expr>"damage-repair"</expr>, <expr>&amp;<name><name>nsBlockFrame</name>::<name>gNoisyDamageRepair</name></name></expr> }</block></expr>,
  <expr><block>{ <expr>"lame-paint-metrics"</expr>, <expr>&amp;<name><name>nsBlockFrame</name>::<name>gLamePaintMetrics</name></name></expr> }</block></expr>,
  <expr><block>{ <expr>"lame-reflow-metrics"</expr>, <expr>&amp;<name><name>nsBlockFrame</name>::<name>gLameReflowMetrics</name></name></expr> }</block></expr>,
  <expr><block>{ <expr>"disable-resize-opt"</expr>, <expr>&amp;<name><name>nsBlockFrame</name>::<name>gDisableResizeOpt</name></name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_DEBUG_FLAGS</name></cpp:macro> <cpp:value>(sizeof(gFlags) / sizeof(gFlags[0]))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShowDebugFlags</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Here are the available GECKO_BLOCK_DEBUG_FLAGS:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BlockDebugFlags</name>*</type> <name>bdf</name> <init>= <expr><name>gFlags</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>BlockDebugFlags</name>*</type> <name>end</name> <init>= <expr><name>gFlags</name> + <name>NUM_DEBUG_FLAGS</name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init> <condition><expr><name>bdf</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>bdf</name>++</expr></incr>) <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  %s\n"</expr></argument>, <argument><expr><name><name>bdf</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Note: GECKO_BLOCK_DEBUG_FLAGS is a comma separated list of flag\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"names (no whitespace)\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsBlockFrame</name>::<name>InitDebugFlags</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <name>PRBool</name></type> <name>firstTime</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>firstTime</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>firstTime</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>flags</name> <init>= <expr><call><name>PR_GetEnv</name><argument_list>(<argument><expr>"GECKO_BLOCK_DEBUG_FLAGS"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>flags</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>error</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
      <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <decl_stmt><decl><type><name>char</name>*</type> <name>cm</name> <init>= <expr><call><name>PL_strchr</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cm</name></expr>)</condition><then> <expr_stmt><expr>*<name>cm</name> = '\0'</expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name>PRBool</name></type> <name>found</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BlockDebugFlags</name>*</type> <name>bdf</name> <init>= <expr><name>gFlags</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BlockDebugFlags</name>*</type> <name>end</name> <init>= <expr><name>gFlags</name> + <name>NUM_DEBUG_FLAGS</name></expr></init></decl>;</decl_stmt>
        <for>for (<init>;</init> <condition><expr><name>bdf</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>bdf</name>++</expr></incr>) <block>{
          <if>if <condition>(<expr><call><name>PL_strcasecmp</name><argument_list>(<argument><expr><name><name>bdf</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr>*(<name><name>bdf</name>-&gt;<name>on</name></name>) = <name>PR_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"nsBlockFrame: setting %s debug flag on\n"</expr></argument>, <argument><expr><name><name>bdf</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>gNoisy</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>found</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr>!<name>found</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>error</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr>!<name>cm</name></expr>)</condition><then> <break>break;</break></then></if>
        <expr_stmt><expr>*<name>cm</name> = ','</expr>;</expr_stmt>
        <expr_stmt><expr><name>flags</name> = <name>cm</name> + 1</expr>;</expr_stmt>
      }</block></for>
      <if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ShowDebugFlags</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// add in a sanity check for absurdly deep frame trees.  See bug 42138</comment>
<comment type="line">// can't just use IsFrameTreeTooDeep() because that method has side effects we don't want</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DEPTH_FOR_LIST_RENUMBERING</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define>  <comment type="line">// 200 open displayable tags is pretty unrealistic</comment>

<comment type="line">//----------------------------------------------------------------------</comment>

<comment type="line">// Debugging support code</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name><name>nsBlockFrame</name>::<name>kReflowCommandType</name><index>[]</index></name> <init>= <expr><block>{
  <expr>"ContentChanged"</expr>,
  <expr>"StyleChanged"</expr>,
  <expr>"ReflowDirty"</expr>,
  <expr>"Timeout"</expr>,
  <expr>"UserDefined"</expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REALLY_NOISY_FIRST_LINE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DumpStyleGeneaology</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>gap</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>nsFrame</name>::<name>ListTag</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsStyleContext</name>*</type> <name>sc</name> <init>= <expr><call><name><name>aFrame</name>-&gt;<name>GetStyleContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>nsnull</name> != <name>sc</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>nsStyleContext</name>*</type> <name>psc</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%p "</expr></argument>, <argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>psc</name> = <call><name><name>sc</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sc</name> = <name>psc</name></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REFLOW_STATUS_COVERAGE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordReflowStatus</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aChildIsBlock</name></decl></param>, <param><decl><type><name>nsReflowStatus</name></type> <name>aFrameReflowStatus</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <name>PRUint32</name></type> <name><name>record</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>

  <comment type="line">// 0: child-is-block</comment>
  <comment type="line">// 1: child-is-inline</comment>
  <decl_stmt><decl><type><name>PRIntn</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>aChildIsBlock</name></expr>)</condition><then> <expr_stmt><expr><name>index</name> |= 1</expr>;</expr_stmt></then></if>

  <comment type="line">// Compute new status</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>newS</name> <init>= <expr><name><name>record</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_INLINE_IS_BREAK</name><argument_list>(<argument><expr><name>aFrameReflowStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>NS_INLINE_IS_BREAK_BEFORE</name><argument_list>(<argument><expr><name>aFrameReflowStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>newS</name> |= 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>NS_FRAME_IS_NOT_COMPLETE</name><argument_list>(<argument><expr><name>aFrameReflowStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>newS</name> |= 2</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>newS</name> |= 4</expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><call><name>NS_FRAME_IS_NOT_COMPLETE</name><argument_list>(<argument><expr><name>aFrameReflowStatus</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>newS</name> |= 8</expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><name>newS</name> |= 16</expr>;</expr_stmt>
  }</block></else></if></else></if>

  <comment type="line">// Log updates to the status that yield different values</comment>
  <if>if <condition>(<expr><name><name>record</name><index>[<expr><name>index</name></expr>]</index></name> != <name>newS</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>record</name><index>[<expr><name>index</name></expr>]</index></name> = <name>newS</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"record(%d): %02x %02x\n"</expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>record</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>record</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//----------------------------------------------------------------------</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>nsIID</name></type> <name>kBlockFrameCID</name> <init>= <expr><name>NS_BLOCK_FRAME_CID</name></expr></init></decl>;</decl_stmt>

<function><type><name>nsIFrame</name>*</type>
<name>NS_NewBlockFrame</name><parameter_list>(<param><decl><type><name>nsIPresShell</name>*</type> <name>aPresShell</name></decl></param>, <param><decl><type><name>nsStyleContext</name>*</type> <name>aContext</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aFlags</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsBlockFrame</name>*</type> <name>it</name> <init>= <expr>new (<name>aPresShell</name>) <call><name>nsBlockFrame</name><argument_list>(<argument><expr><name>aContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>it</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>it</name>-&gt;<name>SetFlags</name></name><argument_list>(<argument><expr><name>aFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>it</name></expr>;</return>
}</block></function>

<destructor><name><name>nsBlockFrame</name>::~<name>nsBlockFrame</name></name><parameter_list>()</parameter_list>
<block>{
}</block></destructor>

<function><type><name>void</name></type>
<name><name>nsBlockFrame</name>::<name>Destroy</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mAbsoluteContainer</name>.<name>DestroyFrames</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Outside bullets are not in our child-list so check for them here</comment>
  <comment type="line">// and delete them when present.</comment>
  <if>if <condition>(<expr><name>mBullet</name> &amp;&amp; <call><name>HaveOutsideBullet</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mBullet</name>-&gt;<name>Destroy</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mBullet</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mFloats</name>.<name>DestroyFrames</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>nsPresContext</name>*</type> <name>presContext</name> <init>= <expr><call><name>PresContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>nsLineBox</name>::<name>DeleteLineList</name></name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr><name>mLines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// destroy overflow lines now</comment>
  <decl_stmt><decl><type><name>nsLineList</name>*</type> <name>overflowLines</name> <init>= <expr><call><name>RemoveOverflowLines</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>overflowLines</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>nsLineBox</name>::<name>DeleteLineList</name></name><argument_list>(<argument><expr><name>presContext</name></expr></argument>, <argument><expr>*<name>overflowLines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <block>{
    <function_decl><type><name>nsAutoOOFFrameList</name></type> <name>oofs</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name><name>oofs</name>.<name>mList</name>.<name>DestroyFrames</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// oofs is now empty and will remove the frame list property</comment>
  }</block>

  <expr_stmt><expr><call><name><name>nsBlockFrameSuper</name>::<name>Destroy</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBlockFrame</name>::<name>QueryInterface</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIID</name>&amp;</type> <name>aIID</name></decl></param>, <param><decl><type><name>void</name>**</type> <name>aInstancePtr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aInstancePtr</name></expr></argument>, <argument><expr>"null out param"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name><name>aIID</name>.<name>Equals</name></name><argument_list>(<argument><expr><name>kBlockFrameCID</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr>*<name>aInstancePtr</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsBlockFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><call><name><name>aIID</name>.<name>Equals</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsILineIterator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> ||
      <call><name><name>aIID</name>.<name>Equals</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsILineIteratorNavigator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsLineIterator</name>*</type> <name>it</name> <init>= <expr>new <name>nsLineIterator</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>it</name></expr>)</condition><then> <block>{
      <expr_stmt><expr>*<name>aInstancePtr</name> = <name>nsnull</name></expr>;</expr_stmt>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// reference passed to caller</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleVisibility</name>*</type> <name>visibility</name> <init>= <expr><call><name>GetStyleVisibility</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>it</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr><name>mLines</name></expr></argument>,
                           <argument><expr><name><name>visibility</name>-&gt;<name>mDirection</name></name> == <name>NS_STYLE_DIRECTION_RTL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr>*<name>aInstancePtr</name> = <name>nsnull</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>aInstancePtr</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsILineIteratorNavigator</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><call><name><name>nsBlockFrameSuper</name>::<name>QueryInterface</name></name><argument_list>(<argument><expr><name>aIID</name></expr></argument>, <argument><expr><name>aInstancePtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsSplittableType</name></type>
<name><name>nsBlockFrame</name>::<name>GetSplittableType</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>NS_FRAME_SPLITTABLE_NON_RECTANGULAR</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><name>NS_METHOD</name></type>
<name><name>nsBlockFrame</name>::<name>List</name></name><parameter_list>(<param><decl><type><name>FILE</name>*</type> <name>out</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aIndent</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>aIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_waterson</name></cpp:ifdef>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" [parent=%p]"</expr></argument>, <argument><expr><name>mParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if <condition>(<expr><call><name>HasView</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" [view=%p]"</expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetView</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>nsnull</name> != <name>mNextSibling</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" next=%p"</expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mNextSibling</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Output the flow linkage</comment>
  <if>if <condition>(<expr><name>nsnull</name> != <call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" prev-in-flow=%p"</expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>nsnull</name> != <call><name>GetNextInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" next-in-flow=%p"</expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetNextInFlow</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Output the rect and state</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" {%d,%d,%d,%d}"</expr></argument>, <argument><expr><name><name>mRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>mRect</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>mRect</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>0 != <name>mState</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" [state=%08x]"</expr></argument>, <argument><expr><name>mState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <decl_stmt><decl><type><name>nsBlockFrame</name>*</type> <name>f</name> <init>= <expr><call><name><name>const_cast</name><argument_list>&lt;<argument><expr><name>nsBlockFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name>*</type> <name>overflowArea</name> <init>= <expr><call><name><name>f</name>-&gt;<name>GetOverflowAreaProperty</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>overflowArea</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" [overflow=%d,%d,%d,%d]"</expr></argument>, <argument><expr><name><name>overflowArea</name>-&gt;<name>x</name></name></expr></argument>, <argument><expr><name><name>overflowArea</name>-&gt;<name>y</name></name></expr></argument>,
            <argument><expr><name><name>overflowArea</name>-&gt;<name>width</name></name></expr></argument>, <argument><expr><name><name>overflowArea</name>-&gt;<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numInlineLines</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>numBlockLines</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>! <call><name><name>mLines</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <for>for (<init><decl><type><name>const_line_iterator</name></type> <name>line</name> <init>= <expr><call><name>begin_lines</name><argument_list>()</argument_list></call></expr></init>, <name>line_end</name> <init>= <expr><call><name>end_lines</name><argument_list>()</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>line</name> != <name>line_end</name></expr>;</condition>
         <incr><expr>++<name>line</name></expr></incr>)
    <block>{
      <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>numBlockLines</name>++</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>numInlineLines</name>++</expr>;</expr_stmt></else></if>
    }</block></for>
  }</block></then></if>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" sc=%p(i=%d,b=%d)"</expr></argument>,
          <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mStyleContext</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>numInlineLines</name></expr></argument>, <argument><expr><name>numBlockLines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>pseudoTag</name> <init>= <expr><call><name><name>mStyleContext</name>-&gt;<name>GetPseudoType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>pseudoTag</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>atomString</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>pseudoTag</name>-&gt;<name>ToString</name></name><argument_list>(<argument><expr><name>atomString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" pst=%s"</expr></argument>,
            <argument><expr><call><name>NS_LossyConvertUTF16toASCII</name><argument_list>(<argument><expr><name>atomString</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"&lt;\n"</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>aIndent</name>++</expr>;</expr_stmt>

  <comment type="line">// Output the lines</comment>
  <if>if <condition>(<expr>! <call><name><name>mLines</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <for>for (<init><decl><type><name>const_line_iterator</name></type> <name>line</name> <init>= <expr><call><name>begin_lines</name><argument_list>()</argument_list></call></expr></init>, <name>line_end</name> <init>= <expr><call><name>end_lines</name><argument_list>()</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>line</name> != <name>line_end</name></expr>;</condition>
         <incr><expr>++<name>line</name></expr></incr>)
    <block>{
      <expr_stmt><expr><call><name><name>line</name>-&gt;<name>List</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>aIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>listName</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>listIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <expr_stmt><expr><name>listName</name> = <call><name>GetAdditionalChildListName</name><argument_list>(<argument><expr><name>listIndex</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>nsnull</name> == <name>listName</name></expr>)</condition><then> <block>{
      <break>break;</break>
    }</block></then></if>
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>kid</name> <init>= <expr><call><name>GetFirstChild</name><argument_list>(<argument><expr><name>listName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>kid</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>aIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsAutoString</name></type> <name>tmp</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>nsnull</name> != <name>listName</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>listName</name>-&gt;<name>ToString</name></name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><call><name>NS_LossyConvertUTF16toASCII</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"&lt;\n"</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>kid</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>nsIFrameDebug</name>*</type>  <name>frameDebug</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name>kid</name></expr></argument>, <argument><expr>&amp;<name>frameDebug</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>frameDebug</name>-&gt;<name>List</name></name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>aIndent</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>kid</name> = <call><name><name>kid</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>aIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"&gt;\n"</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <expr_stmt><expr><name>aIndent</name>--</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>aIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>"&gt;\n"</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<macro><name>NS_IMETHODIMP_</name><argument_list>(<argument>nsFrameState</argument>)</argument_list></macro>
<macro><name>nsBlockFrame</name></macro><expr_stmt><expr><name>::<name>GetDebugStateBits</name></name>() const
<block>{
  <comment type="line">// We don't want to include our cursor flag in the bits the</comment>
  <comment type="line">// regression tester looks at</comment>
  <return>return <expr><call><name><name>nsBlockFrameSuper</name>::<name>GetDebugStateBits</name></name><argument_list>()</argument_list></call> &amp; ~<name>NS_BLOCK_HAS_LINE_CURSOR</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBlockFrame</name>::<name>GetFrameName</name></name><parameter_list>(<param><decl><type><name>nsAString</name>&amp;</type> <name>aResult</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><call><name>MakeFrameName</name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"Block"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aResult</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>nsIAtom</name>*</type>
<name><name>nsBlockFrame</name>::<name>GetType</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name><name>nsGkAtoms</name>::<name>blockFrame</name></name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsBlockFrame</name>::<name>InvalidateInternal</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aDamageRect</name></decl></param>,
                                 <param><decl><type><name>nscoord</name></type> <name>aX</name></decl></param>, <param><decl><type><name>nscoord</name></type> <name>aY</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aForChild</name></decl></param>,
                                 <param><decl><type><name>PRBool</name></type> <name>aImmediate</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Optimize by suppressing invalidation of areas that are clipped out</comment>
  <comment type="line">// with CSS 'clip'.</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleDisplay</name>*</type> <name>disp</name> <init>= <expr><call><name>GetStyleDisplay</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>absPosClipRect</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>GetAbsPosClipRect</name><argument_list>(<argument><expr><name>disp</name></expr></argument>, <argument><expr>&amp;<name>absPosClipRect</name></expr></argument>, <argument><expr><call><name>GetSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Restrict the invalidated area to abs-pos clip rect</comment>
    <comment type="line">// abs-pos clipping clips everything in the frame</comment>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>r</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>r</name>.<name>IntersectRect</name></name><argument_list>(<argument><expr><name>aDamageRect</name></expr></argument>, <argument><expr><name>absPosClipRect</name> - <call><name>nsPoint</name><argument_list>(<argument><expr><name>aX</name></expr></argument>, <argument><expr><name>aY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>nsBlockFrameSuper</name>::<name>InvalidateInternal</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>aX</name></expr></argument>, <argument><expr><name>aY</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>aImmediate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>nsBlockFrameSuper</name>::<name>InvalidateInternal</name></name><argument_list>(<argument><expr><name>aDamageRect</name></expr></argument>, <argument><expr><name>aX</name></expr></argument>, <argument><expr><name>aY</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>aImmediate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>nscoord</name></type>
<name><name>nsBlockFrame</name>::<name>GetBaseline</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>NS_SUBTREE_DIRTY</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"frame must not be dirty"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>result</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name><name>nsLayoutUtils</name>::<name>GetLastLineBaseline</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>
  <return>return <expr><call><name><name>nsFrame</name>::<name>GetBaseline</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="line" format="doxygen">/////////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Child frame enumeration</comment>

<function><type><name>nsIFrame</name>*</type>
<name><name>nsBlockFrame</name>::<name>GetFirstChild</name></name><parameter_list>(<param><decl><type><name>nsIAtom</name>*</type> <name>aListName</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr><name><name>nsGkAtoms</name>::<name>absoluteList</name></name> == <name>aListName</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>result</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mAbsoluteContainer</name>.<name>FirstChild</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aListName</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>nsnull</name> == <name>aListName</name></expr>)</condition><then> <block>{
    <return>return <expr>(<call><name><name>mLines</name>.<name>empty</name></name><argument_list>()</argument_list></call>) ? <name>nsnull</name> : <call><name><name>mLines</name>.<name>front</name></name><argument_list>()</argument_list></call>-&gt;<name>mFirstChild</name></expr>;</return>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>aListName</name> == <name><name>nsGkAtoms</name>::<name>overflowList</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsLineList</name>*</type> <name>overflowLines</name> <init>= <expr><call><name>GetOverflowLines</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>overflowLines</name> ? <call><name><name>overflowLines</name>-&gt;<name>front</name></name><argument_list>()</argument_list></call>-&gt;<name>mFirstChild</name> : <name>nsnull</name></expr>;</return>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>aListName</name> == <name><name>nsGkAtoms</name>::<name>overflowOutOfFlowList</name></name></expr>)</condition><then> <block>{
    <return>return <expr><call><name>GetOverflowOutOfFlows</name><argument_list>()</argument_list></call>.<call><name>FirstChild</name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>aListName</name> == <name><name>nsGkAtoms</name>::<name>floatList</name></name></expr>)</condition><then> <block>{
    <return>return <expr><call><name><name>mFloats</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>aListName</name> == <name><name>nsGkAtoms</name>::<name>bulletList</name></name></expr>)</condition><then> <block>{
    <return>return <expr>(<call><name>HaveOutsideBullet</name><argument_list>()</argument_list></call>) ? <name>mBullet</name> : <name>nsnull</name></expr>;</return>
  }</block></then></if></else></if></else></if></else></if></else></if></else></if>
  <return>return <expr><call><name><name>nsContainerFrame</name>::<name>GetFirstChild</name></name><argument_list>(<argument><expr><name>aListName</name></expr></argument>)</argument_list></call></expr>;</return><empty_stmt>;</empty_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_BLOCK_FRAME_OVERFLOW_OOF_LIST_INDEX</name></cpp:macro>  <cpp:value>(NS_CONTAINER_LIST_COUNT_INCL_OC + 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_BLOCK_FRAME_FLOAT_LIST_INDEX</name></cpp:macro>         <cpp:value>(NS_CONTAINER_LIST_COUNT_INCL_OC + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_BLOCK_FRAME_BULLET_LIST_INDEX</name></cpp:macro>        <cpp:value>(NS_CONTAINER_LIST_COUNT_INCL_OC + 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_BLOCK_FRAME_ABSOLUTE_LIST_INDEX</name></cpp:macro>      <cpp:value>(NS_CONTAINER_LIST_COUNT_INCL_OC + 3)</cpp:value></cpp:define>
<comment type="line">// If adding/removing lists, don't forget to update the count in nsBlockFrame.h</comment>

<function><type><name>nsIAtom</name>*</type>
<name><name>nsBlockFrame</name>::<name>GetAdditionalChildListName</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aIndex</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <if>if <condition>(<expr><name>aIndex</name> &lt; <name>NS_CONTAINER_LIST_COUNT_INCL_OC</name></expr>)</condition><then>
    <return>return <expr><call><name><name>nsContainerFrame</name>::<name>GetAdditionalChildListName</name></name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <switch>switch <condition>(<expr><name>aIndex</name></expr>)</condition> <block>{
  <case>case <expr><name>NS_BLOCK_FRAME_FLOAT_LIST_INDEX</name></expr>:
    <return>return <expr><name><name>nsGkAtoms</name>::<name>floatList</name></name></expr>;</return>
  </case><case>case <expr><name>NS_BLOCK_FRAME_BULLET_LIST_INDEX</name></expr>:
    <return>return <expr><name><name>nsGkAtoms</name>::<name>bulletList</name></name></expr>;</return>
  </case><case>case <expr><name>NS_BLOCK_FRAME_OVERFLOW_OOF_LIST_INDEX</name></expr>:
    <return>return <expr><name><name>nsGkAtoms</name>::<name>overflowOutOfFlowList</name></name></expr>;</return>
  </case><case>case <expr><name>NS_BLOCK_FRAME_ABSOLUTE_LIST_INDEX</name></expr>:
    <return>return <expr><name><name>nsGkAtoms</name>::<name>absoluteList</name></name></expr>;</return>
  </case><default>default:
    <return>return <expr><name>nsnull</name></expr>;</return>
  </default>}</block></switch>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>PRBool</name></type>
<name><name>nsBlockFrame</name>::<name>IsContainingBlock</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>PRBool</name></type>
<name><name>nsBlockFrame</name>::<name>IsFloatContainingBlock</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>IsContinuationPlaceholder</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>aFrame</name>-&gt;<name>GetPrevInFlow</name></name><argument_list>()</argument_list></call> &amp;&amp;
    <name><name>nsGkAtoms</name>::<name>placeholderFrame</name></name> == <call><name><name>aFrame</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ReparentFrame</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>, <param><decl><type><name>nsIFrame</name>*</type> <name>aOldParent</name></decl></param>,
                          <param><decl><type><name>nsIFrame</name>*</type> <name>aNewParent</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aOldParent</name> == <call><name><name>aFrame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Parent not consistent with exepectations"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>aFrame</name>-&gt;<name>SetParent</name></name><argument_list>(<argument><expr><name>aNewParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// When pushing and pulling frames we need to check for whether any</comment>
  <comment type="line">// views need to be reparented</comment>
  <expr_stmt><expr><call><name><name>nsHTMLContainerFrame</name>::<name>ReparentFrameView</name></name><argument_list>(<argument><expr><call><name><name>aFrame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aFrame</name></expr></argument>,
                                          <argument><expr><name>aOldParent</name></expr></argument>, <argument><expr><name>aNewParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
 
<comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Frame structure methods</comment>

<comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Reflow methods</comment>

<comment type="block">/* virtual */</comment> <function><type><name>void</name></type>
<name><name>nsBlockFrame</name>::<name>MarkIntrinsicWidthsDirty</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsBlockFrame</name>*</type> <name>dirtyBlock</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsBlockFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetFirstContinuation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>dirtyBlock</name>-&gt;<name>mMinWidth</name></name> = <name>NS_INTRINSIC_WIDTH_UNKNOWN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dirtyBlock</name>-&gt;<name>mPrefWidth</name></name> = <name>NS_INTRINSIC_WIDTH_UNKNOWN</name></expr>;</expr_stmt>
  <if>if <condition>(<expr>!(<call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_BLOCK_NEEDS_BIDI_RESOLUTION</name>)</expr>)</condition><then> <block>{
    <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><name>dirtyBlock</name></expr></init></decl>;</init> <condition><expr><name>frame</name></expr>;</condition> 
         <incr><expr><name>frame</name> = <call><name><name>frame</name>-&gt;<name>GetNextContinuation</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
      <expr_stmt><expr><call><name><name>frame</name>-&gt;<name>AddStateBits</name></name><argument_list>(<argument><expr><name>NS_BLOCK_NEEDS_BIDI_RESOLUTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>nsBlockFrameSuper</name>::<name>MarkIntrinsicWidthsDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>nscoord</name></type>
<name><name>nsBlockFrame</name>::<name>GetMinWidth</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>firstInFlow</name> <init>= <expr><call><name>GetFirstContinuation</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>firstInFlow</name> != <name>this</name></expr>)</condition><then>
    <return>return <expr><call><name><name>firstInFlow</name>-&gt;<name>GetMinWidth</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>DISPLAY_MIN_WIDTH</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mMinWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>mMinWidth</name> != <name>NS_INTRINSIC_WIDTH_UNKNOWN</name></expr>)</condition><then>
    <return>return <expr><name>mMinWidth</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>gNoisyIntrinsic</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": GetMinWidth\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <function_decl><type><name>AutoNoisyIndenter</name></type> <name>indent</name><parameter_list>(<param><decl><type><name>gNoisyIntrinsic</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_BLOCK_NEEDS_BIDI_RESOLUTION</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>ResolveBidi</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <decl_stmt><decl><type><name>InlineMinWidthData</name></type> <name>data</name></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>nsBlockFrame</name>*</type> <name>curFrame</name> <init>= <expr><name>this</name></expr></init></decl>;</init> <condition><expr><name>curFrame</name></expr>;</condition>
       <incr><expr><name>curFrame</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsBlockFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>curFrame</name>-&gt;<name>GetNextContinuation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></incr>) <block>{
    <for>for (<init><decl><type><name>line_iterator</name></type> <name>line</name> <init>= <expr><call><name><name>curFrame</name>-&gt;<name>begin_lines</name></name><argument_list>()</argument_list></call></expr></init>, <name>line_end</name> <init>= <expr><call><name><name>curFrame</name>-&gt;<name>end_lines</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
      <condition><expr><name>line</name> != <name>line_end</name></expr>;</condition> <incr><expr>++<name>line</name></expr></incr>)
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      <if>if <condition>(<expr><name>gNoisyIntrinsic</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"line (%s%s)\n"</expr></argument>,
               <argument><expr><call><name><name>line</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call> ? "block" : "inline"</expr></argument>,
               <argument><expr><call><name><name>line</name>-&gt;<name>IsEmpty</name></name><argument_list>()</argument_list></call> ? ", empty" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <function_decl><type><name>AutoNoisyIndenter</name></type> <name>lineindent</name><parameter_list>(<param><decl><type><name>gNoisyIntrinsic</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>data</name>.<name>ForceBreak</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>data</name>.<name>currentLine</name></name> = <call><name><name>nsLayoutUtils</name>::<name>IntrinsicForContainer</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>,
                        <argument><expr><name><name>line</name>-&gt;<name>mFirstChild</name></name></expr></argument>, <argument><expr><name><name>nsLayoutUtils</name>::<name>MIN_WIDTH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>data</name>.<name>ForceBreak</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<call><name><name>curFrame</name>-&gt;<name>GetPrevContinuation</name></name><argument_list>()</argument_list></call> &amp;&amp;
            <name>line</name> == <call><name><name>curFrame</name>-&gt;<name>begin_lines</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleCoord</name> &amp;</type><name>indent</name> <init>= <expr><call><name>GetStyleText</name><argument_list>()</argument_list></call>-&gt;<name>mTextIndent</name></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><call><name><name>indent</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eStyleUnit_Coord</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>data</name>.<name>currentLine</name></name> += <call><name><name>indent</name>.<name>GetCoordValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
        <comment type="line">// XXX Bug NNNNNN Should probably handle percentage text-indent.</comment>

      <expr_stmt><expr><name><name>data</name>.<name>line</name></name> = &amp;<name>line</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>kid</name> <init>= <expr><name><name>line</name>-&gt;<name>mFirstChild</name></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>i_end</name> <init>= <expr><call><name><name>line</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> != <name>i_end</name></expr>;</condition>
             <incr><expr>++<name>i</name></expr>, <expr><name>kid</name> = <call><name><name>kid</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
          <expr_stmt><expr><call><name><name>kid</name>-&gt;<name>AddInlineMinWidth</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      }</block></else></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      <if>if <condition>(<expr><name>gNoisyIntrinsic</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"min: [prevLines=%d currentLine=%d]\n"</expr></argument>,
               <argument><expr><name><name>data</name>.<name>prevLines</name></name></expr></argument>, <argument><expr><name><name>data</name>.<name>currentLine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></for>
  }</block></for>
  <expr_stmt><expr><call><name><name>data</name>.<name>ForceBreak</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mMinWidth</name> = <name><name>data</name>.<name>prevLines</name></name></expr>;</expr_stmt>
  <return>return <expr><name>mMinWidth</name></expr>;</return>
}</block></function>

<comment type="block">/* virtual */</comment> <function><type><name>nscoord</name></type>
<name><name>nsBlockFrame</name>::<name>GetPrefWidth</name></name><parameter_list>(<param><decl><type><name>nsIRenderingContext</name> *</type><name>aRenderingContext</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>firstInFlow</name> <init>= <expr><call><name>GetFirstContinuation</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>firstInFlow</name> != <name>this</name></expr>)</condition><then>
    <return>return <expr><call><name><name>firstInFlow</name>-&gt;<name>GetPrefWidth</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>DISPLAY_PREF_WIDTH</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>mPrefWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mPrefWidth</name> != <name>NS_INTRINSIC_WIDTH_UNKNOWN</name></expr>)</condition><then>
    <return>return <expr><name>mPrefWidth</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>gNoisyIntrinsic</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": GetPrefWidth\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <function_decl><type><name>AutoNoisyIndenter</name></type> <name>indent</name><parameter_list>(<param><decl><type><name>gNoisyIntrinsic</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_BLOCK_NEEDS_BIDI_RESOLUTION</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>ResolveBidi</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <decl_stmt><decl><type><name>InlinePrefWidthData</name></type> <name>data</name></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>nsBlockFrame</name>*</type> <name>curFrame</name> <init>= <expr><name>this</name></expr></init></decl>;</init> <condition><expr><name>curFrame</name></expr>;</condition>
       <incr><expr><name>curFrame</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsBlockFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>curFrame</name>-&gt;<name>GetNextContinuation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></incr>) <block>{
    <for>for (<init><decl><type><name>line_iterator</name></type> <name>line</name> <init>= <expr><call><name><name>curFrame</name>-&gt;<name>begin_lines</name></name><argument_list>()</argument_list></call></expr></init>, <name>line_end</name> <init>= <expr><call><name><name>curFrame</name>-&gt;<name>end_lines</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>line</name> != <name>line_end</name></expr>;</condition> <incr><expr>++<name>line</name></expr></incr>)
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      <if>if <condition>(<expr><name>gNoisyIntrinsic</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"line (%s%s)\n"</expr></argument>,
               <argument><expr><call><name><name>line</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call> ? "block" : "inline"</expr></argument>,
               <argument><expr><call><name><name>line</name>-&gt;<name>IsEmpty</name></name><argument_list>()</argument_list></call> ? ", empty" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <function_decl><type><name>AutoNoisyIndenter</name></type> <name>lineindent</name><parameter_list>(<param><decl><type><name>gNoisyIntrinsic</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>data</name>.<name>ForceBreak</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>data</name>.<name>currentLine</name></name> = <call><name><name>nsLayoutUtils</name>::<name>IntrinsicForContainer</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>,
                        <argument><expr><name><name>line</name>-&gt;<name>mFirstChild</name></name></expr></argument>, <argument><expr><name><name>nsLayoutUtils</name>::<name>PREF_WIDTH</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>data</name>.<name>ForceBreak</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<call><name><name>curFrame</name>-&gt;<name>GetPrevContinuation</name></name><argument_list>()</argument_list></call> &amp;&amp;
            <name>line</name> == <call><name><name>curFrame</name>-&gt;<name>begin_lines</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleCoord</name> &amp;</type><name>indent</name> <init>= <expr><call><name>GetStyleText</name><argument_list>()</argument_list></call>-&gt;<name>mTextIndent</name></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><call><name><name>indent</name>.<name>GetUnit</name></name><argument_list>()</argument_list></call> == <name>eStyleUnit_Coord</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>data</name>.<name>currentLine</name></name> += <call><name><name>indent</name>.<name>GetCoordValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
        <comment type="line">// XXX Bug NNNNNN Should probably handle percentage text-indent.</comment>

      <expr_stmt><expr><name><name>data</name>.<name>line</name></name> = &amp;<name>line</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>nsIFrame</name> *</type><name>kid</name> <init>= <expr><name><name>line</name>-&gt;<name>mFirstChild</name></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>PRInt32</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>i_end</name> <init>= <expr><call><name><name>line</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> != <name>i_end</name></expr>;</condition>
             <incr><expr>++<name>i</name></expr>, <expr><name>kid</name> = <call><name><name>kid</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
          <expr_stmt><expr><call><name><name>kid</name>-&gt;<name>AddInlinePrefWidth</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      }</block></else></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      <if>if <condition>(<expr><name>gNoisyIntrinsic</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"pref: [prevLines=%d currentLine=%d]\n"</expr></argument>,
               <argument><expr><name><name>data</name>.<name>prevLines</name></name></expr></argument>, <argument><expr><name><name>data</name>.<name>currentLine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></for>
  }</block></for>
  <expr_stmt><expr><call><name><name>data</name>.<name>ForceBreak</name></name><argument_list>(<argument><expr><name>aRenderingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mPrefWidth</name> = <name><name>data</name>.<name>prevLines</name></name></expr>;</expr_stmt>
  <return>return <expr><name>mPrefWidth</name></expr>;</return>
}</block></function>

<function><type><name>nsRect</name></type>
<name><name>nsBlockFrame</name>::<name>ComputeTightBounds</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
  <comment type="line">// be conservative</comment>
  <if>if <condition>(<expr><call><name>GetStyleContext</name><argument_list>()</argument_list></call>-&gt;<call><name>HasTextDecorations</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>GetOverflowRect</name><argument_list>()</argument_list></call></expr>;</return></then></if>
  <return>return <expr><call><name>ComputeSimpleTightBounds</name><argument_list>(<argument><expr><name>aContext</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsSize</name></type>
<name>CalculateContainingBlockSizeForAbsolutes</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                                         <param><decl><type><name>nsSize</name></type> <name>aFrameSize</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// The issue here is that for a 'height' of 'auto' the reflow state</comment>
  <comment type="line">// code won't know how to calculate the containing block height</comment>
  <comment type="line">// because it's calculated bottom up. So we use our own computed</comment>
  <comment type="line">// size as the dimensions.</comment>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><name><name>aReflowState</name>.<name>frame</name></name></expr></init></decl>;</decl_stmt>

  <function_decl><type><name>nsSize</name></type> <name>cbSize</name><parameter_list>(<param><decl><type><name>aFrameSize</name></type></decl></param>)</parameter_list>;</function_decl>
    <comment type="line">// Containing block is relative to the padding edge</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsMargin</name>&amp;</type> <name>border</name> <init>= <expr><call><name><name>aReflowState</name>.<name>mStyleBorder</name>-&gt;<name>GetBorder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>cbSize</name>.<name>width</name></name> -= <name><name>border</name>.<name>left</name></name> + <name><name>border</name>.<name>right</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cbSize</name>.<name>height</name></name> -= <name><name>border</name>.<name>top</name></name> + <name><name>border</name>.<name>bottom</name></name></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name><name>frame</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call>-&gt;<call><name>GetContent</name><argument_list>()</argument_list></call> == <call><name><name>frame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// We are a wrapped frame for the content. Use the container's</comment>
    <comment type="line">// dimensions, if they have been precomputed.</comment>
    <comment type="line">// XXX This is a hack! We really should be waiting until the outermost</comment>
    <comment type="line">// frame is fully reflowed and using the resulting dimensions, even</comment>
    <comment type="line">// if they're intrinsic.</comment>
    <comment type="line">// In fact we should be attaching absolute children to the outermost</comment>
    <comment type="line">// frame and not always sticking them in block frames.</comment>

    <comment type="line">// First, find the reflow state for the outermost frame for this</comment>
    <comment type="line">// content.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>*</type> <name>aLastRS</name> <init>= <expr>&amp;<name>aReflowState</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>*</type> <name>lastButOneRS</name> <init>= <expr>&amp;<name>aReflowState</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name><name>aLastRS</name>-&gt;<name>parentReflowState</name></name> &amp;&amp;
           <call><name><name>aLastRS</name>-&gt;<name>parentReflowState</name>-&gt;<name>frame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call> == <call><name><name>frame</name>-&gt;<name>GetContent</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
      <expr_stmt><expr><name>lastButOneRS</name> = <name>aLastRS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aLastRS</name> = <name><name>aLastRS</name>-&gt;<name>parentReflowState</name></name></expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr><name>aLastRS</name> != &amp;<name>aReflowState</name></expr>)</condition><then> <block>{
      <comment type="line">// Scrollbars need to be specifically excluded, if present, because they are outside the</comment>
      <comment type="line">// padding-edge. We need better APIs for getting the various boxes from a frame.</comment>
      <decl_stmt><decl><type><name>nsIScrollableFrame</name>*</type> <name>scrollFrame</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>CallQueryInterface</name><argument_list>(<argument><expr><name><name>aLastRS</name>-&gt;<name>frame</name></name></expr></argument>, <argument><expr>&amp;<name>scrollFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>nsMargin</name></type> <name>scrollbars</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>scrollFrame</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsBoxLayoutState</name></type> <name>dummyState</name><argument_list>(<argument><expr><call><name><name>aLastRS</name>-&gt;<name>frame</name>-&gt;<name>PresContext</name></name><argument_list>()</argument_list></call></expr></argument>,
                                    <argument><expr><name><name>aLastRS</name>-&gt;<name>rendContext</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><name>scrollbars</name> = <call><name><name>scrollFrame</name>-&gt;<name>GetDesiredScrollbarSizes</name></name><argument_list>(<argument><expr>&amp;<name>dummyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>lastButOneRS</name>-&gt;<name>mFlags</name>.<name>mAssumingHScrollbar</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>scrollbars</name>.<name>top</name></name> = <name><name>scrollbars</name>.<name>bottom</name></name> = 0</expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>!<name><name>lastButOneRS</name>-&gt;<name>mFlags</name>.<name>mAssumingVScrollbar</name></name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>scrollbars</name>.<name>left</name></name> = <name><name>scrollbars</name>.<name>right</name></name> = 0</expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <comment type="line">// We found a reflow state for the outermost wrapping frame, so use</comment>
      <comment type="line">// its computed metrics if available</comment>
      <if>if <condition>(<expr><call><name><name>aLastRS</name>-&gt;<name>ComputedWidth</name></name><argument_list>()</argument_list></call> != <name>NS_UNCONSTRAINEDSIZE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>cbSize</name>.<name>width</name></name> = <call><name>PR_MAX</name><argument_list>(<argument><expr>0</expr></argument>,
          <argument><expr><call><name><name>aLastRS</name>-&gt;<name>ComputedWidth</name></name><argument_list>()</argument_list></call> + <call><name><name>aLastRS</name>-&gt;<name>mComputedPadding</name>.<name>LeftRight</name></name><argument_list>()</argument_list></call> - <call><name><name>scrollbars</name>.<name>LeftRight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><call><name><name>aLastRS</name>-&gt;<name>ComputedHeight</name></name><argument_list>()</argument_list></call> != <name>NS_UNCONSTRAINEDSIZE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>cbSize</name>.<name>height</name></name> = <call><name>PR_MAX</name><argument_list>(<argument><expr>0</expr></argument>,
          <argument><expr><call><name><name>aLastRS</name>-&gt;<name>ComputedHeight</name></name><argument_list>()</argument_list></call> + <call><name><name>aLastRS</name>-&gt;<name>mComputedPadding</name>.<name>TopBottom</name></name><argument_list>()</argument_list></call> - <call><name><name>scrollbars</name>.<name>TopBottom</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>cbSize</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsBlockFrame</name>::<name>Reflow</name></name><parameter_list>(<param><decl><type><name>nsPresContext</name>*</type>           <name>aPresContext</name></decl></param>,
                     <param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type>     <name>aMetrics</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                     <param><decl><type><name>nsReflowStatus</name>&amp;</type>          <name>aStatus</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>DO_GLOBAL_REFLOW_COUNT</name><argument_list>(<argument><expr>"nsBlockFrame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DISPLAY_REFLOW</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aMetrics</name></expr></argument>, <argument><expr><name>aStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>gNoisyReflow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": begin reflow availSize=%d,%d computedSize=%d,%d\n"</expr></argument>,
           <argument><expr><name><name>aReflowState</name>.<name>availableWidth</name></name></expr></argument>, <argument><expr><name><name>aReflowState</name>.<name>availableHeight</name></name></expr></argument>,
           <argument><expr><call><name><name>aReflowState</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aReflowState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <function_decl><type><name>AutoNoisyIndenter</name></type> <name>indent</name><parameter_list>(<param><decl><type><name>gNoisy</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>PRTime</name></type> <name>start</name> <init>= <expr><name>LL_ZERO</name></expr></init></decl>;</decl_stmt> <comment type="line">// Initialize these variablies to silence the compiler.</comment>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>ctc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>        <comment type="line">// We only use these if they are set (gLameReflowMetrics).</comment>
  <if>if <condition>(<expr><name>gLameReflowMetrics</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>start</name> = <call><name>PR_Now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctc</name> = <call><name><name>nsLineBox</name>::<name>GetCtorCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>nsSize</name></type> <name>oldSize</name> <init>= <expr><call><name>GetSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Should we create a space manager?</comment>
  <decl_stmt><decl><type><name>nsAutoSpaceManager</name></type> <name>autoSpaceManager</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list>&lt;<argument><expr><name>nsHTMLReflowState</name> &amp;</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

  <comment type="line">// XXXldb If we start storing the space manager in the frame rather</comment>
  <comment type="line">// than keeping it around only during reflow then we should create it</comment>
  <comment type="line">// only when there are actually floats to manage.  Otherwise things</comment>
  <comment type="line">// like tables will gain significant bloat.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>needSpaceManager</name> <init>= <expr><call><name><name>nsBlockFrame</name>::<name>BlockNeedsSpaceManager</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>needSpaceManager</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>autoSpaceManager</name>.<name>CreateSpaceManagerFor</name></name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// OK, some lines may be reflowed. Blow away any saved line cursor because</comment>
  <comment type="line">// we may invalidate the nondecreasing combinedArea.y/yMost invariant,</comment>
  <comment type="line">// and we may even delete the line with the line cursor.</comment>
  <expr_stmt><expr><call><name>ClearLineCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>IsFrameTreeTooDeep</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aMetrics</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_kipp</name></cpp:ifdef>
    <block>{
      <decl_stmt><decl><type><specifier>extern</specifier> <name>char</name>*</type> <name>nsPresShell_ReflowStackPointerTop</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>marker</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name>*</type> <name>newsp</name> <init>= <expr>(<name>char</name>*) &amp;<name>marker</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"XXX: frame tree is too deep; approx stack size = %d\n"</expr></argument>,
             <argument><expr><name>nsPresShell_ReflowStackPointerTop</name> - <name>newsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>aStatus</name> = <name>NS_FRAME_COMPLETE</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>marginRoot</name> <init>= <expr><call><name>BlockIsMarginRoot</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>nsBlockReflowState</name></type> <name>state</name><parameter_list>(<param><decl><type><name>aReflowState</name></type></decl></param>, <param><decl><type><name>aPresContext</name></type></decl></param>, <param><decl><type><name>this</name></type></decl></param>, <param><decl><type><name>aMetrics</name></type></decl></param>,
                           <param><decl><type><name>marginRoot</name></type></decl></param>, <param><decl><type><name>marginRoot</name></type></decl></param>, <param><decl><type><name>needSpaceManager</name></type></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
  <if>if <condition>(<expr><call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_BLOCK_NEEDS_BIDI_RESOLUTION</name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsBlockFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetFirstContinuation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>-&gt;<call><name>ResolveBidi</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// IBMBIDI</comment>

  <if>if <condition>(<expr><call><name>RenumberLists</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>AddStateBits</name><argument_list>(<argument><expr><name>NS_FRAME_HAS_DIRTY_CHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// ALWAYS drain overflow. We never want to leave the previnflow's</comment>
  <comment type="line">// overflow lines hanging around; block reflow depends on the</comment>
  <comment type="line">// overflow line lists being cleared out between reflow passes.</comment>
  <expr_stmt><expr><call><name>DrainOverflowLines</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>state</name>.<name>SetupOverflowPlaceholdersProperty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 
  <comment type="line">// If we're not dirty (which means we'll mark everything dirty later)</comment>
  <comment type="line">// and our width has changed, mark the lines dirty that we need to</comment>
  <comment type="line">// mark dirty for a resize reflow.</comment>
  <if>if <condition>(<expr><name><name>aReflowState</name>.<name>mFlags</name>.<name>mHResize</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>PrepareResizeReflow</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>mState</name> &amp;= ~<name>NS_FRAME_FIRST_REFLOW</name></expr>;</expr_stmt>

  <comment type="line">// Now reflow...</comment>
  <expr_stmt><expr><name>rv</name> = <call><name>ReflowDirtyLines</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"reflow dirty lines failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr><name>rv</name></expr>;</return></then></if>

  <comment type="line">// Handle paginated overflow (see nsContainerFrame.h)</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>overflowContainerBounds</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ReflowOverflowContainerChildren</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>,
                                    <argument><expr><name>overflowContainerBounds</name></expr></argument>, <argument><expr>0</expr></argument>,
                                    <argument><expr><name><name>state</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// If the block is complete, put continuted floats in the closest ancestor </comment>
  <comment type="line">// block that uses the same space manager and leave the block complete; this </comment>
  <comment type="line">// allows subsequent lines on the page to be impacted by floats. If the </comment>
  <comment type="line">// block is incomplete or there is no ancestor using the same space manager, </comment>
  <comment type="line">// put continued floats at the beginning of the first overflow line.</comment>
  <if>if <condition>(<expr><call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>NotEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>aReflowState</name>.<name>availableHeight</name></name> != <name>NS_UNCONSTRAINEDSIZE</name></expr></argument>,
                 <argument><expr>"Somehow we failed to fit all content, even though we have unlimited space!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FRAME_IS_FULLY_COMPLETE</name><argument_list>(<argument><expr><name><name>state</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// find the nearest block ancestor that uses the same space manager</comment>
      <for>for (<init><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>*</type> <name>ancestorRS</name> <init>= <expr><name><name>aReflowState</name>.<name>parentReflowState</name></name></expr></init></decl>;</init> 
           <condition><expr><name>ancestorRS</name></expr>;</condition> 
           <incr><expr><name>ancestorRS</name> = <name><name>ancestorRS</name>-&gt;<name>parentReflowState</name></name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>ancestor</name> <init>= <expr><name><name>ancestorRS</name>-&gt;<name>frame</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>nsIAtom</name>*</type> <name>fType</name> <init>= <expr><call><name><name>ancestor</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name><name>nsGkAtoms</name>::<name>blockFrame</name></name> == <name>fType</name> || <name><name>nsGkAtoms</name>::<name>areaFrame</name></name> == <name>fType</name>) &amp;&amp;
            <name><name>aReflowState</name>.<name>mSpaceManager</name></name> == <name><name>ancestorRS</name>-&gt;<name>mSpaceManager</name></name></expr>)</condition><then> <block>{
          <comment type="line">// Put the continued floats in ancestor since it uses the same space manager</comment>
          <decl_stmt><decl><type><name>nsFrameList</name>*</type> <name>ancestorPlace</name> <init>=
            <expr>((<name>nsBlockFrame</name>*)<name>ancestor</name>)-&gt;<call><name>GetOverflowPlaceholders</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <comment type="line">// The ancestor should have this list, since it's being reflowed. But maybe</comment>
          <comment type="line">// it isn't because of reflow roots or something.</comment>
          <if>if <condition>(<expr><name>ancestorPlace</name></expr>)</condition><then> <block>{
            <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
                 <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> = <call><name><name>f</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
              <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>IsContinuationPlaceholder</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr>"Overflow placeholders must be continuation placeholders"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>ReparentFrame</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>ancestorRS</name>-&gt;<name>frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>oof</name> <init>= <expr><call><name><name>nsPlaceholderFrame</name>::<name>GetRealFrameForPlaceholder</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name><name>mFloats</name>.<name>RemoveFrame</name></name><argument_list>(<argument><expr><name>oof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>ReparentFrame</name><argument_list>(<argument><expr><name>oof</name></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>ancestorRS</name>-&gt;<name>frame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <comment type="line">// Clear the next-sibling in case the frame wasn't in mFloats</comment>
              <expr_stmt><expr><call><name><name>oof</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <comment type="line">// Do not put the float into any child frame list, because</comment>
              <comment type="line">// placeholders in the overflow-placeholder block-state list</comment>
              <comment type="line">// don't keep their out of flows in a child frame list.</comment>
            }</block></for>
            <expr_stmt><expr><call><name><name>ancestorPlace</name>-&gt;<name>AppendFrames</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>SetFrames</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></then></if>
      }</block></for>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>SortByContentOrder</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>numOverflowPlace</name> <init>= <expr><call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>GetLength</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsLineBox</name>*</type> <name>newLine</name> <init>=
        <expr><call><name><name>state</name>.<name>NewLineBox</name></name><argument_list>(<argument><expr><call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><name>numOverflowPlace</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>newLine</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsLineList</name>*</type> <name>overflowLines</name> <init>= <expr><call><name>GetOverflowLines</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>overflowLines</name></expr>)</condition><then> <block>{
          <comment type="line">// Need to put the overflow placeholders' floats into our</comment>
          <comment type="line">// overflow-out-of-flows list, since the overflow placeholders are</comment>
          <comment type="line">// going onto our overflow line list. Put them last, because that's</comment>
          <comment type="line">// where the placeholders are going.</comment>
          <decl_stmt><decl><type><name>nsFrameList</name></type> <name>floats</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>lastFloat</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
          <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
               <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> = <call><name><name>f</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
            <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>IsContinuationPlaceholder</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr>"Overflow placeholders must be continuation placeholders"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>oof</name> <init>= <expr><call><name><name>nsPlaceholderFrame</name>::<name>GetRealFrameForPlaceholder</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// oof is not currently in any child list</comment>
            <expr_stmt><expr><call><name><name>floats</name>.<name>InsertFrames</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>lastFloat</name></expr></argument>, <argument><expr><name>oof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastFloat</name> = <name>oof</name></expr>;</expr_stmt>
          }</block></for>

          <comment type="line">// Put the new placeholders *last* in the overflow lines</comment>
          <comment type="line">// because they might have previnflows in the overflow lines.</comment>
          <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>lastChild</name> <init>= <expr><call><name><name>overflowLines</name>-&gt;<name>back</name></name><argument_list>()</argument_list></call>-&gt;<call><name>LastChild</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name><name>lastChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// Create a new line as the last line and put the</comment>
          <comment type="line">// placeholders there</comment>
          <expr_stmt><expr><call><name><name>overflowLines</name>-&gt;<name>push_back</name></name><argument_list>(<argument><expr><name>newLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <function_decl><type><name>nsAutoOOFFrameList</name></type> <name>oofs</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>)</parameter_list>;</function_decl>
          <expr_stmt><expr><call><name><name>oofs</name>.<name>mList</name>.<name>AppendFrames</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><call><name><name>floats</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><call><name><name>mLines</name>.<name>push_back</name></name><argument_list>(<argument><expr><name>newLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name><name>nsLineList</name>::<name>iterator</name></name></type> <name>nextToLastLine</name> <init>= <expr>----<call><name>end_lines</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>PushLines</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>nextToLastLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name><name>state</name>.<name>mOverflowPlaceholders</name>.<name>SetFrames</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name><name>state</name>.<name>mReflowStatus</name></name> |= <name>NS_FRAME_REFLOW_NEXTINFLOW</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_FRAME_SET_INCOMPLETE</name><argument_list>(<argument><expr><name><name>state</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><call><name>NS_FRAME_IS_NOT_COMPLETE</name><argument_list>(<argument><expr><name><name>state</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>GetOverflowLines</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>state</name>.<name>mReflowStatus</name></name> |= <name>NS_FRAME_REFLOW_NEXTINFLOW</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>NS_STYLE_OVERFLOW_CLIP</name> == <name><name>aReflowState</name>.<name>mStyleDisplay</name>-&gt;<name>mOverflowX</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>state</name>.<name>mReflowStatus</name></name> = <name>NS_FRAME_COMPLETE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_kipp</name></cpp:ifdef>
      <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": block is not complete\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>CheckFloats</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Place the "marker" (bullet) frame if it is placed next to a block</comment>
  <comment type="line">// child.</comment>
  <comment type="line">//</comment>
  <comment type="line">// According to the CSS2 spec, section 12.6.1, the "marker" box</comment>
  <comment type="line">// participates in the height calculation of the list-item box's</comment>
  <comment type="line">// first line box.</comment>
  <comment type="line">//</comment>
  <comment type="line">// There are exactly two places a bullet can be placed: near the</comment>
  <comment type="line">// first or second line. It's only placed on the second line in a</comment>
  <comment type="line">// rare case: an empty first line followed by a second line that</comment>
  <comment type="line">// contains a block (example: &lt;LI&gt;\n&lt;P&gt;... ). This is where</comment>
  <comment type="line">// the second case can happen.</comment>
  <if>if <condition>(<expr><name>mBullet</name> &amp;&amp; <call><name>HaveOutsideBullet</name><argument_list>()</argument_list></call> &amp;&amp;
      (<call><name><name>mLines</name>.<name>empty</name></name><argument_list>()</argument_list></call> ||
       <call><name><name>mLines</name>.<name>front</name></name><argument_list>()</argument_list></call>-&gt;<call><name>IsBlock</name><argument_list>()</argument_list></call> ||
       0 == <call><name><name>mLines</name>.<name>front</name></name><argument_list>()</argument_list></call>-&gt;<name><name>mBounds</name>.<name>height</name></name>)</expr>)</condition><then> <block>{
    <comment type="line">// Reflow the bullet</comment>
    <decl_stmt><decl><type><name>nsHTMLReflowMetrics</name></type> <name>metrics</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ReflowBullet</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>metrics</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nscoord</name></type> <name>baseline</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>nsLayoutUtils</name>::<name>GetFirstLineBaseline</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>&amp;<name>baseline</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>baseline</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    
    <comment type="line">// Doing the alignment using the baseline will also cater for</comment>
    <comment type="line">// bullets that are placed next to a child block (bug 92896)</comment>
    
    <comment type="line">// Tall bullets won't look particularly nice here...</comment>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>bbox</name> <init>= <expr><call><name><name>mBullet</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>bbox</name>.<name>y</name></name> = <name>baseline</name> - <name><name>metrics</name>.<name>ascent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mBullet</name>-&gt;<name>SetRect</name></name><argument_list>(<argument><expr><name>bbox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Compute our final size</comment>
  <expr_stmt><expr><call><name>ComputeFinalSize</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>aMetrics</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ComputeCombinedArea</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aMetrics</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// Factor overflow container child bounds into the overflow area</comment>
  <expr_stmt><expr><call><name><name>aMetrics</name>.<name>mOverflowArea</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name><name>aMetrics</name>.<name>mOverflowArea</name></name></expr></argument>,
                                   <argument><expr><name>overflowContainerBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// see if verifyReflow is enabled, and if so store off the space manager pointer</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>verifyReflowFlags</name> <init>= <expr><call><name><name>nsIPresShell</name>::<name>GetVerifyReflowFlags</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>VERIFY_REFLOW_INCLUDE_SPACE_MANAGER</name> &amp; <name>verifyReflowFlags</name></expr>)</condition><then>
  <block>{
    <comment type="line">// this is a leak of the space manager, but it's only in debug if verify reflow is enabled, so not a big deal</comment>
    <decl_stmt><decl><type><name>nsIPresShell</name> *</type><name>shell</name> <init>= <expr><call><name><name>aPresContext</name>-&gt;<name>GetPresShell</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>shell</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsHTMLReflowState</name>&amp;</type>  <name>reflowState</name> <init>= <expr>(<name>nsHTMLReflowState</name>&amp;)<name>aReflowState</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rv</name> = <call><name>SetProperty</name><argument_list>(<argument><expr><name><name>nsGkAtoms</name>::<name>spaceManagerProperty</name></name></expr></argument>,
                       <argument><expr><name><name>reflowState</name>.<name>mSpaceManager</name></name></expr></argument>,
                       <argument><expr><name>nsnull</name></expr></argument> <comment type="block">/* should be nsSpaceManagerDestroyer*/</comment>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name><name>autoSpaceManager</name>.<name>DebugOrphanSpaceManager</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Let the absolutely positioned container reflow any absolutely positioned</comment>
  <comment type="line">// child frames that need to be reflowed, e.g., elements with a percentage</comment>
  <comment type="line">// based width/height</comment>
  <comment type="line">// We want to do this under either of two conditions:</comment>
  <comment type="line">//  1. If we didn't do the incremental reflow above.</comment>
  <comment type="line">//  2. If our size changed.</comment>
  <comment type="line">// Even though it's the padding edge that's the containing block, we</comment>
  <comment type="line">// can use our rect (the border edge) since if the border style</comment>
  <comment type="line">// changed, the reflow would have been targeted at us so we'd satisfy</comment>
  <comment type="line">// condition 1.</comment>
  <if>if <condition>(<expr><call><name><name>mAbsoluteContainer</name>.<name>HasAbsoluteFrames</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>childBounds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsSize</name></type> <name>containingBlockSize</name>
      <init>= <expr><call><name>CalculateContainingBlockSizeForAbsolutes</name><argument_list>(<argument><expr><name>aReflowState</name></expr></argument>,
                                                 <argument><expr><call><name>nsSize</name><argument_list>(<argument><expr><name><name>aMetrics</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aMetrics</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Mark frames that depend on changes we just made to this frame as dirty:</comment>
    <comment type="line">// Now we can assume that the padding edge hasn't moved.</comment>
    <comment type="line">// We need to reflow the absolutes if one of them depends on</comment>
    <comment type="line">// its placeholder position, or the containing block size in a</comment>
    <comment type="line">// direction in which the containing block size might have</comment>
    <comment type="line">// changed.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>cbWidthChanged</name> <init>= <expr><name><name>aMetrics</name>.<name>width</name></name> != <name><name>oldSize</name>.<name>width</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>isRoot</name> <init>= <expr>!<call><name>GetContent</name><argument_list>()</argument_list></call>-&gt;<call><name>GetParent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// If isRoot and we have auto height, then we are the initial</comment>
    <comment type="line">// containing block and the containing block height is the</comment>
    <comment type="line">// viewport height, which can't change during incremental</comment>
    <comment type="line">// reflow.</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>cbHeightChanged</name> <init>=
      <expr>!(<name>isRoot</name> &amp;&amp; <name>NS_UNCONSTRAINEDSIZE</name> == <call><name><name>aReflowState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call>) &amp;&amp;
      <name><name>aMetrics</name>.<name>height</name></name> != <name><name>oldSize</name>.<name>height</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mAbsoluteContainer</name>.<name>Reflow</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>,
                                   <argument><expr><name><name>state</name>.<name>mReflowStatus</name></name></expr></argument>,
                                   <argument><expr><name><name>containingBlockSize</name>.<name>width</name></name></expr></argument>,
                                   <argument><expr><name><name>containingBlockSize</name>.<name>height</name></name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>,
                                   <argument><expr><name>cbWidthChanged</name></expr></argument>, <argument><expr><name>cbHeightChanged</name></expr></argument>,
                                   <argument><expr>&amp;<name>childBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//XXXfr Why isn't this rv (and others in this file) checked/returned?</comment>

    <comment type="line">// Factor the absolutely positioned child bounds into the overflow area</comment>
    <expr_stmt><expr><call><name><name>aMetrics</name>.<name>mOverflowArea</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name><name>aMetrics</name>.<name>mOverflowArea</name></name></expr></argument>, <argument><expr><name>childBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Determine if we need to repaint our border, background or outline</comment>
  <expr_stmt><expr><call><name>CheckInvalidateSizeChange</name><argument_list>(<argument><expr><name>aPresContext</name></expr></argument>, <argument><expr><name>aMetrics</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>FinishAndStoreOverflow</name><argument_list>(<argument><expr>&amp;<name>aMetrics</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Clear the space manager pointer in the block reflow state so we</comment>
  <comment type="line">// don't waste time translating the coordinate system back on a dead</comment>
  <comment type="line">// space manager.</comment>
  <if>if <condition>(<expr><name>needSpaceManager</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>state</name>.<name>mSpaceManager</name></name> = <name>nsnull</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>aStatus</name> = <name><name>state</name>.<name>mReflowStatus</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>gNoisyReflow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": status=%x (%scomplete) metrics=%d,%d carriedMargin=%d"</expr></argument>,
           <argument><expr><name>aStatus</name></expr></argument>, <argument><expr><call><name>NS_FRAME_IS_COMPLETE</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>)</argument_list></call> ? "" : "not "</expr></argument>,
           <argument><expr><name><name>aMetrics</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aMetrics</name>.<name>height</name></name></expr></argument>,
           <argument><expr><call><name><name>aMetrics</name>.<name>mCarriedOutBottomMargin</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mState</name> &amp; <name>NS_FRAME_OUTSIDE_CHILDREN</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" combinedArea={%d,%d,%d,%d}"</expr></argument>,
             <argument><expr><name><name>aMetrics</name>.<name>mOverflowArea</name>.<name>x</name></name></expr></argument>,
             <argument><expr><name><name>aMetrics</name>.<name>mOverflowArea</name>.<name>y</name></name></expr></argument>,
             <argument><expr><name><name>aMetrics</name>.<name>mOverflowArea</name>.<name>width</name></name></expr></argument>,
             <argument><expr><name><name>aMetrics</name>.<name>mOverflowArea</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>gLameReflowMetrics</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRTime</name></type> <name>end</name> <init>= <expr><call><name>PR_Now</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>ectc</name> <init>= <expr><call><name><name>nsLineBox</name>::<name>GetCtorCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>numLines</name> <init>= <expr><call><name><name>mLines</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>numLines</name></expr>)</condition><then> <expr_stmt><expr><name>numLines</name> = 1</expr>;</expr_stmt></then></if>
    <decl_stmt><decl><type><name>PRTime</name></type> <name>delta</name></decl>, <decl><type ref="prev"/><name>perLineDelta</name></decl>, <decl><type ref="prev"/><name>lines</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LL_I2L</name><argument_list>(<argument><expr><name>lines</name></expr></argument>, <argument><expr><name>numLines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LL_SUB</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LL_DIV</name><argument_list>(<argument><expr><name>perLineDelta</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>400</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PR_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                <argument><expr>": %lld elapsed (%lld per line) (%d lines; %d new lines)"</expr></argument>,
                <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>perLineDelta</name></expr></argument>, <argument><expr><name>numLines</name></expr></argument>, <argument><expr><name>ectc</name> - <name>ctc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s\n"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>NS_FRAME_SET_TRUNCATION</name><argument_list>(<argument><expr><name>aStatus</name></expr></argument>, <argument><expr><name>aReflowState</name></expr></argument>, <argument><expr><name>aMetrics</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>PRBool</name></type>
<name><name>nsBlockFrame</name>::<name>CheckForCollapsedBottomMarginFromClearanceLine</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>line_iterator</name></type> <name>begin</name> <init>= <expr><call><name>begin_lines</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>line_iterator</name></type> <name>line</name> <init>= <expr><call><name>end_lines</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><name>PR_TRUE</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><name>begin</name> == <name>line</name></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>--<name>line</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>line</name>-&gt;<name>mBounds</name>.<name>height</name></name> != 0 || !<call><name><name>line</name>-&gt;<name>CachedIsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>HasClearance</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>
  }</block></while>
  <comment type="line">// not reached</comment>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsBlockFrame</name>::<name>ComputeFinalSize</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                               <param><decl><type><name>nsBlockReflowState</name>&amp;</type>      <name>aState</name></decl></param>,
                               <param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type>     <name>aMetrics</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsMargin</name>&amp;</type> <name>borderPadding</name> <init>= <expr><call><name><name>aState</name>.<name>BorderPadding</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_FINAL_SIZE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": mY=%d mIsBottomMarginRoot=%s mPrevBottomMargin=%d bp=%d,%d\n"</expr></argument>,
         <argument><expr><name><name>aState</name>.<name>mY</name></name></expr></argument>, <argument><expr><call><name><name>aState</name>.<name>GetFlag</name></name><argument_list>(<argument><expr><name>BRS_ISBOTTOMMARGINROOT</name></expr></argument>)</argument_list></call> ? "yes" : "no"</expr></argument>,
         <argument><expr><name><name>aState</name>.<name>mPrevBottomMargin</name></name></expr></argument>,
         <argument><expr><name><name>borderPadding</name>.<name>top</name></name></expr></argument>, <argument><expr><name><name>borderPadding</name>.<name>bottom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Compute final width</comment>
  <expr_stmt><expr><name><name>aMetrics</name>.<name>width</name></name> = <name><name>borderPadding</name>.<name>left</name></name> + <call><name><name>aReflowState</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call> +
    <name><name>borderPadding</name>.<name>right</name></name></expr>;</expr_stmt>

  <comment type="line">// Return bottom margin information</comment>
  <comment type="line">// rbs says he hit this assertion occasionally (see bug 86947), so</comment>
  <comment type="line">// just set the margin to zero and we'll figure out why later</comment>
  <comment type="line">//NS_ASSERTION(aMetrics.mCarriedOutBottomMargin.IsZero(),</comment>
  <comment type="line">//             "someone else set the margin");</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>nonCarriedOutVerticalMargin</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>aState</name>.<name>GetFlag</name></name><argument_list>(<argument><expr><name>BRS_ISBOTTOMMARGINROOT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Apply rule from CSS 2.1 section 8.3.1. If we have some empty</comment>
    <comment type="line">// line with clearance and a non-zero top margin and all</comment>
    <comment type="line">// subsequent lines are empty, then we do not allow our children's</comment>
    <comment type="line">// carried out bottom margin to be carried out of us and collapse</comment>
    <comment type="line">// with our own bottom margin.</comment>
    <if>if <condition>(<expr><call><name>CheckForCollapsedBottomMarginFromClearanceLine</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Convert the children's carried out margin to something that</comment>
      <comment type="line">// we will include in our height</comment>
      <expr_stmt><expr><name>nonCarriedOutVerticalMargin</name> = <call><name><name>aState</name>.<name>mPrevBottomMargin</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>aState</name>.<name>mPrevBottomMargin</name>.<name>Zero</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>aMetrics</name>.<name>mCarriedOutBottomMargin</name></name> = <name><name>aState</name>.<name>mPrevBottomMargin</name></name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name><name>aMetrics</name>.<name>mCarriedOutBottomMargin</name>.<name>Zero</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="line">// Compute final height</comment>
  <if>if <condition>(<expr><name>NS_UNCONSTRAINEDSIZE</name> != <call><name><name>aReflowState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Figure out how much of the computed height should be</comment>
    <comment type="line">// applied to this frame.</comment>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>computedHeightLeftOver</name> <init>= <expr><call><name><name>aReflowState</name>.<name>ComputedHeight</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Reduce the height by the computed height of prev-in-flows.</comment>
      <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>prev</name> <init>= <expr><call><name>GetPrevInFlow</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>prev</name></expr>;</condition> <incr><expr><name>prev</name> = <call><name><name>prev</name>-&gt;<name>GetPrevInFlow</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <expr_stmt><expr><name>computedHeightLeftOver</name> -= <call><name><name>prev</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call>.<name>height</name></expr>;</expr_stmt>
      }</block></for>
      <comment type="line">// We just subtracted our top-border padding, since it was included in the</comment>
      <comment type="line">// first frame's height. Add it back to get the content height.</comment>
      <expr_stmt><expr><name>computedHeightLeftOver</name> += <name><name>aReflowState</name>.<name>mComputedBorderPadding</name>.<name>top</name></name></expr>;</expr_stmt>
      <comment type="line">// We may have stretched the frame beyond its computed height. Oh well.</comment>
      <expr_stmt><expr><name>computedHeightLeftOver</name> = <call><name>PR_MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>computedHeightLeftOver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!( <call><name>IS_TRUE_OVERFLOW_CONTAINER</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
                    &amp;&amp; <name>computedHeightLeftOver</name> )</expr></argument>,
                 <argument><expr>"overflow container must not have computedHeightLeftOver"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>aMetrics</name>.<name>height</name></name> = <name><name>borderPadding</name>.<name>top</name></name> + <name>computedHeightLeftOver</name> + <name><name>borderPadding</name>.<name>bottom</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FRAME_IS_NOT_COMPLETE</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call>
        &amp;&amp; <name><name>aMetrics</name>.<name>height</name></name> &lt; <name><name>aReflowState</name>.<name>availableHeight</name></name></expr>)</condition><then> <block>{
      <comment type="line">// We ran out of height on this page but we're incomplete</comment>
      <comment type="line">// Set status to complete except for overflow</comment>
      <expr_stmt><expr><call><name>NS_FRAME_SET_OVERFLOW_INCOMPLETE</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>NS_FRAME_IS_COMPLETE</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>computedHeightLeftOver</name> &gt; 0 &amp;&amp;
          <name>NS_UNCONSTRAINEDSIZE</name> != <name><name>aReflowState</name>.<name>availableHeight</name></name> &amp;&amp;
          <name><name>aMetrics</name>.<name>height</name></name> &gt; <name><name>aReflowState</name>.<name>availableHeight</name></name></expr>)</condition><then> <block>{
        <comment type="line">// We don't fit and we consumed some of the computed height,</comment>
        <comment type="line">// so we should consume all the available height and then</comment>
        <comment type="line">// break.  If our bottom border/padding straddles the break</comment>
        <comment type="line">// point, then this will increase our height and push the</comment>
        <comment type="line">// border/padding to the next page/column.</comment>
        <expr_stmt><expr><name><name>aMetrics</name>.<name>height</name></name> = <call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>aReflowState</name>.<name>availableHeight</name></name></expr></argument>,
                                 <argument><expr><name><name>aState</name>.<name>mY</name></name> + <name>nonCarriedOutVerticalMargin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_FRAME_SET_INCOMPLETE</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>GetNextInFlow</name><argument_list>()</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><name><name>aState</name>.<name>mReflowStatus</name></name> |= <name>NS_FRAME_REFLOW_NEXTINFLOW</name></expr>;</expr_stmt></then></if>
      }</block></then></if>
    }</block></then>
    <else>else <block>{
      <comment type="line">// Use the current height; continuations will take up the rest.</comment>
      <comment type="line">// Do extend the height to at least consume the available</comment>
      <comment type="line">// height, otherwise our left/right borders (for example) won't</comment>
      <comment type="line">// extend all the way to the break.</comment>
      <expr_stmt><expr><name><name>aMetrics</name>.<name>height</name></name> = <call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>aReflowState</name>.<name>availableHeight</name></name></expr></argument>,
                               <argument><expr><name><name>aState</name>.<name>mY</name></name> + <name>nonCarriedOutVerticalMargin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// ... but don't take up more height than is available</comment>
      <expr_stmt><expr><name><name>aMetrics</name>.<name>height</name></name> = <call><name>PR_MIN</name><argument_list>(<argument><expr><name><name>aMetrics</name>.<name>height</name></name></expr></argument>,
                               <argument><expr><name><name>borderPadding</name>.<name>top</name></name> + <name>computedHeightLeftOver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">// XXX It's pretty wrong that our bottom border still gets drawn on</comment>
      <comment type="line">// on its own on the last-in-flow, even if we ran out of height</comment>
      <comment type="line">// here. We need GetSkipSides to check whether we ran out of content</comment>
      <comment type="line">// height in the current frame, not whether it's last-in-flow.</comment>
    }</block></else></if>

    <comment type="line">// Don't carry out a bottom margin when our height is fixed.</comment>
    <expr_stmt><expr><call><name><name>aMetrics</name>.<name>mCarriedOutBottomMargin</name>.<name>Zero</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <decl_stmt><decl><type><name>nscoord</name></type> <name>autoHeight</name> <init>= <expr><name><name>aState</name>.<name>mY</name></name> + <name>nonCarriedOutVerticalMargin</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Shrink wrap our height around our contents.</comment>
    <if>if <condition>(<expr><call><name><name>aState</name>.<name>GetFlag</name></name><argument_list>(<argument><expr><name>BRS_ISBOTTOMMARGINROOT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// When we are a bottom-margin root make sure that our last</comment>
      <comment type="line">// childs bottom margin is fully applied.</comment>
      <comment type="line">// Apply the margin only if there's space for it.</comment>
      <if>if <condition>(<expr><name>autoHeight</name> &lt; <name><name>aState</name>.<name>mReflowState</name>.<name>availableHeight</name></name></expr>)</condition><then>
      <block>{
        <comment type="line">// Truncate bottom margin if it doesn't fit to our available height.</comment>
        <expr_stmt><expr><name>autoHeight</name> = <call><name>PR_MIN</name><argument_list>(<argument><expr><name>autoHeight</name> + <call><name><name>aState</name>.<name>mPrevBottomMargin</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>aState</name>.<name>mReflowState</name>.<name>availableHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><call><name><name>aState</name>.<name>GetFlag</name></name><argument_list>(<argument><expr><name>BRS_SPACE_MGR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Include the space manager's state to properly account for the</comment>
      <comment type="line">// bottom margin of any floated elements; e.g., inside a table cell.</comment>
      <decl_stmt><decl><type><name>nscoord</name></type> <name>floatHeight</name> <init>=
        <expr><call><name><name>aState</name>.<name>ClearFloats</name></name><argument_list>(<argument><expr><name>autoHeight</name></expr></argument>, <argument><expr><name>NS_STYLE_CLEAR_LEFT_AND_RIGHT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>autoHeight</name> = <call><name>PR_MAX</name><argument_list>(<argument><expr><name>autoHeight</name></expr></argument>, <argument><expr><name>floatHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Apply min/max values</comment>
    <expr_stmt><expr><name>autoHeight</name> -= <name><name>borderPadding</name>.<name>top</name></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>oldAutoHeight</name> <init>= <expr><name>autoHeight</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aReflowState</name>.<name>ApplyMinMaxConstraints</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr>&amp;<name>autoHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>autoHeight</name> != <name>oldAutoHeight</name></expr>)</condition><then> <block>{
      <comment type="line">// Our min-height or max-height made our height change.  Don't carry out</comment>
      <comment type="line">// our kids' bottom margins.</comment>
      <expr_stmt><expr><call><name><name>aMetrics</name>.<name>mCarriedOutBottomMargin</name>.<name>Zero</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>autoHeight</name> += <name><name>borderPadding</name>.<name>top</name></name> + <name><name>borderPadding</name>.<name>bottom</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aMetrics</name>.<name>height</name></name> = <name>autoHeight</name></expr>;</expr_stmt>
  }</block></else></if>

  <if>if <condition>(<expr><call><name>IS_TRUE_OVERFLOW_CONTAINER</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> &amp;&amp;
      <call><name>NS_FRAME_IS_NOT_COMPLETE</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Overflow containers can only be overflow complete.</comment>
    <comment type="line">// Note that auto height overflow containers have no normal children</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>aMetrics</name>.<name>height</name></name> == 0</expr></argument>, <argument><expr>"overflow containers must be zero-height"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_FRAME_SET_OVERFLOW_INCOMPLETE</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_blocks</name></cpp:ifdef>
  <if>if <condition>(<expr><call><name>CRAZY_WIDTH</name><argument_list>(<argument><expr><name><name>aMetrics</name>.<name>width</name></name></expr></argument>)</argument_list></call> || <call><name>CRAZY_HEIGHT</name><argument_list>(<argument><expr><name><name>aMetrics</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": WARNING: desired:%d,%d\n"</expr></argument>, <argument><expr><name><name>aMetrics</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aMetrics</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsBlockFrame</name>::<name>ComputeCombinedArea</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsHTMLReflowState</name>&amp;</type> <name>aReflowState</name></decl></param>,
                                  <param><decl><type><name>nsHTMLReflowMetrics</name>&amp;</type> <name>aMetrics</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Compute the combined area of our children</comment>
  <comment type="line">// XXX_perf: This can be done incrementally.  It is currently one of</comment>
  <comment type="line">// the things that makes incremental reflow O(N^2).</comment>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>area</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>aMetrics</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aMetrics</name>.<name>height</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>NS_STYLE_OVERFLOW_CLIP</name> != <name><name>aReflowState</name>.<name>mStyleDisplay</name>-&gt;<name>mOverflowX</name></name></expr>)</condition><then> <block>{
    <for>for (<init><decl><type><name>line_iterator</name></type> <name>line</name> <init>= <expr><call><name>begin_lines</name><argument_list>()</argument_list></call></expr></init>, <name>line_end</name> <init>= <expr><call><name>end_lines</name><argument_list>()</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>line</name> != <name>line_end</name></expr>;</condition>
         <incr><expr>++<name>line</name></expr></incr>) <block>{
      <expr_stmt><expr><call><name><name>area</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><call><name><name>line</name>-&gt;<name>GetCombinedArea</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <comment type="line">// Factor the bullet in; normally the bullet will be factored into</comment>
    <comment type="line">// the line-box's combined area. However, if the line is a block</comment>
    <comment type="line">// line then it won't; if there are no lines, it won't. So just</comment>
    <comment type="line">// factor it in anyway (it can't hurt if it was already done).</comment>
    <comment type="line">// XXXldb Can we just fix GetCombinedArea instead?</comment>
    <if>if <condition>(<expr><name>mBullet</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>area</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><call><name><name>mBullet</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_COMBINED_AREA</name></cpp:ifdef>
  <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": ca=%d,%d,%d,%d\n"</expr></argument>, <argument><expr><name><name>area</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>area</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>area</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>area</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>aMetrics</name>.<name>mOverflowArea</name></name> = <name>area</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsBlockFrame</name>::<name>MarkLineDirty</name></name><parameter_list>(<param><decl><type><name>line_iterator</name></type> <name>aLine</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Mark aLine dirty</comment>
  <expr_stmt><expr><call><name><name>aLine</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aLine</name>-&gt;<name>SetInvalidateTextRuns</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>gNoisyReflow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": mark line %p dirty\n"</expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>aLine</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Mark previous line dirty if it's an inline line so that it can</comment>
  <comment type="line">// maybe pullup something from the line just affected.</comment>
  <comment type="line">// XXX We don't need to do this if aPrevLine ends in a break-after...</comment>
  <if>if <condition>(<expr><name>aLine</name> != <call><name><name>mLines</name>.<name>front</name></name><argument_list>()</argument_list></call> &amp;&amp;
      <call><name><name>aLine</name>-&gt;<name>IsInline</name></name><argument_list>()</argument_list></call> &amp;&amp;
      <call><name><name>aLine</name>.<name>prev</name></name><argument_list>()</argument_list></call>-&gt;<call><name>IsInline</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aLine</name>.<name>prev</name></name><argument_list>()</argument_list></call>-&gt;<call><name>MarkDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aLine</name>.<name>prev</name></name><argument_list>()</argument_list></call>-&gt;<call><name>SetInvalidateTextRuns</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if>if <condition>(<expr><name>gNoisyReflow</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": mark prev-line %p dirty\n"</expr></argument>,
             <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>aLine</name>.<name>prev</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsBlockFrame</name>::<name>PrepareResizeReflow</name></name><parameter_list>(<param><decl><type><name>nsBlockReflowState</name>&amp;</type> <name>aState</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// we need to calculate if any part of then block itself </comment>
  <comment type="line">// is impacted by a float (bug 19579)</comment>
  <expr_stmt><expr><call><name><name>aState</name>.<name>GetAvailableSpace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>nsStyleText</name>*</type> <name>styleText</name> <init>= <expr><call><name>GetStyleText</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// See if we can try and avoid marking all the lines as dirty</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>tryAndSkipLines</name> <init>=
      <comment type="line">// There must be no floats.</comment>
      <expr>!<call><name><name>aState</name>.<name>IsImpactedByFloat</name></name><argument_list>()</argument_list></call> &amp;&amp;
      <comment type="line">// The text must be left-aligned.</comment>
      (<name>NS_STYLE_TEXT_ALIGN_LEFT</name> == <name><name>styleText</name>-&gt;<name>mTextAlign</name></name> ||
       (<name>NS_STYLE_TEXT_ALIGN_DEFAULT</name> == <name><name>styleText</name>-&gt;<name>mTextAlign</name></name> &amp;&amp;
        <name>NS_STYLE_DIRECTION_LTR</name> ==
          <name><name>aState</name>.<name>mReflowState</name>.<name>mStyleVisibility</name>-&gt;<name>mDirection</name></name>)) &amp;&amp;
      <comment type="line">// The left content-edge must be a constant distance from the left</comment>
      <comment type="line">// border-edge.</comment>
      <call><name>GetStylePadding</name><argument_list>()</argument_list></call>-&gt;<call><name><name>mPadding</name>.<name>GetLeftUnit</name></name><argument_list>()</argument_list></call> != <name>eStyleUnit_Percent</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>gDisableResizeOpt</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>tryAndSkipLines</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>gNoisyReflow</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<name>tryAndSkipLines</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": marking all lines dirty: availWidth=%d textAlign=%d\n"</expr></argument>,
             <argument><expr><name><name>aState</name>.<name>mReflowState</name>.<name>availableWidth</name></name></expr></argument>,
             <argument><expr><name><name>styleText</name>-&gt;<name>mTextAlign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><name>tryAndSkipLines</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nscoord</name></type> <name>newAvailWidth</name> <init>= <expr><name><name>aState</name>.<name>mReflowState</name>.<name>mComputedBorderPadding</name>.<name>left</name></name> +
                            <call><name><name>aState</name>.<name>mReflowState</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>NS_UNCONSTRAINEDSIZE</name> != <name><name>aState</name>.<name>mReflowState</name>.<name>mComputedBorderPadding</name>.<name>left</name></name> &amp;&amp;
                 <name>NS_UNCONSTRAINEDSIZE</name> != <call><name><name>aState</name>.<name>mReflowState</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"math on NS_UNCONSTRAINEDSIZE"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if>if <condition>(<expr><name>gNoisyReflow</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": trying to avoid marking all lines dirty\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for (<init><decl><type><name>line_iterator</name></type> <name>line</name> <init>= <expr><call><name>begin_lines</name><argument_list>()</argument_list></call></expr></init>, <name>line_end</name> <init>= <expr><call><name>end_lines</name><argument_list>()</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>line</name> != <name>line_end</name></expr>;</condition>
         <incr><expr>++<name>line</name></expr></incr>)
    <block>{
      <comment type="line">// We let child blocks make their own decisions the same</comment>
      <comment type="line">// way we are here.</comment>
      <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call> ||
          <call><name><name>line</name>-&gt;<name>HasFloats</name></name><argument_list>()</argument_list></call> ||
          (<name>line</name> != <call><name><name>mLines</name>.<name>back</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>line</name>-&gt;<name>HasBreakAfter</name></name><argument_list>()</argument_list></call>) ||
          <call><name><name>line</name>-&gt;<name>ResizeReflowOptimizationDisabled</name></name><argument_list>()</argument_list></call> ||
          <call><name><name>line</name>-&gt;<name>IsImpactedByFloat</name></name><argument_list>()</argument_list></call> ||
          (<call><name><name>line</name>-&gt;<name>mBounds</name>.<name>XMost</name></name><argument_list>()</argument_list></call> &gt; <name>newAvailWidth</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REALLY_NOISY_REFLOW</name></cpp:ifdef>
      <if>if <condition>(<expr>!<call><name><name>line</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"PrepareResizeReflow thinks line %p is %simpacted by floats\n"</expr></argument>, 
               <argument><expr><call><name><name>line</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>line</name>-&gt;<name>IsImpactedByFloat</name></name><argument_list>()</argument_list></call> ? "" : "not "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      <if>if <condition>(<expr><name>gNoisyReflow</name> &amp;&amp; !<call><name><name>line</name>-&gt;<name>IsDirty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"skipped: line=%p next=%p %s %s%s%s breakTypeBefore/After=%d/%d xmost=%d\n"</expr></argument>,
           <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>line</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr>(<call><name><name>line</name>.<name>next</name></name><argument_list>()</argument_list></call> != <call><name>end_lines</name><argument_list>()</argument_list></call> ? <call><name><name>line</name>.<name>next</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call> : <name>nsnull</name>)</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name><name>line</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call> ? "block" : "inline"</expr></argument>,
           <argument><expr><call><name><name>line</name>-&gt;<name>HasBreakAfter</name></name><argument_list>()</argument_list></call> ? "has-break-after " : ""</expr></argument>,
           <argument><expr><call><name><name>line</name>-&gt;<name>HasFloats</name></name><argument_list>()</argument_list></call> ? "has-floats " : ""</expr></argument>,
           <argument><expr><call><name><name>line</name>-&gt;<name>IsImpactedByFloat</name></name><argument_list>()</argument_list></call> ? "impacted " : ""</expr></argument>,
           <argument><expr><call><name><name>line</name>-&gt;<name>GetBreakTypeBefore</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>line</name>-&gt;<name>GetBreakTypeAfter</name></name><argument_list>()</argument_list></call></expr></argument>,
           <argument><expr><call><name><name>line</name>-&gt;<name>mBounds</name>.<name>XMost</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></for>
  }</block></then>
  <else>else <block>{
    <comment type="line">// Mark everything dirty</comment>
    <for>for (<init><decl><type><name>line_iterator</name></type> <name>line</name> <init>= <expr><call><name>begin_lines</name><argument_list>()</argument_list></call></expr></init>, <name>line_end</name> <init>= <expr><call><name>end_lines</name><argument_list>()</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>line</name> != <name>line_end</name></expr>;</condition>
         <incr><expr>++<name>line</name></expr></incr>)
    <block>{
      <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="line">//----------------------------------------</comment>

<function><type><name><name>nsBlockFrame</name>::<name>line_iterator</name></name></type>
<name><name>nsBlockFrame</name>::<name>FindLineFor</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>, <argument><expr>"why pass a null frame?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>line_iterator</name></type> <name>line</name> <init>= <expr><call><name>begin_lines</name><argument_list>()</argument_list></call></expr></init>,
                <name>line_end</name> <init>= <expr><call><name>end_lines</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for ( <init>;</init> <condition><expr><name>line</name> != <name>line_end</name></expr>;</condition> <incr><expr>++<name>line</name></expr></incr>) <block>{
    <comment type="line">// If the target frame is in-flow, and this line contains the it,</comment>
    <comment type="line">// then we've found our line.</comment>
    <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>Contains</name></name><argument_list>(<argument><expr><name>aFrame</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>line</name></expr>;</return></then></if>

    <comment type="line">// If the target frame is floated, and this line contains the</comment>
    <comment type="line">// float's placeholder, then we've found our line.</comment>
    <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>HasFloats</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <for>for (<init><decl><type><name>nsFloatCache</name> *</type><name>fc</name> <init>= <expr><call><name><name>line</name>-&gt;<name>GetFirstFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
           <condition><expr><name>fc</name> != <name>nsnull</name></expr>;</condition>
           <incr><expr><name>fc</name> = <call><name><name>fc</name>-&gt;<name>Next</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><name>aFrame</name> == <call><name><name>fc</name>-&gt;<name>mPlaceholder</name>-&gt;<name>GetOutOfFlowFrame</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
          <return>return <expr><name>line</name></expr>;</return></then></if>
      }</block></for>
    }</block></then></if>
  }</block></for>

  <return>return <expr><name>line_end</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Propagate reflow "damage" from from earlier lines to the current
 * line.  The reflow damage comes from the following sources:
 *  1. The regions of float damage remembered during reflow.
 *  2. The combination of nonzero |aDeltaY| and any impact by a float,
 *     either the previous reflow or now.
 *
 * When entering this function, |aLine| is still at its old position and
 * |aDeltaY| indicates how much it will later be slid (assuming it
 * doesn't get marked dirty and reflowed entirely).
 */</comment>
<function><type><name>void</name></type>
<name><name>nsBlockFrame</name>::<name>PropagateFloatDamage</name></name><parameter_list>(<param><decl><type><name>nsBlockReflowState</name>&amp;</type> <name>aState</name></decl></param>,
                                   <param><decl><type><name>nsLineBox</name>*</type> <name>aLine</name></decl></param>,
                                   <param><decl><type><name>nscoord</name></type> <name>aDeltaY</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsSpaceManager</name> *</type><name>spaceManager</name> <init>= <expr><name><name>aState</name>.<name>mReflowState</name>.<name>mSpaceManager</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>(<name><name>aState</name>.<name>mReflowState</name>.<name>parentReflowState</name></name> &amp;&amp;
                <name><name>aState</name>.<name>mReflowState</name>.<name>parentReflowState</name>-&gt;<name>mSpaceManager</name></name> == <name>spaceManager</name>) ||
                <name><name>aState</name>.<name>mReflowState</name>.<name>mBlockDelta</name></name> == 0</expr></argument>, <argument><expr>"Bad block delta passed in"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Check to see if there are any floats; if there aren't, there can't</comment>
  <comment type="line">// be any float damage</comment>
  <if>if <condition>(<expr>!<call><name><name>spaceManager</name>-&gt;<name>HasAnyFloats</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="line">// Check the damage region recorded in the float damage.</comment>
  <if>if <condition>(<expr><call><name><name>spaceManager</name>-&gt;<name>HasFloatDamage</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// Need to check mBounds *and* mCombinedArea to find intersections </comment>
    <comment type="line">// with aLine's floats</comment>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>lineYA</name> <init>= <expr><name><name>aLine</name>-&gt;<name>mBounds</name>.<name>y</name></name> + <name>aDeltaY</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>lineYB</name> <init>= <expr><name>lineYA</name> + <name><name>aLine</name>-&gt;<name>mBounds</name>.<name>height</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>lineYCombinedA</name> <init>= <expr><call><name><name>aLine</name>-&gt;<name>GetCombinedArea</name></name><argument_list>()</argument_list></call>.<name>y</name> + <name>aDeltaY</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nscoord</name></type> <name>lineYCombinedB</name> <init>= <expr><name>lineYCombinedA</name> + <call><name><name>aLine</name>-&gt;<name>GetCombinedArea</name></name><argument_list>()</argument_list></call>.<name>height</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>spaceManager</name>-&gt;<name>IntersectsDamage</name></name><argument_list>(<argument><expr><name>lineYA</name></expr></argument>, <argument><expr><name>lineYB</name></expr></argument>)</argument_list></call> ||
        <call><name><name>spaceManager</name>-&gt;<name>IntersectsDamage</name></name><argument_list>(<argument><expr><name>lineYCombinedA</name></expr></argument>, <argument><expr><name>lineYCombinedB</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>aLine</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Check if the line is moving relative to the space manager</comment>
  <if>if <condition>(<expr><name>aDeltaY</name> + <name><name>aState</name>.<name>mReflowState</name>.<name>mBlockDelta</name></name> != 0</expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name><name>aLine</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// Unconditionally reflow sliding blocks; we only really need to reflow</comment>
      <comment type="line">// if there's a float impacting this block, but the current space manager</comment>
      <comment type="line">// makes it difficult to check that.  Therefore, we let the child block</comment>
      <comment type="line">// decide what it needs to reflow.</comment>
      <expr_stmt><expr><call><name><name>aLine</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <comment type="line">// Note that this check will become incorrect once bug 25888 is fixed</comment>
      <comment type="line">// because we are only checking the top of the line</comment>
      <expr_stmt><expr><call><name><name>aState</name>.<name>GetAvailableSpace</name></name><argument_list>(<argument><expr><name><name>aLine</name>-&gt;<name>mBounds</name>.<name>y</name></name> + <name>aDeltaY</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>wasImpactedByFloat</name> <init>= <expr><call><name><name>aLine</name>-&gt;<name>IsImpactedByFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>isImpactedByFloat</name> <init>= <expr><call><name><name>aState</name>.<name>IsImpactedByFloat</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REALLY_NOISY_REFLOW</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"nsBlockFrame::PropagateFloatDamage %p was = %d, is=%d\n"</expr></argument>, 
       <argument><expr><name>this</name></expr></argument>, <argument><expr><name>wasImpactedByFloat</name></expr></argument>, <argument><expr><name>isImpactedByFloat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="line">// Mark the line dirty if it was or is affected by a float</comment>
      <comment type="line">// We actually only really need to reflow if the amount of impact</comment>
      <comment type="line">// changes, but that's not straightforward to check</comment>
      <if>if <condition>(<expr><name>wasImpactedByFloat</name> || <name>isImpactedByFloat</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aLine</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
  }</block></then></if>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlaceFrameView</name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFrame</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>LineHasClear</name><parameter_list>(<param><decl><type><name>nsLineBox</name>*</type> <name>aLine</name></decl></param>)</parameter_list> <block>{
  <return>return <expr><call><name><name>aLine</name>-&gt;<name>GetBreakTypeBefore</name></name><argument_list>()</argument_list></call> || <call><name><name>aLine</name>-&gt;<name>HasFloatBreakAfter</name></name><argument_list>()</argument_list></call>
    || (<call><name><name>aLine</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call> &amp;&amp; (<call><name><name>aLine</name>-&gt;<name>mFirstChild</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_BLOCK_HAS_CLEAR_CHILDREN</name>))</expr>;</return>
}</block></function>


<comment type="block" format="doxygen">/**
 * Reparent a whole list of floats from aOldParent to this block.  The
 * floats might be taken from aOldParent's overflow list. They will be
 * removed from the list. They end up appended to our mFloats list.
 */</comment>
<function><type><name>void</name></type>
<name><name>nsBlockFrame</name>::<name>ReparentFloats</name></name><parameter_list>(<param><decl><type><name>nsIFrame</name>*</type> <name>aFirstFrame</name></decl></param>,
                             <param><decl><type><name>nsBlockFrame</name>*</type> <name>aOldParent</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aFromOverflow</name></decl></param>,
                             <param><decl><type><name>PRBool</name></type> <name>aReparentSiblings</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>nsFrameList</name></type> <name>list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>tail</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aOldParent</name>-&gt;<name>CollectFloats</name></name><argument_list>(<argument><expr><name>aFirstFrame</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr>&amp;<name>tail</name></expr></argument>, <argument><expr><name>aFromOverflow</name></expr></argument>, <argument><expr><name>aReparentSiblings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name><name>list</name>.<name>NotEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <for>for (<init><decl><type><name>nsIFrame</name>*</type> <name>f</name> <init>= <expr><call><name><name>list</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> = <call><name><name>f</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
      <expr_stmt><expr><call><name>ReparentFrame</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>aOldParent</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name><name>mFloats</name>.<name>AppendFrames</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><call><name><name>list</name>.<name>FirstChild</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>DumpLine</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsBlockReflowState</name>&amp;</type> <name>aState</name></decl></param>, <param><decl><type><name>nsLineBox</name>*</type> <name>aLine</name></decl></param>,
                     <param><decl><type><name>nscoord</name></type> <name>aDeltaY</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aDeltaIndent</name></decl></param>)</parameter_list> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name><name>nsBlockFrame</name>::<name>gNoisyReflow</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>lca</name><argument_list>(<argument><expr><call><name><name>aLine</name>-&gt;<name>GetCombinedArea</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>nsBlockFrame</name>::<name>IndentBy</name></name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name><name>nsBlockFrame</name>::<name>gNoiseIndent</name></name> + <name>aDeltaIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"line=%p mY=%d dirty=%s oldBounds={%d,%d,%d,%d} oldCombinedArea={%d,%d,%d,%d} deltaY=%d mPrevBottomMargin=%d childCount=%d\n"</expr></argument>,
           <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aLine</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>aState</name>.<name>mY</name></name></expr></argument>,
           <argument><expr><call><name><name>aLine</name>-&gt;<name>IsDirty</name></name><argument_list>()</argument_list></call> ? "yes" : "no"</expr></argument>,
           <argument><expr><name><name>aLine</name>-&gt;<name>mBounds</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aLine</name>-&gt;<name>mBounds</name>.<name>y</name></name></expr></argument>,
           <argument><expr><name><name>aLine</name>-&gt;<name>mBounds</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aLine</name>-&gt;<name>mBounds</name>.<name>height</name></name></expr></argument>,
           <argument><expr><name><name>lca</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>lca</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>lca</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>lca</name>.<name>height</name></name></expr></argument>,
           <argument><expr><name>aDeltaY</name></expr></argument>, <argument><expr><call><name><name>aState</name>.<name>mPrevBottomMargin</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>aLine</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block" format="doxygen">/**
 * Reflow the dirty lines
 */</comment>
<function><type><name>nsresult</name></type>
<name><name>nsBlockFrame</name>::<name>ReflowDirtyLines</name></name><parameter_list>(<param><decl><type><name>nsBlockReflowState</name>&amp;</type> <name>aState</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>keepGoing</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>repositionViews</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt> <comment type="line">// should we really need this?</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>foundAnyClears</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>willReflowAgain</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>gNoisyReflow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": reflowing dirty lines"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" computedWidth=%d\n"</expr></argument>, <argument><expr><call><name><name>aState</name>.<name>mReflowState</name>.<name>ComputedWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <function_decl><type><name>AutoNoisyIndenter</name></type> <name>indent</name><parameter_list>(<param><decl><type><name>gNoisyReflow</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>selfDirty</name> <init>= <expr>(<call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_IS_DIRTY</name>) ||
                     (<name><name>aState</name>.<name>mReflowState</name>.<name>mFlags</name>.<name>mVResize</name></name> &amp;&amp;
                      (<call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_CONTAINS_RELATIVE_HEIGHT</name>))</expr></init></decl>;</decl_stmt>
  
    <comment type="line">// the amount by which we will slide the current line if it is not</comment>
    <comment type="line">// dirty</comment>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>deltaY</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="line">// whether we did NOT reflow the previous line and thus we need to</comment>
    <comment type="line">// recompute the carried out margin before the line if we want to</comment>
    <comment type="line">// reflow it or if its previous margin is dirty</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>needToRecoverState</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>reflowedFloat</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>lastLineMovedUp</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <comment type="line">// We save up information about BR-clearance here</comment>
  <decl_stmt><decl><type><name>PRUint8</name></type> <name>inlineFloatBreakType</name> <init>= <expr><name>NS_STYLE_CLEAR_NONE</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>line_iterator</name></type> <name>line</name> <init>= <expr><call><name>begin_lines</name><argument_list>()</argument_list></call></expr></init>, <name>line_end</name> <init>= <expr><call><name>end_lines</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Reflow the lines that are already ours</comment>
  <for>for ( <init>;</init> <condition><expr><name>line</name> != <name>line_end</name></expr>;</condition> <incr><expr>++<name>line</name></expr>, <expr><call><name><name>aState</name>.<name>AdvanceToNextLine</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <expr_stmt><expr><call><name>DumpLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>deltaY</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <function_decl><type><name>AutoNoisyIndenter</name></type> <name>indent2</name><parameter_list>(<param><decl><type><name>gNoisyReflow</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>selfDirty</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// This really sucks, but we have to look inside any blocks that have clear</comment>
    <comment type="line">// elements inside them.</comment>
    <comment type="line">// XXX what can we do smarter here?</comment>
    <if>if <condition>(<expr>!<call><name><name>line</name>-&gt;<name>IsDirty</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>line</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call> &amp;&amp;
        (<call><name><name>line</name>-&gt;<name>mFirstChild</name>-&gt;<name>GetStateBits</name></name><argument_list>()</argument_list></call> &amp; <name>NS_BLOCK_HAS_CLEAR_CHILDREN</name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// We have to reflow the line if it's a block whose clearance</comment>
    <comment type="line">// might have changed, so detect that.</comment>
    <if>if <condition>(<expr>!<call><name><name>line</name>-&gt;<name>IsDirty</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>line</name>-&gt;<name>GetBreakTypeBefore</name></name><argument_list>()</argument_list></call> != <name>NS_STYLE_CLEAR_NONE</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nscoord</name></type> <name>curY</name> <init>= <expr><name><name>aState</name>.<name>mY</name></name></expr></init></decl>;</decl_stmt>
      <comment type="line">// See where we would be after applying any clearance due to</comment>
      <comment type="line">// BRs.</comment>
      <if>if <condition>(<expr><name>inlineFloatBreakType</name> != <name>NS_STYLE_CLEAR_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>curY</name> = <call><name><name>aState</name>.<name>ClearFloats</name></name><argument_list>(<argument><expr><name>curY</name></expr></argument>, <argument><expr><name>inlineFloatBreakType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <decl_stmt><decl><type><name>nscoord</name></type> <name>newY</name> <init>= <expr><call><name><name>aState</name>.<name>ClearFloats</name></name><argument_list>(<argument><expr><name>curY</name></expr></argument>, <argument><expr><call><name><name>line</name>-&gt;<name>GetBreakTypeBefore</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      
      <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>HasClearance</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// Reflow the line if it might not have clearance anymore.</comment>
        <if>if <condition>(<expr><name>newY</name> == <name>curY</name>
            <comment type="line">// aState.mY is the clearance point which should be the</comment>
            <comment type="line">// top border-edge of the block frame. If sliding the</comment>
            <comment type="line">// block by deltaY isn't going to put it in the predicted</comment>
            <comment type="line">// position, then we'd better reflow the line.</comment>
            || <name>newY</name> != <name><name>line</name>-&gt;<name>mBounds</name>.<name>y</name></name> + <name>deltaY</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then> <else>else <block>{
        <comment type="line">// Reflow the line if the line might have clearance now.</comment>
        <if>if <condition>(<expr><name>curY</name> != <name>newY</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></else></if>
    }</block></then></if>

    <comment type="line">// We might have to reflow a line that is after a clearing BR.</comment>
    <if>if <condition>(<expr><name>inlineFloatBreakType</name> != <name>NS_STYLE_CLEAR_NONE</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>aState</name>.<name>mY</name></name> = <call><name><name>aState</name>.<name>ClearFloats</name></name><argument_list>(<argument><expr><name><name>aState</name>.<name>mY</name></name></expr></argument>, <argument><expr><name>inlineFloatBreakType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>aState</name>.<name>mY</name></name> != <name><name>line</name>-&gt;<name>mBounds</name>.<name>y</name></name> + <name>deltaY</name></expr>)</condition><then> <block>{
        <comment type="line">// SlideLine is not going to put the line where the clearance</comment>
        <comment type="line">// put it. Reflow the line to be sure.</comment>
        <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>inlineFloatBreakType</name> = <name>NS_STYLE_CLEAR_NONE</name></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRBool</name></type> <name>previousMarginWasDirty</name> <init>= <expr><call><name><name>line</name>-&gt;<name>IsPreviousMarginDirty</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>previousMarginWasDirty</name></expr>)</condition><then> <block>{
      <comment type="line">// If the previous margin is dirty, reflow the current line</comment>
      <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>line</name>-&gt;<name>ClearPreviousMarginDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>mBounds</name>.<name>YMost</name></name><argument_list>()</argument_list></call> + <name>deltaY</name> &gt; <name><name>aState</name>.<name>mBottomEdge</name></name></expr>)</condition><then> <block>{
      <comment type="line">// Lines that aren't dirty but get slid past our height constraint must</comment>
      <comment type="line">// be reflowed.</comment>
      <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <if>if <condition>(<expr>!<call><name><name>line</name>-&gt;<name>IsDirty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// See if there's any reflow damage that requires that we mark the</comment>
      <comment type="line">// line dirty.</comment>
      <expr_stmt><expr><call><name>PropagateFloatDamage</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>deltaY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>needToRecoverState</name> &amp;&amp; <call><name><name>line</name>-&gt;<name>IsDirty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// We need to reconstruct the bottom margin only if we didn't</comment>
      <comment type="line">// reflow the previous line and we do need to reflow (or repair</comment>
      <comment type="line">// the top position of) the next line.</comment>
      <expr_stmt><expr><call><name><name>aState</name>.<name>ReconstructMarginAbove</name></name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>needToRecoverState</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>needToRecoverState</name> = <name>PR_FALSE</name></expr>;</expr_stmt>

      <comment type="line">// Update aState.mPrevChild as if we had reflowed all of the frames in</comment>
      <comment type="line">// this line.  This is expensive in some cases, since it requires</comment>
      <comment type="line">// walking |GetNextSibling|.</comment>
      <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>IsDirty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name><name>aState</name>.<name>mPrevChild</name></name> = <call><name><name>line</name>.<name>prev</name></name><argument_list>()</argument_list></call>-&gt;<call><name>LastChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <comment type="line">// Now repair the line and update |aState.mY| by calling</comment>
    <comment type="line">// |ReflowLine| or |SlideLine|.</comment>
    <comment type="line">// If we're going to reflow everything again, then no need to reflow</comment>
    <comment type="line">// the dirty line ... unless the line has floats, in which case we'd</comment>
    <comment type="line">// better reflow it now to refresh its float cache, which may contain</comment>
    <comment type="line">// dangling frame pointers! Ugh! This reflow of the line may be</comment>
    <comment type="line">// incorrect because we skipped reflowing previous lines (e.g., floats</comment>
    <comment type="line">// may be placed incorrectly), but that's OK because we'll mark the</comment>
    <comment type="line">// line dirty below under "if (aState.mReflowState.mDiscoveredClearance..."</comment>
    <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>IsDirty</name></name><argument_list>()</argument_list></call> &amp;&amp; (<call><name><name>line</name>-&gt;<name>HasFloats</name></name><argument_list>()</argument_list></call> || !<name>willReflowAgain</name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>lastLineMovedUp</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>PRBool</name></type> <name>maybeReflowingForFirstTime</name> <init>=
        <expr><name><name>line</name>-&gt;<name>mBounds</name>.<name>x</name></name> == 0 &amp;&amp; <name><name>line</name>-&gt;<name>mBounds</name>.<name>y</name></name> == 0 &amp;&amp;
        <name><name>line</name>-&gt;<name>mBounds</name>.<name>width</name></name> == 0 &amp;&amp; <name><name>line</name>-&gt;<name>mBounds</name>.<name>height</name></name> == 0</expr></init></decl>;</decl_stmt>

      <comment type="line">// Compute the dirty lines "before" YMost, after factoring in</comment>
      <comment type="line">// the running deltaY value - the running value is implicit in</comment>
      <comment type="line">// aState.mY.</comment>
      <decl_stmt><decl><type><name>nscoord</name></type> <name>oldY</name> <init>= <expr><name><name>line</name>-&gt;<name>mBounds</name>.<name>y</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nscoord</name></type> <name>oldYMost</name> <init>= <expr><call><name><name>line</name>-&gt;<name>mBounds</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="line">// Reflow the dirty line. If it's an incremental reflow, then force</comment>
      <comment type="line">// it to invalidate the dirty area if necessary</comment>
      <expr_stmt><expr><name>rv</name> = <call><name>ReflowLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr>&amp;<name>keepGoing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>aState</name>.<name>mReflowState</name>.<name>mDiscoveredClearance</name></name> &amp;&amp;
          *<name><name>aState</name>.<name>mReflowState</name>.<name>mDiscoveredClearance</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>line</name>-&gt;<name>MarkDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>willReflowAgain</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        <comment type="line">// Note that once we've entered this state, every line that gets here</comment>
        <comment type="line">// (e.g. because it has floats) gets marked dirty and reflowed again.</comment>
        <comment type="line">// in the next pass. This is important, see above.</comment>
      }</block></then></if>

      <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>HasFloats</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>reflowedFloat</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>

      <if>if <condition>(<expr>!<name>keepGoing</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>DumpLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>deltaY</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>0 == <call><name><name>line</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>DeleteLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>line_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      }</block></then></if>

      <comment type="line">// Test to see whether the margin that should be carried out</comment>
      <comment type="line">// to the next line (NL) might have changed. In ReflowBlockFrame</comment>
      <comment type="line">// we call nextLine-&gt;MarkPreviousMarginDirty if the block's</comment>
      <comment type="line">// actual carried-out bottom margin changed. So here we only</comment>
      <comment type="line">// need to worry about the following effects:</comment>
      <comment type="line">// 1) the line was just created, and it might now be blocking</comment>
      <comment type="line">// a carried-out bottom margin from previous lines that</comment>
      <comment type="line">// used to reach NL from reaching NL</comment>
      <comment type="line">// 2) the line used to be empty, and is now not empty,</comment>
      <comment type="line">// thus blocking a carried-out bottom margin from previous lines</comment>
      <comment type="line">// that used to reach NL from reaching NL</comment>
      <comment type="line">// 3) the line wasn't empty, but now is, so a carried-out</comment>
      <comment type="line">// bottom margin from previous lines that didn't used to reach NL</comment>
      <comment type="line">// now does</comment>
      <comment type="line">// 4) the line might have changed in a way that affects NL's</comment>
      <comment type="line">// ShouldApplyTopMargin decision. The three things that matter</comment>
      <comment type="line">// are the line's emptiness, its adjacency to the top of the block,</comment>
      <comment type="line">// and whether it has clearance (the latter only matters if the block</comment>
      <comment type="line">// was and is adjacent to the top and empty).</comment>
      <comment type="line">//</comment>
      <comment type="line">// If the line is empty now, we can't reliably tell if the line was empty</comment>
      <comment type="line">// before, so we just assume it was and do nextLine-&gt;MarkPreviousMarginDirty.</comment>
      <comment type="line">// This means the checks in 4) are redundant; if the line is empty now</comment>
      <comment type="line">// we don't need to check 4), but if the line is not empty now and we're sure</comment>
      <comment type="line">// it wasn't empty before, any adjacency and clearance changes are irrelevant</comment>
      <comment type="line">// to the result of nextLine-&gt;ShouldApplyTopMargin.</comment>
      <if>if <condition>(<expr><call><name><name>line</name>.<name>next</name></name><argument_list>()</argument_list></call> != <call><name>end_lines</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>PRBool</name></type> <name>maybeWasEmpty</name> <init>= <expr><name>oldY</name> == <call><name><name>line</name>.<name>next</name></name><argument_list>()</argument_list></call>-&gt;<name><name>mBounds</name>.<name>y</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRBool</name></type> <name>isEmpty</name> <init>= <expr><name><name>line</name>-&gt;<name>mBounds</name>.<name>height</name></name> == 0 &amp;&amp; <call><name><name>line</name>-&gt;<name>CachedIsEmpty</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>maybeReflowingForFirstTime</name> <comment type="block">/*1*/</comment> ||
            (<name>isEmpty</name> || <name>maybeWasEmpty</name>)</expr> <comment type="block">/*2/3/4*/</comment>)</condition><then> <block>{
          <expr_stmt><expr><call><name><name>line</name>.<name>next</name></name><argument_list>()</argument_list></call>-&gt;<call><name>MarkPreviousMarginDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <comment type="line">// since it's marked dirty, nobody will care about |deltaY|</comment>
        }</block></then></if>
      }</block></then></if>

      <comment type="line">// If the line was just reflowed for the first time, then its</comment>
      <comment type="line">// old mBounds cannot be trusted so this deltaY computation is</comment>
      <comment type="line">// bogus. But that's OK because we just did</comment>
      <comment type="line">// MarkPreviousMarginDirty on the next line which will force it</comment>
      <comment type="line">// to be reflowed, so this computation of deltaY will not be</comment>
      <comment type="line">// used.</comment>
      <expr_stmt><expr><name>deltaY</name> = <call><name><name>line</name>-&gt;<name>mBounds</name>.<name>YMost</name></name><argument_list>()</argument_list></call> - <name>oldYMost</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><call><name><name>aState</name>.<name>mOverflowTracker</name>.<name>Skip</name></name><argument_list>(<argument><expr><name><name>line</name>-&gt;<name>mFirstChild</name></name></expr></argument>, <argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Nop except for blocks (we don't create overflow container</comment>
        <comment type="line">// continuations for any inlines atm), so only checking mFirstChild</comment>
        <comment type="line">// is enough</comment>

      <expr_stmt><expr><name>lastLineMovedUp</name> = <name>deltaY</name> &lt; 0</expr>;</expr_stmt>

      <if>if <condition>(<expr><name>deltaY</name> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>SlideLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>deltaY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>repositionViews</name> = <name>PR_TRUE</name></expr>;</expr_stmt></else></if>

      <if>if <condition>(<expr><name>willReflowAgain</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name><name>line</name>-&gt;<name>HasFloats</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Possibly stale float cache here!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// If we're going to reflow everything again, and this line has no</comment>
        <comment type="line">// cached floats, then there is no need to recover float state. The line</comment>
        <comment type="line">// may be a block that contains other lines with floats, but in that</comment>
        <comment type="line">// case RecoverStateFrom would only add floats to the space manager.</comment>
        <comment type="line">// We don't need to do that because everything's going to get reflowed</comment>
        <comment type="line">// again "for real". Calling RecoverStateFrom in this situation could</comment>
        <comment type="line">// be lethal because the block's descendant lines may have float</comment>
        <comment type="line">// caches containing dangling frame pointers. Ugh!</comment>
      }</block></then> <else>else <block>{
        <comment type="line">// XXX EVIL O(N^2) EVIL</comment>
        <expr_stmt><expr><call><name><name>aState</name>.<name>RecoverStateFrom</name></name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>deltaY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>

      <comment type="line">// Keep mY up to date in case we're propagating reflow damage</comment>
      <comment type="line">// and also because our final height may depend on it. If the</comment>
      <comment type="line">// line is inlines, then only update mY if the line is not</comment>
      <comment type="line">// empty, because that's what PlaceLine does. (Empty blocks may</comment>
      <comment type="line">// want to update mY, e.g. if they have clearance.)</comment>
      <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call> || !<call><name><name>line</name>-&gt;<name>CachedIsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>aState</name>.<name>mY</name></name> = <call><name><name>line</name>-&gt;<name>mBounds</name>.<name>YMost</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <expr_stmt><expr><name>needToRecoverState</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="line">// Record if we need to clear floats before reflowing the next</comment>
    <comment type="line">// line. Note that inlineFloatBreakType will be handled and</comment>
    <comment type="line">// cleared before the next line is processed, so there is no</comment>
    <comment type="line">// need to combine break types here.</comment>
    <if>if <condition>(<expr><call><name><name>line</name>-&gt;<name>HasFloatBreakAfter</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>inlineFloatBreakType</name> = <call><name><name>line</name>-&gt;<name>GetBreakTypeAfter</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>LineHasClear</name><argument_list>(<argument><expr><call><name><name>line</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>foundAnyClears</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>DumpLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>deltaY</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// Handle BR-clearance from the last line of the block</comment>
  <if>if <condition>(<expr><name>inlineFloatBreakType</name> != <name>NS_STYLE_CLEAR_NONE</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>aState</name>.<name>mY</name></name> = <call><name><name>aState</name>.<name>ClearFloats</name></name><argument_list>(<argument><expr><name><name>aState</name>.<name>mY</name></name></expr></argument>, <argument><expr><name>inlineFloatBreakType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>needToRecoverState</name></expr>)</condition><then> <block>{
    <comment type="line">// Is this expensive?</comment>
    <expr_stmt><expr><call><name><name>aState</name>.<name>ReconstructMarginAbove</name></name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Update aState.mPrevChild as if we had reflowed all of the frames in</comment>
    <comment type="line">// the last line.  This is expensive in some cases, since it requires</comment>
    <comment type="line">// walking |GetNextSibling|.</comment>
    <expr_stmt><expr><name><name>aState</name>.<name>mPrevChild</name></name> = <call><name><name>line</name>.<name>prev</name></name><argument_list>()</argument_list></call>-&gt;<call><name>LastChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// Should we really have to do this?</comment>
  <if>if <condition>(<expr><name>repositionViews</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>::<name>PlaceFrameView</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="line">// We can skip trying to pull up the next line if there is no next</comment>
  <comment type="line">// in flow or we were told not to or we know it will be futile, i.e.,</comment>
  <comment type="line">// -- the next in flow is not changing</comment>
  <comment type="line">// -- and we cannot have added more space for its first line to be</comment>
  <comment type="line">// pulled up into,</comment>
  <comment type="line">// -- it's an incremental reflow of a descendant</comment>
  <comment type="line">// -- and we didn't reflow any floats (so the available space</comment>
  <comment type="line">// didn't change)</comment>
  <comment type="line">// -- my chain of next-in-flows either has no first line, or its first</comment>
  <comment type="line">// line isn't dirty.</comment>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>skipPull</name> <init>= <expr><name>willReflowAgain</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>aState</name>.<name>mNextInFlow</name></name> &amp;&amp;
      (<name><name>aState</name>.<name>mReflowState</name>.<name>mFlags</name>.<name>mNextInFlowUntouched</name></name> &amp;&amp;
       !<name>lastLineMovedUp</name> &amp;&amp; 
       !(<call><name>GetStateBits</name><argument_list>()</argument_list></call> &amp; <name>NS_FRAME_IS_DIRTY</name>) &amp;&amp;
       !<name>reflowedFloat</name>)</expr>)</condition><then> <block>{
    <comment type="line">// We'll place lineIter at the last line of this block, so that </comment>
    <comment type="line">// nsBlockInFlowLineIterator::Next() will take us to the first</comment>
    <comment type="line">// line of my next-in-flow-chain.  (But first, check that I </comment>
    <comment type="line">// have any lines -- if I don't, just bail out of this</comment>
    <comment type="line">// optimization.) </comment>
    <decl_stmt><decl><type><name>line_iterator</name></type> <name>lineIter</name> <init>= <expr><call><name><name>this</name>-&gt;<name>end_lines</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>lineIter</name> != <call><name><name>this</name>-&gt;<name>begin_lines</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>lineIter</name>--</expr>;</expr_stmt> <comment type="line">// I have lines; step back from dummy iterator to last line.</comment>
      <function_decl><type><name>nsBlockInFlowLineIterator</name></type> <name>bifLineIter</name><parameter_list>(<param><decl><type><name>this</name></type></decl></param>, <param><decl><type><name>lineIter</name></type></decl></param>, <param><decl><type><name>PR_FALSE</name></type></decl></param>)</parameter_list>;</function_decl>

      <comment type="line">// Check for next-in-flow-chain's first line.</comment>
      <comment type="line">// (First, see if there is such a line, and second, see if it's clean)</comment>
      <if>if <condition>(<expr>!<call><name><name>bifLineIter</name>.<name>Next</name></name><argument_list>()</argument_list></call> ||                
          !<call><name><name>bifLineIter</name>.<name>GetLine</name></name><argument_list>()</argument_list></call>-&gt;<call><name>IsDirty</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>IS_TRUE_OVERFLOW_CONTAINER</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mNextInFlow</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><call><name>NS_FRAME_SET_OVERFLOW_INCOMPLETE</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
          <expr_stmt><expr><call><name>NS_FRAME_SET_INCOMPLETE</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <expr_stmt><expr><name>skipPull</name>=<name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  
  <if>if <condition>(<expr>!<name>skipPull</name> &amp;&amp; <name><name>aState</name>.<name>mNextInFlow</name></name></expr>)</condition><then> <block>{
    <comment type="line">// Pull data from a next-in-flow if there's still room for more</comment>
    <comment type="line">// content here.</comment>
    <while>while <condition>(<expr><name>keepGoing</name> &amp;&amp; (<name>nsnull</name> != <name><name>aState</name>.<name>mNextInFlow</name></name>)</expr>)</condition> <block>{
      <comment type="line">// Grab first line from our next-in-flow</comment>
      <decl_stmt><decl><type><name>nsBlockFrame</name>*</type> <name>nextInFlow</name> <init>= <expr><name><name>aState</name>.<name>mNextInFlow</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>line_iterator</name></type> <name>nifLine</name> <init>= <expr><call><name><name>nextInFlow</name>-&gt;<name>begin_lines</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsLineBox</name> *</type><name>toMove</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRBool</name></type> <name>collectOverflowFloats</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>nifLine</name> != <call><name><name>nextInFlow</name>-&gt;<name>end_lines</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>HandleOverflowPlaceholdersOnPulledLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>nifLine</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// go around again in case the line was deleted</comment>
          <continue>continue;</continue>
        }</block></then></if>
        <expr_stmt><expr><name>toMove</name> = <name>nifLine</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>nextInFlow</name>-&gt;<name>mLines</name>.<name>erase</name></name><argument_list>(<argument><expr><name>nifLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>collectOverflowFloats</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <comment type="line">// Grab an overflow line if there are any</comment>
        <decl_stmt><decl><type><name>nsLineList</name>*</type> <name>overflowLines</name> <init>= <expr><call><name><name>nextInFlow</name>-&gt;<name>GetOverflowLines</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>overflowLines</name> &amp;&amp;
            <call><name>HandleOverflowPlaceholdersOnPulledLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><call><name><name>overflowLines</name>-&gt;<name>front</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// go around again in case the line was deleted</comment>
          <continue>continue;</continue>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>overflowLines</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>aState</name>.<name>mNextInFlow</name></name> =
            <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsBlockFrame</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>nextInFlow</name>-&gt;<name>GetNextInFlow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        }</block></then></if>
        <expr_stmt><expr><name>nifLine</name> = <call><name><name>overflowLines</name>-&gt;<name>begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>nifLine</name> != <call><name><name>overflowLines</name>-&gt;<name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
                     <argument><expr>"Stored overflow line list should not be empty"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>toMove</name> = <name>nifLine</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>nextInFlow</name>-&gt;<name>RemoveOverflowLines</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nifLine</name> = <call><name><name>overflowLines</name>-&gt;<name>erase</name></name><argument_list>(<argument><expr><name>nifLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>nifLine</name> != <call><name><name>overflowLines</name>-&gt;<name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
          <comment type="line">// We need to this remove-and-put-back dance because we want</comment>
          <comment type="line">// to avoid making the overflow line list empty while it's</comment>
          <comment type="line">// stored in the property (because the property has the</comment>
          <comment type="line">// invariant that the list is never empty).</comment>
          <expr_stmt><expr><call><name><name>nextInFlow</name>-&gt;<name>SetOverflowLines</name></name><argument_list>(<argument><expr><name>overflowLines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>collectOverflowFloats</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
      }</block></else></if>

      <if>if <condition>(<expr>0 == <call><name><name>toMove</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// The line is empty. Try the next one.</comment>
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>nsnull</name> == <name><name>toMove</name>-&gt;<name>mFirstChild</name></name></expr></argument>, <argument><expr>"bad empty line"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>aState</name>.<name>FreeLineBox</name></name><argument_list>(<argument><expr><name>toMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      }</block></then></if>

      <comment type="line">// XXX move to a subroutine: run-in, overflow, pullframe and this do this</comment>
      <comment type="line">// Make the children in the line ours.</comment>
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>frame</name> <init>= <expr><name><name>toMove</name>-&gt;<name>mFirstChild</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsIFrame</name>*</type> <name>lastFrame</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>n</name> <init>= <expr><call><name><name>toMove</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr>--<name>n</name> &gt;= 0</expr>)</condition> <block>{
        <expr_stmt><expr><call><name>ReparentFrame</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr><name>nextInFlow</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastFrame</name> = <name>frame</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>frame</name> = <call><name><name>frame</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <expr_stmt><expr><call><name><name>lastFrame</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// Reparent floats whose placeholders are in the line.</comment>
      <expr_stmt><expr><call><name>ReparentFloats</name><argument_list>(<argument><expr><name><name>toMove</name>-&gt;<name>mFirstChild</name></name></expr></argument>, <argument><expr><name>nextInFlow</name></expr></argument>, <argument><expr><name>collectOverflowFloats</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="line">// Add line to our line list</comment>
      <if>if <condition>(<expr><name><name>aState</name>.<name>mPrevChild</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>aState</name>.<name>mPrevChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name><name>toMove</name>-&gt;<name>mFirstChild</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <expr_stmt><expr><name>line</name> = <call><name><name>mLines</name>.<name>before_insert</name></name><argument_list>(<argument><expr><call><name>end_lines</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>toMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>DumpLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>toMove</name></expr></argument>, <argument><expr><name>deltaY</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      <function_decl><type><name>AutoNoisyIndenter</name></type> <name>indent2</name><parameter_list>(<param><decl><type><name>gNoisyReflow</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="line">// Now reflow it and any lines that it makes during it's reflow</comment>
      <comment type="line">// (we have to loop here because reflowing the line may case a new</comment>
      <comment type="line">// line to be created; see SplitLine's callers for examples of</comment>
      <comment type="line">// when this happens).</comment>
      <while>while <condition>(<expr><name>line</name> != <call><name>end_lines</name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>ReflowLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr>&amp;<name>keepGoing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_ENSURE_SUCCESS</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DumpLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>deltaY</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>keepGoing</name></expr>)</condition><then> <block>{
          <if>if <condition>(<expr>0 == <call><name><name>line</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>DeleteLine</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>line_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <break>break;</break>
        }</block></then></if>

        <if>if <condition>(<expr><call><name>LineHasClear</name><argument_list>(<argument><expr><call><name><name>line</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>foundAnyClears</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// If this is an inline frame then its time to stop</comment>
        <expr_stmt><expr>++<name>line</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>aState</name>.<name>AdvanceToNextLine</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
    }</block></while>

    <if>if <condition>(<expr><call><name>NS_FRAME_IS_NOT_COMPLETE</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>aState</name>.<name>mReflowStatus</name></name> |= <name>NS_FRAME_REFLOW_NEXTINFLOW</name></expr>;</expr_stmt>
    }</block></then></if> <comment type="line">//XXXfr shouldn't set this flag when nextinflow has no lines</comment>
  }</block></then></if>

  <comment type="line">// Handle an odd-ball case: a list-item with no lines</comment>
  <if>if <condition>(<expr><name>mBullet</name> &amp;&amp; <call><name>HaveOutsideBullet</name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>mLines</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsHTMLReflowMetrics</name></type> <name>metrics</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ReflowBullet</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>metrics</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// There are no lines so we have to fake up some y motion so that</comment>
    <comment type="line">// we end up with *some* height.</comment>
    <expr_stmt><expr><name><name>aState</name>.<name>mY</name></name> += <name><name>metrics</name>.<name>height</name></name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>foundAnyClears</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>AddStateBits</name><argument_list>(<argument><expr><name>NS_BLOCK_HAS_CLEAR_CHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>RemoveStateBits</name><argument_list>(<argument><expr><name>NS_BLOCK_HAS_CLEAR_CHILDREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name>gNoisyReflow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>IndentBy</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>gNoiseIndent</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ListTag</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>": done reflowing dirty lines (status=%x)\n"</expr></argument>,
           <argument><expr><name><name>aState</name>.<name>mReflowStatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nsBlockFrame</name>::<name>DeleteLine</name></name><parameter_list>(<param><decl><type><name>nsBlockReflowState</name>&amp;</type> <name>aState</name></decl></param>,
                         <param><decl><type><name><name>nsLineList</name>::<name>iterator</name></name></type> <name>aLine</name></decl></param>,
                         <param><decl><type><name><name>nsLineList</name>::<name>iterator</name></name></type> <name>aLineEnd</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_PRECONDITION</name><argument_list>(<argument><expr>0 == <call><name><name>aLine</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"can't delete !empty line"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>0 == <call><name><name>aLine</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>aState</name>.<name>mCurrentLine</name></name> == <name>aLine</name></expr></argument>,
                 <argument><expr>"using function more generally than designed, "
                 "but perhaps OK now"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsLineBox</name> *</type><name>line</name> <init>= <expr><name>aLine</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>aLine</name> = <call><name><name>mLines</name>.<name>erase</name></name><argument_list>(<argument><expr><name>aLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aState</name>.<name>FreeLineBox</name></name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Mark the previous margin of the next line dirty since we need to</comment>
    <comment type="line">// recompute its top position.</comment>
    <if>if <condition>(<expr><name>aLine</name> != <name>aLineEnd</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>aLine</name>-&gt;<name>MarkPreviousMarginDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>
}</block></function>

<comment type="block" format="doxygen">/**
 * Takes two rectangles whose origins must be the same, and computes
 * the difference between their union and their intersection as two
 * rectangles. (This difference is a superset of the difference
 * between the two rectangles.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>GetRectDifferenceStrips</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aR1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsRect</name>&amp;</type> <name>aR2</name></decl></param>,
                                    <param><decl><type><name>nsRect</name>*</type> <name>aHStrip</name></decl></param>, <param><decl><type><name>nsRect</name>*</type> <name>aVStrip</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aR1</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call> == <call><name><name>aR2</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"expected rects at the same position"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsRect</name></type> <name>unionRect</name><argument_list>(<argument><expr><name><name>aR1</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aR1</name>.<name>y</name></name></expr></argument>, <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>aR1</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aR2</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name><name>aR1</name>.<name>height</name></name></expr></argument>, <argument><expr><name><name>aR2</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>VStripStart</name> <init>= <expr><call><name>PR_MIN</name><argument_list>(<argument><expr><name><name>aR1</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aR2</name>.<name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nscoord</name></type> <name>HStripStart</name> <init>= <expr><call><name>PR_MIN</name><argument_list>(<argument><expr><name><name>aR1</name>.<name>height</name></name></expr></argument>, <argument><expr><name><name>aR2</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>aVStrip</name> = <name>unionRect</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aVStrip</name>-&gt;<name>x</name></name> += <name>VStripStart</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aVStrip</name>-&gt;<name>width</name></name> -= <name>VStripStart</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aHStrip</name> = <name>unionRect</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aHStrip</name>-&gt;<name>y</name></name> += <name>HStripStart</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aHStrip</name>-&gt;<name>height</name></name> -= <name>HStripStart</name></expr>;</expr_stmt>
}</block></function>

<comment type="block" format="doxygen">/**
 * Reflow a line. The line will either contain a single block frame
 * or contain 1 or more inline frames. aKeepReflowGoing indicates
 * whether or not the caller should continue to reflow more lines.
 */</comment>
<function><type><name>nsresult</name></type>
<name><name>nsBlockFrame</name>::<name>ReflowLine</name></name><parameter_list>(<param><decl><type><name>nsBlockReflowState</name>&amp;</type> <name>aState</name></decl></param>,
                         <param><decl><type><name>line_iterator</name></type> <name>aLine</name></decl></param>,
                         <param><decl><type><name>PRBool</name>*</type> <name>aKeepReflowGoing</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><name>NS_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name><name>aLine</name>-&gt;<name>GetChildCount</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"reflowing empty line"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Setup the line-layout for the new line</comment>
  <expr_stmt><expr><name><name>aState</name>.<name>mCurrentLine</name></name> = <name>aLine</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aLine</name>-&gt;<name>ClearDirty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aLine</name>-&gt;<name>InvalidateCachedIsEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// Now that we know what kind of line we have, reflow it</comment>
  <if>if <condition>(<expr><call><name><name>aLine</name>-&gt;<name>IsBlock</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>oldBounds</name> <init>= <expr><call><name><name>aLine</name>-&gt;<name>mFirstChild</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>oldCombinedArea</name><argument_list>(<argument><expr><call><name><name>aLine</name>-&gt;<name>GetCombinedArea</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>ReflowBlockFrame</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>aLine</name></expr></argument>, <argument><expr><name>aKeepReflowGoing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>newBounds</name> <init>= <expr><call><name><name>aLine</name>-&gt;<name>mFirstChild</name>-&gt;<name>GetRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// We expect blocks to damage any area inside their bounds that is</comment>
    <comment type="line">// dirty; however, if the frame changes size or position then we</comment>
    <comment type="line">// need to do some repainting.</comment>
    <comment type="line">// XXX roc --- the above statement is ambiguous about whether 'bounds'</comment>
    <comment type="line">// means the frame's bounds or overflowArea, and in fact this is a source</comment>
    <comment type="line">// of much confusion and bugs. Thus the following hack considers *both*</comment>
    <comment type="line">// overflowArea and bounds. This should be considered a temporary hack</comment>
    <comment type="line">// until we decide how it's really supposed to work.</comment>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>lineCombinedArea</name><argument_list>(<argument><expr><call><name><name>aLine</name>-&gt;<name>GetCombinedArea</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>oldCombinedArea</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call> != <call><name><name>lineCombinedArea</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call> ||
        <call><name><name>oldBounds</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call> != <call><name><name>newBounds</name>.<name>TopLeft</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <comment type="line">// The block has moved, and so to be safe we need to repaint</comment>
      <comment type="line">// XXX We need to improve on this...</comment>
      <decl_stmt><decl><type><name>nsRect</name></type>  <name>dirtyRect</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>dirtyRect</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>oldCombinedArea</name></expr></argument>, <argument><expr><name>lineCombinedArea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_BLOCK_INVALIDATE</name></cpp:ifdef>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%p invalidate 6 (%d, %d, %d, %d)\n"</expr></argument>,
             <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>dirtyRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>dirtyRect</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>dirtyRect</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>dirtyRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>dirtyRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <decl_stmt><decl><type><name>nsRect</name></type> <name>combinedAreaHStrip</name></decl>, <decl><type ref="prev"/><name>combinedAreaVStrip</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>nsRect</name></type> <name>boundsHStrip</name></decl>, <decl><type ref="prev"/><name>boundsVStrip</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>GetRectDifferenceStrips</name><argument_list>(<argument><expr><name>oldBounds</name></expr></argument>, <argument><expr><name>newBounds</name></expr></argument>,
                              <argument><expr>&amp;<name>boundsHStrip</name></expr></argument>, <argument><expr>&amp;<name>boundsVStrip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GetRectDifferenceStrips</name><argument_list>(<argument><expr><name>oldCombinedArea</name></expr></argument>, <argument><expr><name>lineCombinedArea</name></expr></argument>,
                              <argument><expr>&amp;<name>combinedAreaHStrip</name></expr></argument>, <argument><expr>&amp;<name>combinedAreaVStrip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_BLOCK_INVALIDATE</name></cpp:ifdef>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%p invalidate boundsVStrip (%d, %d, %d, %d)\n"</expr></argument>,
             <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>boundsVStrip</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>boundsVStrip</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>boundsVStrip</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>boundsVStrip</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%p invalidate boundsHStrip (%d, %d, %d, %d)\n"</expr></argument>,
             <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>boundsHStrip</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>boundsHStrip</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>boundsHStrip</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>boundsHStrip</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%p invalidate combinedAreaVStrip (%d, %d, %d, %d)\n"</expr></argument>,
             <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>combinedAreaVStrip</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>combinedAreaVStrip</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>combinedAreaVStrip</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>combinedAreaVStrip</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%p invalidate combinedAreaHStrip (%d, %d, %d, %d)\n"</expr></argument>,
             <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>combinedAreaHStrip</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>combinedAreaHStrip</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>combinedAreaHStrip</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>combinedAreaHStrip</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="line">// The first thing Invalidate does is check if the rect is empty, so</comment>
      <comment type="line">// don't bother doing that here.</comment>
      <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>boundsVStrip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>boundsHStrip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>combinedAreaVStrip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Invalidate</name><argument_list>(<argument><expr><name>combinedAreaHStrip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then>
  <else>else <block>{
    <decl_stmt><decl><type><name>nsRect</name></type> <name>oldCombinedArea</name><argument_list>(<argument><expr><call><name><name>aLine</name>-&gt;<name>GetCombinedArea</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>aLine</name>-&gt;<name>SetLineWrapped</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ReflowInlineFrames</name><argument_list>(<argument><expr><name>aState</name></expr></argument>, <argument><expr><name>aLine</name></expr></argument>, <argument><expr><name>aKeepReflowGoing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We don't really know what changed in the line, so use the union</comment>
    <comment type="line">// of the old and new combined areas</comment>
    <decl_stmt><decl><type><name>nsRect</name></type> <name>dirtyRect</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>dirtyRect</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>oldCombinedArea</name></expr></argument>, <argument><expr><call><name><name>aLine</name>-&gt;<name>GetCombinedArea</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_BLOCK_INVALIDATE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%p invalidate (%d, %d, %d, %d)\n"</expr></argument>,
           <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>dirtyRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>dirtyRect</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>dirtyRect</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>dirtyRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>aLine</name>-&gt;<name>IsForceInvalidate</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
      <macro><name>printf</name><argument_list>(<argument>"  dirty line is %p\n"</argument>, <argument>static_cast&lt;void*&gt;(aLine.get());
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    Invalidate(dirtyRect);
  }

  return rv;
}

<comment type="block" format="doxygen">/**
 * Pull frame from the next available location (one of our lines or
 * one of our next-in-flows lines).
 */</comment>
nsresult
nsBlockFrame::PullFrame(nsBlockReflowState&amp; aState,
                        line_iterator aLine,
                        nsIFrame*&amp; aFrameResult)
{
  aFrameResult = nsnull;

  <comment type="line">// First check our remaining lines</comment>
  if (end_lines() != aLine.next()) {
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    PRBool retry =
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      PullFrameFrom(aState, aLine, this, PR_FALSE, aLine.next(), aFrameResult);
    NS_ASSERTION(!retry, "Shouldn't have to retry in the current block");
    return NS_OK;
  }

  NS_ASSERTION(!GetOverflowLines(),
    "Our overflow lines should have been removed at the start of reflow");

  <comment type="line">// Try each next in flows</comment>
  nsBlockFrame* nextInFlow = aState.mNextInFlow;
  while (nextInFlow) {
    <comment type="line">// first normal lines, then overflow lines</comment>
    if (!nextInFlow-&gt;mLines.empty()) {
      if (PullFrameFrom(aState, aLine, nextInFlow, PR_FALSE,
                        nextInFlow-&gt;mLines.begin(), aFrameResult)) {
        <comment type="line">// try again with the same value of nextInFlow</comment>
        continue;
      }
      break;
    }

    nsLineList* overflowLines = nextInFlow-&gt;GetOverflowLines();
    if (overflowLines) {
      if (PullFrameFrom(aState, aLine, nextInFlow, PR_TRUE,
                        overflowLines-&gt;begin(), aFrameResult)) {
        <comment type="line">// try again with the same value of nextInFlow</comment>
        continue;
      }
      break;
    }

    nextInFlow = (nsBlockFrame*) nextInFlow-&gt;GetNextInFlow();
    aState.mNextInFlow = nextInFlow;
  }

  return NS_OK;
}

<comment type="block" format="doxygen">/**
 * Try to pull a frame out of a line pointed at by aFromLine. If
 * aUpdateGeometricParent is set then the pulled frames geometric parent
 * will be updated (e.g. when pulling from a next-in-flows line list).
 *
 * Note: pulling a frame from a line that is a place-holder frame
 * doesn't automatically remove the corresponding float from the
 * line's float array. This happens indirectly: either the line gets
 * emptied (and destroyed) or the line gets reflowed (because we mark
 * it dirty) and the code at the top of ReflowLine empties the
 * array. So eventually, it will be removed, just not right away.
 *
 * @return PR_TRUE to force retrying of the pull.
 */</comment>
PRBool
nsBlockFrame::PullFrameFrom(nsBlockReflowState&amp; aState,
                            nsLineBox* aLine,
                            nsBlockFrame* aFromContainer,
                            PRBool aFromOverflowLine,
                            nsLineList::iterator aFromLine,
                            nsIFrame*&amp; aFrameResult)
{
  nsLineBox* fromLine = aFromLine;
  NS_ABORT_IF_FALSE(fromLine, "bad line to pull from");
  NS_ABORT_IF_FALSE(fromLine-&gt;GetChildCount(), "empty line");
  NS_ABORT_IF_FALSE(aLine-&gt;GetChildCount(), "empty line");

  NS_ASSERTION(fromLine-&gt;IsBlock() == fromLine-&gt;mFirstChild-&gt;GetStyleDisplay()-&gt;IsBlockOutside(),
               "Disagreement about whether it's a block or not");

  if (fromLine-&gt;IsBlock()) {
    <comment type="line">// If our line is not empty and the child in aFromLine is a block</comment>
    <comment type="line">// then we cannot pull up the frame into this line. In this case</comment>
    <comment type="line">// we stop pulling.</comment>
    aFrameResult = nsnull;
  }
  else {
    <comment type="line">// Take frame from fromLine</comment>
    nsIFrame* frame = fromLine-&gt;mFirstChild;

    if (aFromContainer != this) {
      if (HandleOverflowPlaceholdersForPulledFrame(aState, frame)) {
        <comment type="line">// we lost this one, retry</comment>
        return PR_TRUE;
      }

      aLine-&gt;LastChild()-&gt;SetNextSibling(frame);
    }
    <comment type="line">// when aFromContainer is 'this', then aLine-&gt;LastChild()'s next sibling</comment>
    <comment type="line">// is already set correctly.</comment>
    aLine-&gt;SetChildCount(aLine-&gt;GetChildCount() + 1);
      
    PRInt32 fromLineChildCount = fromLine-&gt;GetChildCount();
    if (0 != --fromLineChildCount) {
      <comment type="line">// Mark line dirty now that we pulled a child</comment>
      fromLine-&gt;SetChildCount(fromLineChildCount);
      fromLine-&gt;MarkDirty();
      fromLine-&gt;mFirstChild = frame-&gt;GetNextSibling();
    }
    else {
      <comment type="line">// Free up the fromLine now that it's empty</comment>
      <comment type="line">// Its bounds might need to be redrawn, though.</comment>
      <comment type="line">// XXX WHY do we invalidate the bounds AND the combined area? doesn't</comment>
      <comment type="line">// the combined area always enclose the bounds?</comment>
      Invalidate(fromLine-&gt;mBounds);
      nsLineList* fromLineList = aFromOverflowLine
        ? aFromContainer-&gt;RemoveOverflowLines()
        : &amp;aFromContainer-&gt;mLines;
      if (aFromLine.next() != fromLineList-&gt;end())
        aFromLine.next()-&gt;MarkPreviousMarginDirty();

      Invalidate(fromLine-&gt;GetCombinedArea());
      fromLineList-&gt;erase(aFromLine);
      <comment type="line">// Note that aFromLine just got incremented, so don't use it again here!</comment>
      aState.FreeLineBox(fromLine);

      <comment type="line">// Put any remaining overflow lines back.</comment>
      if (aFromOverflowLine &amp;&amp; !fromLineList-&gt;empty()) {
        aFromContainer-&gt;SetOverflowLines(fromLineList);
      }
    }

    <comment type="line">// Change geometric parents</comment>
    if (aFromContainer != this) {
      <comment type="line">// When pushing and pulling frames we need to check for whether any</comment>
      <comment type="line">// views need to be reparented</comment>
      NS_ASSERTION(frame-&gt;GetParent() == aFromContainer, "unexpected parent frame");

      ReparentFrame(frame, aFromContainer, this);

      <comment type="line">// The frame is being pulled from a next-in-flow; therefore we</comment>
      <comment type="line">// need to add it to our sibling list.</comment>
      frame-&gt;SetNextSibling(nsnull);
      if (nsnull != aState.mPrevChild) {
        aState.mPrevChild-&gt;SetNextSibling(frame);
      }

      <comment type="line">// The frame might have (or contain) floats that need to be</comment>
      <comment type="line">// brought over too.</comment>
      ReparentFloats(frame, aFromContainer, aFromOverflowLine, PR_TRUE);
    }

    <comment type="line">// Stop pulling because we found a frame to pull</comment>
    aFrameResult = frame;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    VerifyLines(PR_TRUE);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }
  return PR_FALSE;
}

static void
PlaceFrameView(nsIFrame* aFrame)
{
  if (aFrame-&gt;HasView())
    nsContainerFrame::PositionFrameView(aFrame);
  else
    nsContainerFrame::PositionChildViews(aFrame);
}

void
nsBlockFrame::SlideLine(nsBlockReflowState&amp; aState,
                        nsLineBox* aLine, nscoord aDY)
{
  NS_PRECONDITION(aDY != 0, "why slide a line nowhere?");

  Invalidate(aLine-&gt;GetCombinedArea());
  <comment type="line">// Adjust line state</comment>
  aLine-&gt;SlideBy(aDY);
  Invalidate(aLine-&gt;GetCombinedArea());

  <comment type="line">// Adjust the frames in the line</comment>
  nsIFrame* kid = aLine-&gt;mFirstChild;
  if (!kid) {
    return;
  }

  if (aLine-&gt;IsBlock()) {
    if (aDY) {
      nsPoint p = kid-&gt;GetPosition();
      p.y += aDY;
      kid-&gt;SetPosition(p);
    }

    <comment type="line">// Make sure the frame's view and any child views are updated</comment>
    ::PlaceFrameView(kid);
  }
  else {
    <comment type="line">// Adjust the Y coordinate of the frames in the line.</comment>
    <comment type="line">// Note: we need to re-position views even if aDY is 0, because</comment>
    <comment type="line">// one of our parent frames may have moved and so the view's position</comment>
    <comment type="line">// relative to its parent may have changed</comment>
    PRInt32 n = aLine-&gt;GetChildCount();
    while (--n &gt;= 0) {
      if (aDY) {
        nsPoint p = kid-&gt;GetPosition();
        p.y += aDY;
        kid-&gt;SetPosition(p);
      }
      <comment type="line">// Make sure the frame's view and any child views are updated</comment>
      ::PlaceFrameView(kid);
      kid = kid-&gt;GetNextSibling();
    }
  }
}

NS_IMETHODIMP 
nsBlockFrame::AttributeChanged(PRInt32         aNameSpaceID,
                               nsIAtom*        aAttribute,
                               PRInt32         aModType)
{
  nsresult rv = nsBlockFrameSuper::AttributeChanged(aNameSpaceID,
                                                    aAttribute, aModType);

  if (NS_FAILED(rv)) {
    return rv;
  }
  if (nsGkAtoms::start == aAttribute) {
    nsPresContext* presContext = PresContext();

    <comment type="line">// XXX Not sure if this is necessary anymore</comment>
    if (RenumberLists(presContext)) {
      presContext-&gt;PresShell()-&gt;
        FrameNeedsReflow(this, nsIPresShell::eStyleChange,
                         NS_FRAME_HAS_DIRTY_CHILDREN);
    }
  }
  else if (nsGkAtoms::value == aAttribute) {
    const nsStyleDisplay* styleDisplay = GetStyleDisplay();
    if (NS_STYLE_DISPLAY_LIST_ITEM == styleDisplay-&gt;mDisplay) {
      <comment type="line">// Search for the closest ancestor that's a block frame. We</comment>
      <comment type="line">// make the assumption that all related list items share a</comment>
      <comment type="line">// common block parent.</comment>
      <comment type="line">// XXXldb I think that's a bad assumption.</comment>
      nsBlockFrame* blockParent = nsLayoutUtils::FindNearestBlockAncestor(this);

      <comment type="line">// Tell the enclosing block frame to renumber list items within</comment>
      <comment type="line">// itself</comment>
      if (nsnull != blockParent) {
        nsPresContext* presContext = PresContext();
        <comment type="line">// XXX Not sure if this is necessary anymore</comment>
        if (blockParent-&gt;RenumberLists(presContext)) {
          presContext-&gt;PresShell()-&gt;
            FrameNeedsReflow(blockParent, nsIPresShell::eStyleChange,
                             NS_FRAME_HAS_DIRTY_CHILDREN);
        }
      }
    }
  }

  return rv;
}

inline PRBool
IsPaddingZero(nsStyleUnit aUnit, nsStyleCoord &amp;aCoord)
{
    return ((aUnit == eStyleUnit_Coord &amp;&amp; aCoord.GetCoordValue() == 0) ||
            (aUnit == eStyleUnit_Percent &amp;&amp; aCoord.GetPercentValue() == 0.0));
}

inline PRBool
IsMarginZero(nsStyleUnit aUnit, nsStyleCoord &amp;aCoord)
{
    return (aUnit == eStyleUnit_Auto ||
            (aUnit == eStyleUnit_Coord &amp;&amp; aCoord.GetCoordValue() == 0) ||
            (aUnit == eStyleUnit_Percent &amp;&amp; aCoord.GetPercentValue() == 0.0));
}

<comment type="block">/* virtual */</comment> PRBool
nsBlockFrame::IsSelfEmpty()
{
  <comment type="line">// Blocks which are margin-roots (including inline-blocks) cannot be treated</comment>
  <comment type="line">// as empty for margin-collapsing and other purposes. They're more like</comment>
  <comment type="line">// replaced elements.</comment>
  if (GetStateBits() &amp; NS_BLOCK_MARGIN_ROOT)
    return PR_FALSE;

  const nsStylePosition* position = GetStylePosition();

  switch (position-&gt;mMinHeight.GetUnit()) {
    case eStyleUnit_Coord:
      if (position-&gt;mMinHeight.GetCoordValue() != 0)
        return PR_FALSE;
      break;
    case eStyleUnit_Percent:
      if (position-&gt;mMinHeight.GetPercentValue() != 0.0f)
        return PR_FALSE;
      break;
    default:
      return PR_FALSE;
  }

  switch (position-&gt;mHeight.GetUnit()) {
    case eStyleUnit_Auto:
      break;
    case eStyleUnit_Coord:
      if (position-&gt;mHeight.GetCoordValue() != 0)
        return PR_FALSE;
      break;
    case eStyleUnit_Percent:
      if (position-&gt;mHeight.GetPercentValue() != 0.0f)
        return PR_FALSE;
      break;
    default:
      return PR_FALSE;
  }

  const nsStyleBorder* border = GetStyleBorder();
  const nsStylePadding* padding = GetStylePadding();
  nsStyleCoord coord;
  if (border-&gt;GetBorderWidth(NS_SIDE_TOP) != 0 ||
      border-&gt;GetBorderWidth(NS_SIDE_BOTTOM) != 0 ||
      !IsPaddingZero(padding-&gt;mPadding.GetTopUnit(),
                    padding-&gt;mPadding.GetTop(coord)) ||
      !IsPaddingZero(padding-&gt;mPadding.GetBottomUnit(),
                    padding-&gt;mPadding.GetBottom(coord))) {
    return PR_FALSE;
  }

  return PR_TRUE;
}

PRBool
nsBlockFrame::CachedIsEmpty()
{
  if (!IsSelfEmpty()) {
    return PR_FALSE;
  }

  for (line_iterator line = begin_lines(), line_end = end_lines();
       line != line_end;
       ++line)
  {
    if (!line-&gt;CachedIsEmpty())
      return PR_FALSE;
  }

  return PR_TRUE;
}

PRBool
nsBlockFrame::IsEmpty()
{
  if (!IsSelfEmpty()) {
    return PR_FALSE;
  }

  for (line_iterator line = begin_lines(), line_end = end_lines();
       line != line_end;
       ++line)
  {
    if (!line-&gt;IsEmpty())
      return PR_FALSE;
  }

  return PR_TRUE;
}

PRBool
nsBlockFrame::ShouldApplyTopMargin(nsBlockReflowState&amp; aState,
                                   nsLineBox* aLine)
{
  if (aState.GetFlag(BRS_APPLYTOPMARGIN)) {
    <comment type="line">// Apply short-circuit check to avoid searching the line list</comment>
    return PR_TRUE;
  }

  if (!aState.IsAdjacentWithTop()) {
    <comment type="line">// If we aren't at the top Y coordinate then something of non-zero</comment>
    <comment type="line">// height must have been placed. Therefore the childs top-margin</comment>
    <comment type="line">// applies.</comment>
    aState.SetFlag(BRS_APPLYTOPMARGIN, PR_TRUE);
    return PR_TRUE;
  }

  <comment type="line">// Determine if this line is "essentially" the first line</comment>
  line_iterator line = begin_lines();
  if (aState.GetFlag(BRS_HAVELINEADJACENTTOTOP)) {
    line = aState.mLineAdjacentToTop;
  }
  while (line != aLine) {
    if (!line-&gt;CachedIsEmpty() || line-&gt;HasClearance()) {
      <comment type="line">// A line which precedes aLine is non-empty, or has clearance,</comment>
      <comment type="line">// so therefore the top margin applies.</comment>
      aState.SetFlag(BRS_APPLYTOPMARGIN, PR_TRUE);
      return PR_TRUE;
    }
    <comment type="line">// No need to apply the top margin if the line has floats.  We</comment>
    <comment type="line">// should collapse anyway (bug 44419)</comment>
    ++line;
    aState.SetFlag(BRS_HAVELINEADJACENTTOTOP, PR_TRUE);
    aState.mLineAdjacentToTop = line;
  }

  <comment type="line">// The line being reflowed is "essentially" the first line in the</comment>
  <comment type="line">// block. Therefore its top-margin will be collapsed by the</comment>
  <comment type="line">// generational collapsing logic with its parent (us).</comment>
  return PR_FALSE;
}

nsIFrame*
nsBlockFrame::GetTopBlockChild(nsPresContext* aPresContext)
{
  if (mLines.empty())
    return nsnull;

  nsLineBox *firstLine = mLines.front();
  if (firstLine-&gt;IsBlock())
    return firstLine-&gt;mFirstChild;

  if (!firstLine-&gt;CachedIsEmpty())
    return nsnull;

  line_iterator secondLine = begin_lines();
  ++secondLine;
  if (secondLine == end_lines() || !secondLine-&gt;IsBlock())
    return nsnull;

  return secondLine-&gt;mFirstChild;
}

<comment type="line">// If placeholders/floats split during reflowing a line, but that line will </comment>
<comment type="line">// be put on the next page, then put the placeholders/floats back the way</comment>
<comment type="line">// they were before the line was reflowed. </comment>
void
nsBlockFrame::UndoSplitPlaceholders(nsBlockReflowState&amp; aState,
                                    nsIFrame*           aLastPlaceholder)
{
  nsIFrame* undoPlaceholder;
  if (aLastPlaceholder) {
    undoPlaceholder = aLastPlaceholder-&gt;GetNextSibling();
    aLastPlaceholder-&gt;SetNextSibling(nsnull);
  }
  else {
    undoPlaceholder = aState.mOverflowPlaceholders.FirstChild();
    aState.mOverflowPlaceholders.SetFrames(nsnull);
  }
  <comment type="line">// remove the next in flows of the placeholders that need to be removed</comment>
  for (nsPlaceholderFrame* placeholder = static_cast&lt;nsPlaceholderFrame*&gt;(undoPlaceholder);
       placeholder; ) {
    NS_ASSERTION(!placeholder-&gt;GetNextInFlow(), "Must be the last placeholder");

    nsFrameManager* fm = aState.mPresContext-&gt;GetPresShell()-&gt;FrameManager();
    fm-&gt;UnregisterPlaceholderFrame(placeholder);
    placeholder-&gt;SetOutOfFlowFrame(nsnull);

    <comment type="line">// XXX we probably should be doing something with oof here. But what?</comment>

    nsSplittableFrame::RemoveFromFlow(placeholder);
    nsIFrame* savePlaceholder = placeholder; 
    placeholder = static_cast&lt;nsPlaceholderFrame*&gt;(placeholder-&gt;GetNextSibling());
    savePlaceholder-&gt;Destroy();
  }
}

nsresult
nsBlockFrame::ReflowBlockFrame(nsBlockReflowState&amp; aState,
                               line_iterator aLine,
                               PRBool* aKeepReflowGoing)
{
  NS_PRECONDITION(*aKeepReflowGoing, "bad caller");

  nsresult rv = NS_OK;

  nsIFrame* frame = aLine-&gt;mFirstChild;
  if (!frame) {
    NS_ASSERTION(PR_FALSE, "program error - unexpected empty line"); 
    return NS_ERROR_NULL_POINTER; 
  }

  <comment type="line">// Prepare the block reflow engine</comment>
  const nsStyleDisplay* display = frame-&gt;GetStyleDisplay();
  nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);

  PRUint8 breakType = display-&gt;mBreakType;
  <comment type="line">// If a float split and its prev-in-flow was followed by a &lt;BR&gt;, then combine </comment>
  <comment type="line">// the &lt;BR&gt;'s break type with the block's break type (the block will be the very </comment>
  <comment type="line">// next frame after the split float).</comment>
  if (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType) {
    breakType = nsLayoutUtils::CombineBreakType(breakType,
                                                aState.mFloatBreakType);
    aState.mFloatBreakType = NS_STYLE_CLEAR_NONE;
  }

  <comment type="line">// Clear past floats before the block if the clear style is not none</comment>
  aLine-&gt;SetBreakTypeBefore(breakType);

  <comment type="line">// See if we should apply the top margin. If the block frame being</comment>
  <comment type="line">// reflowed is a continuation (non-null prev-in-flow) then we don't</comment>
  <comment type="line">// apply its top margin because it's not significant. Otherwise, dig</comment>
  <comment type="line">// deeper.</comment>
  PRBool applyTopMargin =
    !frame-&gt;GetPrevInFlow() &amp;&amp; ShouldApplyTopMargin(aState, aLine);

  if (applyTopMargin) {
    <comment type="line">// The HasClearance setting is only valid if ShouldApplyTopMargin</comment>
    <comment type="line">// returned PR_FALSE (in which case the top-margin-root set our</comment>
    <comment type="line">// clearance flag). Otherwise clear it now. We'll set it later on</comment>
    <comment type="line">// ourselves if necessary.</comment>
    aLine-&gt;ClearHasClearance();
  }
  PRBool treatWithClearance = aLine-&gt;HasClearance();
  <comment type="line">// If our top margin was counted as part of some parents top-margin</comment>
  <comment type="line">// collapse and we are being speculatively reflowed assuming this</comment>
  <comment type="line">// frame DID NOT need clearance, then we need to check that</comment>
  <comment type="line">// assumption.</comment>
  if (!treatWithClearance &amp;&amp; !applyTopMargin &amp;&amp; breakType != NS_STYLE_CLEAR_NONE &amp;&amp;
      aState.mReflowState.mDiscoveredClearance) {
    nscoord curY = aState.mY + aState.mPrevBottomMargin.get();
    nscoord clearY = aState.ClearFloats(curY, breakType);
    if (clearY != curY) {
      <comment type="line">// Looks like that assumption was invalid, we do need</comment>
      <comment type="line">// clearance. Tell our ancestor so it can reflow again. It is</comment>
      <comment type="line">// responsible for actually setting our clearance flag before</comment>
      <comment type="line">// the next reflow.</comment>
      treatWithClearance = PR_TRUE;
      <comment type="line">// Only record the first frame that requires clearance</comment>
      if (!*aState.mReflowState.mDiscoveredClearance) {
        *aState.mReflowState.mDiscoveredClearance = frame;
      }
      <comment type="line">// Exactly what we do now is flexible since we'll definitely be</comment>
      <comment type="line">// reflowed.</comment>
      return NS_OK;
    }
  }
  if (treatWithClearance) {
    applyTopMargin = PR_TRUE;
  }

  nsIFrame* clearanceFrame = nsnull;
  nscoord startingY = aState.mY;
  nsCollapsingMargin incomingMargin = aState.mPrevBottomMargin;
  nscoord clearance;
  <comment type="line">// Save the original position of the frame so that we can reposition</comment>
  <comment type="line">// its view as needed.</comment>
  nsPoint originalPosition = frame-&gt;GetPosition();
  while (PR_TRUE) {
    <comment type="line">// Save the frame's current position. We might need it later.</comment>
    nscoord passOriginalY = frame-&gt;GetRect().y;
    
    clearance = 0;
    nscoord topMargin = 0;
    PRBool mayNeedRetry = PR_FALSE;
    if (applyTopMargin) {
      <comment type="line">// Precompute the blocks top margin value so that we can get the</comment>
      <comment type="line">// correct available space (there might be a float that's</comment>
      <comment type="line">// already been placed below the aState.mPrevBottomMargin</comment>

      <comment type="line">// Setup a reflowState to get the style computed margin-top</comment>
      <comment type="line">// value. We'll use a reason of `resize' so that we don't fudge</comment>
      <comment type="line">// any incremental reflow state.</comment>
      
      <comment type="line">// The availSpace here is irrelevant to our needs - all we want</comment>
      <comment type="line">// out if this setup is the margin-top value which doesn't depend</comment>
      <comment type="line">// on the childs available space.</comment>
      <comment type="line">// XXX building a complete nsHTMLReflowState just to get the margin-top</comment>
      <comment type="line">// seems like a waste. And we do this for almost every block!</comment>
      nsSize availSpace(aState.mContentArea.width, NS_UNCONSTRAINEDSIZE);
      nsHTMLReflowState reflowState(aState.mPresContext, aState.mReflowState,
                                    frame, availSpace);
      
      if (treatWithClearance) {
        aState.mY += aState.mPrevBottomMargin.get();
        aState.mPrevBottomMargin.Zero();
      }
      
      <comment type="line">// Now compute the collapsed margin-top value into aState.mPrevBottomMargin, assuming</comment>
      <comment type="line">// that all child margins collapse down to clearanceFrame.</comment>
      nsBlockReflowContext::ComputeCollapsedTopMargin(reflowState,
                                                      &amp;aState.mPrevBottomMargin, clearanceFrame, &amp;mayNeedRetry);
      
      <comment type="line">// XXX optimization; we could check the collapsing children to see if they are sure</comment>
      <comment type="line">// to require clearance, and so avoid retrying them</comment>
      
      if (clearanceFrame) {
        <comment type="line">// Don't allow retries on the second pass. The clearance decisions for the</comment>
        <comment type="line">// blocks whose top-margins collapse with ours are now fixed.</comment>
        mayNeedRetry = PR_FALSE;
      }
      
      if (!treatWithClearance &amp;&amp; !clearanceFrame &amp;&amp; breakType != NS_STYLE_CLEAR_NONE) {
        <comment type="line">// We don't know if we need clearance and this is the first,</comment>
        <comment type="line">// optimistic pass.  So determine whether *this block* needs</comment>
        <comment type="line">// clearance. Note that we do not allow the decision for whether</comment>
        <comment type="line">// this block has clearance to change on the second pass; that</comment>
        <comment type="line">// decision is only allowed to be made under the optimistic</comment>
        <comment type="line">// first pass.</comment>
        nscoord curY = aState.mY + aState.mPrevBottomMargin.get();
        nscoord clearY = aState.ClearFloats(curY, breakType);
        if (clearY != curY) {
          <comment type="line">// Looks like we need clearance and we didn't know about it already. So</comment>
          <comment type="line">// recompute collapsed margin</comment>
          treatWithClearance = PR_TRUE;
          <comment type="line">// Remember this decision, needed for incremental reflow</comment>
          aLine-&gt;SetHasClearance();
          
          <comment type="line">// Apply incoming margins</comment>
          aState.mY += aState.mPrevBottomMargin.get();
          aState.mPrevBottomMargin.Zero();
          
          <comment type="line">// Compute the collapsed margin again, ignoring the incoming margin this time</comment>
          mayNeedRetry = PR_FALSE;
          nsBlockReflowContext::ComputeCollapsedTopMargin(reflowState,
                                                          &amp;aState.mPrevBottomMargin, clearanceFrame, &amp;mayNeedRetry);
        }
      }
      
      <comment type="line">// Temporarily advance the running Y value so that the</comment>
      <comment type="line">// GetAvailableSpace method will return the right available</comment>
      <comment type="line">// space. This undone as soon as the horizontal margins are</comment>
      <comment type="line">// computed.</comment>
      topMargin = aState.mPrevBottomMargin.get();
      
      if (treatWithClearance) {
        nscoord currentY = aState.mY;
        <comment type="line">// advance mY to the clear position.</comment>
        aState.mY = aState.ClearFloats(aState.mY, breakType);
        
        <comment type="line">// Compute clearance. It's the amount we need to add to the top</comment>
        <comment type="line">// border-edge of the frame, after applying collapsed margins</comment>
        <comment type="line">// from the frame and its children, to get it to line up with</comment>
        <comment type="line">// the bottom of the floats. The former is currentY + topMargin,</comment>
        <comment type="line">// the latter is the current aState.mY.</comment>
        <comment type="line">// Note that negative clearance is possible</comment>
        clearance = aState.mY - (currentY + topMargin);
        
        <comment type="line">// Add clearance to our top margin while we compute available</comment>
        <comment type="line">// space for the frame</comment>
        topMargin += clearance;
        
        <comment type="line">// Note that aState.mY should stay where it is: at the top</comment>
        <comment type="line">// border-edge of the frame</comment>
      } else {
        <comment type="line">// Advance aState.mY to the top border-edge of the frame.</comment>
        aState.mY += topMargin;
      }
    }
    
    <comment type="line">// Here aState.mY is the top border-edge of the block.</comment>
    <comment type="line">// Compute the available space for the block</comment>
    aState.GetAvailableSpace();
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REALLY_NOISY_REFLOW</name></cpp:ifdef>
    printf("setting line %p isImpacted to %s\n", aLine.get(), aState.IsImpactedByFloat()?"true":"false");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    PRBool isImpacted = aState.IsImpactedByFloat() ? PR_TRUE : PR_FALSE;
    aLine-&gt;SetLineIsImpactedByFloat(isImpacted);
    nsRect availSpace;
    aState.ComputeBlockAvailSpace(frame, display, availSpace);
    
    <comment type="line">// Now put the Y coordinate back to the top of the top-margin +</comment>
    <comment type="line">// clearance, and flow the block.</comment>
    aState.mY -= topMargin;
    availSpace.y -= topMargin;
    if (NS_UNCONSTRAINEDSIZE != availSpace.height) {
      availSpace.height += topMargin;
    }
    
    <comment type="line">// keep track of the last overflow float in case we need to undo any new additions</comment>
    nsIFrame* lastPlaceholder = aState.mOverflowPlaceholders.LastChild();
    
    <comment type="line">// Reflow the block into the available space</comment>
    nsMargin computedOffsets;
    <comment type="line">// construct the html reflow state for the block. ReflowBlock </comment>
    <comment type="line">// will initialize it</comment>
    nsHTMLReflowState blockHtmlRS(aState.mPresContext, aState.mReflowState, frame, 
                                  nsSize(availSpace.width, availSpace.height));
    blockHtmlRS.mFlags.mHasClearance = aLine-&gt;HasClearance();
    
    nsSpaceManager::SavedState spaceManagerState;
    if (mayNeedRetry) {
      blockHtmlRS.mDiscoveredClearance = &amp;clearanceFrame;
      aState.mSpaceManager-&gt;PushState(&amp;spaceManagerState);
    } else if (!applyTopMargin) {
      blockHtmlRS.mDiscoveredClearance = aState.mReflowState.mDiscoveredClearance;
    }
    
    nsReflowStatus frameReflowStatus = NS_FRAME_COMPLETE;
    rv = brc.ReflowBlock(availSpace, applyTopMargin, aState.mPrevBottomMargin,
                         clearance, aState.IsAdjacentWithTop(), computedOffsets,
                         aLine.get(), blockHtmlRS, frameReflowStatus, aState);

    <comment type="line">// If this was a second-pass reflow and the block's vertical position</comment>
    <comment type="line">// changed, invalidates from the first pass might have happened in the</comment>
    <comment type="line">// wrong places.  Invalidate the entire overflow rect at the new position.</comment>
    if (!mayNeedRetry &amp;&amp; clearanceFrame &amp;&amp;
        frame-&gt;GetRect().y != passOriginalY) {
      Invalidate(frame-&gt;GetOverflowRect() + frame-&gt;GetPosition());
    }
    
    NS_ENSURE_SUCCESS(rv, rv);
    
    if (mayNeedRetry &amp;&amp; clearanceFrame) {
      UndoSplitPlaceholders(aState, lastPlaceholder);
      aState.mSpaceManager-&gt;PopState(&amp;spaceManagerState);
      aState.mY = startingY;
      aState.mPrevBottomMargin = incomingMargin;
      continue;
    }
    
    aState.mPrevChild = frame;
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REFLOW_STATUS_COVERAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    RecordReflowStatus(PR_TRUE, frameReflowStatus);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    if (NS_INLINE_IS_BREAK_BEFORE(frameReflowStatus)) {
      <comment type="line">// None of the child block fits.</comment>
      UndoSplitPlaceholders(aState, lastPlaceholder);
      PushLines(aState, aLine.prev());
      *aKeepReflowGoing = PR_FALSE;
      NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
    }
    else {
      <comment type="line">// Note: line-break-after a block is a nop</comment>
      
      <comment type="line">// Try to place the child block.</comment>
      <comment type="line">// Don't force the block to fit if we have positive clearance, because</comment>
      <comment type="line">// pushing it to the next page would give it more room.</comment>
      <comment type="line">// Don't force the block to fit if it's impacted by a float. If it is,</comment>
      <comment type="line">// then pushing it to the next page would give it more room. Note that</comment>
      <comment type="line">// isImpacted doesn't include impact from the block's own floats.</comment>
      PRBool forceFit = aState.IsAdjacentWithTop() &amp;&amp; clearance &lt;= 0 &amp;&amp;
        !isImpacted;
      nsCollapsingMargin collapsedBottomMargin;
      nsRect combinedArea(0,0,0,0);
      *aKeepReflowGoing = brc.PlaceBlock(blockHtmlRS, forceFit, aLine.get(),
                                         computedOffsets, collapsedBottomMargin,
                                         aLine-&gt;mBounds, combinedArea, frameReflowStatus);
      if (aLine-&gt;SetCarriedOutBottomMargin(collapsedBottomMargin)) {
        line_iterator nextLine = aLine;
        ++nextLine;
        if (nextLine != end_lines()) {
          nextLine-&gt;MarkPreviousMarginDirty();
        }
      }
      
      aLine-&gt;SetCombinedArea(combinedArea);
      if (*aKeepReflowGoing) {
        <comment type="line">// Some of the child block fit</comment>
        
        <comment type="line">// Advance to new Y position</comment>
        nscoord newY = aLine-&gt;mBounds.YMost();
        aState.mY = newY;
        
        <comment type="line">// Continue the block frame now if it didn't completely fit in</comment>
        <comment type="line">// the available space.</comment>
        if (!NS_FRAME_IS_FULLY_COMPLETE(frameReflowStatus)) {
          PRBool madeContinuation;
          rv = CreateContinuationFor(aState, nsnull, frame, madeContinuation);
          NS_ENSURE_SUCCESS(rv, rv);
          
          nsIFrame* nextFrame = frame-&gt;GetNextInFlow();
          NS_ASSERTION(nextFrame, "We're supposed to have a next-in-flow by now");
          
          if (NS_FRAME_IS_NOT_COMPLETE(frameReflowStatus)) {
            <comment type="line">// If nextFrame used to be an overflow container, make it a normal block</comment>
            if (!madeContinuation &amp;&amp;
                (NS_FRAME_IS_OVERFLOW_CONTAINER &amp; nextFrame-&gt;GetStateBits())) {
              aState.mOverflowTracker.Finish(frame);
              nsContainerFrame* parent =
                static_cast&lt;nsContainerFrame*&gt;(nextFrame-&gt;GetParent());
              rv = parent-&gt;StealFrame(aState.mPresContext, nextFrame);
              NS_ENSURE_SUCCESS(rv, rv);
              if (parent != this)
                ReparentFrame(nextFrame, parent, this);
              nextFrame-&gt;SetNextSibling(frame-&gt;GetNextSibling());
              frame-&gt;SetNextSibling(nextFrame);
              madeContinuation = PR_TRUE; <comment type="line">// needs to be added to mLines</comment>
              nextFrame-&gt;RemoveStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
              frameReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
            }

            <comment type="line">// Push continuation to a new line, but only if we actually made one.</comment>
            if (madeContinuation) {
              nsLineBox* line = aState.NewLineBox(nextFrame, 1, PR_TRUE);
              NS_ENSURE_TRUE(line, NS_ERROR_OUT_OF_MEMORY);
              mLines.after_insert(aLine, line);
            }

            PushLines(aState, aLine);
            NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);

            <comment type="line">// If we need to reflow the continuation of the block child,</comment>
            <comment type="line">// then we'd better reflow our continuation</comment>
            if (frameReflowStatus &amp; NS_FRAME_REFLOW_NEXTINFLOW) {
              aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
              <comment type="line">// We also need to make that continuation's line dirty so</comment>
              <comment type="line">// it gets reflowed when we reflow our next in flow. The</comment>
              <comment type="line">// nif's line must always be either a line of the nif's</comment>
              <comment type="line">// parent block (only if we didn't make a continuation) or</comment>
              <comment type="line">// else one of our own overflow lines. In the latter case</comment>
              <comment type="line">// the line is already marked dirty, so just handle the</comment>
              <comment type="line">// first case.</comment>
              if (!madeContinuation) {
                nsBlockFrame* nifBlock = static_cast&lt;nsBlockFrame*&gt;(nextFrame-&gt;GetParent());
                NS_ASSERTION(nifBlock-&gt;GetType() == nsGkAtoms::blockFrame
                             || nifBlock-&gt;GetType() == nsGkAtoms::areaFrame,
                             "A block's child's next in flow's parent must be a block!");
                for (line_iterator line = nifBlock-&gt;begin_lines(),
                     line_end = nifBlock-&gt;end_lines(); line != line_end; ++line) {
                  if (line-&gt;Contains(nextFrame)) {
                    line-&gt;MarkDirty();
                    break;
                  }
                }
              }
            }
            *aKeepReflowGoing = PR_FALSE;
            
            <comment type="line">// The bottom margin for a block is only applied on the last</comment>
            <comment type="line">// flow block. Since we just continued the child block frame,</comment>
            <comment type="line">// we know that line-&gt;mFirstChild is not the last flow block</comment>
            <comment type="line">// therefore zero out the running margin value.</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_VERTICAL_MARGINS</name></cpp:ifdef>
            ListTag(stdout);
            printf(": reflow incomplete, frame=");
            nsFrame::ListTag(stdout, frame);
            printf(" prevBottomMargin=%d, setting to zero\n",
                   aState.mPrevBottomMargin);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            aState.mPrevBottomMargin.Zero();
          }
          else { <comment type="line">// frame is complete but its overflow is not complete</comment>
            <comment type="line">// Disconnect the next-in-flow and put it in our overflow tracker</comment>
            if (!madeContinuation &amp;&amp;
                !(NS_FRAME_IS_OVERFLOW_CONTAINER &amp; nextFrame-&gt;GetStateBits())) {
              <comment type="line">// It already exists, but as a normal next-in-flow, so we need</comment>
              <comment type="line">// to dig it out of the child lists.</comment>
              nsContainerFrame* parent = static_cast&lt;nsContainerFrame*&gt;
                                           (nextFrame-&gt;GetParent());
              rv = parent-&gt;StealFrame(aState.mPresContext, nextFrame);
              NS_ENSURE_SUCCESS(rv, rv);
            }
            else if (madeContinuation) {
              frame-&gt;SetNextSibling(nextFrame-&gt;GetNextSibling());
              nextFrame-&gt;SetNextSibling(nsnull);
            }

            <comment type="line">// Put it in our overflow list</comment>
            aState.mOverflowTracker.Insert(nextFrame, frameReflowStatus);
            aState.mReflowStatus = NS_FRAME_MERGE_INCOMPLETE(frameReflowStatus,
                                     aState.mReflowStatus);

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_VERTICAL_MARGINS</name></cpp:ifdef>
            ListTag(stdout);
            printf(": reflow complete but overflow incomplete for ");
            nsFrame::ListTag(stdout, frame);
            printf(" prevBottomMargin=%d collapsedBottomMargin=%d\n",
                   aState.mPrevBottomMargin, collapsedBottomMargin.get());
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            aState.mPrevBottomMargin = collapsedBottomMargin;
          }
        }
        else { <comment type="line">// frame is fully complete</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_VERTICAL_MARGINS</name></cpp:ifdef>
          ListTag(stdout);
          printf(": reflow complete for ");
          nsFrame::ListTag(stdout, frame);
          printf(" prevBottomMargin=%d collapsedBottomMargin=%d\n",
                 aState.mPrevBottomMargin, collapsedBottomMargin.get());
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          aState.mPrevBottomMargin = collapsedBottomMargin;
        }
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_VERTICAL_MARGINS</name></cpp:ifdef>
        ListTag(stdout);
        printf(": frame=");
        nsFrame::ListTag(stdout, frame);
        printf(" carriedOutBottomMargin=%d collapsedBottomMargin=%d =&gt; %d\n",
               brc.GetCarriedOutBottomMargin(), collapsedBottomMargin.get(),
               aState.mPrevBottomMargin);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }
      else {
        <comment type="line">// None of the block fits. Determine the correct reflow status.</comment>
        if (aLine == mLines.front()) {
          <comment type="line">// If it's our very first line then we need to be pushed to</comment>
          <comment type="line">// our parents next-in-flow. Therefore, return break-before</comment>
          <comment type="line">// status for our reflow status.</comment>
          aState.mReflowStatus = NS_INLINE_LINE_BREAK_BEFORE();
        }
        else {
          <comment type="line">// Push the line that didn't fit and any lines that follow it</comment>
          <comment type="line">// to our next-in-flow.</comment>
          UndoSplitPlaceholders(aState, lastPlaceholder);
          PushLines(aState, aLine.prev());
          NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
        }
      }
    }
    break; <comment type="line">// out of the reflow retry loop</comment>
  }

  <comment type="line">// Now that we've got its final position all figured out, position any child</comment>
  <comment type="line">// views it may have.  Note that the case when frame has a view got handled</comment>
  <comment type="line">// by FinishReflowChild, but that function didn't have the coordinates needed</comment>
  <comment type="line">// to correctly decide whether to reposition child views.</comment>
  if (originalPosition != frame-&gt;GetPosition() &amp;&amp; !frame-&gt;HasView()) {
    nsContainerFrame::PositionChildViews(frame);
  }
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  VerifyLines(PR_TRUE);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  return rv;
}

nsresult
nsBlockFrame::ReflowInlineFrames(nsBlockReflowState&amp; aState,
                                 line_iterator aLine,
                                 PRBool* aKeepReflowGoing)
{
  nsresult rv = NS_OK;
  *aKeepReflowGoing = PR_TRUE;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  PRInt32 spins = 0;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  LineReflowStatus lineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
  PRBool movedPastFloat = PR_FALSE;
  do {
    PRBool allowPullUp = PR_TRUE;
    nsIContent* forceBreakInContent = nsnull;
    PRInt32 forceBreakOffset = -1;
    do {
      nsSpaceManager::SavedState spaceManagerState;
      aState.mReflowState.mSpaceManager-&gt;PushState(&amp;spaceManagerState);

      <comment type="line">// Once upon a time we allocated the first 30 nsLineLayout objects</comment>
      <comment type="line">// on the stack, and then we switched to the heap.  At that time</comment>
      <comment type="line">// these objects were large (1100 bytes on a 32 bit system).</comment>
      <comment type="line">// Then the nsLineLayout object was shrunk to 156 bytes by</comment>
      <comment type="line">// removing some internal buffers.  Given that it is so much</comment>
      <comment type="line">// smaller, the complexity of 2 different ways of allocating</comment>
      <comment type="line">// no longer makes sense.  Now we always allocate on the stack.</comment>
      nsLineLayout lineLayout(aState.mPresContext,
                              aState.mReflowState.mSpaceManager,
                              &amp;aState.mReflowState, &amp;aLine);
      lineLayout.Init(&amp;aState, aState.mMinLineHeight, aState.mLineNumber);
      if (forceBreakInContent) {
        lineLayout.ForceBreakAtPosition(forceBreakInContent, forceBreakOffset);
      }
      rv = DoReflowInlineFrames(aState, lineLayout, aLine,
                                aKeepReflowGoing, &amp;lineReflowStatus,
                                allowPullUp);
      lineLayout.EndLineReflow();

      if (LINE_REFLOW_REDO_NO_PULL == lineReflowStatus ||
          LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus) {
        if (lineLayout.NeedsBackup()) {
          NS_ASSERTION(!forceBreakInContent, "Backing up twice; this should never be necessary");
          <comment type="line">// If there is no saved break position, then this will set</comment>
          <comment type="line">// set forceBreakInContent to null and we won't back up, which is</comment>
          <comment type="line">// correct.</comment>
          forceBreakInContent = lineLayout.GetLastOptionalBreakPosition(&amp;forceBreakOffset);
        } else {
          forceBreakInContent = nsnull;
        }
        <comment type="line">// restore the space manager state</comment>
        aState.mReflowState.mSpaceManager-&gt;PopState(&amp;spaceManagerState);
        <comment type="line">// Clear out float lists</comment>
        aState.mCurrentLineFloats.DeleteAll();
        aState.mBelowCurrentLineFloats.DeleteAll();
      }
      
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      spins++;
      if (1000 == spins) {
        ListTag(stdout);
        printf(": yikes! spinning on a line over 1000 times!\n");
        NS_ABORT();
      }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="line">// Don't allow pullup on a subsequent LINE_REFLOW_REDO_NO_PULL pass</comment>
      allowPullUp = PR_FALSE;
    } while (NS_SUCCEEDED(rv) &amp;&amp; LINE_REFLOW_REDO_NO_PULL == lineReflowStatus);

    if (LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus) {
      movedPastFloat = PR_TRUE;
    }
  } while (NS_SUCCEEDED(rv) &amp;&amp; LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus);

  <comment type="line">// If we did at least one REDO_FOR_FLOAT, then the line did not fit next to some float.</comment>
  <comment type="line">// Mark it as impacted by a float, even if it no longer is next to a float.</comment>
  if (movedPastFloat) {
    aLine-&gt;SetLineIsImpactedByFloat(PR_TRUE);
  }

  return rv;
}

<comment type="line">// If at least one float on the line was complete, not at the top of</comment>
<comment type="line">// page, but was truncated, then restore the overflow floats to what</comment>
<comment type="line">// they were before and push the line.  The floats that will be removed</comment>
<comment type="line">// from the list aren't yet known by the block's next in flow.  </comment>
void
nsBlockFrame::PushTruncatedPlaceholderLine(nsBlockReflowState&amp; aState,
                                           line_iterator       aLine,
                                           nsIFrame*           aLastPlaceholder,
                                           PRBool&amp;             aKeepReflowGoing)
{
  UndoSplitPlaceholders(aState, aLastPlaceholder);

  line_iterator prevLine = aLine;
  --prevLine;
  PushLines(aState, prevLine);
  aKeepReflowGoing = PR_FALSE;
  NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
static const char* LineReflowStatusNames[] = {
  "LINE_REFLOW_OK"</argument>, <argument>"LINE_REFLOW_STOP"</argument>, <argument>"LINE_REFLOW_REDO_NO_PULL"</argument>,
  <argument>"LINE_REFLOW_REDO_NEXT_BAND"</argument>, <argument>"LINE_REFLOW_TRUNCATED"
};
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

nsresult
nsBlockFrame::DoReflowInlineFrames(nsBlockReflowState&amp; aState,
                                   nsLineLayout&amp; aLineLayout,
                                   line_iterator aLine,
                                   PRBool* aKeepReflowGoing,
                                   LineReflowStatus* aLineReflowStatus,
                                   PRBool aAllowPullUp)
{
  <comment type="line">// Forget all of the floats on the line</comment>
  aLine-&gt;FreeFloats(aState.mFloatCacheFreeList);
  aState.mFloatCombinedArea.SetRect(0, 0, 0, 0);

  <comment type="line">// Setup initial coordinate system for reflowing the inline frames</comment>
  <comment type="line">// into. Apply a previous block frame's bottom margin first.</comment>
  if (ShouldApplyTopMargin(aState, aLine)) {
    aState.mY += aState.mPrevBottomMargin.get();
  }
  aState.GetAvailableSpace();
  PRBool impactedByFloats = aState.IsImpactedByFloat() ? PR_TRUE : PR_FALSE;
  aLine-&gt;SetLineIsImpactedByFloat(impactedByFloats);
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REALLY_NOISY_REFLOW</name></cpp:ifdef>
  printf("nsBlockFrame::DoReflowInlineFrames %p impacted = %d\n",
         this, impactedByFloats);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  const nsMargin&amp; borderPadding = aState.BorderPadding();
  nscoord x = aState.mAvailSpaceRect.x + borderPadding.left;
  nscoord availWidth = aState.mAvailSpaceRect.width;
  nscoord availHeight;
  if (aState.GetFlag(BRS_UNCONSTRAINEDHEIGHT)) {
    availHeight = NS_UNCONSTRAINEDSIZE;
  }
  else {
    <comment type="block">/* XXX get the height right! */</comment>
    availHeight = aState.mAvailSpaceRect.height;
  }

  <comment type="line">// Make sure to enable resize optimization before we call BeginLineReflow</comment>
  <comment type="line">// because it might get disabled there</comment>
  aLine-&gt;EnableResizeReflowOptimization();

  aLineLayout.BeginLineReflow(x, aState.mY,
                              availWidth, availHeight,
                              impactedByFloats,
                              PR_FALSE <comment type="block">/*XXX isTopOfPage*/</comment>);

  <comment type="line">// XXX Unfortunately we need to know this before reflowing the first</comment>
  <comment type="line">// inline frame in the line. FIX ME.</comment>
  if ((0 == aLineLayout.GetLineNumber()) &amp;&amp;
      (NS_BLOCK_HAS_FIRST_LETTER_STYLE &amp; mState)) {
    aLineLayout.SetFirstLetterStyleOK(PR_TRUE);
  }

  <comment type="line">// keep track of the last overflow float in case we need to undo any new additions</comment>
  nsIFrame* lastPlaceholder = aState.mOverflowPlaceholders.LastChild();

  <comment type="line">// Reflow the frames that are already on the line first</comment>
  nsresult rv = NS_OK;
  LineReflowStatus lineReflowStatus = LINE_REFLOW_OK;
  PRInt32 i;
  nsIFrame* frame = aLine-&gt;mFirstChild;

  <comment type="line">// Determine whether this is a line of placeholders for out-of-flow</comment>
  <comment type="line">// continuations</comment>
  PRBool isContinuingPlaceholders = PR_FALSE;

  if (impactedByFloats) {
    <comment type="line">// There is a soft break opportunity at the start of the line, because</comment>
    <comment type="line">// we can always move this line down below float(s).</comment>
    if (aLineLayout.NotifyOptionalBreakPosition(frame-&gt;GetContent(), 0, PR_TRUE)) {
      lineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
    }
  }

  <comment type="line">// need to repeatedly call GetChildCount here, because the child</comment>
  <comment type="line">// count can change during the loop!</comment>
  for (i = 0; LINE_REFLOW_OK == lineReflowStatus &amp;&amp; i &lt; aLine-&gt;GetChildCount();
       i++, frame = frame-&gt;GetNextSibling()) {
    if (IsContinuationPlaceholder(frame)) {
      isContinuingPlaceholders = PR_TRUE;
    }
    rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
                           &amp;lineReflowStatus);
    NS_ENSURE_SUCCESS(rv, rv);
    if (LINE_REFLOW_OK != lineReflowStatus) {
      <comment type="line">// It is possible that one or more of next lines are empty</comment>
      <comment type="line">// (because of DeleteNextInFlowChild). If so, delete them now</comment>
      <comment type="line">// in case we are finished.</comment>
      ++aLine;
      while ((aLine != end_lines()) &amp;&amp; (0 == aLine-&gt;GetChildCount())) {
        <comment type="line">// XXX Is this still necessary now that DeleteNextInFlowChild</comment>
        <comment type="line">// uses DoRemoveFrame?</comment>
        nsLineBox *toremove = aLine;
        aLine = mLines.erase(aLine);
        NS_ASSERTION(nsnull == toremove-&gt;mFirstChild, "bad empty line");
        aState.FreeLineBox(toremove);
      }
      --aLine;

      if (LINE_REFLOW_TRUNCATED == lineReflowStatus) {
        <comment type="line">// Push the line with the truncated float </comment>
        PushTruncatedPlaceholderLine(aState, aLine, lastPlaceholder, *aKeepReflowGoing);
      }
    }
  }

  <comment type="line">// Don't pull up new frames into lines with continuation placeholders</comment>
  if (!isContinuingPlaceholders &amp;&amp; aAllowPullUp) {
    <comment type="line">// Pull frames and reflow them until we can't</comment>
    while (LINE_REFLOW_OK == lineReflowStatus) {
      rv = PullFrame(aState, aLine, frame);
      NS_ENSURE_SUCCESS(rv, rv);
      if (nsnull == frame) {
        break;
      }

      while (LINE_REFLOW_OK == lineReflowStatus) {
        PRInt32 oldCount = aLine-&gt;GetChildCount();
        rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
                               &amp;lineReflowStatus);
        NS_ENSURE_SUCCESS(rv, rv);
        if (aLine-&gt;GetChildCount() != oldCount) {
          <comment type="line">// We just created a continuation for aFrame AND its going</comment>
          <comment type="line">// to end up on this line (e.g. :first-letter</comment>
          <comment type="line">// situation). Therefore we have to loop here before trying</comment>
          <comment type="line">// to pull another frame.</comment>
          frame = frame-&gt;GetNextSibling();
        }
        else {
          break;
        }
      }
    }
  }

  <comment type="line">// We only need to backup if the line isn't going to be reflowed again anyway</comment>
  PRBool needsBackup = aLineLayout.NeedsBackup() &amp;&amp;
    (lineReflowStatus == LINE_REFLOW_STOP || lineReflowStatus == LINE_REFLOW_OK);
  if (needsBackup &amp;&amp; aLineLayout.HaveForcedBreakPosition()) {
  	NS_WARNING("We shouldn't be backing up more than once! "
               "Someone must have set a break opportunity beyond the available width, "
               "even though there were better break opportunities before it");
    needsBackup = PR_FALSE;
  }
  if (needsBackup) {
    <comment type="line">// We need to try backing up to before a text run</comment>
    PRInt32 offset;
    nsIContent* breakContent = aLineLayout.GetLastOptionalBreakPosition(&amp;offset);
    <comment type="line">// XXX It's possible, in fact not unusual, for the break opportunity to already</comment>
    <comment type="line">// be the end of the line. We should detect that and optimize to not</comment>
    <comment type="line">// re-do the line.</comment>
    if (breakContent) {
      <comment type="line">// We can back up!</comment>
      lineReflowStatus = LINE_REFLOW_REDO_NO_PULL;
    }
  } else {
    <comment type="line">// In case we reflow this line again, remember that we don't</comment>
    <comment type="line">// need to force any breaking</comment>
    aLineLayout.ClearOptionalBreakPosition();
  }

  if (LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus) {
    <comment type="line">// This happens only when we have a line that is impacted by</comment>
    <comment type="line">// floats and the first element in the line doesn't fit with</comment>
    <comment type="line">// the floats.</comment>
    <comment type="line">//</comment>
    <comment type="line">// What we do is to advance past the first float we find and</comment>
    <comment type="line">// then reflow the line all over again.</comment>
    NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aState.mAvailSpaceRect.height,
                 "unconstrained height on totally empty line");

    if (aState.mAvailSpaceRect.height &gt; 0) {
      NS_ASSERTION(aState.IsImpactedByFloat(),
                   "redo line on totally empty line with non-empty band...");
      aState.mY += aState.mAvailSpaceRect.height;
    } else {
      NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aState.mReflowState.availableHeight,
                   "We shouldn't be running out of height here");
      if (NS_UNCONSTRAINEDSIZE == aState.mReflowState.availableHeight) {
        <comment type="line">// just move it down a bit to try to get out of this mess</comment>
        aState.mY += 1;
      } else {
        <comment type="line">// There's nowhere to retry placing the line. Just treat it as if</comment>
        <comment type="line">// we placed the float but it was truncated so we need this line</comment>
        <comment type="line">// to go to the next page/column.</comment>
        lineReflowStatus = LINE_REFLOW_TRUNCATED;
        <comment type="line">// Push the line that didn't fit</comment>
        PushTruncatedPlaceholderLine(aState, aLine, lastPlaceholder,
                                     *aKeepReflowGoing);
      }
    }
      
    <comment type="line">// We don't want to advance by the bottom margin anymore (we did it</comment>
    <comment type="line">// once at the beginning of this function, which will just be called</comment>
    <comment type="line">// again), and we certainly don't want to go back if it's negative</comment>
    <comment type="line">// (infinite loop, bug 153429).</comment>
    aState.mPrevBottomMargin.Zero();

    <comment type="line">// XXX: a small optimization can be done here when paginating:</comment>
    <comment type="line">// if the new Y coordinate is past the end of the block then</comment>
    <comment type="line">// push the line and return now instead of later on after we are</comment>
    <comment type="line">// past the float.</comment>
  }
  else if (LINE_REFLOW_REDO_NO_PULL == lineReflowStatus) {
    <comment type="line">// We don't want to advance by the bottom margin anymore (we did it</comment>
    <comment type="line">// once at the beginning of this function, which will just be called</comment>
    <comment type="line">// again), and we certainly don't want to go back if it's negative</comment>
    <comment type="line">// (infinite loop, bug 153429).</comment>
    aState.mPrevBottomMargin.Zero();
  }
  else if (LINE_REFLOW_TRUNCATED != lineReflowStatus) {
    <comment type="line">// If we are propagating out a break-before status then there is</comment>
    <comment type="line">// no point in placing the line.</comment>
    if (!NS_INLINE_IS_BREAK_BEFORE(aState.mReflowStatus)) {
      if (PlaceLine(aState, aLineLayout, aLine, aKeepReflowGoing)) {
        UndoSplitPlaceholders(aState, lastPlaceholder); <comment type="line">// undo since we pushed the current line</comment>
      }
    }
  }
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  if (gNoisyReflow) {
    printf("Line reflow status = %s\n", LineReflowStatusNames[lineReflowStatus]);
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  *aLineReflowStatus = lineReflowStatus;

  return rv;
}

<comment type="block" format="doxygen">/**
 * Reflow an inline frame. The reflow status is mapped from the frames
 * reflow status to the lines reflow status (not to our reflow status).
 * The line reflow status is simple: PR_TRUE means keep placing frames
 * on the line; PR_FALSE means don't (the line is done). If the line
 * has some sort of breaking affect then aLine's break-type will be set
 * to something other than NS_STYLE_CLEAR_NONE.
 */</comment>
nsresult
nsBlockFrame::ReflowInlineFrame(nsBlockReflowState&amp; aState,
                                nsLineLayout&amp; aLineLayout,
                                line_iterator aLine,
                                nsIFrame* aFrame,
                                LineReflowStatus* aLineReflowStatus)
{
  NS_ENSURE_ARG_POINTER(aFrame);
  
  *aLineReflowStatus = LINE_REFLOW_OK;

  <comment type="line">// If it's currently ok to be reflowing in first-letter style then</comment>
  <comment type="line">// we must be about to reflow a frame that has first-letter style.</comment>
  PRBool reflowingFirstLetter = aLineLayout.GetFirstLetterStyleOK();
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_FIRST_LETTER</name></cpp:ifdef>
  ListTag(stdout);
  printf(": reflowing ");
  nsFrame::ListTag(stdout, aFrame);
  printf(" reflowingFirstLetter=%s\n", reflowingFirstLetter ? "on" : "off");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Reflow the inline frame</comment>
  nsReflowStatus frameReflowStatus;
  PRBool         pushedFrame;
  nsresult rv = aLineLayout.ReflowFrame(aFrame, frameReflowStatus,
                                        nsnull, pushedFrame);
  NS_ENSURE_SUCCESS(rv, rv);

  if (frameReflowStatus &amp; NS_FRAME_REFLOW_NEXTINFLOW) {
    <comment type="line">// we need to ensure that the frame's nextinflow gets reflowed.</comment>
    aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
    nsBlockFrame* ourNext = static_cast&lt;nsBlockFrame*&gt;(GetNextInFlow());
    if (ourNext &amp;&amp; aFrame-&gt;GetNextInFlow()) {
      line_iterator f = ourNext-&gt;FindLineFor(aFrame-&gt;GetNextInFlow());
      if (f != ourNext-&gt;end_lines()) {
        f-&gt;MarkDirty();
      }
    }
  }

  NS_ENSURE_SUCCESS(rv, rv);
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REALLY_NOISY_REFLOW_CHILD</name></cpp:ifdef>
  nsFrame::ListTag(stdout, aFrame);
  printf(": status=%x\n", frameReflowStatus);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REFLOW_STATUS_COVERAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  RecordReflowStatus(PR_FALSE, frameReflowStatus);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Send post-reflow notification</comment>
  aState.mPrevChild = aFrame;

   <comment type="block">/* XXX
      This is where we need to add logic to handle some odd behavior.
      For one thing, we should usually place at least one thing next
      to a left float, even when that float takes up all the width on a line.
      see bug 22496
   */</comment>

  <comment type="line">// Process the child frames reflow status. There are 5 cases:</comment>
  <comment type="line">// complete, not-complete, break-before, break-after-complete,</comment>
  <comment type="line">// break-after-not-complete. There are two situations: we are a</comment>
  <comment type="line">// block or we are an inline. This makes a total of 10 cases</comment>
  <comment type="line">// (fortunately, there is some overlap).</comment>
  aLine-&gt;SetBreakTypeAfter(NS_STYLE_CLEAR_NONE);
  if (NS_INLINE_IS_BREAK(frameReflowStatus) || 
      (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType)) {
    <comment type="line">// Always abort the line reflow (because a line break is the</comment>
    <comment type="line">// minimal amount of break we do).</comment>
    *aLineReflowStatus = LINE_REFLOW_STOP;

    <comment type="line">// XXX what should aLine's break-type be set to in all these cases?</comment>
    PRUint8 breakType = NS_INLINE_GET_BREAK_TYPE(frameReflowStatus);
    NS_ASSERTION((NS_STYLE_CLEAR_NONE != breakType) || 
                 (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType), "bad break type");
    NS_ASSERTION(NS_STYLE_CLEAR_PAGE != breakType, "no page breaks yet");

    if (NS_INLINE_IS_BREAK_BEFORE(frameReflowStatus)) {
      <comment type="line">// Break-before cases.</comment>
      if (aFrame == aLine-&gt;mFirstChild) {
        <comment type="line">// If we break before the first frame on the line then we must</comment>
        <comment type="line">// be trying to place content where there's no room (e.g. on a</comment>
        <comment type="line">// line with wide floats). Inform the caller to reflow the</comment>
        <comment type="line">// line after skipping past a float.</comment>
        *aLineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
      }
      else {
        <comment type="line">// It's not the first child on this line so go ahead and split</comment>
        <comment type="line">// the line. We will see the frame again on the next-line.</comment>
        rv = SplitLine(aState, aLineLayout, aLine, aFrame, aLineReflowStatus);
        NS_ENSURE_SUCCESS(rv, rv);

        <comment type="line">// If we're splitting the line because the frame didn't fit and it</comment>
        <comment type="line">// was pushed, then mark the line as having word wrapped. We need to</comment>
        <comment type="line">// know that if we're shrink wrapping our width</comment>
        if (pushedFrame) {
          aLine-&gt;SetLineWrapped(PR_TRUE);
        }
      }
    }
    else {
      <comment type="line">// If a float split and its prev-in-flow was followed by a &lt;BR&gt;, then combine </comment>
      <comment type="line">// the &lt;BR&gt;'s break type with the inline's break type (the inline will be the very </comment>
      <comment type="line">// next frame after the split float).</comment>
      if (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType) {
        breakType = nsLayoutUtils::CombineBreakType(breakType,
                                                    aState.mFloatBreakType);
        aState.mFloatBreakType = NS_STYLE_CLEAR_NONE;
      }
      <comment type="line">// Break-after cases</comment>
      if (breakType == NS_STYLE_CLEAR_LINE) {
        if (!aLineLayout.GetLineEndsInBR()) {
          breakType = NS_STYLE_CLEAR_NONE;
        }
      }
      aLine-&gt;SetBreakTypeAfter(breakType);
      if (NS_FRAME_IS_NOT_COMPLETE(frameReflowStatus)) {
        <comment type="line">// Create a continuation for the incomplete frame. Note that the</comment>
        <comment type="line">// frame may already have a continuation.</comment>
        PRBool madeContinuation;
        rv = CreateContinuationFor(aState, aLine, aFrame, madeContinuation);
        NS_ENSURE_SUCCESS(rv, rv);
        if (!aLineLayout.GetLineEndsInBR()) {
          <comment type="line">// Remember that the line has wrapped</comment>
          aLine-&gt;SetLineWrapped(PR_TRUE);
        }
      }

      <comment type="line">// Split line, but after the frame just reflowed</comment>
      rv = SplitLine(aState, aLineLayout, aLine, aFrame-&gt;GetNextSibling(), aLineReflowStatus);
      NS_ENSURE_SUCCESS(rv, rv);

      if (NS_FRAME_IS_NOT_COMPLETE(frameReflowStatus) ||
          (NS_INLINE_IS_BREAK_AFTER(frameReflowStatus) &amp;&amp;
           !aLineLayout.GetLineEndsInBR())) {
        <comment type="line">// Mark next line dirty in case SplitLine didn't end up</comment>
        <comment type="line">// pushing any frames.</comment>
        nsLineList_iterator next = aLine.next();
        if (next != end_lines() &amp;&amp; !next-&gt;IsBlock()) {
          next-&gt;MarkDirty();
        }
      }
    }
  }
  else if (NS_FRAME_IS_NOT_COMPLETE(frameReflowStatus)) {
    <comment type="line">// Frame is not-complete, no special breaking status</comment>

    nsIAtom* frameType = aFrame-&gt;GetType();

    <comment type="line">// Create a continuation for the incomplete frame. Note that the</comment>
    <comment type="line">// frame may already have a continuation.</comment>
    PRBool madeContinuation;
    rv = (nsGkAtoms::placeholderFrame == frameType)
         ? SplitPlaceholder(aState, aFrame)
         : CreateContinuationFor(aState, aLine, aFrame, madeContinuation);
    NS_ENSURE_SUCCESS(rv, rv);

    <comment type="line">// Remember that the line has wrapped</comment>
    if (!aLineLayout.GetLineEndsInBR()) {
      aLine-&gt;SetLineWrapped(PR_TRUE);
    }
    
    <comment type="line">// If we are reflowing the first letter frame or a placeholder then </comment>
    <comment type="line">// don't split the line and don't stop the line reflow...</comment>
    PRBool splitLine = !reflowingFirstLetter &amp;&amp; 
      nsGkAtoms::placeholderFrame != frameType;
    if (reflowingFirstLetter) {
      if ((nsGkAtoms::inlineFrame == frameType) ||
          (nsGkAtoms::lineFrame == frameType)) {
        splitLine = PR_TRUE;
      }
    }

    if (splitLine) {
      <comment type="line">// Split line after the current frame</comment>
      *aLineReflowStatus = LINE_REFLOW_STOP;
      rv = SplitLine(aState, aLineLayout, aLine, aFrame-&gt;GetNextSibling(), aLineReflowStatus);
      NS_ENSURE_SUCCESS(rv, rv);

      <comment type="line">// Mark next line dirty in case SplitLine didn't end up</comment>
      <comment type="line">// pushing any frames.</comment>
      nsLineList_iterator next = aLine.next();
      if (next != end_lines() &amp;&amp; !next-&gt;IsBlock()) {
        next-&gt;MarkDirty();
      }
    }
  }
  else if (NS_FRAME_IS_TRUNCATED(frameReflowStatus)) {
    <comment type="line">// if the frame is a placeholder and was complete but truncated (and not at the top</comment>
    <comment type="line">// of page), the entire line will be pushed to give it another chance to not truncate.</comment>
    if (nsGkAtoms::placeholderFrame == aFrame-&gt;GetType()) {
      *aLineReflowStatus = LINE_REFLOW_TRUNCATED;
    }
  }  

  return NS_OK;
}

<comment type="block" format="doxygen">/**
 * Create a continuation, if necessary, for aFrame. Place it in aLine
 * if aLine is not null. Set aMadeNewFrame to PR_TRUE if a new frame is created.
 */</comment>
nsresult
nsBlockFrame::CreateContinuationFor(nsBlockReflowState&amp; aState,
                                    nsLineBox*          aLine,
                                    nsIFrame*           aFrame,
                                    PRBool&amp;             aMadeNewFrame)
{
  aMadeNewFrame = PR_FALSE;
  nsresult rv;
  nsIFrame* nextInFlow;
  rv = CreateNextInFlow(aState.mPresContext, this, aFrame, nextInFlow);
  NS_ENSURE_SUCCESS(rv, rv);
  if (nsnull != nextInFlow) {
    aMadeNewFrame = PR_TRUE;
    if (aLine) { 
      aLine-&gt;SetChildCount(aLine-&gt;GetChildCount() + 1);
    }
  }
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  VerifyLines(PR_FALSE);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  return rv;
}

nsresult
nsBlockFrame::SplitPlaceholder(nsBlockReflowState&amp; aState,
                               nsIFrame*           aPlaceholder)
{
  nsIFrame* nextInFlow;
  nsresult rv = CreateNextInFlow(aState.mPresContext, this, aPlaceholder, nextInFlow);
  NS_ENSURE_SUCCESS(rv, rv);

  if (!nextInFlow) {
    <comment type="line">// Next in flow was not created because it already exists.</comment>
    return NS_OK;
  }

  <comment type="line">// put the sibling list back to what it was before the continuation was created</comment>
  nsIFrame *contFrame = aPlaceholder-&gt;GetNextSibling();
  nsIFrame *next = contFrame-&gt;GetNextSibling();
  aPlaceholder-&gt;SetNextSibling(next);
  contFrame-&gt;SetNextSibling(nsnull);
  
  NS_ASSERTION(IsContinuationPlaceholder(contFrame),
               "Didn't create the right kind of frame");

  <comment type="line">// The new out of flow frame does not get put anywhere; the out-of-flows</comment>
  <comment type="line">// for placeholders in mOverflowPlaceholders are not kept in any child list</comment>
  aState.mOverflowPlaceholders.AppendFrame(this, contFrame);
  return NS_OK;
}

static nsFloatCache*
GetLastFloat(nsLineBox* aLine)
{
  nsFloatCache* fc = aLine-&gt;GetFirstFloat();
  while (fc &amp;&amp; fc-&gt;Next()) {
    fc = fc-&gt;Next();
  }
  return fc;
}

static PRBool
CheckPlaceholderInLine(nsIFrame* aBlock, nsLineBox* aLine, nsFloatCache* aFC)
{
  if (!aFC)
    return PR_TRUE;
  for (nsIFrame* f = aFC-&gt;mPlaceholder; f; f = f-&gt;GetParent()) {
    if (f-&gt;GetParent() == aBlock)
      return aLine-&gt;Contains(f);
  }
  NS_ASSERTION(PR_FALSE, "aBlock is not an ancestor of aFrame!");
  return PR_TRUE;
}

nsresult
nsBlockFrame::SplitLine(nsBlockReflowState&amp; aState,
                        nsLineLayout&amp; aLineLayout,
                        line_iterator aLine,
                        nsIFrame* aFrame,
                        LineReflowStatus* aLineReflowStatus)
{
  NS_ABORT_IF_FALSE(aLine-&gt;IsInline(), "illegal SplitLine on block line");

  PRInt32 pushCount = aLine-&gt;GetChildCount() - aLineLayout.GetCurrentSpanCount();
  NS_ABORT_IF_FALSE(pushCount &gt;= 0, "bad push count"); 

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  if (gNoisyReflow) {
    nsFrame::IndentBy(stdout, gNoiseIndent);
    printf("split line: from line=%p pushCount=%d aFrame=",
           static_cast&lt;void*&gt;(aLine.get()), pushCount);
    if (aFrame) {
      nsFrame::ListTag(stdout, aFrame);
    }
    else {
      printf("(null)");
    }
    printf("\n");
    if (gReallyNoisyReflow) {
      aLine-&gt;List(stdout, gNoiseIndent+1);
    }
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  if (0 != pushCount) {
    NS_ABORT_IF_FALSE(aLine-&gt;GetChildCount() &gt; pushCount, "bad push");
    NS_ABORT_IF_FALSE(nsnull != aFrame, "whoops");
    NS_ASSERTION(nsFrameList(aFrame).GetLength() &gt;= pushCount,
                 "Not enough frames to push");

    <comment type="line">// Put frames being split out into their own line</comment>
    nsLineBox* newLine = aState.NewLineBox(aFrame, pushCount, PR_FALSE);
    if (!newLine) {
      return NS_ERROR_OUT_OF_MEMORY;
    }
    mLines.after_insert(aLine, newLine);
    aLine-&gt;SetChildCount(aLine-&gt;GetChildCount() - pushCount);
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    if (gReallyNoisyReflow) {
      newLine-&gt;List(stdout, gNoiseIndent+1);
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Let line layout know that some frames are no longer part of its</comment>
    <comment type="line">// state.</comment>
    aLineLayout.SplitLineTo(aLine-&gt;GetChildCount());

    <comment type="line">// If floats have been placed whose placeholders have been pushed to the new</comment>
    <comment type="line">// line, we need to reflow the old line again. We don't want to look at the</comment>
    <comment type="line">// frames in the new line, because as a large paragraph is laid out the </comment>
    <comment type="line">// we'd get O(N^2) performance. So instead we just check that the last</comment>
    <comment type="line">// float and the last below-current-line float are still in aLine.</comment>
    if (!CheckPlaceholderInLine(this, aLine, GetLastFloat(aLine)) ||
        !CheckPlaceholderInLine(this, aLine, aState.mBelowCurrentLineFloats.Tail())) {
      *aLineReflowStatus = LINE_REFLOW_REDO_NO_PULL;
    }

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    VerifyLines(PR_TRUE);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }
  return NS_OK;
}

PRBool
nsBlockFrame::ShouldJustifyLine(nsBlockReflowState&amp; aState,
                                line_iterator aLine)
{
  while (++aLine != end_lines()) {
    <comment type="line">// There is another line</comment>
    if (0 != aLine-&gt;GetChildCount()) {
      <comment type="line">// If the next line is a block line then we must not justify</comment>
      <comment type="line">// this line because it means that this line is the last in a</comment>
      <comment type="line">// group of inline lines.</comment>
      return !aLine-&gt;IsBlock();
    }
    <comment type="line">// The next line is empty, try the next one</comment>
  }

  <comment type="line">// XXX Not sure about this part</comment>
  <comment type="line">// Try our next-in-flows lines to answer the question</comment>
  nsBlockFrame* nextInFlow = (nsBlockFrame*) GetNextInFlow();
  while (nsnull != nextInFlow) {
    for (line_iterator line = nextInFlow-&gt;begin_lines(),
                   line_end = nextInFlow-&gt;end_lines();
         line != line_end;
         ++line)
    {
      if (0 != line-&gt;GetChildCount())
        return !line-&gt;IsBlock();
    }
    nextInFlow = (nsBlockFrame*) nextInFlow-&gt;GetNextInFlow();
  }

  <comment type="line">// This is the last line - so don't allow justification</comment>
  return PR_FALSE;
}

PRBool
nsBlockFrame::PlaceLine(nsBlockReflowState&amp; aState,
                        nsLineLayout&amp;       aLineLayout,
                        line_iterator       aLine,
                        PRBool*             aKeepReflowGoing)
{
  <comment type="line">// Trim extra white-space from the line before placing the frames</comment>
  aLineLayout.TrimTrailingWhiteSpace();

  <comment type="line">// Vertically align the frames on this line.</comment>
  <comment type="line">//</comment>
  <comment type="line">// According to the CSS2 spec, section 12.6.1, the "marker" box</comment>
  <comment type="line">// participates in the height calculation of the list-item box's</comment>
  <comment type="line">// first line box.</comment>
  <comment type="line">//</comment>
  <comment type="line">// There are exactly two places a bullet can be placed: near the</comment>
  <comment type="line">// first or second line. It's only placed on the second line in a</comment>
  <comment type="line">// rare case: an empty first line followed by a second line that</comment>
  <comment type="line">// contains a block (example: &lt;LI&gt;\n&lt;P&gt;... ).</comment>
  <comment type="line">//</comment>
  <comment type="line">// For this code, only the first case is possible because this</comment>
  <comment type="line">// method is used for placing a line of inline frames. If the rare</comment>
  <comment type="line">// case is happening then the worst that will happen is that the</comment>
  <comment type="line">// bullet frame will be reflowed twice.</comment>
  PRBool addedBullet = PR_FALSE;
  if (mBullet &amp;&amp; HaveOutsideBullet() &amp;&amp; (aLine == mLines.front()) &amp;&amp;
      (!aLineLayout.IsZeroHeight() || (aLine == mLines.back()))) {
    nsHTMLReflowMetrics metrics;
    ReflowBullet(aState, metrics);
    aLineLayout.AddBulletFrame(mBullet, metrics);
    addedBullet = PR_TRUE;
  }
  aLineLayout.VerticalAlignLine();

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  {
    static nscoord lastHeight = 0;
    if (CRAZY_HEIGHT(aLine-&gt;mBounds.y)) {
      lastHeight = aLine-&gt;mBounds.y;
      if (abs(aLine-&gt;mBounds.y - lastHeight) &gt; CRAZY_H/10) {
        nsFrame::ListTag(stdout);
        printf(": line=%p y=%d line.bounds.height=%d\n",
               static_cast&lt;void*&gt;(aLine.get()),
               aLine-&gt;mBounds.y, aLine-&gt;mBounds.height);
      }
    }
    else {
      lastHeight = 0;
    }
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Only block frames horizontally align their children because</comment>
  <comment type="line">// inline frames "shrink-wrap" around their children (therefore</comment>
  <comment type="line">// there is no extra horizontal space).</comment>
  const nsStyleText* styleText = GetStyleText();
  PRBool allowJustify = NS_STYLE_TEXT_ALIGN_JUSTIFY == styleText-&gt;mTextAlign &amp;&amp;
                        !aLineLayout.GetLineEndsInBR() &amp;&amp;
                        ShouldJustifyLine(aState, aLine);
  aLineLayout.HorizontalAlignFrames(aLine-&gt;mBounds, allowJustify);
  <comment type="line">// XXX: not only bidi: right alignment can be broken after</comment>
  <comment type="line">// RelativePositionFrames!!!</comment>
  <comment type="line">// XXXldb Is something here considering relatively positioned frames at</comment>
  <comment type="line">// other than their original positions?</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
  <comment type="line">// XXXldb Why don't we do this earlier?</comment>
  if (aState.mPresContext-&gt;BidiEnabled()) {
    if (!aState.mPresContext-&gt;IsVisualMode()) {
      nsBidiPresUtils* bidiUtils = aState.mPresContext-&gt;GetBidiUtils();

      if (bidiUtils &amp;&amp; bidiUtils-&gt;IsSuccessful() ) {
        bidiUtils-&gt;ReorderFrames(aLine-&gt;mFirstChild, aLine-&gt;GetChildCount());
      } <comment type="line">// bidiUtils</comment>
    } <comment type="line">// not visual mode</comment>
  } <comment type="line">// bidi enabled</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// IBMBIDI</comment>

  nsRect combinedArea;
  aLineLayout.RelativePositionFrames(combinedArea);  <comment type="line">// XXXldb This returned width as -15, 2001-06-12, Bugzilla</comment>
  aLine-&gt;SetCombinedArea(combinedArea);
  if (addedBullet) {
    aLineLayout.RemoveBulletFrame(mBullet);
  }

  <comment type="line">// Inline lines do not have margins themselves; however they are</comment>
  <comment type="line">// impacted by prior block margins. If this line ends up having some</comment>
  <comment type="line">// height then we zero out the previous bottom margin value that was</comment>
  <comment type="line">// already applied to the line's starting Y coordinate. Otherwise we</comment>
  <comment type="line">// leave it be so that the previous blocks bottom margin can be</comment>
  <comment type="line">// collapsed with a block that follows.</comment>
  nscoord newY;

  if (!aLine-&gt;CachedIsEmpty()) {
    <comment type="line">// This line has some height. Therefore the application of the</comment>
    <comment type="line">// previous-bottom-margin should stick.</comment>
    aState.mPrevBottomMargin.Zero();
    newY = aLine-&gt;mBounds.YMost();
  }
  else {
    <comment type="line">// Don't let the previous-bottom-margin value affect the newY</comment>
    <comment type="line">// coordinate (it was applied in ReflowInlineFrames speculatively)</comment>
    <comment type="line">// since the line is empty.</comment>
    <comment type="line">// We already called |ShouldApplyTopMargin|, and if we applied it</comment>
    <comment type="line">// then BRS_APPLYTOPMARGIN is set.</comment>
    nscoord dy = aState.GetFlag(BRS_APPLYTOPMARGIN)
                   ? -aState.mPrevBottomMargin.get() : 0;
    newY = aState.mY + dy;
    aLine-&gt;SlideBy(dy); <comment type="line">// XXXldb Do we really want to do this?</comment>
  }

  <comment type="line">// See if the line fit. If it doesn't we need to push it. Our first</comment>
  <comment type="line">// line will always fit.</comment>
  if (mLines.front() != aLine &amp;&amp;
      newY &gt; aState.mBottomEdge &amp;&amp;
      aState.mBottomEdge != NS_UNCONSTRAINEDSIZE) {
    <comment type="line">// Push this line and all of its children and anything else that</comment>
    <comment type="line">// follows to our next-in-flow</comment>
    NS_ASSERTION((aState.mCurrentLine == aLine), "oops");
    PushLines(aState, aLine.prev());

    <comment type="line">// Stop reflow and whack the reflow status if reflow hasn't</comment>
    <comment type="line">// already been stopped.</comment>
    if (*aKeepReflowGoing) {
      NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
      *aKeepReflowGoing = PR_FALSE;
    }
    return PR_TRUE;
  }

  <comment type="line">// May be needed below</comment>
  PRBool wasAdjacentWIthTop = aState.IsAdjacentWithTop();

  aState.mY = newY;
  
  <comment type="line">// Add the already placed current-line floats to the line</comment>
  aLine-&gt;AppendFloats(aState.mCurrentLineFloats);

  <comment type="line">// Any below current line floats to place?</comment>
  if (aState.mBelowCurrentLineFloats.NotEmpty()) {
    <comment type="line">// Reflow the below-current-line floats, then add them to the</comment>
    <comment type="line">// lines float list if there aren't any truncated floats.</comment>
    if (aState.PlaceBelowCurrentLineFloats(aState.mBelowCurrentLineFloats,
                                           wasAdjacentWIthTop)) {
      aLine-&gt;AppendFloats(aState.mBelowCurrentLineFloats);
    }
    else { 
      <comment type="line">// At least one float is truncated, so fix up any placeholders that got split and </comment>
      <comment type="line">// push the line. XXX It may be better to put the float on the next line, but this </comment>
      <comment type="line">// is not common enough to justify the complexity. Or maybe it is now...</comment>

      nsIFrame* lastPlaceholder = aState.mOverflowPlaceholders.LastChild();
      PushTruncatedPlaceholderLine(aState, aLine, lastPlaceholder, *aKeepReflowGoing);
    }
  }

  <comment type="line">// When a line has floats, factor them into the combined-area</comment>
  <comment type="line">// computations.</comment>
  if (aLine-&gt;HasFloats()) {
    <comment type="line">// Combine the float combined area (stored in aState) and the</comment>
    <comment type="line">// value computed by the line layout code.</comment>
    nsRect lineCombinedArea(aLine-&gt;GetCombinedArea());
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_COMBINED_AREA</name></cpp:ifdef>
    ListTag(stdout);
    printf(": lineCA=%d,%d,%d,%d floatCA=%d,%d,%d,%d\n",
           lineCombinedArea.x, lineCombinedArea.y,
           lineCombinedArea.width, lineCombinedArea.height,
           aState.mFloatCombinedArea.x, aState.mFloatCombinedArea.y,
           aState.mFloatCombinedArea.width,
           aState.mFloatCombinedArea.height);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    lineCombinedArea.UnionRect(aState.mFloatCombinedArea, lineCombinedArea);

    aLine-&gt;SetCombinedArea(lineCombinedArea);
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_COMBINED_AREA</name></cpp:ifdef>
    printf("  ==&gt; final lineCA=%d,%d,%d,%d\n",
           lineCombinedArea.x, lineCombinedArea.y,
           lineCombinedArea.width, lineCombinedArea.height);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }

  <comment type="line">// Apply break-after clearing if necessary</comment>
  <comment type="line">// This must stay in sync with |ReflowDirtyLines|.</comment>
  if (aLine-&gt;HasFloatBreakAfter()) {
    aState.mY = aState.ClearFloats(aState.mY, aLine-&gt;GetBreakTypeAfter());
  }

  return PR_FALSE;
}

void
nsBlockFrame::PushLines(nsBlockReflowState&amp;  aState,
                        nsLineList::iterator aLineBefore)
{
  nsLineList::iterator overBegin(aLineBefore.next());

  <comment type="line">// PushTruncatedPlaceholderLine sometimes pushes the first line.  Ugh.</comment>
  PRBool firstLine = overBegin == begin_lines();

  if (overBegin != end_lines()) {
    <comment type="line">// Remove floats in the lines from mFloats</comment>
    nsFrameList floats;
    nsIFrame* tail = nsnull;
    CollectFloats(overBegin-&gt;mFirstChild, floats, &amp;tail, PR_FALSE, PR_TRUE);

    if (floats.NotEmpty()) {
      <comment type="line">// Push the floats onto the front of the overflow out-of-flows list</comment>
      nsFrameList oofs = GetOverflowOutOfFlows();
      if (oofs.NotEmpty()) {
        floats.InsertFrames(nsnull, tail, oofs.FirstChild());
      }
      SetOverflowOutOfFlows(floats);
    }

    <comment type="line">// overflow lines can already exist in some cases, in particular,</comment>
    <comment type="line">// when shrinkwrapping and we discover that the shrinkwap causes</comment>
    <comment type="line">// the height of some child block to grow which creates additional</comment>
    <comment type="line">// overflowing content. In such cases we must prepend the new</comment>
    <comment type="line">// overflow to the existing overflow.</comment>
    nsLineList* overflowLines = RemoveOverflowLines();
    if (!overflowLines) {
      <comment type="line">// XXXldb use presshell arena!</comment>
      overflowLines = new nsLineList();
    }
    if (overflowLines) {
      if (!overflowLines-&gt;empty()) {
        mLines.back()-&gt;LastChild()-&gt;SetNextSibling(overflowLines-&gt;front()-&gt;mFirstChild);
      }
      overflowLines-&gt;splice(overflowLines-&gt;begin(), mLines, overBegin,
                            end_lines());
      NS_ASSERTION(!overflowLines-&gt;empty(), "should not be empty");
      <comment type="line">// this takes ownership but it won't delete it immediately so we</comment>
      <comment type="line">// can keep using it.</comment>
      SetOverflowLines(overflowLines);
  
      <comment type="line">// Mark all the overflow lines dirty so that they get reflowed when</comment>
      <comment type="line">// they are pulled up by our next-in-flow.</comment>

      <comment type="line">// XXXldb Can this get called O(N) times making the whole thing O(N^2)?</comment>
      for (line_iterator line = overflowLines-&gt;begin(),
             line_end = overflowLines-&gt;end();
           line != line_end;
           ++line)
        {
          line-&gt;MarkDirty();
          line-&gt;MarkPreviousMarginDirty();
          line-&gt;mBounds.SetRect(0, 0, 0, 0);
          if (line-&gt;HasFloats()) {
            line-&gt;FreeFloats(aState.mFloatCacheFreeList);
          }
        }
    }
  }

  <comment type="line">// Break frame sibling list</comment>
  if (!firstLine)
    aLineBefore-&gt;LastChild()-&gt;SetNextSibling(nsnull);

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  VerifyOverflowSituation();
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}

<comment type="block" format="doxygen">/**
 * Call this when a frame will be pulled from the block's
 * next-in-flow into this frame. If it's a continuation placeholder,
 * it should not be here so we push it into our overflow placeholders
 * list. To avoid creating holes (e.g., the following block doesn't
 * have a placeholder but the block after it does) we also need to
 * pull all the following placeholders and put them in our overflow
 * placeholders list too.
 *
 * If it's a first-in-flow placeholder, or it contains one, then we
 * need to do this to the continuation placeholders.
 *
 * We return PR_TRUE if we removed the frame and it cannot be used.
 * If we return PR_FALSE then the frame *must* be pulled immediately.
 */</comment>
PRBool
nsBlockFrame::HandleOverflowPlaceholdersForPulledFrame(
  nsBlockReflowState&amp; aState, nsIFrame* aFrame)
{
  if (nsGkAtoms::placeholderFrame != aFrame-&gt;GetType()) {
    <comment type="line">// Descend into children that are not float containing blocks.</comment>
    <comment type="line">// We should encounter only first-in-flow placeholders, so the</comment>
    <comment type="line">// frame subtree rooted at aFrame should not change.</comment>
    if (!aFrame-&gt;IsFloatContainingBlock()) {
      for (nsIFrame* f = aFrame-&gt;GetFirstChild(nsnull); f; f = f-&gt;GetNextSibling()) {
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        PRBool changed =
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          HandleOverflowPlaceholdersForPulledFrame(aState, f);
        NS_ASSERTION(!changed, "Shouldn't find any continuation placeholders inside inlines");
      }
    }
    return PR_FALSE;
  }

  PRBool taken = PR_TRUE;
  nsIFrame* frame = aFrame;
  if (!aFrame-&gt;GetPrevInFlow()) {
    <comment type="line">// First in flow frame. We only want to deal with its</comment>
    <comment type="line">// next in flows, if there are any.</comment>
    taken = PR_FALSE;
    frame = frame-&gt;GetNextInFlow();
    if (!frame)
      return PR_FALSE;
  }

  nsBlockFrame* parent = static_cast&lt;nsBlockFrame*&gt;(frame-&gt;GetParent());
  <comment type="line">// Remove aFrame and all its next in flows from their parents, but</comment>
  <comment type="line">// don't destroy the frames.</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  nsresult rv =
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    parent-&gt;DoRemoveFrame(frame, PR_FALSE);
  NS_ASSERTION(NS_SUCCEEDED(rv), "frame should be in parent's lists");
  
  nsIFrame* lastOverflowPlace = aState.mOverflowPlaceholders.LastChild();
  while (frame) {
    NS_ASSERTION(IsContinuationPlaceholder(frame),
                 "Should only be dealing with continuation placeholders here");

    parent = static_cast&lt;nsBlockFrame*&gt;(frame-&gt;GetParent());
    ReparentFrame(frame, parent, this);

    <comment type="line">// continuation placeholders are always direct children of a block</comment>
    nsIFrame* outOfFlow = nsPlaceholderFrame::GetRealFrameForPlaceholder(frame);

    if (!parent-&gt;mFloats.RemoveFrame(outOfFlow)) {
      nsAutoOOFFrameList oofs(parent);
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
      PRBool found =
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        oofs.mList.RemoveFrame(outOfFlow);
      NS_ASSERTION(found, "Must have the out of flow in some child list");
    }
    ReparentFrame(outOfFlow, parent, this);

    aState.mOverflowPlaceholders.InsertFrames(nsnull, lastOverflowPlace, frame);
    <comment type="line">// outOfFlow isn't inserted anywhere yet. Eventually the overflow</comment>
    <comment type="line">// placeholders get put into the overflow lines, and at the same time we</comment>
    <comment type="line">// insert the placeholders' out of flows into the overflow out-of-flows</comment>
    <comment type="line">// list.</comment>
    lastOverflowPlace = frame;

    frame = frame-&gt;GetNextInFlow();
  }

  return taken;
}

<comment type="block" format="doxygen">/**
 * Call this when a line will be pulled from the block's
 * next-in-flow's line.
 *
 * @return PR_TRUE we consumed the entire line, delete it and try again
 */</comment>
PRBool
nsBlockFrame::HandleOverflowPlaceholdersOnPulledLine(
  nsBlockReflowState&amp; aState, nsLineBox* aLine)
{
  <comment type="line">// First, see if it's a line of continuation placeholders. If it</comment>
  <comment type="line">// is, remove one and retry.</comment>
  if (aLine-&gt;mFirstChild &amp;&amp; IsContinuationPlaceholder(aLine-&gt;mFirstChild)) {
    PRBool taken =
      HandleOverflowPlaceholdersForPulledFrame(aState, aLine-&gt;mFirstChild);
    NS_ASSERTION(taken, "We must have removed that frame");
    return PR_TRUE;
  }
 
  <comment type="line">// OK, it's a normal line. Scan it for floats with continuations that</comment>
  <comment type="line">// need to be taken care of. We won't need to change the line.</comment>
  PRInt32 n = aLine-&gt;GetChildCount();
  for (nsIFrame* f = aLine-&gt;mFirstChild; n &gt; 0; f = f-&gt;GetNextSibling(), --n) {
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    PRBool taken =
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      HandleOverflowPlaceholdersForPulledFrame(aState, f);
    NS_ASSERTION(!taken, "Shouldn't be any continuation placeholders on this line");
  }

  return PR_FALSE;
}

<comment type="line">// The overflowLines property is stored as a pointer to a line list,</comment>
<comment type="line">// which must be deleted.  However, the following functions all maintain</comment>
<comment type="line">// the invariant that the property is never set if the list is empty.</comment>

PRBool
nsBlockFrame::DrainOverflowLines(nsBlockReflowState&amp; aState)
{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  VerifyOverflowSituation();
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  nsLineList* overflowLines = nsnull;
  nsLineList* ourOverflowLines = nsnull;

  <comment type="line">// First grab the prev-in-flows overflow lines</comment>
  nsBlockFrame* prevBlock = (nsBlockFrame*) GetPrevInFlow();
  if (prevBlock) {
    overflowLines = prevBlock-&gt;RemoveOverflowLines();
    if (overflowLines) {
      NS_ASSERTION(! overflowLines-&gt;empty(),
                   "overflow lines should never be set and empty");
      <comment type="line">// Make all the frames on the overflow line list mine</comment>
      nsIFrame* frame = overflowLines-&gt;front()-&gt;mFirstChild;
      while (nsnull != frame) {
        ReparentFrame(frame, prevBlock, this);

        <comment type="line">// Get the next frame</comment>
        frame = frame-&gt;GetNextSibling();
      }

      <comment type="line">// make the overflow out-of-flow frames mine too</comment>
      nsAutoOOFFrameList oofs(prevBlock);
      if (oofs.mList.NotEmpty()) {
        for (nsIFrame* f = oofs.mList.FirstChild(); f; f = f-&gt;GetNextSibling()) {
          ReparentFrame(f, prevBlock, this);
        }
        mFloats.InsertFrames(nsnull, nsnull, oofs.mList.FirstChild());
        oofs.mList.SetFrames(nsnull);
      }
    }
    
    <comment type="line">// The lines on the overflow list have already been marked dirty and their</comment>
    <comment type="line">// previous margins marked dirty also.</comment>
  }

  <comment type="line">// Don't need to reparent frames in our own overflow lines/oofs, because they're</comment>
  <comment type="line">// already ours. But we should put overflow floats back in mFloats.</comment>
  ourOverflowLines = RemoveOverflowLines();
  if (ourOverflowLines) {
    nsAutoOOFFrameList oofs(this);
    if (oofs.mList.NotEmpty()) {
      <comment type="line">// The overflow floats go after our regular floats</comment>
      mFloats.AppendFrames(nsnull, oofs.mList.FirstChild());
      oofs.mList.SetFrames(nsnull);
    }
  }

  if (!overflowLines &amp;&amp; !ourOverflowLines) {
    <comment type="line">// nothing to do; always the case for non-constrained-height reflows</comment>
    return PR_FALSE;
  }

  NS_ASSERTION(aState.mOverflowPlaceholders.IsEmpty(),
               "Should have no overflow placeholders yet");

  <comment type="line">// HANDLING CONTINUATION PLACEHOLDERS (floats only at the moment, because</comment>
  <comment type="line">// abs-pos frames don't have continuations)</comment>
  <comment type="line">//</comment>
  <comment type="line">// All continuation placeholders need to be moved to the front of</comment>
  <comment type="line">// our line list. We also need to maintain the invariant that at</comment>
  <comment type="line">// most one frame for a given piece of content is in our normal</comment>
  <comment type="line">// child list, by pushing all but the first placeholder to our</comment>
  <comment type="line">// overflow placeholders list.</comment>
  <comment type="line">// </comment>
  <comment type="line">// One problem we have to deal with is that some of these</comment>
  <comment type="line">// continuation placeholders may have been donated to us by a</comment>
  <comment type="line">// descendant block that was complete. We need to push them down to</comment>
  <comment type="line">// a lower block if possible.</comment>
  <comment type="line">//</comment>
  <comment type="line">// We keep the lists ordered so that prev in flows come before their</comment>
  <comment type="line">// next in flows. We do not worry about properly ordering the</comment>
  <comment type="line">// placeholders for different content relative to each other until</comment>
  <comment type="line">// the end. Then we sort them.</comment>
  <comment type="line">//</comment>
  <comment type="line">// When we're shuffling placeholders we also need to shuffle their out of</comment>
  <comment type="line">// flows to match. As we put placeholders into keepPlaceholders, we unhook</comment>
  <comment type="line">// their floats from mFloats. Later we put the floats back based on the</comment>
  <comment type="line">// order of the placeholders.</comment>
  nsIFrame* lastOP = nsnull;
  nsFrameList keepPlaceholders;
  nsFrameList keepOutOfFlows;
  nsIFrame* lastKP = nsnull;
  nsIFrame* lastKOOF = nsnull;
  nsLineList* lineLists[3] = { overflowLines</argument>, <argument>&amp;mLines</argument>, <argument>ourOverflowLines };
  static const PRPackedBool searchFirstLinesOnly[3] = { PR_FALSE</argument>, <argument>PR_TRUE</argument>, <argument>PR_FALSE };
  for (PRInt32 i = 0; i &lt; 3; ++i) {
    nsLineList* ll = lineLists[i];
    if (ll &amp;&amp; !ll-&gt;empty()) {
      line_iterator iter = ll-&gt;begin();
      line_iterator iter_end = ll-&gt;end();
      nsIFrame* lastFrame = nsnull;
      while (iter != iter_end) {
        PRUint32 n = iter-&gt;GetChildCount();
        if (n == 0 || !IsContinuationPlaceholder(iter-&gt;mFirstChild)) {
          if (lastFrame) {
            lastFrame-&gt;SetNextSibling(iter-&gt;mFirstChild);
          }
          if (searchFirstLinesOnly[i]) {
            break;
          }
          lastFrame = iter-&gt;LastChild();
          ++iter;
        } else {
          nsLineBox* line = iter;
          iter = ll-&gt;erase(iter);
          nsIFrame* next;
          for (nsPlaceholderFrame* f = static_cast&lt;nsPlaceholderFrame*&gt;(line-&gt;mFirstChild);
               n &gt; 0; --n, f = static_cast&lt;nsPlaceholderFrame*&gt;(next)) {
            if (!IsContinuationPlaceholder(f)) {
              NS_ASSERTION(IsContinuationPlaceholder(f),
                           "Line frames should all be continuation placeholders");
            }
            next = f-&gt;GetNextSibling();
            nsIFrame* fpif = f-&gt;GetPrevInFlow();
            nsIFrame* oof = f-&gt;GetOutOfFlowFrame();
            
            <comment type="line">// Take this out of mFloats for now. We may put it back later in</comment>
            <comment type="line">// this function</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            PRBool found =
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              mFloats.RemoveFrame(oof);
            NS_ASSERTION(found, "Float should have been put in our mFloats list");

            PRBool isAncestor = nsLayoutUtils::IsProperAncestorFrame(this, fpif);
            if (isAncestor) {
              <comment type="line">// oops. we already have a prev-in-flow for this</comment>
              <comment type="line">// placeholder. We have to move this frame out of here. We</comment>
              <comment type="line">// can put it in our overflow placeholders.</comment>
              aState.mOverflowPlaceholders.InsertFrame(nsnull, lastOP, f);
              <comment type="line">// Let oof dangle for now, because placeholders in</comment>
              <comment type="line">// mOverflowPlaceholders do not keep their floats in any child list</comment>
              lastOP = f;
            } else {
              if (fpif-&gt;GetParent() == prevBlock) {
                keepPlaceholders.InsertFrame(nsnull, lastKP, f);
                keepOutOfFlows.InsertFrame(nsnull, lastKOOF, oof);
                lastKP = f;
                lastKOOF = oof;
              } else {
                <comment type="line">// Ok, now we're in the tough situation where some child</comment>
                <comment type="line">// of prevBlock was complete and pushed its overflow</comment>
                <comment type="line">// placeholders up to prevBlock's overflow. We might be</comment>
                <comment type="line">// able to find a more appropriate parent for f somewhere</comment>
                <comment type="line">// down in our descendants.</comment>
                NS_ASSERTION(nsLayoutUtils::IsProperAncestorFrame(prevBlock, fpif),
                             "bad prev-in-flow ancestor chain");
                <comment type="line">// Find the first ancestor of f's prev-in-flow that has a next in flow</comment>
                <comment type="line">// that can contain the float.</comment>
                <comment type="line">// That next in flow should become f's parent.</comment>
                nsIFrame* fpAncestor;
                for (fpAncestor = fpif-&gt;GetParent();
                     !fpAncestor-&gt;GetNextInFlow() || !fpAncestor-&gt;IsFloatContainingBlock();
                     fpAncestor = fpAncestor-&gt;GetParent())
                  ;
                if (fpAncestor == prevBlock) {
                  <comment type="line">// We're still the best parent.</comment>
                  keepPlaceholders.InsertFrame(nsnull, lastKP, f);
                  keepOutOfFlows.InsertFrame(nsnull, lastKOOF, oof);
                  lastKP = f;
                  lastKOOF = oof;
                } else {
                  <comment type="line">// Just put it at the front of</comment>
                  <comment type="line">// fpAncestor-&gt;GetNextInFlow()'s lines.</comment>
                  nsLineBox* newLine = aState.NewLineBox(f, 1, PR_FALSE);
                  if (newLine) {
                    nsBlockFrame* target =
                      static_cast&lt;nsBlockFrame*&gt;(fpAncestor-&gt;GetNextInFlow());
                    if (!target-&gt;mLines.empty()) {
                      f-&gt;SetNextSibling(target-&gt;mLines.front()-&gt;mFirstChild);
                    } else {
                      f-&gt;SetNextSibling(nsnull);
                    }
                    target-&gt;mLines.push_front(newLine);
                    ReparentFrame(f, this, target);

                    target-&gt;mFloats.InsertFrame(nsnull, nsnull, oof);
                    ReparentFrame(oof, this, target);
                  }
                }
              }
            }
          }
          aState.FreeLineBox(line);
        }
      }
      if (lastFrame) {
        lastFrame-&gt;SetNextSibling(nsnull);
      }
    }
  }

  <comment type="line">// Now join the line lists into mLines</comment>
  if (overflowLines) {
    if (!overflowLines-&gt;empty()) {
      <comment type="line">// Join the line lists</comment>
      if (! mLines.empty()) 
        {
          <comment type="line">// Remember to recompute the margins on the first line. This will</comment>
          <comment type="line">// also recompute the correct deltaY if necessary.</comment>
          mLines.front()-&gt;MarkPreviousMarginDirty();
          <comment type="line">// Join the sibling lists together</comment>
          nsIFrame* lastFrame = overflowLines-&gt;back()-&gt;LastChild();
          lastFrame-&gt;SetNextSibling(mLines.front()-&gt;mFirstChild);
        }
      <comment type="line">// Place overflow lines at the front of our line list</comment>
      mLines.splice(mLines.begin(), *overflowLines);
      NS_ASSERTION(overflowLines-&gt;empty(), "splice should empty list");
    }
    delete overflowLines;
  }
  if (ourOverflowLines) {
    if (!ourOverflowLines-&gt;empty()) {
      if (!mLines.empty()) {
        mLines.back()-&gt;LastChild()-&gt;
          SetNextSibling(ourOverflowLines-&gt;front()-&gt;mFirstChild);
      }
      <comment type="line">// append the overflow to mLines</comment>
      mLines.splice(mLines.end(), *ourOverflowLines);
    }
    delete ourOverflowLines;
  }

  <comment type="line">// store the placeholders that we're keeping in our frame list</comment>
  if (keepPlaceholders.NotEmpty()) {
    keepPlaceholders.SortByContentOrder();
    nsLineBox* newLine = aState.NewLineBox(keepPlaceholders.FirstChild(),
                                           keepPlaceholders.GetLength(), PR_FALSE);
    if (newLine) {
      if (!mLines.empty()) {
        keepPlaceholders.LastChild()-&gt;SetNextSibling(mLines.front()-&gt;mFirstChild);
      }
      mLines.push_front(newLine);
    }

    <comment type="line">// Put the placeholders' out of flows into the float list</comment>
    keepOutOfFlows.SortByContentOrder();
    mFloats.InsertFrames(nsnull, nsnull, keepOutOfFlows.FirstChild());
  }

  return PR_TRUE;
}

nsLineList*
nsBlockFrame::GetOverflowLines() const
{
  if (!(GetStateBits() &amp; NS_BLOCK_HAS_OVERFLOW_LINES)) {
    return nsnull;
  }
  nsLineList* lines = static_cast&lt;nsLineList*&gt;
                                 (GetProperty(nsGkAtoms::overflowLinesProperty));
  NS_ASSERTION(lines &amp;&amp; !lines-&gt;empty(),
               "value should always be stored and non-empty when state set");
  return lines;
}

nsLineList*
nsBlockFrame::RemoveOverflowLines()
{
  if (!(GetStateBits() &amp; NS_BLOCK_HAS_OVERFLOW_LINES)) {
    return nsnull;
  }
  nsLineList* lines = static_cast&lt;nsLineList*&gt;
                                 (UnsetProperty(nsGkAtoms::overflowLinesProperty));
  NS_ASSERTION(lines &amp;&amp; !lines-&gt;empty(),
               "value should always be stored and non-empty when state set");
  RemoveStateBits(NS_BLOCK_HAS_OVERFLOW_LINES);
  return lines;
}

<comment type="line">// Destructor function for the overflowLines frame property</comment>
static void
DestroyOverflowLines(void*           aFrame,
                     nsIAtom*        aPropertyName,
                     void*           aPropertyValue,
                     void*           aDtorData)
{
  if (aPropertyValue) {
    nsLineList* lines = static_cast&lt;nsLineList*&gt;(aPropertyValue);
    nsPresContext *context = static_cast&lt;nsPresContext*&gt;(aDtorData);
    nsLineBox::DeleteLineList(context, *lines);
    delete lines;
  }
}

<comment type="line">// This takes ownership of aOverflowLines.</comment>
<comment type="line">// XXX We should allocate overflowLines from presShell arena!</comment>
nsresult
nsBlockFrame::SetOverflowLines(nsLineList* aOverflowLines)
{
  NS_ASSERTION(aOverflowLines, "null lines");
  NS_ASSERTION(!aOverflowLines-&gt;empty(), "empty lines");
  NS_ASSERTION(!(GetStateBits() &amp; NS_BLOCK_HAS_OVERFLOW_LINES),
               "Overwriting existing overflow lines");

  nsPresContext *presContext = PresContext();
  nsresult rv = presContext-&gt;PropertyTable()-&gt;
    SetProperty(this, nsGkAtoms::overflowLinesProperty, aOverflowLines,
                DestroyOverflowLines, presContext);
  <comment type="line">// Verify that we didn't overwrite an existing overflow list</comment>
  NS_ASSERTION(rv != NS_PROPTABLE_PROP_OVERWRITTEN, "existing overflow list");
  AddStateBits(NS_BLOCK_HAS_OVERFLOW_LINES);
  return rv;
}

nsFrameList
nsBlockFrame::GetOverflowOutOfFlows() const
{
  if (!(GetStateBits() &amp; NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS)) {
    return nsFrameList();
  }
  nsIFrame* result = static_cast&lt;nsIFrame*&gt;
                                (GetProperty(nsGkAtoms::overflowOutOfFlowsProperty));
  NS_ASSERTION(result, "value should always be non-empty when state set");
  return nsFrameList(result);
}

<comment type="line">// This takes ownership of the frames</comment>
void
nsBlockFrame::SetOverflowOutOfFlows(const nsFrameList&amp; aList)
{
  if (aList.IsEmpty()) {
    if (!(GetStateBits() &amp; NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS)) {
      return;
    }
    nsIFrame* result = static_cast&lt;nsIFrame*&gt;
                                  (UnsetProperty(nsGkAtoms::overflowOutOfFlowsProperty));
    NS_ASSERTION(result, "value should always be non-empty when state set");
    RemoveStateBits(NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS);
  } else {
    SetProperty(nsGkAtoms::overflowOutOfFlowsProperty,
                aList.FirstChild(), nsnull);
    AddStateBits(NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS);
  }
}

nsFrameList*
nsBlockFrame::GetOverflowPlaceholders() const
{
  if (!(GetStateBits() &amp; NS_BLOCK_HAS_OVERFLOW_PLACEHOLDERS)) {
    return nsnull;
  }
  nsFrameList* result = static_cast&lt;nsFrameList*&gt;
                                   (GetProperty(nsGkAtoms::overflowPlaceholdersProperty));
  NS_ASSERTION(result, "value should always be non-empty when state set");
  return result;
}

<comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Frame list manipulation routines</comment>

nsIFrame*
nsBlockFrame::LastChild()
{
  if (! mLines.empty()) {
    return mLines.back()-&gt;LastChild();
  }
  return nsnull;
}

NS_IMETHODIMP
nsBlockFrame::AppendFrames(nsIAtom*  aListName,
                           nsIFrame* aFrameList)
{
  if (nsnull == aFrameList) {
    return NS_OK;
  }
  if (aListName) {
    if (nsGkAtoms::absoluteList == aListName) {
      return mAbsoluteContainer.AppendFrames(this, aListName, aFrameList);
    }
    else if (nsGkAtoms::floatList == aListName) {
      mFloats.AppendFrames(nsnull, aFrameList);
      return NS_OK;
    }
    else {
      NS_ERROR("unexpected child list");
      return NS_ERROR_INVALID_ARG;
    }
  }

  <comment type="line">// Find the proper last-child for where the append should go</comment>
  nsIFrame* lastKid = nsnull;
  nsLineBox* lastLine = mLines.empty() ? nsnull : mLines.back();
  if (lastLine) {
    lastKid = lastLine-&gt;LastChild();
  }

  <comment type="line">// Add frames after the last child</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_REFLOW_REASON</name></cpp:ifdef>
  ListTag(stdout);
  printf(": append ");
  nsFrame::ListTag(stdout, aFrameList);
  if (lastKid) {
    printf(" after ");
    nsFrame::ListTag(stdout, lastKid);
  }
  printf("\n");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  nsresult rv = AddFrames(aFrameList, lastKid);
  if (NS_SUCCEEDED(rv)) {
    PresContext()-&gt;PresShell()-&gt;
      FrameNeedsReflow(this, nsIPresShell::eTreeChange,
                       NS_FRAME_HAS_DIRTY_CHILDREN); <comment type="line">// XXX sufficient?</comment>
  }
  return rv;
}

NS_IMETHODIMP
nsBlockFrame::InsertFrames(nsIAtom*  aListName,
                           nsIFrame* aPrevFrame,
                           nsIFrame* aFrameList)
{
  NS_ASSERTION(!aPrevFrame || aPrevFrame-&gt;GetParent() == this,
               "inserting after sibling frame with different parent");

  if (aListName) {
    if (nsGkAtoms::absoluteList == aListName) {
      return mAbsoluteContainer.InsertFrames(this, aListName, aPrevFrame,
                                             aFrameList);
    }
    else if (nsGkAtoms::floatList == aListName) {
      mFloats.InsertFrames(this, aPrevFrame, aFrameList);
      return NS_OK;
    }
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
    else if (nsGkAtoms::nextBidi == aListName) {}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// IBMBIDI</comment>
    else {
      NS_ERROR("unexpected child list");
      return NS_ERROR_INVALID_ARG;
    }
  }

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_REFLOW_REASON</name></cpp:ifdef>
  ListTag(stdout);
  printf(": insert ");
  nsFrame::ListTag(stdout, aFrameList);
  if (aPrevFrame) {
    printf(" after ");
    nsFrame::ListTag(stdout, aPrevFrame);
  }
  printf("\n");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  nsresult rv = AddFrames(aFrameList, aPrevFrame);
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
  if (aListName != nsGkAtoms::nextBidi)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// IBMBIDI</comment>
  if (NS_SUCCEEDED(rv)) {
    PresContext()-&gt;PresShell()-&gt;
      FrameNeedsReflow(this, nsIPresShell::eTreeChange,
                       NS_FRAME_HAS_DIRTY_CHILDREN); <comment type="line">// XXX sufficient?</comment>
  }
  return rv;
}

static PRBool
ShouldPutNextSiblingOnNewLine(nsIFrame* aLastFrame)
{
  nsIAtom* type = aLastFrame-&gt;GetType();
  if (type == nsGkAtoms::brFrame)
    return PR_TRUE;
  if (type == nsGkAtoms::textFrame)
    return aLastFrame-&gt;HasTerminalNewline() &amp;&amp;
           aLastFrame-&gt;GetStyleText()-&gt;WhiteSpaceIsSignificant();
  if (type == nsGkAtoms::placeholderFrame)
    return IsContinuationPlaceholder(aLastFrame);
  return PR_FALSE;
}

nsresult
nsBlockFrame::AddFrames(nsIFrame* aFrameList,
                        nsIFrame* aPrevSibling)
{
  <comment type="line">// Clear our line cursor, since our lines may change.</comment>
  ClearLineCursor();

  if (nsnull == aFrameList) {
    return NS_OK;
  }

  <comment type="line">// If we're inserting at the beginning of our list and we have an</comment>
  <comment type="line">// inside bullet, insert after that bullet.</comment>
  if (!aPrevSibling &amp;&amp; mBullet &amp;&amp; !HaveOutsideBullet()) {
    NS_ASSERTION(!nsFrameList(aFrameList).ContainsFrame(mBullet),
                 "Trying to make mBullet prev sibling to itself");
    aPrevSibling = mBullet;
  }
  
  nsIPresShell *presShell = PresContext()-&gt;PresShell();

  <comment type="line">// Attempt to find the line that contains the previous sibling</comment>
  nsLineList::iterator prevSibLine = end_lines();
  PRInt32 prevSiblingIndex = -1;
  if (aPrevSibling) {
    <comment type="line">// XXX_perf This is technically O(N^2) in some cases, but by using</comment>
    <comment type="line">// RFind instead of Find, we make it O(N) in the most common case,</comment>
    <comment type="line">// which is appending content.</comment>

    <comment type="line">// Find the line that contains the previous sibling</comment>
    if (! nsLineBox::RFindLineContaining(aPrevSibling,
                                         begin_lines(), prevSibLine,
                                         &amp;prevSiblingIndex)) {
      <comment type="line">// Note: defensive code! RFindLineContaining must not return</comment>
      <comment type="line">// false in this case, so if it does...</comment>
      NS_NOTREACHED("prev sibling not in line list");
      aPrevSibling = nsnull;
      prevSibLine = end_lines();
    }
  }

  <comment type="line">// Find the frame following aPrevSibling so that we can join up the</comment>
  <comment type="line">// two lists of frames.</comment>
  nsIFrame* prevSiblingNextFrame = nsnull;
  if (aPrevSibling) {
    prevSiblingNextFrame = aPrevSibling-&gt;GetNextSibling();

    <comment type="line">// Split line containing aPrevSibling in two if the insertion</comment>
    <comment type="line">// point is somewhere in the middle of the line.</comment>
    PRInt32 rem = prevSibLine-&gt;GetChildCount() - prevSiblingIndex - 1;
    if (rem) {
      <comment type="line">// Split the line in two where the frame(s) are being inserted.</comment>
      nsLineBox* line = NS_NewLineBox(presShell, prevSiblingNextFrame, rem, PR_FALSE);
      if (!line) {
        return NS_ERROR_OUT_OF_MEMORY;
      }
      mLines.after_insert(prevSibLine, line);
      prevSibLine-&gt;SetChildCount(prevSibLine-&gt;GetChildCount() - rem);
      <comment type="line">// Mark prevSibLine dirty and as needing textrun invalidation, since</comment>
      <comment type="line">// we may be breaking up text in the line. Its previous line may also</comment>
      <comment type="line">// need to be invalidated because it may be able to pull some text up.</comment>
      MarkLineDirty(prevSibLine);
      <comment type="line">// The new line will also need its textruns recomputed because of the</comment>
      <comment type="line">// frame changes.</comment>
      line-&gt;SetInvalidateTextRuns(PR_TRUE);
    }

    <comment type="line">// Now (partially) join the sibling lists together</comment>
    aPrevSibling-&gt;SetNextSibling(aFrameList);
  }
  else if (! mLines.empty()) {
    prevSiblingNextFrame = mLines.front()-&gt;mFirstChild;
    mLines.front()-&gt;SetInvalidateTextRuns(PR_TRUE);
  }

  <comment type="line">// Walk through the new frames being added and update the line data</comment>
  <comment type="line">// structures to fit.</comment>
  nsIFrame* newFrame = aFrameList;
  while (newFrame) {
    NS_ASSERTION(newFrame-&gt;GetType() != nsGkAtoms::placeholderFrame ||
                 (!newFrame-&gt;GetStyleDisplay()-&gt;IsAbsolutelyPositioned() &amp;&amp;
                  !newFrame-&gt;GetStyleDisplay()-&gt;IsFloating()),
                 "Placeholders should not float or be positioned");

    PRBool isBlock = newFrame-&gt;GetStyleDisplay()-&gt;IsBlockOutside();

    <comment type="line">// If the frame is a block frame, or if there is no previous line or if the</comment>
    <comment type="line">// previous line is a block line we need to make a new line.  We also make</comment>
    <comment type="line">// a new line, as an optimization, in the three cases we know we'll need it:</comment>
    <comment type="line">// if the previous line ended with a &lt;br&gt;, if it has significant whitespace and</comment>
    <comment type="line">// ended in a newline, or if it contains continuation placeholders.</comment>
    if (isBlock || prevSibLine == end_lines() || prevSibLine-&gt;IsBlock() ||
        (aPrevSibling &amp;&amp; ShouldPutNextSiblingOnNewLine(aPrevSibling))) {
      <comment type="line">// Create a new line for the frame and add its line to the line</comment>
      <comment type="line">// list.</comment>
      nsLineBox* line = NS_NewLineBox(presShell, newFrame, 1, isBlock);
      if (!line) {
        return NS_ERROR_OUT_OF_MEMORY;
      }
      if (prevSibLine != end_lines()) {
        <comment type="line">// Append new line after prevSibLine</comment>
        mLines.after_insert(prevSibLine, line);
        ++prevSibLine;
      }
      else {
        <comment type="line">// New line is going before the other lines</comment>
        mLines.push_front(line);
        prevSibLine = begin_lines();
      }
    }
    else {
      prevSibLine-&gt;SetChildCount(prevSibLine-&gt;GetChildCount() + 1);
      <comment type="line">// We're adding inline content to prevSibLine, so we need to mark it</comment>
      <comment type="line">// dirty, ensure its textruns are recomputed, and possibly do the same</comment>
      <comment type="line">// to its previous line since that line may be able to pull content up.</comment>
      MarkLineDirty(prevSibLine);
    }

    aPrevSibling = newFrame;
    newFrame = newFrame-&gt;GetNextSibling();
  }
  if (prevSiblingNextFrame) {
    <comment type="line">// Connect the last new frame to the remainder of the sibling list</comment>
    aPrevSibling-&gt;SetNextSibling(prevSiblingNextFrame);
  }

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  VerifyLines(PR_TRUE);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  return NS_OK;
}

nsBlockFrame::line_iterator
nsBlockFrame::RemoveFloat(nsIFrame* aFloat) {
  <comment type="line">// Find which line contains the float, so we can update</comment>
  <comment type="line">// the float cache.</comment>
  line_iterator line = begin_lines()</argument>, <argument>line_end = end_lines();
  for ( ; line != line_end; ++line) {
    if (line-&gt;IsInline() &amp;&amp; line-&gt;RemoveFloat(aFloat)) {
      break;
    }
  }

  <comment type="line">// Unlink the placeholder *after* we searched the lines, because</comment>
  <comment type="line">// the line search uses the placeholder relationship.</comment>
  nsFrameManager* fm = PresContext()-&gt;GetPresShell()-&gt;FrameManager();
  nsPlaceholderFrame* placeholder = fm-&gt;GetPlaceholderFrameFor(aFloat);
  if (placeholder) {
    fm-&gt;UnregisterPlaceholderFrame(placeholder);
    placeholder-&gt;SetOutOfFlowFrame(nsnull);
  }

  <comment type="line">// Try to destroy if it's in mFloats.</comment>
  if (mFloats.DestroyFrame(aFloat)) {
    return line;
  }

  <comment type="line">// Try our overflow list</comment>
  {
    nsAutoOOFFrameList oofs(this);
    if (oofs.mList.DestroyFrame(aFloat)) {
      return line_end;
    }
  }
  
  <comment type="line">// If this is during reflow, it could be the out-of-flow frame for a</comment>
  <comment type="line">// placeholder in our block reflow state's mOverflowPlaceholders. But that's</comment>
  <comment type="line">// OK; it's not part of any child list, so we can just go ahead and delete it.</comment>
  aFloat-&gt;Destroy();
  return line_end;
}

static void MarkAllDescendantLinesDirty(nsBlockFrame* aBlock)
{
  nsLineList::iterator line = aBlock-&gt;begin_lines();
  nsLineList::iterator endLine = aBlock-&gt;end_lines();
  while (line != endLine) {
    if (line-&gt;IsBlock()) {
      nsIFrame* f = line-&gt;mFirstChild;
      void* bf;
      if (NS_SUCCEEDED(f-&gt;QueryInterface(kBlockFrameCID, &amp;bf))) {
        MarkAllDescendantLinesDirty(static_cast&lt;nsBlockFrame*&gt;(f));
      }
    }
    line-&gt;MarkDirty();
    ++line;
  }
}

static void MarkSameSpaceManagerLinesDirty(nsBlockFrame* aBlock)
{
  nsBlockFrame* blockWithSpaceMgr = aBlock;
  while (!(blockWithSpaceMgr-&gt;GetStateBits() &amp; NS_BLOCK_SPACE_MGR)) {
    void* bf;
    if (NS_FAILED(blockWithSpaceMgr-&gt;GetParent()-&gt;
                  QueryInterface(kBlockFrameCID, &amp;bf))) {
      break;
    }
    blockWithSpaceMgr = static_cast&lt;nsBlockFrame*&gt;(blockWithSpaceMgr-&gt;GetParent());
  }
    
  <comment type="line">// Mark every line at and below the line where the float was</comment>
  <comment type="line">// dirty, and mark their lines dirty too. We could probably do</comment>
  <comment type="line">// something more efficient --- e.g., just dirty the lines that intersect</comment>
  <comment type="line">// the float vertically.</comment>
  MarkAllDescendantLinesDirty(blockWithSpaceMgr);
}

<comment type="block" format="doxygen">/**
 * Returns PR_TRUE if aFrame is a block that has one or more float children.
 */</comment>
static PRBool BlockHasAnyFloats(nsIFrame* aFrame)
{
  void* bf;
  if (NS_FAILED(aFrame-&gt;QueryInterface(kBlockFrameCID, &amp;bf)))
    return PR_FALSE;
  nsBlockFrame* block = static_cast&lt;nsBlockFrame*&gt;(aFrame);
  if (block-&gt;GetFirstChild(nsGkAtoms::floatList))
    return PR_TRUE;
    
  nsLineList::iterator line = block-&gt;begin_lines();
  nsLineList::iterator endLine = block-&gt;end_lines();
  while (line != endLine) {
    if (line-&gt;IsBlock() &amp;&amp; BlockHasAnyFloats(line-&gt;mFirstChild))
      return PR_TRUE;
    ++line;
  }
  return PR_FALSE;
}

NS_IMETHODIMP
nsBlockFrame::RemoveFrame(nsIAtom*  aListName,
                          nsIFrame* aOldFrame)
{
  nsresult rv = NS_OK;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_REFLOW_REASON</name></cpp:ifdef>
  ListTag(stdout);
  printf(": remove ");
  nsFrame::ListTag(stdout, aOldFrame);
  printf("\n");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  if (nsnull == aListName) {
    PRBool hasFloats = BlockHasAnyFloats(aOldFrame);
    rv = DoRemoveFrame(aOldFrame, PR_TRUE, PR_FALSE);
    if (hasFloats) {
      MarkSameSpaceManagerLinesDirty(this);
    }
  }
  else if (nsGkAtoms::absoluteList == aListName) {
    return mAbsoluteContainer.RemoveFrame(this, aListName, aOldFrame);
  }
  else if (nsGkAtoms::floatList == aListName) {
    nsIFrame* curFrame = aOldFrame;
    <comment type="line">// Make sure to delete all the continuations for the float frame</comment>
    <comment type="line">// we are removing; this way is a bit messy, but so is the rest of the code.</comment>
    <comment type="line">// See bug 390762.</comment>
    do {
      nsIFrame* continuation = curFrame-&gt;GetNextContinuation();
      nsBlockFrame* curParent = static_cast&lt;nsBlockFrame*&gt;(curFrame-&gt;GetParent());
      curParent-&gt;RemoveFloat(curFrame);
      MarkSameSpaceManagerLinesDirty(curParent);
      curFrame = continuation;
    } while (curFrame);
  }
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
  else if (nsGkAtoms::nextBidi == aListName) {
    <comment type="line">// Skip the call to |FrameNeedsReflow| below by returning now.</comment>
    return DoRemoveFrame(aOldFrame, PR_TRUE, PR_FALSE);
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// IBMBIDI</comment>
  else {
    NS_ERROR("unexpected child list");
    rv = NS_ERROR_INVALID_ARG;
  }

  if (NS_SUCCEEDED(rv)) {
    PresContext()-&gt;PresShell()-&gt;
      FrameNeedsReflow(this, nsIPresShell::eTreeChange,
                       NS_FRAME_HAS_DIRTY_CHILDREN); <comment type="line">// XXX sufficient?</comment>
  }
  return rv;
}

void
nsBlockFrame::DoRemoveOutOfFlowFrame(nsIFrame* aFrame)
{
  <comment type="line">// The containing block is always the parent of aFrame.</comment>
  nsBlockFrame* block = (nsBlockFrame*)aFrame-&gt;GetParent();

  <comment type="line">// Remove aFrame from the appropriate list.</comment>
  const nsStyleDisplay* display = aFrame-&gt;GetStyleDisplay();
  if (display-&gt;IsAbsolutelyPositioned()) {
    <comment type="line">// This also deletes the next-in-flows</comment>
    block-&gt;mAbsoluteContainer.RemoveFrame(block,
                                          nsGkAtoms::absoluteList,
                                          aFrame);
  }
  else {
    <comment type="line">// First remove aFrame's next in flow</comment>
    nsIFrame* nextInFlow = aFrame-&gt;GetNextInFlow();
    if (nextInFlow) {
      nsBlockFrame::DoRemoveOutOfFlowFrame(nextInFlow);
    }
    <comment type="line">// Now remove aFrame</comment>
    <comment type="line">// This also destroys the frame.</comment>
    block-&gt;RemoveFloat(aFrame);
  }
}

<comment type="block" format="doxygen">/**
 * This helps us iterate over the list of all normal + overflow lines
 */</comment>
void
nsBlockFrame::TryAllLines(nsLineList::iterator* aIterator,
                          nsLineList::iterator* aStartIterator,
                          nsLineList::iterator* aEndIterator,
                          PRBool* aInOverflowLines) {
  if (*aIterator == *aEndIterator) {
    if (!*aInOverflowLines) {
      *aInOverflowLines = PR_TRUE;
      <comment type="line">// Try the overflow lines</comment>
      nsLineList* overflowLines = GetOverflowLines();
      if (overflowLines) {
        *aStartIterator = overflowLines-&gt;begin();
        *aIterator = *aStartIterator;
        *aEndIterator = overflowLines-&gt;end();
      }
    }
  }
}

nsBlockInFlowLineIterator::nsBlockInFlowLineIterator(nsBlockFrame* aFrame,
    line_iterator&amp; aLine, PRBool aInOverflow)
  : mFrame(aFrame)</argument>, <argument>mLine(aLine)</argument>, <argument>mInOverflowLines(nsnull)
{
  if (aInOverflow) {
    mInOverflowLines = aFrame-&gt;GetOverflowLines();
    NS_ASSERTION(mInOverflowLines, "How can we be in overflow if there isn't any?");
  }
}

PRBool
nsBlockInFlowLineIterator::Next()
{
  ++mLine;
  line_iterator end = mInOverflowLines ? mInOverflowLines-&gt;end() : mFrame-&gt;end_lines();
  if (mLine != end)
    return PR_TRUE;
  PRBool currentlyInOverflowLines = mInOverflowLines != nsnull;
  while (PR_TRUE) {
    if (currentlyInOverflowLines) {
      mFrame = static_cast&lt;nsBlockFrame*&gt;(mFrame-&gt;GetNextInFlow());
      if (!mFrame)
        return PR_FALSE;
      mInOverflowLines = nsnull;
      mLine = mFrame-&gt;begin_lines();
      if (mLine != mFrame-&gt;end_lines())
        return PR_TRUE;
    } else {
      mInOverflowLines = mFrame-&gt;GetOverflowLines();
      if (mInOverflowLines) {
        mLine = mInOverflowLines-&gt;begin();
        NS_ASSERTION(mLine != mInOverflowLines-&gt;end(), "empty overflow line list?");
        return PR_TRUE;
      }
    }
    currentlyInOverflowLines = !currentlyInOverflowLines;
  }
}

PRBool
nsBlockInFlowLineIterator::Prev()
{
  line_iterator begin = mInOverflowLines ? mInOverflowLines-&gt;begin() : mFrame-&gt;begin_lines();
  if (mLine != begin) {
    --mLine;
    return PR_TRUE;
  }
  PRBool currentlyInOverflowLines = mInOverflowLines != nsnull;
  while (PR_TRUE) {
    if (currentlyInOverflowLines) {
      mLine = mFrame-&gt;end_lines();
      if (mLine != mFrame-&gt;begin_lines()) {
        --mLine;
        return PR_TRUE;
      }
    } else {
      mFrame = static_cast&lt;nsBlockFrame*&gt;(mFrame-&gt;GetPrevInFlow());
      if (!mFrame)
        return PR_FALSE;
      mInOverflowLines = mFrame-&gt;GetOverflowLines();
      if (mInOverflowLines) {
        mLine = mInOverflowLines-&gt;end();
        NS_ASSERTION(mLine != mInOverflowLines-&gt;begin(), "empty overflow line list?");
        --mLine;
        return PR_TRUE;
      }
    }
    currentlyInOverflowLines = !currentlyInOverflowLines;
  }
}

static nsresult RemoveBlockChild(nsIFrame* aFrame, PRBool aDestroyFrames)
{
  if (!aFrame)
    return NS_OK;

  nsBlockFrame* nextBlock = static_cast&lt;nsBlockFrame*&gt;(aFrame-&gt;GetParent());
  NS_ASSERTION(nextBlock-&gt;GetType() == nsGkAtoms::blockFrame ||
               nextBlock-&gt;GetType() == nsGkAtoms::areaFrame,
               "Our child's continuation's parent is not a block?");
  return nextBlock-&gt;DoRemoveFrame(aFrame, aDestroyFrames);
}

<comment type="line">// This function removes aDeletedFrame and all its continuations.  It</comment>
<comment type="line">// is optimized for deleting a whole series of frames. The easy</comment>
<comment type="line">// implementation would invoke itself recursively on</comment>
<comment type="line">// aDeletedFrame-&gt;GetNextContinuation, then locate the line containing</comment>
<comment type="line">// aDeletedFrame and remove aDeletedFrame from that line. But here we</comment>
<comment type="line">// start by locating aDeletedFrame and then scanning from that point</comment>
<comment type="line">// on looking for continuations.</comment>
nsresult
nsBlockFrame::DoRemoveFrame(nsIFrame* aDeletedFrame, PRBool aDestroyFrames,
                            PRBool aRemoveOnlyFluidContinuations)
{
  <comment type="line">// Clear our line cursor, since our lines may change.</comment>
  ClearLineCursor();

  nsPresContext* presContext = PresContext();
  if (NS_FRAME_IS_OVERFLOW_CONTAINER &amp; aDeletedFrame-&gt;GetStateBits()) {
    if (aDestroyFrames) {
      nsIFrame* nif = aDeletedFrame-&gt;GetNextInFlow();
      if (nif)
        static_cast&lt;nsContainerFrame*&gt;(nif-&gt;GetParent())
          -&gt;nsContainerFrame::DeleteNextInFlowChild(presContext, nif);
      nsresult rv = nsContainerFrame::StealFrame(presContext, aDeletedFrame);
      NS_ENSURE_SUCCESS(rv, rv);
      aDeletedFrame-&gt;Destroy();
    }
    else {
      PR_NOT_REACHED("We can't not destroy overflow containers");
      return NS_ERROR_NOT_IMPLEMENTED;
      <comment type="line">//XXXfr It seems not destroying frames is only used for placeholder</comment>
      <comment type="line">// continuations; see nsBlockFrame::HandleOverflowPlaceholdersForPulledFrame.</comment>
      <comment type="line">// If we get rid of placeholder continuations, we can simplify this</comment>
      <comment type="line">// function by getting rid of that option.</comment>
    }
    return NS_OK;
  }

  if (aDeletedFrame-&gt;GetStateBits() &amp; NS_FRAME_OUT_OF_FLOW) {
    NS_ASSERTION(aDestroyFrames, "We can't not destroy out of flows");
    DoRemoveOutOfFlowFrame(aDeletedFrame);
    return NS_OK;
  }
  
  nsIPresShell* presShell = presContext-&gt;PresShell();

  PRBool isPlaceholder = nsGkAtoms::placeholderFrame == aDeletedFrame-&gt;GetType();
  if (isPlaceholder) {
    nsFrameList* overflowPlaceholders = GetOverflowPlaceholders();
    if (overflowPlaceholders &amp;&amp; overflowPlaceholders-&gt;RemoveFrame(aDeletedFrame)) {
      nsIFrame* nif = aDeletedFrame-&gt;GetNextInFlow();
      if (aDestroyFrames) {
        aDeletedFrame-&gt;Destroy();
      } else {
        aDeletedFrame-&gt;SetNextSibling(nsnull);
      }
      return RemoveBlockChild(nif, aDestroyFrames);
    }
  }
  
  <comment type="line">// Find the line and the previous sibling that contains</comment>
  <comment type="line">// deletedFrame; we also find the pointer to the line.</comment>
  nsLineList::iterator line_start = mLines.begin()</argument>,
                       <argument>line_end = mLines.end();
  nsLineList::iterator line = line_start;
  PRBool searchingOverflowList = PR_FALSE;
  nsIFrame* prevSibling = nsnull;
  <comment type="line">// Make sure we look in the overflow lines even if the normal line</comment>
  <comment type="line">// list is empty</comment>
  TryAllLines(&amp;line, &amp;line_start, &amp;line_end, &amp;searchingOverflowList);
  while (line != line_end) {
    nsIFrame* frame = line-&gt;mFirstChild;
    PRInt32 n = line-&gt;GetChildCount();
    while (--n &gt;= 0) {
      if (frame == aDeletedFrame) {
        goto found_frame;
      }
      prevSibling = frame;
      frame = frame-&gt;GetNextSibling();
    }
    ++line;
    TryAllLines(&amp;line, &amp;line_start, &amp;line_end, &amp;searchingOverflowList);
  }
found_frame:;
  if (line == line_end) {
    NS_ERROR("can't find deleted frame in lines");
    return NS_ERROR_FAILURE;
  }
  
  if (line != line_start) {
    line.prev()-&gt;SetInvalidateTextRuns(PR_TRUE);
  }
  else if (searchingOverflowList &amp;&amp; !mLines.empty()) {
    mLines.back()-&gt;SetInvalidateTextRuns(PR_TRUE);
  }

  if (prevSibling &amp;&amp; !prevSibling-&gt;GetNextSibling()) {
    <comment type="line">// We must have found the first frame in the overflow line list. So</comment>
    <comment type="line">// there is no prevSibling</comment>
    prevSibling = nsnull;
  }
  NS_ASSERTION(!prevSibling || prevSibling-&gt;GetNextSibling() == aDeletedFrame, "bad prevSibling");

  while ((line != line_end) &amp;&amp; (nsnull != aDeletedFrame)) {
    NS_ASSERTION(this == aDeletedFrame-&gt;GetParent(), "messed up delete code");
    NS_ASSERTION(line-&gt;Contains(aDeletedFrame), "frame not in line");

    line-&gt;SetInvalidateTextRuns(PR_TRUE);

    <comment type="line">// If the frame being deleted is the last one on the line then</comment>
    <comment type="line">// optimize away the line-&gt;Contains(next-in-flow) call below.</comment>
    PRBool isLastFrameOnLine = (1 == line-&gt;GetChildCount() ||
                                line-&gt;LastChild() == aDeletedFrame);

    <comment type="line">// Remove aDeletedFrame from the line</comment>
    nsIFrame* nextFrame = aDeletedFrame-&gt;GetNextSibling();
    if (line-&gt;mFirstChild == aDeletedFrame) {
      <comment type="line">// We should be setting this to null if aDeletedFrame</comment>
      <comment type="line">// is the only frame on the line. HOWEVER in that case</comment>
      <comment type="line">// we will be removing the line anyway, see below.</comment>
      line-&gt;mFirstChild = nextFrame;
    }

    <comment type="line">// Hmm, this won't do anything if we're removing a frame in the first</comment>
    <comment type="line">// overflow line... Hopefully doesn't matter</comment>
    --line;
    if (line != line_end &amp;&amp; !line-&gt;IsBlock()) {
      <comment type="line">// Since we just removed a frame that follows some inline</comment>
      <comment type="line">// frames, we need to reflow the previous line.</comment>
      line-&gt;MarkDirty();
    }
    ++line;

    <comment type="line">// Take aDeletedFrame out of the sibling list. Note that</comment>
    <comment type="line">// prevSibling will only be nsnull when we are deleting the very</comment>
    <comment type="line">// first frame in the main or overflow list.</comment>
    if (prevSibling) {
      prevSibling-&gt;SetNextSibling(nextFrame);
    }

    <comment type="line">// Update the child count of the line to be accurate</comment>
    PRInt32 lineChildCount = line-&gt;GetChildCount();
    lineChildCount--;
    line-&gt;SetChildCount(lineChildCount);

    <comment type="line">// Destroy frame; capture its next continuation first in case we need</comment>
    <comment type="line">// to destroy that too.</comment>
    nsIFrame* deletedNextContinuation = aRemoveOnlyFluidContinuations ?
      aDeletedFrame-&gt;GetNextInFlow() : aDeletedFrame-&gt;GetNextContinuation();
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_REMOVE_FRAME</name></cpp:ifdef>
    printf("DoRemoveFrame: %s line=%p frame=",
           searchingOverflowList?"overflow":"normal", line.get());
    nsFrame::ListTag(stdout, aDeletedFrame);
    printf(" prevSibling=%p deletedNextContinuation=%p\n", prevSibling, deletedNextContinuation);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    if (aDestroyFrames) {
      aDeletedFrame-&gt;Destroy();
    } else {
      aDeletedFrame-&gt;SetNextSibling(nsnull);
    }
    aDeletedFrame = deletedNextContinuation;

    PRBool haveAdvancedToNextLine = PR_FALSE;
    <comment type="line">// If line is empty, remove it now.</comment>
    if (0 == lineChildCount) {
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_REMOVE_FRAME</name></cpp:ifdef>
        printf("DoRemoveFrame: %s line=%p became empty so it will be removed\n",
               searchingOverflowList?"overflow":"normal", line.get());
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      nsLineBox *cur = line;
      if (!searchingOverflowList) {
        line = mLines.erase(line);
        <comment type="line">// Invalidate the space taken up by the line.</comment>
        <comment type="line">// XXX We need to do this if we're removing a frame as a result of</comment>
        <comment type="line">// a call to RemoveFrame(), but we may not need to do this in all</comment>
        <comment type="line">// cases...</comment>
        nsRect lineCombinedArea(cur-&gt;GetCombinedArea());
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_BLOCK_INVALIDATE</name></cpp:ifdef>
        printf("%p invalidate 10 (%d, %d, %d, %d)\n",
               this, lineCombinedArea.x, lineCombinedArea.y,
               lineCombinedArea.width, lineCombinedArea.height);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        Invalidate(lineCombinedArea);
      } else {
        nsLineList* lineList = RemoveOverflowLines();
        line = lineList-&gt;erase(line);
        if (!lineList-&gt;empty()) {
          SetOverflowLines(lineList);
        }
      }
      cur-&gt;Destroy(presShell);

      <comment type="line">// If we're removing a line, ReflowDirtyLines isn't going to</comment>
      <comment type="line">// know that it needs to slide lines unless something is marked</comment>
      <comment type="line">// dirty.  So mark the previous margin of the next line dirty if</comment>
      <comment type="line">// there is one.</comment>
      if (line != line_end) {
        line-&gt;MarkPreviousMarginDirty();
      }
      haveAdvancedToNextLine = PR_TRUE;
    } else {
      <comment type="line">// Make the line that just lost a frame dirty, and advance to</comment>
      <comment type="line">// the next line.</comment>
      if (!deletedNextContinuation || isLastFrameOnLine ||
          !line-&gt;Contains(deletedNextContinuation)) {
        line-&gt;MarkDirty();
        ++line;
        haveAdvancedToNextLine = PR_TRUE;
      }
    }

    if (deletedNextContinuation) {
      <comment type="line">// Continuations for placeholder frames don't always appear in</comment>
      <comment type="line">// consecutive lines. So for placeholders, just continue the slow easy way.</comment>
      if (isPlaceholder) {
        return RemoveBlockChild(deletedNextContinuation, aDestroyFrames);
      }

      <comment type="line">// See if we should keep looking in the current flow's line list.</comment>
      if (deletedNextContinuation-&gt;GetParent() != this) {
        <comment type="line">// The deceased frames continuation is not a child of the</comment>
        <comment type="line">// current block. So break out of the loop so that we advance</comment>
        <comment type="line">// to the next parent.</comment>
        break;
      }

      <comment type="line">// If we advanced to the next line then check if we should switch to the</comment>
      <comment type="line">// overflow line list.</comment>
      if (haveAdvancedToNextLine) {
        if (line != line_end &amp;&amp; !searchingOverflowList &amp;&amp;
            !line-&gt;Contains(deletedNextContinuation)) {
          <comment type="line">// We have advanced to the next *normal* line but the next-in-flow</comment>
          <comment type="line">// is not there - force a switch to the overflow line list.</comment>
          line = line_end;
        }

        PRBool wasSearchingOverflowList = searchingOverflowList;
        TryAllLines(&amp;line, &amp;line_start, &amp;line_end, &amp;searchingOverflowList);
        if (NS_UNLIKELY(searchingOverflowList &amp;&amp; !wasSearchingOverflowList &amp;&amp;
                        prevSibling)) {
          <comment type="line">// We switched to the overflow line list and we have a prev sibling</comment>
          <comment type="line">// (in the main list), in this case we don't want to pick up any</comment>
          <comment type="line">// sibling list from the deceased frames (bug 344557).</comment>
          prevSibling-&gt;SetNextSibling(nsnull);
          prevSibling = nsnull;
        }
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_REMOVE_FRAME</name></cpp:ifdef>
        printf("DoRemoveFrame: now on %s line=%p prevSibling=%p\n",
               searchingOverflowList?"overflow":"normal", line.get(),
               prevSibling);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }
    }
  }
  
  if (line.next() != line_end) {
    line.next()-&gt;SetInvalidateTextRuns(PR_TRUE);
  }

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  VerifyLines(PR_TRUE);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Advance to next flow block if the frame has more continuations</comment>
  return RemoveBlockChild(aDeletedFrame, aDestroyFrames);
}

nsresult
nsBlockFrame::StealFrame(nsPresContext* aPresContext,
                         nsIFrame*      aChild,
                         PRBool         aForceNormal)
{
  NS_PRECONDITION(aPresContext &amp;&amp; aChild, "null pointer");

  if ((aChild-&gt;GetStateBits() &amp; NS_FRAME_IS_OVERFLOW_CONTAINER)
      &amp;&amp; !aForceNormal)
    return nsContainerFrame::StealFrame(aPresContext, aChild);

  <comment type="line">// Find the line and the previous sibling that contains</comment>
  <comment type="line">// aChild; we also find the pointer to the line.</comment>
  nsLineList::iterator line = mLines.begin()</argument>,
                       <argument>line_start = line</argument>,
                       <argument>line_end = mLines.end();
  PRBool searchingOverflowList = PR_FALSE;
  nsIFrame* prevSibling = nsnull;
  <comment type="line">// Make sure we look in the overflow lines even if the normal line</comment>
  <comment type="line">// list is empty</comment>
  TryAllLines(&amp;line, &amp;line_start, &amp;line_end, &amp;searchingOverflowList);
  while (line != line_end) {
    nsIFrame* frame = line-&gt;mFirstChild;
    PRInt32 n = line-&gt;GetChildCount();
    while (--n &gt;= 0) {
      if (frame == aChild) {
        <comment type="line">// Disconnect from sibling list</comment>
        if (prevSibling)
          prevSibling-&gt;SetNextSibling(frame-&gt;GetNextSibling());
        else
          line-&gt;mFirstChild = frame-&gt;GetNextSibling();
        frame-&gt;SetNextSibling(nsnull);

        <comment type="line">// Register removal with the line boxes</comment>
        PRInt32 count = line-&gt;GetChildCount();
        line-&gt;SetChildCount(--count);
        if (count &gt; 0) {
           line-&gt;MarkDirty();
        }
        else {
          <comment type="line">// Remove the line box</comment>
          nsLineBox* lineBox = line;
          if (searchingOverflowList) {
            <comment type="line">// Erase line, but avoid making the overflow line list empty</comment>
            nsLineList* lineList = RemoveOverflowLines();
            lineList-&gt;erase(line);
            if (!lineList-&gt;empty()) {
              nsresult rv = SetOverflowLines(lineList);
              NS_ENSURE_SUCCESS(rv, rv);
            }
          }
          else {
            mLines.erase(line);
          }
          lineBox-&gt;Destroy(aPresContext-&gt;PresShell());
          if (line != line_end) {
            <comment type="line">// Line disappeared, so tell next line it may have to change position</comment>
            line-&gt;MarkPreviousMarginDirty();
          }
        }

        <comment type="line">// Ok, we're done</comment>
        return NS_OK;
      }
      prevSibling = frame;
      frame = frame-&gt;GetNextSibling();
    }
    ++line;
    TryAllLines(&amp;line, &amp;line_start, &amp;line_end, &amp;searchingOverflowList);
  }
  return NS_ERROR_UNEXPECTED;
}

void
nsBlockFrame::DeleteNextInFlowChild(nsPresContext* aPresContext,
                                    nsIFrame*       aNextInFlow)
{
  nsIFrame* prevInFlow = aNextInFlow-&gt;GetPrevInFlow();
  NS_PRECONDITION(prevInFlow, "bad next-in-flow");

  if (NS_FRAME_IS_OVERFLOW_CONTAINER &amp; aNextInFlow-&gt;GetStateBits()) {
    nsContainerFrame::DeleteNextInFlowChild(aPresContext, aNextInFlow);
  }
  else {
    DoRemoveFrame(aNextInFlow);
  }
}

<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Float support</comment>

nsresult
nsBlockFrame::ReflowFloat(nsBlockReflowState&amp; aState,
                          nsPlaceholderFrame* aPlaceholder,
                          nsMargin&amp;           aFloatMargin,
                          nsReflowStatus&amp;     aReflowStatus)
{
  <comment type="line">// Reflow the float.</comment>
  nsIFrame* floatFrame = aPlaceholder-&gt;GetOutOfFlowFrame();
  aReflowStatus = NS_FRAME_COMPLETE;

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_FLOAT</name></cpp:ifdef>
  printf("Reflow Float %p in parent %p, availSpace(%d,%d,%d,%d)\n",
          aPlaceholder-&gt;GetOutOfFlowFrame(), this, 
          aState.mAvailSpaceRect.x, aState.mAvailSpaceRect.y, 
          aState.mAvailSpaceRect.width, aState.mAvailSpaceRect.height
  );
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Compute the available width. By default, assume the width of the</comment>
  <comment type="line">// containing block.</comment>
  nscoord availWidth;
  const nsStyleDisplay* floatDisplay = floatFrame-&gt;GetStyleDisplay();

  if (NS_STYLE_DISPLAY_TABLE != floatDisplay-&gt;mDisplay ||
      eCompatibility_NavQuirks != aState.mPresContext-&gt;CompatibilityMode() ) {
    availWidth = aState.mContentArea.width;
  }
  else {
    <comment type="line">// This quirk matches the one in nsBlockReflowState::FlowAndPlaceFloat</comment>
    <comment type="line">// give tables only the available space</comment>
    <comment type="line">// if they can shrink we may not be constrained to place</comment>
    <comment type="line">// them in the next line</comment>
    availWidth = aState.mAvailSpaceRect.width;
    <comment type="line">// round down to twips per pixel so that we fit</comment>
    <comment type="line">// needed when prev. float has procentage width</comment>
    <comment type="line">// (maybe is a table flaw that makes table chose to round up</comment>
    <comment type="line">// but I don't want to change that, too risky)</comment>
    nscoord twp = nsPresContext::CSSPixelsToAppUnits(1);
    availWidth -=  availWidth % twp;
  }

  <comment type="line">// aState.mY is relative to the border-top, make it relative to the content-top</comment>
  nscoord contentYOffset = aState.mY - aState.BorderPadding().top;
  nscoord availHeight = NS_UNCONSTRAINEDSIZE == aState.mContentArea.height
                        ? NS_UNCONSTRAINEDSIZE 
                        : PR_MAX(0, aState.mContentArea.height - contentYOffset);

  nsRect availSpace(aState.BorderPadding().left,
                    aState.BorderPadding().top,
                    availWidth, availHeight);

  <comment type="line">// construct the html reflow state for the float. ReflowBlock will </comment>
  <comment type="line">// initialize it.</comment>
  nsHTMLReflowState floatRS(aState.mPresContext, aState.mReflowState,
                            floatFrame, 
                            nsSize(availSpace.width, availSpace.height));

  <comment type="line">// Setup a block reflow state to reflow the float.</comment>
  nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);

  <comment type="line">// Reflow the float</comment>
  PRBool isAdjacentWithTop = aState.IsAdjacentWithTop();

  nsIFrame* clearanceFrame = nsnull;
  nsresult rv;
  do {
    nsCollapsingMargin margin;
    PRBool mayNeedRetry = PR_FALSE;
    floatRS.mDiscoveredClearance = nsnull;
    <comment type="line">// Only first in flow gets a top margin.</comment>
    if (!floatFrame-&gt;GetPrevInFlow()) {
      nsBlockReflowContext::ComputeCollapsedTopMargin(floatRS, &amp;margin,
                                                      clearanceFrame, &amp;mayNeedRetry);

      if (mayNeedRetry &amp;&amp; !clearanceFrame) {
        floatRS.mDiscoveredClearance = &amp;clearanceFrame;
        <comment type="line">// We don't need to push the space manager state because the the block has its own</comment>
        <comment type="line">// space manager that will be destroyed and recreated</comment>
      }
    }

    nsMargin offsets; <comment type="line">// Don't bother returning this to the caller; it's stored</comment>
                      <comment type="line">// on a frame property anyawy</comment>
    rv = brc.ReflowBlock(availSpace, PR_TRUE, margin,
                         0, isAdjacentWithTop,
                         offsets, nsnull, floatRS,
                         aReflowStatus, aState);
  } while (NS_SUCCEEDED(rv) &amp;&amp; clearanceFrame);

  <comment type="line">// An incomplete reflow status means we should split the float </comment>
  <comment type="line">// if the height is constrained (bug 145305). </comment>
  if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus) &amp;&amp; (NS_UNCONSTRAINEDSIZE == availHeight))
    aReflowStatus = NS_FRAME_COMPLETE;

  <comment type="line">//XXXfr Floats can't be overflow incomplete yet</comment>
  if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aReflowStatus))
    NS_FRAME_SET_INCOMPLETE(aReflowStatus);
  
  if (NS_FRAME_IS_COMPLETE(aReflowStatus)) {
    <comment type="line">// Float is now complete, so delete the placeholder's next in</comment>
    <comment type="line">// flows, if any; their floats (which are this float's continuations)</comment>
    <comment type="line">// have already been deleted.</comment>
    <comment type="line">// XXX won't this be done later in nsLineLayout::ReflowFrame anyway??</comment>
    nsIFrame* nextInFlow = aPlaceholder-&gt;GetNextInFlow();
    if (nextInFlow) {
      static_cast&lt;nsHTMLContainerFrame*&gt;(nextInFlow-&gt;GetParent())
        -&gt;DeleteNextInFlowChild(aState.mPresContext, nextInFlow);
      <comment type="line">// that takes care of all subsequent nextinflows too</comment>
    }
  }
  if (aReflowStatus &amp; NS_FRAME_REFLOW_NEXTINFLOW) {
    aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
  }

  if (floatFrame-&gt;GetType() == nsGkAtoms::letterFrame) {
    <comment type="line">// We never split floating first letters; an incomplete state for</comment>
    <comment type="line">// such frames simply means that there is more content to be</comment>
    <comment type="line">// reflowed on the line.</comment>
    if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus)) 
      aReflowStatus = NS_FRAME_COMPLETE;
  }

  if (NS_FAILED(rv)) {
    return rv;
  }

  <comment type="line">// Capture the margin information for the caller</comment>
  const nsMargin&amp; m = floatRS.mComputedMargin;
  aFloatMargin.top = brc.GetTopMargin();
  aFloatMargin.right = m.right;
  <comment type="line">// Only last in flows get a bottom margin</comment>
  if (NS_FRAME_IS_COMPLETE(aReflowStatus)) {
    brc.GetCarriedOutBottomMargin().Include(m.bottom);
  }
  aFloatMargin.bottom = brc.GetCarriedOutBottomMargin().get();
  aFloatMargin.left = m.left;

  const nsHTMLReflowMetrics&amp; metrics = brc.GetMetrics();

  <comment type="line">// Set the rect, make sure the view is properly sized and positioned,</comment>
  <comment type="line">// and tell the frame we're done reflowing it</comment>
  <comment type="line">// XXXldb This seems like the wrong place to be doing this -- shouldn't</comment>
  <comment type="line">// we be doing this in nsBlockReflowState::FlowAndPlaceFloat after</comment>
  <comment type="line">// we've positioned the float, and shouldn't we be doing the equivalent</comment>
  <comment type="line">// of |::PlaceFrameView| here?</comment>
  floatFrame-&gt;SetSize(nsSize(metrics.width, metrics.height));
  if (floatFrame-&gt;HasView()) {
    nsContainerFrame::SyncFrameViewAfterReflow(aState.mPresContext, floatFrame,
                                               floatFrame-&gt;GetView(),
                                               &amp;metrics.mOverflowArea,
                                               NS_FRAME_NO_MOVE_VIEW);
  }
  <comment type="line">// Pass floatRS so the frame hierarchy can be used (redoFloatRS has the same hierarchy)  </comment>
  floatFrame-&gt;DidReflow(aState.mPresContext, &amp;floatRS,
                        NS_FRAME_REFLOW_FINISHED);

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOISY_FLOAT</name></cpp:ifdef>
  printf("end ReflowFloat %p, sized to %d,%d\n",
         floatFrame, metrics.width, metrics.height);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// If the placeholder was continued and its first-in-flow was followed by a </comment>
  <comment type="line">// &lt;BR&gt;, then cache the &lt;BR&gt;'s break type in aState.mFloatBreakType so that</comment>
  <comment type="line">// the next frame after the placeholder can combine that break type with its own</comment>
  nsIFrame* prevPlaceholder = aPlaceholder-&gt;GetPrevInFlow();
  if (prevPlaceholder) {
    <comment type="line">// the break occurs only after the last continued placeholder</comment>
    PRBool lastPlaceholder = PR_TRUE;
    nsIFrame* next = aPlaceholder-&gt;GetNextSibling();
    if (next) {
      if (nsGkAtoms::placeholderFrame == next-&gt;GetType()) {
        lastPlaceholder = PR_FALSE;
      }
    }
    if (lastPlaceholder) {
      <comment type="line">// get the containing block of prevPlaceholder which is our prev-in-flow</comment>
      if (GetPrevInFlow()) {
        <comment type="line">// get the break type of the last line in mPrevInFlow</comment>
        nsBlockFrame* prevBlock = static_cast&lt;nsBlockFrame*&gt;(GetPrevInFlow());
        line_iterator endLine = prevBlock-&gt;end_lines();
        if (endLine != prevBlock-&gt;begin_lines()) {
          --endLine;
          if (endLine-&gt;HasFloatBreakAfter())
            aState.mFloatBreakType = endLine-&gt;GetBreakTypeAfter();
        }
      }
      else NS_ASSERTION(PR_FALSE, "no prev in flow");
    }
  }
  return NS_OK;
}

<comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Painting, event handling</comment>

PRIntn
nsBlockFrame::GetSkipSides() const
{
  if (IS_TRUE_OVERFLOW_CONTAINER(this))
    return (1 &lt;&lt; NS_SIDE_TOP) | (1 &lt;&lt; NS_SIDE_BOTTOM);

  PRIntn skip = 0;
  if (GetPrevInFlow()) {
    skip |= 1 &lt;&lt; NS_SIDE_TOP;
  }
  nsIFrame* nif = GetNextInFlow();
  if (nif &amp;&amp; !IS_TRUE_OVERFLOW_CONTAINER(nif)) {
    skip |= 1 &lt;&lt; NS_SIDE_BOTTOM;
  }
  return skip;
}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
static void ComputeCombinedArea(nsLineList&amp; aLines,
                                nscoord aWidth, nscoord aHeight,
                                nsRect&amp; aResult)
{
  nscoord xa = 0</argument>, <argument>ya = 0</argument>, <argument>xb = aWidth</argument>, <argument>yb = aHeight;
  for (nsLineList::iterator line = aLines.begin(), line_end = aLines.end();
       line != line_end;
       ++line) {
    <comment type="line">// Compute min and max x/y values for the reflowed frame's</comment>
    <comment type="line">// combined areas</comment>
    nsRect lineCombinedArea(line-&gt;GetCombinedArea());
    nscoord x = lineCombinedArea.x;
    nscoord y = lineCombinedArea.y;
    nscoord xmost = x + lineCombinedArea.width;
    nscoord ymost = y + lineCombinedArea.height;
    if (x &lt; xa) {
      xa = x;
    }
    if (xmost &gt; xb) {
      xb = xmost;
    }
    if (y &lt; ya) {
      ya = y;
    }
    if (ymost &gt; yb) {
      yb = ymost;
    }
  }

  aResult.x = xa;
  aResult.y = ya;
  aResult.width = xb - xa;
  aResult.height = yb - ya;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

PRBool
nsBlockFrame::IsVisibleInSelection(nsISelection* aSelection)
{
  nsCOMPtr&lt;nsIDOMHTMLHtmlElement&gt; html(do_QueryInterface(mContent));
  nsCOMPtr&lt;nsIDOMHTMLBodyElement&gt; body(do_QueryInterface(mContent));
  if (html || body)
    return PR_TRUE;

  nsCOMPtr&lt;nsIDOMNode&gt; node(do_QueryInterface(mContent));
  PRBool visible;
  nsresult rv = aSelection-&gt;ContainsNode(node, PR_TRUE, &amp;visible);
  return NS_SUCCEEDED(rv) &amp;&amp; visible;
}

<comment type="block">/* virtual */</comment> void
nsBlockFrame::PaintTextDecorationLine(nsIRenderingContext&amp; aRenderingContext, 
                                      nsPoint aPt,
                                      nsLineBox* aLine,
                                      nscolor aColor, 
                                      nscoord aOffset, 
                                      nscoord aAscent, 
                                      nscoord aSize,
                                      const PRUint8 aDecoration) 
{
  NS_ASSERTION(!aLine-&gt;IsBlock(), "Why did we ask for decorations on a block?");

  nscoord start = aLine-&gt;mBounds.x;
  nscoord width = aLine-&gt;mBounds.width;

  if (!GetPrevContinuation() &amp;&amp; aLine == begin_lines().get()) {
    <comment type="line">// Adjust for the text-indent.  See similar code in</comment>
    <comment type="line">// nsLineLayout::BeginLineReflow.</comment>
    nscoord indent = 0;
    const nsStyleText* styleText = GetStyleText();
    nsStyleUnit unit = styleText-&gt;mTextIndent.GetUnit();
    if (eStyleUnit_Coord == unit) {
      indent = styleText-&gt;mTextIndent.GetCoordValue();
    } else if (eStyleUnit_Percent == unit) {
      <comment type="line">// It's a percentage of the containing block width.</comment>
      nsIFrame* containingBlock =
        nsHTMLReflowState::GetContainingBlockFor(this);
      NS_ASSERTION(containingBlock, "Must have containing block!");
      indent = nscoord(styleText-&gt;mTextIndent.GetPercentValue() *
                       containingBlock-&gt;GetContentRect().width);
    }

    <comment type="line">// Adjust the start position and the width of the decoration by the</comment>
    <comment type="line">// value of the indent.  Note that indent can be negative; that's OK.</comment>
    <comment type="line">// It'll just increase the width (which can also happen to be</comment>
    <comment type="line">// negative!).</comment>
    start += indent;
    width -= indent;
  }
      
  <comment type="line">// Only paint if we have a positive width</comment>
  if (width &gt; 0) {
    const nsStyleVisibility* visibility = GetStyleVisibility();
    PRBool isRTL = visibility-&gt;mDirection == NS_STYLE_DIRECTION_RTL;
    nsRefPtr&lt;gfxContext&gt; ctx = (gfxContext*)
      aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT);
    gfxPoint pt(PresContext()-&gt;AppUnitsToGfxUnits(start + aPt.x),
                PresContext()-&gt;AppUnitsToGfxUnits(aLine-&gt;mBounds.y + aPt.y));
    gfxSize size(PresContext()-&gt;AppUnitsToGfxUnits(width),
                 PresContext()-&gt;AppUnitsToGfxUnits(aSize));
    nsCSSRendering::PaintDecorationLine(
      ctx, aColor, pt, size,
      PresContext()-&gt;AppUnitsToGfxUnits(aLine-&gt;GetAscent()),
      PresContext()-&gt;AppUnitsToGfxUnits(aOffset),
      PresContext()-&gt;AppUnitsToGfxUnits(aSize),
      aDecoration, NS_STYLE_BORDER_STYLE_SOLID, isRTL);
  }
}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
static void DebugOutputDrawLine(PRInt32 aDepth, nsLineBox* aLine, PRBool aDrawn) {
  if (nsBlockFrame::gNoisyDamageRepair) {
    nsFrame::IndentBy(stdout, aDepth+1);
    nsRect lineArea = aLine-&gt;GetCombinedArea();
    printf("%s line=%p bounds=%d,%d,%d,%d ca=%d,%d,%d,%d\n",
           aDrawn ? "draw" : "skip",
           static_cast&lt;void*&gt;(aLine),
           aLine-&gt;mBounds.x, aLine-&gt;mBounds.y,
           aLine-&gt;mBounds.width, aLine-&gt;mBounds.height,
           lineArea.x, lineArea.y,
           lineArea.width, lineArea.height);
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static nsresult
DisplayLine(nsDisplayListBuilder* aBuilder, const nsRect&amp; aLineArea,
            const nsRect&amp; aDirtyRect, nsBlockFrame::line_iterator&amp; aLine,
            PRInt32 aDepth, PRInt32&amp; aDrawnLines, const nsDisplayListSet&amp; aLists,
            nsBlockFrame* aFrame) {
  <comment type="line">// If the line's combined area (which includes child frames that</comment>
  <comment type="line">// stick outside of the line's bounding box or our bounding box)</comment>
  <comment type="line">// intersects the dirty rect then paint the line.</comment>
  PRBool intersect = aLineArea.Intersects(aDirtyRect);
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  if (nsBlockFrame::gLamePaintMetrics) {
    aDrawnLines++;
  }
  DebugOutputDrawLine(aDepth, aLine.get(), intersect);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="line">// The line might contain a placeholder for a visible out-of-flow, in which</comment>
  <comment type="line">// case we need to descend into it. If there is such a placeholder, we will</comment>
  <comment type="line">// have NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO set.</comment>
  if (!intersect &amp;&amp;
      !(aFrame-&gt;GetStateBits() &amp; NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO))
    return NS_OK;

  nsresult rv;
  nsDisplayList aboveTextDecorations;
  PRBool lineInline = aLine-&gt;IsInline();
  if (lineInline) {
    <comment type="line">// Display the text-decoration for the hypothetical anonymous inline box</comment>
    <comment type="line">// that wraps these inlines</comment>
    rv = aFrame-&gt;DisplayTextDecorations(aBuilder, aLists.Content(),
                                        &amp;aboveTextDecorations, aLine);
    NS_ENSURE_SUCCESS(rv, rv);
  }

  <comment type="line">// Block-level child backgrounds go on the blockBorderBackgrounds list ...</comment>
  <comment type="line">// Inline-level child backgrounds go on the regular child content list.</comment>
  nsDisplayListSet childLists(aLists,
      lineInline ? aLists.Content() : aLists.BlockBorderBackgrounds());
  nsIFrame* kid = aLine-&gt;mFirstChild;
  PRInt32 n = aLine-&gt;GetChildCount();
  while (--n &gt;= 0) {
    rv = aFrame-&gt;BuildDisplayListForChild(aBuilder, kid, aDirtyRect, childLists,
                                          lineInline ? nsIFrame::DISPLAY_CHILD_INLINE : 0);
    NS_ENSURE_SUCCESS(rv, rv);
    kid = kid-&gt;GetNextSibling();
  }
  
  aLists.Content()-&gt;AppendToTop(&amp;aboveTextDecorations);
  return NS_OK;
}

NS_IMETHODIMP
nsBlockFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&amp;           aDirtyRect,
                               const nsDisplayListSet&amp; aLists)
{
  PRInt32 drawnLines; <comment type="line">// Will only be used if set (gLamePaintMetrics).</comment>
  PRInt32 depth = 0;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  if (gNoisyDamageRepair) {
      depth = GetDepth();
      nsRect ca;
      ::ComputeCombinedArea(mLines, mRect.width, mRect.height, ca);
      nsFrame::IndentBy(stdout, depth);
      ListTag(stdout);
      printf(": bounds=%d,%d,%d,%d dirty(absolute)=%d,%d,%d,%d ca=%d,%d,%d,%d\n",
             mRect.x, mRect.y, mRect.width, mRect.height,
             aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height,
             ca.x, ca.y, ca.width, ca.height);
  }
  PRTime start = LL_ZERO; <comment type="line">// Initialize these variables to silence the compiler.</comment>
  if (gLamePaintMetrics) {
    start = PR_Now();
    drawnLines = 0;
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  DisplayBorderBackgroundOutline(aBuilder, aLists);

  if (GetPrevInFlow()) {
    DisplayOverflowContainers(aBuilder, aDirtyRect, aLists);
  }

  aBuilder-&gt;MarkFramesForDisplayList(this, mFloats.FirstChild(), aDirtyRect);
  aBuilder-&gt;MarkFramesForDisplayList(this, mAbsoluteContainer.GetFirstChild(), aDirtyRect);

  <comment type="line">// Don't use the line cursor if we might have a descendant placeholder ...</comment>
  <comment type="line">// it might skip lines that contain placeholders but don't themselves</comment>
  <comment type="line">// intersect with the dirty area.</comment>
  nsLineBox* cursor = GetStateBits() &amp; NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
    ? nsnull : GetFirstLineContaining(aDirtyRect.y);
  line_iterator line_end = end_lines();
  nsresult rv = NS_OK;
  
  if (cursor) {
    for (line_iterator line = mLines.begin(cursor);
         line != line_end;
         ++line) {
      nsRect lineArea = line-&gt;GetCombinedArea();
      if (!lineArea.IsEmpty()) {
        <comment type="line">// Because we have a cursor, the combinedArea.ys are non-decreasing.</comment>
        <comment type="line">// Once we've passed aDirtyRect.YMost(), we can never see it again.</comment>
        if (lineArea.y &gt;= aDirtyRect.YMost()) {
          break;
        }
        rv = DisplayLine(aBuilder, lineArea, aDirtyRect, line, depth, drawnLines,
                         aLists, this);
        if (NS_FAILED(rv))
          break;
      }
    }
  } else {
    PRBool nonDecreasingYs = PR_TRUE;
    PRInt32 lineCount = 0;
    nscoord lastY = PR_INT32_MIN;
    nscoord lastYMost = PR_INT32_MIN;
    for (line_iterator line = begin_lines();
         line != line_end;
         ++line) {
      nsRect lineArea = line-&gt;GetCombinedArea();
      rv = DisplayLine(aBuilder, lineArea, aDirtyRect, line, depth, drawnLines,
                       aLists, this);
      if (NS_FAILED(rv))
        break;
      if (!lineArea.IsEmpty()) {
        if (lineArea.y &lt; lastY
            || lineArea.YMost() &lt; lastYMost) {
          nonDecreasingYs = PR_FALSE;
        }
        lastY = lineArea.y;
        lastYMost = lineArea.YMost();
      }
      lineCount++;
    }

    if (NS_SUCCEEDED(rv) &amp;&amp; nonDecreasingYs &amp;&amp; lineCount &gt;= MIN_LINES_NEEDING_CURSOR) {
      SetupLineCursor();
    }
  }

  if (NS_SUCCEEDED(rv) &amp;&amp; (nsnull != mBullet) &amp;&amp; HaveOutsideBullet()) {
    <comment type="line">// Display outside bullets manually</comment>
    rv = BuildDisplayListForChild(aBuilder, mBullet, aDirtyRect, aLists);
  }

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  if (gLamePaintMetrics) {
    PRTime end = PR_Now();

    PRInt32 numLines = mLines.size();
    if (!numLines) numLines = 1;
    PRTime lines</argument>, <argument>deltaPerLine</argument>, <argument>delta;
    LL_I2L(lines, numLines);
    LL_SUB(delta, end, start);
    LL_DIV(deltaPerLine, delta, lines);

    ListTag(stdout);
    char buf[400];
    PR_snprintf(buf, sizeof(buf),
                ": %lld elapsed (%lld per line) lines=%d drawn=%d skip=%d",
                delta, deltaPerLine,
                numLines, drawnLines, numLines - drawnLines);
    printf("%s\n", buf);
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  return rv;
}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACCESSIBILITY</name></cpp:ifdef>
NS_IMETHODIMP nsBlockFrame::GetAccessible(nsIAccessible** aAccessible)
{
  *aAccessible = nsnull;
  nsCOMPtr&lt;nsIAccessibilityService&gt; accService = 
    do_GetService("@mozilla.org/accessibilityService;1");
  NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);

  <comment type="line">// block frame may be for &lt;hr&gt;</comment>
  if (mContent-&gt;Tag() == nsGkAtoms::hr) {
    return accService-&gt;CreateHTMLHRAccessible(static_cast&lt;nsIFrame*&gt;(this), aAccessible);
  }

  nsPresContext *aPresContext = PresContext();
  if (!mBullet || !aPresContext) {
    if (!mContent || !mContent-&gt;GetParent()) {
      <comment type="line">// Don't create accessible objects for the root content node, they are redundant with</comment>
      <comment type="line">// the nsDocAccessible object created with the document node</comment>
      return NS_ERROR_FAILURE;
    }
    
    nsCOMPtr&lt;nsIDOMHTMLDocument&gt; htmlDoc =
      do_QueryInterface(mContent-&gt;GetDocument());
    if (htmlDoc) {
      nsCOMPtr&lt;nsIDOMHTMLElement&gt; body;
      htmlDoc-&gt;GetBody(getter_AddRefs(body));
      if (SameCOMIdentity(body, mContent)) {
        <comment type="line">// Don't create accessible objects for the body, they are redundant with</comment>
        <comment type="line">// the nsDocAccessible object created with the document node</comment>
        return NS_ERROR_FAILURE;
      }
    }

    <comment type="line">// Not a bullet, treat as normal HTML container</comment>
    return accService-&gt;CreateHyperTextAccessible(static_cast&lt;nsIFrame*&gt;(this), aAccessible);
  }

  <comment type="line">// Create special list bullet accessible</comment>
  const nsStyleList* myList = GetStyleList();
  nsAutoString bulletText;
  if (myList-&gt;mListStyleImage || myList-&gt;mListStyleType == NS_STYLE_LIST_STYLE_DISC ||
      myList-&gt;mListStyleType == NS_STYLE_LIST_STYLE_CIRCLE ||
      myList-&gt;mListStyleType == NS_STYLE_LIST_STYLE_SQUARE) {
    bulletText.Assign(PRUnichar(0x2022));; <comment type="line">// Unicode bullet character</comment>
  }
  else if (myList-&gt;mListStyleType != NS_STYLE_LIST_STYLE_NONE) {
    mBullet-&gt;GetListItemText(*myList, bulletText);
  }

  return accService-&gt;CreateHTMLLIAccessible(static_cast&lt;nsIFrame*&gt;(this), 
                                            static_cast&lt;nsIFrame*&gt;(mBullet), 
                                            bulletText,
                                            aAccessible);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

void nsBlockFrame::ClearLineCursor() {
  if (!(GetStateBits() &amp; NS_BLOCK_HAS_LINE_CURSOR)) {
    return;
  }

  UnsetProperty(nsGkAtoms::lineCursorProperty);
  RemoveStateBits(NS_BLOCK_HAS_LINE_CURSOR);
}

void nsBlockFrame::SetupLineCursor() {
  if (GetStateBits() &amp; NS_BLOCK_HAS_LINE_CURSOR
      || mLines.empty()) {
    return;
  }
   
  SetProperty(nsGkAtoms::lineCursorProperty,
              mLines.front(), nsnull);
  AddStateBits(NS_BLOCK_HAS_LINE_CURSOR);
}

nsLineBox* nsBlockFrame::GetFirstLineContaining(nscoord y) {
  if (!(GetStateBits() &amp; NS_BLOCK_HAS_LINE_CURSOR)) {
    return nsnull;
  }

  nsLineBox* property = static_cast&lt;nsLineBox*&gt;
                                   (GetProperty(nsGkAtoms::lineCursorProperty));
  line_iterator cursor = mLines.begin(property);
  nsRect cursorArea = cursor-&gt;GetCombinedArea();

  while ((cursorArea.IsEmpty() || cursorArea.YMost() &gt; y)
         &amp;&amp; cursor != mLines.front()) {
    cursor = cursor.prev();
    cursorArea = cursor-&gt;GetCombinedArea();
  }
  while ((cursorArea.IsEmpty() || cursorArea.YMost() &lt;= y)
         &amp;&amp; cursor != mLines.back()) {
    cursor = cursor.next();
    cursorArea = cursor-&gt;GetCombinedArea();
  }

  if (cursor.get() != property) {
    SetProperty(nsGkAtoms::lineCursorProperty,
                cursor.get(), nsnull);
  }

  return cursor.get();
}

<comment type="block">/* virtual */</comment> void
nsBlockFrame::ChildIsDirty(nsIFrame* aChild)
{
  <comment type="line">// See if the child is absolutely positioned</comment>
  if (aChild-&gt;GetStateBits() &amp; NS_FRAME_OUT_OF_FLOW &amp;&amp;
      aChild-&gt;GetStyleDisplay()-&gt;IsAbsolutelyPositioned()) {
    <comment type="line">// do nothing</comment>
  } else if (aChild == mBullet &amp;&amp; HaveOutsideBullet()) {
    <comment type="line">// The bullet lives in the first line, unless the first line has</comment>
    <comment type="line">// height 0 and there is a second line, in which case it lives</comment>
    <comment type="line">// in the second line.</comment>
    line_iterator bulletLine = begin_lines();
    if (bulletLine != end_lines() &amp;&amp; bulletLine-&gt;mBounds.height == 0 &amp;&amp;
        bulletLine != mLines.back()) {
      bulletLine = bulletLine.next();
    }
    
    if (bulletLine != end_lines()) {
      MarkLineDirty(bulletLine);
    }
    <comment type="line">// otherwise we have an empty line list, and ReflowDirtyLines</comment>
    <comment type="line">// will handle reflowing the bullet.</comment>
  } else {
    <comment type="line">// Mark the line containing the child frame dirty. We would rather do this</comment>
    <comment type="line">// in MarkIntrinsicWidthsDirty but that currently won't tell us which</comment>
    <comment type="line">// child is being dirtied.</comment>
    line_iterator fline = FindLineFor(aChild);
    if (fline != end_lines()) {
      MarkLineDirty(fline);
    }
  }

  nsBlockFrameSuper::ChildIsDirty(aChild);
}

<comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////////</comment>
<comment type="line">// Start Debugging</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NS_DEBUG</name></cpp:ifdef>
static PRBool
InLineList(nsLineList&amp; aLines, nsIFrame* aFrame)
{
  for (nsLineList::iterator line = aLines.begin(), line_end = aLines.end();
       line != line_end;
       ++line) {
    nsIFrame* frame = line-&gt;mFirstChild;
    PRInt32 n = line-&gt;GetChildCount();
    while (--n &gt;= 0) {
      if (frame == aFrame) {
        return PR_TRUE;
      }
      frame = frame-&gt;GetNextSibling();
    }
  }
  return PR_FALSE;
}

static PRBool
InSiblingList(nsLineList&amp; aLines, nsIFrame* aFrame)
{
  if (! aLines.empty()) {
    nsIFrame* frame = aLines.front()-&gt;mFirstChild;
    while (frame) {
      if (frame == aFrame) {
        return PR_TRUE;
      }
      frame = frame-&gt;GetNextSibling();
    }
  }
  return PR_FALSE;
}

NS_IMETHODIMP
nsBlockFrame::VerifyTree() const
{
  <comment type="line">// XXX rewrite this</comment>
  return NS_OK;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// End Debugging</comment>
<comment type="line" format="doxygen">//////////////////////////////////////////////////////////////////////</comment>

NS_IMETHODIMP
nsBlockFrame::Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
                   nsIFrame*        aPrevInFlow)
{
  if (aPrevInFlow) {
    <comment type="line">// Copy over the block/area frame type flags</comment>
    nsBlockFrame*  blockFrame = (nsBlockFrame*)aPrevInFlow;

    SetFlags(blockFrame-&gt;mState &amp;
             (NS_BLOCK_FLAGS_MASK &amp; ~NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET));
  }

  nsresult rv = nsBlockFrameSuper::Init(aContent, aParent, aPrevInFlow);

  if (!aPrevInFlow ||
      aPrevInFlow-&gt;GetStateBits() &amp; NS_BLOCK_NEEDS_BIDI_RESOLUTION)
    AddStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);

  return rv;
}

NS_IMETHODIMP
nsBlockFrame::SetInitialChildList(nsIAtom*        aListName,
                                  nsIFrame*       aChildList)
{
  nsresult rv = NS_OK;

  if (nsGkAtoms::absoluteList == aListName) {
    mAbsoluteContainer.SetInitialChildList(this, aListName, aChildList);
  }
  else if (nsGkAtoms::floatList == aListName) {
    mFloats.SetFrames(aChildList);
  }
  else {
    nsPresContext* presContext = PresContext();

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="line">// The only times a block that is an anonymous box is allowed to have a</comment>
    <comment type="line">// first-letter frame are when it's the block inside a non-anonymous cell,</comment>
    <comment type="line">// the block inside a fieldset, a scrolled content block, or a column</comment>
    <comment type="line">// content block.  Note that this means that blocks which are the anonymous</comment>
    <comment type="line">// block in {ib} splits do NOT get first-letter frames.  Note that</comment>
    <comment type="line">// NS_BLOCK_HAS_FIRST_LETTER_STYLE gets set on all continuations of the</comment>
    <comment type="line">// block.</comment>
    nsIAtom *pseudo = GetStyleContext()-&gt;GetPseudoType();
    PRBool haveFirstLetterStyle =
      (!pseudo ||
       (pseudo == nsCSSAnonBoxes::cellContent &amp;&amp;
        mParent-&gt;GetStyleContext()-&gt;GetPseudoType() == nsnull) ||
       pseudo == nsCSSAnonBoxes::fieldsetContent ||
       pseudo == nsCSSAnonBoxes::scrolledContent ||
       pseudo == nsCSSAnonBoxes::columnContent) &amp;&amp;
      !IsFrameOfType(eMathML) &amp;&amp;
      nsRefPtr&lt;nsStyleContext&gt;(GetFirstLetterStyle(presContext)) != nsnull;
    NS_ASSERTION(haveFirstLetterStyle ==
                 ((mState &amp; NS_BLOCK_HAS_FIRST_LETTER_STYLE) != 0),
                 "NS_BLOCK_HAS_FIRST_LETTER_STYLE state out of sync");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    rv = AddFrames(aChildList, nsnull);
    if (NS_FAILED(rv)) {
      return rv;
    }

    <comment type="line">// Create list bullet if this is a list-item. Note that this is done</comment>
    <comment type="line">// here so that RenumberLists will work (it needs the bullets to</comment>
    <comment type="line">// store the bullet numbers).</comment>
    const nsStyleDisplay* styleDisplay = GetStyleDisplay();
    if ((nsnull == GetPrevInFlow()) &amp;&amp;
        (NS_STYLE_DISPLAY_LIST_ITEM == styleDisplay-&gt;mDisplay) &amp;&amp;
        (nsnull == mBullet)) {
      <comment type="line">// Resolve style for the bullet frame</comment>
      const nsStyleList* styleList = GetStyleList();
      nsIAtom *pseudoElement;
      switch (styleList-&gt;mListStyleType) {
        case NS_STYLE_LIST_STYLE_DISC:
        case NS_STYLE_LIST_STYLE_CIRCLE:
        case NS_STYLE_LIST_STYLE_SQUARE:
          pseudoElement = nsCSSPseudoElements::mozListBullet;
          break;
        default:
          pseudoElement = nsCSSPseudoElements::mozListNumber;
          break;
      }

      nsIPresShell *shell = presContext-&gt;PresShell();

      nsStyleContext* parentStyle =
        CorrectStyleParentFrame(this, pseudoElement)-&gt;GetStyleContext();
      nsRefPtr&lt;nsStyleContext&gt; kidSC = shell-&gt;StyleSet()-&gt;
        ResolvePseudoStyleFor(mContent, pseudoElement, parentStyle);

      <comment type="line">// Create bullet frame</comment>
      nsBulletFrame* bullet = new (shell) nsBulletFrame(kidSC);
      if (nsnull == bullet) {
        return NS_ERROR_OUT_OF_MEMORY;
      }
      bullet-&gt;Init(mContent, this, nsnull);

      <comment type="line">// If the list bullet frame should be positioned inside then add</comment>
      <comment type="line">// it to the flow now.</comment>
      if (NS_STYLE_LIST_STYLE_POSITION_INSIDE ==
          styleList-&gt;mListStylePosition) {
        AddFrames(bullet, nsnull);
        mState &amp;= ~NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET;
      }
      else {
        mState |= NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET;
      }

      mBullet = bullet;
    }
  }

  return NS_OK;
}

<comment type="line">// static</comment>
PRBool
nsBlockFrame::FrameStartsCounterScope(nsIFrame* aFrame)
{
  nsIContent* content = aFrame-&gt;GetContent();
  if (!content || !content-&gt;IsNodeOfType(nsINode::eHTML))
    return PR_FALSE;

  nsIAtom *localName = content-&gt;NodeInfo()-&gt;NameAtom();
  return localName == nsGkAtoms::ol ||
         localName == nsGkAtoms::ul ||
         localName == nsGkAtoms::dir ||
         localName == nsGkAtoms::menu;
}

PRBool
nsBlockFrame::RenumberLists(nsPresContext* aPresContext)
{
  if (!FrameStartsCounterScope(this)) {
    <comment type="line">// If this frame doesn't start a counter scope then we don't need</comment>
    <comment type="line">// to renumber child list items.</comment>
    return PR_FALSE;
  }

  <comment type="line">// Setup initial list ordinal value</comment>
  <comment type="line">// XXX Map html's start property to counter-reset style</comment>
  PRInt32 ordinal = 1;

  nsGenericHTMLElement *hc = nsGenericHTMLElement::FromContent(mContent);

  if (hc) {
    const nsAttrValue* attr = hc-&gt;GetParsedAttr(nsGkAtoms::start);
    if (attr &amp;&amp; attr-&gt;Type() == nsAttrValue::eInteger) {
      ordinal = attr-&gt;GetIntegerValue();
    }
  }

  <comment type="line">// Get to first-in-flow</comment>
  nsBlockFrame* block = (nsBlockFrame*) GetFirstInFlow();
  return RenumberListsInBlock(aPresContext, block, &amp;ordinal, 0);
}

PRBool
nsBlockFrame::RenumberListsInBlock(nsPresContext* aPresContext,
                                   nsBlockFrame* aBlockFrame,
                                   PRInt32* aOrdinal,
                                   PRInt32 aDepth)
{
  PRBool renumberedABullet = PR_FALSE;

  while (nsnull != aBlockFrame) {
    <comment type="line">// Examine each line in the block</comment>
    for (line_iterator line = aBlockFrame-&gt;begin_lines(),
                       line_end = aBlockFrame-&gt;end_lines();
         line != line_end;
         ++line) {
      nsIFrame* kid = line-&gt;mFirstChild;
      PRInt32 n = line-&gt;GetChildCount();
      while (--n &gt;= 0) {
        PRBool kidRenumberedABullet = RenumberListsFor(aPresContext, kid, aOrdinal, aDepth);
        if (kidRenumberedABullet) {
          line-&gt;MarkDirty();
          renumberedABullet = PR_TRUE;
        }
        kid = kid-&gt;GetNextSibling();
      }
    }

    <comment type="line">// Advance to the next continuation</comment>
    aBlockFrame = static_cast&lt;nsBlockFrame*&gt;(aBlockFrame-&gt;GetNextInFlow());
  }

  return renumberedABullet;
}

PRBool
nsBlockFrame::RenumberListsFor(nsPresContext* aPresContext,
                               nsIFrame* aKid,
                               PRInt32* aOrdinal,
                               PRInt32 aDepth)
{
  NS_PRECONDITION(aPresContext &amp;&amp; aKid &amp;&amp; aOrdinal, "null params are immoral!");

  <comment type="line">// add in a sanity check for absurdly deep frame trees.  See bug 42138</comment>
  if (MAX_DEPTH_FOR_LIST_RENUMBERING &lt; aDepth)
    return PR_FALSE;

  PRBool kidRenumberedABullet = PR_FALSE;

  <comment type="line">// if the frame is a placeholder, then get the out of flow frame</comment>
  nsIFrame* kid = nsPlaceholderFrame::GetRealFrameFor(aKid);

  <comment type="line">// drill down through any wrappers to the real frame</comment>
  kid = kid-&gt;GetContentInsertionFrame();

  <comment type="line">// If the frame is a list-item and the frame implements our</comment>
  <comment type="line">// block frame API then get its bullet and set the list item</comment>
  <comment type="line">// ordinal.</comment>
  const nsStyleDisplay* display = kid-&gt;GetStyleDisplay();
  if (NS_STYLE_DISPLAY_LIST_ITEM == display-&gt;mDisplay) {
    <comment type="line">// Make certain that the frame is a block frame in case</comment>
    <comment type="line">// something foreign has crept in.</comment>
    nsBlockFrame* listItem;
    nsresult rv = kid-&gt;QueryInterface(kBlockFrameCID, (void**)&amp;listItem);
    if (NS_SUCCEEDED(rv)) {
      if (nsnull != listItem-&gt;mBullet) {
        PRBool changed;
        *aOrdinal = listItem-&gt;mBullet-&gt;SetListItemOrdinal(*aOrdinal,
                                                          &amp;changed);
        if (changed) {
          kidRenumberedABullet = PR_TRUE;

          <comment type="line">// Invalidate the bullet content area since it may look different now</comment>
          nsRect damageRect(nsPoint(0, 0), listItem-&gt;mBullet-&gt;GetSize());
          listItem-&gt;mBullet-&gt;Invalidate(damageRect);
        }
      }

      <comment type="line">// XXX temporary? if the list-item has child list-items they</comment>
      <comment type="line">// should be numbered too; especially since the list-item is</comment>
      <comment type="line">// itself (ASSUMED!) not to be a counter-resetter.</comment>
      PRBool meToo = RenumberListsInBlock(aPresContext, listItem, aOrdinal, aDepth + 1);
      if (meToo) {
        kidRenumberedABullet = PR_TRUE;
      }
    }
  }
  else if (NS_STYLE_DISPLAY_BLOCK == display-&gt;mDisplay) {
    if (FrameStartsCounterScope(kid)) {
      <comment type="line">// Don't bother recursing into a block frame that is a new</comment>
      <comment type="line">// counter scope. Any list-items in there will be handled by</comment>
      <comment type="line">// it.</comment>
    }
    else {
      <comment type="line">// If the display=block element is a block frame then go ahead</comment>
      <comment type="line">// and recurse into it, as it might have child list-items.</comment>
      nsBlockFrame* kidBlock;
      nsresult rv = kid-&gt;QueryInterface(kBlockFrameCID, (void**) &amp;kidBlock);
      if (NS_SUCCEEDED(rv)) {
        kidRenumberedABullet = RenumberListsInBlock(aPresContext, kidBlock, aOrdinal, aDepth + 1);
      }
    }
  }
  return kidRenumberedABullet;
}

void
nsBlockFrame::ReflowBullet(nsBlockReflowState&amp; aState,
                           nsHTMLReflowMetrics&amp; aMetrics)
{
  const nsHTMLReflowState &amp;rs = aState.mReflowState;

  <comment type="line">// Reflow the bullet now</comment>
  nsSize availSize;
  <comment type="line">// Make up a width since it doesn't really matter (XXX).</comment>
  availSize.width = rs.ComputedWidth();
  availSize.height = NS_UNCONSTRAINEDSIZE;

  <comment type="line">// Get the reason right.</comment>
  <comment type="line">// XXXwaterson Should this look just like the logic in</comment>
  <comment type="line">// nsBlockReflowContext::ReflowBlock and nsLineLayout::ReflowFrame?</comment>
  nsHTMLReflowState reflowState(aState.mPresContext, rs,
                                mBullet, availSize);
  nsReflowStatus  status;
  mBullet-&gt;WillReflow(aState.mPresContext);
  mBullet-&gt;Reflow(aState.mPresContext, aMetrics, reflowState, status);

  <comment type="line">// Place the bullet now; use its right margin to distance it</comment>
  <comment type="line">// from the rest of the frames in the line</comment>
  nscoord x = 
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
           (NS_STYLE_DIRECTION_RTL == GetStyleVisibility()-&gt;mDirection)
             <comment type="line">// According to the CSS2 spec, section 12.6.1, outside marker box</comment>
             <comment type="line">// is distanced from the associated principal box's border edge.</comment>
             <comment type="line">// |rs.availableWidth| reflects exactly a border edge: it includes</comment>
             <comment type="line">// border, padding, and content area, without margins.</comment>
             ? rs.ComputedWidth() + rs.mComputedBorderPadding.LeftRight() +
               reflowState.mComputedMargin.left :
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
             - reflowState.mComputedMargin.right - aMetrics.width;

  <comment type="line">// Approximate the bullets position; vertical alignment will provide</comment>
  <comment type="line">// the final vertical location.</comment>
  const nsMargin&amp; bp = aState.BorderPadding();
  nscoord y = bp.top;
  mBullet-&gt;SetRect(nsRect(x, y, aMetrics.width, aMetrics.height));
  mBullet-&gt;DidReflow(aState.mPresContext, &amp;aState.mReflowState, NS_FRAME_REFLOW_FINISHED);
}

<comment type="line">// This is used to scan frames for any float placeholders, add their</comment>
<comment type="line">// floats to the list represented by aList and aTail, and remove the</comment>
<comment type="line">// floats from whatever list they might be in. We don't search descendants</comment>
<comment type="line">// that are float containing blocks. The floats must be children of 'this'.</comment>
void nsBlockFrame::CollectFloats(nsIFrame* aFrame, nsFrameList&amp; aList, nsIFrame** aTail,
                                 PRBool aFromOverflow, PRBool aCollectSiblings) {
  while (aFrame) {
    <comment type="line">// Don't descend into float containing blocks.</comment>
    if (!aFrame-&gt;IsFloatContainingBlock()) {
      nsIFrame *outOfFlowFrame = nsLayoutUtils::GetFloatFromPlaceholder(aFrame);
      if (outOfFlowFrame) {
        <comment type="line">// Make sure that its parent is us. Otherwise we don't want</comment>
        <comment type="line">// to mess around with it because it belongs to someone</comment>
        <comment type="line">// else. I think this could happen if the overflow lines</comment>
        <comment type="line">// contain a block descendant which owns its own floats.</comment>
        NS_ASSERTION(outOfFlowFrame-&gt;GetParent() == this,
                     "Out of flow frame doesn't have the expected parent");
        if (aFromOverflow) {
          nsAutoOOFFrameList oofs(this);
          oofs.mList.RemoveFrame(outOfFlowFrame);
        } else {
          mFloats.RemoveFrame(outOfFlowFrame);
        }
        aList.InsertFrame(nsnull, *aTail, outOfFlowFrame);
        *aTail = outOfFlowFrame;
      }

      CollectFloats(aFrame-&gt;GetFirstChild(nsnull), 
                    aList, aTail, aFromOverflow, PR_TRUE);
      <comment type="line">// Note: Even though we're calling CollectFloats on aFrame's overflow</comment>
      <comment type="line">// list, we'll pass down aFromOverflow unchanged because we're still</comment>
      <comment type="line">// traversing the regular-children subtree of the 'this' frame.</comment>
      CollectFloats(aFrame-&gt;GetFirstChild(nsGkAtoms::overflowList), 
                    aList, aTail, aFromOverflow, PR_TRUE);
    }
    if (!aCollectSiblings)
      break;
    aFrame = aFrame-&gt;GetNextSibling();
  }
}

void
nsBlockFrame::CheckFloats(nsBlockReflowState&amp; aState)
{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <comment type="line">// If any line is still dirty, that must mean we're going to reflow this</comment>
  <comment type="line">// block again soon (e.g. because we bailed out after noticing that</comment>
  <comment type="line">// clearance was imposed), so don't worry if the floats are out of sync.</comment>
  PRBool anyLineDirty = PR_FALSE;

  <comment type="line">// Check that the float list is what we would have built</comment>
  nsAutoVoidArray lineFloats;
  for (line_iterator line = begin_lines(), line_end = end_lines();
       line != line_end; ++line) {
    if (line-&gt;HasFloats()) {
      nsFloatCache* fc = line-&gt;GetFirstFloat();
      while (fc) {
        nsIFrame* floatFrame = fc-&gt;mPlaceholder-&gt;GetOutOfFlowFrame();
        lineFloats.AppendElement(floatFrame);
        fc = fc-&gt;Next();
      }
    }
    if (line-&gt;IsDirty()) {
      anyLineDirty = PR_TRUE;
    }
  }
  
  nsAutoVoidArray storedFloats;
  PRBool equal = PR_TRUE;
  PRInt32 i = 0;
  for (nsIFrame* f = mFloats.FirstChild(); f; f = f-&gt;GetNextSibling()) {
    storedFloats.AppendElement(f);
    if (i &lt; lineFloats.Count() &amp;&amp; lineFloats.ElementAt(i) != f) {
      equal = PR_FALSE;
    }
    ++i;
  }

  if ((!equal || lineFloats.Count() != storedFloats.Count()) &amp;&amp; !anyLineDirty) {
    NS_WARNING("nsBlockFrame::CheckFloats: Explicit float list is out of sync with float cache");
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_roc</name></expr></argument>)</argument_list></call></expr></cpp:if>
    nsIFrameDebug::RootFrameList(PresContext(), stdout, 0);
    for (i = 0; i &lt; lineFloats.Count(); ++i) {
      printf("Line float: %p\n", lineFloats.ElementAt(i));
    }
    for (i = 0; i &lt; storedFloats.Count(); ++i) {
      printf("Stored float: %p\n", storedFloats.ElementAt(i));
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  nsFrameList oofs = GetOverflowOutOfFlows();
  if (oofs.NotEmpty()) {
    <comment type="line">// Floats that were pushed should be removed from our space</comment>
    <comment type="line">// manager.  Otherwise the space manager's YMost or XMost might</comment>
    <comment type="line">// be larger than necessary, causing this block to get an</comment>
    <comment type="line">// incorrect desired height (or width).  Some of these floats</comment>
    <comment type="line">// may not actually have been added to the space manager because</comment>
    <comment type="line">// they weren't reflowed before being pushed; that's OK,</comment>
    <comment type="line">// RemoveRegions will ignore them. It is safe to do this here</comment>
    <comment type="line">// because we know from here on the space manager will only be</comment>
    <comment type="line">// used for its XMost and YMost, not to place new floats and</comment>
    <comment type="line">// lines.</comment>
    aState.mSpaceManager-&gt;RemoveTrailingRegions(oofs.FirstChild());
  }
}

<comment type="block">/* static */</comment>
PRBool
nsBlockFrame::BlockIsMarginRoot(nsIFrame* aBlock)
{
  NS_PRECONDITION(aBlock, "Must have a frame");
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  nsBlockFrame* blockFrame;
  aBlock-&gt;QueryInterface(kBlockFrameCID, (void**)&amp;blockFrame);
  NS_ASSERTION(blockFrame, "aBlock must be a block");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  nsIFrame* parent = aBlock-&gt;GetParent();
  return (aBlock-&gt;GetStateBits() &amp; NS_BLOCK_MARGIN_ROOT) ||
    (parent &amp;&amp; !parent-&gt;IsFloatContainingBlock() &amp;&amp;
     parent-&gt;GetType() != nsGkAtoms::columnSetFrame);
}

<comment type="block">/* static */</comment>
PRBool
nsBlockFrame::BlockNeedsSpaceManager(nsIFrame* aBlock)
{
  NS_PRECONDITION(aBlock, "Must have a frame");
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  nsBlockFrame* blockFrame;
  aBlock-&gt;QueryInterface(kBlockFrameCID, (void**)&amp;blockFrame);
  NS_ASSERTION(blockFrame, "aBlock must be a block");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  nsIFrame* parent = aBlock-&gt;GetParent();
  return (aBlock-&gt;GetStateBits() &amp; NS_BLOCK_SPACE_MGR) ||
    (parent &amp;&amp; !parent-&gt;IsFloatContainingBlock());
}
 
<comment type="block">/* static */</comment>
nsBlockFrame*
nsBlockFrame::GetNearestAncestorBlock(nsIFrame* aCandidate)
{
  nsBlockFrame* block = nsnull;
  while(aCandidate) {
    aCandidate-&gt;QueryInterface(kBlockFrameCID, (void**)&amp;block);
    if (block) { 
      <comment type="line">// yay, candidate is a block!</comment>
      return block;
    }
    <comment type="line">// Not a block. Check its parent next.</comment>
    aCandidate = aCandidate-&gt;GetParent();
  }
  NS_NOTREACHED("Fell off frame tree looking for ancestor block!");
  return nsnull;
}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IBMBIDI</name></cpp:ifdef>
nsresult
nsBlockFrame::ResolveBidi()
{
  NS_ASSERTION(!GetPrevInFlow(),
               "ResolveBidi called on non-first continuation");

  nsPresContext* presContext = PresContext();
  if (!presContext-&gt;BidiEnabled()) {
    return NS_OK;
  }

  nsBidiPresUtils* bidiUtils = presContext-&gt;GetBidiUtils();
  if (!bidiUtils)
    return NS_ERROR_NULL_POINTER;

  for (nsBlockFrame* curFrame = this; curFrame;
       curFrame = static_cast&lt;nsBlockFrame*&gt;(curFrame-&gt;GetNextContinuation())) {
    curFrame-&gt;RemoveStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);
    if (!curFrame-&gt;mLines.empty()) {
      nsresult rv = bidiUtils-&gt;Resolve(curFrame,
                                       curFrame-&gt;mLines.front()-&gt;mFirstChild,
                                       IsVisualFormControl(presContext));
      if (NS_FAILED(rv))
        return rv;
    }
  }

  return NS_OK;
}

PRBool
nsBlockFrame::IsVisualFormControl(nsPresContext* aPresContext)
{
  <comment type="line">// This check is only necessary on visual bidi pages, because most</comment>
  <comment type="line">// visual pages use logical order for form controls so that they will</comment>
  <comment type="line">// display correctly on native widgets in OSs with Bidi support.</comment>
  <comment type="line">// So bail out if the page is not visual, or if the pref is</comment>
  <comment type="line">// set to use visual order on forms in visual pages</comment>
  if (!aPresContext-&gt;IsVisualMode()) {
    return PR_FALSE;
  }

  PRUint32 options = aPresContext-&gt;GetBidi();
  if (IBMBIDI_CONTROLSTEXTMODE_LOGICAL != GET_BIDI_OPTION_CONTROLSTEXTMODE(options)) {
    return PR_FALSE;
  }

  nsIContent* content = GetContent();
  for ( ; content; content = content-&gt;GetParent()) {
    if (content-&gt;IsNodeOfType(nsINode::eHTML_FORM_CONTROL)) {
      return PR_TRUE;
    }
  }
  
  return PR_FALSE;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
void
nsBlockFrame::VerifyLines(PRBool aFinalCheckOK)
{
  if (!gVerifyLines) {
    return;
  }
  if (mLines.empty()) {
    return;
  }

  <comment type="line">// Add up the counts on each line. Also validate that IsFirstLine is</comment>
  <comment type="line">// set properly.</comment>
  PRInt32 count = 0;
  PRBool seenBlock = PR_FALSE;
  line_iterator line</argument>, <argument>line_end;
  for (line = begin_lines(), line_end = end_lines();
       line != line_end;
       ++line) {
    if (aFinalCheckOK) {
      NS_ABORT_IF_FALSE(line-&gt;GetChildCount(), "empty line");
      if (line-&gt;IsBlock()) {
        seenBlock = PR_TRUE;
      }
      if (line-&gt;IsBlock()) {
        NS_ASSERTION(1 == line-&gt;GetChildCount(), "bad first line");
      }
    }
    count += line-&gt;GetChildCount();
  }

  <comment type="line">// Then count the frames</comment>
  PRInt32 frameCount = 0;
  nsIFrame* frame = mLines.front()-&gt;mFirstChild;
  while (frame) {
    frameCount++;
    frame = frame-&gt;GetNextSibling();
  }
  NS_ASSERTION(count == frameCount, "bad line list");

  <comment type="line">// Next: test that each line has right number of frames on it</comment>
  for (line = begin_lines(), line_end = end_lines();
       line != line_end;
        ) {
    count = line-&gt;GetChildCount();
    frame = line-&gt;mFirstChild;
    while (--count &gt;= 0) {
      frame = frame-&gt;GetNextSibling();
    }
    ++line;
    if ((line != line_end) &amp;&amp; (0 != line-&gt;GetChildCount())) {
      NS_ASSERTION(frame == line-&gt;mFirstChild, "bad line list");
    }
  }
}

<comment type="line">// Its possible that a frame can have some frames on an overflow</comment>
<comment type="line">// list. But its never possible for multiple frames to have overflow</comment>
<comment type="line">// lists. Check that this fact is actually true.</comment>
void
nsBlockFrame::VerifyOverflowSituation()
{
  nsBlockFrame* flow = (nsBlockFrame*) GetFirstInFlow();
  while (nsnull != flow) {
    nsLineList* overflowLines = GetOverflowLines();
    if (nsnull != overflowLines) {
      NS_ASSERTION(! overflowLines-&gt;empty(), "should not be empty if present");
      NS_ASSERTION(overflowLines-&gt;front()-&gt;mFirstChild, "bad overflow list");
    }
    flow = (nsBlockFrame*) flow-&gt;GetNextInFlow();
  }
}

PRInt32
nsBlockFrame::GetDepth() const
{
  PRInt32 depth = 0;
  nsIFrame* parent = mParent;
  while (parent) {
    parent = parent-&gt;GetParent();
    depth++;
  }
  return depth;
}</argument></argument_list></macro></then></if></block></else></if></block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
