<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0076aa766b5d76ddff38c857c7c0fec4834c6e9c.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=4 sw=4 et tw=99:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
 * May 28, 2008.
 *
 * The Initial Developer of the Original Code is
 *   Brendan Eich &lt;brendan@mozilla.org&gt;
 *
 * Contributor(s):
 *   Andreas Gal &lt;gal@mozilla.com&gt;
 *   Mike Shaver &lt;shaver@mozilla.org&gt;
 *   David Anderson &lt;danderson@mozilla.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstdint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbit.h"</cpp:file></cpp:include>              <comment type="line">// low-level (NSPR-based) headers next</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>               <comment type="line">// standard headers next</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>alloca</name></cpp:macro> <cpp:value>_alloca</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SOLARIS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nanojit/nanojit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>              <comment type="line">// higher-level library and API headers</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdbgapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsemit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsfun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsiter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsmath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsregexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscript.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstaticcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstracer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsxml.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypedarray.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatominlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspropertycacheinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobjinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscopeinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscriptinlines.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsautooplen.h"</cpp:file></cpp:include>        <comment type="line">// generated headers last</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"imacros.c.out"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NANOJIT_ARM</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>AVMPLUS_LINUX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;elf.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<namespace>namespace <name>nanojit</name> <block>{
<using>using namespace <name>js</name>;</using>

<comment type="block">/* Implement embedder-specific nanojit members. */</comment>

<function><type><name>void</name>*</type>
<name><name>nanojit</name>::<name>Allocator</name>::<name>allocChunk</name></name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>VMAllocator</name> *</type><name>vma</name> <init>= <expr>(<name>VMAllocator</name>*)<name>this</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>vma</name>-&gt;<name>outOfMemory</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>nbytes</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name><name>vma</name>-&gt;<name>mReserve</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vma</name>-&gt;<name>mOutOfMemory</name></name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> = (<name>void</name>*) &amp;<name><name>vma</name>-&gt;<name>mReserve</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>vma</name>-&gt;<name>mSize</name></name> += <name>nbytes</name></expr>;</expr_stmt>
    <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>nanojit</name>::<name>Allocator</name>::<name>freeChunk</name></name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>VMAllocator</name> *</type><name>vma</name> <init>= <expr>(<name>VMAllocator</name>*)<name>this</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>p</name> != &amp;<name><name>vma</name>-&gt;<name>mReserve</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>nanojit</name>::<name>Allocator</name>::<name>postReset</name></name><parameter_list>()</parameter_list> <block>{
    <decl_stmt><decl><type><name>VMAllocator</name> *</type><name>vma</name> <init>= <expr>(<name>VMAllocator</name>*)<name>this</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>vma</name>-&gt;<name>mOutOfMemory</name></name> = false</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vma</name>-&gt;<name>mSize</name></name> = 0</expr>;</expr_stmt>
}</block></function>

<function><type><name>int</name></type>
<name><name>StackFilter</name>::<name>getTop</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>guard</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>e</name> <init>= <expr>(<name>VMSideExit</name>*)<call><name><name>guard</name>-&gt;<name>record</name></name><argument_list>()</argument_list></call>-&gt;<name>exit</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>e</name>-&gt;<name>sp_adj</name></name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NJ_VERBOSE</name></expr></cpp:if>
<function><type><name>void</name></type>
<name><name>LInsPrinter</name>::<name>formatGuard</name></name><parameter_list>(<param><decl><type><name>InsBuf</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>RefBuf</name></type> <name>b1</name></decl>, <decl><type ref="prev"/><name>b2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMSideExit</name> *</type><name>x</name> <init>= <expr>(<name>VMSideExit</name> *)<call><name><name>ins</name>-&gt;<name>record</name></name><argument_list>()</argument_list></call>-&gt;<name>exit</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VMPI_snprintf</name><argument_list>(<argument><expr><name><name>buf</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name><name>buf</name>-&gt;<name>len</name></name></expr></argument>,
            <argument><expr>"%s: %s %s -&gt; pc=%p imacpc=%p sp%+ld rp%+ld (GuardID=%03d)"</expr></argument>,
            <argument><expr><call><name>formatRef</name><argument_list>(<argument><expr>&amp;<name>b1</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name><name>lirNames</name><index>[<expr><call><name><name>ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>,
            <argument><expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call> ? <call><name>formatRef</name><argument_list>(<argument><expr>&amp;<name>b2</name></expr></argument>, <argument><expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> : ""</expr></argument>,
            <argument><expr>(<name>void</name> *)<name><name>x</name>-&gt;<name>pc</name></name></expr></argument>,
            <argument><expr>(<name>void</name> *)<name><name>x</name>-&gt;<name>imacpc</name></name></expr></argument>,
            <argument><expr>(<name>long</name> <name>int</name>)<name><name>x</name>-&gt;<name>sp_adj</name></name></expr></argument>,
            <argument><expr>(<name>long</name> <name>int</name>)<name><name>x</name>-&gt;<name>rp_adj</name></name></expr></argument>,
            <argument><expr><call><name><name>ins</name>-&gt;<name>record</name></name><argument_list>()</argument_list></call>-&gt;<name>profGuardID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>LInsPrinter</name>::<name>formatGuardXov</name></name><parameter_list>(<param><decl><type><name>InsBuf</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>RefBuf</name></type> <name>b1</name></decl>, <decl><type ref="prev"/><name>b2</name></decl>, <decl><type ref="prev"/><name>b3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMSideExit</name> *</type><name>x</name> <init>= <expr>(<name>VMSideExit</name> *)<call><name><name>ins</name>-&gt;<name>record</name></name><argument_list>()</argument_list></call>-&gt;<name>exit</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VMPI_snprintf</name><argument_list>(<argument><expr><name><name>buf</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name><name>buf</name>-&gt;<name>len</name></name></expr></argument>,
            <argument><expr>"%s = %s %s, %s -&gt; pc=%p imacpc=%p sp%+ld rp%+ld (GuardID=%03d)"</expr></argument>,
            <argument><expr><call><name>formatRef</name><argument_list>(<argument><expr>&amp;<name>b1</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name><name>lirNames</name><index>[<expr><call><name><name>ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>,
            <argument><expr><call><name>formatRef</name><argument_list>(<argument><expr>&amp;<name>b2</name></expr></argument>, <argument><expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>formatRef</name><argument_list>(<argument><expr>&amp;<name>b3</name></expr></argument>, <argument><expr><call><name><name>ins</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr>(<name>void</name> *)<name><name>x</name>-&gt;<name>pc</name></name></expr></argument>,
            <argument><expr>(<name>void</name> *)<name><name>x</name>-&gt;<name>imacpc</name></name></expr></argument>,
            <argument><expr>(<name>long</name> <name>int</name>)<name><name>x</name>-&gt;<name>sp_adj</name></name></expr></argument>,
            <argument><expr>(<name>long</name> <name>int</name>)<name><name>x</name>-&gt;<name>rp_adj</name></name></expr></argument>,
            <argument><expr><call><name><name>ins</name>-&gt;<name>record</name></name><argument_list>()</argument_list></call>-&gt;<name>profGuardID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></namespace> <comment type="block">/* namespace nanojit */</comment>

<namespace>namespace <name>js</name> <block>{

<using>using namespace <name>nanojit</name>;</using>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_VALUE_IF_XML</name><parameter_list>(<param><type><name>val</name></type></param>, <param><type><name>ret</name></type></param>)</parameter_list></cpp:macro>                                         \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        if (!JSVAL_IS_PRIMITIVE(val) &amp;&amp; JSVAL_TO_OBJECT(val)-&gt;isXML())        \
            RETURN_VALUE("xml detected", ret);                                \
    JS_END_MACRO</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_IF_XML</name><parameter_list>(<param><type><name>val</name></type></param>, <param><type><name>ret</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_IF_XML_A</name><parameter_list>(<param><type><name>val</name></type></param>)</parameter_list></cpp:macro> <cpp:value>RETURN_VALUE_IF_XML(val, ARECORD_STOP)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_IF_XML</name><parameter_list>(<param><type><name>val</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>RETURN_VALUE_IF_XML(val, RECORD_STOP)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>TraceNativeStorage</name></expr></argument>, <argument><expr><name>stack_global_buf</name></expr></argument>)</argument_list></call> % 16 == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Map to translate a type tag into a printable representation. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>typeChar</name><index>[]</index></name> <init>= <expr>"OIDXSNBF"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>tagChar</name><index>[]</index></name>  <init>= <expr>"OIDISIBI"</expr></init></decl>;</decl_stmt>

<comment type="block">/* Blacklist parameters. */</comment>

<comment type="block">/*
 * Number of iterations of a loop where we start tracing.  That is, we don't
 * start tracing until the beginning of the HOTLOOP-th iteration.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOTLOOP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* Attempt recording this many times before blacklisting permanently. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BL_ATTEMPTS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* Skip this many hits before attempting recording again, after an aborted attempt. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BL_BACKOFF</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<comment type="block">/* Number of times we wait to exit on a side exit before we try to extend the tree. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOTEXIT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* Number of times we try to extend the tree along a side exit. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXEXIT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Maximum number of peer trees allowed. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPEERS</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>

<comment type="block">/* Max number of hits to a RECURSIVE_UNLINKED exit before we trash the tree. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_RECURSIVE_UNLINK_HITS</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<comment type="block">/* Max call depths for inlining. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CALLDEPTH</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/* Max number of slots in a table-switch. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TABLE_SWITCH</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/* Max memory needed to rebuild the interpreter stack when falling off trace. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_INTERP_STACK_BYTES</name></cpp:macro>                                                \
    <cpp:value>(MAX_NATIVE_STACK_SLOTS * sizeof(jsval) +                                 \
     MAX_CALL_STACK_ENTRIES * sizeof(JSInlineFrame) +                         \
     sizeof(JSInlineFrame))</cpp:value></cpp:define> <comment type="block">/* possibly slow native frame at top of stack */</comment>

<comment type="block">/* Max number of branches per tree. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BRANCHES</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_STATUS</name><parameter_list>(<param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>                                                    \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        RecordingStatus _status = (expr);                                     \
        if (_status != RECORD_CONTINUE)                                       \
          return _status;                                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_STATUS_A</name><parameter_list>(<param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>                                                  \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        AbortableRecordingStatus _status = InjectStatus((expr));              \
        if (_status != ARECORD_CONTINUE)                                      \
          return _status;                                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_VALUE</name><parameter_list>(<param><type><name>msg</name></type></param>, <param><type><name>value</name></type></param>)</parameter_list></cpp:macro>                                              \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        debug_only_printf(LC_TMAbort, "trace stopped: %d: %s\n", __LINE__, (msg)); \
        return (value);                                                       \
    JS_END_MACRO</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_VALUE</name><parameter_list>(<param><type><name>msg</name></type></param>, <param><type><name>value</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>return (value)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_STOP</name><parameter_list>(<param><type><name>msg</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>RETURN_VALUE(msg, RECORD_STOP)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_STOP_A</name><parameter_list>(<param><type><name>msg</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>RETURN_VALUE(msg, ARECORD_STOP)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_ERROR</name><parameter_list>(<param><type><name>msg</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>RETURN_VALUE(msg, RECORD_ERROR)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_ERROR_A</name><parameter_list>(<param><type><name>msg</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>RETURN_VALUE(msg, ARECORD_ERROR)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
<struct>struct <name>__jitstats</name> <block>{<public type="default">
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JITSTAT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>uint64 x;</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jitstats.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JITSTAT</name></cpp:undef>
</public>}</block> <decl><name>jitstats</name> <init>= <expr><block>{ <expr>0LL</expr>, }</block></expr></init></decl>;</struct>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jitstats</name></expr></argument>)</argument_list></sizeof> % <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<enum>enum <name>jitstat_ids</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JITSTAT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>STAT ## x ## ID,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jitstats.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JITSTAT</name></cpp:undef>
    <decl><name>STAT_IDS_TOTAL</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSPropertySpec</name></type> <name><name>jitstats_props</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JITSTAT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ #x, STAT ## x ## ID, JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT },</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jitstats.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JITSTAT</name></cpp:undef>
    <expr><block>{ <expr>0</expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>jitstats_getProperty</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>jsid</name></type> <name>id</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSString</name>*</type> <name>str</name> <init>= <expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>JS_GetStringBytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"HOTLOOP"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>vp</name> = <call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><name>HOTLOOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>index</name> = <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>uint64</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>index</name></expr>)</condition> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JITSTAT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case STAT ## x ## ID: result = jitstats.x; break;</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jitstats.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JITSTAT</name></cpp:undef>
      <default>default:
        <expr_stmt><expr>*<name>vp</name> = <name>JSVAL_VOID</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    </default>}</block></switch>

    <if>if <condition>(<expr><name>result</name> &lt; <name>JSVAL_INT_MAX</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>vp</name> = <call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><call><name>jsint</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>char</name></type> <name><name>retstr</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr>sizeof <name>retstr</name></expr></argument>, <argument><expr>"%llu"</expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>vp</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><call><name>JS_NewStringCopyZ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>retstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>JSClass</name></type> <name>jitstats_class</name> <init>= <expr><block>{
    <expr>"jitstats"</expr>,
    <expr>0</expr>,
    <expr><name>JS_PropertyStub</name></expr>,       <expr><name>JS_PropertyStub</name></expr>,
    <expr><name>jitstats_getProperty</name></expr>,  <expr><name>JS_PropertyStub</name></expr>,
    <expr><name>JS_EnumerateStub</name></expr>,      <expr><name>JS_ResolveStub</name></expr>,
    <expr><name>JS_ConvertStub</name></expr>,        <expr><name>NULL</name></expr>,
    <expr><name>JSCLASS_NO_OPTIONAL_MEMBERS</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>InitJITStatsClass</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>glob</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_InitClass</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>glob</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>jitstats_class</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>jitstats_props</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUDIT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(jitstats.x++)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUDIT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_JIT_SPEW */</comment>

<comment type="block">/*
 * INS_CONSTPTR can be used to embed arbitrary pointers into the native code. It should not
 * be used directly to embed GC thing pointers. Instead, use the INS_CONSTOBJ/FUN/STR/SPROP
 * variants which ensure that the embedded pointer will be kept alive across GCs.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_CONST</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>          <cpp:value>addName(lir-&gt;insImm(c), #c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_CONSTPTR</name><parameter_list>(<param><type><name>p</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>addName(lir-&gt;insImmPtr(p), #p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_CONSTWORD</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>addName(lir-&gt;insImmPtr((void *) (v)), #v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_CONSTVAL</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>addName(insImmVal(v), #v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_CONSTOBJ</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>addName(insImmObj(obj), #obj)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_CONSTFUN</name><parameter_list>(<param><type><name>fun</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>addName(insImmFun(fun), #fun)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_CONSTSTR</name><parameter_list>(<param><type><name>str</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>addName(insImmStr(str), #str)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_CONSTSPROP</name><parameter_list>(<param><type><name>sprop</name></type></param>)</parameter_list></cpp:macro> <cpp:value>addName(insImmSprop(sprop), #sprop)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_ATOM</name><parameter_list>(<param><type><name>atom</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>INS_CONSTSTR(ATOM_TO_STRING(atom))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_NULL</name><parameter_list>()</parameter_list></cpp:macro>            <cpp:value>INS_CONSTPTR(NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INS_VOID</name><parameter_list>()</parameter_list></cpp:macro>            <cpp:value>INS_CONST(JSVAL_TO_SPECIAL(JSVAL_VOID))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>avmplus</name>::<name>AvmCore</name></name></type> <name>s_core</name> <init>= <expr><call><name><name>avmplus</name>::<name>AvmCore</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>avmplus</name>::<name>AvmCore</name></name>*</type> <name>core</name> <init>= <expr>&amp;<name>s_core</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>OutOfMemoryAbort</name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"out of memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>DumpPeerStability</name><parameter_list>(<param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>ip</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>globalShape</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * We really need a better way to configure the JIT. Shaver, where is
 * my fancy JIT object?
 *
 * NB: this is raced on, if jstracer.cpp should ever be running MT.
 * I think it's harmless tho.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>did_we_check_processor_features</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>

<comment type="block">/* ------ Debug logging control ------ */</comment>

<comment type="block">/*
 * All the logging control stuff lives in here.  It is shared between
 * all threads, but I think that's OK.
 */</comment>
<decl_stmt><decl><type><name>LogControl</name></type> <name>LogController</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>

<comment type="block">/*
 * NB: this is raced on too, if jstracer.cpp should ever be running MT.
 * Also harmless.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>did_we_set_up_debug_logging</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitJITLogController</name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>tm</name></decl>, *<decl><type ref="prev"/><name>tmf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>LogController</name>.<name>lcbits</name></name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name>tm</name> = <call><name>getenv</name><argument_list>(<argument><expr>"TRACEMONKEY"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tm</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(
            <argument><expr>"The environment variable $TRACEMONKEY has been replaced by $TMFLAGS.\n"
            "Try 'TMFLAGS=help js -j' for a list of options.\n"</expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>tmf</name> = <call><name>getenv</name><argument_list>(<argument><expr>"TMFLAGS"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>tmf</name></expr>)</condition><then> <return>return;</return></then></if>

    <comment type="block">/* Using strstr() is really a cheap hack as far as flag decoding goes. */</comment>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"help"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printf</name><argument_list>(
            <argument><expr>"usage: TMFLAGS=option,option,option,... where options can be:\n"
            "\n"
            "  help         show this message\n"
            "  ------ options for jstracer &amp; jsregexp ------\n"
            "  minimal      ultra-minimalist output; try this first\n"
            "  full         everything except 'treevis' and 'fragprofile'\n"
            "  tracer       tracer lifetime (FIXME:better description)\n"
            "  recorder     trace recording stuff (FIXME:better description)\n"
            "  abort        show trace recording aborts\n"
            "  stats        show trace recording stats\n"
            "  regexp       show compilation &amp; entry for regexps\n"
            "  treevis      spew that tracevis/tree.py can parse\n"
            "  ------ options for Nanojit ------\n"
            "  fragprofile  count entries and exits for each fragment\n"
            "  liveness     show LIR liveness at start of rdr pipeline\n"
            "  readlir      show LIR as it enters the reader pipeline\n"
            "  aftersf      show LIR after StackFilter\n"
            "  assembly     show final aggregated assembly code\n"
            "  regalloc     show regalloc state in 'assembly' output\n"
            "  activation   show activation state in 'assembly' output\n"
            "\n"</expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*NOTREACHED*/</comment>
    }</block></then></if>

    <expr_stmt><expr><name>bits</name> = 0</expr>;</expr_stmt>

    <comment type="block">/* flags for jstracer.cpp */</comment>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"minimal"</expr></argument>)</argument_list></call>  || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_TMMinimal</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"tracer"</expr></argument>)</argument_list></call>   || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_TMTracer</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"recorder"</expr></argument>)</argument_list></call> || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_TMRecorder</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"abort"</expr></argument>)</argument_list></call>    || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_TMAbort</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"stats"</expr></argument>)</argument_list></call>    || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_TMStats</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"regexp"</expr></argument>)</argument_list></call>   || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_TMRegexp</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"treevis"</expr></argument>)</argument_list></call></expr>)</condition><then>                         <expr_stmt><expr><name>bits</name> |= <name>LC_TMTreeVis</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* flags for nanojit */</comment>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"fragprofile"</expr></argument>)</argument_list></call></expr>)</condition><then>                       <expr_stmt><expr><name>bits</name> |= <name>LC_FragProfile</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"liveness"</expr></argument>)</argument_list></call>   || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_Liveness</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"activation"</expr></argument>)</argument_list></call> || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_Activation</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"readlir"</expr></argument>)</argument_list></call>    || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_ReadLIR</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"aftersf"</expr></argument>)</argument_list></call>    || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_AfterSF</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"regalloc"</expr></argument>)</argument_list></call>   || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_RegAlloc</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"assembly"</expr></argument>)</argument_list></call>   || <call><name>strstr</name><argument_list>(<argument><expr><name>tmf</name></expr></argument>, <argument><expr>"full"</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bits</name> |= <name>LC_Assembly</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name><name>LogController</name>.<name>lcbits</name></name> = <name>bits</name></expr>;</expr_stmt>
    <return>return;</return>

}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ------------------ Frag-level profiling support ------------------ */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>

<comment type="block">/*
 * All the allocations done by this profile data-collection and
 * display machinery, are done in TraceMonitor::profAlloc.  That is
 * emptied out at the end of js_FinishJIT.  It has a lifetime from
 * js_InitJIT to js_FinishJIT, which exactly matches the span
 * js_FragProfiling_init to js_FragProfiling_showResults.
 */</comment>
<template>template<parameter_list>&lt;<param><type><name>class</name></type> <name>T</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier>
<name><name>Seq</name><argument_list>&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>*</type> <name>reverseInPlace</name><parameter_list>(<param><decl><type><name><name>Seq</name><argument_list>&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>*</type> <name>seq</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>Seq</name><argument_list>&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>*</type> <name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Seq</name><argument_list>&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>*</type> <name>curr</name> <init>= <expr><name>seq</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>curr</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name><name>Seq</name><argument_list>&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>*</type> <name>next</name> <init>= <expr><name><name>curr</name>-&gt;<name>tail</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>curr</name>-&gt;<name>tail</name></name> = <name>prev</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev</name> = <name>curr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>curr</name> = <name>next</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>prev</name></expr>;</return>
}</block></function></template>

<comment type="line">// The number of top blocks to show in the profile</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_TOP_BLOCKS</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>

<comment type="line">// Contains profile info for a single guard</comment>
<struct>struct <name>GuardPI</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>guardID</name></decl>;</decl_stmt> <comment type="line">// identifying number</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name></decl>;</decl_stmt>   <comment type="line">// count.</comment>
</public>}</block>;</struct>

<struct>struct <name>FragPI</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name></decl>;</decl_stmt>          <comment type="line">// entry count for this Fragment</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nStaticExits</name></decl>;</decl_stmt>   <comment type="line">// statically: the number of exits</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nCodeBytes</name></decl>;</decl_stmt>       <comment type="line">// statically: the number of insn bytes in the main fragment</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nExitBytes</name></decl>;</decl_stmt>       <comment type="line">// statically: the number of insn bytes in the exit paths</comment>
    <decl_stmt><decl><type><name><name>Seq</name><argument_list>&lt;<argument><expr><name>GuardPI</name></expr></argument>&gt;</argument_list></name>*</type> <name>guards</name></decl>;</decl_stmt>    <comment type="line">// guards, each with its own count</comment>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>largestGuardID</name></decl>;</decl_stmt> <comment type="line">// that exists in .guards</comment>
</public>}</block>;</struct>

<function><type><name>void</name></type>
<name>FragProfiling_FragFinalizer</name><parameter_list>(<param><decl><type><name>Fragment</name>*</type> <name>f</name></decl></param>, <param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Recover profiling data from 'f', which is logically at the end</comment>
    <comment type="line">// of its useful lifetime.</comment>
    <if>if <condition>(<expr>!(<name><name>LogController</name>.<name>lcbits</name></name> &amp; <name>LC_FragProfile</name>)</expr>)</condition><then>
        <return>return;</return></then></if>

    <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Valid profFragIDs start at 1</comment>
    <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>profFragID</name></name> &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// Should be called exactly once per Fragment.  This will assert if</comment>
    <comment type="line">// you issue the same FragID to more than one Fragment.</comment>
    <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr>!<call><name><name>tm</name>-&gt;<name>profTab</name>-&gt;<name>containsKey</name></name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>profFragID</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>FragPI</name></type> <name>pi</name> <init>= <expr><block>{ <expr><name><name>f</name>-&gt;<name>profCount</name></name></expr>,
                  <expr><name><name>f</name>-&gt;<name>nStaticExits</name></name></expr>,
                  <expr><name><name>f</name>-&gt;<name>nCodeBytes</name></name></expr>,
                  <expr><name><name>f</name>-&gt;<name>nExitBytes</name></name></expr>,
                  <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

    <comment type="line">// Begin sanity check on the guards</comment>
    <decl_stmt><decl><type><name><name>SeqBuilder</name><argument_list>&lt;<argument><expr><name>GuardPI</name></expr></argument>&gt;</argument_list></name></type> <name>guardsBuilder</name><argument_list>(<argument><expr>*<name><name>tm</name>-&gt;<name>profAlloc</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GuardRecord</name>*</type> <name>gr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>nGs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>sumOfDynExits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <for>for (<init><expr><name>gr</name> = <name><name>f</name>-&gt;<name>guardsForFrag</name></name></expr>;</init> <condition><expr><name>gr</name></expr>;</condition> <incr><expr><name>gr</name> = <name><name>gr</name>-&gt;<name>nextInFrag</name></name></expr></incr>) <block>{
         <expr_stmt><expr><name>nGs</name>++</expr>;</expr_stmt>
         <comment type="line">// Also copy the data into our auxiliary structure.</comment>
         <comment type="line">// f-&gt;guardsForFrag is in reverse order, and so this</comment>
         <comment type="line">// copy preserves that ordering (-&gt;add adds at end).</comment>
         <comment type="line">// Valid profGuardIDs start at 1.</comment>
         <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name><name>gr</name>-&gt;<name>profGuardID</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>sumOfDynExits</name> += <name><name>gr</name>-&gt;<name>profCount</name></name></expr>;</expr_stmt>
         <decl_stmt><decl><type><name>GuardPI</name></type> <name>gpi</name> <init>= <expr><block>{ <expr><name><name>gr</name>-&gt;<name>profGuardID</name></name></expr>, <expr><name><name>gr</name>-&gt;<name>profCount</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
         <expr_stmt><expr><call><name><name>guardsBuilder</name>.<name>add</name></name><argument_list>(<argument><expr><name>gpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if>if <condition>(<expr><name><name>gr</name>-&gt;<name>profGuardID</name></name> &gt; <name><name>pi</name>.<name>largestGuardID</name></name></expr>)</condition><then>
             <expr_stmt><expr><name><name>pi</name>.<name>largestGuardID</name></name> = <name><name>gr</name>-&gt;<name>profGuardID</name></name></expr>;</expr_stmt></then></if>
    }</block></for>
    <expr_stmt><expr><name><name>pi</name>.<name>guards</name></name> = <call><name><name>guardsBuilder</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// And put the guard list in forwards order</comment>
    <expr_stmt><expr><name><name>pi</name>.<name>guards</name></name> = <call><name>reverseInPlace</name><argument_list>(<argument><expr><name><name>pi</name>.<name>guards</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Why is this so?  Because nGs is the number of guards</comment>
    <comment type="line">// at the time the LIR was generated, whereas f-&gt;nStaticExits</comment>
    <comment type="line">// is the number of them observed by the time it makes it</comment>
    <comment type="line">// through to the assembler.  It can be the case that LIR</comment>
    <comment type="line">// optimisation removes redundant guards; hence we expect</comment>
    <comment type="line">// nGs to always be the same or higher.</comment>
    <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>nGs</name> &gt;= <name><name>f</name>-&gt;<name>nStaticExits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Also we can assert that the sum of the exit counts</comment>
    <comment type="line">// can't exceed the entry count.  It'd be nice to assert that</comment>
    <comment type="line">// they are exactly equal, but we can't because we don't know</comment>
    <comment type="line">// how many times we got to the end of the trace.</comment>
    <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>profCount</name></name> &gt;= <name>sumOfDynExits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// End sanity check on guards</comment>

    <expr_stmt><expr><call><name><name>tm</name>-&gt;<name>profTab</name>-&gt;<name>put</name></name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>profFragID</name></name></expr></argument>, <argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FragProfiling_showResults</name><parameter_list>(<param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>topFragID</name><index>[<expr><name>N_TOP_BLOCKS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FragPI</name></type>   <name><name>topPI</name><index>[<expr><name>N_TOP_BLOCKS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>totCount</name> <init>= <expr>0</expr></init>, <name>cumulCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>totSE</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>   <name>totCodeB</name> <init>= <expr>0</expr></init>, <name>totExitB</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PodArrayZero</name><argument_list>(<argument><expr><name>topFragID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PodArrayZero</name><argument_list>(<argument><expr><name>topPI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>FragStatsMap</name>::<name>Iter</name></name></type> <name>iter</name><argument_list>(<argument><expr>*<name><name>tm</name>-&gt;<name>profTab</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>fragID</name>  <init>= <expr><call><name><name>iter</name>.<name>key</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FragPI</name></type>   <name>pi</name>      <init>= <expr><call><name><name>iter</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name>   <init>= <expr><name><name>pi</name>.<name>count</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>totCount</name> += (<name>uint64_t</name>)<name>count</name></expr>;</expr_stmt>
        <comment type="block">/* Find the rank for this entry, in tops */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><name>N_TOP_BLOCKS</name>-1</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr>true</expr>)</condition> <block>{
            <if>if <condition>(<expr><name>r</name> == -1</expr>)</condition><then>
                <break>break;</break></then></if>
            <if>if <condition>(<expr><name><name>topFragID</name><index>[<expr><name>r</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>r</name>--</expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <if>if <condition>(<expr><name>count</name> &gt; <name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>count</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>r</name>--</expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <break>break;</break>
        }</block></while>
        <expr_stmt><expr><name>r</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>r</name> &gt;= 0 &amp;&amp; <name>r</name> &lt;= <name>N_TOP_BLOCKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* This entry should be placed at topPI[r], and entries
           at higher numbered slots moved up one. */</comment>
        <if>if <condition>(<expr><name>r</name> &lt; <name>N_TOP_BLOCKS</name></expr>)</condition><then> <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>s</name> <init>= <expr><name>N_TOP_BLOCKS</name>-1</expr></init></decl>;</init> <condition><expr><name>s</name> &gt; <name>r</name></expr>;</condition> <incr><expr><name>s</name>--</expr></incr>) <block>{
                <expr_stmt><expr><name><name>topFragID</name><index>[<expr><name>s</name></expr>]</index></name> = <name><name>topFragID</name><index>[<expr><name>s</name>-1</expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>topPI</name><index>[<expr><name>s</name></expr>]</index></name>     = <name><name>topPI</name><index>[<expr><name>s</name>-1</expr>]</index></name></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><name><name>topFragID</name><index>[<expr><name>r</name></expr>]</index></name> = <name>fragID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>     = <name>pi</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></while>

    <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(
        <argument><expr>"\n----------------- Per-fragment execution counts ------------------\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(
        <argument><expr>"\nTotal count = %llu\n\n"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name> <name>long</name> <name>int</name>)<name>totCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(
        <argument><expr>"           Entry counts         Entry counts       ----- Static -----\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(
        <argument><expr>"         ------Self------     ----Cumulative---   Exits  Cbytes Xbytes   FragID\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>totCount</name> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>totCount</name> = 1</expr>;</expr_stmt></then></if> <comment type="block">/* avoid division by zero */</comment>
    <expr_stmt><expr><name>cumulCount</name> = 0</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>r</name> = 0</expr>;</init> <condition><expr><name>r</name> &lt; <name>N_TOP_BLOCKS</name></expr>;</condition> <incr><expr><name>r</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>topFragID</name><index>[<expr><name>r</name></expr>]</index></name> == 0</expr>)</condition><then>
            <break>break;</break></then></if>
        <expr_stmt><expr><name>cumulCount</name> += (<name>uint64_t</name>)<name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>count</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(<argument><expr>"%3d:     %5.2f%% %9u     %6.2f%% %9llu"
                             "     %3d   %5u  %5u   %06u\n"</expr></argument>,
                             <argument><expr><name>r</name></expr></argument>,
                             <argument><expr>(<name>double</name>)<name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>count</name> * 100.0 / (<name>double</name>)<name>totCount</name></expr></argument>,
                             <argument><expr><name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>count</name></expr></argument>,
                             <argument><expr>(<name>double</name>)<name>cumulCount</name> * 100.0 / (<name>double</name>)<name>totCount</name></expr></argument>,
                             <argument><expr>(<name>unsigned</name> <name>long</name> <name>long</name> <name>int</name>)<name>cumulCount</name></expr></argument>,
                             <argument><expr><name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>nStaticExits</name></expr></argument>,
                             <argument><expr>(<name>unsigned</name> <name>int</name>)<name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>nCodeBytes</name></expr></argument>,
                             <argument><expr>(<name>unsigned</name> <name>int</name>)<name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>nExitBytes</name></expr></argument>,
                             <argument><expr><name><name>topFragID</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totSE</name> += (<name>uint32_t</name>)<name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>nStaticExits</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>totCodeB</name> += <name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>nCodeBytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>totExitB</name> += <name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>nExitBytes</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(<argument><expr>"\nTotal displayed code bytes = %u, "
                            "exit bytes = %u\n"
                            "Total displayed static exits = %d\n\n"</expr></argument>,
                            <argument><expr>(<name>unsigned</name> <name>int</name>)<name>totCodeB</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>int</name>)<name>totExitB</name></expr></argument>, <argument><expr><name>totSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(<argument><expr>"Analysis by exit counts\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>r</name> = 0</expr>;</init> <condition><expr><name>r</name> &lt; <name>N_TOP_BLOCKS</name></expr>;</condition> <incr><expr><name>r</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>topFragID</name><index>[<expr><name>r</name></expr>]</index></name> == 0</expr>)</condition><then>
            <break>break;</break></then></if>
        <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(<argument><expr>"FragID=%06u, total count %u:\n"</expr></argument>, <argument><expr><name><name>topFragID</name><index>[<expr><name>r</name></expr>]</index></name></expr></argument>,
                                <argument><expr><name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>madeItToEnd</name> <init>= <expr><name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>count</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>totThisFrag</name> <init>= <expr><name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>count</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>totThisFrag</name> == 0</expr>)</condition><then>
            <expr_stmt><expr><name>totThisFrag</name> = 1</expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>GuardPI</name></type> <name>gpi</name></decl>;</decl_stmt>
        <comment type="line">// visit the guards, in forward order</comment>
        <for>for (<init><decl><type><name><name>Seq</name><argument_list>&lt;<argument><expr><name>GuardPI</name></expr></argument>&gt;</argument_list></name>*</type> <name>guards</name> <init>= <expr><name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>guards</name></expr></init></decl>;</init> <condition><expr><name>guards</name></expr>;</condition> <incr><expr><name>guards</name> = <name><name>guards</name>-&gt;<name>tail</name></name></expr></incr>) <block>{
            <expr_stmt><expr><name>gpi</name> = <name>(*<name>guards</name>).<name>head</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>gpi</name>.<name>count</name></name> == 0</expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <expr_stmt><expr><name>madeItToEnd</name> -= <name><name>gpi</name>.<name>count</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(<argument><expr>"   GuardID=%03u    %7u (%5.2f%%)\n"</expr></argument>,
                                    <argument><expr><name><name>gpi</name>.<name>guardID</name></name></expr></argument>, <argument><expr><name><name>gpi</name>.<name>count</name></name></expr></argument>,
                                    <argument><expr>100.0 * (<name>double</name>)<name><name>gpi</name>.<name>count</name></name> / (<name>double</name>)<name>totThisFrag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(<argument><expr>"   Looped (%03u)   %7u (%5.2f%%)\n"</expr></argument>,
                                <argument><expr><name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>largestGuardID</name>+1</expr></argument>,
                                <argument><expr><name>madeItToEnd</name></expr></argument>,
                                <argument><expr>100.0 * (<name>double</name>)<name>madeItToEnd</name> /  (<name>double</name>)<name>totThisFrag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>madeItToEnd</name> &lt;= <name><name>topPI</name><index>[<expr><name>r</name></expr>]</index></name>.<name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// else unsigned underflow</comment>
        <expr_stmt><expr><call><name><name>LogController</name>.<name>printf</name></name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><name><name>tm</name>-&gt;<name>profTab</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------------------------------------------------------------- */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name>*</type>
<name>getExitName</name><parameter_list>(<param><decl><type><name>ExitType</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name>*</type> <name><name>exitNames</name><index>[]</index></name> <init>=
    <expr><block>{
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAKE_EXIT_STRING</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>#x,</cpp:value></cpp:define>
    <macro><name>JS_TM_EXITCODES</name><argument_list>(<argument>MAKE_EXIT_STRING</argument>)</argument_list></macro>
    <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAKE_EXIT_STRING</name></cpp:undef>
    <expr><name>NULL</name></expr>
    }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> &lt; <name>TOTAL_EXIT_TYPES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>exitNames</name><index>[<expr><name>type</name></expr>]</index></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>PrintOnTrace</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>format</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>, <param><decl><type><name>double</name> *</type><name>argv</name></decl></param>)</parameter_list>
<block>{
    <union>union <block>{<public type="default">
        <struct>struct <block>{<public type="default">
            <decl_stmt><decl><type><name>uint32</name></type> <name>lo</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32</name></type> <name>hi</name></decl>;</decl_stmt>
        </public>}</block> <decl><name>i</name></decl>;</struct>
        <decl_stmt><decl><type><name>double</name></type>   <name>d</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>     *</type><name>cstr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>o</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSString</name> *</type><name>s</name></decl>;</decl_stmt>
    </public>}</block> <decl><name>u</name></decl>;</union>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ARG</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>JS_BEGIN_MACRO          \
        if (argi &gt;= argc) { \
        fprintf(out, "[too few args for format]"); \
        break;       \
} \
    u.d = argv[argi++]; \
    JS_END_MACRO</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>FILE</name> *</type><name>out</name> <init>= <expr><name>stderr</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>uint32</name></type> <name>argi</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><name>format</name></expr></init></decl>;</init> <condition><expr>*<name>p</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
        <if>if <condition>(<expr>*<name>p</name> != '%'</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>
        <decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr>*++<name>p</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>ch</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"[trailing %%]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{
        <case>case <expr>'a'</expr>:
            <expr_stmt><expr><call><name>GET_ARG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"[%u:%u 0x%x:0x%x %f]"</expr></argument>, <argument><expr><name><name>u</name>.<name>i</name>.<name>lo</name></name></expr></argument>, <argument><expr><name><name>u</name>.<name>i</name>.<name>hi</name></name></expr></argument>, <argument><expr><name><name>u</name>.<name>i</name>.<name>lo</name></name></expr></argument>, <argument><expr><name><name>u</name>.<name>i</name>.<name>hi</name></name></expr></argument>, <argument><expr><name><name>u</name>.<name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr>'d'</expr>:
            <expr_stmt><expr><call><name>GET_ARG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name><name>u</name>.<name>i</name>.<name>lo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr>'u'</expr>:
            <expr_stmt><expr><call><name>GET_ARG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"%u"</expr></argument>, <argument><expr><name><name>u</name>.<name>i</name>.<name>lo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr>'x'</expr>:
            <expr_stmt><expr><call><name>GET_ARG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"%x"</expr></argument>, <argument><expr><name><name>u</name>.<name>i</name>.<name>lo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr>'f'</expr>:
            <expr_stmt><expr><call><name>GET_ARG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"%f"</expr></argument>, <argument><expr><name><name>u</name>.<name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr>'o'</expr>:
            <expr_stmt><expr><call><name>GET_ARG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_DumpObject</name><argument_list>(<argument><expr><name><name>u</name>.<name>o</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr>'s'</expr>:
            <expr_stmt><expr><call><name>GET_ARG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <block>{
                <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name><name>u</name>.<name>s</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// protect against massive spew if u.s is a bad pointer.</comment>
                <if>if <condition>(<expr><name>length</name> &gt; 1 &lt;&lt; 16</expr>)</condition><then>
                    <expr_stmt><expr><name>length</name> = 1 &lt;&lt; 16</expr>;</expr_stmt></then></if>
                <decl_stmt><decl><type><name>jschar</name> *</type><name>chars</name> <init>= <expr><call><name><name>u</name>.<name>s</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                    <decl_stmt><decl><type><name>jschar</name></type> <name>co</name> <init>= <expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>co</name> &lt; 128</expr>)</condition><then>
                        <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>co</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                    <else>else <if>if <condition>(<expr><name>co</name> &lt; 256</expr>)</condition><then>
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"\\u%02x"</expr></argument>, <argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                    <else>else
                        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"\\u%04x"</expr></argument>, <argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
                }</block></for>
            }</block>
            <break>break;</break>
        </case><case>case <expr>'S'</expr>:
            <expr_stmt><expr><call><name>GET_ARG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name><name>u</name>.<name>cstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><default>default:
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"[invalid %%%c]"</expr></argument>, <argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
    }</block></for>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_ARG</name></cpp:undef>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<macro><name>JS_DEFINE_CALLINFO_3</name><argument_list>(<argument>extern</argument>, <argument>BOOL</argument>, <argument>PrintOnTrace</argument>, <argument>CHARPTR</argument>, <argument>UINT32</argument>, <argument>DOUBLEPTR</argument>, <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<comment type="line">// This version is not intended to be called directly: usually it is easier to</comment>
<comment type="line">// use one of the other overloads.</comment>
<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>tprint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>, <param><decl><type><name><name>nanojit</name>::<name>LIns</name></name> *</type><name><name>insa</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>data</name> <init>= <expr>(<name>char</name>*) <call><name><name>traceMonitor</name>-&gt;<name>traceAlloc</name>-&gt;<name>alloc</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>double</name> *</type><name>args</name> <init>= <expr>(<name>double</name>*) <call><name><name>traceMonitor</name>-&gt;<name>traceAlloc</name>-&gt;<name>alloc</name></name><argument_list>(<argument><expr><name>count</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>insa</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name><name>insa</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> * <name>i</name></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args_ins</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>, <macro><name>INS_CONSTPTR</name><argument_list>(<argument>data</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>PrintOnTrace_ci</name></expr></argument>, <argument><expr><name>args_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>call_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Generate a 'printf'-type call from trace for debugging.</comment>
<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>tprint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>insa</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tprint</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>insa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>tprint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>insa</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tprint</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>insa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>tprint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins1</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>insa</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>ins1</name></expr>, <expr><name>ins2</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tprint</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>insa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>tprint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins1</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins2</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins3</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>insa</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>ins1</name></expr>, <expr><name>ins2</name></expr>, <expr><name>ins3</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tprint</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><name>insa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>tprint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins1</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins2</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins3</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins4</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>insa</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>ins1</name></expr>, <expr><name>ins2</name></expr>, <expr><name>ins3</name></expr>, <expr><name>ins4</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tprint</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name>insa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>tprint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins1</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins2</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins3</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins4</name></decl></param>,
                      <param><decl><type><name>LIns</name> *</type><name>ins5</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>insa</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>ins1</name></expr>, <expr><name>ins2</name></expr>, <expr><name>ins3</name></expr>, <expr><name>ins4</name></expr>, <expr><name>ins5</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tprint</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><name>insa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>tprint</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins1</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins2</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins3</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins4</name></decl></param>,
                      <param><decl><type><name>LIns</name> *</type><name>ins5</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>ins6</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>insa</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>ins1</name></expr>, <expr><name>ins2</name></expr>, <expr><name>ins3</name></expr>, <expr><name>ins4</name></expr>, <expr><name>ins5</name></expr>, <expr><name>ins6</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tprint</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>6</expr></argument>, <argument><expr><name>insa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * The entire VM shares one oracle. Collisions and concurrent updates are
 * tolerated and worst case cause performance regressions.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oracle</name></type> <name>oracle</name></decl>;</decl_stmt>

<constructor><name><name>Tracker</name>::<name>Tracker</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>pagelist</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>Tracker</name>::~<name>Tracker</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><specifier>inline</specifier> <name>jsuword</name></type>
<name><name>Tracker</name>::<name>getTrackerPageBase</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>v</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <return>return <expr><call><name>jsuword</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp; ~<name>TRACKER_PAGE_MASK</name></expr>;</return>
}</block></function>

<function><type><specifier>inline</specifier> <name>jsuword</name></type>
<name><name>Tracker</name>::<name>getTrackerPageOffset</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>v</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <return>return <expr>(<call><name>jsuword</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp; <name>TRACKER_PAGE_MASK</name>) &gt;&gt; 2</expr>;</return>
}</block></function>

struct <function><type><name><name>Tracker</name>::<name>TrackerPage</name></name>*</type>
<name><name>Tracker</name>::<name>findTrackerPage</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>v</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <decl_stmt><decl><type><name>jsuword</name></type> <name>base</name> <init>= <expr><call><name>getTrackerPageBase</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    struct <decl_stmt><decl><type><name><name>Tracker</name>::<name>TrackerPage</name></name>*</type> <name>p</name> <init>= <expr><name>pagelist</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name><name>p</name>-&gt;<name>base</name></name> == <name>base</name></expr>)</condition><then>
            <return>return <expr><name>p</name></expr>;</return></then></if>
        <expr_stmt><expr><name>p</name> = <name><name>p</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

struct <function><type><name><name>Tracker</name>::<name>TrackerPage</name></name>*</type>
<name><name>Tracker</name>::<name>addTrackerPage</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsuword</name></type> <name>base</name> <init>= <expr><call><name>getTrackerPageBase</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>TrackerPage</name>*</type> <name>p</name> <init>= <expr>(struct <name>TrackerPage</name>*) <call><name>calloc</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name>-&gt;<name>base</name></name> = <name>base</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name>-&gt;<name>next</name></name> = <name>pagelist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pagelist</name> = <name>p</name></expr>;</expr_stmt>
    <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>Tracker</name>::<name>clear</name></name><parameter_list>()</parameter_list>
<block>{
    <while>while <condition>(<expr><name>pagelist</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>TrackerPage</name>*</type> <name>p</name> <init>= <expr><name>pagelist</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pagelist</name> = <name><name>pagelist</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
}</block></function>

<function><type><name>bool</name></type>
<name><name>Tracker</name>::<name>has</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>v</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <return>return <expr><call><name>get</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>LIns</name>*</type>
<name><name>Tracker</name>::<name>get</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>v</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    struct <decl_stmt><decl><type><name><name>Tracker</name>::<name>TrackerPage</name></name>*</type> <name>p</name> <init>= <expr><call><name>findTrackerPage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <return>return <expr><name><name>p</name>-&gt;<name>map</name><index>[<expr><call><name>getTrackerPageOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>Tracker</name>::<name>set</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>v</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
    struct <decl_stmt><decl><type><name><name>Tracker</name>::<name>TrackerPage</name></name>*</type> <name>p</name> <init>= <expr><call><name>findTrackerPage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then>
        <expr_stmt><expr><name>p</name> = <call><name>addTrackerPage</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>p</name>-&gt;<name>map</name><index>[<expr><call><name>getTrackerPageOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>jsuint</name></type>
<name>argSlots</name><parameter_list>(<param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>JS_MAX</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>argc</name></name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>isNumber</name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || <call><name>JSVAL_IS_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>jsdouble</name></type>
<name>asNumber</name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>*<call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr>(<name>jsdouble</name>)<call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>isInt32</name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name> <init>= <expr><call><name>asNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>;</decl_stmt>
    <return>return <expr>!!<call><name>JSDOUBLE_IS_INT</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>jsint</name></type>
<name>asInt32</name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSDOUBLE_IS_INT</name><argument_list>(<argument><expr>*<call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name>jsint</name><argument_list>(<argument><expr>*<call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Return TT_DOUBLE for all numbers (int and double) and the tag otherwise. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>TraceType</name></type>
<name>GetPromotedType</name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>TT_DOUBLE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>TT_NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>TT_FUNCTION</name></expr>;</return></then></if>
        <return>return <expr><name>TT_OBJECT</name></expr>;</return>
    }</block></then></if>
    <comment type="block">/* N.B. void is JSVAL_SPECIAL. */</comment>
    <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>TT_VOID</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>tag</name> <init>= <expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL_DOUBLE</name> || <name>tag</name> == <name>JSVAL_STRING</name> || <name>tag</name> == <name>JSVAL_SPECIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>jsvaltag</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TT_DOUBLE</name></expr></argument>)</argument_list></call> == <name>JSVAL_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>jsvaltag</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TT_STRING</name></expr></argument>)</argument_list></call> == <name>JSVAL_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>jsvaltag</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TT_SPECIAL</name></expr></argument>)</argument_list></call> == <name>JSVAL_SPECIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>TraceType</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Return TT_INT32 for all whole numbers that fit into signed 32-bit and the tag otherwise. */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>TraceType</name></type>
<name>getCoercedType</name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>isInt32</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>TT_INT32</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>TT_NULL</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>TT_FUNCTION</name></expr>;</return></then></if>
        <return>return <expr><name>TT_OBJECT</name></expr>;</return>
    }</block></then></if>
    <comment type="block">/* N.B. void is JSVAL_SPECIAL. */</comment>
    <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>TT_VOID</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>tag</name> <init>= <expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL_DOUBLE</name> || <name>tag</name> == <name>JSVAL_STRING</name> || <name>tag</name> == <name>JSVAL_SPECIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>jsvaltag</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TT_DOUBLE</name></expr></argument>)</argument_list></call> == <name>JSVAL_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>jsvaltag</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TT_STRING</name></expr></argument>)</argument_list></call> == <name>JSVAL_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>jsvaltag</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TT_SPECIAL</name></expr></argument>)</argument_list></call> == <name>JSVAL_SPECIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>TraceType</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Constant seed and accumulate step borrowed from the DJB hash. */</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>ORACLE_MASK</name> <init>= <expr><name>ORACLE_SIZE</name> - 1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr>(<name>ORACLE_MASK</name> &amp; <name>ORACLE_SIZE</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>FRAGMENT_TABLE_MASK</name> <init>= <expr><name>FRAGMENT_TABLE_SIZE</name> - 1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr>(<name>FRAGMENT_TABLE_MASK</name> &amp; <name>FRAGMENT_TABLE_SIZE</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>HASH_SEED</name> <init>= <expr>5381</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>HashAccum</name><parameter_list>(<param><decl><type><name>uintptr_t</name>&amp;</type> <name>h</name></decl></param>, <param><decl><type><name>uintptr_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>uintptr_t</name></type> <name>mask</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>h</name> = ((<name>h</name> &lt;&lt; 5) + <name>h</name> + (<name>mask</name> &amp; <name>i</name>)) &amp; <name>mask</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <specifier>inline</specifier> <name>int</name></type>
<name>StackSlotHash</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>pc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintptr_t</name></type> <name>h</name> <init>= <expr><name>HASH_SEED</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>HashAccum</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ORACLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HashAccum</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ORACLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HashAccum</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ORACLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>int</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <specifier>inline</specifier> <name>int</name></type>
<name>GlobalSlotHash</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintptr_t</name></type> <name>h</name> <init>= <expr><name>HASH_SEED</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name><name>fp</name>-&gt;<name>down</name></name></expr>)</condition>
        <expr_stmt><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr>;</expr_stmt></while>

    <expr_stmt><expr><call><name>HashAccum</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>script</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ORACLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HashAccum</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><call><name>OBJ_SHAPE</name><argument_list>(<argument><expr><call><name><name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getGlobal</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ORACLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HashAccum</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ORACLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>int</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>PCHash</name><parameter_list>(<param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>int</name><argument_list>(<argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call> &amp; <name>ORACLE_MASK</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<constructor><name><name>Oracle</name>::<name>Oracle</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/* Grow the oracle bitsets to their (fixed) size here, once. */</comment>
    <expr_stmt><expr><call><name><name>_stackDontDemote</name>.<name>set</name></name><argument_list>(<argument><expr><name>ORACLE_SIZE</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>_globalDontDemote</name>.<name>set</name></name><argument_list>(<argument><expr><name>ORACLE_SIZE</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<comment type="block">/* Tell the oracle that a certain global variable should not be demoted. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>Oracle</name>::<name>markGlobalSlotUndemotable</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_dvander</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"MGSU: %d [%08x]: %d\n"</expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>GlobalSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name><name>_globalDontDemote</name>.<name>get</name></name><argument_list>(<argument><expr><call><name>GlobalSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name><name>_globalDontDemote</name>.<name>set</name></name><argument_list>(<argument><expr><call><name>GlobalSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Consult with the oracle whether we shouldn't demote a certain global variable. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>Oracle</name>::<name>isGlobalSlotUndemotable</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_dvander</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"IGSU: %d [%08x]: %d\n"</expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>GlobalSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name><name>_globalDontDemote</name>.<name>get</name></name><argument_list>(<argument><expr><call><name>GlobalSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name><name>_globalDontDemote</name>.<name>get</name></name><argument_list>(<argument><expr><call><name>GlobalSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Tell the oracle that a certain slot at a certain stack slot should not be demoted. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>Oracle</name>::<name>markStackSlotUndemotable</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>pc</name></decl></param>)</parameter_list>
<block>{
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_dvander</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"MSSU: %p:%d [%08x]: %d\n"</expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>StackSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name><name>_stackDontDemote</name>.<name>get</name></name><argument_list>(<argument><expr><call><name>StackSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name><name>_stackDontDemote</name>.<name>set</name></name><argument_list>(<argument><expr><call><name>StackSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>Oracle</name>::<name>markStackSlotUndemotable</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>markStackSlotUndemotable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Consult with the oracle whether we shouldn't demote a certain slot. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>Oracle</name>::<name>isStackSlotUndemotable</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>pc</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_dvander</name></cpp:ifdef>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"ISSU: %p:%d [%08x]: %d\n"</expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>StackSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name><name>_stackDontDemote</name>.<name>get</name></name><argument_list>(<argument><expr><call><name>StackSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name><name>_stackDontDemote</name>.<name>get</name></name><argument_list>(<argument><expr><call><name>StackSlotHash</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>Oracle</name>::<name>isStackSlotUndemotable</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <return>return <expr><call><name>isStackSlotUndemotable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Tell the oracle that a certain slot at a certain bytecode location should not be demoted. */</comment>
<function><type><name>void</name></type>
<name><name>Oracle</name>::<name>markInstructionUndemotable</name></name><parameter_list>(<param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>_pcDontDemote</name>.<name>set</name></name><argument_list>(<argument><expr><call><name>PCHash</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Consult with the oracle whether we shouldn't demote a certain bytecode location. */</comment>
<function><type><name>bool</name></type>
<name><name>Oracle</name>::<name>isInstructionUndemotable</name></name><parameter_list>(<param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <return>return <expr><call><name><name>_pcDontDemote</name>.<name>get</name></name><argument_list>(<argument><expr><call><name>PCHash</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>Oracle</name>::<name>clearDemotability</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>_stackDontDemote</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>_globalDontDemote</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>_pcDontDemote</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <specifier>static</specifier> <name>JS_INLINE</name> <name>void</name></type>
<name>MarkSlotUndemotable</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>LinkableFragment</name>*</type> <name>f</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>slot</name> &lt; <name><name>f</name>-&gt;<name>nStackTypes</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>oracle</name>.<name>markStackSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>uint16</name>*</type> <name>gslots</name> <init>= <expr><call><name><name>f</name>-&gt;<name>globalSlots</name>-&gt;<name>data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>oracle</name>.<name>markGlobalSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>gslots</name><index>[<expr><name>slot</name> - <name><name>f</name>-&gt;<name>nStackTypes</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <specifier>static</specifier> <name>JS_INLINE</name> <name>void</name></type>
<name>MarkSlotUndemotable</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>LinkableFragment</name>*</type> <name>f</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>pc</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>slot</name> &lt; <name><name>f</name>-&gt;<name>nStackTypes</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>oracle</name>.<name>markStackSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>uint16</name>*</type> <name>gslots</name> <init>= <expr><call><name><name>f</name>-&gt;<name>globalSlots</name>-&gt;<name>data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>oracle</name>.<name>markGlobalSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>gslots</name><index>[<expr><name>slot</name> - <name><name>f</name>-&gt;<name>nStackTypes</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <specifier>inline</specifier> <name>bool</name></type>
<name>IsSlotUndemotable</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>LinkableFragment</name>*</type> <name>f</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>ip</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>slot</name> &lt; <name><name>f</name>-&gt;<name>nStackTypes</name></name></expr>)</condition><then>
        <return>return <expr><call><name><name>oracle</name>.<name>isStackSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <decl_stmt><decl><type><name>uint16</name>*</type> <name>gslots</name> <init>= <expr><call><name><name>f</name>-&gt;<name>globalSlots</name>-&gt;<name>data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>oracle</name>.<name>isGlobalSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>gslots</name><index>[<expr><name>slot</name> - <name><name>f</name>-&gt;<name>nStackTypes</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <specifier>inline</specifier> <name>bool</name></type>
<name>IsSlotUndemotable</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>LinkableFragment</name>*</type> <name>f</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>IsSlotUndemotable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<class>class <name>FrameInfoCache</name>
<block>{<private type="default">
    <struct>struct <name>HashPolicy</name>
    <block>{<public type="default">
        <typedef>typedef <type><name>FrameInfo</name> *</type><name>Lookup</name>;</typedef>
        <function><type><specifier>static</specifier> <name>HashNumber</name></type> <name>hash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>FrameInfo</name>*</type> <name>fi</name></decl></param>)</parameter_list> <block>{
            <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name></expr></argument>)</argument_list></sizeof> + <name><name>fi</name>-&gt;<name>callerHeight</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>HashNumber</name></type> <name>h</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name> <init>= <expr>(const <name>unsigned</name> <name>char</name>*)<name>fi</name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>s</name>++</expr></incr>)
                <expr_stmt><expr><name>h</name> = <call><name>JS_ROTATE_LEFT32</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> ^ *<name>s</name></expr>;</expr_stmt></for>
            <return>return <expr><name>h</name></expr>;</return>
        }</block></function>

        <function><type><specifier>static</specifier> <name>bool</name></type> <name>match</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>FrameInfo</name>*</type> <name>fi1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>FrameInfo</name>*</type> <name>fi2</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>fi1</name></expr></argument>, <argument><expr><name>fi2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
            <return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><call><name><name>fi1</name>-&gt;<name>get_typemap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>fi2</name>-&gt;<name>get_typemap</name></name><argument_list>()</argument_list></call></expr></argument>,
                          <argument><expr><name><name>fi1</name>-&gt;<name>callerHeight</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> == 0</expr>;</return>
        }</block></function>
    </public>}</block>;</struct>

    <typedef>typedef <type><name><name>HashSet</name><argument_list>&lt;<argument><expr><name>FrameInfo</name> *</expr></argument>, <argument><expr><name>HashPolicy</name></expr></argument>, <argument><expr><name>SystemAllocPolicy</name></expr></argument>&gt;</argument_list></name></type> <name>FrameSet</name>;</typedef>

    <decl_stmt><decl><type><name>FrameSet</name></type> <name>set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMAllocator</name> *</type><name>allocator</name></decl>;</decl_stmt>

  </private><public>public:

    <constructor_decl><name>FrameInfoCache</name><parameter_list>(<param><decl><type><name>VMAllocator</name> *</type><name>allocator</name></decl></param>)</parameter_list>;</constructor_decl>

    <function><type><name>void</name></type> <name>reset</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>set</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>FrameInfo</name> *</type><name>memoize</name><parameter_list>(<param><decl><type><name>FrameInfo</name> *</type><name>fi</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name><name>FrameSet</name>::<name>AddPtr</name></name></type> <name>p</name> <init>= <expr><call><name><name>set</name>.<name>lookupForAdd</name></name><argument_list>(<argument><expr><name>fi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>FrameInfo</name>*</type> <name>n</name> <init>= <expr>(<name>FrameInfo</name>*)
                <call><name><name>allocator</name>-&gt;<name>alloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name></expr></argument>)</argument_list></sizeof> + <name><name>fi</name>-&gt;<name>callerHeight</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>fi</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name></expr></argument>)</argument_list></sizeof> + <name><name>fi</name>-&gt;<name>callerHeight</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>set</name>.<name>add</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
        }</block></then></if>

        <return>return <expr>*<name>p</name></expr>;</return>
    }</block></function>
</public>}</block>;</class>

<constructor><name><name>FrameInfoCache</name>::<name>FrameInfoCache</name></name><parameter_list>(<param><decl><type><name>VMAllocator</name> *</type><name>allocator</name></decl></param>)</parameter_list>
  <member_list>: <call><name>allocator</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>)</argument_list></call>
</member_list><block>{
    <if>if <condition>(<expr>!<call><name><name>set</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>OutOfMemoryAbort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></constructor>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PC_HASH_COUNT</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Blacklist</name><parameter_list>(<param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>blacklisted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_TRACE</name> || *<name>pc</name> == <name>JSOP_NOP</name> || *<name>pc</name> == <name>JSOP_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_CALL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*(<name>pc</name> + <name>JSOP_CALL_LENGTH</name>) == <name>JSOP_TRACE</name> ||
                  *(<name>pc</name> + <name>JSOP_CALL_LENGTH</name>) == <name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>pc</name> + <name>JSOP_CALL_LENGTH</name>) = <name>JSOP_NOP</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_TRACE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>pc</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsBlacklisted</name><parameter_list>(<param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_NOP</name></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>
    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_CALL</name></expr>)</condition><then>
        <return>return <expr>*(<name>pc</name> + <name>JSOP_CALL_LENGTH</name>) == <name>JSOP_NOP</name></expr>;</return></then></if>
    <return>return <expr>false</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Backoff</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>, <param><decl><type><name>Fragment</name>*</type> <name>tree</name> <init>= <expr><name>NULL</name></expr></init></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* N.B. This code path cannot assume the recorder is/is not alive. */</comment>
    <decl_stmt><decl><type><name>RecordAttemptMap</name> &amp;</type><name>table</name> <init>= <expr>*<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>recordAttempts</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<decl><type><name><name>RecordAttemptMap</name>::<name>AddPtr</name></name></type> <name>p</name> <init>= <expr><call><name><name>table</name>.<name>lookupForAdd</name></name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>p</name>-&gt;<name>value</name></name>++ &gt; (<name>BL_ATTEMPTS</name> * <name>MAXPEERS</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>p</name>-&gt;<name>value</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name><name>table</name>.<name>add</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>tree</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>hits</name></name><argument_list>()</argument_list></call> -= <name>BL_BACKOFF</name></expr>;</expr_stmt>

        <comment type="block">/*
         * In case there is no entry or no table (due to OOM) or some
         * serious imbalance in the recording-attempt distribution on a
         * multitree, give each tree another chance to blacklist here as
         * well.
         */</comment>
        <if>if <condition>(<expr>++<name><name>tree</name>-&gt;<name>recordAttempts</name></name> &gt; <name>BL_ATTEMPTS</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetRecordingAttempts</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>RecordAttemptMap</name> &amp;</type><name>table</name> <init>= <expr>*<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>recordAttempts</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<decl><type><name><name>RecordAttemptMap</name>::<name>Ptr</name></name></type> <name>p</name> <init>= <expr><call><name><name>table</name>.<name>lookup</name></name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then>
        <expr_stmt><expr><name><name>p</name>-&gt;<name>value</name></name> = 0</expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>
<name>FragmentHash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>ip</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>globalShape</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintptr_t</name></type> <name>h</name> <init>= <expr><name>HASH_SEED</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>HashAccum</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FRAGMENT_TABLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HashAccum</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FRAGMENT_TABLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HashAccum</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>globalShape</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FRAGMENT_TABLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HashAccum</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FRAGMENT_TABLE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>size_t</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RawLookupFirstPeer</name><parameter_list>(<param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>ip</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>,
                   <param><decl><type><name>uint32</name></type> <name>globalShape</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>,
                   <param><decl><type><name>TreeFragment</name>*&amp;</type> <name>firstInBucket</name></decl></param>, <param><decl><type><name>TreeFragment</name>**&amp;</type> <name>prevTreeNextp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>h</name> <init>= <expr><call><name>FragmentHash</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>globalShape</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TreeFragment</name>**</type> <name>ppf</name> <init>= <expr>&amp;<name><name>tm</name>-&gt;<name>vmfragments</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>firstInBucket</name> = *<name>ppf</name></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>TreeFragment</name>* <name>pf</name> = *<name>ppf</name></expr>;</condition> <incr><expr><name>ppf</name> = &amp;<name><name>pf</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>pf</name>-&gt;<name>globalObj</name></name> == <name>globalObj</name> &amp;&amp;
            <name><name>pf</name>-&gt;<name>globalShape</name></name> == <name>globalShape</name> &amp;&amp;
            <name><name>pf</name>-&gt;<name>ip</name></name> == <name>ip</name> &amp;&amp;
            <name><name>pf</name>-&gt;<name>argc</name></name> == <name>argc</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>prevTreeNextp</name> = <name>ppf</name></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
    }</block></for>
    <expr_stmt><expr><name>prevTreeNextp</name> = <name>ppf</name></expr>;</expr_stmt>
    <return>return;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>TreeFragment</name>*</type>
<name>LookupLoop</name><parameter_list>(<param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>ip</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>,
                <param><decl><type><name>uint32</name></type> <name>globalShape</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TreeFragment</name> *</type><name>_</name></decl>, **<decl><type ref="prev"/><name>prevTreeNextp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RawLookupFirstPeer</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>globalShape</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>_</name></expr></argument>, <argument><expr><name>prevTreeNextp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>*<name>prevTreeNextp</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>TreeFragment</name>*</type>
<name>LookupOrAddLoop</name><parameter_list>(<param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>ip</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>,
                <param><decl><type><name>uint32</name></type> <name>globalShape</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TreeFragment</name> *</type><name>firstInBucket</name></decl>, **<decl><type ref="prev"/><name>prevTreeNextp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RawLookupFirstPeer</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>globalShape</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>firstInBucket</name></expr></argument>, <argument><expr><name>prevTreeNextp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<decl><type><name>TreeFragment</name> *</type><name>f</name> <init>= <expr>*<name>prevTreeNextp</name></expr></init></decl>)</condition><then>
        <return>return <expr><name>f</name></expr>;</return></then></if>

    <macro><name>verbose_only</name><argument_list>(
    <argument>uint32_t profFragID = (LogController.lcbits &amp; LC_FragProfile)
                          ? (++(tm-&gt;lastFragID)) : 0;</argument>
    )</argument_list></macro>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>f</name> <init>= <expr>new (*<name><name>tm</name>-&gt;<name>dataAlloc</name></name>) <macro><name>TreeFragment</name><argument_list>(<argument>ip</argument>, <argument>tm-&gt;dataAlloc</argument>, <argument>globalObj</argument>, <argument>globalShape</argument>,
                                                        <argument>argc verbose_only(, profFragID)</argument>)</argument_list></macro></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>f</name>-&gt;<name>root</name></name> = <name>f</name></expr>;</expr_stmt>                <comment type="block">/* f is the root of a new tree */</comment>
    <expr_stmt><expr>*<name>prevTreeNextp</name> = <name>f</name></expr>;</expr_stmt>         <comment type="block">/* insert f at the end of the vmfragments bucket-list */</comment>
    <expr_stmt><expr><name><name>f</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name>-&gt;<name>first</name></name> = <name>f</name></expr>;</expr_stmt>               <comment type="block">/* initialize peer-list at f */</comment>
    <expr_stmt><expr><name><name>f</name>-&gt;<name>peer</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>f</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>TreeFragment</name>*</type>
<name>AddNewPeerToPeerList</name><parameter_list>(<param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>peer</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>verbose_only</name><argument_list>(
    <argument>uint32_t profFragID = (LogController.lcbits &amp; LC_FragProfile)
                          ? (++(tm-&gt;lastFragID)) : 0;</argument>
    )</argument_list></macro>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>f</name> <init>= <expr>new (*<name><name>tm</name>-&gt;<name>dataAlloc</name></name>) <macro><name>TreeFragment</name><argument_list>(<argument>peer-&gt;ip</argument>, <argument>tm-&gt;dataAlloc</argument>, <argument>peer-&gt;globalObj</argument>,
                                                        <argument>peer-&gt;globalShape</argument>, <argument>peer-&gt;argc
                                                        verbose_only(, profFragID)</argument>)</argument_list></macro></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>f</name>-&gt;<name>root</name></name> = <name>f</name></expr>;</expr_stmt>                <comment type="block">/* f is the root of a new tree */</comment>
    <expr_stmt><expr><name><name>f</name>-&gt;<name>first</name></name> = <name><name>peer</name>-&gt;<name>first</name></name></expr>;</expr_stmt>     <comment type="block">/* add f to peer list */</comment>
    <expr_stmt><expr><name><name>f</name>-&gt;<name>peer</name></name> = <name><name>peer</name>-&gt;<name>peer</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>peer</name>-&gt;<name>peer</name></name> = <name>f</name></expr>;</expr_stmt>
    <comment type="block">/* only the |first| Fragment of a peer list needs a valid |next| field */</comment>
    <expr_stmt><expr><call><name>debug_only</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name> = (<name>TreeFragment</name>*)0xcdcdcdcd</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>f</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TreeFragment</name>::<name>initialize</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>SlotList</name> *</type><name>globalSlots</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>this</name>-&gt;<name>dependentTrees</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>this</name>-&gt;<name>linkedTrees</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>globalSlots</name></name> = <name>globalSlots</name></expr>;</expr_stmt>

    <comment type="block">/* Capture the coerced type of each active slot in the type map. */</comment>
    <expr_stmt><expr><call><name><name>this</name>-&gt;<name>typeMap</name>.<name>captureTypes</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr>*<name>globalSlots</name></expr></argument>, <argument><expr>0</expr></argument> <comment type="block">/* callDepth */</comment>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>nStackTypes</name></name> = <call><name><name>this</name>-&gt;<name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call> - <call><name><name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>treeFileName</name></name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>treeLineNumber</name></name> = <call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>treePCOffset</name></name> = <call><name>FramePCOffset</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>script</name></name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>recursion</name></name> = <name>Recursion_None</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>this</name>-&gt;<name>gcthings</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>this</name>-&gt;<name>sprops</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>unstableExits</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>this</name>-&gt;<name>sideExits</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Determine the native frame layout at the entry point. */</comment>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>nativeStackBase</name></name> = (<name>nStackTypes</name> - (<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> - <call><name>StackBase</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call>)) *
                             <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>maxNativeStackSlots</name></name> = <name>nStackTypes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this</name>-&gt;<name>maxCallDepth</name></name> = 0</expr>;</expr_stmt>
}</block></function>

<function><type><name>UnstableExit</name>*</type>
<name><name>TreeFragment</name>::<name>removeUnstableExit</name></name><parameter_list>(<param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Now erase this exit from the unstable exit list. */</comment>
    <decl_stmt><decl><type><name>UnstableExit</name>**</type> <name>tail</name> <init>= <expr>&amp;<name><name>this</name>-&gt;<name>unstableExits</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>UnstableExit</name>*</type> <name>uexit</name> <init>= <expr><name><name>this</name>-&gt;<name>unstableExits</name></name></expr></init></decl>;</init> <condition><expr><name>uexit</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>uexit</name> = <name><name>uexit</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>uexit</name>-&gt;<name>exit</name></name> == <name>exit</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>tail</name> = <name><name>uexit</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            <return>return <expr>*<name>tail</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>tail</name> = &amp;<name><name>uexit</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"exit not in unstable exit list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AssertTreeIsUnique</name><parameter_list>(<param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>root</name></name> == <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for duplicate entry type maps.  This is always wrong and hints at
     * trace explosion since we are trying to stabilize something without
     * properly connecting peer edges.
     */</comment>
    <for>for (<init><decl><type><name>TreeFragment</name>*</type> <name>peer</name> <init>= <expr><call><name>LookupLoop</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>ip</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>globalObj</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>globalShape</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</init>
         <condition><expr><name>peer</name> != <name>NULL</name></expr>;</condition>
         <incr><expr><name>peer</name> = <name><name>peer</name>-&gt;<name>peer</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name><name>peer</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call> || <name>peer</name> == <name>f</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>f</name>-&gt;<name>typeMap</name>.<name>matches</name></name><argument_list>(<argument><expr><name><name>peer</name>-&gt;<name>typeMap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AttemptCompilation</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>, <param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceMonitor</name> *</type><name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If we already permanently blacklisted the location, undo that. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_NOP</name> || *<name>pc</name> == <name>JSOP_TRACE</name> || *<name>pc</name> == <name>JSOP_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_NOP</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>pc</name> = <name>JSOP_TRACE</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>ResetRecordingAttempts</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Breathe new life into all peer fragments at the designated loop header. */</comment>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>f</name> <init>= <expr><call><name>LookupLoop</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><call><name>OBJ_SHAPE</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>f</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If the global object's shape changed, we can't easily find the
         * corresponding loop header via a hash table lookup. In this
         * we simply bail here and hope that the fragment has another
         * outstanding compilation attempt. This case is extremely rare.
         */</comment>
        <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>root</name></name> == <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>f</name> = <name><name>f</name>-&gt;<name>first</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>f</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>root</name></name> == <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>--<name><name>f</name>-&gt;<name>recordAttempts</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>f</name>-&gt;<name>hits</name></name><argument_list>()</argument_list></call> = <name>HOTLOOP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>f</name> = <name><name>f</name>-&gt;<name>peer</name></name></expr>;</expr_stmt>
    }</block></while>
}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isfop</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>, <param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NJ_SOFTFLOAT_SUPPORTED</name></expr></cpp:if>
    <if>if <condition>(<expr><name><name>nanojit</name>::<name>AvmCore</name>::<name>config</name>.<name>soft_float</name></name> &amp;&amp;
        <call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_qjoin</name></expr></argument>)</argument_list></call> &amp;&amp;
        <call><name><name>i</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call>-&gt;<call><name>isop</name><argument_list>(<argument><expr><name>LIR_icall</name></expr></argument>)</argument_list></call> &amp;&amp;
        <call><name><name>i</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call>-&gt;<call><name>isop</name><argument_list>(<argument><expr><name>LIR_callh</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><call><name><name>i</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call>-&gt;<call><name>callInfo</name><argument_list>()</argument_list></call> == <name><name>softFloatOps</name>.<name>opmap</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>false</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>CallInfo</name> *</type>
<name>fcallinfo</name><parameter_list>(<param><decl><type><name>LIns</name> *</type><name>i</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NJ_SOFTFLOAT_SUPPORTED</name></expr></cpp:if>
    <if>if <condition>(<expr><name><name>nanojit</name>::<name>AvmCore</name>::<name>config</name>.<name>soft_float</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_qjoin</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>i</name> = <call><name><name>i</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_icall</name></expr></argument>)</argument_list></call> ? <call><name><name>i</name>-&gt;<name>callInfo</name></name><argument_list>()</argument_list></call> : <name>NULL</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_fcall</name></expr></argument>)</argument_list></call> ? <call><name><name>i</name>-&gt;<name>callInfo</name></name><argument_list>()</argument_list></call> : <name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>LIns</name>*</type>
<name>fcallarg</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NJ_SOFTFLOAT_SUPPORTED</name></expr></cpp:if>
    <if>if <condition>(<expr><name><name>nanojit</name>::<name>AvmCore</name>::<name>config</name>.<name>soft_float</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_qjoin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>i</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call>-&gt;<call><name>callArgN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_fcall</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>i</name>-&gt;<name>callArgN</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>LIns</name>*</type>
<name>foprnd1</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NJ_SOFTFLOAT_SUPPORTED</name></expr></cpp:if>
    <if>if <condition>(<expr><name><name>nanojit</name>::<name>AvmCore</name>::<name>config</name>.<name>soft_float</name></name></expr>)</condition><then>
        <return>return <expr><call><name>fcallarg</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name><name>i</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>LIns</name>*</type>
<name>foprnd2</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NJ_SOFTFLOAT_SUPPORTED</name></expr></cpp:if>
    <if>if <condition>(<expr><name><name>nanojit</name>::<name>AvmCore</name>::<name>config</name>.<name>soft_float</name></name></expr>)</condition><then>
        <return>return <expr><call><name>fcallarg</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name><name>i</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>LIns</name>*</type>
<name>demote</name><parameter_list>(<param><decl><type><name>LirWriter</name> *</type><name>out</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>i</name>-&gt;<name>isCall</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name><name>i</name>-&gt;<name>callArgN</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>isfop</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>LIR_i2f</name></expr></argument>)</argument_list></call> || <call><name>isfop</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>LIR_u2f</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>foprnd1</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name><name>i</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>i</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>i</name>-&gt;<name>isconstf</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>cf</name> <init>= <expr><call><name><name>i</name>-&gt;<name>imm64f</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>ci</name> <init>= <expr><name>cf</name> &gt; 0x7fffffff ? <call><name>uint32_t</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call> : <call><name>int32_t</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>out</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isPromoteInt</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>isfop</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>LIR_i2f</name></expr></argument>)</argument_list></call> || <call><name><name>i</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name><name>i</name>-&gt;<name>isconstf</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name> <init>= <expr><call><name><name>i</name>-&gt;<name>imm64f</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>d</name> == <call><name>jsdouble</name><argument_list>(<argument><expr><call><name>jsint</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>JSDOUBLE_IS_NEGZERO</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isPromoteUint</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>isfop</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>LIR_u2f</name></expr></argument>)</argument_list></call> || <call><name><name>i</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>
    <if>if <condition>(<expr>!<call><name><name>i</name>-&gt;<name>isconstf</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name> <init>= <expr><call><name><name>i</name>-&gt;<name>imm64f</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>d</name> == <call><name>jsdouble</name><argument_list>(<argument><expr><call><name>jsuint</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>JSDOUBLE_IS_NEGZERO</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isPromote</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>isPromoteInt</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> || <call><name>isPromoteUint</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Determine whether this operand is guaranteed to not overflow the specified
 * integer operation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsOverflowSafe</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>c</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
      <case>case <expr><name>LIR_add</name></expr>:
      </case><case>case <expr><name>LIR_sub</name></expr>:
          <return>return <expr>(<call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_and</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>c</name> = <call><name><name>i</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call>)-&gt;<call><name>isconst</name><argument_list>()</argument_list></call>) &amp;&amp;
                  ((<call><name><name>c</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call> &amp; 0xc0000000) == 0)) ||
                 (<call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_rsh</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>c</name> = <call><name><name>i</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call>)-&gt;<call><name>isconst</name><argument_list>()</argument_list></call>) &amp;&amp;
                  ((<call><name><name>c</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call> &gt; 0)))</expr>;</return>
    </case><default>default:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>LIR_mul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>
    <return>return <expr>(<call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_and</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>c</name> = <call><name><name>i</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call>)-&gt;<call><name>isconst</name><argument_list>()</argument_list></call>) &amp;&amp;
            ((<call><name><name>c</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call> &amp; 0xffff0000) == 0)) ||
           (<call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_ush</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>c</name> = <call><name><name>i</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call>)-&gt;<call><name>isconst</name><argument_list>()</argument_list></call>) &amp;&amp;
            ((<call><name><name>c</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call> &gt;= 16)))</expr>;</return>
}</block></function>

<class>class <name>FuncFilter</name><super>: <specifier>public</specifier> <name>LirWriter</name></super>
<block>{<private type="default">
</private><public>public:
    <constructor><name>FuncFilter</name><parameter_list>(<param><decl><type><name>LirWriter</name>*</type> <name>out</name></decl></param>)</parameter_list><member_list>:
        <call><name>LirWriter</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call>
    </member_list><block>{
    }</block></constructor>

    <function><type><name>LIns</name>*</type> <name>ins2</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>s0</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>s1</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>s0</name> == <name>s1</name> &amp;&amp; <name>v</name> == <name>LIR_feq</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>isPromote</name><argument_list>(<argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// double(int) and double(uint) cannot be nan</comment>
                <return>return <expr><call><name>insImm</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name><name>s0</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_fmul</name></expr></argument>)</argument_list></call> || <call><name><name>s0</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_fsub</name></expr></argument>)</argument_list></call> || <call><name><name>s0</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_fadd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>LIns</name>*</type> <name>lhs</name> <init>= <expr><call><name><name>s0</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>LIns</name>*</type> <name>rhs</name> <init>= <expr><call><name><name>s0</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name>isPromote</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>isPromote</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="line">// add/sub/mul promoted ints can't be nan</comment>
                    <return>return <expr><call><name>insImm</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>isFCmpOpcode</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>isPromoteInt</name><argument_list>(<argument><expr><name>s0</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>isPromoteInt</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// demote fcmp to cmp</comment>
                <expr_stmt><expr><name>v</name> = <call><name>LOpcode</name><argument_list>(<argument><expr><name>v</name> + (<name>LIR_eq</name> - <name>LIR_feq</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name><name>out</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>demote</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>demote</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then> <else>else <if>if <condition>(<expr><call><name>isPromoteUint</name><argument_list>(<argument><expr><name>s0</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>isPromoteUint</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="line">// uint compare</comment>
                <expr_stmt><expr><name>v</name> = <call><name>LOpcode</name><argument_list>(<argument><expr><name>v</name> + (<name>LIR_eq</name> - <name>LIR_feq</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>v</name> != <name>LIR_eq</name></expr>)</condition><then>
                    <expr_stmt><expr><name>v</name> = <call><name>LOpcode</name><argument_list>(<argument><expr><name>v</name> + (<name>LIR_ult</name> - <name>LIR_lt</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> <comment type="line">// cmp -&gt; ucmp</comment>
                <return>return <expr><call><name><name>out</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>demote</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>demote</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if></else></if>
        }</block></then></if></else></if>
        <return>return <expr><call><name><name>out</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>s0</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
</public>}</block>;</class>

<comment type="block">/*
 * Visit the values in the given JSStackFrame that the tracer cares about. This
 * visitor function is (implicitly) the primary definition of the native stack
 * area layout. There are a few other independent pieces of code that must be
 * maintained to assume the same layout. They are marked like this:
 *
 *   Duplicate native stack layout computation: see VisitFrameSlots header comment.
 */</comment>
<template>template <parameter_list>&lt;<param><type><typename>typename</typename></type> <name>Visitor</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name>VisitFrameSlots</name><parameter_list>(<param><decl><type><name>Visitor</name> &amp;</type><name>visitor</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>depth</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>,
                <param><decl><type><name>JSStackFrame</name> *</type><name>up</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>depth</name> &gt; 0 &amp;&amp; !<call><name>VisitFrameSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>depth</name>-1</expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>down</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>argv</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>depth</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>visitor</name>.<name>setStackSlotKind</name></name><argument_list>(<argument><expr>"args"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>visitor</name>.<name>visitStackSlots</name></name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>, <argument><expr><call><name>argSlots</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> + 2</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>visitor</name>.<name>setStackSlotKind</name></name><argument_list>(<argument><expr>"arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>visitor</name>.<name>visitStackSlots</name></name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <comment type="line">// We want to import and track |JSObject *scopeChain|, but the tracker</comment>
        <comment type="line">// requires type |jsval|. But the bits are the same, so we can import</comment>
        <comment type="line">// it with a cast and the (identity function) unboxing will be OK.</comment>
        <expr_stmt><expr><call><name><name>visitor</name>.<name>setStackSlotKind</name></name><argument_list>(<argument><expr>"scopeChain"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>visitor</name>.<name>visitStackSlots</name></name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>scopeChainVal</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>visitor</name>.<name>setStackSlotKind</name></name><argument_list>(<argument><expr>"var"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>visitor</name>.<name>visitStackSlots</name></name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>slots</name></name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>visitor</name>.<name>setStackSlotKind</name></name><argument_list>(<argument><expr>"stack"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> &gt;= <call><name>StackBase</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>visitor</name>.<name>visitStackSlots</name></name><argument_list>(<argument><expr><call><name>StackBase</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> - <call><name>StackBase</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>false</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>up</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>missing</name> <init>= <expr><name><name>up</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name> - <name><name>up</name>-&gt;<name>argc</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>missing</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>visitor</name>.<name>setStackSlotKind</name></name><argument_list>(<argument><expr>"missing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>visitor</name>.<name>visitStackSlots</name></name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name></expr></argument>, <argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name>missing</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>true</expr>;</return>
}</block></function></template>

<comment type="line">// Number of native frame slots used for 'special' values between args and vars.</comment>
<comment type="line">// Currently the two values are |arguments| (args object) and |scopeChain|.</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>SPECIAL_FRAME_SLOTS</name> <init>= <expr>2</expr></init></decl>;</decl_stmt>

<template>template <parameter_list>&lt;<param><type><typename>typename</typename></type> <name>Visitor</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
<name>VisitStackSlots</name><parameter_list>(<param><decl><type><name>Visitor</name> &amp;</type><name>visitor</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>VisitFrameSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function></template>

<template>template <parameter_list>&lt;<param><type><typename>typename</typename></type> <name>Visitor</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
<name>VisitGlobalSlots</name><parameter_list>(<param><decl><type><name>Visitor</name> &amp;</type><name>visitor</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>globalObj</name></decl></param>,
                 <param><decl><type><name>unsigned</name></type> <name>ngslots</name></decl></param>, <param><decl><type><name>uint16</name> *</type><name>gslots</name></decl></param>)</parameter_list>
<block>{
    <for>for (<init><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>n</name> &lt; <name>ngslots</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>slot</name> <init>= <expr><name><name>gslots</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>visitor</name>.<name>visitGlobalSlot</name></name><argument_list>(<argument><expr>&amp;<call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function></template>

<template>template <parameter_list>&lt;<param><type><typename>typename</typename></type> <name>Visitor</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
<name>VisitGlobalSlots</name><parameter_list>(<param><decl><type><name>Visitor</name> &amp;</type><name>visitor</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>TreeFragment</name> *</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>globalObj</name> <init>= <expr><call><name><name>f</name>-&gt;<name>globalObj</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SlotList</name>&amp;</type> <name>gslots</name> <init>= <expr>*<name><name>f</name>-&gt;<name>globalSlots</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitGlobalSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><call><name><name>gslots</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>gslots</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function></template>

<class_decl>class <name>AdjustCallerTypeVisitor</name>;</class_decl>

<template>template <parameter_list>&lt;<param><type><typename>typename</typename></type> <name>Visitor</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
<name>VisitGlobalSlots</name><parameter_list>(<param><decl><type><name>Visitor</name> &amp;</type><name>visitor</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>SlotList</name> &amp;</type><name>gslots</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>VisitGlobalSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getGlobal</name></name><argument_list>()</argument_list></call></expr></argument>,
                     <argument><expr><call><name><name>gslots</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>gslots</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function></template>


<template>template <parameter_list>&lt;<param><type><typename>typename</typename></type> <name>Visitor</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
<name>VisitSlots</name><parameter_list>(<param><decl><type><name>Visitor</name>&amp;</type> <name>visitor</name></decl></param>, <param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>,
           <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ngslots</name></decl></param>, <param><decl><type><name>uint16</name>*</type> <name>gslots</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>VisitGlobalSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>ngslots</name></expr></argument>, <argument><expr><name>gslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function></template>

<template>template <parameter_list>&lt;<param><type><typename>typename</typename></type> <name>Visitor</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
<name>VisitSlots</name><parameter_list>(<param><decl><type><name>Visitor</name>&amp;</type> <name>visitor</name></decl></param>, <param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>,
           <param><decl><type><name>unsigned</name></type> <name>ngslots</name></decl></param>, <param><decl><type><name>uint16</name>*</type> <name>gslots</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>VisitSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getGlobal</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><name>ngslots</name></expr></argument>, <argument><expr><name>gslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function></template>

<template>template <parameter_list>&lt;<param><type><typename>typename</typename></type> <name>Visitor</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
<name>VisitSlots</name><parameter_list>(<param><decl><type><name>Visitor</name> &amp;</type><name>visitor</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>globalObj</name></decl></param>,
           <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>SlotList</name>&amp;</type> <name>slots</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>VisitSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><call><name><name>slots</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr><call><name><name>slots</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function></template>

<template>template <parameter_list>&lt;<param><type><typename>typename</typename></type> <name>Visitor</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
<name>VisitSlots</name><parameter_list>(<param><decl><type><name>Visitor</name> &amp;</type><name>visitor</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>SlotList</name>&amp;</type> <name>slots</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>VisitSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getGlobal</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><call><name><name>slots</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>slots</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function></template>


<class>class <name>SlotVisitorBase</name> <block>{<private type="default">
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_JIT_SPEW</name></expr></cpp:if>
</private><protected>protected:
    <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> *</type><name>mStackSlotKind</name></decl>;</decl_stmt>
</protected><public>public:
    <constructor><name>SlotVisitorBase</name><parameter_list>()</parameter_list> <member_list>: <call><name>mStackSlotKind</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> </member_list><block>{}</block></constructor>
    <function><type><name>JS_ALWAYS_INLINE</name> <specifier>const</specifier> <name>char</name> *</type><name>stackSlotKind</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>mStackSlotKind</name></expr>;</return> }</block></function>
    <function><type><name>JS_ALWAYS_INLINE</name> <name>void</name></type> <name>setStackSlotKind</name><parameter_list>(<param><decl><type><name>char</name> <specifier>const</specifier> *</type><name>k</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>mStackSlotKind</name> = <name>k</name></expr>;</expr_stmt>
    }</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
</public><public>public:
    <function><type><name>JS_ALWAYS_INLINE</name> <specifier>const</specifier> <name>char</name> *</type><name>stackSlotKind</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>NULL</name></expr>;</return> }</block></function>
    <function><type><name>JS_ALWAYS_INLINE</name> <name>void</name></type> <name>setStackSlotKind</name><parameter_list>(<param><decl><type><name>char</name> <specifier>const</specifier> *</type><name>k</name></decl></param>)</parameter_list> <block>{}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</public>}</block>;</class>

<struct>struct <name>CountSlotsVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<public type="default">
    <decl_stmt><decl><type><name>unsigned</name></type> <name>mCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>mDone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>mStop</name></decl>;</decl_stmt>
</public><public>public:
    <macro><name>JS_ALWAYS_INLINE</name></macro> <constructor><name>CountSlotsVisitor</name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>stop</name> <init>= <expr><name>NULL</name></expr></init></decl></param>)</parameter_list> <member_list>:
        <call><name>mCount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
        <call><name>mDone</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call>,
        <call><name>mStop</name><argument_list>(<argument><expr><name>stop</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
    <name>visitStackSlots</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>mDone</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <if>if <condition>(<expr><name>mStop</name> &amp;&amp; <call><name>size_t</name><argument_list>(<argument><expr><name>mStop</name> - <name>vp</name></expr></argument>)</argument_list></call> &lt; <name>count</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mCount</name> += <call><name>size_t</name><argument_list>(<argument><expr><name>mStop</name> - <name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mDone</name> = true</expr>;</expr_stmt>
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>mCount</name> += <name>count</name></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><name>JS_ALWAYS_INLINE</name> <name>unsigned</name></type> <name>count</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mCount</name></expr>;</return>
    }</block></function>

    <function><type><name>JS_ALWAYS_INLINE</name> <name>bool</name></type> <name>stopped</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mDone</name></expr>;</return>
    }</block></function>
</public>}</block>;</struct>

<comment type="block">/*
 * Calculate the total number of native frame slots we need from this frame all
 * the way back to the entry frame, including the current stack usage.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>unsigned</name></type>
<name>NativeStackSlots</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>slots</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>depth</name> <init>= <expr><name>callDepth</name></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <comment type="block">/*
         * Duplicate native stack layout computation: see VisitFrameSlots
         * header comment.
         */</comment>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>operands</name> <init>= <expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> - <call><name>StackBase</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>slots</name> += <name>operands</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>argv</name></name></expr>)</condition><then>
            <expr_stmt><expr><name>slots</name> += <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name> + <name>SPECIAL_FRAME_SLOTS</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>depth</name>-- == 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>argv</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>slots</name> += 2<comment type="block">/*callee,this*/</comment> + <call><name>argSlots</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <decl_stmt><decl><type><name>CountSlotsVisitor</name></type> <name>visitor</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>visitor</name>.<name>count</name></name><argument_list>()</argument_list></call> == <name>slots</name> &amp;&amp; !<call><name><name>visitor</name>.<name>stopped</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return <expr><name>slots</name></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp2</name> <init>= <expr><name>fp</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>missing</name> <init>= <expr><name><name>fp2</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name> - <name><name>fp2</name>-&gt;<name>argc</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>missing</name> &gt; 0</expr>)</condition><then>
            <expr_stmt><expr><name>slots</name> += <name>missing</name></expr>;</expr_stmt></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"NativeStackSlots"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<class>class <name>CaptureTypesVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>JSContext</name>*</type> <name>mCx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name>*</type> <name>mTypeMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name>*</type> <name>mPtr</name></decl>;</decl_stmt>

</private><public>public:
    <macro><name>JS_ALWAYS_INLINE</name></macro> <constructor><name>CaptureTypesVisitor</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TraceType</name>*</type> <name>typeMap</name></decl></param>)</parameter_list> <member_list>:
        <call><name>mCx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>,
        <call><name>mTypeMap</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>)</argument_list></call>,
        <call><name>mPtr</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>visitGlobalSlot</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
            <decl_stmt><decl><type><name>TraceType</name></type> <name>type</name> <init>= <expr><call><name>getCoercedType</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>type</name> == <name>TT_INT32</name> &amp;&amp;
                <call><name><name>oracle</name>.<name>isGlobalSlotUndemotable</name></name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>type</name> = <name>TT_DOUBLE</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> != <name>TT_JSVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                              <argument><expr>"capture type global%d: %d=%c\n"</expr></argument>,
                              <argument><expr><name>n</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>mPtr</name>++ = <name>type</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
    <name>visitStackSlots</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>TraceType</name></type> <name>type</name> <init>= <expr><call><name>getCoercedType</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>type</name> == <name>TT_INT32</name> &amp;&amp;
                <call><name><name>oracle</name>.<name>isStackSlotUndemotable</name></name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr><call><name>length</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>type</name> = <name>TT_DOUBLE</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> != <name>TT_JSVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                              <argument><expr>"capture type %s%d: %d=%c\n"</expr></argument>,
                              <argument><expr><call><name>stackSlotKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>mPtr</name>++ = <name>type</name></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><name>JS_ALWAYS_INLINE</name> <name>uintptr_t</name></type> <name>length</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mPtr</name> - <name>mTypeMap</name></expr>;</return>
    }</block></function>
</public>}</block>;</class>

<function><type><name>void</name></type>
<name><name>TypeMap</name>::<name>set</name></name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>stackSlots</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ngslots</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>TraceType</name>*</type> <name>stackTypeMap</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>TraceType</name>*</type> <name>globalTypeMap</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>setLength</name><argument_list>(<argument><expr><name>ngslots</name> + <name>stackSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>data</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>stackTypeMap</name></expr></argument>, <argument><expr><name>stackSlots</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>data</name><argument_list>()</argument_list></call> + <name>stackSlots</name></expr></argument>, <argument><expr><name>globalTypeMap</name></expr></argument>, <argument><expr><name>ngslots</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Capture the type map for the selected slots of the global object and currently pending
 * stack frames.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TypeMap</name>::<name>captureTypes</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>, <param><decl><type><name>SlotList</name>&amp;</type> <name>slots</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>setLength</name><argument_list>(<argument><expr><call><name>NativeStackSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call> + <call><name><name>slots</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CaptureTypesVisitor</name></type> <name>visitor</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>data</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>visitor</name>.<name>length</name></name><argument_list>()</argument_list></call> == <call><name>length</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TypeMap</name>::<name>captureMissingGlobalTypes</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>, <param><decl><type><name>SlotList</name>&amp;</type> <name>slots</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>stackSlots</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>oldSlots</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call> - <name>stackSlots</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr><call><name><name>slots</name>.<name>length</name></name><argument_list>()</argument_list></call> - <name>oldSlots</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>diff</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setLength</name><argument_list>(<argument><expr><call><name>length</name><argument_list>()</argument_list></call> + <name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>CaptureTypesVisitor</name></type> <name>visitor</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>data</name><argument_list>()</argument_list></call> + <name>stackSlots</name> + <name>oldSlots</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitGlobalSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><call><name><name>slots</name>.<name>data</name></name><argument_list>()</argument_list></call> + <name>oldSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Compare this type map to another one and see whether they match. */</comment>
<function><type><name>bool</name></type>
<name><name>TypeMap</name>::<name>matches</name></name><parameter_list>(<param><decl><type><name>TypeMap</name>&amp;</type> <name>other</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <if>if <condition>(<expr><call><name>length</name><argument_list>()</argument_list></call> != <call><name><name>other</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <return>return <expr>!<call><name>memcmp</name><argument_list>(<argument><expr><call><name>data</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>length</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>TypeMap</name>::<name>fromRaw</name></name><parameter_list>(<param><decl><type><name>TraceType</name>*</type> <name>other</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>numSlots</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>oldLength</name> <init>= <expr><call><name>length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setLength</name><argument_list>(<argument><expr><call><name>length</name><argument_list>()</argument_list></call> + <name>numSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>numSlots</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>get</name><argument_list>(<argument><expr><name>oldLength</name> + <name>i</name></expr></argument>)</argument_list></call> = <name><name>other</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
}</block></function>

<comment type="block">/*
 * Use the provided storage area to create a new type map that contains the
 * partial type map with the rest of it filled up from the complete type
 * map.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MergeTypeMaps</name><parameter_list>(<param><decl><type><name>TraceType</name>**</type> <name>partial</name></decl></param>, <param><decl><type><name>unsigned</name>*</type> <name>plength</name></decl></param>, <param><decl><type><name>TraceType</name>*</type> <name>complete</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>clength</name></decl></param>, <param><decl><type><name>TraceType</name>*</type> <name>mem</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>l</name> <init>= <expr>*<name>plength</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>l</name> &lt; <name>clength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr>*<name>partial</name></expr></argument>, <argument><expr><name>l</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mem</name> + <name>l</name></expr></argument>, <argument><expr><name>complete</name> + <name>l</name></expr></argument>, <argument><expr>(<name>clength</name> - <name>l</name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>partial</name> = <name>mem</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>plength</name> = <name>clength</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Specializes a tree to any specifically missing globals, including any
 * dependent trees.
 */</comment>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name>SpecializeTreesToLateGlobals</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>root</name></decl></param>, <param><decl><type><name>TraceType</name>*</type> <name>globalTypeMap</name></decl></param>,
                            <param><decl><type><name>unsigned</name></type> <name>numGlobalSlots</name></decl></param>)</parameter_list>
<block>{
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><call><name><name>root</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>numGlobalSlots</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name><name>root</name>-&gt;<name>typeMap</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>globalTypeMap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>root</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call> == <name>numGlobalSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>root</name>-&gt;<name>dependentTrees</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>tree</name> <init>= <expr><name><name>root</name>-&gt;<name>dependentTrees</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>tree</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>tree</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call> &lt; <name>numGlobalSlots</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SpecializeTreesToLateGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>globalTypeMap</name></expr></argument>, <argument><expr><name>numGlobalSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>root</name>-&gt;<name>linkedTrees</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>tree</name> <init>= <expr><name><name>root</name>-&gt;<name>linkedTrees</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>tree</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>tree</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call> &lt; <name>numGlobalSlots</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SpecializeTreesToLateGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>globalTypeMap</name></expr></argument>, <argument><expr><name>numGlobalSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
}</block></function>

<comment type="block">/* Specializes a tree to any missing globals, including any dependent trees. */</comment>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name>SpecializeTreesToMissingGlobals</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>root</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>root</name>-&gt;<name>typeMap</name>.<name>captureMissingGlobalTypes</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr>*<name><name>root</name>-&gt;<name>globalSlots</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>nStackTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>root</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> == <call><name><name>root</name>-&gt;<name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call> - <name><name>root</name>-&gt;<name>nStackTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <expr_stmt><expr><call><name>SpecializeTreesToLateGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><call><name><name>root</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>root</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>ResetJITImpl</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>void</name></type>
<name>ResetJIT</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TraceVisFlushReason</name></type> <name>r</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LogTraceVisEvent</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>S_RESET</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ResetJITImpl</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ResetJIT</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>reason</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ResetJITImpl(cx)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>FlushJITCache</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>TrashTree</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>)</parameter_list>;</function_decl>

<template>template <parameter_list>&lt;<param><type><name>class</name></type> <name>T</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>T</name>&amp;</type>
<name>InitConst</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>T</name> &amp;</type><name>t</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>const_cast</name><argument_list>&lt;<argument><expr><name>T</name> &amp;</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function></template>

<macro><name>JS_REQUIRES_STACK</name></macro>
<constructor><name><name>TraceRecorder</name>::<name>TraceRecorder</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>anchor</name></decl></param>, <param><decl><type><name>VMFragment</name>*</type> <name>fragment</name></decl></param>,
                             <param><decl><type><name>unsigned</name></type> <name>stackSlots</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ngslots</name></decl></param>, <param><decl><type><name>TraceType</name>*</type> <name>typeMap</name></decl></param>,
                             <param><decl><type><name>VMSideExit</name>*</type> <name>innermost</name></decl></param>, <param><decl><type><name>jsbytecode</name>*</type> <name>outer</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>outerArgc</name></decl></param>,
                             <param><decl><type><name>RecordReason</name></type> <name>recordReason</name></decl></param>)</parameter_list>
  <member_list>: <call><name>cx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>,
    <call><name>traceMonitor</name><argument_list>(<argument><expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>fragment</name><argument_list>(<argument><expr><name>fragment</name></expr></argument>)</argument_list></call>,
    <call><name>tree</name><argument_list>(<argument><expr><name><name>fragment</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call>,
    <call><name>recordReason</name><argument_list>(<argument><expr><name>recordReason</name></expr></argument>)</argument_list></call>,
    <call><name>globalObj</name><argument_list>(<argument><expr><name><name>tree</name>-&gt;<name>globalObj</name></name></expr></argument>)</argument_list></call>,
    <call><name>outer</name><argument_list>(<argument><expr><name>outer</name></expr></argument>)</argument_list></call>,
    <call><name>outerArgc</name><argument_list>(<argument><expr><name>outerArgc</name></expr></argument>)</argument_list></call>,
    <call><name>lexicalBlock</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>blockChain</name></name></expr></argument>)</argument_list></call>,
    <call><name>anchor</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call>,
    <call><name>lir</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>cx_ins</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>eos_ins</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>eor_ins</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>loopLabel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>importTypeMap</name><argument_list>(<argument><expr>&amp;<call><name>tempAlloc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>lirbuf</name><argument_list>(<argument><expr>new (<call><name>tempAlloc</name><argument_list>()</argument_list></call>) <call><name>LirBuffer</name><argument_list>(<argument><expr><call><name>tempAlloc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>mark</name><argument_list>(<argument><expr>*<name><name>traceMonitor</name>-&gt;<name>traceAlloc</name></name></expr></argument>)</argument_list></call>,
    <call><name>numSideExitsBefore</name><argument_list>(<argument><expr><call><name><name>tree</name>-&gt;<name>sideExits</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>tracker</name><argument_list>()</argument_list></call>,
    <call><name>nativeFrameTracker</name><argument_list>()</argument_list></call>,
    <call><name>global_dslots</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>callDepth</name><argument_list>(<argument><expr><name>anchor</name> ? <name><name>anchor</name>-&gt;<name>calldepth</name></name> : 0</expr></argument>)</argument_list></call>,
    <call><name>atoms</name><argument_list>(<argument><expr><call><name>FrameAtomBase</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>cfgMerges</name><argument_list>(<argument><expr>&amp;<call><name>tempAlloc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>trashSelf</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call>,
    <call><name>whichTreesToTrash</name><argument_list>(<argument><expr>&amp;<call><name>tempAlloc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>guardedShapeTable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>,
    <call><name>rval_ins</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>native_rval_ins</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>newobj_ins</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>pendingSpecializedNative</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>pendingUnboxSlot</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>pendingGuardCondition</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>pendingLoop</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call>,
    <call><name>generatedSpecializedNative</name><argument_list>()</argument_list></call>,
    <call><name>tempTypeMap</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>
</member_list><block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>globalObj</name> == <call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getGlobal</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == (<name>jsbytecode</name>*)<name><name>fragment</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>fragment</name>-&gt;<name>lirbuf</name></name> = <name>lirbuf</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>lirbuf</name>-&gt;<name>printer</name></name> = new (<call><name>tempAlloc</name><argument_list>()</argument_list></call>) <call><name>LInsPrinter</name><argument_list>(<argument><expr><call><name>tempAlloc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Reset the fragment state we care about in case we got a recycled
     * fragment.  This includes resetting any profiling data we might have
     * accumulated.
     */</comment>
    <expr_stmt><expr><name><name>fragment</name>-&gt;<name>lastIns</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>fragment</name>-&gt;<name>setCode</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fragment</name>-&gt;<name>lirbuf</name></name> = <name>lirbuf</name></expr>;</expr_stmt>
    <macro><name>verbose_only</name><argument_list>( <argument>fragment-&gt;profCount = 0;</argument> )</argument_list></macro>
    <macro><name>verbose_only</name><argument_list>( <argument>fragment-&gt;nStaticExits = 0;</argument> )</argument_list></macro>
    <macro><name>verbose_only</name><argument_list>( <argument>fragment-&gt;nCodeBytes = 0;</argument> )</argument_list></macro>
    <macro><name>verbose_only</name><argument_list>( <argument>fragment-&gt;nExitBytes = 0;</argument> )</argument_list></macro>
    <macro><name>verbose_only</name><argument_list>( <argument>fragment-&gt;guardNumberer = 1;</argument> )</argument_list></macro>
    <macro><name>verbose_only</name><argument_list>( <argument>fragment-&gt;guardsForFrag = NULL;</argument> )</argument_list></macro>
    <macro><name>verbose_only</name><argument_list>( <argument>fragment-&gt;loopLabel = NULL;</argument> )</argument_list></macro>

    <comment type="block">/*
     * Don't change fragment-&gt;profFragID, though.  Once the identity of the
     * Fragment is set up (for profiling purposes), we can't change it.
     */</comment>

    <if>if <condition>(<expr>!<call><name><name>guardedShapeTable</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMMinimal</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMMinimal</name></expr></argument>, <argument><expr>"Recording starting from %s:%u@%u (FragID=%06u)\n"</expr></argument>,
                      <argument><expr><name><name>tree</name>-&gt;<name>treeFileName</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>treeLineNumber</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>treePCOffset</name></name></expr></argument>,
                      <argument><expr><name><name>fragment</name>-&gt;<name>profFragID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"globalObj=%p, shape=%d\n"</expr></argument>,
                      <argument><expr>(<name>void</name>*)<name><name>this</name>-&gt;<name>globalObj</name></name></expr></argument>, <argument><expr><call><name>OBJ_SHAPE</name><argument_list>(<argument><expr><name><name>this</name>-&gt;<name>globalObj</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"TREEVIS RECORD FRAG=%p ANCHOR=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>fragment</name></expr></argument>,
                      <argument><expr>(<name>void</name>*)<name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name><name>nanojit</name>::<name>LirWriter</name></name>*&amp;</type> <name>lir</name> <init>= <expr><call><name>InitConst</name><argument_list>(<argument><expr><name><name>this</name>-&gt;<name>lir</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>lir</name> = new (<call><name>tempAlloc</name><argument_list>()</argument_list></call>) <call><name>LirBufWriter</name><argument_list>(<argument><expr><name>lirbuf</name></expr></argument>, <argument><expr><name><name>nanojit</name>::<name>AvmCore</name>::<name>config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>ValidateWriter</name>*</type> <name>validate2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>lir</name> = <name>validate2</name> =
        new (<call><name>tempAlloc</name><argument_list>()</argument_list></call>) <call><name>ValidateWriter</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>printer</name></name></expr></argument>, <argument><expr>"end of writer pipeline"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <macro><name>debug_only_stmt</name><argument_list>(
        <argument>if (LogController.lcbits &amp; LC_TMRecorder) {
           lir = new (tempAlloc()) VerboseWriter(tempAlloc(), lir, lirbuf-&gt;printer,
                                               &amp;LogController);
        }</argument>
    )</argument_list></macro>
    <comment type="line">// CseFilter must be downstream of SoftFloatFilter (see bug 527754 for why).</comment>
    <if>if <condition>(<expr><name><name>avmplus</name>::<name>AvmCore</name>::<name>config</name>.<name>cseopt</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>lir</name> = new (<call><name>tempAlloc</name><argument_list>()</argument_list></call>) <call><name>CseFilter</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><call><name>tempAlloc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NJ_SOFTFLOAT_SUPPORTED</name></expr></cpp:if>
    <if>if <condition>(<expr><name><name>nanojit</name>::<name>AvmCore</name>::<name>config</name>.<name>soft_float</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>lir</name> = new (<call><name>tempAlloc</name><argument_list>()</argument_list></call>) <call><name>SoftFloatFilter</name><argument_list>(<argument><expr><name>lir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>lir</name> = new (<call><name>tempAlloc</name><argument_list>()</argument_list></call>) <call><name>ExprFilter</name><argument_list>(<argument><expr><name>lir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lir</name> = new (<call><name>tempAlloc</name><argument_list>()</argument_list></call>) <call><name>FuncFilter</name><argument_list>(<argument><expr><name>lir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>ValidateWriter</name>*</type> <name>validate1</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>lir</name> = <name>validate1</name> =
        new (<call><name>tempAlloc</name><argument_list>()</argument_list></call>) <call><name>ValidateWriter</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>printer</name></name></expr></argument>, <argument><expr>"start of writer pipeline"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NumSavedRegs</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insParam</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NumSavedRegs</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <expr_stmt><expr><call><name>addName</name><argument_list>(<argument><expr><name><name>lirbuf</name>-&gt;<name>savedRegs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>regNames</name><index>[<expr><name><name>Assembler</name>::<name>savedRegs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>lirbuf</name>-&gt;<name>state</name></name> = <call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insParam</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>fragment</name> == <name><name>fragment</name>-&gt;<name>root</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>InitConst</name><argument_list>(<argument><expr><name>loopLabel</name></expr></argument>)</argument_list></call> = <call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// if profiling, drop a label, so the assembler knows to put a</comment>
    <comment type="line">// frag-entry-counter increment at this point.  If there's a</comment>
    <comment type="line">// loopLabel, use that; else we'll have to make a dummy label</comment>
    <comment type="line">// especially for this purpose.</comment>
    <macro><name>verbose_only</name><argument_list>( <argument>if (LogController.lcbits &amp; LC_FragProfile) {
        LIns* entryLabel = NULL;
        if (fragment == fragment-&gt;root) {
            entryLabel = loopLabel;
        } else {
            entryLabel = lir-&gt;ins0(LIR_label);
        }
        NanoAssert(entryLabel);
        NanoAssert(!fragment-&gt;loopLabel);
        fragment-&gt;loopLabel = entryLabel;
    }</argument>)</argument_list></macro>

    <expr_stmt><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name> =
        <call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"sp"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lirbuf</name>-&gt;<name>rp</name></name> =
        <call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"rp"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitConst</name><argument_list>(<argument><expr><name>cx_ins</name></expr></argument>)</argument_list></call> =
        <call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"cx"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitConst</name><argument_list>(<argument><expr><name>eos_ins</name></expr></argument>)</argument_list></call> =
        <call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>eos</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"eos"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitConst</name><argument_list>(<argument><expr><name>eor_ins</name></expr></argument>)</argument_list></call> =
        <call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>eor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"eor"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="line">// Need to set these up before any stack/rstack loads/stores occur.</comment>
    <expr_stmt><expr><call><name><name>validate1</name>-&gt;<name>setSp</name></name><argument_list>(<argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>validate2</name>-&gt;<name>setSp</name></name><argument_list>(<argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>validate1</name>-&gt;<name>setRp</name></name><argument_list>(<argument><expr><name><name>lirbuf</name>-&gt;<name>rp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>validate2</name>-&gt;<name>setRp</name></name><argument_list>(<argument><expr><name><name>lirbuf</name>-&gt;<name>rp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If we came from exit, we might not have enough global types. */</comment>
    <if>if <condition>(<expr><call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> &gt; <call><name><name>tree</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SpecializeTreesToMissingGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* read into registers all values on the stack and all globals we know so far */</comment>
    <expr_stmt><expr><call><name>import</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>, <argument><expr><name>stackSlots</name></expr></argument>, <argument><expr><name>ngslots</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><name>typeMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Finish handling RECURSIVE_SLURP_FAIL_EXIT in startRecorder. */</comment>
    <if>if <condition>(<expr><name>anchor</name> &amp;&amp; <name><name>anchor</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_SLURP_FAIL_EXIT</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <if>if <condition>(<expr><name>fragment</name> == <name><name>fragment</name>-&gt;<name>root</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * We poll the operation callback request flag. It is updated asynchronously whenever
         * the callback is to be invoked.
         */</comment>
        <comment type="line">// XXX: this load is volatile.  If bug 545406 (loop-invariant code</comment>
        <comment type="line">// hoisting) is implemented this fact will need to be made explicit.</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name> <init>=
            <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>cx_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSContext</name></expr></argument>, <argument><expr><name>operationCallbackFlag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_LOAD_ANY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>TIMEOUT_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * If we are attached to a tree call guard, make sure the guard the inner
     * tree exited from is what we expect it to be.
     */</comment>
    <if>if <condition>(<expr><name>anchor</name> &amp;&amp; <name><name>anchor</name>-&gt;<name>exitType</name></name> == <name>NESTED_EXIT</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>nested_ins</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>,
                                                <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>outermostTreeExitGuard</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"outermostTreeExitGuard"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>nested_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>innermost</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NESTED_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></constructor>

<destructor><name><name>TraceRecorder</name>::~<name>TraceRecorder</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/* Should already have been adjusted by callers before calling delete. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>traceMonitor</name>-&gt;<name>recorder</name></name> != <name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>trashSelf</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>TrashTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>fragment</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <for>for (<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>whichTreesToTrash</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>TrashTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>whichTreesToTrash</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

    <comment type="block">/* Purge the tempAlloc used during recording. */</comment>
    <expr_stmt><expr><call><name>tempAlloc</name><argument_list>()</argument_list></call>.<call><name>reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>forgetGuardedShapes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><specifier>inline</specifier> <name>bool</name></type>
<name><name>TraceMonitor</name>::<name>outOfMemory</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
    <return>return <expr><call><name><name>dataAlloc</name>-&gt;<name>outOfMemory</name></name><argument_list>()</argument_list></call> ||
           <call><name><name>tempAlloc</name>-&gt;<name>outOfMemory</name></name><argument_list>()</argument_list></call> ||
           <call><name><name>traceAlloc</name>-&gt;<name>outOfMemory</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function destroys the recorder after a successful recording, possibly
 * starting a suspended outer recorder.
 */</comment>
<function><type><name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>finishSuccessfully</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>traceMonitor</name>-&gt;<name>recorder</name></name> == <name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>fragment</name>-&gt;<name>lastIns</name></name> &amp;&amp; <call><name><name>fragment</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>traceCompleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mark</name>.<name>commit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Grab local copies of members needed after |delete this|. */</comment>
    <decl_stmt><decl><type><name>JSContext</name>*</type> <name>localcx</name> <init>= <expr><name>cx</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>localtm</name> <init>= <expr><name>traceMonitor</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>localtm</name>-&gt;<name>recorder</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr>delete <name>this</name></expr>;</expr_stmt>

    <comment type="block">/* Catch OOM that occurred during recording. */</comment>
    <if>if <condition>(<expr><call><name><name>localtm</name>-&gt;<name>outOfMemory</name></name><argument_list>()</argument_list></call> || <call><name>OverfullJITCache</name><argument_list>(<argument><expr><name>localtm</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>localcx</name></expr></argument>, <argument><expr><name>FR_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>ARECORD_COMPLETED</name></expr>;</return>
}</block></function>

<comment type="block">/* This function aborts a recorder and any pending outer recorders. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>finishAbort</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>reason</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>traceMonitor</name>-&gt;<name>recorder</name></name> == <name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>fragment</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>recorderAborted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMAbort</name></expr></argument>,
                      <argument><expr>"Abort recording of tree %s:%d@%d at %s:%d@%d: %s.\n"</expr></argument>,
                      <argument><expr><name><name>tree</name>-&gt;<name>treeFileName</name></name></expr></argument>,
                      <argument><expr><name><name>tree</name>-&gt;<name>treeLineNumber</name></name></expr></argument>,
                      <argument><expr><name><name>tree</name>-&gt;<name>treePCOffset</name></name></expr></argument>,
                      <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></argument>,
                      <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>Backoff</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>*) <name><name>fragment</name>-&gt;<name>root</name>-&gt;<name>ip</name></name></expr></argument>, <argument><expr><name><name>fragment</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If this is the primary trace and we didn't succeed compiling, trash the
     * tree. Otherwise, remove the VMSideExits we added while recording, which
     * are about to be invalid.
     *
     * BIG FAT WARNING: resetting the length is only a valid strategy as long as
     * there may be only one recorder active for a single TreeInfo at a time.
     * Otherwise, we may be throwing away another recorder's valid side exits.
     */</comment>
    <if>if <condition>(<expr><name><name>fragment</name>-&gt;<name>root</name></name> == <name>fragment</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>TrashTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>fragment</name>-&gt;<name>toTreeFragment</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>numSideExitsBefore</name> &lt;= <call><name><name>fragment</name>-&gt;<name>root</name>-&gt;<name>sideExits</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>fragment</name>-&gt;<name>root</name>-&gt;<name>sideExits</name>.<name>setLength</name></name><argument_list>(<argument><expr><name>numSideExitsBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Grab local copies of members needed after |delete this|. */</comment>
    <decl_stmt><decl><type><name>JSContext</name>*</type> <name>localcx</name> <init>= <expr><name>cx</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>localtm</name> <init>= <expr><name>traceMonitor</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>localtm</name>-&gt;<name>recorder</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr>delete <name>this</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>localtm</name>-&gt;<name>outOfMemory</name></name><argument_list>()</argument_list></call> || <call><name>OverfullJITCache</name><argument_list>(<argument><expr><name>localtm</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>localcx</name></expr></argument>, <argument><expr><name>FR_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
}</block></function>

<comment type="block">/* Add debug information to a LIR instruction as we emit it. */</comment>
<function><type><specifier>inline</specifier> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>addName</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>ins</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>name</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
    <comment type="block">/*
     * We'll only ask for verbose Nanojit when .lcbits &gt; 0, so there's no point
     * in adding names otherwise.
     */</comment>
    <if>if <condition>(<expr><name><name>LogController</name>.<name>lcbits</name></name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name><name>lirbuf</name>-&gt;<name>printer</name>-&gt;<name>lirNameMap</name>-&gt;<name>addName</name></name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>ins</name></expr>;</return>
}</block></function>

<function><type><specifier>inline</specifier> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>insImmVal</name></name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>val</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>JSVAL_IS_TRACEABLE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>gcthings</name>.<name>addUnique</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insImmWord</name></name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>inline</specifier> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>insImmObj</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>gcthings</name>.<name>addUnique</name></name><argument_list>(<argument><expr><call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insImmPtr</name></name><argument_list>(<argument><expr>(<name>void</name>*)<name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>inline</specifier> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>insImmFun</name></name><parameter_list>(<param><decl><type><name>JSFunction</name>*</type> <name>fun</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>gcthings</name>.<name>addUnique</name></name><argument_list>(<argument><expr><call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insImmPtr</name></name><argument_list>(<argument><expr>(<name>void</name>*)<name>fun</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>inline</specifier> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>insImmStr</name></name><parameter_list>(<param><decl><type><name>JSString</name>*</type> <name>str</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>gcthings</name>.<name>addUnique</name></name><argument_list>(<argument><expr><call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insImmPtr</name></name><argument_list>(<argument><expr>(<name>void</name>*)<name>str</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>inline</specifier> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>insImmSprop</name></name><parameter_list>(<param><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>sprops</name>.<name>addUnique</name></name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insImmPtr</name></name><argument_list>(<argument><expr>(<name>void</name>*)<name>sprop</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>inline</specifier> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>p2i</name></name><parameter_list>(<param><decl><type><name><name>nanojit</name>::<name>LIns</name></name>*</type> <name>ins</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NANOJIT_64BIT</name></cpp:ifdef>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_q2i</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>ins</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>ptrdiff_t</name></type>
<name><name>TraceRecorder</name>::<name>nativeGlobalSlot</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isGlobal</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>size_t</name><argument_list>(<argument><expr><name>p</name> - <name><name>globalObj</name>-&gt;<name>fslots</name></name></expr></argument>)</argument_list></call> &lt; <name>JS_INITIAL_NSLOTS</name></expr>)</condition><then>
        <return>return <expr><call><name>ptrdiff_t</name><argument_list>(<argument><expr><name>p</name> - <name><name>globalObj</name>-&gt;<name>fslots</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><call><name>ptrdiff_t</name><argument_list>(<argument><expr>(<name>p</name> - <name><name>globalObj</name>-&gt;<name>dslots</name></name>) + <name>JS_INITIAL_NSLOTS</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Determine the offset in the native global frame for a jsval we track. */</comment>
<function><type><name>ptrdiff_t</name></type>
<name><name>TraceRecorder</name>::<name>nativeGlobalOffset</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <return>return <expr><call><name>nativeGlobalSlot</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block></function>

<comment type="block">/* Determine whether a value is a global stack slot. */</comment>
<function><type><name>bool</name></type>
<name><name>TraceRecorder</name>::<name>isGlobal</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <return>return <expr>((<call><name>size_t</name><argument_list>(<argument><expr><name>p</name> - <name><name>globalObj</name>-&gt;<name>fslots</name></name></expr></argument>)</argument_list></call> &lt; <name>JS_INITIAL_NSLOTS</name>) ||
            (<call><name>size_t</name><argument_list>(<argument><expr><name>p</name> - <name><name>globalObj</name>-&gt;<name>dslots</name></name></expr></argument>)</argument_list></call> &lt; (<call><name><name>globalObj</name>-&gt;<name>numSlots</name></name><argument_list>()</argument_list></call> - <name>JS_INITIAL_NSLOTS</name>)))</expr>;</return>
}</block></function>

<comment type="block">/*
 * Return the offset in the native stack for the given jsval. More formally,
 * |p| must be the address of a jsval that is represented in the native stack
 * area. The return value is the offset, from InterpState::stackBase, in bytes,
 * where the native representation of |*p| is stored. To get the offset
 * relative to InterpState::sp, subtract TreeFragment::nativeStackBase.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>ptrdiff_t</name></type>
<name><name>TraceRecorder</name>::<name>nativeStackOffset</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <function_decl><type><name>CountSlotsVisitor</name></type> <name>visitor</name><parameter_list>(<param><decl><type><name>p</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><call><name><name>visitor</name>.<name>count</name></name><argument_list>()</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If it's not in a pending frame, it must be on the stack of the current
     * frame above sp but below fp-&gt;slots + script-&gt;nslots.
     */</comment>
    <if>if <condition>(<expr>!<call><name><name>visitor</name>.<name>stopped</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name>p</name> - <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name></name></expr></argument>)</argument_list></call> &lt; <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>nslots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> += <call><name>size_t</name><argument_list>(<argument><expr><name>p</name> - <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>offset</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>ptrdiff_t</name></type>
<name><name>TraceRecorder</name>::<name>nativeStackSlot</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <return>return <expr><call><name>nativeStackOffset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> / <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block></function>

<comment type="block">/*
 * Return the offset, from InterpState:sp, for the given jsval. Shorthand for:
 *  -TreeFragment::nativeStackBase + nativeStackOffset(p).
 */</comment>
<function><type><specifier>inline</specifier> <name>JS_REQUIRES_STACK</name> <name>ptrdiff_t</name></type>
<name><name>TraceRecorder</name>::<name>nativespOffset</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list> <specifier>const</specifier>
<block>{
    <return>return <expr>-<name><name>tree</name>-&gt;<name>nativeStackBase</name></name> + <call><name>nativeStackOffset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Track the maximum number of native frame slots we need during execution. */</comment>
<function><type><specifier>inline</specifier> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>trackNativeStackUse</name></name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>slots</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>slots</name> &gt; <name><name>tree</name>-&gt;<name>maxNativeStackSlots</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tree</name>-&gt;<name>maxNativeStackSlots</name></name> = <name>slots</name></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/*
 * Unbox a jsval into a slot. Slots are wide enough to hold double values
 * directly (instead of storing a pointer to them). We assert instead of
 * type checking. The caller must ensure the types are compatible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ValueToNative</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>, <param><decl><type><name>TraceType</name></type> <name>type</name></decl></param>, <param><decl><type><name>double</name>*</type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>tag</name> <init>= <expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
      <case>case <expr><name>TT_OBJECT</name></expr>:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>JSObject</name>**)<name>slot</name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"object&lt;%p:%s&gt; "</expr></argument>, <argument><expr>(<name>void</name>*)<call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>
                          ? "null"
                          : <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<call><name>getClass</name><argument_list>()</argument_list></call>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>

      </case><case>case <expr><name>TT_INT32</name></expr>:
        <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*(<name>jsint</name>*)<name>slot</name> = <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>tag</name> == <name>JSVAL_DOUBLE</name> &amp;&amp; <call><name>JSDOUBLE_IS_INT</name><argument_list>(<argument><expr>*<call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*(<name>jsint</name>*)<name>slot</name> = <name>i</name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"int&lt;%d&gt; "</expr></argument>, <argument><expr>*(<name>jsint</name>*)<name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>

      </case><case>case <expr><name>TT_DOUBLE</name></expr>:
        <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>d</name> = <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>d</name> = *<call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || <call><name>JSVAL_IS_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>jsdouble</name>*)<name>slot</name> = <name>d</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"double&lt;%g&gt; "</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>

      </case><case>case <expr><name>TT_JSVAL</name></expr>:
        <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"found jsval type in an entry type map"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>

      </case><case>case <expr><name>TT_STRING</name></expr>:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>JSString</name>**)<name>slot</name> = <call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"string&lt;%p&gt; "</expr></argument>, <argument><expr>(<name>void</name>*)(*(<name>JSString</name>**)<name>slot</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>

      </case><case>case <expr><name>TT_NULL</name></expr>:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>JSObject</name>**)<name>slot</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"null "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>

      </case><case>case <expr><name>TT_SPECIAL</name></expr>:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL_SPECIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>JSBool</name>*)<name>slot</name> = <call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"special&lt;%d&gt; "</expr></argument>, <argument><expr>*(<name>JSBool</name>*)<name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>

      </case><case>case <expr><name>TT_VOID</name></expr>:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>JSBool</name>*)<name>slot</name> = <call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>JSVAL_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"undefined "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>

      </case><case>case <expr><name>TT_FUNCTION</name></expr>: <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tag</name> == <name>JSVAL_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*(<name>JSObject</name>**)<name>slot</name> = <name>obj</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name> <init>= <expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"function&lt;%p:%s&gt; "</expr></argument>, <argument><expr>(<name>void</name>*) <name>obj</name></expr></argument>,
                          <argument><expr><name><name>fun</name>-&gt;<name>atom</name></name>
                          ? <call><name>JS_GetStringBytes</name><argument_list>(<argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>fun</name>-&gt;<name>atom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                          : "unnamed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return;</return>
      }</block>
      </case><default>default:
        <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"unexpected type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceMonitor</name>::<name>flush</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/* flush should only be called after all recorders have been aborted. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>recorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>cacheFlushed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// recover profiling data from expiring Fragments</comment>
    <macro><name>verbose_only</name><argument_list>(
        <argument>for (size_t i = 0; i &lt; FRAGMENT_TABLE_SIZE; ++i) {
            for (TreeFragment *f = vmfragments[i]; f; f = f-&gt;next) {
                JS_ASSERT(f-&gt;root == f);
                for (TreeFragment *p = f; p; p = p-&gt;peer)
                    FragProfiling_FragFinalizer(p, this);
            }
        }</argument>
    )</argument_list></macro>

    <macro><name>verbose_only</name><argument_list>(
        <argument>for (Seq&lt;Fragment*&gt;* f = branches; f; f = f-&gt;tail)
            FragProfiling_FragFinalizer(f-&gt;head, this);</argument>
    )</argument_list></macro>

    <expr_stmt><expr><call><name><name>frameCache</name>-&gt;<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>dataAlloc</name>-&gt;<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>traceAlloc</name>-&gt;<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>codeAlloc</name>-&gt;<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>tempAlloc</name>-&gt;<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>reTempAlloc</name>-&gt;<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Allocator</name>&amp;</type> <name>alloc</name> <init>= <expr>*<name>dataAlloc</name></expr></init></decl>;</decl_stmt>

    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>MONITOR_N_GLOBAL_STATES</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><name><name>globalStates</name><index>[<expr><name>i</name></expr>]</index></name>.<name>globalShape</name> = -1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>globalStates</name><index>[<expr><name>i</name></expr>]</index></name>.<name>globalSlots</name> = new (<name>alloc</name>) <call><name>SlotList</name><argument_list>(<argument><expr>&amp;<name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><name>assembler</name> = new (<name>alloc</name>) <call><name>Assembler</name><argument_list>(<argument><expr>*<name>codeAlloc</name></expr></argument>, <argument><expr><name>alloc</name></expr></argument>, <argument><expr><name>alloc</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr>&amp;<name>LogController</name></expr></argument>, <argument><expr><name><name>avmplus</name>::<name>AvmCore</name>::<name>config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>verbose_only</name><argument_list>( <argument>branches = NULL;</argument> )</argument_list></macro>

    <expr_stmt><expr><call><name>PodArrayZero</name><argument_list>(<argument><expr><name>vmfragments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reFragments</name> = new (<name>alloc</name>) <call><name>REHashMap</name><argument_list>(<argument><expr><name>alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>needFlush</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>MarkTree</name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>, <param><decl><type><name>TreeFragment</name> *</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name> <init>= <expr><call><name><name>f</name>-&gt;<name>gcthings</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name> <init>= <expr><call><name><name>f</name>-&gt;<name>gcthings</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>len</name>--</expr>)</condition> <block>{
        <decl_stmt><decl><type><name>jsval</name></type> <name>v</name> <init>= <expr>*<name>vp</name>++</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_SET_TRACING_NAME</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>"jitgcthing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_CallGCMarker</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_TRACEABLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>JSVAL_TRACE_KIND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <decl_stmt><decl><type><name>JSScopeProperty</name>**</type> <name>spropp</name> <init>= <expr><call><name><name>f</name>-&gt;<name>sprops</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>len</name> = <call><name><name>f</name>-&gt;<name>sprops</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>len</name>--</expr>)</condition> <block>{
        <decl_stmt><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name> <init>= <expr>*<name>spropp</name>++</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>sprop</name>-&gt;<name>trace</name></name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceMonitor</name>::<name>mark</name></name><parameter_list>(<param><decl><type><name>JSTracer</name>*</type> <name>trc</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name><name>trc</name>-&gt;<name>context</name>-&gt;<name>runtime</name>-&gt;<name>gcFlushCodeCaches</name></name></expr>)</condition><then> <block>{
        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>FRAGMENT_TABLE_SIZE</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>f</name> <init>= <expr><name><name>vmfragments</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>f</name></expr>)</condition> <block>{
                <if>if <condition>(<expr><call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>MarkTree</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>peer</name> <init>= <expr><name><name>f</name>-&gt;<name>peer</name></name></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><name>peer</name></expr>)</condition> <block>{
                    <if>if <condition>(<expr><call><name><name>peer</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><call><name>MarkTree</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><name>peer</name> = <name><name>peer</name>-&gt;<name>peer</name></name></expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><name>f</name> = <name><name>f</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            }</block></while>
        }</block></for>
        <if>if <condition>(<expr><name>recorder</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MarkTree</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><call><name><name>recorder</name>-&gt;<name>getTree</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Box a value from the native stack back into the jsval format. Integers that
 * are too large to fit into a jsval are automatically boxed into
 * heap-allocated doubles.
 */</comment>
<function><type><name>bool</name></type>
<name>NativeToValue</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>jsval</name>&amp;</type> <name>v</name></decl></param>, <param><decl><type><name>TraceType</name></type> <name>type</name></decl></param>, <param><decl><type><name>double</name>*</type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
      <case>case <expr><name>TT_OBJECT</name></expr>:
        <expr_stmt><expr><name>v</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr>*(<name>JSObject</name>**)<name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>v</name> != <name>JSVAL_ERROR_COOKIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* don't leak JSVAL_ERROR_COOKIE */</comment>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"object&lt;%p:%s&gt; "</expr></argument>, <argument><expr>(<name>void</name>*)<call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>
                          ? "null"
                          : <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<call><name>getClass</name><argument_list>()</argument_list></call>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TT_INT32</name></expr>:
        <expr_stmt><expr><name>i</name> = *(<name>jsint</name>*)<name>slot</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"int&lt;%d&gt; "</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <label><name>store_int</name>:</label>
        <if>if <condition>(<expr><call><name>INT_FITS_IN_JSVAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>v</name> = <call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>d</name> = (<name>jsdouble</name>)<name>i</name></expr>;</expr_stmt>
        <goto>goto <name>store_double</name>;</goto>
      </case><case>case <expr><name>TT_DOUBLE</name></expr>:
        <expr_stmt><expr><name>d</name> = *<name>slot</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"double&lt;%g&gt; "</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>JSDOUBLE_IS_INT</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>store_int</name>;</goto></then></if>
      <label><name>store_double</name>:</label>
        <expr_stmt><expr><name>ok</name> = <call><name>js_NewDoubleInRootedValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <return>return <expr>true</expr>;</return>

      </case><case>case <expr><name>TT_JSVAL</name></expr>:
        <expr_stmt><expr><name>v</name> = *(<name>jsval</name>*)<name>slot</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>v</name> != <name>JSVAL_ERROR_COOKIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* don't leak JSVAL_ERROR_COOKIE */</comment>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"box&lt;%p&gt; "</expr></argument>, <argument><expr>(<name>void</name>*)<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TT_STRING</name></expr>:
        <expr_stmt><expr><name>v</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr>*(<name>JSString</name>**)<name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"string&lt;%p&gt; "</expr></argument>, <argument><expr>(<name>void</name>*)(*(<name>JSString</name>**)<name>slot</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TT_NULL</name></expr>:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*(<name>JSObject</name>**)<name>slot</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name> = <name>JSVAL_NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"null&lt;%p&gt; "</expr></argument>, <argument><expr>(<name>void</name>*)(*(<name>JSObject</name>**)<name>slot</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TT_SPECIAL</name></expr>:
        <expr_stmt><expr><name>v</name> = <call><name>SPECIAL_TO_JSVAL</name><argument_list>(<argument><expr>*(<name>JSBool</name>*)<name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"special&lt;%d&gt; "</expr></argument>, <argument><expr>*(<name>JSBool</name>*)<name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TT_VOID</name></expr>:
        <expr_stmt><expr><name>v</name> = <name>JSVAL_VOID</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"undefined "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TT_FUNCTION</name></expr>: <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr>*(<name>JSObject</name>**)<name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr>*(<name>JSObject</name>**)<name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name> <init>= <expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"function&lt;%p:%s&gt; "</expr></argument>, <argument><expr>(<name>void</name>*)<call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name><name>fun</name>-&gt;<name>atom</name></name>
                          ? <call><name>JS_GetStringBytes</name><argument_list>(<argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>fun</name>-&gt;<name>atom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                          : "unnamed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>
      }</block>
      </case><default>default:
        <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"unexpected type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>
    <return>return <expr>true</expr>;</return>
}</block></function>

<class>class <name>BuildNativeFrameVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>mCx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name> *</type><name>mTypeMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name> *</type><name>mGlobal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name> *</type><name>mStack</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><name>BuildNativeFrameVisitor</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>,
                            <param><decl><type><name>TraceType</name> *</type><name>typemap</name></decl></param>,
                            <param><decl><type><name>double</name> *</type><name>global</name></decl></param>,
                            <param><decl><type><name>double</name> *</type><name>stack</name></decl></param>)</parameter_list> <member_list>:
        <call><name>mCx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>,
        <call><name>mTypeMap</name><argument_list>(<argument><expr><name>typemap</name></expr></argument>)</argument_list></call>,
        <call><name>mGlobal</name><argument_list>(<argument><expr><name>global</name></expr></argument>)</argument_list></call>,
        <call><name>mStack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>visitGlobalSlot</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"global%d: "</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ValueToNative</name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr>*<name>vp</name></expr></argument>, <argument><expr>*<name>mTypeMap</name>++</expr></argument>, <argument><expr>&amp;<name><name>mGlobal</name><index>[<expr><name>slot</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
    <name>visitStackSlots</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>int</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"%s%d: "</expr></argument>, <argument><expr><call><name>stackSlotKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ValueToNative</name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr>*<name>vp</name>++</expr></argument>, <argument><expr>*<name>mTypeMap</name>++</expr></argument>, <argument><expr><name>mStack</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>
</public>}</block>;</class>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name>BuildNativeFrame</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>globalObj</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>,
                 <param><decl><type><name>unsigned</name></type> <name>ngslots</name></decl></param>, <param><decl><type><name>uint16</name> *</type><name>gslots</name></decl></param>,
                 <param><decl><type><name>TraceType</name> *</type><name>typeMap</name></decl></param>, <param><decl><type><name>double</name> *</type><name>global</name></decl></param>, <param><decl><type><name>double</name> *</type><name>stack</name></decl></param>)</parameter_list>
<block>{
    <function_decl><type><name>BuildNativeFrameVisitor</name></type> <name>visitor</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>typeMap</name></type></decl></param>, <param><decl><type><name>global</name></type></decl></param>, <param><decl><type><name>stack</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>VisitSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><name>ngslots</name></expr></argument>, <argument><expr><name>gslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<class>class <name>FlushNativeGlobalFrameVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>mCx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name> *</type><name>mTypeMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name> *</type><name>mGlobal</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><name>FlushNativeGlobalFrameVisitor</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>,
                                  <param><decl><type><name>TraceType</name> *</type><name>typeMap</name></decl></param>,
                                  <param><decl><type><name>double</name> *</type><name>global</name></decl></param>)</parameter_list> <member_list>:
        <call><name>mCx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>,
        <call><name>mTypeMap</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>)</argument_list></call>,
        <call><name>mGlobal</name><argument_list>(<argument><expr><name>global</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>visitGlobalSlot</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"global%d="</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>mCx</name></expr></argument>)</argument_list></call>-&gt;<name>waiveGCQuota</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>NativeToValue</name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr>*<name>vp</name></expr></argument>, <argument><expr>*<name>mTypeMap</name>++</expr></argument>, <argument><expr>&amp;<name><name>mGlobal</name><index>[<expr><name>slot</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>OutOfMemoryAbort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>
</public>}</block>;</class>

<class>class <name>FlushNativeStackFrameVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>mCx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>TraceType</name> *</type><name>mInitTypeMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>TraceType</name> *</type><name>mTypeMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name> *</type><name>mStack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name> *</type><name>mStop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>mIgnoreSlots</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><name>FlushNativeStackFrameVisitor</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>TraceType</name> *</type><name>typeMap</name></decl></param>,
                                 <param><decl><type><name>double</name> *</type><name>stack</name></decl></param>,
                                 <param><decl><type><name>jsval</name> *</type><name>stop</name></decl></param>,
                                 <param><decl><type><name>unsigned</name></type> <name>ignoreSlots</name></decl></param>)</parameter_list> <member_list>:
        <call><name>mCx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>,
        <call><name>mInitTypeMap</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>)</argument_list></call>,
        <call><name>mTypeMap</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>)</argument_list></call>,
        <call><name>mStack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call>,
        <call><name>mStop</name><argument_list>(<argument><expr><name>stop</name></expr></argument>)</argument_list></call>,
        <call><name>mIgnoreSlots</name><argument_list>(<argument><expr><name>ignoreSlots</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><specifier>const</specifier> <name>TraceType</name>*</type> <name>getTypeMap</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>mTypeMap</name></expr>;</return>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
    <name>visitStackSlots</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>mCx</name></expr></argument>)</argument_list></call>-&gt;<name>waiveGCQuota</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name>vp</name> == <name>mStop</name></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
            <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"%s%u="</expr></argument>, <argument><expr><call><name>stackSlotKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>unsigned</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>unsigned</name><argument_list>(<argument><expr><name>mTypeMap</name> - <name>mInitTypeMap</name></expr></argument>)</argument_list></call> &gt;= <name>mIgnoreSlots</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>NativeToValue</name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr>*<name>vp</name></expr></argument>, <argument><expr>*<name>mTypeMap</name></expr></argument>, <argument><expr><name>mStack</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>OutOfMemoryAbort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then></if>
            <expr_stmt><expr><name>vp</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>mTypeMap</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>mStack</name>++</expr>;</expr_stmt>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>
</public>}</block>;</class>

<comment type="block">/* Box the given native frame into a JS frame. This is infallible. */</comment>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name>FlushNativeGlobalFrame</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>globalObj</name></decl></param>, <param><decl><type><name>double</name> *</type><name>global</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ngslots</name></decl></param>,
                       <param><decl><type><name>uint16</name> *</type><name>gslots</name></decl></param>, <param><decl><type><name>TraceType</name> *</type><name>typemap</name></decl></param>)</parameter_list>
<block>{
    <function_decl><type><name>FlushNativeGlobalFrameVisitor</name></type> <name>visitor</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>typemap</name></type></decl></param>, <param><decl><type><name>global</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>VisitGlobalSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>ngslots</name></expr></argument>, <argument><expr><name>gslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Returns the number of values on the native stack, excluding the innermost
 * frame. This walks all FrameInfos on the native frame stack and sums the
 * slot usage of each frame.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>StackDepthFromCallStack</name><parameter_list>(<param><decl><type><name>InterpState</name>*</type> <name>state</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>callDepth</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int32</name></type> <name>nativeStackFramePos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="line">// Duplicate native stack layout computation: see VisitFrameSlots header comment.</comment>
    <for>for (<init><decl><type><name>FrameInfo</name>**</type> <name>fip</name> <init>= <expr><name><name>state</name>-&gt;<name>callstackBase</name></name></expr></init></decl>;</init> <condition><expr><name>fip</name> &lt; <name><name>state</name>-&gt;<name>rp</name></name> + <name>callDepth</name></expr>;</condition> <incr><expr><name>fip</name>++</expr></incr>)
        <expr_stmt><expr><name>nativeStackFramePos</name> += <name>(*<name>fip</name>)-&gt;<name>callerHeight</name></name></expr>;</expr_stmt></for>
    <return>return <expr><name>nativeStackFramePos</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Generic function to read upvars on trace from slots of active frames.
 *     T   Traits type parameter. Must provide static functions:
 *             interp_get(fp, slot)     Read the value out of an interpreter frame.
 *             native_slot(argc, slot)  Return the position of the desired value in the on-trace
 *                                      stack frame (with position 0 being callee).
 *
 *     upvarLevel  Static level of the function containing the upvar definition
 *     slot        Identifies the value to get. The meaning is defined by the traits type.
 *     callDepth   Call depth of current point relative to trace entry
 */</comment>
<template>template<parameter_list>&lt;<param><type><typename>typename</typename></type> <name>T</name></param>&gt;</parameter_list>
<function><type><specifier>inline</specifier> <name>TraceType</name></type>
<name>GetUpvarOnTrace</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>upvarLevel</name></decl></param>, <param><decl><type><name>int32</name></type> <name>slot</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>callDepth</name></decl></param>, <param><decl><type><name>double</name>*</type> <name>result</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>InterpState</name>*</type> <name>state</name> <init>= <expr><name><name>cx</name>-&gt;<name>interpState</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FrameInfo</name>**</type> <name>fip</name> <init>= <expr><name><name>state</name>-&gt;<name>rp</name></name> + <name>callDepth</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * First search the FrameInfo call stack for an entry containing our
     * upvar, namely one with level == upvarLevel. The first FrameInfo is a
     * transition from the entry frame to some callee. However, it is not
     * known (from looking at the FrameInfo) whether the entry frame had a
     * callee. Rather than special-case this or insert more logic into the
     * loop, instead just stop before that FrameInfo (i.e. |&gt; base| instead of
     * |&gt;= base|), and let the code after the loop handle it.
     */</comment>
    <decl_stmt><decl><type><name>int32</name></type> <name>stackOffset</name> <init>= <expr><call><name>StackDepthFromCallStack</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr>--<name>fip</name> &gt; <name><name>state</name>-&gt;<name>callstackBase</name></name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>FrameInfo</name>*</type> <name>fi</name> <init>= <expr>*<name>fip</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * The loop starts aligned to the top of the stack, so move down to the first meaningful
         * callee. Then read the callee directly from the frame.
         */</comment>
        <expr_stmt><expr><name>stackOffset</name> -= <name><name>fi</name>-&gt;<name>callerHeight</name></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>JSObject</name>*</type> <name>callee</name> <init>= <expr>*(<name>JSObject</name>**)(&amp;<name><name>state</name>-&gt;<name>stackBase</name><index>[<expr><name>stackOffset</name></expr>]</index></name>)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name> <init>= <expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callee</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uintN</name></type> <name>calleeLevel</name> <init>= <expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>staticLevel</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>calleeLevel</name> == <name>upvarLevel</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Now find the upvar's value in the native stack. stackOffset is
             * the offset of the start of the activation record corresponding
             * to *fip in the native stack.
             */</comment>
            <decl_stmt><decl><type><name>uint32</name></type> <name>native_slot</name> <init>= <expr><call><name><name>T</name>::<name>native_slot</name></name><argument_list>(<argument><expr><name><name>fi</name>-&gt;<name>callerArgc</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr>*<name>result</name> = <name><name>state</name>-&gt;<name>stackBase</name><index>[<expr><name>stackOffset</name> + <name>native_slot</name></expr>]</index></name></expr>;</expr_stmt>
            <return>return <expr><call><name><name>fi</name>-&gt;<name>get_typemap</name></name><argument_list>()</argument_list></call><index>[<expr><name>native_slot</name></expr>]</index></expr>;</return>
        }</block></then></if>
    }</block></while>

    <comment type="line">// Next search the trace entry frame, which is not in the FrameInfo stack.</comment>
    <if>if <condition>(<expr><name><name>state</name>-&gt;<name>outermostTree</name>-&gt;<name>script</name>-&gt;<name>staticLevel</name></name> == <name>upvarLevel</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>uint32</name></type> <name>argc</name> <init>= <expr><name><name>state</name>-&gt;<name>outermostTree</name>-&gt;<name>argc</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>native_slot</name> <init>= <expr><call><name><name>T</name>::<name>native_slot</name></name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*<name>result</name> = <name><name>state</name>-&gt;<name>stackBase</name><index>[<expr><name>native_slot</name></expr>]</index></name></expr>;</expr_stmt>
        <return>return <expr><name><name>state</name>-&gt;<name>callstackBase</name><index>[<expr>0</expr>]</index></name>-&gt;<call><name>get_typemap</name><argument_list>()</argument_list></call><index>[<expr><name>native_slot</name></expr>]</index></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * If we did not find the upvar in the frames for the active traces,
     * then we simply get the value from the interpreter state.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>upvarLevel</name> &lt; <name>JS_DISPLAY_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>display</name><index>[<expr><name>upvarLevel</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name> <init>= <expr><call><name><name>T</name>::<name>interp_get</name></name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name></type> <name>type</name> <init>= <expr><call><name>getCoercedType</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ValueToNative</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>type</name></expr>;</return>
}</block></function></template>

<comment type="line">// For this traits type, 'slot' is the argument index, which may be -2 for callee.</comment>
<struct>struct <name>UpvarArgTraits</name> <block>{<public type="default">
    <function><type><specifier>static</specifier> <name>jsval</name></type> <name>interp_get</name><parameter_list>(<param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>, <param><decl><type><name>int32</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name><name>fp</name>-&gt;<name>argv</name><index>[<expr><name>slot</name></expr>]</index></name></expr>;</return>
    }</block></function>

    <function><type><specifier>static</specifier> <name>uint32</name></type> <name>native_slot</name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>, <param><decl><type><name>int32</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>2 <comment type="block">/*callee,this*/</comment> + <name>slot</name></expr>;</return>
    }</block></function>
</public>}</block>;</struct>

<function><type><name>uint32</name> <name>JS_FASTCALL</name></type>
<name>GetUpvarArgOnTrace</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>upvarLevel</name></decl></param>, <param><decl><type><name>int32</name></type> <name>slot</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>callDepth</name></decl></param>, <param><decl><type><name>double</name>*</type> <name>result</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>GetUpvarOnTrace</name><argument_list>&lt;<argument><expr><name>UpvarArgTraits</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>upvarLevel</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// For this traits type, 'slot' is an index into the local slots array.</comment>
<struct>struct <name>UpvarVarTraits</name> <block>{<public type="default">
    <function><type><specifier>static</specifier> <name>jsval</name></type> <name>interp_get</name><parameter_list>(<param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>, <param><decl><type><name>int32</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name><name>fp</name>-&gt;<name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr>;</return>
    }</block></function>

    <function><type><specifier>static</specifier> <name>uint32</name></type> <name>native_slot</name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>, <param><decl><type><name>int32</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>4 <comment type="block">/*callee,this,arguments,scopeChain*/</comment> + <name>argc</name> + <name>slot</name></expr>;</return>
    }</block></function>
</public>}</block>;</struct>

<function><type><name>uint32</name> <name>JS_FASTCALL</name></type>
<name>GetUpvarVarOnTrace</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>upvarLevel</name></decl></param>, <param><decl><type><name>int32</name></type> <name>slot</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>callDepth</name></decl></param>, <param><decl><type><name>double</name>*</type> <name>result</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>GetUpvarOnTrace</name><argument_list>&lt;<argument><expr><name>UpvarVarTraits</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>upvarLevel</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * For this traits type, 'slot' is an index into the stack area (within slots,
 * after nfixed) of a frame with no function. (On trace, the top-level frame is
 * the only one that can have no function.)
 */</comment>
<struct>struct <name>UpvarStackTraits</name> <block>{<public type="default">
    <function><type><specifier>static</specifier> <name>jsval</name></type> <name>interp_get</name><parameter_list>(<param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>, <param><decl><type><name>int32</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><name><name>fp</name>-&gt;<name>slots</name><index>[<expr><name>slot</name> + <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name></expr>]</index></name></expr>;</return>
    }</block></function>

    <function><type><specifier>static</specifier> <name>uint32</name></type> <name>native_slot</name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>, <param><decl><type><name>int32</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <comment type="block">/*
         * Locals are not imported by the tracer when the frame has no
         * function, so we do not add fp-&gt;script-&gt;nfixed.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>argc</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>slot</name></expr>;</return>
    }</block></function>
</public>}</block>;</struct>

<function><type><name>uint32</name> <name>JS_FASTCALL</name></type>
<name>GetUpvarStackOnTrace</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>upvarLevel</name></decl></param>, <param><decl><type><name>int32</name></type> <name>slot</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>callDepth</name></decl></param>,
                     <param><decl><type><name>double</name>*</type> <name>result</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>GetUpvarOnTrace</name><argument_list>&lt;<argument><expr><name>UpvarStackTraits</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>upvarLevel</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Parameters needed to access a value from a closure on trace.</comment>
<struct>struct <name>ClosureVarInfo</name>
<block>{<public type="default">
    <decl_stmt><decl><type><name>uint32</name></type>   <name>slot</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uint32</name></type>   <name>callDepth</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</public>}</block>;</struct>

<comment type="block">/*
 * Generic function to read upvars from Call objects of active heavyweight functions.
 *     call       Callee Function object in which the upvar is accessed.
 */</comment>
<template>template<parameter_list>&lt;<param><type><typename>typename</typename></type> <name>T</name></param>&gt;</parameter_list>
<function><type><specifier>inline</specifier> <name>uint32</name></type>
<name>GetFromClosure</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>call</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ClosureVarInfo</name>*</type> <name>cv</name></decl></param>, <param><decl><type><name>double</name>*</type> <name>result</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>call</name></expr></argument>)</argument_list></call> == &amp;<name>js_CallClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>InterpState</name>*</type> <name>state</name> <init>= <expr><name><name>cx</name>-&gt;<name>interpState</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>FrameInfo</name>**</type> <name>fip</name> <init>= <expr><name><name>state</name>-&gt;<name>rp</name></name> + <name><name>cv</name>-&gt;<name>callDepth</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>stackOffset</name> <init>= <expr><call><name>StackDepthFromCallStack</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>cv</name>-&gt;<name>callDepth</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr>--<name>fip</name> &gt; <name><name>state</name>-&gt;<name>callstackBase</name></name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>FrameInfo</name>*</type> <name>fi</name> <init>= <expr>*<name>fip</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * The loop starts aligned to the top of the stack, so move down to the first meaningful
         * callee. Then read the callee directly from the frame.
         */</comment>
        <expr_stmt><expr><name>stackOffset</name> -= <name><name>fi</name>-&gt;<name>callerHeight</name></name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>JSObject</name>*</type> <name>callee</name> <init>= <expr>*(<name>JSObject</name>**)(&amp;<name><name>state</name>-&gt;<name>stackBase</name><index>[<expr><name>stackOffset</name></expr>]</index></name>)</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>callee</name> == <name>call</name></expr>)</condition><then> <block>{
            <comment type="line">// This is not reachable as long as the tracer guards on the identity of the callee's</comment>
            <comment type="line">// parent when making a call:</comment>
            <comment type="line">//</comment>
            <comment type="line">// - We can only reach this point if we execute JSOP_LAMBDA on trace, then call the</comment>
            <comment type="line">//   function created by the lambda, and then execute a JSOP_NAME on trace.</comment>
            <comment type="line">// - Each time we execute JSOP_LAMBDA we get a function with a different parent.</comment>
            <comment type="line">// - When we execute the call to the new function, we exit trace because the parent</comment>
            <comment type="line">//   is different.</comment>
            <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"JSOP_NAME variable found in outer trace"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Here we specifically want to check the call object of the trace entry frame.
     */</comment>
    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name> <init>= <expr><name><name>cv</name>-&gt;<name>slot</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VOUCH_DOES_NOT_REQUIRE_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>callobj</name></name> == <name>call</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>slot</name> = <call><name><name>T</name>::<name>adj_slot</name></name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>result</name> = <name><name>state</name>-&gt;<name>stackBase</name><index>[<expr><name>slot</name></expr>]</index></name></expr>;</expr_stmt>
        <return>return <expr><name><name>state</name>-&gt;<name>callstackBase</name><index>[<expr>0</expr>]</index></name>-&gt;<call><name>get_typemap</name><argument_list>()</argument_list></call><index>[<expr><name>slot</name></expr>]</index></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr>(<name>JSStackFrame</name>*) <call><name><name>call</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>fp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>v</name> = <call><name><name>T</name>::<name>slots</name></name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><index>[<expr><name>slot</name></expr>]</index></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * Get the value from the object. We know we have a Call object, and
         * that our slot index is fine, so don't monkey around with calling the
         * property getter (which just looks in the slot) or calling
         * js_GetReservedSlot. Just get the slot directly. Note the static
         * asserts in jsfun.cpp which make sure Call objects use dslots.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>slot</name> &lt; <call><name><name>T</name>::<name>slot_count</name></name><argument_list>(<argument><expr><name>call</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v</name> = <call><name><name>T</name>::<name>slots</name></name><argument_list>(<argument><expr><name>call</name></expr></argument>)</argument_list></call><index>[<expr><name>slot</name></expr>]</index></expr>;</expr_stmt>
    }</block></else></if>
    <decl_stmt><decl><type><name>TraceType</name></type> <name>type</name> <init>= <expr><call><name>getCoercedType</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ValueToNative</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>type</name></expr>;</return>
}</block></function></template>

<struct>struct <name>ArgClosureTraits</name>
<block>{<public type="default">
    <comment type="line">// Adjust our slot to point to the correct slot on the native stack.</comment>
    <comment type="line">// See also UpvarArgTraits.</comment>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32</name></type> <name>adj_slot</name><parameter_list>(<param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{ <return>return <expr>2 + <name>slot</name></expr>;</return> }</block></function>

    <comment type="line">// Generate the adj_slot computation in LIR.</comment>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>LIns</name>*</type> <name>adj_slot_lir</name><parameter_list>(<param><decl><type><name>LirWriter</name>*</type> <name>lir</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>fp_ins</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>2 + <name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Get the right frame slots to use our slot index with.</comment>
    <comment type="line">// See also UpvarArgTraits.</comment>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>jsval</name>*</type> <name>slots</name><parameter_list>(<param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name><name>fp</name>-&gt;<name>argv</name></name></expr>;</return> }</block></function>

    <comment type="line">// Get the right object slots to use our slot index with.</comment>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>jsval</name>*</type> <name>slots</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// We know Call objects use dslots.</comment>
        <return>return <expr><name><name>obj</name>-&gt;<name>dslots</name></name> + <call><name>slot_offset</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
    <comment type="line">// Get the offset of our object slots from the object's dslots pointer.</comment>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32</name></type> <name>slot_offset</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>JSSLOT_START</name><argument_list>(<argument><expr>&amp;<name>js_CallClass</name></expr></argument>)</argument_list></call> +
            <name>CALL_CLASS_FIXED_RESERVED_SLOTS</name> - <name>JS_INITIAL_NSLOTS</name></expr>;</return>
    }</block></function>
    <comment type="line">// Get the maximum slot index of this type that should be allowed</comment>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint16</name></type> <name>slot_count</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>js_GetCallObjectFunction</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>nargs</name></expr>;</return>
    }</block></function>
</public><private>private:
    <constructor_decl><name>ArgClosureTraits</name><parameter_list>()</parameter_list>;</constructor_decl>
</private>}</block>;</struct>

<function><type><name>uint32</name> <name>JS_FASTCALL</name></type>
<name>GetClosureArg</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>callee</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ClosureVarInfo</name>*</type> <name>cv</name></decl></param>, <param><decl><type><name>double</name>*</type> <name>result</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>GetFromClosure</name><argument_list>&lt;<argument><expr><name>ArgClosureTraits</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callee</name></expr></argument>, <argument><expr><name>cv</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<struct>struct <name>VarClosureTraits</name>
<block>{<public type="default">
    <comment type="line">// See documentation on ArgClosureTraits for what these functions</comment>
    <comment type="line">// should be doing.</comment>
    <comment type="line">// See also UpvarVarTraits.</comment>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32</name></type> <name>adj_slot</name><parameter_list>(<param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{ <return>return <expr>4 + <name><name>fp</name>-&gt;<name>argc</name></name> + <name>slot</name></expr>;</return> }</block></function>

    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>LIns</name>*</type> <name>adj_slot_lir</name><parameter_list>(<param><decl><type><name>LirWriter</name>*</type> <name>lir</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>fp_ins</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>LIns</name> *</type><name>argc_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>fp_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSStackFrame</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_add</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>4 + <name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc_ins</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// See also UpvarVarTraits.</comment>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>jsval</name>*</type> <name>slots</name><parameter_list>(<param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name><name>fp</name>-&gt;<name>slots</name></name></expr>;</return> }</block></function>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>jsval</name>*</type> <name>slots</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list> <block>{
        <comment type="line">// We know Call objects use dslots.</comment>
        <return>return <expr><name><name>obj</name>-&gt;<name>dslots</name></name> + <call><name>slot_offset</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32</name></type> <name>slot_offset</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>JSSLOT_START</name><argument_list>(<argument><expr>&amp;<name>js_CallClass</name></expr></argument>)</argument_list></call> +
            <name>CALL_CLASS_FIXED_RESERVED_SLOTS</name> - <name>JS_INITIAL_NSLOTS</name> +
            <call><name>js_GetCallObjectFunction</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>nargs</name></expr>;</return>
    }</block></function>
    <function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint16</name></type> <name>slot_count</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list> <block>{
        <return>return <expr><call><name>js_GetCallObjectFunction</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name><name>u</name>.<name>i</name>.<name>nvars</name></name></expr>;</return>
    }</block></function>
</public><private>private:
    <constructor_decl><name>VarClosureTraits</name><parameter_list>()</parameter_list>;</constructor_decl>
</private>}</block>;</struct>

<function><type><name>uint32</name> <name>JS_FASTCALL</name></type>
<name>GetClosureVar</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>callee</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ClosureVarInfo</name>*</type> <name>cv</name></decl></param>, <param><decl><type><name>double</name>*</type> <name>result</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>GetFromClosure</name><argument_list>&lt;<argument><expr><name>VarClosureTraits</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callee</name></expr></argument>, <argument><expr><name>cv</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Box the given native stack frame into the virtual machine stack. This
 * is infallible.
 *
 * @param callDepth the distance between the entry frame into our trace and
 *                  cx-&gt;fp when we make this call.  If this is not called as a
 *                  result of a nested exit, callDepth is 0.
 * @param mp an array of TraceType that indicate what the types of the things
 *           on the stack are.
 * @param np pointer to the native stack.  We want to copy values from here to
 *           the JS stack as needed.
 * @param stopFrame if non-null, this frame and everything above it should not
 *                  be restored.
 * @return the number of things we popped off of np.
 */</comment>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>int</name></type>
<name>FlushNativeStackFrame</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>TraceType</name>*</type> <name>mp</name></decl></param>, <param><decl><type><name>double</name>*</type> <name>np</name></decl></param>,
                      <param><decl><type><name>JSStackFrame</name>*</type> <name>stopFrame</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ignoreSlots</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>stopAt</name> <init>= <expr><name>stopFrame</name> ? &amp;<name><name>stopFrame</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name> : <name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Root all string and object references first (we don't need to call the GC for this). */</comment>
    <function_decl><type><name>FlushNativeStackFrameVisitor</name></type> <name>visitor</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>mp</name></type></decl></param>, <param><decl><type><name>np</name></type></decl></param>, <param><decl><type><name>stopAt</name></type></decl></param>, <param><decl><type><name>ignoreSlots</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Restore thisv from the now-restored argv[-1] in each pending frame.</comment>
    <comment type="line">// Keep in mind that we didn't restore frames at stopFrame and above!</comment>
    <comment type="line">// Scope to keep |fp| from leaking into the macros we're using.</comment>
    <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><name>callDepth</name>+1</expr></init></decl>;</decl_stmt> <comment type="line">// +1 to make sure we restore the entry frame</comment>
        <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>stopFrame</name></expr>)</condition><then> <block>{
            <for>for (<init>;</init> <condition><expr><name>fp</name> != <name>stopFrame</name></expr>;</condition> <incr><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr></incr>) <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>n</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>--<name>n</name></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// Skip over stopFrame itself.</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>n</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>--<name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <for>for (<init>;</init> <condition><expr><name>n</name> != 0</expr>;</condition> <incr><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr></incr>) <block>{
            <expr_stmt><expr>--<name>n</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>argv</name></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>argsobj</name></name> &amp;&amp; <call><name>GetArgsPrivateNative</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>)</argument_list></call>-&gt;<call><name>setPrivate</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>argv</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><call><name><name>fp</name>-&gt;<name>calleeObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>fp</name>-&gt;<name>callee</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == <name><name>fp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call> &amp;&amp;
                    (<name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_HEAVYWEIGHT</name>)</expr>)</condition><then> <block>{
                    <comment type="line">// Iff these fields are NULL, then |fp| was synthesized on trace exit, so</comment>
                    <comment type="line">// we need to update the frame fields.</comment>
                    <if>if <condition>(<expr>!<name><name>fp</name>-&gt;<name>callobj</name></name></expr>)</condition><then>
                        <expr_stmt><expr><name><name>fp</name>-&gt;<name>callobj</name></name> = <name><name>fp</name>-&gt;<name>scopeChain</name></name></expr>;</expr_stmt></then></if>

                    <comment type="line">// Iff scope chain's private is NULL, then |fp-&gt;scopeChain| was created</comment>
                    <comment type="line">// on trace for a call, so we set the private field now. (Call objects</comment>
                    <comment type="line">// that correspond to returned frames also have a NULL private, but such</comment>
                    <comment type="line">// a call object would not occur as the |scopeChain| member of a frame,</comment>
                    <comment type="line">// so we cannot be in that case here.)</comment>
                    <if>if <condition>(<expr>!<call><name><name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>setPrivate</name></name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></then></if>
                <expr_stmt><expr><name><name>fp</name>-&gt;<name>thisv</name></name> = <name><name>fp</name>-&gt;<name>argv</name><index>[<expr>-1</expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_CONSTRUCTING</name></expr>)</condition><then> <comment type="line">// constructors always compute 'this'</comment>
                    <expr_stmt><expr><name><name>fp</name>-&gt;<name>flags</name></name> |= <name>JSFRAME_COMPUTED_THIS</name></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></for>
    }</block>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>visitor</name>.<name>getTypeMap</name></name><argument_list>()</argument_list></call> - <name>mp</name></expr>;</return>
}</block></function>

<comment type="block">/* Emit load instructions onto the trace that read the initial stack state. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>import</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>base</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>, <param><decl><type><name>TraceType</name></type> <name>t</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>index</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AccSet</name></type> <name>accSet</name> <init>= <expr><name>base</name> == <name><name>lirbuf</name>-&gt;<name>sp</name></name> ? <name>ACC_STACK</name> : <name>ACC_OTHER</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>t</name> == <name>TT_INT32</name></expr>)</condition><then> <block>{ <comment type="block">/* demoted */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isInt32</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Ok, we have a valid demotion attempt pending, so insert an integer
         * read and promote it to double since all arithmetic operations expect
         * to see doubles on entry. The first op to use this slot will emit a
         * f2i cast which will cancel out the i2f we insert here.
         */</comment>
        <expr_stmt><expr><name>ins</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>accSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ins</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>t</name> != <name>TT_JSVAL</name></expr></argument>, <argument><expr><call><name>isNumber</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> == (<name>t</name> == <name>TT_DOUBLE</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>t</name> == <name>TT_DOUBLE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ins</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldf</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>accSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>t</name> == <name>TT_SPECIAL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ins</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>accSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>t</name> == <name>TT_VOID</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ins</name> = <call><name>INS_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>ins</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>accSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>checkForGlobalObjectReallocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>tracker</name>.<name>set</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call> &lt; 11</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>void</name>*</type> <name>mark</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsuword</name>*</type> <name>localNames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>funName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>*<name>prefix</name> == 'a' || *<name>prefix</name> == 'v'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>hasLocalNames</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>localNames</name> = <call><name>js_GetLocalNameArray</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>fun</name></name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>funName</name> = <name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>atom</name></name> ? <call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>atom</name></name></expr></argument>)</argument_list></call> : "&lt;anonymous&gt;"</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr>"argv"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>index</name> &lt; <name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name> <init>= <expr><call><name>JS_LOCAL_NAME_TO_ATOM</name><argument_list>(<argument><expr><name><name>localNames</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>sizeof <name>name</name></expr></argument>, <argument><expr>"$%s.%s"</expr></argument>, <argument><expr><name>funName</name></expr></argument>, <argument><expr><call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>sizeof <name>name</name></expr></argument>, <argument><expr>"$%s.&lt;arg%d&gt;"</expr></argument>, <argument><expr><name>funName</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then> <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr>"vars"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name> <init>= <expr><call><name>JS_LOCAL_NAME_TO_ATOM</name><argument_list>(<argument><expr><name><name>localNames</name><index>[<expr><name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name> + <name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>sizeof <name>name</name></expr></argument>, <argument><expr>"$%s.%s"</expr></argument>, <argument><expr><name>funName</name></expr></argument>, <argument><expr><call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>sizeof <name>name</name></expr></argument>, <argument><expr>"$%s%d"</expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <if>if <condition>(<expr><name>mark</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>addName</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name>*</type> <name><name>typestr</name><index>[]</index></name> <init>= <expr><block>{
        <expr>"object"</expr>, <expr>"int"</expr>, <expr>"double"</expr>, <expr>"jsval"</expr>, <expr>"string"</expr>, <expr>"null"</expr>, <expr>"boolean"</expr>, <expr>"function"</expr>
    }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"import vp=%p name=%s type=%s flags=%d\n"</expr></argument>,
                      <argument><expr>(<name>void</name>*)<name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>typestr</name><index>[<expr><name>t</name> &amp; 7</expr>]</index></name></expr></argument>, <argument><expr><name>t</name> &gt;&gt; 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<class>class <name>ImportBoxedStackSlotVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>TraceRecorder</name> &amp;</type><name>mRecorder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>mBase</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>mStackOffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name> *</type><name>mTypemap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>mFp</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><name>ImportBoxedStackSlotVisitor</name><parameter_list>(<param><decl><type><name>TraceRecorder</name> &amp;</type><name>recorder</name></decl></param>,
                                <param><decl><type><name>LIns</name> *</type><name>base</name></decl></param>,
                                <param><decl><type><name>ptrdiff_t</name></type> <name>stackOffset</name></decl></param>,
                                <param><decl><type><name>TraceType</name> *</type><name>typemap</name></decl></param>)</parameter_list> <member_list>:
        <call><name>mRecorder</name><argument_list>(<argument><expr><name>recorder</name></expr></argument>)</argument_list></call>,
        <call><name>mBase</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call>,
        <call><name>mStackOffset</name><argument_list>(<argument><expr><name>stackOffset</name></expr></argument>)</argument_list></call>,
        <call><name>mTypemap</name><argument_list>(<argument><expr><name>typemap</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
    <name>visitStackSlots</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr>*<name>mTypemap</name> == <name>TT_JSVAL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>mRecorder</name>.<name>import</name></name><argument_list>(<argument><expr><name>mBase</name></expr></argument>, <argument><expr><name>mStackOffset</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>TT_JSVAL</name></expr></argument>,
                                 <argument><expr>"jsval"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>LIns</name> *</type><name>vp_ins</name> <init>= <expr><call><name><name>mRecorder</name>.<name>unbox_jsval</name></name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>, <argument><expr><call><name><name>mRecorder</name>.<name>get</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>,
                                                     <argument><expr><call><name><name>mRecorder</name>.<name>copy</name></name><argument_list>(<argument><expr><name><name>mRecorder</name>.<name>anchor</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>mRecorder</name>.<name>set</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>vp_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>vp</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>mTypemap</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>mStackOffset</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>
</public>}</block>;</class>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>import</name></name><parameter_list>(<param><decl><type><name>TreeFragment</name>*</type> <name>tree</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>sp</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>stackSlots</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ngslots</name></decl></param>,
                      <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>, <param><decl><type><name>TraceType</name>*</type> <name>typeMap</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * If we get a partial list that doesn't have all the types (i.e. recording
     * from a side exit that was recorded but we added more global slots
     * later), merge the missing types from the entry type map. This is safe
     * because at the loop edge we verify that we have compatible types for all
     * globals (entry type and loop edge type match). While a different trace
     * of the tree might have had a guard with a different type map for these
     * slots we just filled in here (the guard we continue from didn't know
     * about them), since we didn't take that particular guard the only way we
     * could have ended up here is if that other trace had at its end a
     * compatible type distribution with the entry map. Since that's exactly
     * what we used to fill in the types our current side exit didn't provide,
     * this is always safe to do.
     */</comment>

    <decl_stmt><decl><type><name>TraceType</name>*</type> <name>globalTypeMap</name> <init>= <expr><name>typeMap</name> + <name>stackSlots</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>length</name> <init>= <expr><call><name><name>tree</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * This is potentially the typemap of the side exit and thus shorter than
     * the tree's global type map.
     */</comment>
    <if>if <condition>(<expr><name>ngslots</name> &lt; <name>length</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>MergeTypeMaps</name><argument_list>(<argument><expr>&amp;<name>globalTypeMap</name></expr></argument> <comment type="block">/* out param */</comment>, <argument><expr>&amp;<name>ngslots</name></expr></argument> <comment type="block">/* out param */</comment>,
                      <argument><expr><call><name><name>tree</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>length</name></expr></argument>,
                      <argument><expr>(<name>TraceType</name>*)<call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof> * <name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ngslots</name> == <call><name><name>tree</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check whether there are any values on the stack we have to unbox and do
     * that first before we waste any time fetching the state from the stack.
     */</comment>
    <if>if <condition>(<expr>!<name>anchor</name> || <name><name>anchor</name>-&gt;<name>exitType</name></name> != <name>RECURSIVE_SLURP_FAIL_EXIT</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>ImportBoxedStackSlotVisitor</name></type> <name>boxedStackVisitor</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr>-<name><name>tree</name>-&gt;<name>nativeStackBase</name></name></expr></argument>, <argument><expr><name>typeMap</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>boxedStackVisitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>


    <comment type="block">/*
     * Remember the import type map so we can lazily import later whatever
     * we need.
     */</comment>
    <expr_stmt><expr><call><name><name>importTypeMap</name>.<name>set</name></name><argument_list>(<argument><expr><name>importStackSlots</name> = <name>stackSlots</name></expr></argument>,
                      <argument><expr><name>importGlobalSlots</name> = <name>ngslots</name></expr></argument>,
                      <argument><expr><name>typeMap</name></expr></argument>, <argument><expr><name>globalTypeMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>TraceRecorder</name>::<name>isValidSlot</name></name><parameter_list>(<param><decl><type><name>JSScope</name>*</type> <name>scope</name></decl></param>, <param><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type> <name>setflags</name> <init>= <expr>(<name><name>js_CodeSpec</name><index>[<expr>*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr>]</index></name>.<name>format</name> &amp; (<name>JOF_SET</name> | <name>JOF_INCDEC</name> | <name>JOF_FOR</name>))</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>setflags</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name><name>sprop</name>-&gt;<name>hasDefaultSetter</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_VALUE</name><argument_list>(<argument><expr>"non-stub setter"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr>!<call><name><name>sprop</name>-&gt;<name>writable</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_VALUE</name><argument_list>(<argument><expr>"writing to a read-only property"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <comment type="block">/* This check applies even when setflags == 0. */</comment>
    <if>if <condition>(<expr><name>setflags</name> != <name>JOF_SET</name> &amp;&amp; !<call><name><name>sprop</name>-&gt;<name>hasDefaultGetter</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>sprop</name>-&gt;<name>isMethod</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RETURN_VALUE</name><argument_list>(<argument><expr>"non-stub getter"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>SPROP_HAS_VALID_SLOT</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_VALUE</name><argument_list>(<argument><expr>"invalid-slot obj property"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/* Lazily import a global slot if we don't already have it in the tracker. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>importGlobalSlot</name></name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>slot</name> == <call><name>uint16</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>globalObj</name>-&gt;<name>numSlots</name></name><argument_list>()</argument_list></call> &lt;= <name>MAX_GLOBAL_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name> <init>= <expr>&amp;<call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>known</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add the slot to the list of interned global slots. */</comment>
    <decl_stmt><decl><type><name>TraceType</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>offsetOf</name></name><argument_list>(<argument><expr><call><name>uint16</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>index</name> == -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>type</name> = <call><name>getCoercedType</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>type</name> == <name>TT_INT32</name> &amp;&amp; <call><name><name>oracle</name>.<name>isGlobalSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>type</name> = <name>TT_DOUBLE</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>index</name> = (<name>int</name>)<call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>add</name></name><argument_list>(<argument><expr><call><name>uint16</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>typeMap</name>.<name>add</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpecializeTreesToMissingGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>tree</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call> == <call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>type</name> = <name><name>importTypeMap</name><index>[<expr><name>importStackSlots</name> + <name>index</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> != <name>TT_IGNORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>import</name><argument_list>(<argument><expr><name>eos_ins</name></expr></argument>, <argument><expr><name>slot</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>"global"</expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Lazily import a global slot if we don't already have it in the tracker. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>TraceRecorder</name>::<name>lazilyImportGlobalSlot</name></name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>slot</name> != <call><name>uint16</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="block">/* we use a table of 16-bit ints, bail out if that's not enough */</comment>
        <return>return <expr>false</expr>;</return></then></if>
    <comment type="block">/*
     * If the global object grows too large, alloca in ExecuteTree might fail,
     * so abort tracing on global objects with unreasonably many slots.
     */</comment>
    <if>if <condition>(<expr><call><name><name>globalObj</name>-&gt;<name>numSlots</name></name><argument_list>()</argument_list></call> &gt; <name>MAX_GLOBAL_SLOTS</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name> <init>= <expr>&amp;<call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>known</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if> <comment type="block">/* we already have it */</comment>
    <expr_stmt><expr><call><name>importGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/* Write back a value onto the stack or global frames. */</comment>
<function><type><name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>writeBack</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>base</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl></param>, <param><decl><type><name>bool</name></type> <name>shouldDemote</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Sink all type casts targeting the stack into the side exit by simply storing the original
     * (uncasted) value. Each guard generates the side exit map based on the types of the
     * last stores to every stack location, so it's safe to not perform them on-trace.
     */</comment>
    <if>if <condition>(<expr><name>shouldDemote</name> &amp;&amp; <call><name>isPromoteInt</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>i</name> = <call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr>(<name>base</name> == <name><name>lirbuf</name>-&gt;<name>sp</name></name>) ? <name>ACC_STACK</name> : <name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Update the tracker, then issue a write back store. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>set</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>, <param><decl><type><name>bool</name></type> <name>demote</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>i</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkForGlobalObjectReallocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>tracker</name>.<name>set</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we are writing to this location for the first time, calculate the
     * offset into the native frame manually. Otherwise just look up the last
     * load or store associated with the same source address (p) and use the
     * same offset/base.
     */</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name> <init>= <expr><call><name><name>nativeFrameTracker</name>.<name>get</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>x</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>isGlobal</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>x</name> = <call><name>writeBack</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>eos_ins</name></expr></argument>, <argument><expr><call><name>nativeGlobalOffset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>demote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>x</name> = <call><name>writeBack</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>, <argument><expr><call><name>nativespOffset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>demote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <expr_stmt><expr><call><name><name>nativeFrameTracker</name>.<name>set</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_64BIT</name></expr></cpp:if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>( <argument><expr><call><name><name>x</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_stqi</name></expr></argument>)</argument_list></call> || <call><name><name>x</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_sti</name></expr></argument>)</argument_list></call> || <call><name><name>x</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_stfi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>( <argument><expr><call><name><name>x</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_sti</name></expr></argument>)</argument_list></call> || <call><name><name>x</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_stfi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <decl_stmt><decl><type><name>int</name></type> <name>disp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>base</name> <init>= <expr><call><name><name>x</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NANOJIT_ARM</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name><name>base</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>disp</name> = <call><name><name>base</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call>-&gt;<call><name>imm32</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>base</name> = <call><name><name>base</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>disp</name> = <call><name><name>x</name>-&gt;<name>disp</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>base</name> == <name><name>lirbuf</name>-&gt;<name>sp</name></name> || <name>base</name> == <name>eos_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>disp</name> == ((<name>base</name> == <name><name>lirbuf</name>-&gt;<name>sp</name></name>)
                            ? <call><name>nativespOffset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>
                            : <call><name>nativeGlobalOffset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>writeBack</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>, <argument><expr><name>demote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>attemptImport</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<decl><type><name>LIns</name>*</type> <name>i</name> <init>= <expr><call><name>getFromTracker</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then>
        <return>return <expr><name>i</name></expr>;</return></then></if>

    <comment type="block">/* If the variable was not known, it could require a lazy import. */</comment>
    <function_decl><type><name>CountSlotsVisitor</name></type> <name>countVisitor</name><parameter_list>(<param><decl><type><name>p</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>countVisitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>countVisitor</name>.<name>stopped</name></name><argument_list>()</argument_list></call> || <call><name>size_t</name><argument_list>(<argument><expr><name>p</name> - <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name></name></expr></argument>)</argument_list></call> &lt; <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>nslots</name></name></expr>)</condition><then>
        <return>return <expr><call><name>get</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name><name>nanojit</name>::<name>LIns</name></name>*</type>
<name><name>TraceRecorder</name>::<name>getFromTracker</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>checkForGlobalObjectReallocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>tracker</name>.<name>get</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>get</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name> <init>= <expr><call><name>getFromTracker</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>x</name></expr>)</condition><then>
        <return>return <expr><name>x</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>isGlobal</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>slot</name> <init>= <expr><call><name>nativeGlobalSlot</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>offsetOf</name></name><argument_list>(<argument><expr><call><name>uint16</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>importGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>slot</name> <init>= <expr><call><name>nativeStackSlot</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TraceType</name></type> <name>type</name> <init>= <expr><name><name>importTypeMap</name><index>[<expr><name>slot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> != <name>TT_IGNORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>import</name><argument_list>(<argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>, <argument><expr>-<name><name>tree</name>-&gt;<name>nativeStackBase</name></name> + <name>slot</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsdouble</name></expr></argument>)</argument_list></sizeof></expr></argument>,
               <argument><expr><name>p</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>"stack"</expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>known</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>tracker</name>.<name>get</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>addr</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>isGlobal</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>
           ? <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>eos_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><call><name>nativeGlobalOffset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
           : <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>,
                       <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><call><name>nativespOffset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>TraceRecorder</name>::<name>known</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>p</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>checkForGlobalObjectReallocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>tracker</name>.<name>has</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * The dslots of the global object are sometimes reallocated by the interpreter.
 * This function check for that condition and re-maps the entries of the tracker
 * accordingly.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>checkForGlobalObjectReallocation</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name>global_dslots</name> != <name><name>globalObj</name>-&gt;<name>dslots</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"globalObj-&gt;dslots relocated, updating tracker\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>jsval</name>*</type> <name>src</name> <init>= <expr><name>global_dslots</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsval</name>*</type> <name>dst</name> <init>= <expr><name><name>globalObj</name>-&gt;<name>dslots</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsuint</name></type> <name>length</name> <init>= <expr><name><name>globalObj</name>-&gt;<name>dslots</name><index>[<expr>-1</expr>]</index></name> - <name>JS_INITIAL_NSLOTS</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>**</type> <name>map</name> <init>= <expr>(<name>LIns</name>**)<call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LIns</name>*</expr></argument>)</argument_list></sizeof> * <name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>jsuint</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>n</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
            <expr_stmt><expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name> = <call><name><name>tracker</name>.<name>get</name></name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tracker</name>.<name>set</name></name><argument_list>(<argument><expr><name>src</name>++</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <for>for (<init><decl><type><name>jsuint</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>n</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>)
            <expr_stmt><expr><call><name><name>tracker</name>.<name>set</name></name><argument_list>(<argument><expr><name>dst</name>++</expr></argument>, <argument><expr><name><name>map</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <expr_stmt><expr><name>global_dslots</name> = <name><name>globalObj</name>-&gt;<name>dslots</name></name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* Determine whether the current branch is a loop edge (taken or not taken). */</comment>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name>IsLoopEdge</name><parameter_list>(<param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>, <param><decl><type><name>jsbytecode</name>*</type> <name>header</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr>*<name>pc</name></expr>)</condition> <block>{
      <case>case <expr><name>JSOP_IFEQ</name></expr>:
      </case><case>case <expr><name>JSOP_IFNE</name></expr>:
        <return>return <expr>((<name>pc</name> + <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call>) == <name>header</name>)</expr>;</return>
      </case><case>case <expr><name>JSOP_IFEQX</name></expr>:
      </case><case>case <expr><name>JSOP_IFNEX</name></expr>:
        <return>return <expr>((<name>pc</name> + <call><name>GET_JUMPX_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call>) == <name>header</name>)</expr>;</return>
      </case><default>default:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(*<name>pc</name> == <name>JSOP_AND</name>) || (*<name>pc</name> == <name>JSOP_ANDX</name>) ||
                  (*<name>pc</name> == <name>JSOP_OR</name>) || (*<name>pc</name> == <name>JSOP_ORX</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>
    <return>return <expr>false</expr>;</return>
}</block></function>

<class>class <name>AdjustCallerGlobalTypesVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>TraceRecorder</name> &amp;</type><name>mRecorder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>mCx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nanojit</name>::<name>LirBuffer</name></name> *</type><name>mLirbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nanojit</name>::<name>LirWriter</name></name> *</type><name>mLir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name> *</type><name>mTypeMap</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><name>AdjustCallerGlobalTypesVisitor</name><parameter_list>(<param><decl><type><name>TraceRecorder</name> &amp;</type><name>recorder</name></decl></param>,
                                   <param><decl><type><name>TraceType</name> *</type><name>typeMap</name></decl></param>)</parameter_list> <member_list>:
        <call><name>mRecorder</name><argument_list>(<argument><expr><name>recorder</name></expr></argument>)</argument_list></call>,
        <call><name>mCx</name><argument_list>(<argument><expr><name><name>mRecorder</name>.<name>cx</name></name></expr></argument>)</argument_list></call>,
        <call><name>mLirbuf</name><argument_list>(<argument><expr><name><name>mRecorder</name>.<name>lirbuf</name></name></expr></argument>)</argument_list></call>,
        <call><name>mLir</name><argument_list>(<argument><expr><name><name>mRecorder</name>.<name>lir</name></name></expr></argument>)</argument_list></call>,
        <call><name>mTypeMap</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><name>TraceType</name>*</type> <name>getTypeMap</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>mTypeMap</name></expr>;</return>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>visitGlobalSlot</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <decl_stmt><decl><type><name>LIns</name> *</type><name>ins</name> <init>= <expr><call><name><name>mRecorder</name>.<name>get</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>isPromote</name> <init>= <expr><call><name>isPromoteInt</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>isPromote</name> &amp;&amp; *<name>mTypeMap</name> == <name>TT_DOUBLE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>mLir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name><name>mRecorder</name>.<name>get</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>mRecorder</name>.<name>eos_ins</name></name></expr></argument>,
                            <argument><expr><call><name><name>mRecorder</name>.<name>nativeGlobalOffset</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Aggressively undo speculation so the inner tree will compile
             * if this fails.
             */</comment>
            <expr_stmt><expr><call><name><name>oracle</name>.<name>markGlobalSlotUndemotable</name></name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!(!<name>isPromote</name> &amp;&amp; *<name>mTypeMap</name> == <name>TT_INT32</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>mTypeMap</name></expr>;</expr_stmt>
    }</block></function>
</public>}</block>;</class>

<class>class <name>AdjustCallerStackTypesVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>TraceRecorder</name> &amp;</type><name>mRecorder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>mCx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nanojit</name>::<name>LirBuffer</name></name> *</type><name>mLirbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nanojit</name>::<name>LirWriter</name></name> *</type><name>mLir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>mSlotnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name> *</type><name>mTypeMap</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><name>AdjustCallerStackTypesVisitor</name><parameter_list>(<param><decl><type><name>TraceRecorder</name> &amp;</type><name>recorder</name></decl></param>,
                                  <param><decl><type><name>TraceType</name> *</type><name>typeMap</name></decl></param>)</parameter_list> <member_list>:
        <call><name>mRecorder</name><argument_list>(<argument><expr><name>recorder</name></expr></argument>)</argument_list></call>,
        <call><name>mCx</name><argument_list>(<argument><expr><name><name>mRecorder</name>.<name>cx</name></name></expr></argument>)</argument_list></call>,
        <call><name>mLirbuf</name><argument_list>(<argument><expr><name><name>mRecorder</name>.<name>lirbuf</name></name></expr></argument>)</argument_list></call>,
        <call><name>mLir</name><argument_list>(<argument><expr><name><name>mRecorder</name>.<name>lir</name></name></expr></argument>)</argument_list></call>,
        <call><name>mSlotnum</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
        <call><name>mTypeMap</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><name>TraceType</name>*</type> <name>getTypeMap</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>mTypeMap</name></expr>;</return>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
    <name>visitStackSlots</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>LIns</name> *</type><name>ins</name> <init>= <expr><call><name><name>mRecorder</name>.<name>get</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>isPromote</name> <init>= <expr><call><name>isPromoteInt</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>isPromote</name> &amp;&amp; *<name>mTypeMap</name> == <name>TT_DOUBLE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>mLir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name><name>mRecorder</name>.<name>get</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>mLirbuf</name>-&gt;<name>sp</name></name></expr></argument>,
                                <argument><expr><call><name><name>mRecorder</name>.<name>nativespOffset</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Aggressively undo speculation so the inner tree will compile
                 * if this fails.
                 */</comment>
                <expr_stmt><expr><call><name><name>oracle</name>.<name>markStackSlotUndemotable</name></name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr><name>mSlotnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!(!<name>isPromote</name> &amp;&amp; *<name>mTypeMap</name> == <name>TT_INT32</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>vp</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>mTypeMap</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>mSlotnum</name></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>
</public>}</block>;</class>

<comment type="block">/*
 * Promote slots if necessary to match the called tree's type map. This
 * function is infallible and must only be called if we are certain that it is
 * possible to reconcile the types for each slot in the inner and outer trees.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>adjustCallerTypes</name></name><parameter_list>(<param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>AdjustCallerGlobalTypesVisitor</name></type> <name>globalVisitor</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><call><name><name>f</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitGlobalSlots</name><argument_list>(<argument><expr><name>globalVisitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr>*<name><name>tree</name>-&gt;<name>globalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>AdjustCallerStackTypesVisitor</name></type> <name>stackVisitor</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><call><name><name>f</name>-&gt;<name>stackTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>stackVisitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>f</name> == <name><name>f</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>TraceType</name></type>
<name><name>TraceRecorder</name>::<name>determineSlotType</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceType</name></type> <name>m</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>i</name> <init>= <expr><call><name>getFromTracker</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>i</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>m</name> = <call><name>isPromoteInt</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> ? <name>TT_INT32</name> : <name>TT_DOUBLE</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>isGlobal</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>offsetOf</name></name><argument_list>(<argument><expr><call><name>uint16</name><argument_list>(<argument><expr><call><name>nativeGlobalSlot</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>offset</name> != -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>m</name> = <name><name>importTypeMap</name><index>[<expr><name>importStackSlots</name> + <name>offset</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>m</name> = <name><name>importTypeMap</name><index>[<expr><call><name>nativeStackSlot</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>m</name> != <name>TT_IGNORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>m</name> = <name>TT_NULL</name></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>m</name> = <name>TT_FUNCTION</name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>m</name> = <name>TT_OBJECT</name></expr>;</expr_stmt></else></if></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* N.B. void is JSVAL_SPECIAL. */</comment>
        <expr_stmt><expr><name>m</name> = <name>TT_VOID</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> || <call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>jsvaltag</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TT_STRING</name></expr></argument>)</argument_list></call> == <name>JSVAL_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>jsvaltag</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TT_SPECIAL</name></expr></argument>)</argument_list></call> == <name>JSVAL_SPECIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>m</name> = <call><name>TraceType</name><argument_list>(<argument><expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>m</name> != <name>TT_INT32</name> || <call><name>isInt32</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>m</name></expr>;</return>
}</block></function>

<class>class <name>DetermineTypesVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>TraceRecorder</name> &amp;</type><name>mRecorder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name> *</type><name>mTypeMap</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><name>DetermineTypesVisitor</name><parameter_list>(<param><decl><type><name>TraceRecorder</name> &amp;</type><name>recorder</name></decl></param>,
                          <param><decl><type><name>TraceType</name> *</type><name>typeMap</name></decl></param>)</parameter_list> <member_list>:
        <call><name>mRecorder</name><argument_list>(<argument><expr><name>recorder</name></expr></argument>)</argument_list></call>,
        <call><name>mTypeMap</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>visitGlobalSlot</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr>*<name>mTypeMap</name>++ = <call><name><name>mRecorder</name>.<name>determineSlotType</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
    <name>visitStackSlots</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
            <expr_stmt><expr>*<name>mTypeMap</name>++ = <call><name><name>mRecorder</name>.<name>determineSlotType</name></name><argument_list>(<argument><expr><name>vp</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><name>TraceType</name>*</type> <name>getTypeMap</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>mTypeMap</name></expr>;</return>
    }</block></function>
</public>}</block>;</class>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_JIT_SPEW</name></expr></cpp:if>
<function><type><name>JS_REQUIRES_STACK</name> <specifier>static</specifier> <name>void</name></type>
<name>TreevisLogExit</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"TREEVIS ADDEXIT EXIT=%p TYPE=%s FRAG=%p PC=%p FILE=\"%s\""
                      " LINE=%d OFFS=%d"</expr></argument>, <argument><expr>(<name>void</name>*)<name>exit</name></expr></argument>, <argument><expr><call><name>getExitName</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr>(<name>void</name>*)<name><name>exit</name>-&gt;<name>from</name></name></expr></argument>, <argument><expr>(<name>void</name>*)<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></argument>,
                      <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>" STACK=\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>exit</name>-&gt;<name>numStackSlots</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr><call><name><name>exit</name>-&gt;<name>stackTypeMap</name></name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"\" GLOBALS=\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>exit</name>-&gt;<name>numGlobalSlots</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr><call><name><name>exit</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"\"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>JS_REQUIRES_STACK</name> <name>VMSideExit</name>*</type>
<name><name>TraceRecorder</name>::<name>snapshot</name></name><parameter_list>(<param><decl><type><name>ExitType</name></type> <name>exitType</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFrameRegs</name>*</type> <name>regs</name> <init>= <expr><name><name>fp</name>-&gt;<name>regs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Check for a return-value opcode that needs to restart at the next
     * instruction.
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name>&amp;</type> <name>cs</name> <init>= <expr><name><name>js_CodeSpec</name><index>[<expr>*<name>pc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * When calling a _FAIL native, make the snapshot's pc point to the next
     * instruction after the CALL or APPLY. Even on failure, a _FAIL native
     * must not be called again from the interpreter.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>resumeAfter</name> <init>= <expr>(<name>pendingSpecializedNative</name> &amp;&amp;
                        <call><name>JSTN_ERRTYPE</name><argument_list>(<argument><expr><name>pendingSpecializedNative</name></expr></argument>)</argument_list></call> == <name>FAIL_STATUS</name>)</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>resumeAfter</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_CALL</name> || *<name>pc</name> == <name>JSOP_APPLY</name> || *<name>pc</name> == <name>JSOP_NEW</name> ||
                  *<name>pc</name> == <name>JSOP_SETPROP</name> || *<name>pc</name> == <name>JSOP_SETNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> += <name><name>cs</name>.<name>length</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>regs</name>-&gt;<name>pc</name></name> = <name>pc</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MUST_FLOW_THROUGH</name><argument_list>(<argument><expr>"restore_pc"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Generate the entry map for the (possibly advanced) pc and stash it in
     * the trace.
     */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>stackSlots</name> <init>= <expr><call><name>NativeStackSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * It's sufficient to track the native stack use here since all stores
     * above the stack watermark defined by guards are killed.
     */</comment>
    <expr_stmt><expr><call><name>trackNativeStackUse</name><argument_list>(<argument><expr><name>stackSlots</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Capture the type map into a temporary location. */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>ngslots</name> <init>= <expr><call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>typemap_size</name> <init>= <expr>(<name>stackSlots</name> + <name>ngslots</name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Use the recorder-local temporary type map. */</comment>
    <decl_stmt><decl><type><name>TraceType</name>*</type> <name>typemap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>tempTypeMap</name>.<name>resize</name></name><argument_list>(<argument><expr><name>typemap_size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>typemap</name> = <call><name><name>tempTypeMap</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if> <comment type="block">/* crash if resize() fails. */</comment>

    <comment type="block">/*
     * Determine the type of a store by looking at the current type of the
     * actual value the interpreter is using. For numbers we have to check what
     * kind of store we used last (integer or double) to figure out what the
     * side exit show reflect in its typemap.
     */</comment>
    <decl_stmt><decl><type><name>DetermineTypesVisitor</name></type> <name>detVisitor</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><name>typemap</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitSlots</name><argument_list>(<argument><expr><name>detVisitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>, <argument><expr><name>ngslots</name></expr></argument>,
               <argument><expr><call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>unsigned</name><argument_list>(<argument><expr><call><name><name>detVisitor</name>.<name>getTypeMap</name></name><argument_list>()</argument_list></call> - <name>typemap</name></expr></argument>)</argument_list></call> ==
              <name>ngslots</name> + <name>stackSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If this snapshot is for a side exit that leaves a boxed jsval result on
     * the stack, make a note of this in the typemap. Examples include the
     * builtinStatus guard after calling a _FAIL builtin, a JSFastNative, or
     * GetPropertyByName; and the type guard in unbox_jsval after such a call
     * (also at the beginning of a trace branched from such a type guard).
     */</comment>
    <if>if <condition>(<expr><name>pendingUnboxSlot</name> ||
        (<name>pendingSpecializedNative</name> &amp;&amp; (<name><name>pendingSpecializedNative</name>-&gt;<name>flags</name></name> &amp; <name>JSTN_UNBOX_AFTER</name>))</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>pos</name> <init>= <expr><name>stackSlots</name> - 1</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pendingUnboxSlot</name> == <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> - 2</expr>)</condition><then>
            <expr_stmt><expr><name>pos</name> = <name>stackSlots</name> - 2</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>typemap</name><index>[<expr><name>pos</name></expr>]</index></name> = <name>TT_JSVAL</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Now restore the the original pc (after which early returns are ok). */</comment>
    <if>if <condition>(<expr><name>resumeAfter</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>MUST_FLOW_LABEL</name><argument_list>(<argument><expr><name>restore_pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>regs</name>-&gt;<name>pc</name></name> = <name>pc</name> - <name><name>cs</name>.<name>length</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * If we take a snapshot on a goto, advance to the target address. This
         * avoids inner trees returning on a break goto, which the outer
         * recorder then would confuse with a break in the outer tree.
         */</comment>
        <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_GOTO</name></expr>)</condition><then>
            <expr_stmt><expr><name>pc</name> += <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_GOTOX</name></expr>)</condition><then>
            <expr_stmt><expr><name>pc</name> += <call><name>GET_JUMPX_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
    }</block></else></if>

    <comment type="block">/*
     * Check if we already have a matching side exit; if so we can return that
     * side exit instead of creating a new one.
     */</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>**</type> <name>exits</name> <init>= <expr><call><name><name>tree</name>-&gt;<name>sideExits</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>nexits</name> <init>= <expr><call><name><name>tree</name>-&gt;<name>sideExits</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>exitType</name> == <name>LOOP_EXIT</name></expr>)</condition><then> <block>{
        <for>for (<init><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>n</name> &lt; <name>nexits</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>e</name> <init>= <expr><name><name>exits</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>e</name>-&gt;<name>pc</name></name> == <name>pc</name> &amp;&amp; <name><name>e</name>-&gt;<name>imacpc</name></name> == <name><name>fp</name>-&gt;<name>imacpc</name></name> &amp;&amp;
                <name>ngslots</name> == <name><name>e</name>-&gt;<name>numGlobalSlots</name></name> &amp;&amp;
                !<call><name>memcmp</name><argument_list>(<argument><expr><name><name>exits</name><index>[<expr><name>n</name></expr>]</index></name>-&gt;<call><name>fullTypeMap</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>typemap</name></expr></argument>, <argument><expr><name>typemap_size</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>mergedLoopExits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_JIT_SPEW</name></expr></cpp:if>
                <expr_stmt><expr><call><name>TreevisLogExit</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return <expr><name>e</name></expr>;</return>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

    <comment type="block">/* We couldn't find a matching side exit, so create a new one. */</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr>(<name>VMSideExit</name>*)
        <call><name>traceAlloc</name><argument_list>()</argument_list></call>.<call><name>alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VMSideExit</name></expr></argument>)</argument_list></sizeof> + (<name>stackSlots</name> + <name>ngslots</name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Setup side exit structure. */</comment>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>from</name></name> = <name>fragment</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>calldepth</name></name> = <name>callDepth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>numGlobalSlots</name></name> = <name>ngslots</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>numStackSlots</name></name> = <name>stackSlots</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>numStackSlotsBelowCurrentFrame</name></name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name></name> ?
                                           <call><name>nativeStackOffset</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>)</argument_list></call> / <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> :
                                           0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>exitType</name></name> = <name>exitType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>block</name></name> = <name><name>fp</name>-&gt;<name>blockChain</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>blockChain</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>gcthings</name>.<name>addUnique</name></name><argument_list>(<argument><expr><call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>blockChain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>pc</name></name> = <name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>imacpc</name></name> = <name><name>fp</name>-&gt;<name>imacpc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>sp_adj</name></name> = (<name>stackSlots</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof>) - <name><name>tree</name>-&gt;<name>nativeStackBase</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>rp_adj</name></name> = <name><name>exit</name>-&gt;<name>calldepth</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name>*</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>nativeCalleeWord</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>lookupFlags</name></name> = <call><name>js_InferFlags</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name><name>exit</name>-&gt;<name>fullTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>typemap</name></expr></argument>, <argument><expr><name>typemap_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_JIT_SPEW</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TreevisLogExit</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>exit</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>GuardRecord</name>*</type>
<name><name>TraceRecorder</name>::<name>createGuardRecord</name></name><parameter_list>(<param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
    <comment type="line">// For debug builds, place the guard records in a longer lasting</comment>
    <comment type="line">// pool.  This is because the fragment profiler will look at them</comment>
    <comment type="line">// relatively late in the day, after they would have been freed,</comment>
    <comment type="line">// in some cases, had they been allocated in traceAlloc().</comment>
    <decl_stmt><decl><type><name>GuardRecord</name>*</type> <name>gr</name> <init>= <expr>new (<call><name>dataAlloc</name><argument_list>()</argument_list></call>) <call><name>GuardRecord</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="line">// The standard place (for production builds).</comment>
    <decl_stmt><decl><type><name>GuardRecord</name>*</type> <name>gr</name> <init>= <expr>new (<call><name>traceAlloc</name><argument_list>()</argument_list></call>) <call><name>GuardRecord</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>gr</name>-&gt;<name>exit</name></name> = <name>exit</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>exit</name>-&gt;<name>addGuard</name></name><argument_list>(<argument><expr><name>gr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// gr-&gt;profCount is calloc'd to zero</comment>
    <macro><name>verbose_only</name><argument_list>(
        <argument>gr-&gt;profGuardID = fragment-&gt;guardNumberer++;
        gr-&gt;nextInFrag = fragment-&gt;guardsForFrag;
        fragment-&gt;guardsForFrag = gr;</argument>
    )</argument_list></macro>

    <return>return <expr><name>gr</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Emit a guard for condition (cond), expecting to evaluate to boolean result
 * (expected) and using the supplied side exit if the conditon doesn't hold.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>guard</name></name><parameter_list>(<param><decl><type><name>bool</name></type> <name>expected</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>cond</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>,
                      <argument><expr>"    About to try emitting guard code for "
                      "SideExit=%p exitType=%s\n"</expr></argument>,
                      <argument><expr>(<name>void</name>*)<name>exit</name></expr></argument>, <argument><expr><call><name>getExitName</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>GuardRecord</name>*</type> <name>guardRec</name> <init>= <expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>LOOP_EXIT</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>sideExits</name>.<name>add</name></name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>!<call><name><name>cond</name>-&gt;<name>isCmp</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>expected</name> = !<name>expected</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cond</name> = <call><name><name>cond</name>-&gt;<name>isI32</name></name><argument_list>()</argument_list></call> ? <call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call> : <call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>guardIns</name> <init>=
        <expr><call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>expected</name> ? <name>LIR_xf</name> : <name>LIR_xt</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>guardRec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>guardIns</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>,
                          <argument><expr>"    redundant guard, eliminated, no codegen\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Emit a guard a 32-bit integer arithmetic operation op(d0, d1) and
 * using the supplied side exit if it overflows.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>guard_xov</name></name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>d0</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>d1</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>,
                      <argument><expr>"    About to try emitting guard_xov code for "
                      "SideExit=%p exitType=%s\n"</expr></argument>,
                      <argument><expr>(<name>void</name>*)<name>exit</name></expr></argument>, <argument><expr><call><name>getExitName</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>GuardRecord</name>*</type> <name>guardRec</name> <init>= <expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>OVERFLOW_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
      <case>case <expr><name>LIR_add</name></expr>:
        <expr_stmt><expr><name>op</name> = <name>LIR_addxov</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>LIR_sub</name></expr>:
        <expr_stmt><expr><name>op</name> = <name>LIR_subxov</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>LIR_mul</name></expr>:
        <expr_stmt><expr><name>op</name> = <name>LIR_mulxov</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"unexpected comparison op"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>guardIns</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insGuardXov</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>d0</name></expr></argument>, <argument><expr><name>d1</name></expr></argument>, <argument><expr><name>guardRec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>guardIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>guardIns</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>VMSideExit</name>*</type>
<name><name>TraceRecorder</name>::<name>copy</name></name><parameter_list>(<param><decl><type><name>VMSideExit</name>*</type> <name>copy</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>typemap_size</name> <init>= <expr><name><name>copy</name>-&gt;<name>numGlobalSlots</name></name> + <name><name>copy</name>-&gt;<name>numStackSlots</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr>(<name>VMSideExit</name>*)
        <call><name>traceAlloc</name><argument_list>()</argument_list></call>.<call><name>alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VMSideExit</name></expr></argument>)</argument_list></sizeof> + <name>typemap_size</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Copy side exit structure. */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>exit</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VMSideExit</name></expr></argument>)</argument_list></sizeof> + <name>typemap_size</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>guards</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>from</name></name> = <name>fragment</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>target</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>LOOP_EXIT</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>sideExits</name>.<name>add</name></name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_JIT_SPEW</name></expr></cpp:if>
    <expr_stmt><expr><call><name>TreevisLogExit</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>exit</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Emit a guard for condition (cond), expecting to evaluate to boolean result
 * (expected) and generate a side exit with type exitType to jump to if the
 * condition does not hold.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>guard</name></name><parameter_list>(<param><decl><type><name>bool</name></type> <name>expected</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>cond</name></decl></param>, <param><decl><type><name>ExitType</name></type> <name>exitType</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>exitType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Determine whether any context associated with the same thread as cx is
 * executing native code.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>ProhibitFlush</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>interpState</name></name></expr>)</condition><then> <comment type="line">// early out if the given is in native code</comment>
        <return>return <expr>true</expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSCList</name> *</type><name>cl</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSThread</name>*</type> <name>thread</name> <init>= <expr><name><name>cx</name>-&gt;<name>thread</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init><expr><name>cl</name> = <name><name>thread</name>-&gt;<name>contextList</name>.<name>next</name></name></expr>;</init> <condition><expr><name>cl</name> != &amp;<name><name>thread</name>-&gt;<name>contextList</name></name></expr>;</condition> <incr><expr><name>cl</name> = <name><name>cl</name>-&gt;<name>next</name></name></expr></incr>)
        <if>if <condition>(<expr><call><name>CX_FROM_THREAD_LINKS</name><argument_list>(<argument><expr><name>cl</name></expr></argument>)</argument_list></call>-&gt;<name>interpState</name></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>JSRuntime</name>*</type> <name>rt</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init><expr><name>cl</name> = <name><name>rt</name>-&gt;<name>contextList</name>.<name>next</name></name></expr>;</init> <condition><expr><name>cl</name> != &amp;<name><name>rt</name>-&gt;<name>contextList</name></name></expr>;</condition> <incr><expr><name>cl</name> = <name><name>cl</name>-&gt;<name>next</name></name></expr></incr>)
        <if>if <condition>(<expr><call><name>js_ContextFromLinkField</name><argument_list>(<argument><expr><name>cl</name></expr></argument>)</argument_list></call>-&gt;<name>interpState</name></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>false</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetJITImpl</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>TRACING_ENABLED</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return;</return></then></if>
    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Flushing cache.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>recorder</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT_NOT_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"flush cache"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>ProhibitFlush</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Deferring JIT flush due to deep bail.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tm</name>-&gt;<name>needFlush</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>tm</name>-&gt;<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Compile the current fragment. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>compile</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
    <function_decl><type><name>TraceVisStateObj</name></type> <name>tvso</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>S_COMPILE</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name><name>traceMonitor</name>-&gt;<name>needFlush</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_DEEP_BAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>tree</name>-&gt;<name>maxNativeStackSlots</name></name> &gt;= <name>MAX_NATIVE_STACK_SLOTS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Blacklist: excessive stack use.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr>(<name>jsbytecode</name>*)<name><name>tree</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>anchor</name> &amp;&amp; <name><name>anchor</name>-&gt;<name>exitType</name></name> != <name>CASE_EXIT</name></expr>)</condition><then>
        <expr_stmt><expr>++<name><name>tree</name>-&gt;<name>branchCount</name></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return></then></if>

    <comment type="block">/* :TODO: windows support */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG</name> &amp;&amp; !<name>defined</name> <name>WIN32</name></expr></cpp:if>
    <comment type="block">/* Associate a filename and line number with the fragment. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>filename</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>label</name> <init>= <expr>(<name>char</name>*)<call><name>js_malloc</name><argument_list>(<argument><expr>(<name>filename</name> ? <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> : 7) + 16</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>label</name></expr></argument>, <argument><expr>"%s:%u"</expr></argument>, <argument><expr><name>filename</name> ? <name>filename</name> : "&lt;stdin&gt;"</expr></argument>,
            <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>lirbuf</name>-&gt;<name>printer</name>-&gt;<name>addrNameMap</name>-&gt;<name>addAddrRange</name></name><argument_list>(<argument><expr><name>fragment</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Fragment</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>Assembler</name> *</type><name>assm</name> <init>= <expr><name><name>traceMonitor</name>-&gt;<name>assembler</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>assm</name>-&gt;<name>error</name></name><argument_list>()</argument_list></call> == <name><name>nanojit</name>::<name>None</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>assm</name>-&gt;<name>compile</name></name><argument_list>(<argument><expr><name>fragment</name></expr></argument>, <argument><expr><call><name>tempAlloc</name><argument_list>()</argument_list></call></expr></argument>, <comment type="block">/*optimize*/</comment><argument><expr>true <call><name>verbose_only</name><argument_list>(, <argument><expr><name><name>lirbuf</name>-&gt;<name>printer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>assm</name>-&gt;<name>error</name></name><argument_list>()</argument_list></call> != <name><name>nanojit</name>::<name>None</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>assm</name>-&gt;<name>setError</name></name><argument_list>(<argument><expr><name><name>nanojit</name>::<name>None</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Blacklisted: error during compilation\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr>(<name>jsbytecode</name>*)<name><name>tree</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>ResetRecordingAttempts</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>*)<name><name>fragment</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ResetRecordingAttempts</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>*)<name><name>tree</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>anchor</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NANOJIT_IA32</name></cpp:ifdef>
        <if>if <condition>(<expr><name><name>anchor</name>-&gt;<name>exitType</name></name> == <name>CASE_EXIT</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>assm</name>-&gt;<name>patch</name></name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><name><name>anchor</name>-&gt;<name>switchInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name><name>assm</name>-&gt;<name>patch</name></name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>fragment</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>fragment</name> == <name><name>fragment</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>fragment</name>-&gt;<name>root</name></name> == <name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>JoinPeers</name><parameter_list>(<param><decl><type><name>Assembler</name>*</type> <name>assm</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>target</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>target</name></name> = <name>target</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>assm</name>-&gt;<name>patch</name></name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"TREEVIS JOIN ANCHOR=%p FRAG=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>exit</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>exit</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call> == <name>target</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <expr_stmt><expr><call><name><name>target</name>-&gt;<name>dependentTrees</name>.<name>addUnique</name></name><argument_list>(<argument><expr><call><name><name>exit</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>exit</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call>-&gt;<call><name><name>linkedTrees</name>.<name>addUnique</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Results of trying to connect an arbitrary type A with arbitrary type B */</comment>
<enum>enum <name>TypeCheckResult</name>
<block>{
    <decl><name>TypeCheck_Okay</name></decl>,         <comment type="block">/* Okay: same type */</comment>
    <decl><name>TypeCheck_Promote</name></decl>,      <comment type="block">/* Okay: Type A needs f2i() */</comment>
    <decl><name>TypeCheck_Demote</name></decl>,       <comment type="block">/* Okay: Type A needs i2f() */</comment>
    <decl><name>TypeCheck_Undemote</name></decl>,     <comment type="block">/* Bad: Slot is undemotable */</comment>
    <decl><name>TypeCheck_Bad</name></decl>           <comment type="block">/* Bad: incompatible types */</comment>
}</block>;</enum>

<class>class <name>SlotMap</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
  </private><public>public:
    <struct>struct <name>SlotInfo</name>
    <block>{<public type="default">
        <constructor><name>SlotInfo</name><parameter_list>()</parameter_list>
          <member_list>: <call><name>vp</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>, <call><name>promoteInt</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call>, <call><name>lastCheck</name><argument_list>(<argument><expr><name>TypeCheck_Bad</name></expr></argument>)</argument_list></call>
        </member_list><block>{}</block></constructor>
        <constructor><name>SlotInfo</name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>, <param><decl><type><name>bool</name></type> <name>promoteInt</name></decl></param>)</parameter_list>
          <member_list>: <call><name>vp</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call>, <call><name>promoteInt</name><argument_list>(<argument><expr><name>promoteInt</name></expr></argument>)</argument_list></call>, <call><name>lastCheck</name><argument_list>(<argument><expr><name>TypeCheck_Bad</name></expr></argument>)</argument_list></call>, <call><name>type</name><argument_list>(<argument><expr><call><name>getCoercedType</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
        </member_list><block>{}</block></constructor>
        <constructor><name>SlotInfo</name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>, <param><decl><type><name>TraceType</name></type> <name>t</name></decl></param>)</parameter_list>
          <member_list>: <call><name>vp</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call>, <call><name>promoteInt</name><argument_list>(<argument><expr><name>t</name> == <name>TT_INT32</name></expr></argument>)</argument_list></call>, <call><name>lastCheck</name><argument_list>(<argument><expr><name>TypeCheck_Bad</name></expr></argument>)</argument_list></call>, <call><name>type</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call>
        </member_list><block>{}</block></constructor>
        <decl_stmt><decl><type><name>jsval</name>           *</type><name>vp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>            <name>promoteInt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TypeCheckResult</name></type> <name>lastCheck</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TraceType</name></type>     <name>type</name></decl>;</decl_stmt>
    </public>}</block>;</struct>

    <constructor><name>SlotMap</name><parameter_list>(<param><decl><type><name>TraceRecorder</name>&amp;</type> <name>rec</name></decl></param>)</parameter_list>
        <member_list>: <call><name>mRecorder</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call>,
          <call><name>mCx</name><argument_list>(<argument><expr><name><name>rec</name>.<name>cx</name></name></expr></argument>)</argument_list></call>,
          <call><name>slots</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
    </member_list><block>{
    }</block></constructor>

    <destructor><specifier>virtual</specifier> <name>~<name>SlotMap</name></name><parameter_list>()</parameter_list>
    <block>{
    }</block></destructor>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>visitGlobalSlot</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>addSlot</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>JS_ALWAYS_INLINE</name> <name><name>SlotMap</name>::<name>SlotInfo</name></name>&amp;</type>
    <name>operator []</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>i</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
    }</block></function>

    <function><type><name>JS_ALWAYS_INLINE</name> <name><name>SlotMap</name>::<name>SlotInfo</name></name>&amp;</type>
    <name>get</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>i</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
    }</block></function>

    <function><type><name>JS_ALWAYS_INLINE</name> <name>unsigned</name></type>
    <name>length</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>slots</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="doxygen">/**
     * Possible return states:
     *
     * TypeConsensus_Okay:      All types are compatible. Caller must go through slot list and handle
     *                          promote/demotes.
     * TypeConsensus_Bad:       Types are not compatible. Individual type check results are undefined.
     * TypeConsensus_Undemotes: Types would be compatible if slots were marked as undemotable
     *                          before recording began. Caller can go through slot list and mark
     *                          such slots as undemotable.
     */</comment>
    <function><type><name>JS_REQUIRES_STACK</name> <name>TypeConsensus</name></type>
    <name>checkTypes</name><parameter_list>(<param><decl><type><name>LinkableFragment</name>*</type> <name>f</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name>length</name><argument_list>()</argument_list></call> != <call><name><name>f</name>-&gt;<name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>TypeConsensus_Bad</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>bool</name></type> <name>has_undemotes</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name>length</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>TypeCheckResult</name></type> <name>result</name> <init>= <expr><call><name>checkType</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>typeMap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>result</name> == <name>TypeCheck_Bad</name></expr>)</condition><then>
                <return>return <expr><name>TypeConsensus_Bad</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name>result</name> == <name>TypeCheck_Undemote</name></expr>)</condition><then>
                <expr_stmt><expr><name>has_undemotes</name> = true</expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>lastCheck</name> = <name>result</name></expr>;</expr_stmt>
        }</block></for>
        <if>if <condition>(<expr><name>has_undemotes</name></expr>)</condition><then>
            <return>return <expr><name>TypeConsensus_Undemotes</name></expr>;</return></then></if>
        <return>return <expr><name>TypeConsensus_Okay</name></expr>;</return>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>addSlot</name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>bool</name></type> <name>promoteInt</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<decl><type><name>LIns</name>*</type> <name>i</name> <init>= <expr><call><name><name>mRecorder</name>.<name>getFromTracker</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then> <block>{
                <expr_stmt><expr><name>promoteInt</name> = <call><name>isPromoteInt</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><call><name><name>mRecorder</name>.<name>isGlobal</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name><name>mRecorder</name>.<name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>offsetOf</name></name><argument_list>(<argument><expr><call><name>uint16</name><argument_list>(<argument><expr><call><name><name>mRecorder</name>.<name>nativeGlobalSlot</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>offset</name> != -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>promoteInt</name> = <name><name>mRecorder</name>.<name>importTypeMap</name><index>[<expr><name><name>mRecorder</name>.<name>importStackSlots</name></name> + <name>offset</name></expr>]</index></name> ==
                             <name>TT_INT32</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>promoteInt</name> = <name><name>mRecorder</name>.<name>importTypeMap</name><index>[<expr><call><name><name>mRecorder</name>.<name>nativeStackSlot</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>]</index></name> ==
                             <name>TT_INT32</name></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>slots</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>SlotInfo</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>promoteInt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>addSlot</name><parameter_list>(<param><decl><type><name>TraceType</name></type> <name>t</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>slots</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>SlotInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>addSlot</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>TraceType</name></type> <name>t</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>slots</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>SlotInfo</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
    <name>markUndemotes</name><parameter_list>()</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name>length</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name>get</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<name>lastCheck</name> == <name>TypeCheck_Undemote</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>MarkSlotUndemotable</name><argument_list>(<argument><expr><name><name>mRecorder</name>.<name>cx</name></name></expr></argument>, <argument><expr><name><name>mRecorder</name>.<name>tree</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <specifier>virtual</specifier> <name>void</name></type>
    <name>adjustTail</name><parameter_list>(<param><decl><type><name>TypeConsensus</name></type> <name>consensus</name></decl></param>)</parameter_list>
    <block>{
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <specifier>virtual</specifier> <name>void</name></type>
    <name>adjustTypes</name><parameter_list>()</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name>length</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><call><name>adjustType</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

  </public><protected>protected:
    <function><type><name>JS_REQUIRES_STACK</name> <specifier>virtual</specifier> <name>void</name></type>
    <name>adjustType</name><parameter_list>(<param><decl><type><name>SlotInfo</name>&amp;</type> <name>info</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>info</name>.<name>lastCheck</name></name> != <name>TypeCheck_Undemote</name> &amp;&amp; <name><name>info</name>.<name>lastCheck</name></name> != <name>TypeCheck_Bad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>info</name>.<name>lastCheck</name></name> == <name>TypeCheck_Promote</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>info</name>.<name>type</name></name> == <name>TT_INT32</name> || <name><name>info</name>.<name>type</name></name> == <name>TT_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mRecorder</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>vp</name></name></expr></argument>, <argument><expr><call><name><name>mRecorder</name>.<name>f2i</name></name><argument_list>(<argument><expr><call><name><name>mRecorder</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>vp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>info</name>.<name>lastCheck</name></name> == <name>TypeCheck_Demote</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>info</name>.<name>type</name></name> == <name>TT_INT32</name> || <name><name>info</name>.<name>type</name></name> == <name>TT_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>mRecorder</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>vp</name></name></expr></argument>)</argument_list></call>-&gt;<call><name>isF64</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Never demote this final i2f. */</comment>
            <expr_stmt><expr><call><name><name>mRecorder</name>.<name>set</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>vp</name></name></expr></argument>, <argument><expr><call><name><name>mRecorder</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>vp</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></function>

  </protected><private>private:
    <function><type><name>TypeCheckResult</name></type>
    <name>checkType</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>i</name></decl></param>, <param><decl><type><name>TraceType</name></type> <name>t</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"checkType slot %d: interp=%c typemap=%c isNum=%d promoteInt=%d\n"</expr></argument>,
                          <argument><expr><name>i</name></expr></argument>,
                          <argument><expr><name><name>typeChar</name><index>[<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>type</name></expr>]</index></name></expr></argument>,
                          <argument><expr><name><name>typeChar</name><index>[<expr><name>t</name></expr>]</index></name></expr></argument>,
                          <argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>type</name> == <name>TT_INT32</name> || <name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>type</name> == <name>TT_DOUBLE</name></expr></argument>,
                          <argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>promoteInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>t</name></expr>)</condition> <block>{
          <case>case <expr><name>TT_INT32</name></expr>:
            <if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>type</name> != <name>TT_INT32</name> &amp;&amp; <name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>type</name> != <name>TT_DOUBLE</name></expr>)</condition><then>
                <return>return <expr><name>TypeCheck_Bad</name></expr>;</return></then></if> <comment type="block">/* Not a number? Type mismatch. */</comment>
            <comment type="block">/* This is always a type mismatch, we can't close a double to an int. */</comment>
            <if>if <condition>(<expr>!<name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>promoteInt</name></expr>)</condition><then>
                <return>return <expr><name>TypeCheck_Undemote</name></expr>;</return></then></if>
            <comment type="block">/* Looks good, slot is an int32, the last instruction should be promotable. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>vp</name></expr></argument>, <argument><expr><call><name>isInt32</name><argument_list>(<argument><expr>*<name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>vp</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>promoteInt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>vp</name> ? <name>TypeCheck_Promote</name> : <name>TypeCheck_Okay</name></expr>;</return>
          </case><case>case <expr><name>TT_DOUBLE</name></expr>:
            <if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>type</name> != <name>TT_INT32</name> &amp;&amp; <name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>type</name> != <name>TT_DOUBLE</name></expr>)</condition><then>
                <return>return <expr><name>TypeCheck_Bad</name></expr>;</return></then></if> <comment type="block">/* Not a number? Type mismatch. */</comment>
            <if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>promoteInt</name></expr>)</condition><then>
                <return>return <expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>vp</name> ? <name>TypeCheck_Demote</name> : <name>TypeCheck_Bad</name></expr>;</return></then></if>
            <return>return <expr><name>TypeCheck_Okay</name></expr>;</return>
          </case><default>default:
            <return>return <expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>type</name> == <name>t</name> ? <name>TypeCheck_Okay</name> : <name>TypeCheck_Bad</name></expr>;</return>
        </default>}</block></switch>
        <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"shouldn't fall through type check switch"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>
  </private><protected>protected:
    <decl_stmt><decl><type><name>TraceRecorder</name>&amp;</type> <name>mRecorder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name>*</type> <name>mCx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Queue</name><argument_list>&lt;<argument><expr><name>SlotInfo</name></expr></argument>&gt;</argument_list></name></type> <name>slots</name></decl>;</decl_stmt>
</protected>}</block>;</class>

<class>class <name>DefaultSlotMap</name> <super>: <specifier>public</specifier> <name>SlotMap</name></super>
<block>{<private type="default">
  </private><public>public:
    <constructor><name>DefaultSlotMap</name><parameter_list>(<param><decl><type><name>TraceRecorder</name>&amp;</type> <name>tr</name></decl></param>)</parameter_list> <member_list>: <call><name>SlotMap</name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call>
    </member_list><block>{
    }</block></constructor>
    
    <destructor><specifier>virtual</specifier> <name>~<name>DefaultSlotMap</name></name><parameter_list>()</parameter_list>
    <block>{
    }</block></destructor>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
    <name>visitStackSlots</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><call><name>addSlot</name><argument_list>(<argument><expr>&amp;<name><name>vp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>
</public>}</block>;</class>

<function><type><name>JS_REQUIRES_STACK</name> <name>TypeConsensus</name></type>
<name><name>TraceRecorder</name>::<name>selfTypeStability</name></name><parameter_list>(<param><decl><type><name>SlotMap</name>&amp;</type> <name>slotMap</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Checking type stability against self=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>fragment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>TypeConsensus</name></type> <name>consensus</name> <init>= <expr><call><name><name>slotMap</name>.<name>checkTypes</name></name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Best case: loop jumps back to its own header */</comment>
    <if>if <condition>(<expr><name>consensus</name> == <name>TypeConsensus_Okay</name></expr>)</condition><then>
        <return>return <expr><name>TypeConsensus_Okay</name></expr>;</return></then></if>

    <comment type="block">/* If the only thing keeping this loop from being stable is undemotions, then mark relevant
     * slots as undemotable.
     */</comment>
    <if>if <condition>(<expr><name>consensus</name> == <name>TypeConsensus_Undemotes</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>slotMap</name>.<name>markUndemotes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>consensus</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>TypeConsensus</name></type>
<name><name>TraceRecorder</name>::<name>peerTypeStability</name></name><parameter_list>(<param><decl><type><name>SlotMap</name>&amp;</type> <name>slotMap</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>ip</name></decl></param>, <param><decl><type><name>TreeFragment</name>**</type> <name>pPeer</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* See if there are any peers that would make this stable */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>fragment</name>-&gt;<name>root</name></name> == <name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>peer</name> <init>= <expr><call><name>LookupLoop</name><argument_list>(<argument><expr><name>traceMonitor</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>globalObj</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>globalShape</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* This condition is possible with recursion */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name>peer</name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>ip</name></name> != <name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>peer</name></expr>)</condition><then>
        <return>return <expr><name>TypeConsensus_Bad</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>bool</name></type> <name>onlyUndemotes</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init> <condition><expr><name>peer</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>peer</name> = <name><name>peer</name>-&gt;<name>peer</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name><name>peer</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call> || <name>peer</name> == <name>fragment</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Checking type stability against peer=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>TypeConsensus</name></type> <name>consensus</name> <init>= <expr><call><name><name>slotMap</name>.<name>checkTypes</name></name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>consensus</name> == <name>TypeConsensus_Okay</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>pPeer</name> = <name>peer</name></expr>;</expr_stmt>
            <comment type="block">/* Return this even though there will be linkage; the trace itself is not stable.
             * Caller should inspect ppeer to check for a compatible peer.
             */</comment>
            <return>return <expr><name>TypeConsensus_Okay</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>consensus</name> == <name>TypeConsensus_Undemotes</name></expr>)</condition><then>
            <expr_stmt><expr><name>onlyUndemotes</name> = true</expr>;</expr_stmt></then></if>
    }</block></for>

    <return>return <expr><name>onlyUndemotes</name> ? <name>TypeConsensus_Undemotes</name> : <name>TypeConsensus_Bad</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>closeLoop</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>closeLoop</name><argument_list>(<argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>UNSTABLE_LOOP_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>closeLoop</name></name><parameter_list>(<param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>DefaultSlotMap</name></type> <name>slotMap</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitSlots</name><argument_list>(<argument><expr><name>slotMap</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>*<name><name>tree</name>-&gt;<name>globalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>closeLoop</name><argument_list>(<argument><expr><name>slotMap</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Complete and compile a trace and link it to the existing tree if
 * appropriate.  Returns ARECORD_ABORTED or ARECORD_STOP, depending on whether
 * the recorder was deleted. Outparam is always set.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>closeLoop</name></name><parameter_list>(<param><decl><type><name>SlotMap</name>&amp;</type> <name>slotMap</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * We should have arrived back at the loop header, and hence we don't want
     * to be in an imacro here and the opcode should be either JSOP_TRACE or, in
     * case this loop was blacklisted in the meantime, JSOP_NOP.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_TRACE</name> || *<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_NOP</name> ||
               *<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_RETURN</name> || *<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_STOP</name>) &amp;&amp;
              !<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>callDepth</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"Blacklisted: stack depth mismatch, possible recursion.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr>(<name>jsbytecode</name>*)<name><name>tree</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>trashSelf</name> = true</expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>UNSTABLE_LOOP_EXIT</name></expr></argument>,
                 <argument><expr><name><name>exit</name>-&gt;<name>numStackSlots</name></name> == <name><name>tree</name>-&gt;<name>nStackTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name> != <name>UNSTABLE_LOOP_EXIT</name></expr></argument>, <argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_UNLINKED_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_UNLINKED_EXIT</name></expr></argument>,
                 <argument><expr><name><name>exit</name>-&gt;<name>recursive_pc</name></name> != <name><name>tree</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>fragment</name>-&gt;<name>root</name></name> == <name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>peer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TypeConsensus</name></type> <name>consensus</name> <init>= <expr><name>TypeConsensus_Bad</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>UNSTABLE_LOOP_EXIT</name></expr>)</condition><then>
        <expr_stmt><expr><name>consensus</name> = <call><name>selfTypeStability</name><argument_list>(<argument><expr><name>slotMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>consensus</name> != <name>TypeConsensus_Okay</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>ip</name> <init>= <expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_UNLINKED_EXIT</name> ?
                         <name><name>exit</name>-&gt;<name>recursive_pc</name></name> : <name><name>tree</name>-&gt;<name>ip</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TypeConsensus</name></type> <name>peerConsensus</name> <init>= <expr><call><name>peerTypeStability</name><argument_list>(<argument><expr><name>slotMap</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr>&amp;<name>peer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/* If there was a semblance of a stable peer (even if not linkable), keep the result. */</comment>
        <if>if <condition>(<expr><name>peerConsensus</name> != <name>TypeConsensus_Bad</name></expr>)</condition><then>
            <expr_stmt><expr><name>consensus</name> = <name>peerConsensus</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEBUG</name></expr></cpp:if>
    <if>if <condition>(<expr><name>consensus</name> != <name>TypeConsensus_Okay</name> || <name>peer</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>unstableLoopVariable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>trashSelf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * This exit is indeed linkable to something now. Process any promote or
     * demotes that are pending in the slot map.
     */</comment>
    <if>if <condition>(<expr><name>consensus</name> == <name>TypeConsensus_Okay</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>slotMap</name>.<name>adjustTypes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Give up-recursion a chance to pop the stack frame. */</comment>
    <expr_stmt><expr><call><name><name>slotMap</name>.<name>adjustTail</name></name><argument_list>(<argument><expr><name>consensus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>consensus</name> != <name>TypeConsensus_Okay</name> || <name>peer</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>fragment</name>-&gt;<name>lastIns</name></name> = <call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_x</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If there is a peer, there must have been an "Okay" consensus. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>peer</name></expr></argument>, <argument><expr><name>consensus</name> == <name>TypeConsensus_Okay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Compile as a type-unstable loop, and hope for a connection later. */</comment>
        <if>if <condition>(<expr>!<name>peer</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If such a fragment does not exist, let's compile the loop ahead
             * of time anyway.  Later, if the loop becomes type stable, we will
             * connect these two fragments together.
             */</comment>
            <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                              <argument><expr>"Trace has unstable loop variable with no stable peer, "
                              "compiling anyway.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>UnstableExit</name>*</type> <name>uexit</name> <init>= <expr>new (<call><name>traceAlloc</name><argument_list>()</argument_list></call>) <name>UnstableExit</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>uexit</name>-&gt;<name>fragment</name></name> = <name>fragment</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uexit</name>-&gt;<name>exit</name></name> = <name>exit</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uexit</name>-&gt;<name>next</name></name> = <name><name>tree</name>-&gt;<name>unstableExits</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tree</name>-&gt;<name>unstableExits</name></name> = <name>uexit</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>peer</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>exit</name>-&gt;<name>target</name></name> = <name>peer</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                              <argument><expr>"Joining type-unstable trace to target fragment %p.\n"</expr></argument>,
                              <argument><expr>(<name>void</name>*)<name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>peer</name>-&gt;<name>dependentTrees</name>.<name>addUnique</name></name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>linkedTrees</name>.<name>addUnique</name></name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>exit</name>-&gt;<name>exitType</name></name> = <name>LOOP_EXIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"TREEVIS CHANGEEXIT EXIT=%p TYPE=%s\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>exit</name></expr></argument>,
                          <argument><expr><call><name>getExitName</name><argument_list>(<argument><expr><name>LOOP_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>fragment</name> == <name><name>fragment</name>-&gt;<name>root</name></name>) == !!<name>loopLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>loopLabel</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>loopLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_plive</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name><name>exit</name>-&gt;<name>target</name></name> = <name>tree</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fragment</name>-&gt;<name>lastIns</name></name> = <call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_x</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>compile</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"TREEVIS CLOSELOOP EXIT=%p PEER=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>exit</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>LookupLoop</name><argument_list>(<argument><expr><name>traceMonitor</name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>ip</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>globalObj</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>globalShape</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call> ==
              <name><name>tree</name>-&gt;<name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tree</name>-&gt;<name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>peer</name> = <name><name>tree</name>-&gt;<name>first</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>joinEdgesToEntry</name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>debug_only_stmt</name><argument_list>(<argument>DumpPeerStability(traceMonitor, peer-&gt;ip, peer-&gt;globalObj,
                                      peer-&gt;globalShape, peer-&gt;argc);</argument>)</argument_list></macro>

    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                      <argument><expr>"updating specializations on dependent and linked trees\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>tree</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SpecializeTreesToMissingGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * If this is a newly formed tree, and the outer tree has not been compiled yet, we
     * should try to compile the outer tree again.
     */</comment>
    <if>if <condition>(<expr><name>outer</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>AttemptCompilation</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>, <argument><expr><name>outerArgc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMMinimal</name></expr></argument>,
                      <argument><expr>"Recording completed at  %s:%u@%u via closeLoop (FragID=%06u)\n"</expr></argument>,
                      <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></argument>,
                      <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>fragment</name>-&gt;<name>profFragID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMMinimal</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><call><name>finishSuccessfully</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FullMapFromExit</name><parameter_list>(<param><decl><type><name>TypeMap</name>&amp;</type> <name>typeMap</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>typeMap</name>.<name>setLength</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>typeMap</name>.<name>fromRaw</name></name><argument_list>(<argument><expr><call><name><name>exit</name>-&gt;<name>stackTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>exit</name>-&gt;<name>numStackSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>typeMap</name>.<name>fromRaw</name></name><argument_list>(<argument><expr><call><name><name>exit</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>exit</name>-&gt;<name>numGlobalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Include globals that were later specialized at the root of the tree. */</comment>
    <if>if <condition>(<expr><name><name>exit</name>-&gt;<name>numGlobalSlots</name></name> &lt; <call><name><name>exit</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call>-&gt;<call><name>nGlobalTypes</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>typeMap</name>.<name>fromRaw</name></name><argument_list>(<argument><expr><call><name><name>exit</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call>-&gt;<call><name>globalTypeMap</name><argument_list>()</argument_list></call> + <name><name>exit</name>-&gt;<name>numGlobalSlots</name></name></expr></argument>,
                        <argument><expr><call><name><name>exit</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call>-&gt;<call><name>nGlobalTypes</name><argument_list>()</argument_list></call> - <name><name>exit</name>-&gt;<name>numGlobalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>TypeConsensus</name></type>
<name>TypeMapLinkability</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>TypeMap</name>&amp;</type> <name>typeMap</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>peer</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>TypeMap</name>&amp;</type> <name>peerMap</name> <init>= <expr><name><name>peer</name>-&gt;<name>typeMap</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>minSlots</name> <init>= <expr><call><name>JS_MIN</name><argument_list>(<argument><expr><call><name><name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>peerMap</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeConsensus</name></type> <name>consensus</name> <init>= <expr><name>TypeConsensus_Okay</name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>minSlots</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>typeMap</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>peerMap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
            <continue>continue;</continue></then></if>
        <if>if <condition>(<expr><name><name>typeMap</name><index>[<expr><name>i</name></expr>]</index></name> == <name>TT_INT32</name> &amp;&amp; <name><name>peerMap</name><index>[<expr><name>i</name></expr>]</index></name> == <name>TT_DOUBLE</name> &amp;&amp;
            <call><name>IsSlotUndemotable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>peer</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>peer</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>consensus</name> = <name>TypeConsensus_Undemotes</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <return>return <expr><name>TypeConsensus_Bad</name></expr>;</return>
        }</block></else></if>
    }</block></for>
    <return>return <expr><name>consensus</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>unsigned</name></type>
<name>FindUndemotesInTypemaps</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>TypeMap</name>&amp;</type> <name>typeMap</name></decl></param>, <param><decl><type><name>LinkableFragment</name>*</type> <name>f</name></decl></param>,
                        <param><decl><type><name><name>Queue</name><argument_list>&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>undemotes</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>undemotes</name>.<name>setLength</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>minSlots</name> <init>= <expr><call><name>JS_MIN</name><argument_list>(<argument><expr><call><name><name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>f</name>-&gt;<name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>minSlots</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>typeMap</name><index>[<expr><name>i</name></expr>]</index></name> == <name>TT_INT32</name> &amp;&amp; <name><name>f</name>-&gt;<name>typeMap</name><index>[<expr><name>i</name></expr>]</index></name> == <name>TT_DOUBLE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>undemotes</name>.<name>add</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>typeMap</name><index>[<expr><name>i</name></expr>]</index></name> != <name><name>f</name>-&gt;<name>typeMap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if></else></if>
    }</block></for>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>undemotes</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>MarkSlotUndemotable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>undemotes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <return>return <expr><call><name><name>undemotes</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>joinEdgesToEntry</name></name><parameter_list>(<param><decl><type><name>TreeFragment</name>*</type> <name>peer_root</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>fragment</name>-&gt;<name>root</name></name> != <name>fragment</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <function_decl><type><name>TypeMap</name></type> <name>typeMap</name><parameter_list>(<param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name><name>Queue</name><argument_list>&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>undemotes</name><parameter_list>(<param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</function_decl>

    <for>for (<init><decl><type><name>TreeFragment</name>*</type> <name>peer</name> <init>= <expr><name>peer_root</name></expr></init></decl>;</init> <condition><expr><name>peer</name></expr>;</condition> <incr><expr><name>peer</name> = <name><name>peer</name>-&gt;<name>peer</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name><name>peer</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>
        <decl_stmt><decl><type><name>UnstableExit</name>*</type> <name>uexit</name> <init>= <expr><name><name>peer</name>-&gt;<name>unstableExits</name></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>uexit</name> != <name>NULL</name></expr>)</condition> <block>{
            <comment type="block">/* :TODO: these exits go somewhere else. */</comment>
            <if>if <condition>(<expr><name><name>uexit</name>-&gt;<name>exit</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_UNLINKED_EXIT</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>uexit</name> = <name><name>uexit</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <comment type="block">/* Build the full typemap for this unstable exit */</comment>
            <expr_stmt><expr><call><name>FullMapFromExit</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>, <argument><expr><name><name>uexit</name>-&gt;<name>exit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Check its compatibility against this tree */</comment>
            <decl_stmt><decl><type><name>TypeConsensus</name></type> <name>consensus</name> <init>= <expr><call><name>TypeMapLinkability</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>typeMap</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>consensus</name> == <name>TypeConsensus_Okay</name></expr></argument>, <argument><expr><name>peer</name> != <name>fragment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>consensus</name> == <name>TypeConsensus_Okay</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                                  <argument><expr>"Joining type-stable trace to target exit %p-&gt;%p.\n"</expr></argument>,
                                  <argument><expr>(<name>void</name>*)<name><name>uexit</name>-&gt;<name>fragment</name></name></expr></argument>, <argument><expr>(<name>void</name>*)<name><name>uexit</name>-&gt;<name>exit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * See bug 531513. Before linking these trees, make sure the
                 * peer's dependency graph is up to date.
                 */</comment>
                <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>from</name> <init>= <expr><call><name><name>uexit</name>-&gt;<name>exit</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>from</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call> &lt; <call><name><name>tree</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>SpecializeTreesToLateGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><call><name><name>tree</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                 <argument><expr><call><name><name>tree</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <comment type="block">/* It's okay! Link together and remove the unstable exit. */</comment>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tree</name> == <name>fragment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JoinPeers</name><argument_list>(<argument><expr><name><name>traceMonitor</name>-&gt;<name>assembler</name></name></expr></argument>, <argument><expr><name><name>uexit</name>-&gt;<name>exit</name></name></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>uexit</name> = <call><name><name>peer</name>-&gt;<name>removeUnstableExit</name></name><argument_list>(<argument><expr><name><name>uexit</name>-&gt;<name>exit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <comment type="block">/* Check for int32-&gt;double slots that suggest trashing. */</comment>
                <if>if <condition>(<expr><call><name>FindUndemotesInTypemaps</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>typeMap</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>undemotes</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>peer</name> == <name><name>uexit</name>-&gt;<name>fragment</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>fragment</name> == <name>peer</name></expr>)</condition><then>
                        <expr_stmt><expr><name>trashSelf</name> = true</expr>;</expr_stmt></then>
                    <else>else
                        <expr_stmt><expr><call><name><name>whichTreesToTrash</name>.<name>addUnique</name></name><argument_list>(<argument><expr><name><name>uexit</name>-&gt;<name>fragment</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                    <return>return;</return>
                }</block></then></if>
                <expr_stmt><expr><name>uexit</name> = <name><name>uexit</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>
    }</block></for>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>endLoop</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>endLoop</name><argument_list>(<argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>LOOP_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Emit an always-exit guard and compile the tree (used for break statements. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>endLoop</name></name><parameter_list>(<param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>fragment</name>-&gt;<name>root</name></name> == <name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>callDepth</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Blacklisted: stack depth mismatch, possible recursion.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr>(<name>jsbytecode</name>*)<name><name>tree</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>trashSelf</name> = true</expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>recordReason</name> != <name>Record_Branch</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"control flow should have been recursive"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name><name>fragment</name>-&gt;<name>lastIns</name></name> =
        <call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_x</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>compile</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"TREEVIS ENDLOOP EXIT=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>LookupLoop</name><argument_list>(<argument><expr><name>traceMonitor</name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>ip</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>globalObj</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>globalShape</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call> ==
              <name><name>tree</name>-&gt;<name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>joinEdgesToEntry</name><argument_list>(<argument><expr><name><name>tree</name>-&gt;<name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>debug_only_stmt</name><argument_list>(<argument>DumpPeerStability(traceMonitor, tree-&gt;ip, tree-&gt;globalObj,
                                      tree-&gt;globalShape, tree-&gt;argc);</argument>)</argument_list></macro>

    <comment type="block">/*
     * Note: this must always be done, in case we added new globals on trace
     * and haven't yet propagated those to linked and dependent trees.
     */</comment>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                      <argument><expr>"updating specializations on dependent and linked trees\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>tree</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SpecializeTreesToMissingGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name><name>fragment</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * If this is a newly formed tree, and the outer tree has not been compiled
     * yet, we should try to compile the outer tree again.
     */</comment>
    <if>if <condition>(<expr><name>outer</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>AttemptCompilation</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>, <argument><expr><name>outerArgc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMMinimal</name></expr></argument>,
                      <argument><expr>"Recording completed at  %s:%u@%u via endLoop (FragID=%06u)\n"</expr></argument>,
                      <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></argument>,
                      <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>fragment</name>-&gt;<name>profFragID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><call><name>finishSuccessfully</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Emit code to adjust the stack to match the inner tree's stack expectations. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>prepareTreeCall</name></name><parameter_list>(<param><decl><type><name>TreeFragment</name>*</type> <name>inner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * The inner tree expects to be called from the current frame. If the outer
     * tree (this trace) is currently inside a function inlining code
     * (calldepth &gt; 0), we have to advance the native stack pointer such that
     * we match what the inner trace expects to see. We move it back when we
     * come out of the inner tree call.
     */</comment>
    <if>if <condition>(<expr><name>callDepth</name> &gt; 0</expr>)</condition><then> <block>{
        <comment type="block">/*
         * Calculate the amount we have to lift the native stack pointer by to
         * compensate for any outer frames that the inner tree doesn't expect
         * but the outer tree has.
         */</comment>
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>sp_adj</name> <init>= <expr><call><name>nativeStackOffset</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Calculate the amount we have to lift the call stack by. */</comment>
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>rp_adj</name> <init>= <expr><name>callDepth</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name>*</expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Guard that we have enough stack space for the tree we are trying to
         * call on top of the new value for sp.
         */</comment>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"sp_adj=%lld outer=%lld inner=%lld\n"</expr></argument>,
                          <argument><expr>(<name>long</name> <name>long</name> <name>int</name>)<name>sp_adj</name></expr></argument>,
                          <argument><expr>(<name>long</name> <name>long</name> <name>int</name>)<name><name>tree</name>-&gt;<name>nativeStackBase</name></name></expr></argument>,
                          <argument><expr>(<name>long</name> <name>long</name> <name>int</name>)<name><name>inner</name>-&gt;<name>nativeStackBase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>sp_offset</name> <init>=
                <expr>- <name><name>tree</name>-&gt;<name>nativeStackBase</name></name> <comment type="block">/* rebase sp to beginning of outer tree's stack */</comment>
                + <name>sp_adj</name> <comment type="block">/* adjust for stack in outer frame inner tree can't see */</comment>
                + <name><name>inner</name>-&gt;<name>maxNativeStackSlots</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt> <comment type="block">/* plus the inner tree's stack */</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>sp_top</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>sp_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_plt</name></expr></argument>, <argument><expr><name>sp_top</name></expr></argument>, <argument><expr><name>eos_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Guard that we have enough call stack space. */</comment>
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>rp_offset</name> <init>= <expr><name>rp_adj</name> + <name><name>inner</name>-&gt;<name>maxCallDepth</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name>*</expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>rp_top</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>rp</name></name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>rp_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_plt</name></expr></argument>, <argument><expr><name>rp_top</name></expr></argument>, <argument><expr><name>eor_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>sp_offset</name> =
                - <name><name>tree</name>-&gt;<name>nativeStackBase</name></name> <comment type="block">/* rebase sp to beginning of outer tree's stack */</comment>
                + <name>sp_adj</name> <comment type="block">/* adjust for stack in outer frame inner tree can't see */</comment>
                + <name><name>inner</name>-&gt;<name>nativeStackBase</name></name></expr>;</expr_stmt> <comment type="block">/* plus the inner tree's stack base */</comment>
        <comment type="block">/* We have enough space, so adjust sp and rp to their new level. */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>sp_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>rp</name></name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>rp_adj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * The inner tree will probably access stack slots. So tell nanojit not to
     * discard or defer stack writes before emitting the call tree code.
     *
     * (The ExitType of this snapshot is nugatory. The exit can't be taken.)
     */</comment>
    <decl_stmt><decl><type><name>GuardRecord</name>*</type> <name>guardRec</name> <init>= <expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_xbarrier</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>guardRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>BuildGlobalTypeMapFromInnerTree</name><parameter_list>(<param><decl><type><name><name>Queue</name><argument_list>&lt;<argument><expr><name>TraceType</name></expr></argument>&gt;</argument_list></name>&amp;</type> <name>typeMap</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>inner</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG</name></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>initialSlots</name> <init>= <expr><call><name><name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* First, use the innermost exit's global typemap. */</comment>
    <expr_stmt><expr><call><name><name>typeMap</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>inner</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>inner</name>-&gt;<name>numGlobalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add missing global types from the innermost exit's tree. */</comment>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>innerFrag</name> <init>= <expr><call><name><name>inner</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>slots</name> <init>= <expr><name><name>inner</name>-&gt;<name>numGlobalSlots</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>slots</name> &lt; <call><name><name>innerFrag</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>typeMap</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>innerFrag</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call> + <name>slots</name></expr></argument>, <argument><expr><call><name><name>innerFrag</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call> - <name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>slots</name> = <call><name><name>innerFrag</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call> - <name>initialSlots</name> == <name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>slots</name></expr>;</return>
}</block></function>

<comment type="block">/* Record a call to an inner tree. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>emitTreeCall</name></name><parameter_list>(<param><decl><type><name>TreeFragment</name>*</type> <name>inner</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Invoke the inner tree. */</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr> }</block></expr></init></decl>;</decl_stmt> <comment type="block">/* reverse order */</comment>
    <comment type="block">/* Construct a call info structure for the target tree. */</comment>
    <decl_stmt><decl><type><name>CallInfo</name>*</type> <name>ci</name> <init>= <expr>new (<call><name>traceAlloc</name><argument_list>()</argument_list></call>) <call><name>CallInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_address</name></name> = <call><name>uintptr_t</name><argument_list>(<argument><expr><call><name><name>inner</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>_address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_typesig</name></name> = <name>ARGTYPE_P</name> | <name>ARGTYPE_P</name> &lt;&lt; <name>ARGTYPE_SHIFT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_isPure</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_storeAccSet</name></name> = <name>ACC_STORE_ANY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_abi</name></name> = <name>ABI_FASTCALL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_name</name></name> = "fragment"</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>rec</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>lr</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>GuardRecord</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>nested</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>,
                                  <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>,
                                             <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>,
                                                          <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>VMSideExit</name></expr></argument>, <argument><expr><name>exitType</name></expr></argument>)</argument_list></call></expr></argument>,
                                                          <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name>NESTED_EXIT</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If the tree exits on a regular (non-nested) guard, keep updating lastTreeExitGuard
     * with that guard. If we mismatch on a tree call guard, this will contain the last
     * non-nested guard we encountered, which is the innermost loop or branch guard.
     */</comment>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>lastTreeExitGuard</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>done1</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * The tree exited on a nested guard. This only occurs once a tree call guard mismatches
     * and we unwind the tree call stack. We store the first (innermost) tree call guard in state
     * and we will try to grow the outer tree the failing call was in starting at that guard.
     */</comment>
    <expr_stmt><expr><call><name><name>nested</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>done2</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>,
                                 <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>,
                                                            <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>,
                                                            <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>lastTreeCallGuard</name></expr></argument>)</argument_list></call></expr></argument>,
                                                            <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>lastTreeCallGuard</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>,
                             <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name><name>lir</name>-&gt;<name>ins_i2p</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_lsh</name></expr></argument>,
                                                     <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>,
                                                                  <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>VMSideExit</name></expr></argument>, <argument><expr><name>calldepth</name></expr></argument>)</argument_list></call></expr></argument>,
                                                                  <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>,
                                                     <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof> == 4 ? 2 : 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>,
                   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>rpAtLastTreeCall</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>label</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>done1</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>done2</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Keep updating outermostTreeExit so that InterpState always contains the most recent
     * side exit.
     */</comment>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>outermostTreeExitGuard</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Read back all registers, in case the called tree changed any of them. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TraceType</name>*</type> <name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>map</name> = <call><name><name>exit</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>exit</name>-&gt;<name>numGlobalSlots</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>i</name></expr>]</index></name> != <name>TT_JSVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><name>map</name> = <call><name><name>exit</name>-&gt;<name>stackTypeMap</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>exit</name>-&gt;<name>numStackSlots</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>i</name></expr>]</index></name> != <name>TT_JSVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Clear anything from the tracker that the inner tree could have written.
     * This includes the current frame (which has variables that are local in
     * the inner tree), the entry frame (which can be written to when upvars
     * are set), and the globals.
     */</comment>
    <expr_stmt><expr><call><name>clearEntryFrameSlotsFromTracker</name><argument_list>(<argument><expr><name>tracker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clearCurrentFrameSlotsFromTracker</name><argument_list>(<argument><expr><name>tracker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>SlotList</name>&amp;</type> <name>gslots</name> <init>= <expr>*<name><name>tree</name>-&gt;<name>globalSlots</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>gslots</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>slot</name> <init>= <expr><name><name>gslots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name> <init>= <expr>&amp;<call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>tracker</name>.<name>set</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* Set stack slots from the innermost frame. */</comment>
    <expr_stmt><expr><call><name><name>importTypeMap</name>.<name>setLength</name></name><argument_list>(<argument><expr><call><name>NativeStackSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><name>importStackSlots</name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>importTypeMap</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>importTypeMap</name><index>[<expr><name>i</name></expr>]</index></name> = <name>TT_IGNORE</name></expr>;</expr_stmt></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>startOfInnerFrame</name> <init>= <expr><call><name><name>importTypeMap</name>.<name>length</name></name><argument_list>()</argument_list></call> - <name><name>exit</name>-&gt;<name>numStackSlots</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>exit</name>-&gt;<name>numStackSlots</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><name><name>importTypeMap</name><index>[<expr><name>startOfInnerFrame</name> + <name>i</name></expr>]</index></name> = <call><name><name>exit</name>-&gt;<name>stackTypeMap</name></name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt></for>
    <expr_stmt><expr><name>importStackSlots</name> = <call><name><name>importTypeMap</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>importStackSlots</name> == <call><name>NativeStackSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Bug 502604 - It is illegal to extend from the outer typemap without
     * first extending from the inner. Make a new typemap here.
     */</comment>
    <expr_stmt><expr><call><name>BuildGlobalTypeMapFromInnerTree</name><argument_list>(<argument><expr><name>importTypeMap</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>importGlobalSlots</name> = <call><name><name>importTypeMap</name>.<name>length</name></name><argument_list>()</argument_list></call> - <name>importStackSlots</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>importGlobalSlots</name> == <call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Restore sp and rp to their original values (we still have them in a register). */</comment>
    <if>if <condition>(<expr><name>callDepth</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name><name>lirbuf</name>-&gt;<name>rp</name></name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Guard that we come out of the inner tree along the same side exit we came out when
     * we called the inner tree at recording time.
     */</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>nestedExit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>NESTED_EXIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>LOOP_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nestedExit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"TREEVIS TREECALL INNER=%p EXIT=%p GUARD=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>inner</name></expr></argument>,
                      <argument><expr>(<name>void</name>*)<name>nestedExit</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Register us as a dependent tree of the inner tree. */</comment>
    <expr_stmt><expr><call><name><name>inner</name>-&gt;<name>dependentTrees</name>.<name>addUnique</name></name><argument_list>(<argument><expr><name><name>fragment</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>linkedTrees</name>.<name>addUnique</name></name><argument_list>(<argument><expr><name>inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Add a if/if-else control-flow merge point to the list of known merge points. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>trackCfgMerges</name></name><parameter_list>(<param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* If we hit the beginning of an if/if-else, then keep track of the merge point after it. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(*<name>pc</name> == <name>JSOP_IFEQ</name>) || (*<name>pc</name> == <name>JSOP_IFEQX</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name>*</type> <name>sn</name> <init>= <expr><call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>sn</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_IF</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>cfgMerges</name>.<name>add</name></name><argument_list>(<argument><expr>(*<name>pc</name> == <name>JSOP_IFEQ</name>)
                          ? <name>pc</name> + <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call>
                          : <name>pc</name> + <call><name>GET_JUMPX_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_IF_ELSE</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>cfgMerges</name>.<name>add</name></name><argument_list>(<argument><expr><name>pc</name> + <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Invert the direction of the guard if this is a loop edge that is not
 * taken (thin loop).
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>emitIf</name></name><parameter_list>(<param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>, <param><decl><type><name>bool</name></type> <name>cond</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>x</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ExitType</name></type> <name>exitType</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>IsLoopEdge</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>*)<name><name>tree</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>exitType</name> = <name>LOOP_EXIT</name></expr>;</expr_stmt>

        <comment type="block">/*
         * If we are about to walk out of the loop, generate code for the
         * inverse loop condition, pretending we recorded the case that stays
         * on trace.
         */</comment>
        <if>if <condition>(<expr>(*<name>pc</name> == <name>JSOP_IFEQ</name> || *<name>pc</name> == <name>JSOP_IFEQX</name>) == <name>cond</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_IFNE</name> || *<name>pc</name> == <name>JSOP_IFNEX</name> || *<name>pc</name> == <name>JSOP_IFEQ</name> || *<name>pc</name> == <name>JSOP_IFEQX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                              <argument><expr>"Walking out of the loop, terminating it anyway.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cond</name> = !<name>cond</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/*
         * Conditional guards do not have to be emitted if the condition is
         * constant. We make a note whether the loop condition is true or false
         * here, so we later know whether to emit a loop edge or a loop end.
         */</comment>
        <if>if <condition>(<expr><call><name><name>x</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pendingLoop</name> = (<call><name><name>x</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call> == <call><name>int32</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>exitType</name> = <name>BRANCH_EXIT</name></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr>!<call><name><name>x</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>exitType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* Emit code for a fused IFEQ/IFNE. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>fuseIf</name></name><parameter_list>(<param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>, <param><decl><type><name>bool</name></type> <name>cond</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>x</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_IFEQ</name> || *<name>pc</name> == <name>JSOP_IFNE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>emitIf</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_IFEQ</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>trackCfgMerges</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
}</block></function>

<comment type="block">/* Check whether we have reached the end of the trace. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>checkTraceEnd</name></name><parameter_list>(<param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>IsLoopEdge</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>*)<name><name>tree</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If we compile a loop, the trace should have a zero stack balance at
         * the loop edge. Currently we are parked on a comparison op or
         * IFNE/IFEQ, so advance pc to the loop header and adjust the stack
         * pointer and pretend we have reached the loop header.
         */</comment>
        <if>if <condition>(<expr><name>pendingLoop</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name> &amp;&amp; (<name>pc</name> == <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> || <name>pc</name> == <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>fused</name> <init>= <expr><name>pc</name> != <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSFrameRegs</name></type> <name>orig</name> <init>= <expr>*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> = (<name>jsbytecode</name>*)<name><name>tree</name>-&gt;<name>ip</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> -= <name>fused</name> ? 2 : 1</expr>;</expr_stmt>

            <decl_stmt><decl><type><name>JSContext</name>*</type> <name>localcx</name> <init>= <expr><name>cx</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AbortableRecordingStatus</name></type> <name>ars</name> <init>= <expr><call><name>closeLoop</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr>*<name><name>localcx</name>-&gt;<name>fp</name>-&gt;<name>regs</name></name> = <name>orig</name></expr>;</expr_stmt>
            <return>return <expr><name>ars</name></expr>;</return>
        }</block></then> <else>else <block>{
            <return>return <expr><call><name>endLoop</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></then></if>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>hasMethod</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>jsid</name></type> <name>id</name></decl></param>, <param><decl><type><name>bool</name>&amp;</type> <name>found</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>found</name> = false</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>RecordingStatus</name></type> <name>status</name> <init>= <expr><name>RECORD_CONTINUE</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
        <return>return <expr><name>status</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>pobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSProperty</name>*</type> <name>prop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>protoIndex</name> <init>= <expr><call><name><name>obj</name>-&gt;<name>lookupProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr>&amp;<name>pobj</name></expr></argument>, <argument><expr>&amp;<name>prop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>protoIndex</name> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>RECORD_ERROR</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<name>prop</name></expr>)</condition><then>
        <return>return <expr><name>status</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<call><name>OBJ_IS_NATIVE</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// We can't rely on __iterator__ being present on trace just because</comment>
        <comment type="line">// it's there now, if found in a non-native object.</comment>
        <expr_stmt><expr><name>status</name> = <name>RECORD_STOP</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>JSScope</name>*</type> <name>scope</name> <init>= <expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name> <init>= <expr>(<name>JSScopeProperty</name>*) <name>prop</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>hasDefaultGetterOrIsMethod</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>SPROP_HAS_VALID_SLOT</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jsval</name></type> <name>v</name> <init>= <expr><call><name>LOCKED_OBJ_GET_SLOT</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><name><name>sprop</name>-&gt;<name>slot</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>VALUE_IS_FUNCTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>found</name> = true</expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name><name>scope</name>-&gt;<name>generic</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>scope</name>-&gt;<name>branded</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>scope</name>-&gt;<name>brand</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>sprop</name>-&gt;<name>slot</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name>status</name> = <name>RECORD_STOP</name></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block></else></if>

    <expr_stmt><expr><call><name><name>pobj</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>hasIteratorMethod</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>bool</name>&amp;</type> <name>found</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> + 2 &lt;= <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name></name> + <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>nslots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>hasMethod</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>iteratorAtom</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Check whether the shape of the global object has changed. The return value
 * indicates whether the recorder is still active.  If 'false', any active
 * recording has been aborted and the JIT may have been reset.
 */</comment>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name>CheckGlobalObjectShape</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>,
                       <param><decl><type><name>uint32</name> *</type><name>shape</name> <init>= <expr><name>NULL</name></expr></init></decl></param>, <name>SlotList</name>** <name>slots</name> = <name>NULL</name>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>needFlush</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_DEEP_BAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name><name>globalObj</name>-&gt;<name>numSlots</name></name><argument_list>()</argument_list></call> &gt; <name>MAX_GLOBAL_SLOTS</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>recorder</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"too many slots in global object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>uint32</name></type> <name>globalShape</name> <init>= <expr><call><name>OBJ_SHAPE</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>recorder</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>root</name> <init>= <expr><call><name><name>tm</name>-&gt;<name>recorder</name>-&gt;<name>getFragment</name></name><argument_list>()</argument_list></call>-&gt;<name>root</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Check the global shape matches the recorder's treeinfo's shape. */</comment>
        <if>if <condition>(<expr><name>globalObj</name> != <name><name>root</name>-&gt;<name>globalObj</name></name> || <name>globalShape</name> != <name><name>root</name>-&gt;<name>globalShape</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>globalShapeMismatchAtEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                              <argument><expr>"Global object/shape mismatch (%p/%u vs. %p/%u), flushing cache.\n"</expr></argument>,
                              <argument><expr>(<name>void</name>*)<name>globalObj</name></expr></argument>, <argument><expr><name>globalShape</name></expr></argument>, <argument><expr>(<name>void</name>*)<name><name>root</name>-&gt;<name>globalObj</name></name></expr></argument>,
                              <argument><expr><name><name>root</name>-&gt;<name>globalShape</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Backoff</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>*) <name><name>root</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_GLOBAL_SHAPE_MISMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>shape</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>shape</name> = <name>globalShape</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>slots</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>slots</name> = <name><name>root</name>-&gt;<name>globalSlots</name></name></expr>;</expr_stmt></then></if>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <comment type="block">/* No recorder, search for a tracked global-state (or allocate one). */</comment>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>MONITOR_N_GLOBAL_STATES</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>GlobalState</name> &amp;</type><name>state</name> <init>= <expr><name><name>tm</name>-&gt;<name>globalStates</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>state</name>.<name>globalShape</name></name> == <call><name>uint32</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>state</name>.<name>globalObj</name></name> = <name>globalObj</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name>.<name>globalShape</name></name> = <name>globalShape</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>state</name>.<name>globalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>state</name>.<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>state</name>.<name>globalObj</name></name> == <name>globalObj</name> &amp;&amp; <name><name>state</name>.<name>globalShape</name></name> == <name>globalShape</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>shape</name></expr>)</condition><then>
                <expr_stmt><expr>*<name>shape</name> = <name>globalShape</name></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name>slots</name></expr>)</condition><then>
                <expr_stmt><expr>*<name>slots</name> = <name><name>state</name>.<name>globalSlots</name></name></expr>;</expr_stmt></then></if>
            <return>return <expr>true</expr>;</return>
        }</block></then></if>
    }</block></for>

    <comment type="block">/* No currently-tracked-global found and no room to allocate, abort. */</comment>
    <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>globalShapeMismatchAtEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                      <argument><expr>"No global slotlist for global shape %u, flushing cache.\n"</expr></argument>,
                      <argument><expr><name>globalShape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_GLOBALS_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>false</expr>;</return>
}</block></function>

<comment type="block">/*
 * Return whether or not the recorder could be started. If 'false', the JIT has
 * been reset in response to an OOM.
 */</comment>
<function><type><name>bool</name> <name>JS_REQUIRES_STACK</name></type>
<name><name>TraceRecorder</name>::<name>startRecorder</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>anchor</name></decl></param>, <param><decl><type><name>VMFragment</name>*</type> <name>f</name></decl></param>,
                             <param><decl><type><name>unsigned</name></type> <name>stackSlots</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>ngslots</name></decl></param>,
                             <param><decl><type><name>TraceType</name>*</type> <name>typeMap</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>expectedInnerExit</name></decl></param>,
                             <param><decl><type><name>jsbytecode</name>*</type> <name>outer</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>outerArgc</name></decl></param>, <param><decl><type><name>RecordReason</name></type> <name>recordReason</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceMonitor</name> *</type><name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>tm</name>-&gt;<name>needFlush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>root</name></name> != <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>tm</name>-&gt;<name>recorder</name></name> = new <call><name>TraceRecorder</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>stackSlots</name></expr></argument>, <argument><expr><name>ngslots</name></expr></argument>, <argument><expr><name>typeMap</name></expr></argument>,
                                     <argument><expr><name>expectedInnerExit</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>, <argument><expr><name>outerArgc</name></expr></argument>, <argument><expr><name>recordReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>tm</name>-&gt;<name>recorder</name></name> || <call><name><name>tm</name>-&gt;<name>outOfMemory</name></name><argument_list>()</argument_list></call> || <call><name>OverfullJITCache</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * If slurping failed, there's no reason to start recording again. Emit LIR
     * to capture the rest of the slots, then immediately compile and finish.
     */</comment>
    <if>if <condition>(<expr><name>anchor</name> &amp;&amp; <name><name>anchor</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_SLURP_FAIL_EXIT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>tm</name>-&gt;<name>recorder</name>-&gt;<name>slurpDownFrames</name></name><argument_list>(<argument><expr>(<name>jsbytecode</name>*)<name><name>anchor</name>-&gt;<name>recursive_pc</name></name> - <name>JSOP_CALL_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>recorder</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>tm</name>-&gt;<name>recorder</name>-&gt;<name>finishAbort</name></name><argument_list>(<argument><expr>"Failed to slurp down frames"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>TrashTree</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>f</name> == <name><name>f</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"TREEVIS TRASH FRAG=%p\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>treesTrashed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Trashing tree info.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>f</name>-&gt;<name>setCode</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>TreeFragment</name>**</type> <name>data</name> <init>= <expr><call><name><name>f</name>-&gt;<name>dependentTrees</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>length</name> <init>= <expr><call><name><name>f</name>-&gt;<name>dependentTrees</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>n</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>)
        <expr_stmt><expr><call><name>TrashTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><name>data</name> = <call><name><name>f</name>-&gt;<name>linkedTrees</name>.<name>data</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>length</name> = <call><name><name>f</name>-&gt;<name>linkedTrees</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>n</name> &lt; <name>length</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>)
        <expr_stmt><expr><call><name>TrashTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>SynthesizeFrame</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>FrameInfo</name>&amp;</type> <name>fi</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>callee</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>VOUCH_DOES_NOT_REQUIRE_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name> <init>= <expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callee</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Assert that we have a correct sp distance from cx-&gt;fp-&gt;slots in fi. */</comment>
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name><name>fi</name>.<name>imacpc</name></name></expr></argument>,
                 <argument><expr><call><name>js_ReconstructStackDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name><name>fi</name>.<name>pc</name></name></expr></argument>)</argument_list></call> ==
                 <call><name>uintN</name><argument_list>(<argument><expr><name><name>fi</name>.<name>spdist</name></name> - <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uintN</name></type> <name>nframeslots</name> <init>= <expr><call><name>JS_HOWMANY</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSInlineFrame</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name>*</type> <name>script</name> <init>= <expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name> <init>= <expr>(<name>nframeslots</name> + <name><name>script</name>-&gt;<name>nslots</name></name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Code duplicated from inline_call: case in js_Interpret (FIXME). */</comment>
    <decl_stmt><decl><type><name>JSArena</name>*</type> <name>a</name> <init>= <expr><name><name>cx</name>-&gt;<name>stackPool</name>.<name>current</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>*</type> <name>newmark</name> <init>= <expr>(<name>void</name>*) <name><name>a</name>-&gt;<name>avail</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>argc</name> <init>= <expr><call><name><name>fi</name>.<name>get_argc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name> <init>= <expr><name><name>fp</name>-&gt;<name>slots</name></name> + <name><name>fi</name>.<name>spdist</name></name> - (2 + <name>argc</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>missing</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>newsp</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>fun</name>-&gt;<name>nargs</name></name> &gt; <name>argc</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>JSFrameRegs</name>&amp;</type> <name>regs</name> <init>= <expr>*<name><name>fp</name>-&gt;<name>regs</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>newsp</name> = <name>vp</name> + 2 + <name><name>fun</name>-&gt;<name>nargs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>newsp</name> &gt; <name><name>regs</name>.<name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>jsuword</name>) <name>newsp</name> &lt;= <name><name>a</name>-&gt;<name>limit</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>(<name>jsuword</name>) <name>newsp</name> &gt; <name><name>a</name>-&gt;<name>avail</name></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>a</name>-&gt;<name>avail</name></name> = (<name>jsuword</name>) <name>newsp</name></expr>;</expr_stmt></then></if>
            <decl_stmt><decl><type><name>jsval</name>*</type> <name>argsp</name> <init>= <expr><name>newsp</name></expr></init></decl>;</decl_stmt>
            <do>do <block>{
                <expr_stmt><expr>*--<name>argsp</name> = <name>JSVAL_VOID</name></expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>argsp</name> != <name><name>regs</name>.<name>sp</name></name></expr>)</condition>;</do>
            <expr_stmt><expr><name>missing</name> = 0</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>missing</name> = <name><name>fun</name>-&gt;<name>nargs</name></name> - <name>argc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nbytes</name> += (2 + <name><name>fun</name>-&gt;<name>nargs</name></name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <comment type="block">/* Allocate the inline frame with its vars and operands. */</comment>
    <if>if <condition>(<expr><name><name>a</name>-&gt;<name>avail</name></name> + <name>nbytes</name> &lt;= <name><name>a</name>-&gt;<name>limit</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>newsp</name> = (<name>jsval</name> *) <name><name>a</name>-&gt;<name>avail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>avail</name></name> += <name>nbytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>missing</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><name>newsp</name></expr></argument>, <argument><expr><name>jsval</name> *</expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>stackPool</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>newsp</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>OutOfMemoryAbort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="block">/*
         * Move args if the missing ones overflow arena a, then push
         * undefined for the missing args.
         */</comment>
        <if>if <condition>(<expr><name>missing</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newsp</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>(2 + <name>argc</name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>vp</name> = <name>newsp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>newsp</name> = <name>vp</name> + 2 + <name>argc</name></expr>;</expr_stmt>
            <do>do <block>{
                <expr_stmt><expr>*<name>newsp</name>++ = <name>JSVAL_VOID</name></expr>;</expr_stmt>
            }</block> while <condition>(<expr>--<name>missing</name> != 0</expr>)</condition>;</do>
        }</block></then></if>
    }</block></else></if>

    <comment type="block">/* Claim space for the stack frame and initialize it. */</comment>
    <decl_stmt><decl><type><name>JSInlineFrame</name>*</type> <name>newifp</name> <init>= <expr>(<name>JSInlineFrame</name> *) <name>newsp</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>newsp</name> += <name>nframeslots</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>callobj</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>argsobj</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>script</name></name> = <name>script</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>fun</name></name> = <name>fun</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>constructing</name> <init>= <expr><call><name><name>fi</name>.<name>is_constructing</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>argc</name></name> = <name>argc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>callerRegs</name>.<name>pc</name></name> = <name><name>fi</name>.<name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>callerRegs</name>.<name>sp</name></name> = <name><name>fp</name>-&gt;<name>slots</name></name> + <name><name>fi</name>.<name>spdist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>imacpc</name></name> = <name><name>fi</name>.<name>imacpc</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>fi</name>.<name>block</name></name> != <name><name>fp</name>-&gt;<name>blockChain</name></name></expr>)</condition><then> <block>{
        <for>for (<init><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><name><name>fi</name>.<name>block</name></name></expr></init></decl>;</init> <condition><expr><name>obj</name> != <name><name>fp</name>-&gt;<name>blockChain</name></name></expr>;</condition> <incr><expr><name>obj</name> = <call><name><name>obj</name>-&gt;<name>getParent</name></name><argument_list>()</argument_list></call></expr></incr>)
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>blockChain</name></name> = <name><name>fi</name>.<name>block</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>argv</name></name> = <name><name>newifp</name>-&gt;<name>callerRegs</name>.<name>sp</name></name> - <name>argc</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="line">// Initialize argv[-1] to a known-bogus value so we'll catch it if</comment>
    <comment type="line">// someone forgets to initialize it later.</comment>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>argv</name><index>[<expr>-1</expr>]</index></name> = <name>JSVAL_HOLE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>argv</name></name> &gt;= <call><name>StackBase</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>rval</name></name> = <name>JSVAL_VOID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>down</name></name> = <name>fp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>annotation</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>scopeChain</name></name> = <name>NULL</name></expr>;</expr_stmt> <comment type="line">// will be updated in FlushNativeStackFrame</comment>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>flags</name></name> = <name>constructing</name> ? <name>JSFRAME_CONSTRUCTING</name> : 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>blockChain</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>mark</name></name> = <name>newmark</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>thisv</name></name> = <name>JSVAL_NULL</name></expr>;</expr_stmt> <comment type="line">// will be updated in FlushNativeStackFrame</comment>

    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>regs</name></name> = <name><name>fp</name>-&gt;<name>regs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>regs</name>-&gt;<name>pc</name></name> = <name><name>script</name>-&gt;<name>code</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>regs</name>-&gt;<name>sp</name></name> = <name>newsp</name> + <name><name>script</name>-&gt;<name>nfixed</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>imacpc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>slots</name></name> = <name>newsp</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>script</name>-&gt;<name>staticLevel</name></name> &lt; <name>JS_DISPLAY_SIZE</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSStackFrame</name> **</type><name>disp</name> <init>= <expr>&amp;<name><name>cx</name>-&gt;<name>display</name><index>[<expr><name><name>script</name>-&gt;<name>staticLevel</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newifp</name>-&gt;<name>frame</name>.<name>displaySave</name></name> = *<name>disp</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>disp</name> = &amp;<name><name>newifp</name>-&gt;<name>frame</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Note that fp-&gt;script is still the caller's script; set the callee
     * inline frame's idea of caller version from its version.
     */</comment>
    <expr_stmt><expr><name><name>newifp</name>-&gt;<name>callerVersion</name></name> = (<name>JSVersion</name>) <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>version</name></name></expr>;</expr_stmt>

    <comment type="line">// After this paragraph, fp and cx-&gt;fp point to the newly synthesized frame.</comment>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>regs</name></name> = &amp;<name><name>newifp</name>-&gt;<name>callerRegs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>fp</name> = <name><name>cx</name>-&gt;<name>fp</name></name> = &amp;<name><name>newifp</name>-&gt;<name>frame</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If there's a call hook, invoke it to compute the hookData used by
     * debuggers that cooperate with the interpreter.
     */</comment>
    <decl_stmt><decl><type><name>JSInterpreterHook</name></type> <name>hook</name> <init>= <expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>callHook</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>hook</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>newifp</name>-&gt;<name>hookData</name></name> = <call><name>hook</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>callHookData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>newifp</name>-&gt;<name>hookData</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*
     * Duplicate native stack layout computation: see VisitFrameSlots header comment.
     *
     * FIXME - We must count stack slots from caller's operand stack up to (but
     * not including) callee's, including missing arguments. Could we shift
     * everything down to the caller's fp-&gt;slots (where vars start) and avoid
     * some of the complexity?
     */</comment>
    <return>return <expr>(<name><name>fi</name>.<name>spdist</name></name> - <name><name>fp</name>-&gt;<name>down</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name>) +
           ((<name><name>fun</name>-&gt;<name>nargs</name></name> &gt; <name><name>fp</name>-&gt;<name>argc</name></name>) ? <name><name>fun</name>-&gt;<name>nargs</name></name> - <name><name>fp</name>-&gt;<name>argc</name></name> : 0) +
           <name><name>script</name>-&gt;<name>nfixed</name></name> + <name>SPECIAL_FRAME_SLOTS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SynthesizeSlowNativeFrame</name><parameter_list>(<param><decl><type><name>InterpState</name>&amp;</type> <name>state</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>VMSideExit</name> *</type><name>exit</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>VOUCH_DOES_NOT_REQUIRE_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>void</name> *</type><name>mark</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSInlineFrame</name> *</type><name>ifp</name></decl>;</decl_stmt>

    <comment type="block">/* This allocation is infallible: ExecuteTree reserved enough stack. */</comment>
    <expr_stmt><expr><name>mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>stackPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><name>ifp</name></expr></argument>, <argument><expr><name>JSInlineFrame</name> *</expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>stackPool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSInlineFrame</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ifp</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>OutOfMemoryAbort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr>&amp;<name><name>ifp</name>-&gt;<name>frame</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>regs</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>imacpc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>slots</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>callobj</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>argsobj</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>script</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>thisv</name></name> = <name><name>state</name>.<name>nativeVp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>argc</name></name> = <name><name>state</name>.<name>nativeVpLen</name></name> - 2</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>argv</name></name> = <name><name>state</name>.<name>nativeVp</name></name> + 2</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>fun</name></name> = <call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>fp</name>-&gt;<name>calleeObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>rval</name></name> = <name>JSVAL_VOID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>down</name></name> = <name><name>cx</name>-&gt;<name>fp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>annotation</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>scopeChain</name></name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>blockChain</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>flags</name></name> = <call><name><name>exit</name>-&gt;<name>constructing</name></name><argument_list>()</argument_list></call> ? <name>JSFRAME_CONSTRUCTING</name> : 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>displaySave</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ifp</name>-&gt;<name>mark</name></name> = <name>mark</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>fp</name></name> = <name>fp</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name>RecordTree</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>peer</name></decl></param>, <param><decl><type><name>jsbytecode</name>*</type> <name>outer</name></decl></param>,
           <param><decl><type><name>uint32</name></type> <name>outerArgc</name></decl></param>, <param><decl><type><name>SlotList</name>*</type> <name>globalSlots</name></decl></param>, <param><decl><type><name>RecordReason</name></type> <name>reason</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Try to find an unused peer fragment, or allocate a new one. */</comment>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>f</name> <init>= <expr><name>peer</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>f</name>-&gt;<name>peer</name></name></expr>)</condition>
        <expr_stmt><expr><name>f</name> = <name><name>f</name>-&gt;<name>peer</name></name></expr>;</expr_stmt></while>
    <if>if <condition>(<expr><call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>f</name> = <call><name>AddNewPeerToPeerList</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>root</name></name> == <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* save a local copy for use after JIT flush */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>localRootIP</name> <init>= <expr><name><name>f</name>-&gt;<name>root</name>-&gt;<name>ip</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Make sure the global type map didn't change on us. */</comment>
    <if>if <condition>(<expr>!<call><name>CheckGlobalObjectShape</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>globalObj</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Backoff</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>*) <name>localRootIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>recorderStarted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>tm</name>-&gt;<name>outOfMemory</name></name><argument_list>()</argument_list></call> || <call><name>OverfullJITCache</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Backoff</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>*) <name><name>f</name>-&gt;<name>root</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"Out of memory recording new tree, flushing cache.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>f</name>-&gt;<name>initialize</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>AssertTreeIsUnique</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"TREEVIS CREATETREE ROOT=%p PC=%p FILE=\"%s\" LINE=%d OFFS=%d"</expr></argument>,
                      <argument><expr>(<name>void</name>*)<name>f</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>ip</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>treeFileName</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>treeLineNumber</name></name></expr></argument>,
                      <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>" STACK=\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>f</name>-&gt;<name>nStackTypes</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr><name><name>f</name>-&gt;<name>typeMap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"\" GLOBALS=\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>f</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr><name><name>f</name>-&gt;<name>typeMap</name><index>[<expr><name><name>f</name>-&gt;<name>nStackTypes</name></name> + <name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"\"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Recording primary trace. */</comment>
    <return>return <expr><call><name><name>TraceRecorder</name>::<name>startRecorder</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>nStackTypes</name></name></expr></argument>,
                                        <argument><expr><call><name><name>f</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>,
                                        <argument><expr><call><name><name>f</name>-&gt;<name>typeMap</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>outer</name></expr></argument>, <argument><expr><name>outerArgc</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>TypeConsensus</name></type>
<name>FindLoopEdgeTarget</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>, <param><decl><type><name>TreeFragment</name>**</type> <name>peerp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>from</name> <init>= <expr><call><name><name>exit</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>from</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>TypeMap</name></type> <name>typeMap</name><parameter_list>(<param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>FullMapFromExit</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call> - <name><name>exit</name>-&gt;<name>numStackSlots</name></name> == <call><name><name>from</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Mark all double slots as undemotable */</comment>
    <decl_stmt><decl><type><name>uint16</name>*</type> <name>gslots</name> <init>= <expr><call><name><name>from</name>-&gt;<name>globalSlots</name>-&gt;<name>data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>typeMap</name><index>[<expr><name>i</name></expr>]</index></name> == <name>TT_DOUBLE</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_UNLINKED_EXIT</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>i</name> &lt; <name><name>exit</name>-&gt;<name>numStackSlots</name></name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>oracle</name>.<name>markStackSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>exit</name>-&gt;<name>recursive_pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><call><name><name>oracle</name>.<name>markGlobalSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>gslots</name><index>[<expr><name>i</name> - <name><name>exit</name>-&gt;<name>numStackSlots</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            }</block></then></if>
            <if>if <condition>(<expr><name>i</name> &lt; <name><name>from</name>-&gt;<name>nStackTypes</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>oracle</name>.<name>markStackSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>from</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><name>i</name> &gt;= <name><name>exit</name>-&gt;<name>numStackSlots</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>oracle</name>.<name>markGlobalSlotUndemotable</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>gslots</name><index>[<expr><name>i</name> - <name><name>exit</name>-&gt;<name>numStackSlots</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
        }</block></then></if>
    }</block></for>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>UNSTABLE_LOOP_EXIT</name> ||
              (<name><name>exit</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_UNLINKED_EXIT</name> &amp;&amp; <name><name>exit</name>-&gt;<name>recursive_pc</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>firstPeer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>UNSTABLE_LOOP_EXIT</name> || <name><name>exit</name>-&gt;<name>recursive_pc</name></name> == <name><name>from</name>-&gt;<name>ip</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>firstPeer</name> = <name><name>from</name>-&gt;<name>first</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>firstPeer</name> = <call><name>LookupLoop</name><argument_list>(<argument><expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>exit</name>-&gt;<name>recursive_pc</name></name></expr></argument>, <argument><expr><name><name>from</name>-&gt;<name>globalObj</name></name></expr></argument>,
                               <argument><expr><name><name>from</name>-&gt;<name>globalShape</name></name></expr></argument>, <argument><expr><name><name>from</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <for>for (<init><decl><type><name>TreeFragment</name>*</type> <name>peer</name> <init>= <expr><name>firstPeer</name></expr></init></decl>;</init> <condition><expr><name>peer</name></expr>;</condition> <incr><expr><name>peer</name> = <name><name>peer</name>-&gt;<name>peer</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name><name>peer</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>peer</name>-&gt;<name>argc</name></name> == <name><name>from</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>numStackSlots</name></name> == <name><name>peer</name>-&gt;<name>nStackTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>TypeConsensus</name></type> <name>consensus</name> <init>= <expr><call><name>TypeMapLinkability</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>typeMap</name></expr></argument>, <argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>consensus</name> == <name>TypeConsensus_Okay</name> || <name>consensus</name> == <name>TypeConsensus_Undemotes</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>peerp</name> = <name>peer</name></expr>;</expr_stmt>
            <return>return <expr><name>consensus</name></expr>;</return>
        }</block></then></if>
    }</block></for>

    <return>return <expr><name>TypeConsensus_Bad</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name>AttemptToStabilizeTree</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>, <param><decl><type><name>jsbytecode</name>*</type> <name>outer</name></decl></param>,
                       <param><decl><type><name>uint32</name></type> <name>outerArgc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>needFlush</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_DEEP_BAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>from</name> <init>= <expr><call><name><name>exit</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>peer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TypeConsensus</name></type> <name>consensus</name> <init>= <expr><call><name>FindLoopEdgeTarget</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>, <argument><expr>&amp;<name>peer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>consensus</name> == <name>TypeConsensus_Okay</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>from</name>-&gt;<name>globalSlots</name></name> == <name><name>peer</name>-&gt;<name>globalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>UNSTABLE_LOOP_EXIT</name></expr></argument>,
                     <argument><expr><name><name>from</name>-&gt;<name>nStackTypes</name></name> == <name><name>peer</name>-&gt;<name>nStackTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>exit</name>-&gt;<name>numStackSlots</name></name> == <name><name>peer</name>-&gt;<name>nStackTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Patch this exit to its peer */</comment>
        <expr_stmt><expr><call><name>JoinPeers</name><argument_list>(<argument><expr><name><name>tm</name>-&gt;<name>assembler</name></name></expr></argument>, <argument><expr><name>exit</name></expr></argument>, <argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Update peer global types. The |from| fragment should already be updated because it on
         * the execution path, and somehow connected to the entry trace.
         */</comment>
        <if>if <condition>(<expr><call><name><name>peer</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call> &lt; <call><name><name>peer</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>SpecializeTreesToMissingGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>from</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call> == <call><name><name>from</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* This exit is no longer unstable, so remove it. */</comment>
        <if>if <condition>(<expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>UNSTABLE_LOOP_EXIT</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>from</name>-&gt;<name>removeUnstableExit</name></name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <macro><name>debug_only_stmt</name><argument_list>(<argument>DumpPeerStability(tm, peer-&gt;ip, globalObj, from-&gt;globalShape, from-&gt;argc);</argument>)</argument_list></macro>
        <return>return <expr>false</expr>;</return>
    }</block></then> <else>else <if>if <condition>(<expr><name>consensus</name> == <name>TypeConsensus_Undemotes</name></expr>)</condition><then> <block>{
        <comment type="block">/* The original tree is unconnectable, so trash it. */</comment>
        <expr_stmt><expr><call><name>TrashTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if></else></if>

    <decl_stmt><decl><type><name>uint32</name></type> <name>globalShape</name> <init>= <expr><name><name>from</name>-&gt;<name>globalShape</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SlotList</name> *</type><name>globalSlots</name> <init>= <expr><name><name>from</name>-&gt;<name>globalSlots</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Don't bother recording if the exit doesn't expect this PC */</comment>
    <if>if <condition>(<expr><name><name>exit</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_UNLINKED_EXIT</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>++<name><name>exit</name>-&gt;<name>hitcount</name></name> &gt;= <name>MAX_RECURSIVE_UNLINK_HITS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr>(<name>jsbytecode</name>*)<name><name>from</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TrashTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>exit</name>-&gt;<name>recursive_pc</name></name> != <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><name>from</name> = <call><name>LookupLoop</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name><name>exit</name>-&gt;<name>recursive_pc</name></name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>globalShape</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>from</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <comment type="block">/* use stale TI for RecordTree - since from might not have one anymore. */</comment>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>from</name> == <name><name>from</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If this tree has been blacklisted, don't try to record a new one. */</comment>
    <if>if <condition>(<expr>*(<name>jsbytecode</name>*)<name><name>from</name>-&gt;<name>ip</name></name> == <name>JSOP_NOP</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <return>return <expr><call><name>RecordTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>from</name>-&gt;<name>first</name></name></expr></argument>, <argument><expr><name>outer</name></expr></argument>, <argument><expr><name>outerArgc</name></expr></argument>, <argument><expr><name>globalSlots</name></expr></argument>, <argument><expr><name>Record_Branch</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>VMFragment</name>*</type>
<name>CreateBranchFragment</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>root</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>anchor</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>verbose_only</name><argument_list>(
    <argument>uint32_t profFragID = (LogController.lcbits &amp; LC_FragProfile)
                          ? (++(tm-&gt;lastFragID)) : 0;</argument>
    )</argument_list></macro>

    <decl_stmt><decl><type><name>VMFragment</name>*</type> <name>f</name> <init>= <expr>new (*<name><name>tm</name>-&gt;<name>dataAlloc</name></name>) <macro><name>VMFragment</name><argument_list>(<argument>cx-&gt;fp-&gt;regs-&gt;pc verbose_only(, profFragID)</argument>)</argument_list></macro></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTreeVis</name></expr></argument>, <argument><expr>"TREEVIS CREATEBRANCH ROOT=%p FRAG=%p PC=%p FILE=\"%s\""
                      " LINE=%d ANCHOR=%p OFFS=%d\n"</expr></argument>,
                      <argument><expr>(<name>void</name>*)<name>root</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>f</name></expr></argument>, <argument><expr>(<name>void</name>*)<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></argument>,
                      <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>void</name>*)<name>anchor</name></expr></argument>,
                      <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>verbose_only</name><argument_list>( <argument>tm-&gt;branches = new (*tm-&gt;dataAlloc) Seq&lt;Fragment*&gt;(f, tm-&gt;branches);</argument> )</argument_list></macro>

    <expr_stmt><expr><name><name>f</name>-&gt;<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>anchor</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>anchor</name>-&gt;<name>target</name></name> = <name>f</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>f</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name>AttemptToExtendTree</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>anchor</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exitedFrom</name></decl></param>, <param><decl><type><name>jsbytecode</name>*</type> <name>outer</name></decl></param>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
    , <param><decl><type><name>TraceVisStateObj</name>*</type> <name>tvso</name> <init>= <expr><name>NULL</name></expr></init></decl></param>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    )</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>tm</name>-&gt;<name>recorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>needFlush</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_DEEP_BAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
        <if>if <condition>(<expr><name>tvso</name></expr>)</condition><then> <expr_stmt><expr><name><name>tvso</name>-&gt;<name>r</name></name> = <name>R_FAIL_EXTEND_FLUSH</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>f</name> <init>= <expr><call><name><name>anchor</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Don't grow trees above a certain size to avoid code explosion due to
     * tail duplication.
     */</comment>
    <if>if <condition>(<expr><name><name>f</name>-&gt;<name>branchCount</name></name> &gt;= <name>MAX_BRANCHES</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
        <if>if <condition>(<expr><name>tvso</name></expr>)</condition><then> <expr_stmt><expr><name><name>tvso</name>-&gt;<name>r</name></name> = <name>R_FAIL_EXTEND_MAX_BRANCHES</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>VMFragment</name>*</type> <name>c</name> <init>= <expr>(<name>VMFragment</name>*)<name><name>anchor</name>-&gt;<name>target</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>c</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>c</name> = <call><name>CreateBranchFragment</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * If we are recycling a fragment, it might have a different ip so reset it
         * here. This can happen when attaching a branch to a NESTED_EXIT, which
         * might extend along separate paths (i.e. after the loop edge, and after a
         * return statement).
         */</comment>
        <expr_stmt><expr><name><name>c</name>-&gt;<name>ip</name></name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>root</name></name> == <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                      <argument><expr>"trying to attach another branch to the tree (hits = %d)\n"</expr></argument>, <argument><expr><call><name><name>c</name>-&gt;<name>hits</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int32_t</name>&amp;</type> <name>hits</name> <init>= <expr><call><name><name>c</name>-&gt;<name>hits</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>maxHits</name> <init>= <expr><name>HOTEXIT</name> + <name>MAXEXIT</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>anchor</name>-&gt;<name>exitType</name></name> == <name>CASE_EXIT</name></expr>)</condition><then>
        <expr_stmt><expr><name>maxHits</name> *= <name><name>anchor</name>-&gt;<name>switchInfo</name>-&gt;<name>count</name></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>outer</name> || (<name>hits</name>++ &gt;= <name>HOTEXIT</name> &amp;&amp; <name>hits</name> &lt;= <name>maxHits</name>)</expr>)</condition><then> <block>{
        <comment type="block">/* start tracing secondary trace from this point */</comment>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>stackSlots</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>ngslots</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TraceType</name>*</type> <name>typeMap</name></decl>;</decl_stmt>
        <function_decl><type><name>TypeMap</name></type> <name>fullMap</name><parameter_list>(<param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</function_decl>
        <if>if <condition>(<expr>!<name>exitedFrom</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If we are coming straight from a simple side exit, just use that
             * exit's type map as starting point.
             */</comment>
            <expr_stmt><expr><name>ngslots</name> = <name><name>anchor</name>-&gt;<name>numGlobalSlots</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>stackSlots</name> = <name><name>anchor</name>-&gt;<name>numStackSlots</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>typeMap</name> = <call><name><name>anchor</name>-&gt;<name>fullTypeMap</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * If we side-exited on a loop exit and continue on a nesting
             * guard, the nesting guard (anchor) has the type information for
             * everything below the current scope, and the actual guard we
             * exited from has the types for everything in the current scope
             * (and whatever it inlined). We have to merge those maps here.
             */</comment>
            <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>e1</name> <init>= <expr><name>anchor</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>e2</name> <init>= <expr><name>exitedFrom</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>fullMap</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>e1</name>-&gt;<name>stackTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>e1</name>-&gt;<name>numStackSlotsBelowCurrentFrame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>fullMap</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>e2</name>-&gt;<name>stackTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>e2</name>-&gt;<name>numStackSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>stackSlots</name> = <call><name><name>fullMap</name>.<name>length</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ngslots</name> = <call><name>BuildGlobalTypeMapFromInnerTree</name><argument_list>(<argument><expr><name>fullMap</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ngslots</name> &gt;= <name><name>e1</name>-&gt;<name>numGlobalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// inner tree must have all globals</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ngslots</name> == <call><name><name>fullMap</name>.<name>length</name></name><argument_list>()</argument_list></call> - <name>stackSlots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>typeMap</name> = <call><name><name>fullMap</name>.<name>data</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ngslots</name> &gt;= <name><name>anchor</name>-&gt;<name>numGlobalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>rv</name> <init>= <expr><call><name><name>TraceRecorder</name>::<name>startRecorder</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>stackSlots</name></expr></argument>, <argument><expr><name>ngslots</name></expr></argument>, <argument><expr><name>typeMap</name></expr></argument>,
                                               <argument><expr><name>exitedFrom</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name></expr></argument>, <argument><expr><name>Record_Branch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
        <if>if <condition>(<expr>!<name>rv</name> &amp;&amp; <name>tvso</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>tvso</name>-&gt;<name>r</name></name> = <name>R_FAIL_EXTEND_START</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
    <if>if <condition>(<expr><name>tvso</name></expr>)</condition><then> <expr_stmt><expr><name><name>tvso</name>-&gt;<name>r</name></name> = <name>R_FAIL_EXTEND_COLD</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>false</expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>VMSideExit</name>*</type>
<name>ExecuteTree</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>, <param><decl><type><name>uintN</name>&amp;</type> <name>inlineCallCount</name></decl></param>,
            <param><decl><type><name>VMSideExit</name>**</type> <name>innermostNestedGuardp</name></decl></param>)</parameter_list>;</function_decl>

<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>TraceRecorder</name>::<name>recordLoopEdge</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TraceRecorder</name>*</type> <name>r</name></decl></param>, <param><decl><type><name>uintN</name>&amp;</type> <name>inlineCallCount</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getGlobal</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>-&gt;<name><name>title</name>.<name>ownercx</name></name> != <name>cx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"Global object not owned by this context"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return> <comment type="block">/* we stay away from shared global objects */</comment>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Process needFlush and deep abort requests. */</comment>
    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>needFlush</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_DEEP_BAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>fragment</name></name> &amp;&amp; !<name><name>r</name>-&gt;<name>fragment</name>-&gt;<name>lastIns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>root</name> <init>= <expr><name><name>r</name>-&gt;<name>fragment</name>-&gt;<name>root</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>first</name> <init>= <expr><call><name>LookupOrAddLoop</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>globalObj</name></name></expr></argument>,
                                        <argument><expr><name><name>root</name>-&gt;<name>globalShape</name></name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Make sure the shape of the global object still matches (this might flush
     * the JIT cache).
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>globalObj</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getGlobal</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>globalShape</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SlotList</name>*</type> <name>globalSlots</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>CheckGlobalObjectShape</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr>&amp;<name>globalShape</name></expr></argument>, <argument><expr>&amp;<name>globalSlots</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>tm</name>-&gt;<name>recorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                      <argument><expr>"Looking for type-compatible peer (%s:%d@%d)\n"</expr></argument>,
                      <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></argument>,
                      <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Find a matching inner tree. If none can be found, compile one.</comment>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>f</name> <init>= <expr><call><name><name>r</name>-&gt;<name>findNestedCompatiblePeer</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>f</name> || !<call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>noCompatInnerTrees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>outerFragment</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>outer</name> <init>= <expr>(<name>jsbytecode</name>*) <name><name>outerFragment</name>-&gt;<name>ip</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>outerArgc</name> <init>= <expr><name><name>outerFragment</name>-&gt;<name>argc</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name> == <name><name>first</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"No compatible inner tree"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name>RecordTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>, <argument><expr><name>outerArgc</name></expr></argument>, <argument><expr><name>globalSlots</name></expr></argument>, <argument><expr><name>Record_Branch</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name><name>r</name>-&gt;<name>attemptTreeCall</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>inlineCallCount</name></expr></argument>)</argument_list></call> == <name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>attemptTreeCall</name></name><parameter_list>(<param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>, <param><decl><type><name>uintN</name>&amp;</type> <name>inlineCallCount</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * It is absolutely forbidden to have recursive loops tree call themselves
     * because it could accidentally pop frames owned by the parent call, and
     * there is no way to deal with this yet. We could have to set a "start of
     * poppable rp stack" variable, and if that unequals "real start of rp stack",
     * it would be illegal to pop frames.
     * --
     * In the interim, just do tree calls knowing that they won't go into
     * recursive trees that can pop parent frames.
     */</comment>
    <if>if <condition>(<expr><name><name>f</name>-&gt;<name>script</name></name> == <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>f</name>-&gt;<name>recursion</name></name> &gt;= <name>Recursion_Unwinds</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"Inner tree is an unsupported type of recursion"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>f</name>-&gt;<name>recursion</name></name> = <name>Recursion_Disallowed</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>adjustCallerTypes</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>prepareTreeCall</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>oldInlineCallCount</name> <init>= <expr><name>inlineCallCount</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>JSContext</name> *</type><name>localCx</name> <init>= <expr><name>cx</name></expr></init></decl>;</decl_stmt>

    <comment type="line">// Refresh the import type map so the tracker can reimport values after the</comment>
    <comment type="line">// call with their correct types. The inner tree must not change the type of</comment>
    <comment type="line">// any variable in a frame above the current one (i.e., upvars).</comment>
    <comment type="line">//</comment>
    <comment type="line">// Note that DetermineTypesVisitor may call determineSlotType, which may</comment>
    <comment type="line">// read from the (current, stale) import type map, but this is safe here.</comment>
    <comment type="line">// The reason is that determineSlotType will read the import type map only</comment>
    <comment type="line">// if there is not a tracker instruction for that value, which means that</comment>
    <comment type="line">// value has not been written yet, so that type map entry is up to date.</comment>
    <expr_stmt><expr><call><name><name>importTypeMap</name>.<name>setLength</name></name><argument_list>(<argument><expr><call><name>NativeStackSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>DetermineTypesVisitor</name></type> <name>visitor</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><call><name><name>importTypeMap</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>innermostNestedGuard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>lr</name> <init>= <expr><call><name>ExecuteTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>inlineCallCount</name></expr></argument>, <argument><expr>&amp;<name>innermostNestedGuard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* ExecuteTree can reenter the interpreter and kill |this|. */</comment>
    <if>if <condition>(<expr>!<call><name>TRACE_RECORDER</name><argument_list>(<argument><expr><name>localCx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<name>lr</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"Couldn't call inner tree"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>outerFragment</name> <init>= <expr><name>tree</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>outer</name> <init>= <expr>(<name>jsbytecode</name>*) <name><name>outerFragment</name>-&gt;<name>ip</name></name></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>lr</name>-&gt;<name>exitType</name></name></expr>)</condition> <block>{
      <case>case <expr><name>RECURSIVE_LOOP_EXIT</name></expr>:
      </case><case>case <expr><name>LOOP_EXIT</name></expr>:
        <comment type="block">/* If the inner tree exited on an unknown loop exit, grow the tree around it. */</comment>
        <if>if <condition>(<expr><name>innermostNestedGuard</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"Inner tree took different side exit, abort current "
                              "recording and grow nesting tree"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>AttemptToExtendTree</name><argument_list>(<argument><expr><name>localCx</name></expr></argument>, <argument><expr><name>innermostNestedGuard</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>)</argument_list></call> ?
                <name>ARECORD_CONTINUE</name> : <name>ARECORD_ABORTED</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>oldInlineCallCount</name> == <name>inlineCallCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Emit a call to the inner tree and continue recording the outer tree trace. */</comment>
        <expr_stmt><expr><call><name>emitTreeCall</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>

      </case><case>case <expr><name>UNSTABLE_LOOP_EXIT</name></expr>:
      <block>{
        <comment type="block">/* Abort recording so the inner loop can become type stable. */</comment>
        <decl_stmt><decl><type><name>JSObject</name>*</type> <name>_globalObj</name> <init>= <expr><name>globalObj</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"Inner tree is trying to stabilize, abort outer recording"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>AttemptToStabilizeTree</name><argument_list>(<argument><expr><name>localCx</name></expr></argument>, <argument><expr><name>_globalObj</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>, <argument><expr><name><name>outerFragment</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call> ?
            <name>ARECORD_CONTINUE</name> : <name>ARECORD_ABORTED</name></expr>;</return>
      }</block>

      </case><case>case <expr><name>OVERFLOW_EXIT</name></expr>:
        <expr_stmt><expr><call><name><name>oracle</name>.<name>markInstructionUndemotable</name></name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* FALL THROUGH */</comment>
      </case><case>case <expr><name>RECURSIVE_SLURP_FAIL_EXIT</name></expr>:
      </case><case>case <expr><name>RECURSIVE_SLURP_MISMATCH_EXIT</name></expr>:
      </case><case>case <expr><name>RECURSIVE_MISMATCH_EXIT</name></expr>:
      </case><case>case <expr><name>RECURSIVE_EMPTY_RP_EXIT</name></expr>:
      </case><case>case <expr><name>BRANCH_EXIT</name></expr>:
      </case><case>case <expr><name>CASE_EXIT</name></expr>: <block>{
          <comment type="block">/* Abort recording the outer tree, extend the inner tree. */</comment>
          <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"Inner tree is trying to grow, abort outer recording"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>AttemptToExtendTree</name><argument_list>(<argument><expr><name>localCx</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>outer</name></expr></argument>)</argument_list></call> ? <name>ARECORD_CONTINUE</name> : <name>ARECORD_ABORTED</name></expr>;</return>
      }</block>

      </case><case>case <expr><name>NESTED_EXIT</name></expr>:
          <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"NESTED_EXIT should be replaced by innermost side exit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </case><default>default:
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"exit_type=%s\n"</expr></argument>, <argument><expr><call><name>getExitName</name><argument_list>(<argument><expr><name><name>lr</name>-&gt;<name>exitType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"Inner tree not suitable for calling"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsEntryTypeCompatible</name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>, <param><decl><type><name>TraceType</name>*</type> <name>m</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>tag</name> <init>= <expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"%c/%c "</expr></argument>, <argument><expr><name><name>tagChar</name><index>[<expr><name>tag</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr>*<name>m</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr>*<name>m</name></expr>)</condition> <block>{
      <case>case <expr><name>TT_OBJECT</name></expr>:
        <if>if <condition>(<expr><name>tag</name> == <name>JSVAL_OBJECT</name> &amp;&amp; !<call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> &amp;&amp;
            !<call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>true</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"object != tag%u "</expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>TT_INT32</name></expr>:
        <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
        <if>if <condition>(<expr><name>tag</name> == <name>JSVAL_DOUBLE</name> &amp;&amp; <call><name>JSDOUBLE_IS_INT</name><argument_list>(<argument><expr>*<call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"int != tag%u(value=%lu) "</expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)*<name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>TT_DOUBLE</name></expr>:
        <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> || <name>tag</name> == <name>JSVAL_DOUBLE</name></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"double != tag%u "</expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>TT_JSVAL</name></expr>:
        <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"shouldn't see jsval type in entry"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>TT_STRING</name></expr>:
        <if>if <condition>(<expr><name>tag</name> == <name>JSVAL_STRING</name></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"string != tag%u "</expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>TT_NULL</name></expr>:
        <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"null != tag%u "</expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>TT_SPECIAL</name></expr>:
        <comment type="block">/* N.B. void is JSVAL_SPECIAL. */</comment>
        <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"bool != tag%u "</expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>TT_VOID</name></expr>:
        <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"undefined != tag%u "</expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
      </case><default>default:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>m</name> == <name>TT_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tag</name> == <name>JSVAL_OBJECT</name> &amp;&amp; !<call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>true</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"fun != tag%u "</expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    </default>}</block></switch>
}</block></function>

<class>class <name>TypeCompatibilityVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>TraceRecorder</name> &amp;</type><name>mRecorder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>mCx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name> *</type><name>mTypeMap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>mStackSlotNum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>mOk</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><name>TypeCompatibilityVisitor</name> <parameter_list>(<param><decl><type><name>TraceRecorder</name> &amp;</type><name>recorder</name></decl></param>,
                              <param><decl><type><name>TraceType</name> *</type><name>typeMap</name></decl></param>)</parameter_list> <member_list>:
        <call><name>mRecorder</name><argument_list>(<argument><expr><name>recorder</name></expr></argument>)</argument_list></call>,
        <call><name>mCx</name><argument_list>(<argument><expr><name><name>mRecorder</name>.<name>cx</name></name></expr></argument>)</argument_list></call>,
        <call><name>mTypeMap</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>)</argument_list></call>,
        <call><name>mStackSlotNum</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
        <call><name>mOk</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>visitGlobalSlot</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"global%d="</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>IsEntryTypeCompatible</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>mTypeMap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mOk</name> = false</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr>!<call><name>isPromoteInt</name><argument_list>(<argument><expr><call><name><name>mRecorder</name>.<name>get</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; *<name>mTypeMap</name> == <name>TT_INT32</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>oracle</name>.<name>markGlobalSlotUndemotable</name></name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mOk</name> = false</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> &amp;&amp; *<name>mTypeMap</name> == <name>TT_DOUBLE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>oracle</name>.<name>markGlobalSlotUndemotable</name></name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if></else></if>
        <expr_stmt><expr><name>mTypeMap</name>++</expr>;</expr_stmt>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
    <name>visitStackSlots</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"%s%u="</expr></argument>, <argument><expr><call><name>stackSlotKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>unsigned</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>IsEntryTypeCompatible</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>mTypeMap</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>mOk</name> = false</expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr>!<call><name>isPromoteInt</name><argument_list>(<argument><expr><call><name><name>mRecorder</name>.<name>get</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; *<name>mTypeMap</name> == <name>TT_INT32</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>oracle</name>.<name>markStackSlotUndemotable</name></name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr><name>mStackSlotNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>mOk</name> = false</expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> &amp;&amp; *<name>mTypeMap</name> == <name>TT_DOUBLE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>oracle</name>.<name>markStackSlotUndemotable</name></name><argument_list>(<argument><expr><name>mCx</name></expr></argument>, <argument><expr><name>mStackSlotNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if></else></if>
            <expr_stmt><expr><name>vp</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>mTypeMap</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>mStackSlotNum</name>++</expr>;</expr_stmt>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><name>bool</name></type> <name>isOk</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mOk</name></expr>;</return>
    }</block></function>
</public>}</block>;</class>

<function><type><name>JS_REQUIRES_STACK</name> <name>TreeFragment</name>*</type>
<name><name>TraceRecorder</name>::<name>findNestedCompatiblePeer</name></name><parameter_list>(<param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tm</name> = &amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ngslots</name> <init>= <expr><call><name><name>tree</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for (<init>;</init> <condition><expr><name>f</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>peer</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>

        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"checking nested types %p: "</expr></argument>, <argument><expr>(<name>void</name>*)<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>ngslots</name> &gt; <call><name><name>f</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>SpecializeTreesToMissingGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="block">/*
         * Determine whether the typemap of the inner tree matches the outer
         * tree's current state. If the inner tree expects an integer, but the
         * outer tree doesn't guarantee an integer for that slot, we mark the
         * slot undemotable and mismatch here. This will force a new tree to be
         * compiled that accepts a double for the slot. If the inner tree
         * expects a double, but the outer tree has an integer, we can proceed,
         * but we mark the location undemotable.
         */</comment>
        <decl_stmt><decl><type><name>TypeCompatibilityVisitor</name></type> <name>visitor</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><call><name><name>f</name>-&gt;<name>typeMap</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>VisitSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>*<name><name>tree</name>-&gt;<name>globalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>" %s\n"</expr></argument>, <argument><expr><call><name><name>visitor</name>.<name>isOk</name></name><argument_list>()</argument_list></call> ? "match" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>visitor</name>.<name>isOk</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>f</name></expr>;</return></then></if>
    }</block></for>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<class>class <name>CheckEntryTypeVisitor</name> <super>: <specifier>public</specifier> <name>SlotVisitorBase</name></super>
<block>{<private type="default">
    <decl_stmt><decl><type><name>bool</name></type> <name>mOk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name> *</type><name>mTypeMap</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><name>CheckEntryTypeVisitor</name><parameter_list>(<param><decl><type><name>TraceType</name> *</type><name>typeMap</name></decl></param>)</parameter_list> <member_list>:
        <call><name>mOk</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call>,
        <call><name>mTypeMap</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>)</argument_list></call>
    </member_list><block>{}</block></constructor>

    <function><type><name>JS_ALWAYS_INLINE</name> <name>void</name></type> <name>checkSlot</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>char</name> <specifier>const</specifier> *</type><name>name</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"%s%d="</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*(<name>uint8_t</name>*)<name>mTypeMap</name> != 0xCD</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mOk</name> = <call><name>IsEntryTypeCompatible</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>mTypeMap</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>void</name></type>
    <name>visitGlobalSlot</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list> <block>{
        <if>if <condition>(<expr><name>mOk</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>checkSlot</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr>"global"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
    <name>visitStackSlots</name><parameter_list>(<param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{
        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<name>mOk</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr><call><name>checkSlot</name><argument_list>(<argument><expr><name>vp</name>++</expr></argument>, <argument><expr><call><name>stackSlotKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>mOk</name></expr>;</return>
    }</block></function>

    <function><type><name>bool</name></type> <name>isOk</name><parameter_list>()</parameter_list> <block>{
        <return>return <expr><name>mOk</name></expr>;</return>
    }</block></function>
</public>}</block>;</class>

<comment type="block" format="doxygen">/**
 * Check if types are usable for trace execution.
 *
 * @param cx            Context.
 * @param f             Tree of peer we're testing.
 * @return              True if compatible (with or without demotions), false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name>CheckEntryTypes</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ngslots</name> <init>= <expr><call><name><name>f</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>nStackTypes</name></name> == <call><name>NativeStackSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>ngslots</name> &gt; <call><name><name>f</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SpecializeTreesToMissingGlobals</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call> == <call><name>NativeStackSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> + <name>ngslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>typeMap</name>.<name>length</name></name><argument_list>()</argument_list></call> == <name><name>f</name>-&gt;<name>nStackTypes</name></name> + <name>ngslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call> == <name>ngslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>CheckEntryTypeVisitor</name></type> <name>visitor</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>typeMap</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitSlots</name><argument_list>(<argument><expr><name>visitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>*<name><name>f</name>-&gt;<name>globalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>visitor</name>.<name>isOk</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Find an acceptable entry tree given a PC.
 *
 * @param cx            Context.
 * @param globalObj     Global object.
 * @param f             First peer fragment.
 * @param nodemote      If true, will try to find a peer that does not require demotion.
 * @out   count         Number of fragments consulted.
 */</comment>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>TreeFragment</name>*</type>
<name>FindVMCompatiblePeer</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>, <param><decl><type><name>uintN</name>&amp;</type> <name>count</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>f</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>peer</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"checking vm types %p (ip: %p): "</expr></argument>, <argument><expr>(<name>void</name>*)<name>f</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>CheckEntryTypes</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>f</name></expr>;</return></then></if>
        <expr_stmt><expr>++<name>count</name></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * For the native stacks and global frame, reuse the storage in |tm-&gt;storage|.
 * This reuse depends on the invariant that only one trace uses |tm-&gt;storage| at
 * a time. This is subtley correct in lieu of deep bail; see comment for
 * |deepBailSp| in DeepBail.
 */</comment>
<macro><name>JS_ALWAYS_INLINE</name></macro>
<constructor><name><name>InterpState</name>::<name>InterpState</name></name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>,
                         <param><decl><type><name>uintN</name>&amp;</type> <name>inlineCallCount</name></decl></param>, <param><decl><type><name>VMSideExit</name>**</type> <name>innermostNestedGuardp</name></decl></param>)</parameter_list>
  <member_list>: <call><name>cx</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>,
    <call><name>stackBase</name><argument_list>(<argument><expr><call><name><name>tm</name>-&gt;<name>storage</name>-&gt;<name>stack</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>sp</name><argument_list>(<argument><expr><name>stackBase</name> + <name><name>f</name>-&gt;<name>nativeStackBase</name></name> / <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>,
    <call><name>eos</name><argument_list>(<argument><expr><call><name><name>tm</name>-&gt;<name>storage</name>-&gt;<name>global</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>callstackBase</name><argument_list>(<argument><expr><call><name><name>tm</name>-&gt;<name>storage</name>-&gt;<name>callstack</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>sor</name><argument_list>(<argument><expr><name>callstackBase</name></expr></argument>)</argument_list></call>,
    <call><name>rp</name><argument_list>(<argument><expr><name>callstackBase</name></expr></argument>)</argument_list></call>,
    <call><name>eor</name><argument_list>(<argument><expr><name>callstackBase</name> + <call><name>JS_MIN</name><argument_list>(<argument><expr><name>MAX_CALL_STACK_ENTRIES</name></expr></argument>,
                               <argument><expr><name>JS_MAX_INLINE_CALL_COUNT</name> - <name>inlineCallCount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>lastTreeExitGuard</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>lastTreeCallGuard</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>rpAtLastTreeCall</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>,
    <call><name>outermostTree</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call>,
    <call><name>inlineCallCountp</name><argument_list>(<argument><expr>&amp;<name>inlineCallCount</name></expr></argument>)</argument_list></call>,
    <call><name>innermostNestedGuardp</name><argument_list>(<argument><expr><name>innermostNestedGuardp</name></expr></argument>)</argument_list></call>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXECUTE_TREE_TIMER</name></cpp:ifdef>
    <call><name>startTime</name><argument_list>(<argument><expr><call><name>rdtsc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <call><name>builtinStatus</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
    <call><name>nativeVp</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
</member_list><block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>tm</name>-&gt;<name>tracecx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>tracecx</name></name> = <name>cx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev</name> = <name><name>cx</name>-&gt;<name>interpState</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>interpState</name></name> = <name>this</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>eos</name> == <name>stackBase</name> + <name>MAX_NATIVE_STACK_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>sp</name> &lt; <name>eos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * inlineCallCount has already been incremented, if being invoked from
     * EnterFrame. It is okay to have a 0-frame restriction since the JIT
     * might not need any frames.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>inlineCallCount</name> &lt;= <name>JS_MAX_INLINE_CALL_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/*
     * Cannot 0xCD-fill global frame since it may overwrite a bailed outer
     * ExecuteTree's 0xdeadbeefdeadbeef marker.
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name><name>tm</name>-&gt;<name>storage</name>-&gt;<name>stack</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0xCD</expr></argument>, <argument><expr><name>MAX_NATIVE_STACK_SLOTS</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name><name>tm</name>-&gt;<name>storage</name>-&gt;<name>callstack</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0xCD</expr></argument>, <argument><expr><name>MAX_CALL_STACK_ENTRIES</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></constructor>

<expr_stmt><expr><name>JS_ALWAYS_INLINE</name>
<macro><name>InterpState</name></macro><name>::~<name>InterpState</name></name>()
<block>{
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>nativeVp</name></expr></argument>)</argument_list></call></expr>;

    <expr><name><name>cx</name>-&gt;<name>interpState</name></name> = <name>prev</name></expr>;
    <expr><call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>tracecx</name> = <name>NULL</name></expr>;
}</block>

<comment type="block">/* Call |f|, return the exit taken. */</comment>
static <name>JS_ALWAYS_INLINE</name> <name>VMSideExit</name>*
<macro><name>ExecuteTrace</name><argument_list>(<argument>JSContext* cx</argument>, <argument>Fragment* f</argument>, <argument>InterpState&amp; state</argument>)</argument_list></macro>
<block>{
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>cx</name>-&gt;<name>bailExit</name></name></expr></argument>)</argument_list></call></expr>;
    <expr>union <block>{ <expr><name>NIns</name> *<name>code</name></expr>; <expr><name>GuardRecord</name>* (<name>FASTCALL</name> *<name>func</name>)(<name>InterpState</name>*)</expr>; }</block> <name>u</name></expr>;
    <expr><name><name>u</name>.<name>code</name></name> = <call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>;
    <expr><name>GuardRecord</name>* <name>rec</name></expr>;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JS_NO_FASTCALL</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>NANOJIT_IA32</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><call><name>SIMULATE_FASTCALL</name><argument_list>(<argument><expr><name>rec</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>u</name>.<name>func</name></name></expr></argument>)</argument_list></call></expr>;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr><name>rec</name> = <call><name><name>u</name>.<name>func</name></name><argument_list>(<argument><expr>&amp;<name>state</name></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>cx</name>-&gt;<name>bailExit</name></name></expr></argument>)</argument_list></call></expr>;
    <return>return <expr>(<name>VMSideExit</name>*)<name><name>rec</name>-&gt;<name>exit</name></name></expr>;</return>
}</block></expr></expr_stmt>

<comment type="block">/* Check whether our assumptions about the incoming scope-chain are upheld. */</comment>
<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>JS_ALWAYS_INLINE</name> <name>bool</name></type>
<name>ScopeChainCheck</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>globalObj</name></name> == <call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getGlobal</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The JIT records and expects to execute with two scope-chain
     * assumptions baked-in:
     *
     *   1. That the bottom of the scope chain is global, in the sense of
     *      JSCLASS_IS_GLOBAL.
     *
     *   2. That the scope chain between fp and the global is free of
     *      "unusual" native objects such as HTML forms or other funny
     *      things.
     *
     * #2 is checked here while following the scope-chain links, via
     * js_IsCacheableNonGlobalScope, which consults a whitelist of known
     * class types; once a global is found, it's checked for #1. Failing
     * either check causes an early return from execution.
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>child</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name></name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<decl><type><name>JSObject</name>*</type> <name>parent</name> <init>= <expr><call><name><name>child</name>-&gt;<name>getParent</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{
        <if>if <condition>(<expr>!<call><name>js_IsCacheableNonGlobalScope</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,<argument><expr>"Blacklist: non-cacheable object on scope chain.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr>(<name>jsbytecode</name>*) <name><name>f</name>-&gt;<name>root</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>child</name> = <name>parent</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>child</name> == <name><name>f</name>-&gt;<name>globalObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!(<call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>globalObj</name></name></expr></argument>)</argument_list></call>-&gt;<name>flags</name> &amp; <name>JSCLASS_IS_GLOBAL</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Blacklist: non-global at root of scope chain.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr>(<name>jsbytecode</name>*) <name><name>f</name>-&gt;<name>root</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Make sure the global object is sane. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>globalObj</name>-&gt;<name>numSlots</name></name><argument_list>()</argument_list></call> &lt;= <name>MAX_GLOBAL_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call> == <call><name><name>f</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call> != 0</expr></argument>,
                 <argument><expr><call><name>OBJ_SHAPE</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>globalObj</name></name></expr></argument>)</argument_list></call> == <name><name>f</name>-&gt;<name>globalShape</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>LeaveTree</name><parameter_list>(<param><decl><type><name>TraceMonitor</name> *</type><name>tm</name></decl></param>, <param><decl><type><name>InterpState</name>&amp;</type></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>lr</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <name>VMSideExit</name>*</type>
<name>ExecuteTree</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl></param>, <param><decl><type><name>uintN</name>&amp;</type> <name>inlineCallCount</name></decl></param>,
            <param><decl><type><name>VMSideExit</name>**</type> <name>innermostNestedGuardp</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
    <function_decl><type><name>TraceVisStateObj</name></type> <name>tvso</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>S_EXECUTE</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>root</name></name> == <name>f</name> &amp;&amp; <call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>ScopeChainCheck</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* Initialize trace state. */</comment>
    <function_decl><type><name>InterpState</name></type> <name>state</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>tm</name></type></decl></param>, <param><decl><type><name>f</name></type></decl></param>, <param><decl><type><name>inlineCallCount</name></type></decl></param>, <param><decl><type><name>innermostNestedGuardp</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>double</name>*</type> <name>stack</name> <init>= <expr><call><name><name>tm</name>-&gt;<name>storage</name>-&gt;<name>stack</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name>*</type> <name>global</name> <init>= <expr><call><name><name>tm</name>-&gt;<name>storage</name>-&gt;<name>global</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>globalObj</name> <init>= <expr><name><name>f</name>-&gt;<name>globalObj</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>ngslots</name> <init>= <expr><call><name><name>f</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name>*</type> <name>gslots</name> <init>= <expr><call><name><name>f</name>-&gt;<name>globalSlots</name>-&gt;<name>data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>BuildNativeFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr>0</expr></argument> <comment type="block">/* callDepth */</comment>, <argument><expr><name>ngslots</name></expr></argument>, <argument><expr><name>gslots</name></expr></argument>,
                     <argument><expr><call><name><name>f</name>-&gt;<name>typeMap</name>.<name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>global</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>traceTriggered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                      <argument><expr>"entering trace at %s:%u@%u, native stack slots: %u code: %p\n"</expr></argument>,
                      <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></argument>,
                      <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>f</name>-&gt;<name>maxNativeStackSlots</name></name></expr></argument>,
                      <argument><expr><call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>debug_only_stmt</name><argument_list>(<argument>uint32 globalSlots = globalObj-&gt;numSlots();</argument>)</argument_list></macro>
    <macro><name>debug_only_stmt</name><argument_list>(<argument>*(uint64*)&amp;tm-&gt;storage-&gt;global()[globalSlots] = 0xdeadbeefdeadbeefLL;</argument>)</argument_list></macro>

    <comment type="block">/* Execute trace. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>lr</name> <init>= <expr>(<call><name>TraceVisStateObj</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>S_NATIVE</name></expr></argument>)</argument_list></call>, <call><name>ExecuteTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>lr</name> <init>= <expr><call><name>ExecuteTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*(<name>uint64</name>*)&amp;<call><name><name>tm</name>-&gt;<name>storage</name>-&gt;<name>global</name></name><argument_list>()</argument_list></call><index>[<expr><name>globalSlots</name></expr>]</index> == 0xdeadbeefdeadbeefLL</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>lr</name>-&gt;<name>exitType</name></name> == <name>LOOP_EXIT</name></expr></argument>, <argument><expr>!<name><name>lr</name>-&gt;<name>calldepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Restore interpreter state. */</comment>
    <expr_stmt><expr><call><name>LeaveTree</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>state</name>.<name>innermost</name></name></expr>;</return>
}</block></function>

<class>class <name>Guardian</name> <block>{<private type="default">
    <decl_stmt><decl><type><name>bool</name> *</type><name>flagp</name></decl>;</decl_stmt>
</private><public>public:
    <constructor><name>Guardian</name><parameter_list>(<param><decl><type><name>bool</name> *</type><name>flagp</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name><name>this</name>-&gt;<name>flagp</name></name> = <name>flagp</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!*<name>flagp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>flagp</name> = true</expr>;</expr_stmt>
    }</block></constructor>

    <destructor><name>~<name>Guardian</name></name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>flagp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>flagp</name> = false</expr>;</expr_stmt>
    }</block></destructor>
</public>}</block>;</class>

<function><type><specifier>static</specifier> <name>JS_FORCES_STACK</name> <name>void</name></type>
<name>LeaveTree</name><parameter_list>(<param><decl><type><name>TraceMonitor</name> *</type><name>tm</name></decl></param>, <param><decl><type><name>InterpState</name>&amp;</type> <name>state</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>lr</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>VOUCH_DOES_NOT_REQUIRE_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSContext</name>*</type> <name>cx</name> <init>= <expr><name><name>state</name>.<name>cx</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Temporary waive the soft GC quota to make sure LeaveTree() doesn't fail. */</comment>
    <decl_stmt><decl><type><name>Guardian</name></type> <name>waiver</name><argument_list>(<argument><expr>&amp;<call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>-&gt;<name>waiveGCQuota</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>FrameInfo</name>**</type> <name>callstack</name> <init>= <expr><name><name>state</name>.<name>callstackBase</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name>*</type> <name>stack</name> <init>= <expr><name><name>state</name>.<name>stackBase</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Except if we find that this is a nested bailout, the guard the call
     * returned is the one we have to use to adjust pc and sp.
     */</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>innermost</name> <init>= <expr><name>lr</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * While executing a tree we do not update state.sp and state.rp even if
     * they grow. Instead, guards tell us by how much sp and rp should be
     * incremented in case of a side exit. When calling a nested tree, however,
     * we actively adjust sp and rp. If we have such frames from outer trees on
     * the stack, then rp will have been adjusted. Before we can process the
     * stack of the frames of the tree we directly exited from, we have to
     * first work our way through the outer frames and generate interpreter
     * frames for them. Once the call stack (rp) is empty, we can process the
     * final frames (which again are not directly visible and only the guard we
     * exited on will tells us about).
     */</comment>
    <decl_stmt><decl><type><name>FrameInfo</name>**</type> <name>rp</name> <init>= <expr>(<name>FrameInfo</name>**)<name><name>state</name>.<name>rp</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>lr</name>-&gt;<name>exitType</name></name> == <name>NESTED_EXIT</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>nested</name> <init>= <expr><name><name>state</name>.<name>lastTreeCallGuard</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>nested</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If lastTreeCallGuard is not set in state, we only have a single
             * level of nesting in this exit, so lr itself is the innermost and
             * outermost nested guard, and hence we set nested to lr. The
             * calldepth of the innermost guard is not added to state.rp, so we
             * do it here manually. For a nesting depth greater than 1 the
             * call tree code already added the innermost guard's calldepth
             * to state.rpAtLastTreeCall.
             */</comment>
            <expr_stmt><expr><name>nested</name> = <name>lr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rp</name> += <name><name>lr</name>-&gt;<name>calldepth</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * During unwinding state.rp gets overwritten at every step and we
             * restore it here to its state at the innermost nested guard. The
             * builtin already added the calldepth of that innermost guard to
             * rpAtLastTreeCall.
             */</comment>
            <expr_stmt><expr><name>rp</name> = (<name>FrameInfo</name>**)<name><name>state</name>.<name>rpAtLastTreeCall</name></name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>innermost</name> = <name><name>state</name>.<name>lastTreeExitGuard</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>state</name>.<name>innermostNestedGuardp</name></name></expr>)</condition><then>
            <expr_stmt><expr>*<name><name>state</name>.<name>innermostNestedGuardp</name></name> = <name>nested</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>nested</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>nested</name>-&gt;<name>exitType</name></name> == <name>NESTED_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>state</name>.<name>lastTreeExitGuard</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>state</name>.<name>lastTreeExitGuard</name>-&gt;<name>exitType</name></name> != <name>NESTED_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>bs</name> <init>= <expr><name><name>state</name>.<name>builtinStatus</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>bailed</name> <init>= <expr><name><name>innermost</name>-&gt;<name>exitType</name></name> == <name>STATUS_EXIT</name> &amp;&amp; (<name>bs</name> &amp; <name>BUILTIN_BAILED</name>)</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>bailed</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Deep-bail case.
         *
         * A _FAIL native already called LeaveTree. We already reconstructed
         * the interpreter stack, in pre-call state, with pc pointing to the
         * CALL/APPLY op, for correctness. Then we continued in native code.
         *
         * First, if we just returned from a slow native, pop its stack frame.
         */</comment>
        <if>if <condition>(<expr>!<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>FUN_SLOW_NATIVE</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>fp</name>-&gt;<name>regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>down</name>-&gt;<name>regs</name></name> != &amp;((<name>JSInlineFrame</name> *) <name>fp</name>)-&gt;<name>callerRegs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cx</name>-&gt;<name>fp</name></name> = <name><name>fp</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>stackPool</name></name></expr></argument>, <argument><expr>((<name>JSInlineFrame</name> *) <name>fp</name>)-&gt;<name>mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!(<name>bs</name> &amp; <name>BUILTIN_ERROR</name>)</expr>)</condition><then> <block>{
            <comment type="block">/*
             * The builtin or native deep-bailed but finished successfully
             * (no exception or error).
             *
             * After it returned, the JIT code stored the results of the
             * builtin or native at the top of the native stack and then
             * immediately flunked the guard on state-&gt;builtinStatus.
             *
             * Now LeaveTree has been called again from the tail of
             * ExecuteTree. We are about to return to the interpreter. Adjust
             * the top stack frame to resume on the next op.
             */</comment>
            <decl_stmt><decl><type><name>JSFrameRegs</name>*</type> <name>regs</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name> <init>= <expr>(<name>JSOp</name>) *<name><name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_CALL</name> || <name>op</name> == <name>JSOP_APPLY</name> || <name>op</name> == <name>JSOP_NEW</name> ||
                      <name>op</name> == <name>JSOP_GETPROP</name> || <name>op</name> == <name>JSOP_GETTHISPROP</name> || <name>op</name> == <name>JSOP_GETARGPROP</name> ||
                      <name>op</name> == <name>JSOP_GETLOCALPROP</name> || <name>op</name> == <name>JSOP_LENGTH</name> ||
                      <name>op</name> == <name>JSOP_GETELEM</name> || <name>op</name> == <name>JSOP_CALLELEM</name> || <name>op</name> == <name>JSOP_CALLPROP</name> ||
                      <name>op</name> == <name>JSOP_SETPROP</name> || <name>op</name> == <name>JSOP_SETNAME</name> || <name>op</name> == <name>JSOP_SETMETHOD</name> ||
                      <name>op</name> == <name>JSOP_SETELEM</name> || <name>op</name> == <name>JSOP_INITELEM</name> || <name>op</name> == <name>JSOP_ENUMELEM</name> ||
                      <name>op</name> == <name>JSOP_INSTANCEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * JSOP_SETELEM can be coalesced with a JSOP_POP in the interpeter.
             * Since this doesn't re-enter the recorder, the post-state snapshot
             * is invalid. Fix it up here.
             */</comment>
            <if>if <condition>(<expr><name>op</name> == <name>JSOP_SETELEM</name> &amp;&amp; <call><name>JSOp</name><argument_list>(<argument><expr><name><name>regs</name>-&gt;<name>pc</name><index>[<expr><name>JSOP_SETELEM_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call> == <name>JSOP_POP</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>regs</name>-&gt;<name>sp</name></name> -= <name><name>js_CodeSpec</name><index>[<expr><name>JSOP_SETELEM</name></expr>]</index></name>.<name>nuses</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>regs</name>-&gt;<name>sp</name></name> += <name><name>js_CodeSpec</name><index>[<expr><name>JSOP_SETELEM</name></expr>]</index></name>.<name>ndefs</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>regs</name>-&gt;<name>pc</name></name> += <name>JSOP_SETELEM_LENGTH</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>JSOP_POP</name></expr>;</expr_stmt>
            }</block></then></if>

            <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name>&amp;</type> <name>cs</name> <init>= <expr><name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>regs</name>-&gt;<name>sp</name></name> -= (<name><name>cs</name>.<name>format</name></name> &amp; <name>JOF_INVOKE</name>) ? <call><name>GET_ARGC</name><argument_list>(<argument><expr><name><name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call> + 2 : <name><name>cs</name>.<name>nuses</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>regs</name>-&gt;<name>sp</name></name> += <name><name>cs</name>.<name>ndefs</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>regs</name>-&gt;<name>pc</name></name> += <name><name>cs</name>.<name>length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name></expr></argument>,
                         <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name></name> + <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name> +
                         <call><name>js_ReconstructStackDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name><name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call> ==
                         <name><name>regs</name>-&gt;<name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If there's a tree call around the point that we deep exited at,
             * then state.sp and state.rp were restored to their original
             * values before the tree call and sp might be less than deepBailSp,
             * which we sampled when we were told to deep bail.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>state</name>.<name>deepBailSp</name></name> &gt;= <name><name>state</name>.<name>stackBase</name></name> &amp;&amp; <name><name>state</name>.<name>sp</name></name> &lt;= <name><name>state</name>.<name>deepBailSp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * As explained above, the JIT code stored a result value or values
             * on the native stack. Transfer them to the interpreter stack now.
             * (Some opcodes, like JSOP_CALLELEM, produce two values, hence the
             * loop.)
             */</comment>
            <decl_stmt><decl><type><name>TraceType</name>*</type> <name>typeMap</name> <init>= <expr><call><name><name>innermost</name>-&gt;<name>stackTypeMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name><name>cs</name>.<name>ndefs</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <if>if <condition>(<expr>!<call><name>NativeToValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>,
                                   <argument><expr><name><name>regs</name>-&gt;<name>sp</name><index>[<expr>-<name>i</name></expr>]</index></name></expr></argument>,
                                   <argument><expr><name><name>typeMap</name><index>[<expr><name><name>innermost</name>-&gt;<name>numStackSlots</name></name> - <name>i</name></expr>]</index></name></expr></argument>,
                                   <argument><expr>(<name>jsdouble</name> *) <name><name>state</name>.<name>deepBailSp</name></name>
                                   + <name><name>innermost</name>-&gt;<name>sp_adj</name></name> / <sizeof>sizeof<argument_list>(<argument><expr><name>jsdouble</name></expr></argument>)</argument_list></sizeof> - <name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>OutOfMemoryAbort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* Save the innermost FrameInfo for guardUpRecursion */</comment>
    <if>if <condition>(<expr><name><name>innermost</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_MISMATCH_EXIT</name></expr>)</condition><then> <block>{
        <comment type="block">/* There should never be a static calldepth for a recursive mismatch. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>innermost</name>-&gt;<name>calldepth</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* There must be at least one item on the rp stack. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>callstack</name> &lt; <name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* :TODO: don't be all squirrelin' this in here */</comment>
        <expr_stmt><expr><name><name>innermost</name>-&gt;<name>recursive_down</name></name> = *(<name>rp</name> - 1)</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Slurp failure should have no frames */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>innermost</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_SLURP_FAIL_EXIT</name></expr></argument>,
                 <argument><expr><name><name>innermost</name>-&gt;<name>calldepth</name></name> == 0 &amp;&amp; <name>callstack</name> == <name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>callstack</name> &lt; <name>rp</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>FrameInfo</name>*</type> <name>fi</name> <init>= <expr>*<name>callstack</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Peek at the callee native slot in the not-yet-synthesized down frame. */</comment>
        <decl_stmt><decl><type><name>JSObject</name>*</type> <name>callee</name> <init>= <expr>*(<name>JSObject</name>**)&amp;<name><name>stack</name><index>[<expr><name><name>fi</name>-&gt;<name>callerHeight</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Synthesize a stack frame and write out the values in it using the
         * type map pointer on the native call stack.
         */</comment>
        <expr_stmt><expr><call><name>SynthesizeFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>*<name>fi</name></expr></argument>, <argument><expr><name>callee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>slots</name> <init>= <expr><call><name>FlushNativeStackFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>1</expr></argument> <comment type="block">/* callDepth */</comment>, <argument><expr><call><name>(*<name>callstack</name>)-&gt;<name>get_typemap</name></name><argument_list>()</argument_list></call></expr></argument>,
                                          <argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"synthesized deep frame for %s:%u@%u, slots=%d, fi=%p\n"</expr></argument>,
                          <argument><expr><name><name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></argument>,
                          <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>slots</name></expr></argument>,
                          <argument><expr>(<name>void</name>*)*<name>callstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Keep track of the additional frames we put on the interpreter stack
         * and the native stack slots we consumed.
         */</comment>
        <expr_stmt><expr>++*<name><name>state</name>.<name>inlineCallCountp</name></name></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>callstack</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>stack</name> += <name>slots</name></expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/*
     * We already synthesized the frames around the innermost guard. Here we
     * just deal with additional frames inside the tree we are bailing out
     * from.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>rp</name> == <name>callstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>calldepth</name> <init>= <expr><name><name>innermost</name>-&gt;<name>calldepth</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>calldepth_slots</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>calleeOffset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>n</name> &lt; <name>calldepth</name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
        <comment type="block">/* Peek at the callee native slot in the not-yet-synthesized down frame. */</comment>
        <expr_stmt><expr><name>calleeOffset</name> += <name><name>callstack</name><index>[<expr><name>n</name></expr>]</index></name>-&gt;<name>callerHeight</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>JSObject</name>*</type> <name>callee</name> <init>= <expr>*(<name>JSObject</name>**)&amp;<name><name>stack</name><index>[<expr><name>calleeOffset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Reconstruct the frame. */</comment>
        <expr_stmt><expr><name>calldepth_slots</name> += <call><name>SynthesizeFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>*<name><name>callstack</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>callee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>++*<name><name>state</name>.<name>inlineCallCountp</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                          <argument><expr>"synthesized shallow frame for %s:%u@%u\n"</expr></argument>,
                          <argument><expr><name><name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></for>

    <comment type="block">/*
     * Adjust sp and pc relative to the tree we exited from (not the tree we
     * entered into).  These are our final values for sp and pc since
     * SynthesizeFrame has already taken care of all frames in between. But
     * first we recover fp-&gt;blockChain, which comes from the side exit
     * struct.
     */</comment>
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>fp</name>-&gt;<name>blockChain</name></name> = <name><name>innermost</name>-&gt;<name>block</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If we are not exiting from an inlined frame, the state-&gt;sp is spbase.
     * Otherwise spbase is whatever slots frames around us consume.
     */</comment>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> = <name><name>innermost</name>-&gt;<name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>imacpc</name></name> = <name><name>innermost</name>-&gt;<name>imacpc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> = <call><name>StackBase</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> + (<name><name>innermost</name>-&gt;<name>sp_adj</name></name> / <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof>) - <name>calldepth_slots</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name><name>fp</name>-&gt;<name>imacpc</name></name></expr></argument>,
                 <argument><expr><name><name>fp</name>-&gt;<name>slots</name></name> + <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name> +
                 <call><name>js_ReconstructStackDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call> == <name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXECUTE_TREE_TIMER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uint64</name></type> <name>cycles</name> <init>= <expr><call><name>rdtsc</name><argument_list>()</argument_list></call> - <name><name>state</name>.<name>startTime</name></name></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JS_JIT_SPEW</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <decl_stmt><decl><type><name>uint64</name></type> <name>cycles</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                      <argument><expr>"leaving trace at %s:%u@%u, op=%s, lr=%p, exitType=%s, sp=%lld, "
                      "calldepth=%d, cycles=%llu\n"</expr></argument>,
                      <argument><expr><name><name>fp</name>-&gt;<name>script</name>-&gt;<name>filename</name></name></expr></argument>,
                      <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>js_CodeName</name><index>[<expr><name><name>fp</name>-&gt;<name>imacpc</name></name> ? *<name><name>fp</name>-&gt;<name>imacpc</name></name> : *<name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr>]</index></name></expr></argument>,
                      <argument><expr>(<name>void</name>*)<name>lr</name></expr></argument>,
                      <argument><expr><call><name>getExitName</name><argument_list>(<argument><expr><name><name>lr</name>-&gt;<name>exitType</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call>(<name>long</name> <name>long</name> <name>int</name>)<argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> - <call><name>StackBase</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>calldepth</name></expr></argument>,
                      <argument><expr>(<name>unsigned</name> <name>long</name> <name>long</name> <name>int</name>)<name>cycles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If this trace is part of a tree, later branches might have added
     * additional globals for which we don't have any type information
     * available in the side exit. We merge in this information from the entry
     * type-map. See also the comment in the constructor of TraceRecorder
     * regarding why this is always safe to do.
     */</comment>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>outermostTree</name> <init>= <expr><name><name>state</name>.<name>outermostTree</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name>*</type> <name>gslots</name> <init>= <expr><call><name><name>outermostTree</name>-&gt;<name>globalSlots</name>-&gt;<name>data</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>ngslots</name> <init>= <expr><call><name><name>outermostTree</name>-&gt;<name>globalSlots</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ngslots</name> == <call><name><name>outermostTree</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>TraceType</name>*</type> <name>globalTypeMap</name></decl>;</decl_stmt>

    <comment type="block">/* Are there enough globals? */</comment>
    <decl_stmt><decl><type><name>TypeMap</name>&amp;</type> <name>typeMap</name> <init>= <expr>*<name><name>tm</name>-&gt;<name>cachedTempTypeMap</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>typeMap</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>innermost</name>-&gt;<name>numGlobalSlots</name></name> == <name>ngslots</name></expr>)</condition><then> <block>{
        <comment type="block">/* Yes. This is the ideal fast path. */</comment>
        <expr_stmt><expr><name>globalTypeMap</name> = <call><name><name>innermost</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * No. Merge the typemap of the innermost entry and exit together. This
         * should always work because it is invalid for nested trees or linked
         * trees to have incompatible types. Thus, whenever a new global type
         * is lazily added into a tree, all dependent and linked trees are
         * immediately specialized (see bug 476653).
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>innermost</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call>-&gt;<call><name>nGlobalTypes</name><argument_list>()</argument_list></call> == <name>ngslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>innermost</name>-&gt;<name>root</name></name><argument_list>()</argument_list></call>-&gt;<call><name>nGlobalTypes</name><argument_list>()</argument_list></call> &gt; <name><name>innermost</name>-&gt;<name>numGlobalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>typeMap</name>.<name>ensure</name></name><argument_list>(<argument><expr><name>ngslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>check_ngslots</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr><call><name>BuildGlobalTypeMapFromInnerTree</name><argument_list>(<argument><expr><name>typeMap</name></expr></argument>, <argument><expr><name>innermost</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>check_ngslots</name> == <name>ngslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>globalTypeMap</name> = <call><name><name>typeMap</name>.<name>data</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Write back the topmost native stack frame. */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>ignoreSlots</name> <init>= <expr><name><name>innermost</name>-&gt;<name>exitType</name></name> == <name>RECURSIVE_SLURP_FAIL_EXIT</name> ?
                           <name><name>innermost</name>-&gt;<name>numStackSlots</name></name> - 1 : 0</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>slots</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr><call><name>FlushNativeStackFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>innermost</name>-&gt;<name>calldepth</name></name></expr></argument>,
                              <argument><expr><call><name><name>innermost</name>-&gt;<name>stackTypeMap</name></name><argument_list>()</argument_list></call></expr></argument>,
                              <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ignoreSlots</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>unsigned</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call> == <name><name>innermost</name>-&gt;<name>numStackSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>innermost</name>-&gt;<name>nativeCalleeWord</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SynthesizeSlowNativeFrame</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>innermost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Write back interned globals. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>state</name>.<name>eos</name></name> == <name><name>state</name>.<name>stackBase</name></name> + <name>MAX_NATIVE_STACK_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>globalObj</name> <init>= <expr><name><name>outermostTree</name>-&gt;<name>globalObj</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>FlushNativeGlobalFrame</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name><name>state</name>.<name>eos</name></name></expr></argument>, <argument><expr><name>ngslots</name></expr></argument>, <argument><expr><name>gslots</name></expr></argument>, <argument><expr><name>globalTypeMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/* Verify that our state restoration worked. */</comment>
    <for>for (<init><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</init> <condition><expr><name>fp</name></expr>;</condition> <incr><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr></incr>) <block>{
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>argv</name></name></expr></argument>, <argument><expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>argv</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>innermost</name>-&gt;<name>exitType</name></name> != <name>TIMEOUT_EXIT</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>sideExitIntoInterpreter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>timeoutIntoInterpreter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>state</name>.<name>innermost</name></name> = <name>innermost</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name>MonitorLoopEdge</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>uintN</name>&amp;</type> <name>inlineCallCount</name></decl></param>, <param><decl><type><name>RecordReason</name></type> <name>reason</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
    <function_decl><type><name>TraceVisStateObj</name></type> <name>tvso</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>S_MONITOR</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Is the recorder currently active? */</comment>
    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>recorder</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pc</name> == <name><name>tm</name>-&gt;<name>recorder</name>-&gt;<name>tree</name>-&gt;<name>ip</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>tm</name>-&gt;<name>recorder</name>-&gt;<name>closeLoop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><call><name><name>TraceRecorder</name>::<name>recordLoopEdge</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>tm</name>-&gt;<name>recorder</name></name></expr></argument>, <argument><expr><name>inlineCallCount</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>true</expr>;</return></then></if>

            <comment type="block">/*
             * recordLoopEdge will invoke an inner tree if we have a matching
             * one. If we arrive here, that tree didn't run to completion and
             * instead we mis-matched or the inner tree took a side exit other than
             * the loop exit. We are thus no longer guaranteed to be parked on the
             * same loop header js_MonitorLoopEdge was called for. In fact, this
             * might not even be a loop header at all. Hence if the program counter
             * no longer hovers over the inner loop header, return to the
             * interpreter and do not attempt to trigger or record a new tree at
             * this location.
             */</comment>
            <if>if <condition>(<expr><name>pc</name> != <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
                <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_INNER_SIDE_EXIT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return <expr>false</expr>;</return>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>tm</name>-&gt;<name>recorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Make sure the shape of the global object still matches (this might flush
     * the JIT cache).
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>globalObj</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getGlobal</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>globalShape</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SlotList</name>*</type> <name>globalSlots</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>CheckGlobalObjectShape</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr>&amp;<name>globalShape</name></expr></argument>, <argument><expr>&amp;<name>globalSlots</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>Backoff</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Do not enter the JIT code with a pending operation callback. */</comment>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>operationCallbackFlag</name></name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
        <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_CALLBACK_PENDING</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>argc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>f</name> <init>= <expr><call><name>LookupOrAddLoop</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>globalShape</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If we have no code in the anchor and no peers, we definitively won't be
     * able to activate any trees, so start compiling.
     */</comment>
    <if>if <condition>(<expr>!<call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call> &amp;&amp; !<name><name>f</name>-&gt;<name>peer</name></name></expr>)</condition><then> <block>{
    <label><name>record</name>:</label>
        <if>if <condition>(<expr>++<call><name><name>f</name>-&gt;<name>hits</name></name><argument_list>()</argument_list></call> &lt; <name>HOTLOOP</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
            <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <call><name><name>f</name>-&gt;<name>hits</name></name><argument_list>()</argument_list></call> &lt; 1 ? <name>R_BACKED_OFF</name> : <name>R_COLD</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return <expr>false</expr>;</return>
        }</block></then></if>

        <comment type="block">/*
         * We can give RecordTree the root peer. If that peer is already taken,
         * it will walk the peer list and find us a free slot or allocate a new
         * tree if needed.
         */</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>rv</name> <init>= <expr><call><name>RecordTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>first</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>globalSlots</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
        <if>if <condition>(<expr>!<name>rv</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_FAIL_RECORD_TREE</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                      <argument><expr>"Looking for compat peer %d@%d, from %p (ip: %p)\n"</expr></argument>,
                      <argument><expr><call><name>js_FramePCToLineNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>FramePCOffset</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>void</name>*)<name>f</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uintN</name></type> <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>match</name> <init>= <expr><call><name>FindVMCompatiblePeer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>match</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>count</name> &lt; <name>MAXPEERS</name></expr>)</condition><then>
            <goto>goto <name>record</name>;</goto></then></if>

        <comment type="block">/*
         * If we hit the max peers ceiling, don't try to lookup fragments all
         * the time. That's expensive. This must be a rather type-unstable loop.
         */</comment>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Blacklisted: too many peer trees.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Blacklist</name><argument_list>(<argument><expr>(<name>jsbytecode</name>*) <name><name>f</name>-&gt;<name>root</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
        <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_MAX_PEERS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Trees that only unwind recursive frames usually won't do much work, and
     * most time will be spent entering and exiting ExecuteTree(). There's no
     * benefit to doing this until the down-recursive side completes.
     */</comment>
    <if>if <condition>(<expr><name><name>match</name>-&gt;<name>recursion</name></name> == <name>Recursion_Unwinds</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>lr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>innermostNestedGuard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>lr</name> = <call><name>ExecuteTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>inlineCallCount</name></expr></argument>, <argument><expr>&amp;<name>innermostNestedGuard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>lr</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
        <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_FAIL_EXECUTE_TREE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * If we exit on a branch, or on a tree call guard, try to grow the inner
     * tree (in case of a branch exit), or the tree nested around the tree we
     * exited from (in case of the tree call guard).
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>rv</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>lr</name>-&gt;<name>exitType</name></name></expr>)</condition> <block>{
      <case>case <expr><name>RECURSIVE_UNLINKED_EXIT</name></expr>:
      </case><case>case <expr><name>UNSTABLE_LOOP_EXIT</name></expr>:
          <expr_stmt><expr><name>rv</name> = <call><name>AttemptToStabilizeTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
          <if>if <condition>(<expr>!<name>rv</name></expr>)</condition><then>
              <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_FAIL_STABILIZE</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <return>return <expr><name>rv</name></expr>;</return>

      </case><case>case <expr><name>OVERFLOW_EXIT</name></expr>:
        <expr_stmt><expr><call><name><name>oracle</name>.<name>markInstructionUndemotable</name></name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* FALL THROUGH */</comment>
      </case><case>case <expr><name>RECURSIVE_SLURP_FAIL_EXIT</name></expr>:
      </case><case>case <expr><name>RECURSIVE_SLURP_MISMATCH_EXIT</name></expr>:
      </case><case>case <expr><name>RECURSIVE_EMPTY_RP_EXIT</name></expr>:
      </case><case>case <expr><name>RECURSIVE_MISMATCH_EXIT</name></expr>:
      </case><case>case <expr><name>BRANCH_EXIT</name></expr>:
      </case><case>case <expr><name>CASE_EXIT</name></expr>:
        <return>return <expr><call><name>AttemptToExtendTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
                                          , <argument><expr>&amp;<name>tvso</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                 )</argument_list></call></expr>;</return>

      </case><case>case <expr><name>RECURSIVE_LOOP_EXIT</name></expr>:
      </case><case>case <expr><name>LOOP_EXIT</name></expr>:
        <if>if <condition>(<expr><name>innermostNestedGuard</name></expr>)</condition><then>
            <return>return <expr><call><name>AttemptToExtendTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>innermostNestedGuard</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
                                            , <argument><expr>&amp;<name>tvso</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   )</argument_list></call></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
        <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_NO_EXTEND_OUTER</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr>false</expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
      </case><case>case <expr><name>MISMATCH_EXIT</name></expr>:  <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_MISMATCH_EXIT</name></expr>;</expr_stmt>  <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>OOM_EXIT</name></expr>:       <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_OOM_EXIT</name></expr>;</expr_stmt>       <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>TIMEOUT_EXIT</name></expr>:   <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_TIMEOUT_EXIT</name></expr>;</expr_stmt>   <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>DEEP_BAIL_EXIT</name></expr>: <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_DEEP_BAIL_EXIT</name></expr>;</expr_stmt> <return>return <expr>false</expr>;</return>
      </case><case>case <expr><name>STATUS_EXIT</name></expr>:    <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_STATUS_EXIT</name></expr>;</expr_stmt>    <return>return <expr>false</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      </case><default>default:
        <comment type="block">/*
         * No, this was an unusual exit (i.e. out of memory/GC), so just resume
         * interpretation.
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>
        <expr_stmt><expr><name><name>tvso</name>.<name>r</name></name> = <name>R_OTHER_EXIT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr>false</expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>monitorRecording</name></name><parameter_list>(<param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceMonitor</name> &amp;</type><name>localtm</name> <init>= <expr><call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <macro><name>debug_only_stmt</name><argument_list>( <argument>JSContext *localcx = cx;</argument> )</argument_list></macro>

    <comment type="block">/* Process needFlush requests now. */</comment>
    <if>if <condition>(<expr><name><name>localtm</name>.<name>needFlush</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_DEEP_BAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>fragment</name>-&gt;<name>lastIns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Clear one-shot state used to communicate between record_JSOP_CALL and post-
     * opcode-case-guts record hook (record_NativeCallComplete).
     */</comment>
    <expr_stmt><expr><name>pendingSpecializedNative</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newobj_ins</name> = <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Handle one-shot request from finishGetProp or INSTANCEOF to snapshot post-op state and guard. */</comment>
    <if>if <condition>(<expr><name>pendingGuardCondition</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>pendingGuardCondition</name></expr></argument>, <argument><expr><name>STATUS_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pendingGuardCondition</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Handle one-shot request to unbox the result of a property get. */</comment>
    <if>if <condition>(<expr><name>pendingUnboxSlot</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>val_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr><name>pendingUnboxSlot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>val_ins</name> = <call><name>unbox_jsval</name><argument_list>(<argument><expr>*<name>pendingUnboxSlot</name></expr></argument>, <argument><expr><name>val_ins</name></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>pendingUnboxSlot</name></expr></argument>, <argument><expr><name>val_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pendingUnboxSlot</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <macro><name>debug_only_stmt</name><argument_list>(
        <argument>if (LogController.lcbits &amp; LC_TMRecorder) {
            js_Disassemble1(cx, cx-&gt;fp-&gt;script, cx-&gt;fp-&gt;regs-&gt;pc,
                            cx-&gt;fp-&gt;imacpc
                                ? 0 : cx-&gt;fp-&gt;regs-&gt;pc - cx-&gt;fp-&gt;script-&gt;code,
                            !cx-&gt;fp-&gt;imacpc, stdout);
        }</argument>
    )</argument_list></macro>

    <comment type="block">/*
     * If op is not a break or a return from a loop, continue recording and
     * follow the trace. We check for imacro-calling bytecodes inside each
     * switch case to resolve the if (JSOP_IS_IMACOP(x)) conditions at compile
     * time.
     */</comment>

    <decl_stmt><decl><type><name>AbortableRecordingStatus</name></type> <name>status</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type> <name>wasInImacro</name> <init>= <expr>(<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name> != <name>NULL</name>)</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
      <default>default:
          <expr_stmt><expr><name>status</name> = <name>ARECORD_ERROR</name></expr>;</expr_stmt>
          <goto>goto <name>stop_recording</name>;</goto>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>OPDEF</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>val</name></type></param>,<param><type><name>name</name></type></param>,<param><type><name>token</name></type></param>,<param><type><name>length</name></type></param>,<param><type><name>nuses</name></type></param>,<param><type><name>ndefs</name></type></param>,<param><type><name>prec</name></type></param>,<param><type><name>format</name></type></param>)</parameter_list></cpp:macro>               \
      <cpp:value>case x:                                                                 \
        status = this-&gt;record_##x();                                            \
        if (JSOP_IS_IMACOP(x))                                                \
            goto imacro;                                                      \
        break;</cpp:value></cpp:define>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.tbl"</cpp:file></cpp:include>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>OPDEF</name></cpp:undef>
    </default>}</block></switch>

    <comment type="block">/* Careful, |this| may have been deleted. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>status</name> != <name>ARECORD_IMACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr>!<name>wasInImacro</name></expr></argument>, <argument><expr><name><name>localcx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <label><name>imacro</name>:</label>
    <comment type="block">/* |this| may be killed while recording. */</comment>
    <if>if <condition>(<expr><name>status</name> == <name>ARECORD_COMPLETED</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>localtm</name>.<name>recorder</name></name> != <name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>localtm</name>.<name>recorder</name></name> ? <name>ARECORD_CONTINUE</name> : <name>ARECORD_COMPLETED</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>status</name> == <name>ARECORD_ABORTED</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>localtm</name>.<name>recorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
    }</block></then></if>

  <label><name>stop_recording</name>:</label>
    <comment type="block">/* Handle lazy abort / OOM. */</comment>
    <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call> || <call><name>OverfullJITCache</name><argument_list>(<argument><expr>&amp;<name>localtm</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ResetJIT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>FR_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>StatusAbortsRecording</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>js_CodeName</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name>AbortRecording</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>reason</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>TRACE_RECORDER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE_RECORDER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>-&gt;<call><name>finishAbort</name><argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>TRACE_RECORDER</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>-&gt;<call><name>finishAbort</name><argument_list>(<argument><expr>"[no reason]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_IA32</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckForSSE2</name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>c</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"X86_FORCE_SSE2"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>c</name></expr>)</condition><then>
        <return>return <expr>(!<call><name>strcmp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call> ||
                !<call><name>strcmp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call> ||
                !<call><name>strcmp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>"yes"</expr></argument>)</argument_list></call>)</expr>;</return></then></if>

    <decl_stmt><decl><type><name>int</name></type> <name>features</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_MSC_VER</name></expr></cpp:if>
    <asm>__asm</asm>
    <block>{
        <decl_stmt><decl><type><name>pushad</name>
        <name>mov</name></type> <name>eax</name></decl>, 1
        <decl><type ref="prev"/><name>cpuid</name>
        <name>mov</name> <name>features</name></decl>, <decl><type ref="prev"/><name>edx</name>
        <name>popad</name></decl></decl_stmt>
    }</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name></expr></cpp:elif>
    <asm>asm("xchg %%esi, %%ebx\n" <comment type="block">/* we can't clobber ebx on gcc (PIC register) */</comment>
        "mov $0x01, %%eax\n"
        "cpuid\n"
        "mov %%edx, %0\n"
        "xchg %%esi, %%ebx\n"
        : "=m" (features)
        : <comment type="block">/* We have no inputs */</comment>
        : "%eax", "%esi", "%ecx", "%edx"
       );</asm>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__SUNPRO_C</name> || <name>defined</name> <name>__SUNPRO_CC</name></expr></cpp:elif>
    <asm>asm("push %%ebx\n"
        "mov $0x01, %%eax\n"
        "cpuid\n"
        "pop %%ebx\n"
        : "=d" (features)
        : <comment type="block">/* We have no inputs */</comment>
        : "%eax", "%ecx"
       );</asm>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>(<name>features</name> &amp; (1&lt;&lt;26)) != 0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NANOJIT_ARM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>WINCE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="line">// these come in from jswince.asm</comment>
<extern>extern "C" <function_decl><type><name>int</name></type> <name>js_arm_try_armv5_op</name><parameter_list>()</parameter_list>;</function_decl></extern>
<extern>extern "C" <function_decl><type><name>int</name></type> <name>js_arm_try_armv6_op</name><parameter_list>()</parameter_list>;</function_decl></extern>
<extern>extern "C" <function_decl><type><name>int</name></type> <name>js_arm_try_armv7_op</name><parameter_list>()</parameter_list>;</function_decl></extern>
<extern>extern "C" <function_decl><type><name>int</name></type> <name>js_arm_try_vfp_op</name><parameter_list>()</parameter_list>;</function_decl></extern>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>arm_check_arch</name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>arch</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>
    <macro><name>__try</name></macro> <block>{
        <expr_stmt><expr><call><name>js_arm_try_armv5_op</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>arch</name> = 5</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_arm_try_armv6_op</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>arch</name> = 6</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_arm_try_armv7_op</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>arch</name> = 7</expr>;</expr_stmt>
    }</block> <macro><name>__except</name><argument_list>(<argument>GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION</argument>)</argument_list></macro> <block>{
    }</block>
    <return>return <expr><name>arch</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arm_check_vfp</name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WINCE_WINDOWS_MOBILE</name></cpp:ifdef>
    <return>return <expr>false</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
    <macro><name>__try</name></macro> <block>{
        <expr_stmt><expr><call><name>js_arm_try_vfp_op</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> = true</expr>;</expr_stmt>
    }</block> <macro><name>__except</name><argument_list>(<argument>GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><name>ret</name> = false</expr>;</expr_stmt>
    }</block>
    <return>return <expr><name>ret</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_ENABLE_DISABLE_DEBUGGER_EXCEPTIONS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* See "Suppressing Exception Notifications while Debugging", at
 * http://msdn.microsoft.com/en-us/library/ms924252.aspx
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>disable_debugger_exceptions</name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// 2 == TLSSLOT_KERNEL</comment>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>kctrl</name> <init>= <expr>(<name>DWORD</name>) <call><name>TlsGetValue</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// 0x12 = TLSKERN_NOFAULT | TLSKERN_NOFAULTMSG</comment>
    <expr_stmt><expr><name>kctrl</name> |= 0x12</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TlsSetValue</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr>(<name>LPVOID</name>) <name>kctrl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>enable_debugger_exceptions</name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// 2 == TLSSLOT_KERNEL</comment>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>kctrl</name> <init>= <expr>(<name>DWORD</name>) <call><name>TlsGetValue</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// 0x12 = TLSKERN_NOFAULT | TLSKERN_NOFAULTMSG</comment>
    <expr_stmt><expr><name>kctrl</name> &amp;= ~0x12</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TlsSetValue</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr>(<name>LPVOID</name>) <name>kctrl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>AVMPLUS_LINUX</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<comment type="line">// Assume ARMv4 by default.</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>arm_arch</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>arm_has_vfp</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>arm_has_neon</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>arm_has_iwmmxt</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>arm_tests_initialized</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arm_read_auxv</name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Elf32_auxv_t</name></type> <name>aux</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr>"/proc/self/auxv"</expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>fd</name> &gt; 0</expr>)</condition><then> <block>{
        <while>while <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>aux</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_auxv_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <if>if <condition>(<expr><name><name>aux</name>.<name>a_type</name></name> == <name>AT_HWCAP</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>uint32_t</name></type> <name>hwcap</name> <init>= <expr><name><name>aux</name>.<name>a_un</name>.<name>a_val</name></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr>"ARM_FORCE_HWCAP"</expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name>hwcap</name> = <call><name>strtoul</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr>"ARM_FORCE_HWCAP"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <comment type="line">// hardcode these values to avoid depending on specific versions</comment>
                <comment type="line">// of the hwcap header, e.g. HWCAP_NEON</comment>
                <expr_stmt><expr><name>arm_has_vfp</name> = (<name>hwcap</name> &amp; 64) != 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>arm_has_iwmmxt</name> = (<name>hwcap</name> &amp; 512) != 0</expr>;</expr_stmt>
                <comment type="line">// this flag is only present on kernel 2.6.29</comment>
                <expr_stmt><expr><name>arm_has_neon</name> = (<name>hwcap</name> &amp; 4096) != 0</expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>aux</name>.<name>a_type</name></name> == <name>AT_PLATFORM</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>plat</name> <init>= <expr>(const <name>char</name>*) <name><name>aux</name>.<name>a_un</name>.<name>a_val</name></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr>"ARM_FORCE_PLATFORM"</expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name>plat</name> = <call><name>getenv</name><argument_list>(<argument><expr>"ARM_FORCE_PLATFORM"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <comment type="line">// The platform string has the form "v[0-9][lb]". The "l" or "b" indicate little-</comment>
                <comment type="line">// or big-endian variants and the digit indicates the version of the platform.</comment>
                <comment type="line">// We can only accept ARMv4 and above, but allow anything up to ARMv9 for future</comment>
                <comment type="line">// processors. Architectures newer than ARMv7 are assumed to be</comment>
                <comment type="line">// backwards-compatible with ARMv7.</comment>
                <if>if <condition>(<expr>(<name><name>plat</name><index>[<expr>0</expr>]</index></name> == 'v') &amp;&amp;
                    (<name><name>plat</name><index>[<expr>1</expr>]</index></name> &gt;= '4') &amp;&amp; (<name><name>plat</name><index>[<expr>1</expr>]</index></name> &lt;= '9') &amp;&amp;
                    ((<name><name>plat</name><index>[<expr>2</expr>]</index></name> == 'l') || (<name><name>plat</name><index>[<expr>2</expr>]</index></name> == 'b'))</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>arm_arch</name> = <name><name>plat</name><index>[<expr>1</expr>]</index></name> - '0'</expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <comment type="line">// For production code, ignore invalid (or unexpected) platform strings and</comment>
                    <comment type="line">// fall back to the default. For debug code, use an assertion to catch this</comment>
                    <comment type="line">// when not running in scratchbox.</comment>
                    <if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr>"_SBOX_DIR"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></else></if>
            }</block></then></if></else></if>
        }</block></while>
        <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// if we don't have 2.6.29, we have to do this hack; set</comment>
        <comment type="line">// the env var to trust HWCAP.</comment>
        <if>if <condition>(<expr>!<call><name>getenv</name><argument_list>(<argument><expr>"ARM_TRUST_HWCAP"</expr></argument>)</argument_list></call> &amp;&amp; (<name>arm_arch</name> &gt;= 7)</expr>)</condition><then>
            <expr_stmt><expr><name>arm_has_neon</name> = true</expr>;</expr_stmt></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>arm_tests_initialized</name> = true</expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>arm_check_arch</name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>arm_tests_initialized</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>arm_read_auxv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>arm_arch</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arm_check_vfp</name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>arm_tests_initialized</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>arm_read_auxv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>arm_has_vfp</name></expr>;</return>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>warning</cpp:directive> Not sure how to check for architecture variant on your platform. Assuming ARMv4.</cpp:error>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>arm_check_arch</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>4</expr>;</return> }</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>arm_check_vfp</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>false</expr>;</return> }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_ENABLE_DISABLE_DEBUGGER_EXCEPTIONS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>enable_debugger_exceptions</name><parameter_list>()</parameter_list> <block>{ }</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>disable_debugger_exceptions</name><parameter_list>()</parameter_list> <block>{ }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NANOJIT_ARM */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>K</name></cpp:macro> <cpp:value>*1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M</name></cpp:macro> <cpp:value>K K</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>G</name></cpp:macro> <cpp:value>K M</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>SetMaxCodeCacheBytes</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>bytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>-&gt;<name>traceMonitor</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tm</name>-&gt;<name>codeAlloc</name></name> &amp;&amp; <name><name>tm</name>-&gt;<name>dataAlloc</name></name> &amp;&amp; <name><name>tm</name>-&gt;<name>traceAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>bytes</name> &gt; 1 <name>G</name></expr>)</condition><then>
        <expr_stmt><expr><name>bytes</name> = 1 <name>G</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>bytes</name> &lt; 128 <name>K</name></expr>)</condition><then>
        <expr_stmt><expr><name>bytes</name> = 128 <name>K</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>maxCodeCacheBytes</name></name> = <name>bytes</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>InitJIT</name><parameter_list>(<param><decl><type><name>TraceMonitor</name> *</type><name>tm</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_JIT_SPEW</name></expr></cpp:if>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>profAlloc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* Set up debug logging. */</comment>
    <if>if <condition>(<expr>!<name>did_we_set_up_debug_logging</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>InitJITLogController</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>did_we_set_up_debug_logging</name> = true</expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* Set up fragprofiling, if required. */</comment>
    <if>if <condition>(<expr><name><name>LogController</name>.<name>lcbits</name></name> &amp; <name>LC_FragProfile</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>tm</name>-&gt;<name>profAlloc</name></name> = new <call><name>VMAllocator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tm</name>-&gt;<name>profTab</name></name> = new (*<name><name>tm</name>-&gt;<name>profAlloc</name></name>) <call><name>FragStatsMap</name><argument_list>(<argument><expr>*<name><name>tm</name>-&gt;<name>profAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>lastFragID</name></name> = 0</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>PodZero</name><argument_list>(<argument><expr>&amp;<name>LogController</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr>!<name>did_we_check_processor_features</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_IA32</name></expr></cpp:if>
        <expr_stmt><expr><name><name>avmplus</name>::<name>AvmCore</name>::<name>config</name>.<name>i386_use_cmov</name></name> =
            <name><name>avmplus</name>::<name>AvmCore</name>::<name>config</name>.<name>i386_sse2</name></name> = <call><name>CheckForSSE2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>avmplus</name>::<name>AvmCore</name>::<name>config</name>.<name>i386_fixed_esp</name></name> = true</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_ARM</name></expr></cpp:if>

        <expr_stmt><expr><call><name>disable_debugger_exceptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>bool</name></type>            <name>arm_vfp</name>     <init>= <expr><call><name>arm_check_vfp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>    <name>arm_arch</name>    <init>= <expr><call><name>arm_check_arch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>enable_debugger_exceptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>avmplus</name>::<name>AvmCore</name>::<name>config</name>.<name>arm_vfp</name></name>        = <name>arm_vfp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>avmplus</name>::<name>AvmCore</name>::<name>config</name>.<name>soft_float</name></name>     = !<name>arm_vfp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>avmplus</name>::<name>AvmCore</name>::<name>config</name>.<name>arm_arch</name></name>       = <name>arm_arch</name></expr>;</expr_stmt>

        <comment type="line">// Sanity-check the configuration detection.</comment>
        <comment type="line">//  * We don't understand architectures prior to ARMv4.</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>arm_arch</name> &gt;= 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>did_we_check_processor_features</name> = true</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Set the default size for the code cache to 16MB. */</comment>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>maxCodeCacheBytes</name></name> = 16 <name>M</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>tm</name>-&gt;<name>recordAttempts</name></name> = new <name>RecordAttemptMap</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>tm</name>-&gt;<name>recordAttempts</name>-&gt;<name>init</name></name><argument_list>(<argument><expr><name>PC_HASH_COUNT</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>tm</name>-&gt;<name>dataAlloc</name></name> &amp;&amp; !<name><name>tm</name>-&gt;<name>traceAlloc</name></name> &amp;&amp; !<name><name>tm</name>-&gt;<name>codeAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>dataAlloc</name></name> = new <call><name>VMAllocator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>traceAlloc</name></name> = new <call><name>VMAllocator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>tempAlloc</name></name> = new <call><name>VMAllocator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>reTempAlloc</name></name> = new <call><name>VMAllocator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>codeAlloc</name></name> = new <call><name>CodeAlloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>frameCache</name></name> = new <call><name>FrameInfoCache</name><argument_list>(<argument><expr><name><name>tm</name>-&gt;<name>dataAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>storage</name></name> = new <call><name>TraceNativeStorage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>cachedTempTypeMap</name></name> = new <call><name>TypeMap</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>tm</name>-&gt;<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <macro><name>verbose_only</name><argument_list>( <argument>tm-&gt;branches = NULL;</argument> )</argument_list></macro>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>defined</name> <name>XP_WIN</name></expr></cpp:if>
    <expr_stmt><expr><call><name>debug_only</name><argument_list>(<argument><expr><call><name>PodZero</name><argument_list>(<argument><expr>&amp;<name>jitstats</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
    <comment type="block">/* Architecture properties used by test cases. */</comment>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIsIA32</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIs64BIT</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIsARM</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIsSPARC</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIsPPC</name></name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_IA32</name></expr></cpp:if>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIsIA32</name></name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_64BIT</name></expr></cpp:if>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIs64BIT</name></name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_ARM</name></expr></cpp:if>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIsARM</name></name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_SPARC</name></expr></cpp:if>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIsSPARC</name></name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_PPC</name></expr></cpp:if>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIsPPC</name></name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_X64</name></expr></cpp:if>
    <expr_stmt><expr><name><name>jitstats</name>.<name>archIsAMD64</name></name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name>FinishJIT</name><parameter_list>(<param><decl><type><name>TraceMonitor</name> *</type><name>tm</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>tm</name>-&gt;<name>recorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>jitstats</name>.<name>recorderStarted</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name>sep</name> <init>= <expr>':'</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMStats</name></expr></argument>, <argument><expr>"recorder"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECORDER_JITSTAT</name><parameter_list>(<param><type><name>_ident</name></type></param>, <param><type><name>_name</name></type></param>)</parameter_list></cpp:macro>                             \
        <cpp:value>debug_only_printf(LC_TMStats, "%c " _name "(%llu)", sep,    \
                          (unsigned long long int)jitstats._ident); \
        sep = ',';</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JITSTAT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* nothing */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jitstats.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JITSTAT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RECORDER_JITSTAT</name></cpp:undef>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMStats</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>sep</name> = ':'</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMStats</name></expr></argument>, <argument><expr>"monitor"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MONITOR_JITSTAT</name><parameter_list>(<param><type><name>_ident</name></type></param>, <param><type><name>_name</name></type></param>)</parameter_list></cpp:macro>                              \
        <cpp:value>debug_only_printf(LC_TMStats, "%c " _name "(%llu)", sep,    \
                          (unsigned long long int)jitstats._ident); \
        sep = ',';</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JITSTAT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* nothing */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jitstats.tbl"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>JITSTAT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MONITOR_JITSTAT</name></cpp:undef>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMStats</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr>delete <name><name>tm</name>-&gt;<name>recordAttempts</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="line">// Recover profiling data from expiring Fragments, and display</comment>
    <comment type="line">// final results.</comment>
    <if>if <condition>(<expr><name><name>LogController</name>.<name>lcbits</name></name> &amp; <name>LC_FragProfile</name></expr>)</condition><then> <block>{
        <for>for (<init><decl><type><name><name>Seq</name><argument_list>&lt;<argument><expr><name>Fragment</name>*</expr></argument>&gt;</argument_list></name>*</type> <name>f</name> <init>= <expr><name><name>tm</name>-&gt;<name>branches</name></name></expr></init></decl>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>tail</name></name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>FragProfiling_FragFinalizer</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>head</name></name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>FRAGMENT_TABLE_SIZE</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <for>for (<init><decl><type><name>TreeFragment</name> *</type><name>f</name> <init>= <expr><name><name>tm</name>-&gt;<name>vmfragments</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>next</name></name></expr></incr>) <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>root</name></name> == <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for (<init><decl><type><name>TreeFragment</name> *</type><name>p</name> <init>= <expr><name>f</name></expr></init></decl>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>peer</name></name></expr></incr>)
                    <expr_stmt><expr><call><name>FragProfiling_FragFinalizer</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            }</block></for>
        }</block></for>
        <decl_stmt><decl><type><name><name>REHashMap</name>::<name>Iter</name></name></type> <name>iter</name><argument_list>(<argument><expr>*(<name><name>tm</name>-&gt;<name>reFragments</name></name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>VMFragment</name>*</type> <name>frag</name> <init>= <expr>(<name>VMFragment</name>*)<call><name><name>iter</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>FragProfiling_FragFinalizer</name><argument_list>(<argument><expr><name>frag</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <expr_stmt><expr><call><name>FragProfiling_showResults</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>delete <name><name>tm</name>-&gt;<name>profAlloc</name></name></expr>;</expr_stmt>

    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr>!<name><name>tm</name>-&gt;<name>profTab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr>!<name><name>tm</name>-&gt;<name>profAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>PodArrayZero</name><argument_list>(<argument><expr><name><name>tm</name>-&gt;<name>vmfragments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>frameCache</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name><name>tm</name>-&gt;<name>frameCache</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tm</name>-&gt;<name>frameCache</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>codeAlloc</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name><name>tm</name>-&gt;<name>codeAlloc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tm</name>-&gt;<name>codeAlloc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>dataAlloc</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name><name>tm</name>-&gt;<name>dataAlloc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tm</name>-&gt;<name>dataAlloc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>traceAlloc</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name><name>tm</name>-&gt;<name>traceAlloc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tm</name>-&gt;<name>traceAlloc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>tempAlloc</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name><name>tm</name>-&gt;<name>tempAlloc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tm</name>-&gt;<name>tempAlloc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>reTempAlloc</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name><name>tm</name>-&gt;<name>reTempAlloc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tm</name>-&gt;<name>reTempAlloc</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>tm</name>-&gt;<name>storage</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr>delete <name><name>tm</name>-&gt;<name>storage</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tm</name>-&gt;<name>storage</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr>delete <name><name>tm</name>-&gt;<name>cachedTempTypeMap</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tm</name>-&gt;<name>cachedTempTypeMap</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>PurgeJITOracle</name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>oracle</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name>PurgeScriptFragments</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSScript</name>*</type> <name>script</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>TRACING_ENABLED</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return;</return></then></if>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                      <argument><expr>"Purging fragments for JSScript %p.\n"</expr></argument>, <argument><expr>(<name>void</name>*)<name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>TraceMonitor</name>*</type> <name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>FRAGMENT_TABLE_SIZE</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>TreeFragment</name>**</type> <name>fragp</name> <init>= <expr>&amp;<name><name>tm</name>-&gt;<name>vmfragments</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<decl><type><name>TreeFragment</name>*</type> <name>frag</name> <init>= <expr>*<name>fragp</name></expr></init></decl>)</condition> <block>{
            <if>if <condition>(<expr><call><name>JS_UPTRDIFF</name><argument_list>(<argument><expr><name><name>frag</name>-&gt;<name>ip</name></name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>code</name></name></expr></argument>)</argument_list></call> &lt; <name><name>script</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
                <comment type="block">/* This fragment is associated with the script. */</comment>
                <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                                  <argument><expr>"Disconnecting TreeFragment %p "
                                  "with ip %p, in range [%p,%p).\n"</expr></argument>,
                                  <argument><expr>(<name>void</name>*)<name>frag</name></expr></argument>, <argument><expr><name><name>frag</name>-&gt;<name>ip</name></name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>code</name></name></expr></argument>,
                                  <argument><expr><name><name>script</name>-&gt;<name>code</name></name> + <name><name>script</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>frag</name>-&gt;<name>root</name></name> == <name>frag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>fragp</name> = <name><name>frag</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
                <do>do <block>{
                    <macro><name>verbose_only</name><argument_list>( <argument>FragProfiling_FragFinalizer(frag, tm);</argument> )</argument_list></macro>
                    <expr_stmt><expr><call><name>TrashTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>frag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> while <condition>(<expr>(<name>frag</name> = <name><name>frag</name>-&gt;<name>peer</name></name>) != <name>NULL</name></expr>)</condition>;</do>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>fragp</name> = &amp;<name><name>frag</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></while>
    }</block></for>

    <decl_stmt><decl><type><name>RecordAttemptMap</name> &amp;</type><name>table</name> <init>= <expr>*<name><name>tm</name>-&gt;<name>recordAttempts</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init><expr><name><name>RecordAttemptMap</name>::<name>Enum</name></name> <call><name>e</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr>!<call><name><name>e</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><call><name><name>e</name>.<name>popFront</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>JS_UPTRDIFF</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>front</name></name><argument_list>()</argument_list></call>.<name>key</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>code</name></name></expr></argument>)</argument_list></call> &lt; <name><name>script</name>-&gt;<name>length</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>e</name>.<name>removeFront</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
}</block></function>

<function><type><name>bool</name></type>
<name>OverfullJITCache</name><parameter_list>(<param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * You might imagine the outOfMemory flag on the allocator is sufficient
     * to model the notion of "running out of memory", but there are actually
     * two separate issues involved:
     *
     *  1. The process truly running out of memory: malloc() or mmap()
     *     failed.
     *
     *  2. The limit we put on the "intended size" of the tracemonkey code
     *     cache, in pages, has been exceeded.
     *
     * Condition 1 doesn't happen very often, but we're obliged to try to
     * safely shut down and signal the rest of spidermonkey when it
     * does. Condition 2 happens quite regularly.
     *
     * Presently, the code in this file doesn't check the outOfMemory condition
     * often enough, and frequently misuses the unchecked results of
     * lirbuffer insertions on the asssumption that it will notice the
     * outOfMemory flag "soon enough" when it returns to the monitorRecording
     * function. This turns out to be a false assumption if we use outOfMemory
     * to signal condition 2: we regularly provoke "passing our intended
     * size" and regularly fail to notice it in time to prevent writing
     * over the end of an artificially self-limited LIR buffer.
     *
     * To mitigate, though not completely solve, this problem, we're
     * modeling the two forms of memory exhaustion *separately* for the
     * time being: condition 1 is handled by the outOfMemory flag inside
     * nanojit, and condition 2 is being handled independently *here*. So
     * we construct our allocators to use all available memory they like,
     * and only report outOfMemory to us when there is literally no OS memory
     * left. Merely purging our cache when we hit our highwater mark is
     * handled by the (few) callers of this function.
     *
     */</comment>
    <decl_stmt><decl><type><name>jsuint</name></type> <name>maxsz</name> <init>= <expr><name><name>tm</name>-&gt;<name>maxCodeCacheBytes</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMAllocator</name> *</type><name>dataAlloc</name> <init>= <expr><name><name>tm</name>-&gt;<name>dataAlloc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VMAllocator</name> *</type><name>traceAlloc</name> <init>= <expr><name><name>tm</name>-&gt;<name>traceAlloc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CodeAlloc</name> *</type><name>codeAlloc</name> <init>= <expr><name><name>tm</name>-&gt;<name>codeAlloc</name></name></expr></init></decl>;</decl_stmt>

    <return>return <expr>(<call><name><name>codeAlloc</name>-&gt;<name>size</name></name><argument_list>()</argument_list></call> + <call><name><name>dataAlloc</name>-&gt;<name>size</name></name><argument_list>()</argument_list></call> + <call><name><name>traceAlloc</name>-&gt;<name>size</name></name><argument_list>()</argument_list></call> &gt; <name>maxsz</name>)</expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>JS_FORCES_STACK</name></type> <name>JS_FRIEND_API</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
<name>DeepBail</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>;

    <comment type="block">/*
     * Exactly one context on the current thread is on trace. Find out which
     * one. (Most callers cannot guarantee that it's cx.)
     */</comment>
    <argument><expr><name>TraceMonitor</name> *<name>tm</name> = &amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><name>JSContext</name> *<name>tracecx</name> = <name><name>tm</name>-&gt;<name>tracecx</name></name></expr></argument>;

    <comment type="block">/* It's a bug if a non-FAIL_STATUS builtin gets here. */</comment>
    <argument><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tracecx</name>-&gt;<name>bailExit</name></name></expr></argument>)</argument_list></call></expr></argument>;

    <argument><expr><name><name>tm</name>-&gt;<name>tracecx</name></name> = <name>NULL</name></expr></argument>;
    <argument><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"Deep bail.\n"</expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><call><name>LeaveTree</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr>*<name><name>tracecx</name>-&gt;<name>interpState</name></name></expr></argument>, <argument><expr><name><name>tracecx</name>-&gt;<name>bailExit</name></name></expr></argument>)</argument_list></call></expr></argument>;
    <argument><expr><name><name>tracecx</name>-&gt;<name>bailExit</name></name> = <name>NULL</name></expr></argument>;

    <argument><expr><name>InterpState</name>* <name>state</name> = <name><name>tracecx</name>-&gt;<name>interpState</name></name></expr></argument>;
    <argument><expr><name><name>state</name>-&gt;<name>builtinStatus</name></name> |= <name>BUILTIN_BAILED</name></expr></argument>;

    <comment type="block">/*
     * Between now and the LeaveTree in ExecuteTree, |tm-&gt;storage| may be reused
     * if another trace executes before the currently executing native returns.
     * However, all such traces will complete by the time the currently
     * executing native returns and the return value is written to the native
     * stack. After that point, no traces may execute until the LeaveTree in
     * ExecuteTree, hence the invariant is maintained that only one trace uses
     * |tm-&gt;storage| at a time.
     */</comment>
    <argument><expr><name><name>state</name>-&gt;<name>deepBailSp</name></name> = <name><name>state</name>-&gt;<name>sp</name></name></expr></argument>;
}</argument_list>

extern <name>bool</name>
<name>InCustomIterNextTryRegion</name><argument_list>(<argument><expr><name>jsbytecode</name> *<name>pc</name></expr></argument>)</argument_list>
<argument_list>{
    return <argument><expr><name><name>nextiter_imacros</name>.<name>custom_iter_next</name></name> &lt;= <name>pc</name> &amp;&amp;
           <name>pc</name> &lt; <name><name>nextiter_imacros</name>.<name>custom_iter_next</name></name> + <sizeof>sizeof<argument_list>(<argument><expr><name><name>nextiter_imacros</name>.<name>custom_iter_next</name></name></expr></argument>)</argument_list></sizeof></expr></argument>;
}</argument_list>

<name>JS_REQUIRES_STACK</name> <name>jsval</name>&amp;
<name><name>TraceRecorder</name>::<name>argval</name></name><argument_list>(<argument><expr><name>unsigned</name> <name>n</name></expr></argument>)</argument_list> const
<argument_list>{
    <argument><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>n</name> &lt; <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name></expr></argument>)</argument_list></call></expr></argument>;
    return <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>;
}</argument_list>

<name>JS_REQUIRES_STACK</name> <name>jsval</name>&amp;
<name><name>TraceRecorder</name>::<name>varval</name></name><argument_list>(<argument><expr><name>unsigned</name> <name>n</name></expr></argument>)</argument_list> const
<argument_list>{
    <argument><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>n</name> &lt; <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>nslots</name></name></expr></argument>)</argument_list></call></expr></argument>;
    return <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>;
}</argument_list>

<name>JS_REQUIRES_STACK</name> <name>jsval</name>&amp;
<name><name>TraceRecorder</name>::<name>stackval</name></name><argument_list>(<argument><expr><name>int</name> <name>n</name></expr></argument>)</argument_list> const
<argument_list>{
    <argument><expr><name>jsval</name>* <name>sp</name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name></expr></argument>;
    return <argument><expr><name><name>sp</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>;
}</argument_list>

<comment type="block">/*
 * Generate LIR to compute the scope chain.
 */</comment>
<name>JS_REQUIRES_STACK</name> <name>LIns</name>*
<name><name>TraceRecorder</name>::<name>scopeChain</name></name><argument_list>()</argument_list>
<argument_list>{
    return <argument><expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>callee</name></name><argument_list>()</argument_list></call>
           ? <call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChainVal</name></name></expr></argument>)</argument_list></call>
           : <call><name>entryScopeChain</name><argument_list>()</argument_list></call></expr></argument>;
}</argument_list>

<comment type="block">/*
 * Generate LIR to compute the scope chain on entry to the trace. This is
 * generally useful only for getting to the global object, because only
 * the global object is guaranteed to be present.
 */</comment>
<name>JS_REQUIRES_STACK</name> <name>LIns</name>*
<name><name>TraceRecorder</name>::<name>entryScopeChain</name></name><argument_list>()</argument_list> const
<argument_list>{
    return <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>,
                        <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>cx_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSContext</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSStackFrame</name></expr></argument>, <argument><expr><name>scopeChain</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>;
}</argument_list>

<comment type="block">/*
 * Return the frame of a call object if that frame is part of the current
 * trace. |depthp| is an optional outparam: if it is non-null, it will be
 * filled in with the depth of the call object's frame relevant to cx-&gt;fp.
 */</comment>
<name>JS_REQUIRES_STACK</name> <name>JSStackFrame</name>*
<name><name>TraceRecorder</name>::<name>frameIfInRange</name></name><argument_list>(<argument><expr><name>JSObject</name>* <name>obj</name></expr></argument>, <argument><expr><name>unsigned</name>* <name>depthp</name></expr></argument>)</argument_list> const
<argument_list>{
    <argument><expr><name>JSStackFrame</name>* <name>ofp</name> = (<name>JSStackFrame</name>*) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr></argument>;
    <argument><expr><name>JSStackFrame</name>* <name>fp</name> = <name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>;
    for <argument><expr>(<name>unsigned</name> <name>depth</name> = 0; <name>depth</name> &lt;= <name>callDepth</name>; ++<name>depth</name>) <block>{
        <if>if <condition>(<expr><name>fp</name> == <name>ofp</name></expr>)</condition><then> <expr_stmt><expr><block>{
            <if>if <condition>(<expr><name>depthp</name></expr>)</condition><then>
                <expr_stmt><expr>*<name>depthp</name> = <name>depth</name></expr>;</expr_stmt></then></if></block></expr></expr_stmt></then></if>
            <return>return <expr><name>ofp</name></expr>;</return>
        }</block></expr></argument>
        <if>if <condition>(<expr>!(<name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name>)</expr>)</condition><then>
            <break>break;</break></then></if></argument_list></decl></decl_stmt>
    }</block></namespace>
    <return>return <expr><name>NULL</name></expr>;</return>
}

JS_DEFINE_CALLINFO_4<expr_stmt><expr>(extern, <name>UINT32</name>, <name>GetClosureVar</name>, <name>CONTEXT</name>, <name>OBJECT</name>, <name>CVIPTR</name>, <name>DOUBLEPTR</name>, 0,
                     <name>ACC_STORE_ANY</name>)
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>extern</argument>, <argument>UINT32</argument>, <argument>GetClosureArg</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>CVIPTR</argument>, <argument>DOUBLEPTR</argument>, <argument>0</argument>,
                     <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<comment type="block">/*
 * Search the scope chain for a property lookup operation at the current PC and
 * generate LIR to access the given property. Return RECORD_CONTINUE on success,
 * otherwise abort and return RECORD_STOP. There are 3 outparams:
 *
 *     vp           the address of the current property value
 *     ins          LIR instruction representing the property value on trace
 *     NameResult   describes how to look up name; see comment for NameResult in jstracer.h
 */</comment>
<name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name>
<macro><name>TraceRecorder</name></macro><name>::<name>scopeChainProp</name></name>(<name>JSObject</name>* <name>chainHead</name>, <name>jsval</name>*&amp; <name>vp</name>, <name>LIns</name>*&amp; <name>ins</name>, <name>NameResult</name>&amp; <name>nr</name>)
<block>{
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>chainHead</name> == <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name></name></expr></argument>)</argument_list></call></expr>;
    <expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>chainHead</name> != <name>globalObj</name></expr></argument>)</argument_list></call></expr>;

    <expr><name>TraceMonitor</name> &amp;<name>localtm</name> = *<name>traceMonitor</name></expr>;

    <expr><name>JSAtom</name>* <name>atom</name> = <name><name>atoms</name><index>[<expr><call><name>GET_INDEX</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;
    <expr><name>JSObject</name>* <name>obj2</name></expr>;
    <expr><name>JSProperty</name>* <name>prop</name></expr>;
    <expr><name>JSObject</name> *<name>obj</name> = <name>chainHead</name></expr>;
    <expr><name>JSBool</name> <name>ok</name> = <call><name>js_FindProperty</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>obj2</name></expr></argument>, <argument><expr>&amp;<name>prop</name></expr></argument>)</argument_list></call></expr>;

    <comment type="block">/* js_FindProperty can reenter the interpreter and kill |this|. */</comment>
    <if>if <condition>(<expr>!<name><name>localtm</name>.<name>recorder</name></name></expr>)</condition><then>
        <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return></then></if></block></expr></expr_stmt>

    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_ERROR_A</name><argument_list>(<argument><expr>"error in js_FindProperty"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>!<name>prop</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"failed to find name in non-global scope chain"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>obj</name> == <name>globalObj</name></expr>)</condition><then> <block>{
        <comment type="line">// Even if the property is on the global object, we must guard against</comment>
        <comment type="line">// the creation of properties that shadow the property in the middle</comment>
        <comment type="line">// of the scope chain.</comment>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>head_ins</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name></name></expr>)</condition><then> <block>{
            <comment type="line">// Skip any Call object when inside a function. Any reference to a</comment>
            <comment type="line">// Call name the compiler resolves statically and we do not need</comment>
            <comment type="line">// to match shapes of the Call objects.</comment>
            <expr_stmt><expr><name>chainHead</name> = <call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>calleeObject</name></name><argument_list>()</argument_list></call>-&gt;<call><name>getParent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>head_ins</name> = <call><name>stobj_get_parent</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>head_ins</name> = <call><name>scopeChain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>obj_ins</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>traverseScopeChain</name><argument_list>(<argument><expr><name>chainHead</name></expr></argument>, <argument><expr><name>head_ins</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name> <init>= <expr>(<name>JSScopeProperty</name>*) <name>prop</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>obj2</name> != <name>obj</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>obj2</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"prototype property"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>!<call><name>isValidSlot</name><argument_list>(<argument><expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>obj2</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!<call><name>lazilyImportGlobalSlot</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>slot</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>obj2</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"lazy import of global slot failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>vp</name> = &amp;<call><name><name>obj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ins</name> = <call><name>get</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>obj2</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nr</name>.<name>tracked</name></name> = true</expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>obj</name> == <name>obj2</name> &amp;&amp; <call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> == &amp;<name>js_CallClass</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>AbortableRecordingStatus</name></type> <name>status</name> <init>=
            <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>callProp</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>obj</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>status</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>obj2</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"fp-&gt;scopeChain is not global or active call object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

<comment type="block">/*
 * Generate LIR to access a property of a Call object.
 */</comment>
JS_REQUIRES_STACK <function><type><name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>callProp</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>JSProperty</name>*</type> <name>prop</name></decl></param>, <param><decl><type><name>jsid</name></type> <name>id</name></decl></param>, <param><decl><type><name>jsval</name>*&amp;</type> <name>vp</name></decl></param>,
                        <param><decl><type><name>LIns</name>*&amp;</type> <name>ins</name></decl></param>, <param><decl><type><name>NameResult</name>&amp;</type> <name>nr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSScopeProperty</name> *</type><name>sprop</name> <init>= <expr>(<name>JSScopeProperty</name>*) <name>prop</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name> <init>= <expr><call><name>JSOp</name><argument_list>(<argument><expr>*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>setflags</name> <init>= <expr>(<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name>.<name>format</name> &amp; (<name>JOF_SET</name> | <name>JOF_INCDEC</name> | <name>JOF_FOR</name>))</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>setflags</name> &amp;&amp; !<call><name><name>sprop</name>-&gt;<name>writable</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"writing to a read-only property"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>uintN</name></type> <name>slot</name> <init>= <expr><call><name>uint16</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>shortid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>vp</name> = <name>NULL</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>upvar_slot</name> <init>= <expr><name>SPROP_INVALID_SLOT</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>cfp</name> <init>= <expr>(<name>JSStackFrame</name>*) <call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>cfp</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call> == <name>js_GetCallArg</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>slot</name> &lt; <name><name>cfp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>vp</name> = &amp;<name><name>cfp</name>-&gt;<name>argv</name><index>[<expr><name>slot</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>upvar_slot</name> = <name>slot</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nr</name>.<name>v</name></name> = *<name>vp</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call> == <name>js_GetCallVar</name> ||
                   <call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call> == <name>js_GetCallVarChecked</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>slot</name> &lt; <name><name>cfp</name>-&gt;<name>script</name>-&gt;<name>nslots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>vp</name> = &amp;<name><name>cfp</name>-&gt;<name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>upvar_slot</name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name> + <name>slot</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nr</name>.<name>v</name></name> = *<name>vp</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"dynamic property of Call object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>

        <comment type="line">// Now assert that our use of sprop-&gt;shortid was in fact kosher.</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>sprop</name>-&gt;<name>hasShortID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>frameIfInRange</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// At this point we are guaranteed to be looking at an active call oject</comment>
            <comment type="line">// whose properties are stored in the corresponding JSStackFrame.</comment>
            <expr_stmt><expr><name>ins</name> = <call><name>get</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nr</name>.<name>tracked</name></name> = true</expr>;</expr_stmt>
            <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <comment type="line">// Call objects do not yet have sprop-&gt;isMethod() properties, but they</comment>
        <comment type="line">// should. See bug 514046, for which this code is future-proof. Remove</comment>
        <comment type="line">// this comment when that bug is fixed (so, FIXME: 514046).</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>JSBool</name></type> <name>rv</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr><call><name>js_GetPropertyHelper</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>,
                                 <argument><expr>(<name>op</name> == <name>JSOP_CALLNAME</name>)
                                 ? <name>JSGET_NO_METHOD_BARRIER</name>
                                 : <name>JSGET_METHOD_BARRIER</name></expr></argument>,
                                 <argument><expr>&amp;<name><name>nr</name>.<name>v</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>parent</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>calleeObject</name></name><argument_list>()</argument_list></call>-&gt;<call><name>getParent</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>parent_ins</name> <init>= <expr><call><name>stobj_get_parent</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>traverseScopeChain</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>parent_ins</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>cfp</name></expr>)</condition><then> <block>{
        <comment type="line">// Because the parent guard in guardCallee ensures this Call object</comment>
        <comment type="line">// will be the same object now and on trace, and because once a Call</comment>
        <comment type="line">// object loses its frame it never regains one, on trace we will also</comment>
        <comment type="line">// have a null private in the Call object. So all we need to do is</comment>
        <comment type="line">// write the value to the Call object's slot.</comment>
        <decl_stmt><decl><type><name>int32</name></type> <name>dslot_index</name> <init>= <expr><name>slot</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call> == <name>js_GetCallArg</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>dslot_index</name> &lt; <call><name><name>ArgClosureTraits</name>::<name>slot_count</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dslot_index</name> += <call><name><name>ArgClosureTraits</name>::<name>slot_offset</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call> == <name>js_GetCallVar</name> ||
                   <call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call> == <name>js_GetCallVarChecked</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>dslot_index</name> &lt; <call><name><name>VarClosureTraits</name>::<name>slot_count</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dslot_index</name> += <call><name><name>VarClosureTraits</name>::<name>slot_offset</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"dynamic property of Call object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>

        <comment type="line">// Now assert that our use of sprop-&gt;shortid was in fact kosher.</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>sprop</name>-&gt;<name>hasShortID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>base</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>dslots</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>val_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>dslot_index</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ins</name> = <call><name>unbox_jsval</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>dslots</name><index>[<expr><name>dslot_index</name></expr>]</index></name></expr></argument>, <argument><expr><name>val_ins</name></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>ClosureVarInfo</name>*</type> <name>cv</name> <init>= <expr>new (<call><name>traceAlloc</name><argument_list>()</argument_list></call>) <call><name>ClosureVarInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>cv</name>-&gt;<name>slot</name></name> = <name>slot</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><name><name>cv</name>-&gt;<name>callDepth</name></name> = <name>callDepth</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>outp</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{
            <expr><name>outp</name></expr>,
            <expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>cv</name></expr></argument>)</argument_list></call></expr>,
            <expr><name>obj_ins</name></expr>,
            <expr><name>cx_ins</name></expr>
        }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>CallInfo</name>*</type> <name>ci</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call> == <name>js_GetCallArg</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ci</name> = &amp;<name>GetClosureArg_ci</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call> == <name>js_GetCallVar</name> ||
                   <call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call> == <name>js_GetCallVarChecked</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ci</name> = &amp;<name>GetClosureVar_ci</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"dynamic property of Call object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>

        <comment type="line">// Now assert that our use of sprop-&gt;shortid was in fact kosher.</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>sprop</name>-&gt;<name>hasShortID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>call_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>TraceType</name></type> <name>type</name> <init>= <expr><call><name>getCoercedType</name><argument_list>(<argument><expr><name><name>nr</name>.<name>v</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
              <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>call_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr>"guard(type-stable name access)"</expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ins</name> = <call><name>stackLoad</name><argument_list>(<argument><expr><name>outp</name></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name><name>nr</name>.<name>tracked</name></name> = false</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nr</name>.<name>obj</name></name> = <name>obj</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nr</name>.<name>obj_ins</name></name> = <name>obj_ins</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nr</name>.<name>sprop</name></name> = <name>sprop</name></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>arg</name></name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<call><name>argval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>arg</name></name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<call><name>argval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>var</name></name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<call><name>varval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>var</name></name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>n</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<call><name>varval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>stack</name></name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<call><name>stackval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>stack</name></name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<call><name>stackval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>alu</name></name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>jsdouble</name></type> <name>v0</name></decl></param>, <param><decl><type><name>jsdouble</name></type> <name>v1</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>s0</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>s1</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * To even consider this operation for demotion, both operands have to be
     * integers and the oracle must not give us a negative hint for the
     * instruction.
     */</comment>
    <if>if <condition>(<expr><call><name><name>oracle</name>.<name>isInstructionUndemotable</name></name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call> || !<call><name>isPromoteInt</name><argument_list>(<argument><expr><name>s0</name></expr></argument>)</argument_list></call> || !<call><name>isPromoteInt</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <label><name>out</name>:</label>
        <if>if <condition>(<expr><name>v</name> == <name>LIR_fmod</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>s1</name></expr>, <expr><name>s0</name></expr> }</block></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_dmod_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>result</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>s0</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name><name>s0</name>-&gt;<name>isconstf</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>s1</name>-&gt;<name>isconstf</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>result</name>-&gt;<name>isconstf</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>jsdouble</name></type> <name>r</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>v</name></expr>)</condition> <block>{
    <case>case <expr><name>LIR_fadd</name></expr>:
        <expr_stmt><expr><name>r</name> = <name>v0</name> + <name>v1</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>LIR_fsub</name></expr>:
        <expr_stmt><expr><name>r</name> = <name>v0</name> - <name>v1</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>LIR_fmul</name></expr>:
        <expr_stmt><expr><name>r</name> = <name>v0</name> * <name>v1</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>r</name> == 0.0</expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
        <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_IA32</name> || <name>defined</name> <name>NANOJIT_X64</name></expr></cpp:if>
    </case><case>case <expr><name>LIR_fdiv</name></expr>:
        <if>if <condition>(<expr><name>v1</name> == 0</expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
        <expr_stmt><expr><name>r</name> = <name>v0</name> / <name>v1</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>LIR_fmod</name></expr>:
        <if>if <condition>(<expr><name>v0</name> &lt; 0 || <name>v1</name> == 0 || (<call><name><name>s1</name>-&gt;<name>isconstf</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>v1</name> &lt; 0)</expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
        <expr_stmt><expr><name>r</name> = <call><name>js_dmod</name><argument_list>(<argument><expr><name>v0</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><default>default:
        <goto>goto <name>out</name>;</goto>
    </default>}</block></switch>

    <comment type="block">/*
     * The result must be an integer at record time, otherwise there is no
     * point in trying to demote it.
     */</comment>
    <if>if <condition>(<expr><call><name>jsint</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> != <name>r</name> || <call><name>JSDOUBLE_IS_NEGZERO</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>d0</name> <init>= <expr><call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>d1</name> <init>= <expr><call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Speculatively emit an integer operation, betting that at runtime we
     * will get integer results again.
     */</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>result</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>v</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_IA32</name> || <name>defined</name> <name>NANOJIT_X64</name></expr></cpp:if>
      <case>case <expr><name>LIR_fdiv</name></expr>:
        <if>if <condition>(<expr><call><name><name>d0</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>d1</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><call><name>jsint</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

        <expr_stmt><expr><name>exit</name> = <call><name>snapshot</name><argument_list>(<argument><expr><name>OVERFLOW_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the divisor is greater than zero its always safe to execute
         * the division. If not, we have to make sure we are not running
         * into -2147483648 / -1, because it can raise an overflow exception.
         */</comment>
        <if>if <condition>(<expr>!<call><name><name>d1</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>gt</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_gt</name></expr></argument>, <argument><expr><name>d1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_and</name></expr></argument>,
                                   <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>d0</name></expr></argument>, <argument><expr>0x80000000</expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>d1</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>gt</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><call><name><name>d1</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call> == -1</expr>)</condition><then>
                <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>d0</name></expr></argument>, <argument><expr>0x80000000</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></else></if>
        <expr_stmt><expr><name>result</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>v</name> = <name>LIR_div</name></expr></argument>, <argument><expr><name>d0</name></expr></argument>, <argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* As long as the modulus is zero, the result is an integer. */</comment>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_mod</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Don't lose a -0. */</comment>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>LIR_fmod</name></expr>: <block>{
        <if>if <condition>(<expr><call><name><name>d0</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>d1</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><call><name>jsint</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

        <expr_stmt><expr><name>exit</name> = <call><name>snapshot</name><argument_list>(<argument><expr><name>OVERFLOW_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make sure we don't trigger division by zero at runtime. */</comment>
        <if>if <condition>(<expr>!<call><name><name>d1</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>result</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>v</name> = <name>LIR_mod</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_div</name></expr></argument>, <argument><expr><name>d0</name></expr></argument>, <argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If the result is not 0, it is always within the integer domain. */</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>branch</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If the result is zero, we must exit if the lhs is negative since
         * the result is -0 in this case, which is not in the integer domain.
         */</comment>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_lt</name></expr></argument>, <argument><expr><name>d0</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>branch</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      </case><default>default:
        <expr_stmt><expr><name>v</name> = <call><name>f64arith_to_i32arith</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>v</name> == <name>LIR_add</name> || <name>v</name> == <name>LIR_mul</name> || <name>v</name> == <name>LIR_sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the operands guarantee that the result will be an integer (e.g.
         * z = x * y with 0 &lt;= (x|y) &lt;= 0xffff guarantees z &lt;= fffe0001), we
         * don't have to guard against an overflow. Otherwise we emit a guard
         * that will inform the oracle and cause a non-demoted trace to be
         * attached that uses floating-point math for this operation.
         */</comment>
        <if>if <condition>(<expr>!<call><name>IsOverflowSafe</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d0</name></expr></argument>)</argument_list></call> || !<call><name>IsOverflowSafe</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>exit</name> = <call><name>snapshot</name><argument_list>(<argument><expr><name>OVERFLOW_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> = <call><name>guard_xov</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d0</name></expr></argument>, <argument><expr><name>d1</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>v</name> == <name>LIR_mul</name></expr>)</condition><then> <comment type="line">// make sure we don't lose a -0</comment>
                <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>result</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d0</name></expr></argument>, <argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
    </default>}</block></switch>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name><name>d0</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>d1</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr><call><name><name>result</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>result</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call> == <call><name>jsint</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>i2f</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>f2i</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>f</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>f</name>-&gt;<name>isconstf</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><call><name>js_DoubleToECMAInt32</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>imm64f</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>isfop</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>LIR_i2f</name></expr></argument>)</argument_list></call> || <call><name>isfop</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>LIR_u2f</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>foprnd1</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>isfop</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>LIR_fadd</name></expr></argument>)</argument_list></call> || <call><name>isfop</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>LIR_fsub</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>lhs</name> <init>= <expr><call><name>foprnd1</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>rhs</name> <init>= <expr><call><name>foprnd2</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>isPromote</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>isPromote</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LOpcode</name></type> <name>op</name> <init>= <expr><call><name>f64arith_to_i32arith</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><call><name><name>f</name>-&gt;<name>isCall</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>CallInfo</name>*</type> <name>ci</name> <init>= <expr><call><name><name>f</name>-&gt;<name>callInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>ci</name> == &amp;<name>js_UnboxDouble_ci</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <macro><name>fcallarg</name><argument_list>(<argument>f</argument>, <argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_UnboxInt32_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>ci</name> == &amp;<name>js_StringToNumber_ci</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>fcallarg</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>, <macro><name>fcallarg</name><argument_list>(<argument>f</argument>, <argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_StringToInt32_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>ci</name> == &amp;<name>js_String_p_charCodeAt0_ci</name></expr>)</condition><then> <block>{
            <comment type="line">// Use a fast path builtin for a charCodeAt that converts to an int right away.</comment>
            <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <macro><name>fcallarg</name><argument_list>(<argument>f</argument>, <argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_String_p_charCodeAt0_int_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>ci</name> == &amp;<name>js_String_p_charCodeAt_ci</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>idx</name> <init>= <expr><call><name>fcallarg</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>isPromote</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>, <macro><name>fcallarg</name><argument_list>(<argument>f</argument>, <argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
                <return>return <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_String_p_charCodeAt_int_int_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>idx</name></expr>, <macro><name>fcallarg</name><argument_list>(<argument>f</argument>, <argument>0</argument>)</argument_list></macro> }</block></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_String_p_charCodeAt_double_int_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_DoubleToInt32_ci</name></expr></argument>, <argument><expr>&amp;<name>f</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>f2u</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>f</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>f</name>-&gt;<name>isconstf</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><call><name>js_DoubleToECMAUint32</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>imm64f</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>isfop</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>LIR_i2f</name></expr></argument>)</argument_list></call> || <call><name>isfop</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>LIR_u2f</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>foprnd1</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_DoubleToUint32_ci</name></expr></argument>, <argument><expr>&amp;<name>f</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>makeNumberInt32</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>f</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>f</name>-&gt;<name>isF64</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>isPromote</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>x</name> = <call><name>f2i</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_feq</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>x</name> = <call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>x</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>stringify</name></name><parameter_list>(<param><decl><type><name>jsval</name>&amp;</type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>v_ins</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>v_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CallInfo</name>*</type> <name>ci</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_NUMBER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ci</name> = &amp;<name>js_NumberToString_ci</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* N.B. void is JSVAL_SPECIAL. */</comment>
        <return>return <expr><call><name>INS_ATOM</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>booleanAtoms</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_BOOLEAN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ci</name> = &amp;<name>js_BooleanIntToString_ci</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * Callers must deal with non-primitive (non-null object) values by
         * calling an imacro. We don't try to guess about which imacro, with
         * what valueOf hint, here.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>INS_ATOM</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>nullAtom</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if></else></if>

    <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v_ins</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>call_imacro</name></name><parameter_list>(<param><decl><type><name>jsbytecode</name>*</type> <name>imacro</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFrameRegs</name>*</type> <name>regs</name> <init>= <expr><name><name>fp</name>-&gt;<name>regs</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We cannot nest imacros. */</comment>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>imacpc</name></name></expr>)</condition><then>
        <return>return <expr><name>RECORD_STOP</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>fp</name>-&gt;<name>imacpc</name></name> = <name><name>regs</name>-&gt;<name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>regs</name>-&gt;<name>pc</name></name> = <name>imacro</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>atoms</name> = <call><name>COMMON_ATOMS_START</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_IMACRO</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>ifop</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>cond</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>cond</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>cond</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Test for boolean is true, negate later if we are testing for false. */</comment>
        <expr_stmt><expr><name>cond</name> = <call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == <name>JS_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name> <init>= <expr><call><name>asNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>cond</name> = !<call><name>JSDOUBLE_IS_NaN</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> &amp;&amp; <name>d</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_and</name></expr></argument>,
                      <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_feq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_feq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>cond</name> = <call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<call><name>length</name><argument_list>()</argument_list></call> != 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSString</name></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"ifop"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
    }</block></else></if></else></if></else></if></else></if></else></if>

    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>emitIf</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>checkTraceEnd</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NANOJIT_IA32</name></cpp:ifdef>
<comment type="block">/*
 * Record LIR for a tableswitch or tableswitchx op. We record LIR only the
 * "first" time we hit the op. Later, when we start traces after exiting that
 * trace, we just patch.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>tableswitch</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* No need to guard if the condition can't match any of the cases. */</comment>
    <if>if <condition>(<expr>!<call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>

    <comment type="block">/* No need to guard if the condition is constant. */</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name>f2i</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>v_ins</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Starting a new trace after exiting a trace via switch. */</comment>
    <if>if <condition>(<expr><name>anchor</name> &amp;&amp;
        (<name><name>anchor</name>-&gt;<name>exitType</name></name> == <name>CASE_EXIT</name> || <name><name>anchor</name>-&gt;<name>exitType</name></name> == <name>DEFAULT_EXIT</name>) &amp;&amp;
        <name><name>fragment</name>-&gt;<name>ip</name></name> == <name>pc</name></expr>)</condition><then> <block>{
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Decode jsop. */</comment>
    <decl_stmt><decl><type><name>jsint</name></type> <name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_TABLESWITCH</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pc</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>low</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>high</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>pc</name> += <name>JUMPX_OFFSET_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>low</name> = <call><name>GET_JUMPX_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> += <name>JUMPX_OFFSET_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>high</name> = <call><name>GET_JUMPX_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Cap maximum table-switch size for modesty. */</comment>
    <if>if <condition>(<expr>(<name>high</name> + 1 - <name>low</name>) &gt; <name>MAX_TABLE_SWITCH</name></expr>)</condition><then>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>switchop</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Generate switch LIR. */</comment>
    <decl_stmt><decl><type><name>SwitchInfo</name>*</type> <name>si</name> <init>= <expr>new (<call><name>traceAlloc</name><argument_list>()</argument_list></call>) <call><name>SwitchInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>si</name>-&gt;<name>count</name></name> = <name>high</name> + 1 - <name>low</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name>-&gt;<name>table</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name>-&gt;<name>index</name></name> = (<name>uint32</name>) -1</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>diff</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_sub</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>low</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>cmp</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ult</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name><name>si</name>-&gt;<name>count</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_xf</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>DEFAULT_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmPtr</name></name><argument_list>(<argument><expr>&amp;<name><name>si</name>-&gt;<name>index</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>CASE_EXIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>exit</name>-&gt;<name>switchInfo</name></name> = <name>si</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>guardIns</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_xtbl</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>fragment</name>-&gt;<name>lastIns</name></name> = <name>guardIns</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>compile</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>finishSuccessfully</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>int32_t</name></type>
<name>UnboxBooleanOrUndefined</name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Although this says 'special', we really only expect 3 special values: */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>v</name> == <name>JSVAL_TRUE</name> || <name>v</name> == <name>JSVAL_FALSE</name> || <name>v</name> == <name>JSVAL_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>switchop</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* No need to guard if the condition is constant. */</comment>
    <if>if <condition>(<expr><call><name><name>v_ins</name>-&gt;<name>isImmAny</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name> <init>= <expr><call><name>asNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
              <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_feq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr>"guard(switch on numeric)"</expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>INS_CONSTSTR</name><argument_list>(<argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><name>v_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
              <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_EqualStrings_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr>"guard(switch on string)"</expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
              <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><call><name>UnboxBooleanOrUndefined</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr>"guard(switch on boolean)"</expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"switch on object or null"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>inc</name></name><parameter_list>(<param><decl><type><name>jsval</name>&amp;</type> <name>v</name></decl></param>, <param><decl><type><name>jsint</name></type> <name>incr</name></decl></param>, <param><decl><type><name>bool</name></type> <name>pre</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * On exit, v_ins is the incremented unboxed value, and the appropriate value
 * (pre- or post-increment as described by pre) is stacked.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>inc</name></name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>v_ins</name></decl></param>, <param><decl><type><name>jsint</name></type> <name>incr</name></decl></param>, <param><decl><type><name>bool</name></type> <name>pre</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_after</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>incHelper</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>v_after</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name>&amp;</type> <name>cs</name> <init>= <expr><name><name>js_CodeSpec</name><index>[<expr>*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cs</name>.<name>ndefs</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>-<name><name>cs</name>.<name>nuses</name></name></expr></argument>, <argument><expr><name>pre</name> ? <name>v_after</name> : <name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v_ins</name> = <name>v_after</name></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Do an increment operation without storing anything to the stack.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>incHelper</name></name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>v_after</name></decl></param>, <param><decl><type><name>jsint</name></type> <name>incr</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can only inc numbers"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>v_after</name> = <call><name>alu</name><argument_list>(<argument><expr><name>LIR_fadd</name></expr></argument>, <argument><expr><call><name>asNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>incr</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>incProp</name></name><parameter_list>(<param><decl><type><name>jsint</name></type> <name>incr</name></decl></param>, <param><decl><type><name>bool</name></type> <name>pre</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"incProp on primitive"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>prop</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>slot</name></expr></argument>, <argument><expr>&amp;<name>v_ins</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>slot</name> == <name>SPROP_INVALID_SLOT</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"incProp on invalid slot"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name><name>obj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>dslots_ins</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>stobj_set_slot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>, <argument><expr><call><name>box_jsval</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>incElem</name></name><parameter_list>(<param><decl><type><name>jsint</name></type> <name>incr</name></decl></param>, <param><decl><type><name>bool</name></type> <name>pre</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>r</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>addr_ins</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> || !<call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> ||
        !<call><name>guardDenseArray</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>RECORD_STOP</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>denseArrayElement</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>addr_ins</name></expr>)</condition><then> <comment type="line">// if we read a hole, abort</comment>
        <return>return <expr><name>RECORD_STOP</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>box_jsval</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>EvalCmp</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>, <param><decl><type><name>double</name></type> <name>l</name></decl></param>, <param><decl><type><name>double</name></type> <name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bool</name></type> <name>cond</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
      <case>case <expr><name>LIR_feq</name></expr>:
        <expr_stmt><expr><name>cond</name> = (<name>l</name> == <name>r</name>)</expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>LIR_flt</name></expr>:
        <expr_stmt><expr><name>cond</name> = <name>l</name> &lt; <name>r</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>LIR_fgt</name></expr>:
        <expr_stmt><expr><name>cond</name> = <name>l</name> &gt; <name>r</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>LIR_fle</name></expr>:
        <expr_stmt><expr><name>cond</name> = <name>l</name> &lt;= <name>r</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>LIR_fge</name></expr>:
        <expr_stmt><expr><name>cond</name> = <name>l</name> &gt;= <name>r</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"unexpected comparison op"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    </default>}</block></switch>
    <return>return <expr><name>cond</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>EvalCmp</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>, <param><decl><type><name>JSString</name>*</type> <name>l</name></decl></param>, <param><decl><type><name>JSString</name>*</type> <name>r</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>op</name> == <name>LIR_feq</name></expr>)</condition><then>
        <return>return <expr>!!<call><name>js_EqualStrings</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><call><name>EvalCmp</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>js_CompareStrings</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>strictEquality</name></name><parameter_list>(<param><decl><type><name>bool</name></type> <name>equal</name></decl></param>, <param><decl><type><name>bool</name></type> <name>cmpCase</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>r</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>l_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>r_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>cond</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>TraceType</name></type> <name>ltag</name> <init>= <expr><call><name>GetPromotedType</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>ltag</name> != <call><name>GetPromotedType</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>cond</name> = !<name>equal</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>ltag</name> == <name>TT_STRING</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>r_ins</name></expr>, <expr><name>l_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_EqualStrings_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cond</name> = !!<call><name>js_EqualStrings</name><argument_list>(<argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>op</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>ltag</name> == <name>TT_DOUBLE</name></expr>)</condition><then>
            <expr_stmt><expr><name>op</name> = <name>LIR_feq</name></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>ltag</name> == <name>TT_NULL</name> || <name>ltag</name> == <name>TT_OBJECT</name> || <name>ltag</name> == <name>TT_FUNCTION</name></expr>)</condition><then>
            <expr_stmt><expr><name>op</name> = <name>LIR_peq</name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>op</name> = <name>LIR_eq</name></expr>;</expr_stmt></else></if></else></if>
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>l_ins</name></expr></argument>, <argument><expr><name>r_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>equal</name></expr>)</condition><then>
            <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>cond</name> = (<name>ltag</name> == <name>TT_DOUBLE</name>)
               ? <call><name>asNumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> == <call><name>asNumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>
               : <name>l</name> == <name>r</name></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <expr_stmt><expr><name>cond</name> = (<name>cond</name> == <name>equal</name>)</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>cmpCase</name></expr>)</condition><then> <block>{
        <comment type="block">/* Only guard if the same path may not always be taken. */</comment>
        <if>if <condition>(<expr>!<call><name><name>x</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>equality</name></name><parameter_list>(<param><decl><type><name>bool</name></type> <name>negate</name></decl></param>, <param><decl><type><name>bool</name></type> <name>tryBranchAfterCond</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>rval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>lval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>l_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>r_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>rval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>equalityHelper</name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>, <argument><expr><name>l_ins</name></expr></argument>, <argument><expr><name>r_ins</name></expr></argument>, <argument><expr><name>negate</name></expr></argument>, <argument><expr><name>tryBranchAfterCond</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>equalityHelper</name></name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>l</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>r</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>l_ins</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>r_ins</name></decl></param>,
                              <param><decl><type><name>bool</name></type> <name>negate</name></decl></param>, <param><decl><type><name>bool</name></type> <name>tryBranchAfterCond</name></decl></param>,
                              <param><decl><type><name>jsval</name>&amp;</type> <name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LOpcode</name></type> <name>op</name> <init>= <expr><name>LIR_eq</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>cond</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * The if chain below closely mirrors that found in 11.9.3, in general
     * deviating from that ordering of ifs only to account for SpiderMonkey's
     * conflation of booleans and undefined and for the possibility of
     * confusing objects and null.  Note carefully the spec-mandated recursion
     * in the final else clause, which terminates because Number == T recurs
     * only if T is Object, but that must recur again to convert Object to
     * primitive, and ToPrimitive throws if the object cannot be converted to
     * a primitive value (which would terminate recursion).
     */</comment>

    <if>if <condition>(<expr><call><name>GetPromotedType</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> == <call><name>GetPromotedType</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> || <call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cond</name> = true</expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>op</name> = <name>LIR_peq</name></expr>;</expr_stmt></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSClass</name> *</type><name>clasp</name> <init>= <expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>(<name><name>clasp</name>-&gt;<name>flags</name></name> &amp; <name>JSCLASS_IS_EXTENDED</name>) &amp;&amp; ((<name>JSExtendedClass</name>*) <name>clasp</name>)-&gt;<name>equality</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"Can't trace extended class equality operator"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>op</name> = <name>LIR_peq</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cond</name> = (<name>l</name> == <name>r</name>)</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_BOOLEAN</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JSVAL_IS_BOOLEAN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cond</name> = (<name>l</name> == <name>r</name>)</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> = <name>r_ins</name></expr>, <expr><name><name>args</name><index>[<expr>1</expr>]</index></name> = <name>l_ins</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>l_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_EqualStrings_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>r_ins</name> = <call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cond</name> = !!<call><name>js_EqualStrings</name><argument_list>(<argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isNumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>isNumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cond</name> = (<call><name>asNumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> == <call><name>asNumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = <name>LIR_feq</name></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if></else></if>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>l_ins</name> = <call><name>INS_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cond</name> = true</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>r_ins</name> = <call><name>INS_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cond</name> = true</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> = <name>r_ins</name></expr>, <expr><name><name>args</name><index>[<expr>1</expr>]</index></name> = <name>cx_ins</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>r_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_StringToNumber_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cond</name> = (<call><name>asNumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> == <call><name>js_StringToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <name>LIR_feq</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>isNumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> = <name>l_ins</name></expr>, <expr><name><name>args</name><index>[<expr>1</expr>]</index></name> = <name>cx_ins</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_StringToNumber_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cond</name> = (<call><name>js_StringToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <call><name>asNumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <name>LIR_feq</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr><call><name>JSVAL_IS_BOOLEAN</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>l_ins</name> = <call><name>i2f</name><argument_list>(<argument><expr><name>l_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>l</name> = <call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><name>l</name> == <name>JSVAL_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>equalityHelper</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>l_ins</name></expr></argument>, <argument><expr><name>r_ins</name></expr></argument>, <argument><expr><name>negate</name></expr></argument>,
                                  <argument><expr><name>tryBranchAfterCond</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>JSVAL_IS_BOOLEAN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>r_ins</name> = <call><name>i2f</name><argument_list>(<argument><expr><name>r_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>r</name> = <call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><name>r</name> == <name>JSVAL_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>equalityHelper</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>l_ins</name></expr></argument>, <argument><expr><name>r_ins</name></expr></argument>, <argument><expr><name>negate</name></expr></argument>,
                                  <argument><expr><name>tryBranchAfterCond</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>(<call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> || <call><name>isNumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call>) &amp;&amp; !<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>equality_imacros</name>.<name>any_obj</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> &amp;&amp; (<call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> || <call><name>isNumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>equality_imacros</name>.<name>obj_any</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>l_ins</name> = <call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r_ins</name> = <call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cond</name> = false</expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if></else></if>

    <comment type="block">/* If the operands aren't numbers, compare them as integers. */</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>l_ins</name></expr></argument>, <argument><expr><name>r_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>negate</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cond</name> = !<name>cond</name></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Don't guard if the same path is always taken.  If it isn't, we have to
     * fuse comparisons and the following branch, because the interpreter does
     * that.
     */</comment>
    <if>if <condition>(<expr><name>tryBranchAfterCond</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>fuseIf</name><argument_list>(<argument><expr><name>pc</name> + 1</expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * There is no need to write out the result of this comparison if the trace
     * ends on this operation.
     */</comment>
    <if>if <condition>(<expr><name><name>pc</name><index>[<expr>1</expr>]</index></name> == <name>JSOP_IFNE</name> || <name><name>pc</name><index>[<expr>1</expr>]</index></name> == <name>JSOP_IFEQ</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>checkTraceEnd</name><argument_list>(<argument><expr><name>pc</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * We update the stack after the guard. This is safe since the guard bails
     * out at the comparison and the interpreter will therefore re-execute the
     * comparison. This way the value of the condition doesn't have to be
     * calculated and saved on the stack in most cases.
     */</comment>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>rval</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>relational</name></name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>, <param><decl><type><name>bool</name></type> <name>tryBranchAfterCond</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>r</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>cond</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>l_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>r_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>fp</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>lnum</name></decl>, <decl><type ref="prev"/><name>rnum</name></decl>;</decl_stmt>

    <comment type="block">/*
     * 11.8.5 if either argument is an object with a function-valued valueOf
     * property; if both arguments are objects with non-function-valued valueOf
     * properties, abort.
     */</comment>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>binary_imacros</name>.<name>obj_obj</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>binary_imacros</name>.<name>obj_any</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>binary_imacros</name>.<name>any_obj</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* 11.8.5 steps 3, 16-21. */</comment>
    <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>r_ins</name></expr>, <expr><name>l_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>l_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_CompareStrings_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r_ins</name> = <call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cond</name> = <call><name>EvalCmp</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>do_comparison</name>;</goto>
    }</block></then></if>

    <comment type="block">/* 11.8.5 steps 4-5. */</comment>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_NUMBER</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>l_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
          <case>case <expr><name>JSVAL_SPECIAL</name></expr>:
            <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>l_ins</name> = <call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name>js_NaN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><name>l_ins</name> = <call><name>i2f</name><argument_list>(<argument><expr><name>l_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            <break>break;</break>
          </case><case>case <expr><name>JSVAL_STRING</name></expr>:
            <expr_stmt><expr><name>l_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_StringToNumber_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSVAL_OBJECT</name></expr>:
            <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>l_ins</name> = <call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr>0.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <comment type="line">// FALL THROUGH</comment>
          </case><case>case <expr><name>JSVAL_INT</name></expr>:
          </case><case>case <expr><name>JSVAL_DOUBLE</name></expr>:
          </case><default>default:
            <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"JSVAL_IS_NUMBER if int/double, objects should "
                           "have been handled at start of method"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"safety belt"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_NUMBER</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>r_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
          <case>case <expr><name>JSVAL_SPECIAL</name></expr>:
            <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>r_ins</name> = <call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name>js_NaN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><name>r_ins</name> = <call><name>i2f</name><argument_list>(<argument><expr><name>r_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            <break>break;</break>
          </case><case>case <expr><name>JSVAL_STRING</name></expr>:
            <expr_stmt><expr><name>r_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_StringToNumber_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSVAL_OBJECT</name></expr>:
            <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>r_ins</name> = <call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr>0.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <comment type="line">// FALL THROUGH</comment>
          </case><case>case <expr><name>JSVAL_INT</name></expr>:
          </case><case>case <expr><name>JSVAL_DOUBLE</name></expr>:
          </case><default>default:
            <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"JSVAL_IS_NUMBER if int/double, objects should "
                           "have been handled at start of method"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"safety belt"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
    }</block></then></if>
    <block>{
        <function_decl><type><name>AutoValueRooter</name></type> <name>tvr</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>JSVAL_NULL</name></type></decl></param>)</parameter_list>;</function_decl>

        <expr_stmt><expr>*<call><name><name>tvr</name>.<name>addr</name></name><argument_list>()</argument_list></call> = <name>l</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lnum</name> = <call><name>js_ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>tvr</name>.<name>addr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<call><name><name>tvr</name>.<name>addr</name></name><argument_list>()</argument_list></call> = <name>r</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rnum</name> = <call><name>js_ValueToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>tvr</name>.<name>addr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <expr_stmt><expr><name>cond</name> = <call><name>EvalCmp</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>rnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fp</name> = true</expr>;</expr_stmt>

    <comment type="block">/* 11.8.5 steps 6-15. */</comment>
  <label><name>do_comparison</name>:</label>
    <comment type="block">/*
     * If the result is not a number or it's not a quad, we must use an integer
     * compare.
     */</comment>
    <if>if <condition>(<expr>!<name>fp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>isFCmpOpcode</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <call><name>LOpcode</name><argument_list>(<argument><expr><name>op</name> + (<name>LIR_eq</name> - <name>LIR_feq</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>l_ins</name></expr></argument>, <argument><expr><name>r_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Don't guard if the same path is always taken.  If it isn't, we have to
     * fuse comparisons and the following branch, because the interpreter does
     * that.
     */</comment>
    <if>if <condition>(<expr><name>tryBranchAfterCond</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>fuseIf</name><argument_list>(<argument><expr><name>pc</name> + 1</expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * There is no need to write out the result of this comparison if the trace
     * ends on this operation.
     */</comment>
    <if>if <condition>(<expr><name><name>pc</name><index>[<expr>1</expr>]</index></name> == <name>JSOP_IFNE</name> || <name><name>pc</name><index>[<expr>1</expr>]</index></name> == <name>JSOP_IFEQ</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>checkTraceEnd</name><argument_list>(<argument><expr><name>pc</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * We update the stack after the guard. This is safe since the guard bails
     * out at the comparison and the interpreter will therefore re-execute the
     * comparison. This way the value of the condition doesn't have to be
     * calculated and saved on the stack in most cases.
     */</comment>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>unary</name></name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>intop</name> <init>= <expr><name><name>retTypes</name><index>[<expr><name>op</name></expr>]</index></name> == <name>LTy_I32</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>a</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>intop</name></expr>)</condition><then>
            <expr_stmt><expr><name>a</name> = <call><name>f2i</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>a</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>intop</name></expr>)</condition><then>
            <expr_stmt><expr><name>a</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>RECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>binary</name></name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>r</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_IF_XML</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>RETURN_IF_XML</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>binary_imacros</name>.<name>obj_obj</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>binary_imacros</name>.<name>obj_any</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_IF_XML</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>binary_imacros</name>.<name>any_obj</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>bool</name></type> <name>intop</name> <init>= <expr><name><name>retTypes</name><index>[<expr><name>op</name></expr>]</index></name> == <name>LTy_I32</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>a</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>b</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>leftIsNumber</name> <init>= <expr><call><name>isNumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>lnum</name> <init>= <expr><name>leftIsNumber</name> ? <call><name>asNumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>rightIsNumber</name> <init>= <expr><call><name>isNumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>rnum</name> <init>= <expr><name>rightIsNumber</name> ? <call><name>asNumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>op</name> != <name>LIR_fadd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// LIR_fadd/IS_STRING case handled by record_JSOP_ADD()</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>a</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>a</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_StringToNumber_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lnum</name> = <call><name>js_StringToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>leftIsNumber</name> = true</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>op</name> != <name>LIR_fadd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// LIR_fadd/IS_STRING case handled by record_JSOP_ADD()</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>b</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>b</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_StringToNumber_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rnum</name> = <call><name>js_StringToNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rightIsNumber</name> = true</expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* N.B. void is JSVAL_SPECIAL. */</comment>
    <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> = <call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name>js_NaN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>lnum</name> = <name>js_NaN</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>a</name> = <call><name>i2f</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>lnum</name> = <call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>leftIsNumber</name> = true</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>b</name> = <call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name>js_NaN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rnum</name> = <name>js_NaN</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>b</name> = <call><name>i2f</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rnum</name> = <call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>rightIsNumber</name> = true</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>leftIsNumber</name> &amp;&amp; <name>rightIsNumber</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>intop</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> = (<name>op</name> == <name>LIR_ush</name>) ? <call><name>f2u</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> : <call><name>f2i</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>b</name> = <call><name>f2i</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>a</name> = <call><name>alu</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>rnum</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>intop</name></expr>)</condition><then>
            <expr_stmt><expr><name>a</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>op</name> == <name>LIR_ush</name> ? <name>LIR_u2f</name> : <name>LIR_i2f</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>RECORD_STOP</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_notme</name> &amp;&amp; <name>defined</name> <name>XP_UNIX</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name>*</type> <name>shapefp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DumpShape</name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>prefix</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSScope</name>*</type> <name>scope</name> <init>= <expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>shapefp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>shapefp</name> = <call><name>fopen</name><argument_list>(<argument><expr>"/tmp/shapes.dump"</expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>shapefp</name></expr>)</condition><then>
            <return>return;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>shapefp</name></expr></argument>, <argument><expr>"\n%s: shape %u flags %x\n"</expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>scope</name>-&gt;<name>shape</name></name></expr></argument>, <argument><expr><name><name>scope</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name> <init>= <expr><call><name><name>scope</name>-&gt;<name>lastProperty</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>sprop</name></expr>;</condition> <incr><expr><name>sprop</name> = <name><name>sprop</name>-&gt;<name>parent</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>JSID_IS_ATOM</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>shapefp</name></expr></argument>, <argument><expr>" %s"</expr></argument>, <argument><expr><call><name>JS_GetStringBytes</name><argument_list>(<argument><expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><call><name>ID_TO_VALUE</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JSID_IS_OBJECT</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>shapefp</name></expr></argument>, <argument><expr>" %d"</expr></argument>, <argument><expr><call><name>JSID_TO_INT</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>shapefp</name></expr></argument>, <argument><expr>" %u %p %p %x %x %d\n"</expr></argument>,
                <argument><expr><name><name>sprop</name>-&gt;<name>slot</name></name></expr></argument>, <argument><expr><name><name>sprop</name>-&gt;<name>getter</name></name></expr></argument>, <argument><expr><name><name>sprop</name>-&gt;<name>setter</name></name></expr></argument>, <argument><expr><name><name>sprop</name>-&gt;<name>attrs</name></name></expr></argument>, <argument><expr><name><name>sprop</name>-&gt;<name>flags</name></name></expr></argument>,
                <argument><expr><name><name>sprop</name>-&gt;<name>shortid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>shapefp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>dumpGuardedShapes</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>prefix</name></decl></param>)</parameter_list>
<block>{
    <for>for (<init><decl><type><name><name>GuardedShapeTable</name>::<name>Range</name></name></type> <name>r</name> <init>= <expr><call><name><name>guardedShapeTable</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr>!<call><name><name>r</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><call><name><name>r</name>.<name>popFront</name></name><argument_list>()</argument_list></call></expr></incr>)
        <expr_stmt><expr><call><name>DumpShape</name><argument_list>(<argument><expr><call><name><name>r</name>.<name>front</name></name><argument_list>()</argument_list></call>.<name>value</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG_notme &amp;&amp; XP_UNIX */</comment>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>guardShape</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>shape</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>guardName</name></decl></param>,
                          <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Test (with add if missing) for a remembered guard for (obj_ins, obj).</comment>
    <decl_stmt><decl><type><name><name>GuardedShapeTable</name>::<name>AddPtr</name></name></type> <name>p</name> <init>= <expr><call><name><name>guardedShapeTable</name>.<name>lookupForAdd</name></name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>p</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>value</name></name> == <name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<call><name><name>guardedShapeTable</name>.<name>add</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>RECORD_ERROR</name></expr>;</return></then></if>
    }</block></else></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_notme</name> &amp;&amp; <name>defined</name> <name>XP_UNIX</name></expr></cpp:if>
    <expr_stmt><expr><call><name>DumpShape</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>"guard"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>shapefp</name></expr></argument>, <argument><expr>"for obj_ins %p\n"</expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Finally, emit the shape guard.</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>shape_ins</name> <init>=
        <expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><call><name>map</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSScope</name></expr></argument>, <argument><expr><name>shape</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"shape"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
          <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>shape_ins</name></expr></argument>, <argument><expr><name>shape</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>guardName</name></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>forgetGuardedShapesForObject</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list>
<block>{
    <for>for (<init><expr><name><name>GuardedShapeTable</name>::<name>Enum</name></name> <call><name>e</name><argument_list>(<argument><expr><name>guardedShapeTable</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr>!<call><name><name>e</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><call><name><name>e</name>.<name>popFront</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name><name>e</name>.<name>front</name></name><argument_list>()</argument_list></call>.<name>value</name> == <name>obj</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_notme</name> &amp;&amp; <name>defined</name> <name>XP_UNIX</name></expr></cpp:if>
            <expr_stmt><expr><call><name>DumpShape</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>obj</name></name></expr></argument>, <argument><expr>"forget"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name><name>e</name>.<name>removeFront</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>forgetGuardedShapes</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_notme</name> &amp;&amp; <name>defined</name> <name>XP_UNIX</name></expr></cpp:if>
    <expr_stmt><expr><call><name>dumpGuardedShapes</name><argument_list>(<argument><expr>"forget-all"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name><name>guardedShapeTable</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObjectOps</name></expr></argument>, <argument><expr><name>objectMap</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>inline</specifier> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>map</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>(<name>int</name>) <call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"map"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>bool</name></type>
<name><name>TraceRecorder</name>::<name>map_is_native</name></name><parameter_list>(<param><decl><type><name>JSObjectMap</name>*</type> <name>map</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>map_ins</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>ops_ins</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>op_offset</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op_offset</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>JSObjectOps</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op_offset</name> % <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<param><type><name>ops</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(*(void **) ((uint8 *) (ops) + op_offset))</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>void</name>*</type> <name>ptr</name> <init>= <expr><call><name>OP</name><argument_list>(<argument><expr><name><name>map</name>-&gt;<name>ops</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>ptr</name> != <call><name>OP</name><argument_list>(<argument><expr>&amp;<name>js_ObjectOps</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>

    <expr_stmt><expr><name>ops_ins</name> = <call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>map_ins</name></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObjectMap</name></expr></argument>, <argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr>"ops"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>n</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>ops_ins</name></expr></argument>, <argument><expr><name>op_offset</name></expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
          <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"guard(native-map)"</expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>test_property_cache</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>JSObject</name>*&amp;</type> <name>obj2</name></decl></param>, <param><decl><type><name>PCVal</name>&amp;</type> <name>pcval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> != <name>JSOP_INITPROP</name> &amp;&amp; *<name>pc</name> != <name>JSOP_INITMETHOD</name> &amp;&amp;
              *<name>pc</name> != <name>JSOP_SETNAME</name> &amp;&amp; *<name>pc</name> != <name>JSOP_SETPROP</name> &amp;&amp; *<name>pc</name> != <name>JSOP_SETMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Mimic the interpreter's special case for dense arrays by skipping up one</comment>
    <comment type="line">// hop along the proto chain when accessing a named (not indexed) property,</comment>
    <comment type="line">// typically to find Array.prototype methods.</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>aobj</name> <init>= <expr><name>obj</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>obj</name>-&gt;<name>isDenseArray</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>guardDenseArray</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aobj</name> = <call><name><name>obj</name>-&gt;<name>getProto</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>obj_ins</name> = <call><name>stobj_get_proto</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSAtom</name>*</type> <name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PropertyCacheEntry</name>*</type> <name>entry</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_PROPERTY_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<call><name>test</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>aobj</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>atom</name></expr>)</condition><then> <block>{
        <comment type="line">// Miss: pre-fill the cache for the interpreter, as well as for our needs.</comment>
        <decl_stmt><decl><type><name>jsid</name></type> <name>id</name> <init>= <expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSProperty</name>*</type> <name>prop</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>JOF_OPMODE</name><argument_list>(<argument><expr>*<name>pc</name></expr></argument>)</argument_list></call> == <name>JOF_NAME</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>aobj</name> == <name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>TraceMonitor</name> &amp;</type><name>localtm</name> <init>= <expr>*<name>traceMonitor</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>entry</name> = <call><name>js_FindPropertyHelper</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>obj2</name></expr></argument>, <argument><expr>&amp;<name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* js_FindPropertyHelper can reenter the interpreter and kill |this|. */</comment>
            <if>if <condition>(<expr>!<name><name>localtm</name>.<name>recorder</name></name></expr>)</condition><then>
                <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return></then></if>

            <if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_ERROR_A</name><argument_list>(<argument><expr>"error in js_FindPropertyHelper"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name>entry</name> == <name>JS_NO_PROP_CACHE_FILL</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"cannot cache name"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>TraceMonitor</name> &amp;</type><name>localtm</name> <init>= <expr>*<name>traceMonitor</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSContext</name> *</type><name>localcx</name> <init>= <expr><name>cx</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>protoIndex</name> <init>= <expr><call><name>js_LookupPropertyWithFlags</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>aobj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>,
                                                        <argument><expr><name><name>cx</name>-&gt;<name>resolveFlags</name></name></expr></argument>,
                                                        <argument><expr>&amp;<name>obj2</name></expr></argument>, <argument><expr>&amp;<name>prop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* js_LookupPropertyWithFlags can reenter the interpreter and kill |this|. */</comment>
            <if>if <condition>(<expr>!<name><name>localtm</name>.<name>recorder</name></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>prop</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>obj2</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>localcx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>protoIndex</name> &lt; 0</expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_ERROR_A</name><argument_list>(<argument><expr>"error in js_LookupPropertyWithFlags"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <if>if <condition>(<expr><name>prop</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>OBJ_IS_NATIVE</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name><name>obj2</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"property found on non-native object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>entry</name> = <call><name>JS_PROPERTY_CACHE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<call><name>fill</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>aobj</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>protoIndex</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>,
                                                   <argument><expr>(<name>JSScopeProperty</name>*) <name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>entry</name> == <name>JS_NO_PROP_CACHE_FILL</name></expr>)</condition><then>
                    <expr_stmt><expr><name>entry</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
            }</block></then></if>

        }</block></else></if>

        <if>if <condition>(<expr>!<name>prop</name></expr>)</condition><then> <block>{
            <comment type="line">// Propagate obj from js_FindPropertyHelper to record_JSOP_BINDNAME</comment>
            <comment type="line">// via our obj2 out-parameter. If we are recording JSOP_SETNAME and</comment>
            <comment type="line">// the global it's assigning does not yet exist, create it.</comment>
            <expr_stmt><expr><name>obj2</name> = <name>obj</name></expr>;</expr_stmt>

            <comment type="line">// Use a null pcval to return "no such property" to our caller.</comment>
            <expr_stmt><expr><call><name><name>pcval</name>.<name>setNull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>obj2</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"failed to fill property cache"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="line">// There's a potential race in any JS_THREADSAFE embedding that's nuts</comment>
    <comment type="line">// enough to share mutable objects on the scope or proto chain, but we</comment>
    <comment type="line">// don't care about such insane embeddings. Anyway, the (scope, proto)</comment>
    <comment type="line">// entry-&gt;vcap coordinates must reach obj2 from aobj at this point.</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>requestDepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>guardPropertyCacheHit</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>aobj</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pcval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>guardPropertyCacheHit</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>,
                                     <param><decl><type><name>JSObject</name>*</type> <name>aobj</name></decl></param>,
                                     <param><decl><type><name>JSObject</name>*</type> <name>obj2</name></decl></param>,
                                     <param><decl><type><name>PropertyCacheEntry</name>*</type> <name>entry</name></decl></param>,
                                     <param><decl><type><name>PCVal</name>&amp;</type> <name>pcval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>uint32</name></type> <name>vshape</name> <init>= <expr><call><name><name>entry</name>-&gt;<name>vshape</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Special case for the global object, which may be aliased to get a property value.</comment>
    <comment type="line">// To catch cross-global property accesses we must check against globalObj identity.</comment>
    <comment type="line">// But a JOF_NAME mode opcode needs no guard, as we ensure the global object's shape</comment>
    <comment type="line">// never changes, and name ops can't reach across a global object ('with' aborts).</comment>
    <if>if <condition>(<expr><name>aobj</name> == <name>globalObj</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name><name>entry</name>-&gt;<name>adding</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"adding a property to the global object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name> <init>= <expr><call><name>js_GetOpcode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>JOF_OPMODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> != <name>JOF_NAME</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
                  <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"guard_global"</expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>guardShape</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>aobj</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kshape</name></name></expr></argument>, <argument><expr>"guard_kshape"</expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><call><name><name>entry</name>-&gt;<name>adding</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name> *</type><name>vshape_ins</name> <init>= <expr><call><name>addName</name><argument_list>(
            <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>,
                         <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>cx_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSContext</name></expr></argument>, <argument><expr><name>runtime</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr>"runtime"</expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSRuntime</name></expr></argument>, <argument><expr><name>protoHazardShape</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr>"protoHazardShape"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
              <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>vshape_ins</name></expr></argument>, <argument><expr><name>vshape</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"guard_protoHazardShape"</expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// For any hit that goes up the scope and/or proto chains, we will need to</comment>
    <comment type="line">// guard on the shape of the object containing the property.</comment>
    <if>if <condition>(<expr><call><name><name>entry</name>-&gt;<name>vcapTag</name></name><argument_list>()</argument_list></call> &gt;= 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>OBJ_SHAPE</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call> == <name>vshape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>obj2</name> == <name>globalObj</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"hitting the global object via a prototype chain"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj2_ins</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>entry</name>-&gt;<name>vcapTag</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then> <block>{
            <comment type="line">// Duplicate the special case in PropertyCache::test.</comment>
            <expr_stmt><expr><name>obj2_ins</name> = <call><name>addName</name><argument_list>(<argument><expr><call><name>stobj_get_proto</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"proto"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>obj2_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>obj2_ins</name> = <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>guardShape</name><argument_list>(<argument><expr><name>obj2_ins</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>vshape</name></expr></argument>, <argument><expr>"guard_vshape"</expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>pcval</name> = <name><name>entry</name>-&gt;<name>vword</name></name></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>stobj_set_fslot</name></name><parameter_list>(<param><decl><type><name>LIns</name> *</type><name>obj_ins</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>fslots</name></expr></argument>)</argument_list></call> + <name>slot</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>stobj_set_dslot</name></name><parameter_list>(<param><decl><type><name>LIns</name> *</type><name>obj_ins</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>dslots_ins</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>dslots_ins</name></expr>)</condition><then>
        <expr_stmt><expr><name>dslots_ins</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>dslots</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>, <argument><expr><name>slot</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>TraceRecorder</name>::<name>stobj_set_slot</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>dslots_ins</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>slot</name> &lt; <name>JS_INITIAL_NSLOTS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>stobj_set_fslot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>stobj_set_dslot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>slot</name> - <name>JS_INITIAL_NSLOTS</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>stobj_get_fslot</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>slot</name> &lt; <name>JS_INITIAL_NSLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>fslots</name></expr></argument>)</argument_list></call> + <name>slot</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                        <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>stobj_get_const_fslot</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>slot</name> &lt; <name>JS_INITIAL_NSLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>fslots</name></expr></argument>)</argument_list></call> + <name>slot</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                        <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>stobj_get_dslot</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>index</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>dslots_ins</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>dslots_ins</name></expr>)</condition><then>
        <expr_stmt><expr><name>dslots_ins</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>dslots</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>, <argument><expr><name>index</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>stobj_get_slot</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>slot</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>dslots_ins</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>slot</name> &lt; <name>JS_INITIAL_NSLOTS</name></expr>)</condition><then>
        <return>return <expr><call><name>stobj_get_fslot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><call><name>stobj_get_dslot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>slot</name> - <name>JS_INITIAL_NSLOTS</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>box_jsval</name></name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>v_ins</name>-&gt;<name>isF64</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>fcallinfo</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call> == &amp;<name>js_UnboxDouble_ci</name></expr>)</condition><then>
            <return>return <expr><call><name>fcallarg</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>isPromoteInt</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_BoxInt32_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>v_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_BoxDouble_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_ERROR_COOKIE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>v_ins</name></expr>;</return>
    }</block></then></if>
    <switch>switch <condition>(<expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
      <case>case <expr><name>JSVAL_SPECIAL</name></expr>:
        <return>return <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_pior</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_u2p</name></name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>JSVAL_TAGBITS</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_SPECIAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
      </case><case>case <expr><name>JSVAL_OBJECT</name></expr>:
        <return>return <expr><name>v_ins</name></expr>;</return>
      </case><default>default:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == <name>JSVAL_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_pior</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_STRING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>unbox_jsval</name></name><parameter_list>(<param><decl><type><name>jsval</name></type> <name>v</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// JSVAL_IS_NUMBER(v)</comment>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>,
              <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_or</name></expr></argument>,
                                     <argument><expr><call><name>p2i</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piand</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_INT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>,
                                               <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piand</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>,
                                                         <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_TAGMASK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_DOUBLE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>v_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_UnboxDouble_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <switch>switch <condition>(<expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
      <case>case <expr><name>JSVAL_SPECIAL</name></expr>:
        <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_VOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>INS_VOID</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
              <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>,
                        <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piand</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_TAGMASK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_SPECIAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>v_ins</name>-&gt;<name>isconstp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_VOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>p2i</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pursh</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>JSVAL_TAGBITS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

      </case><case>case <expr><name>JSVAL_OBJECT</name></expr>:
        <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// JSVAL_NULL maps to type TT_NULL, so insist that v_ins == 0 here.</comment>
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
                  <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>,
                            <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piand</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_TAGMASK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_OBJECT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr><call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>,
                            <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piand</name></expr></argument>,
                                      <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>classword</name></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr>~<name>JSSLOT_CLASS_MASK_BITS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr>&amp;<name>js_FunctionClass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>v_ins</name></expr>;</return>

      </case><default>default:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == <name>JSVAL_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
              <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>,
                        <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piand</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_TAGMASK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_STRING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piand</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insImmWord</name></name><argument_list>(<argument><expr>~<name>JSVAL_TAGMASK</name></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr>"~JSVAL_TAGMASK"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>getThis</name></name><parameter_list>(<param><decl><type><name>LIns</name>*&amp;</type> <name>this_ins</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * JSStackFrame::getThisObject updates cx-&gt;fp-&gt;argv[-1], so sample it into 'original' first.
     */</comment>
    <decl_stmt><decl><type><name>jsval</name></type> <name>original</name> <init>= <expr><name>JSVAL_NULL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>original</name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-1</expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>guardClass</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>js_WithClass</name></expr></argument>,
                       <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't trace getThis on With object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>thisObj</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>getThisObject</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>thisObj</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr>"fp-&gt;getThisObject failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* In global code, bake in the global object as 'this' object. */</comment>
    <if>if <condition>(<expr>!<call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>callee</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>callDepth</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>this_ins</name> = <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>thisObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We don't have argv[-1] in global code, so we don't update the
         * tracker here.
         */</comment>
        <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>thisv</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name>thisv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Traces type-specialize between null and objects, so if we currently see
     * a null value in argv[-1], this trace will only match if we see null at
     * runtime as well.  Bake in the global object as 'this' object, updating
     * the tracker as well. We can only detect this condition prior to calling
     * JSStackFrame::getThisObject, since it updates the interpreter's copy of
     * argv[-1].
     */</comment>
    <decl_stmt><decl><type><name>JSClass</name>*</type> <name>clasp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call> ||
        (((<name>clasp</name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call>-&gt;<call><name>getClass</name><argument_list>()</argument_list></call>) == &amp;<name>js_CallClass</name>) ||
         (<name>clasp</name> == &amp;<name>js_BlockClass</name>))</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>clasp</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>guardClass</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>thisv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>clasp</name></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>thisv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>thisObj</name> != <name>globalObj</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"global object was wrapped while recording"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>this_ins</name> = <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>thisObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>thisv</name></expr></argument>, <argument><expr><name>this_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>this_ins</name> = <call><name>get</name><argument_list>(<argument><expr>&amp;<name>thisv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>wrappedGlobal</name> <init>= <expr><call><name><name>globalObj</name>-&gt;<name>thisObject</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>wrappedGlobal</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr>"globalObj-&gt;thisObject hook threw in getThis"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * The only unwrapped object that needs to be wrapped that we can get here
     * is the global object obtained throught the scope chain.
     */</comment>
    <expr_stmt><expr><name>this_ins</name> = <call><name><name>lir</name>-&gt;<name>ins_choose</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><call><name>stobj_get_parent</name><argument_list>(<argument><expr><name>this_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>wrappedGlobal</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>this_ins</name></expr></argument>, <argument><expr><call><name><name>avmplus</name>::<name>AvmCore</name>::<name>use_cmov</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>


<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>TraceRecorder</name>::<name>guardClass</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>JSClass</name>*</type> <name>clasp</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>,
                          <param><decl><type><name>AccSet</name></type> <name>accSet</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bool</name></type> <name>cond</name> <init>= <expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> == <name>clasp</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>class_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>classword</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>accSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>class_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piand</name></expr></argument>, <argument><expr><name>class_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr>~<name>JSSLOT_CLASS_MASK_BITS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name></type> <name><name>namebuf</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr>sizeof <name>namebuf</name></expr></argument>, <argument><expr>"guard(class is %s)"</expr></argument>, <argument><expr><name><name>clasp</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>namebuf</name><index>[]</index></name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>class_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>clasp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cond</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>TraceRecorder</name>::<name>guardDenseArray</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>ExitType</name></type> <name>exitType</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>guardClass</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>js_ArrayClass</name></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>exitType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>TraceRecorder</name>::<name>guardDenseArray</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>guardClass</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>js_ArrayClass</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>bool</name></type>
<name><name>TraceRecorder</name>::<name>guardHasPrototype</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>,
                                 <param><decl><type><name>JSObject</name>**</type> <name>pobj</name></decl></param>, <param><decl><type><name>LIns</name>**</type> <name>pobj_ins</name></decl></param>,
                                 <param><decl><type><name>VMSideExit</name>*</type> <name>exit</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>pobj</name> = <call><name><name>obj</name>-&gt;<name>getProto</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pobj_ins</name> = <call><name>stobj_get_proto</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>cond</name> <init>= <expr>*<name>pobj</name> == <name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr>*<name>pobj_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"guard(proto-not-null)"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>!<name>cond</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>guardPrototypeHasNoIndexedProperties</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>ExitType</name></type> <name>exitType</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Guard that no object along the prototype chain has any indexed
     * properties which might become visible through holes in the array.
     */</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>exitType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>js_PrototypeHasIndexedProperties</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>RECORD_STOP</name></expr>;</return></then></if>

    <while>while <condition>(<expr><call><name>guardHasPrototype</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>obj_ins</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>guardShape</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>OBJ_SHAPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"guard(shape)"</expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>guardNotGlobalObject</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>obj</name> == <name>globalObj</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"reference aliases global object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="line">// Helper for clearXEntryFrameSlotsFromTracker.</comment>
<comment type="line">// Clear out slots of the given frame in the NativeFrameTracker. All argument slots</comment>
<comment type="line">// are cleared. |nslots| local slots are cleared.</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>clearFrameSlotsFromTracker</name></name><parameter_list>(<param><decl><type><name>Tracker</name>&amp;</type> <name>which</name></decl></param>, <param><decl><type><name>JSStackFrame</name>*</type> <name>fp</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>nslots</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Clear out all slots of this frame in the nativeFrameTracker. Different
     * locations on the VM stack might map to different locations on the native
     * stack depending on the number of arguments (i.e.) of the next call, so
     * we have to make sure we map those in to the cache with the right
     * offsets.
     */</comment>
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vpstop</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Duplicate native stack layout computation: see VisitFrameSlots header comment.
     * This doesn't do layout arithmetic, but it must clear out all the slots defined as
     * imported by VisitFrameSlots.
     */</comment>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>argv</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>vp</name> = &amp;<name><name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>vpstop</name> = &amp;<name><name>fp</name>-&gt;<name>argv</name><index>[<expr><call><name>argSlots</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>vp</name> &lt; <name>vpstop</name></expr>)</condition>
            <expr_stmt><expr><call><name><name>which</name>.<name>set</name></name><argument_list>(<argument><expr><name>vp</name>++</expr></argument>, <argument><expr>(<name>LIns</name>*)0</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
        <expr_stmt><expr><call><name><name>which</name>.<name>set</name></name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>, <argument><expr>(<name>LIns</name>*)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>which</name>.<name>set</name></name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>scopeChain</name></name></expr></argument>, <argument><expr>(<name>LIns</name>*)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>vp</name> = &amp;<name><name>fp</name>-&gt;<name>slots</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>vpstop</name> = &amp;<name><name>fp</name>-&gt;<name>slots</name><index>[<expr><name>nslots</name></expr>]</index></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>vp</name> &lt; <name>vpstop</name></expr>)</condition>
        <expr_stmt><expr><call><name><name>which</name>.<name>set</name></name><argument_list>(<argument><expr><name>vp</name>++</expr></argument>, <argument><expr>(<name>LIns</name>*)0</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>JSStackFrame</name>*</type>
<name><name>TraceRecorder</name>::<name>entryFrame</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>callDepth</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <expr_stmt><expr><name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name></expr>;</expr_stmt></for>
    <return>return <expr><name>fp</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>clearEntryFrameSlotsFromTracker</name></name><parameter_list>(<param><decl><type><name>Tracker</name>&amp;</type> <name>which</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name>entryFrame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Clear only slots that are not also used by the next frame up.</comment>
    <expr_stmt><expr><call><name>clearFrameSlotsFromTracker</name><argument_list>(<argument><expr><name>which</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>clearCurrentFrameSlotsFromTracker</name></name><parameter_list>(<param><decl><type><name>Tracker</name>&amp;</type> <name>which</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Clear out all local slots.</comment>
    <expr_stmt><expr><call><name>clearFrameSlotsFromTracker</name><argument_list>(<argument><expr><name>which</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>nslots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * If we have created an |arguments| object for the frame, we must copy the
 * argument values into the object as properties in case it is used after
 * this frame returns.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>putActivationObjects</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bool</name></type> <name>have_args</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argsobj</name></name> &amp;&amp; <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>have_call</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name></name> &amp;&amp; <call><name>JSFUN_HEAVYWEIGHT_TEST</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>countArgsAndVars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>have_args</name> &amp;&amp; !<name>have_call</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><name>have_args</name> ? <call><name>argSlots</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call> : <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>args_ins</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>nargs</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>args_ins</name> = <call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof> * <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>nargs</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>arg_ins</name> <init>= <expr><call><name>box_jsval</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>arg_ins</name></expr></argument>, <argument><expr><name>args_ins</name></expr></argument>, <argument><expr><name>i</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>args_ins</name> = <call><name>INS_CONSTPTR</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>have_args</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>argsobj_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>args_ins</name></expr>, <expr><name>argsobj_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_PutArguments_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>have_call</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>nslots</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>countVars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>slots_ins</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>nslots</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>slots_ins</name> = <call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof> * <name>nslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>nslots</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <decl_stmt><decl><type><name>LIns</name>*</type> <name>slot_ins</name> <init>= <expr><call><name>box_jsval</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>slot_ins</name></expr></argument>, <argument><expr><name>slots_ins</name></expr></argument>, <argument><expr><name>i</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>slots_ins</name> = <call><name>INS_CONSTPTR</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>scopeChain_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChainVal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>slots_ins</name></expr>, <expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>)</argument_list></call></expr>, <expr><name>args_ins</name></expr>,
                         <expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name></expr></argument>)</argument_list></call></expr>, <expr><name>scopeChain_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_PutCallObjectOnTrace_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_REQUIRES_STACK</name> <specifier>inline</specifier> <name>bool</name></type>
<name>IsTraceableRecursion</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>down</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>down</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>down</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>down</name>-&gt;<name>script</name></name> != <name><name>fp</name>-&gt;<name>script</name></name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>down</name>-&gt;<name>argc</name></name> != <name><name>fp</name>-&gt;<name>argc</name></name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>argc</name></name> != <name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>imacpc</name></name> || <name><name>down</name>-&gt;<name>imacpc</name></name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<expr>(<name><name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_CONSTRUCTING</name>) || (<name><name>down</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_CONSTRUCTING</name>)</expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>blockChain</name></name> || <name><name>down</name>-&gt;<name>blockChain</name></name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <if>if <condition>(<expr>*<name><name>fp</name>-&gt;<name>script</name>-&gt;<name>code</name></name> != <name>JSOP_TRACE</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_EnterFrame</name></name><parameter_list>(<param><decl><type><name>uintN</name>&amp;</type> <name>inlineCallCount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>++<name>callDepth</name> &gt;= <name>MAX_CALLDEPTH</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"exceeded maximum call depth"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"EnterFrame %s, callDepth=%d\n"</expr></argument>,
                      <argument><expr><call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>atom</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>debug_only_stmt</name><argument_list>(
        <argument>if (LogController.lcbits &amp; LC_TMRecorder) {
            js_Disassemble(cx, cx-&gt;fp-&gt;script, JS_TRUE, stdout);
            debug_only_print0(LC_TMTracer, "----\n");
        }</argument>
    )</argument_list></macro>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>void_ins</name> <init>= <expr><call><name>INS_VOID</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Duplicate native stack layout computation: see VisitFrameSlots header comment.</comment>
    <comment type="line">// This doesn't do layout arithmetic, but it must initialize in the tracker all the</comment>
    <comment type="line">// slots defined as imported by VisitFrameSlots.</comment>
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name> <init>= <expr>&amp;<name><name>fp</name>-&gt;<name>argv</name><index>[<expr><name><name>fp</name>-&gt;<name>argc</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vpstop</name> <init>= <expr><name>vp</name> + <call><name>ptrdiff_t</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name></expr></argument>)</argument_list></call> - <call><name>ptrdiff_t</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>vp</name> &lt; <name>vpstop</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name><name>nativeFrameTracker</name>.<name>set</name></name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr>(<name>LIns</name>*)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>vp</name>++</expr></argument>, <argument><expr><name>void_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name>vp</name> = &amp;<name><name>fp</name>-&gt;<name>slots</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>vpstop</name> = <name>vp</name> + <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>vp</name> &lt; <name>vpstop</name></expr>)</condition>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>vp</name>++</expr></argument>, <argument><expr><name>void_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>, <argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>callee_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>scopeChain_ins</name> <init>= <expr><call><name>stobj_get_parent</name><argument_list>(<argument><expr><name>callee_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name></name> &amp;&amp; <call><name>JSFUN_HEAVYWEIGHT_TEST</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// We need to make sure every part of the frame is known to the tracker</comment>
        <comment type="line">// before taking a snapshot.</comment>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>scopeChainVal</name></name></expr></argument>, <argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>js_IsNamedLambda</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't call named lambda heavyweight on trace"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>fun_ins</name> <init>= <expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>scopeChain_ins</name></expr>, <expr><name>callee_ins</name></expr>, <expr><name>fun_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_CreateCallObjectOnTrace_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>call_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>scopeChainVal</name></name></expr></argument>, <argument><expr><name>call_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>scopeChainVal</name></name></expr></argument>, <argument><expr><name>scopeChain_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*
     * Check for recursion. This is a special check for recursive cases that can be
     * a trace-tree, just like a loop. If recursion acts weird, for example
     * differing argc or existence of an imacpc, it's not something this code is
     * concerned about. That should pass through below to not regress pre-recursion
     * functionality.
     */</comment>
    <if>if <condition>(<expr><call><name>IsTraceableRecursion</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>tree</name>-&gt;<name>script</name></name> == <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>tree</name>-&gt;<name>recursion</name></name> == <name>Recursion_Disallowed</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"recursion not allowed in this tree"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>tree</name>-&gt;<name>script</name></name> != <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"recursion does not match original tree"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>downRecursion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Try inlining one level in case this recursion doesn't go too deep. */</comment>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>script</name></name> == <name><name>fp</name>-&gt;<name>down</name>-&gt;<name>script</name></name> &amp;&amp;
        <name><name>fp</name>-&gt;<name>down</name>-&gt;<name>down</name></name> &amp;&amp; <name><name>fp</name>-&gt;<name>down</name>-&gt;<name>down</name>-&gt;<name>script</name></name> == <name><name>fp</name>-&gt;<name>script</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"recursion started inlining"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>first</name> <init>= <expr><call><name>LookupLoop</name><argument_list>(<argument><expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>, <argument><expr><name><name>tree</name>-&gt;<name>globalObj</name></name></expr></argument>,
                                     <argument><expr><name><name>tree</name>-&gt;<name>globalShape</name></name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>first</name></expr>)</condition><then>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>f</name> <init>= <expr><call><name>findNestedCompatiblePeer</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>f</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If there were no compatible peers, but there were peers at all, then it is probable that
         * an inner recursive function is type mismatching. Start a new recorder that must be
         * recursive.
         */</comment>
        <for>for (<init><expr><name>f</name> = <name>first</name></expr>;</init> <condition><expr><name>f</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>peer</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>f</name>-&gt;<name>recursion</name></name> == <name>Recursion_Detected</name></expr>)</condition><then> <block>{
                <comment type="block">/* Since this recorder is about to die, save its values. */</comment>
                <if>if <condition>(<expr>++<call><name><name>first</name>-&gt;<name>hits</name></name><argument_list>()</argument_list></call> &lt;= <name>HOTLOOP</name></expr>)</condition><then>
                    <return>return <expr><name>ARECORD_STOP</name></expr>;</return></then></if>
                <if>if <condition>(<expr><call><name>IsBlacklisted</name><argument_list>(<argument><expr>(<name>jsbytecode</name>*)<name><name>f</name>-&gt;<name>ip</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"inner recursive tree is blacklisted"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <decl_stmt><decl><type><name>JSContext</name>*</type> <name>_cx</name> <init>= <expr><name>cx</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>SlotList</name>*</type> <name>globalSlots</name> <init>= <expr><name><name>tree</name>-&gt;<name>globalSlots</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>AbortRecording</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"trying to compile inner recursive tree"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>_cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name> == <name><name>first</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RecordTree</name><argument_list>(<argument><expr><name>_cx</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>globalSlots</name></expr></argument>, <argument><expr><name>Record_EnterFrame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then> <else>else <if>if <condition>(<expr><name>f</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Make sure the shape of the global object still matches (this might
         * flush the JIT cache).
         */</comment>
        <decl_stmt><decl><type><name>JSObject</name>*</type> <name>globalObj</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name>-&gt;<name>getGlobal</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>globalShape</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SlotList</name>*</type> <name>globalSlots</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>CheckGlobalObjectShape</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>traceMonitor</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr>&amp;<name>globalShape</name></expr></argument>, <argument><expr>&amp;<name>globalSlots</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>ARECORD_ABORTED</name></expr>;</return></then></if>
        <return>return <expr><call><name>attemptTreeCall</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>inlineCallCount</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if></else></if>

   <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_LeaveFrame</name></name><parameter_list>()</parameter_list>
<block>{
    <macro><name>debug_only_stmt</name><argument_list>(
        <argument>if (cx-&gt;fp-&gt;fun)
            debug_only_printf(LC_TMTracer,
                              "LeaveFrame (back to %s), callDepth=%d\n",
                              js_AtomToPrintableString(cx, cx-&gt;fp-&gt;fun-&gt;atom),
                              callDepth);</argument>
        )</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>js_CodeSpec</name><index>[<expr><call><name>js_GetOpcode</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr></argument>,
              <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name>.<name>length</name> == <name>JSOP_CALL_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>callDepth</name>-- &lt;= 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"returned out of a loop we started tracing"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// LeaveFrame gets called after the interpreter popped the frame and</comment>
    <comment type="line">// stored rval, so cx-&gt;fp not cx-&gt;fp-&gt;down, and -1 not 0.</comment>
    <expr_stmt><expr><name>atoms</name> = <call><name>FrameAtomBase</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rval_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_PUSH</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_VOID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_POPV</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>rval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>rval_ins</name> <init>= <expr><call><name>box_jsval</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>rval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Store it in cx-&gt;fp-&gt;rval. NB: Tricky dependencies. cx-&gt;fp is the right</comment>
    <comment type="line">// frame because POPV appears only in global and eval code and we don't</comment>
    <comment type="line">// trace JSOP_EVAL or leaving the frame where tracing started.</comment>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>fp_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>cx_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSContext</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>rval_ins</name></expr></argument>, <argument><expr><name>fp_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSStackFrame</name></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ENTERWITH</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LEAVEWITH</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_RETURN</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/* A return from callDepth 0 terminates the current loop, except for recursion. */</comment>
    <if>if <condition>(<expr><name>callDepth</name> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>IsTraceableRecursion</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>tree</name>-&gt;<name>recursion</name></name> != <name>Recursion_Disallowed</name> &amp;&amp;
            <name><name>tree</name>-&gt;<name>script</name></name> == <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>upRecursion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>returnLoopExits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>endLoop</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>putActivationObjects</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we inlined this function call, make the return value available to the caller code. */</comment>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>rval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>(<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_CONSTRUCTING</name>) &amp;&amp; <call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>thisv</name></name> == <name><name>fp</name>-&gt;<name>argv</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rval_ins</name> = <call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>argv</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>rval_ins</name> = <call><name>get</name><argument_list>(<argument><expr>&amp;<name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>,
                      <argument><expr>"returning from %s\n"</expr></argument>,
                      <argument><expr><call><name>js_AtomToPrintableString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>atom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>clearCurrentFrameSlotsFromTracker</name><argument_list>(<argument><expr><name>nativeFrameTracker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GOTO</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/*
     * If we hit a break or a continue to an outer loop, end the loop and
     * generate an always-taken loop exit guard.  For other downward gotos
     * (like if/else) continue recording.
     */</comment>
    <decl_stmt><decl><type><name>jssrcnote</name>*</type> <name>sn</name> <init>= <expr><call><name>js_GetSrcNote</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>sn</name> &amp;&amp; (<call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_BREAK</name> || <call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>SRC_CONT2LABEL</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>AUDIT</name><argument_list>(<argument><expr><name>breakLoopExits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>endLoop</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_IFEQ</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>trackCfgMerges</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>ifop</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_IFNE</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>ifop</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>newArguments</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>callee_ins</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>global_ins</name> <init>= <expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>argc_ins</name> <init>= <expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>argv_ins</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name>
                     ? <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>,
                                 <argument><expr><call><name><name>lir</name>-&gt;<name>insImmWord</name></name><argument_list>(<argument><expr><call><name>nativespOffset</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                     : <call><name>INS_CONSTPTR</name><argument_list>(<argument><expr>(<name>void</name> *) 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArgsPrivateNative</name> *</type><name>apn</name> <init>= <expr><call><name><name>ArgsPrivateNative</name>::<name>create</name></name><argument_list>(<argument><expr><call><name>traceAlloc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>uintN</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name><name>apn</name>-&gt;<name>typemap</name></name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index> = <call><name>determineSlotType</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>apn</name></expr></argument>)</argument_list></call></expr>, <expr><name>argv_ins</name></expr>, <expr><name>callee_ins</name></expr>, <expr><name>argc_ins</name></expr>, <expr><name>global_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_Arguments_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>call_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>call_ins</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ARGUMENTS</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_OVERRIDE_ARGS</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"Can't trace |arguments| if |arguments| is assigned to"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>a_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>args_ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>callee_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>a_ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call> == <name>LIR_int</name></expr>)</condition><then> <block>{
        <comment type="line">// |arguments| is set to 0 by EnterFrame on this trace, so call to create it.</comment>
        <expr_stmt><expr><name>args_ins</name> = <call><name>newArguments</name><argument_list>(<argument><expr><name>callee_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// Generate LIR to create arguments only if it has not already been created.</comment>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>mem_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>br1</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>a_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>a_ins</name></expr></argument>, <argument><expr><name>mem_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>br2</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>label1</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>br1</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name> <init>= <expr><call><name>newArguments</name><argument_list>(<argument><expr><name>callee_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>call_ins</name></expr></argument>, <argument><expr><name>mem_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>label2</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>br2</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>args_ins</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>mem_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>args_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>, <argument><expr><name>args_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DUP</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DUP2</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SWAP</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>r</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>l_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>r_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr><name>l_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name>r_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_PICK</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>sp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>n</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>sp</name> - (<name>n</name>+1) &gt;= <call><name>StackBase</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>top</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr><name>sp</name> - (<name>n</name>+1)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>jsint</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>sp</name> - (<name>n</name>+1) + <name>i</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr><name>sp</name> - <name>n</name> + <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name><name>sp</name><index>[<expr>-1</expr>]</index></name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETCONST</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_BITOR</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_or</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_BITXOR</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_xor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_BITAND</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_and</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_EQ</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>equality</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NE</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>equality</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LT</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>relational</name><argument_list>(<argument><expr><name>LIR_flt</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LE</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>relational</name><argument_list>(<argument><expr><name>LIR_fle</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GT</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>relational</name><argument_list>(<argument><expr><name>LIR_fgt</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GE</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>relational</name><argument_list>(<argument><expr><name>LIR_fge</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LSH</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_lsh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_RSH</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_rsh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_URSH</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_ush</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ADD</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>r</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>add_imacros</name>.<name>obj_obj</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>add_imacros</name>.<name>obj_any</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>add_imacros</name>.<name>any_obj</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> || <call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>stringify</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>stringify</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>concat</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_ConcatStrings_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>concat</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name>concat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_fadd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SUB</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_fsub</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_MUL</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_fmul</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DIV</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_fdiv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_MOD</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>binary</name><argument_list>(<argument><expr><name>LIR_fmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NOT</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_or</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_feq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_feq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == <name>JSVAL_OBJECT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSString</name></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_BITNOT</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>unary</name><argument_list>(<argument><expr><name>LIR_not</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NEG</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>unary_imacros</name>.<name>sign</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>a</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If we're a promoted integer, we have to watch out for 0s since -0 is
         * a double. Only follow this path if we're not an integer that's 0 and
         * we're not a double that's zero.
         */</comment>
        <if>if <condition>(<expr>!<call><name><name>oracle</name>.<name>isInstructionUndemotable</name></name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>isPromoteInt</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &amp;&amp;
            (!<call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0) &amp;&amp;
            (!<call><name>JSVAL_IS_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || !<call><name>JSDOUBLE_IS_NEGZERO</name><argument_list>(<argument><expr>*<call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) &amp;&amp;
            -<call><name>asNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == (<name>int</name>)-<call><name>asNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>OVERFLOW_EXIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>a</name> = <call><name>guard_xov</name><argument_list>(<argument><expr><name>LIR_sub</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>a</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>a</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_subxov</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// make sure we don't lose a -0</comment>
            }</block></then></if>
            <expr_stmt><expr><name>a</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>a</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_fneg</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr>-0.0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name>js_NaN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_fneg</name></expr></argument>,
                          <argument><expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_StringToNumber_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_BOOLEAN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_fneg</name></expr></argument>, <argument><expr><call><name>i2f</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_POS</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>unary_imacros</name>.<name>sign</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name>js_NaN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_StringToNumber_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_BOOLEAN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name>i2f</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_PRIMTOP</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// Either this opcode does nothing or we couldn't have traced here, because</comment>
    <comment type="line">// we'd have thrown an exception -- so do nothing if we actually hit this.</comment>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_OBJTOP</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>getClassPrototype</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>ctor</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>proto_ins</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// ctor must be a function created via js_InitClass.</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSClass</name> *</type><name>clasp</name> <init>= <expr><call><name>FUN_CLASP</name><argument_list>(<argument><expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ctor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>clasp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>TraceMonitor</name> &amp;</type><name>localtm</name> <init>= <expr><call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>jsval</name></type> <name>pval</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>ctor</name>-&gt;<name>getProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>classPrototypeAtom</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>pval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr>"error getting prototype from constructor"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// ctor.prototype is a permanent data property, so this lookup cannot have</comment>
    <comment type="line">// deep-aborted.</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>localtm</name>.<name>recorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>, <decl><type ref="prev"/><name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>attrs</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>ok</name> = <call><name>JS_GetPropertyAttributes</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ctor</name></expr></argument>, <argument><expr><name>js_class_prototype_str</name></expr></argument>, <argument><expr>&amp;<name>attrs</name></expr></argument>, <argument><expr>&amp;<name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(~<name>attrs</name> &amp; (<name>JSPROP_READONLY</name> | <name>JSPROP_PERMANENT</name>)) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Since ctor was built by js_InitClass, we can assert (rather than check)</comment>
    <comment type="line">// that pval is usable.</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>proto</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>clasp</name> != &amp;<name>js_ArrayClass</name></expr></argument>, <argument><expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call>-&gt;<name><name>emptyScope</name>-&gt;<name>clasp</name></name> == <name>clasp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>proto_ins</name> = <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>getClassPrototype</name></name><parameter_list>(<param><decl><type><name>JSProtoKey</name></type> <name>key</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>proto_ins</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TraceMonitor</name> &amp;</type><name>localtm</name> <init>= <expr><call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>proto</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>js_GetClassPrototype</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>&amp;<name>proto</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr>"error in js_GetClassPrototype"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// This should not have reentered.</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>localtm</name>.<name>recorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/* Double-check that a native proto has a matching emptyScope. */</comment>
    <if>if <condition>(<expr><name>key</name> != <name>JSProto_Array</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>OBJ_IS_NATIVE</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>JSEmptyScope</name> *</type><name>emptyScope</name> <init>= <expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call>-&gt;<name>emptyScope</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>emptyScope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSCLASS_CACHED_PROTO_KEY</name><argument_list>(<argument><expr><name><name>emptyScope</name>-&gt;<name>clasp</name></name></expr></argument>)</argument_list></call> == <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>proto_ins</name> = <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IGNORE_NATIVE_CALL_COMPLETE_CALLBACK</name></cpp:macro> <cpp:value>((JSSpecializedNative*)1)</cpp:value></cpp:define>

<function><type><name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>newString</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>ctor</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>argv</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>rval</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>argc</name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_IF_XML</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>new_imacros</name>.<name>String</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>proto_ins</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>getClassPrototype</name><argument_list>(<argument><expr><name>ctor</name></expr></argument>, <argument><expr><name>proto_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>stringify</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>, <expr><name>proto_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_String_tn_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pendingSpecializedNative</name> = <name>IGNORE_NATIVE_CALL_COMPLETE_CALLBACK</name></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>newArray</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>ctor</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>argv</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>rval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name> *</type><name>proto_ins</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>getClassPrototype</name><argument_list>(<argument><expr><name>ctor</name></expr></argument>, <argument><expr><name>proto_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name> *</type><name>arr_ins</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>argc</name> == 0</expr>)</condition><then> <block>{
        <comment type="line">// arr_ins = js_NewEmptyArray(cx, Array.prototype)</comment>
        <decl_stmt><decl><type><name>LIns</name> *</type><name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>proto_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>arr_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_NewEmptyArray_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>arr_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>argc</name> == 1 &amp;&amp; <call><name>JSVAL_IS_NUMBER</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// arr_ins = js_NewEmptyArray(cx, Array.prototype, length)</comment>
        <decl_stmt><decl><type><name>LIns</name> *</type><name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>f2i</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><name>proto_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt> <comment type="line">// FIXME: is this 64-bit safe?</comment>
        <expr_stmt><expr><name>arr_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_NewEmptyArrayWithLength_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>arr_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// arr_ins = js_NewArrayWithSlots(cx, Array.prototype, argc)</comment>
        <decl_stmt><decl><type><name>LIns</name> *</type><name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>, <expr><name>proto_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>arr_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_NewArrayWithSlots_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>arr_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// arr-&gt;dslots[i] = box_jsval(vp[i]);  for i in 0..argc</comment>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>dslots_ins</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>uint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>argc</name> &amp;&amp; !<call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>LIns</name> *</type><name>elt_ins</name> <init>= <expr><call><name>box_jsval</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>stobj_set_dslot</name><argument_list>(<argument><expr><name>arr_ins</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>, <argument><expr><name>elt_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr><name>argc</name> &gt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>stobj_set_fslot</name><argument_list>(<argument><expr><name>arr_ins</name></expr></argument>, <argument><expr><name>JSSLOT_ARRAY_COUNT</name></expr></argument>, <argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if></else></if>

    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>rval</name></expr></argument>, <argument><expr><name>arr_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pendingSpecializedNative</name> = <name>IGNORE_NATIVE_CALL_COMPLETE_CALLBACK</name></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>propagateFailureToBuiltinStatus</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>ok_ins</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>status_ins</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Check the boolean return value (ok_ins) of a native JSNative,
     * JSFastNative, or JSPropertyOp hook for failure. On failure, set the
     * BUILTIN_ERROR bit of cx-&gt;builtinStatus.
     *
     * If the return value (ok_ins) is true, status' == status. Otherwise
     * status' = status | BUILTIN_ERROR. We calculate (rval&amp;1)^1, which is 1
     * if rval is JS_FALSE (error), and then shift that by 1, which is the log2
     * of BUILTIN_ERROR.
     */</comment>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr>((<name>JS_TRUE</name> &amp; 1) ^ 1) &lt;&lt; 1 == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr>((<name>JS_FALSE</name> &amp; 1) ^ 1) &lt;&lt; 1 == <name>BUILTIN_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>status_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_or</name></expr></argument>,
                           <argument><expr><name>status_ins</name></expr></argument>,
                           <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_lsh</name></expr></argument>,
                                      <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_xor</name></expr></argument>,
                                                 <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_and</name></expr></argument>, <argument><expr><name>ok_ins</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>status_ins</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr>(<name>int</name>) <call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>builtinStatus</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>emitNativePropertyOp</name></name><parameter_list>(<param><decl><type><name>JSScope</name>*</type> <name>scope</name></decl></param>, <param><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>,
                                    <param><decl><type><name>bool</name></type> <name>setflag</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>boxed_ins</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>setflag</name> ? !<call><name><name>sprop</name>-&gt;<name>hasSetterValue</name></name><argument_list>()</argument_list></call> : !<call><name><name>sprop</name>-&gt;<name>hasGetterValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>setflag</name> ? !<call><name><name>sprop</name>-&gt;<name>hasDefaultSetter</name></name><argument_list>()</argument_list></call> : !<call><name><name>sprop</name>-&gt;<name>hasDefaultGetterOrIsMethod</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// It is unsafe to pass the address of an object slot as the out parameter,</comment>
    <comment type="line">// because the getter or setter could end up resizing the object's dslots.</comment>
    <comment type="line">// Instead, use a word of stack and root it in nativeVp.</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>vp_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>vp_ins</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>nativeVp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>nativeVpLen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>setflag</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>boxed_ins</name></expr></argument>, <argument><expr><name>vp_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>CallInfo</name>*</type> <name>ci</name> <init>= <expr>new (<call><name>traceAlloc</name><argument_list>()</argument_list></call>) <call><name>CallInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_address</name></name> = <call><name>uintptr_t</name><argument_list>(<argument><expr><name>setflag</name> ? <call><name><name>sprop</name>-&gt;<name>setterOp</name></name><argument_list>()</argument_list></call> : <call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_typesig</name></name> = <name>ARGTYPE_I</name> &lt;&lt; (0*<name>ARGTYPE_SHIFT</name>) |
                   <name>ARGTYPE_P</name> &lt;&lt; (1*<name>ARGTYPE_SHIFT</name>) |
                   <name>ARGTYPE_P</name> &lt;&lt; (2*<name>ARGTYPE_SHIFT</name>) |
                   <name>ARGTYPE_P</name> &lt;&lt; (3*<name>ARGTYPE_SHIFT</name>) |
                   <name>ARGTYPE_P</name> &lt;&lt; (4*<name>ARGTYPE_SHIFT</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_isPure</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_storeAccSet</name></name> = <name>ACC_STORE_ANY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_abi</name></name> = <name>ABI_CDECL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_name</name></name> = "JSPropertyOp"</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>vp_ins</name></expr>, <expr><call><name>INS_CONSTVAL</name><argument_list>(<argument><expr><call><name>SPROP_USERID</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Cleanup. Immediately clear nativeVp before we might deep bail.</comment>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>nativeVp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>leaveDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Guard that the call succeeded and builtinStatus is still 0.</comment>
    <comment type="line">// If the native op succeeds but we deep-bail here, the result value is</comment>
    <comment type="line">// lost!  Therefore this can only be used for setters of shared properties.</comment>
    <comment type="line">// In that case we ignore the result value anyway.</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>status_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>,
                                    <argument><expr>(<name>int</name>) <call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>builtinStatus</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>propagateFailureToBuiltinStatus</name><argument_list>(<argument><expr><name>ok_ins</name></expr></argument>, <argument><expr><name>status_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>status_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STATUS_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Re-load the value--but this is currently unused, so commented out.</comment>
    <comment type="line">//boxed_ins = lir-&gt;insLoad(LIR_ldp, vp_ins, 0, ACC_OTHER);</comment>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>emitNativeCall</name></name><parameter_list>(<param><decl><type><name>JSSpecializedNative</name>*</type> <name>sn</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name></decl></param>, <param><decl><type><name>bool</name></type> <name>rooted</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bool</name></type> <name>constructing</name> <init>= <expr>!!(<name><name>sn</name>-&gt;<name>flags</name></name> &amp; <name>JSTN_CONSTRUCTOR</name>)</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JSTN_ERRTYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> == <name>FAIL_STATUS</name></expr>)</condition><then> <block>{
        <comment type="line">// This needs to capture the pre-call state of the stack. So do not set</comment>
        <comment type="line">// pendingSpecializedNative before taking this snapshot.</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>pendingSpecializedNative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Take snapshot for DeepBail and store it in cx-&gt;bailExit.</comment>
        <comment type="line">// If we are calling a slow native, add information to the side exit</comment>
        <comment type="line">// for SynthesizeSlowNativeFrame.</comment>
        <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSObject</name>*</type> <name>funobj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><call><name>stackval</name><argument_list>(<argument><expr>0 - (2 + <name>argc</name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>FUN_SLOW_NATIVE</name><argument_list>(<argument><expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>funobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>exit</name>-&gt;<name>setNativeCallee</name></name><argument_list>(<argument><expr><name>funobj</name></expr></argument>, <argument><expr><name>constructing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>gcthings</name>.<name>addUnique</name></name><argument_list>(<argument><expr><call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>funobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>res_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr><name><name>sn</name>-&gt;<name>builtin</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Immediately unroot the vp as soon we return since we might deep bail next.</comment>
    <if>if <condition>(<expr><name>rooted</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>nativeVp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>rval_ins</name> = <name>res_ins</name></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><call><name>JSTN_ERRTYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
      <case>case <expr><name>FAIL_NULL</name></expr>:
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>res_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>FAIL_NEG</name></expr>:
        <expr_stmt><expr><name>res_ins</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><name>res_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_flt</name></expr></argument>, <argument><expr><name>res_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>FAIL_VOID</name></expr>:
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>res_ins</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>JSVAL_VOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>FAIL_COOKIE</name></expr>:
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>res_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_ERROR_COOKIE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:<empty_stmt>;</empty_stmt>
    </default>}</block></switch>

    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<call><name>stackval</name><argument_list>(<argument><expr>0 - (2 + <name>argc</name>)</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>res_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The return value will be processed by NativeCallComplete since
     * we have to know the actual return value type for calls that return
     * jsval (like Array_p_pop).
     */</comment>
    <expr_stmt><expr><name>pendingSpecializedNative</name> = <name>sn</name></expr>;</expr_stmt>

    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Check whether we have a specialized implementation for this native
 * invocation.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>callSpecializedNative</name></name><parameter_list>(<param><decl><type><name>JSNativeTraceInfo</name> *</type><name>trcinfo</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>,
                                     <param><decl><type><name>bool</name></type> <name>constructing</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name> <init>= <expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>fval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>0 - (2 + <name>argc</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>tval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>0 - (1 + <name>argc</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>this_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>tval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[<expr><name><name>nanojit</name>::<name>MAXARGS</name></name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSpecializedNative</name> *</type><name>sn</name> <init>= <expr><name><name>trcinfo</name>-&gt;<name>specializations</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{
        <if>if <condition>(<expr>((<name><name>sn</name>-&gt;<name>flags</name></name> &amp; <name>JSTN_CONSTRUCTOR</name>) != 0) != <name>constructing</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>

        <decl_stmt><decl><type><name>uintN</name></type> <name>knownargc</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>sn</name>-&gt;<name>argtypes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>argc</name> != <name>knownargc</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>

        <decl_stmt><decl><type><name>intN</name></type> <name>prefixc</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>sn</name>-&gt;<name>prefix</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>prefixc</name> &lt;= 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>**</type> <name>argp</name> <init>= <expr>&amp;<name><name>args</name><index>[<expr><name>argc</name> + <name>prefixc</name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>argtype</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0xCD</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for (<init><expr><name>i</name> = <name>prefixc</name></expr>;</init> <condition><expr><name>i</name>--</expr>;</condition> <incr/>) <block>{
            <expr_stmt><expr><name>argtype</name> = <name><name>sn</name>-&gt;<name>prefix</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>argtype</name> == 'C'</expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>argp</name> = <name>cx_ins</name></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'T'</expr>)</condition><then> <block>{ <comment type="block">/* this, as an object */</comment>
                <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>tval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>next_specialization</name>;</goto></then></if>
                <expr_stmt><expr>*<name>argp</name> = <name>this_ins</name></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'S'</expr>)</condition><then> <block>{ <comment type="block">/* this, as a string */</comment>
                <if>if <condition>(<expr>!<call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>tval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>next_specialization</name>;</goto></then></if>
                <expr_stmt><expr>*<name>argp</name> = <name>this_ins</name></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'f'</expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>argp</name> = <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'p'</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>getClassPrototype</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>*<name>argp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'R'</expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>argp</name> = <call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'P'</expr>)</condition><then> <block>{
                <comment type="line">// FIXME: Set pc to imacpc when recording JSOP_CALL inside the</comment>
                <comment type="line">//        JSOP_GETELEM imacro (bug 476559).</comment>
                <if>if <condition>(<expr>(*<name>pc</name> == <name>JSOP_CALL</name>) &amp;&amp;
                    <name><name>fp</name>-&gt;<name>imacpc</name></name> &amp;&amp; *<name><name>fp</name>-&gt;<name>imacpc</name></name> == <name>JSOP_GETELEM</name></expr>)</condition><then>
                    <expr_stmt><expr>*<name>argp</name> = <call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>imacpc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr>*<name>argp</name> = <call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'D'</expr>)</condition><then> <block>{ <comment type="block">/* this, as a number */</comment>
                <if>if <condition>(<expr>!<call><name>isNumber</name><argument_list>(<argument><expr><name>tval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>next_specialization</name>;</goto></then></if>
                <expr_stmt><expr>*<name>argp</name> = <name>this_ins</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"unknown prefix arg type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
            <expr_stmt><expr><name>argp</name>--</expr>;</expr_stmt>
        }</block></for>

        <for>for (<init><expr><name>i</name> = <name>knownargc</name></expr>;</init> <condition><expr><name>i</name>--</expr>;</condition> <incr/>) <block>{
            <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>arg</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>0 - (<name>i</name> + 1)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr>*<name>argp</name> = <call><name>get</name><argument_list>(<argument><expr>&amp;<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>argtype</name> = <name><name>sn</name>-&gt;<name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>argtype</name> == 'd' || <name>argtype</name> == 'i'</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>isNumber</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>next_specialization</name>;</goto></then></if>
                <if>if <condition>(<expr><name>argtype</name> == 'i'</expr>)</condition><then>
                    <expr_stmt><expr>*<name>argp</name> = <call><name>f2i</name><argument_list>(<argument><expr>*<name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'o'</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>next_specialization</name>;</goto></then></if>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 's'</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>next_specialization</name>;</goto></then></if>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'r'</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>VALUE_IS_REGEXP</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>next_specialization</name>;</goto></then></if>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'f'</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>VALUE_IS_FUNCTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>next_specialization</name>;</goto></then></if>
            }</block></then> <else>else <if>if <condition>(<expr><name>argtype</name> == 'v'</expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>argp</name> = <call><name>box_jsval</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>*<name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <goto>goto <name>next_specialization</name>;</goto>
            }</block></else></if></else></if></else></if></else></if></else></if></else></if>
            <expr_stmt><expr><name>argp</name>--</expr>;</expr_stmt>
        }</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> != (<name>LIns</name> *)0xcdcdcdcd</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><call><name>emitNativeCall</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>

<label><name>next_specialization</name>:</label><empty_stmt>;</empty_stmt>
    }</block> while <condition>(<expr>(<name>sn</name>++)-&gt;<name>flags</name> &amp; <name>JSTN_MORE</name></expr>)</condition>;</do>

    <return>return <expr><name>RECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>callNative</name></name><parameter_list>(<param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>mode</name> == <name>JSOP_CALL</name> || <name>mode</name> == <name>JSOP_NEW</name> || <name>mode</name> == <name>JSOP_APPLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name> <init>= <expr>&amp;<call><name>stackval</name><argument_list>(<argument><expr>0 - (2 + <name>argc</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>funobj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name> <init>= <expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>funobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFastNative</name></type> <name>native</name> <init>= <expr>(<name>JSFastNative</name>)<name><name>fun</name>-&gt;<name>u</name>.<name>n</name>.<name>native</name></name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>argc</name></expr>)</condition> <block>{
      <case>case <expr>1</expr>:
        <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp;
            (<name>native</name> == <name>js_math_ceil</name> || <name>native</name> == <name>js_math_floor</name> || <name>native</name> == <name>js_math_round</name>)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>a</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>isPromote</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name><name>vp</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pendingSpecializedNative</name> = <name>IGNORE_NATIVE_CALL_COMPLETE_CALLBACK</name></expr>;</expr_stmt>
                <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr>2</expr>:
        <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>isNumber</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp;
            (<name>native</name> == <name>js_math_min</name> || <name>native</name> == <name>js_math_max</name>)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>a</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>b</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>isPromote</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>isPromote</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>a</name> = <call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>b</name> = <call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name><name>vp</name><index>[<expr>0</expr>]</index></name></expr></argument>,
                    <argument><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>,
                              <argument><expr><call><name><name>lir</name>-&gt;<name>ins_choose</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr>(<name>native</name> == <name>js_math_min</name>)
                                                        ? <name>LIR_lt</name>
                                                        : <name>LIR_gt</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><call><name><name>avmplus</name>::<name>AvmCore</name>::<name>use_cmov</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pendingSpecializedNative</name> = <name>IGNORE_NATIVE_CALL_COMPLETE_CALLBACK</name></expr>;</expr_stmt>
                <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
        <break>break;</break>
    </case>}</block></switch>

    <if>if <condition>(<expr><name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_TRCINFO</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSNativeTraceInfo</name> *</type><name>trcinfo</name> <init>= <expr><call><name>FUN_TRCINFO</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>trcinfo</name> &amp;&amp; (<name>JSFastNative</name>)<name><name>fun</name>-&gt;<name>u</name>.<name>n</name>.<name>native</name></name> == <name><name>trcinfo</name>-&gt;<name>native</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Try to call a type specialized version of the native. */</comment>
        <if>if <condition>(<expr><name><name>trcinfo</name>-&gt;<name>specializations</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>RecordingStatus</name></type> <name>status</name> <init>= <expr><call><name>callSpecializedNative</name><argument_list>(<argument><expr><name>trcinfo</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>mode</name> == <name>JSOP_NEW</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>status</name> != <name>RECORD_STOP</name></expr>)</condition><then>
                <return>return <expr><name>status</name></expr>;</return></then></if>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>native</name> == <name>js_fun_apply</name> || <name>native</name> == <name>js_fun_call</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"trying to call native apply or call"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name><name>fun</name>-&gt;<name>u</name>.<name>n</name>.<name>extra</name></name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"trying to trace slow native with fun-&gt;u.n.extra &gt; 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// Allocate the vp vector and emit code to root it.</comment>
    <decl_stmt><decl><type><name>uintN</name></type> <name>vplen</name> <init>= <expr>2 + <call><name>JS_MAX</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><call><name>unsigned</name><argument_list>(<argument><expr><call><name>FUN_MINARGS</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!(<name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_FAST_NATIVE</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>vplen</name>++</expr>;</expr_stmt></then></if> <comment type="line">// slow native return value slot</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>invokevp_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><name>vplen</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// vp[0] is the callee.</comment>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>INS_CONSTVAL</name><argument_list>(<argument><expr><call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>funobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>invokevp_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Calculate |this|.</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>this_ins</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>mode</name> == <name>JSOP_NEW</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSClass</name>*</type> <name>clasp</name> <init>= <expr><name><name>fun</name>-&gt;<name>u</name>.<name>n</name>.<name>clasp</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>clasp</name> != &amp;<name>js_SlowArrayClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>clasp</name></expr>)</condition><then>
            <expr_stmt><expr><name>clasp</name> = &amp;<name>js_ObjectClass</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>((<name>jsuword</name>) <name>clasp</name> &amp; 3) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Abort on |new Function|. js_NewInstance would allocate a regular-</comment>
        <comment type="line">// sized JSObject, not a Function-sized one. (The Function ctor would</comment>
        <comment type="line">// deep-bail anyway but let's not go there.)</comment>
        <if>if <condition>(<expr><name>clasp</name> == &amp;<name>js_FunctionClass</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"new Function"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><name><name>clasp</name>-&gt;<name>getObjectOps</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"new with non-native ops"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> = <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>funobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>1</expr>]</index></name> = <call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>clasp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>2</expr>]</index></name> = <name>cx_ins</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>newobj_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_NewInstance_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>newobj_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>this_ins</name> = <name>newobj_ins</name></expr>;</expr_stmt> <comment type="block">/* boxing an object is a no-op */</comment>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSFUN_BOUND_METHOD_TEST</name><argument_list>(<argument><expr><name><name>fun</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* |funobj| was rooted above already. */</comment>
        <expr_stmt><expr><name>this_ins</name> = <call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><call><name><name>funobj</name>-&gt;<name>getParent</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>this_ins</name> = <call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>vp</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * For fast natives, 'null' or primitives are fine as as 'this' value.
         * For slow natives we have to ensure the object is substituted for the
         * appropriate global object or boxed object value. JSOP_NEW allocates its
         * own object so it's guaranteed to have a valid 'this' value.
         */</comment>
        <if>if <condition>(<expr>!(<name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_FAST_NATIVE</name>)</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSObject</name>*</type> <name>thisObj</name> <init>= <expr><call><name>js_ComputeThis</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name> + 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>thisObj</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr>"error in js_ComputeGlobalThis"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>this_ins</name> = <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>thisObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr>!<call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"slow native(primitive, args)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr><call><name>guardClass</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>this_ins</name></expr></argument>, <argument><expr>&amp;<name>js_WithClass</name></expr></argument>,
                               <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't trace slow native invocation on With object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <expr_stmt><expr><name>this_ins</name> = <call><name><name>lir</name>-&gt;<name>ins_choose</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><call><name>stobj_get_parent</name><argument_list>(<argument><expr><name>this_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>this_ins</name></expr></argument>, <argument><expr><call><name><name>avmplus</name>::<name>AvmCore</name>::<name>use_cmov</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></then></if>
        <expr_stmt><expr><name>this_ins</name> = <call><name>box_jsval</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>this_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>this_ins</name></expr></argument>, <argument><expr><name>invokevp_ins</name></expr></argument>, <argument><expr>1 * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Populate argv.</comment>
    <for>for (<init><decl><type><name>uintN</name></type> <name>n</name> <init>= <expr>2</expr></init></decl>;</init> <condition><expr><name>n</name> &lt; 2 + <name>argc</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>i</name> <init>= <expr><call><name>box_jsval</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>vp</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>invokevp_ins</name></expr></argument>, <argument><expr><name>n</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// For a very long argument list we might run out of LIR space, so</comment>
        <comment type="line">// check inside the loop.</comment>
        <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"out of memory in argument list"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>

    <comment type="line">// Populate extra slots, including the return value slot for a slow native.</comment>
    <if>if <condition>(<expr>2 + <name>argc</name> &lt; <name>vplen</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>undef_ins</name> <init>= <expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_VOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>uintN</name></type> <name>n</name> <init>= <expr>2 + <name>argc</name></expr></init></decl>;</init> <condition><expr><name>n</name> &lt; <name>vplen</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>undef_ins</name></expr></argument>, <argument><expr><name>invokevp_ins</name></expr></argument>, <argument><expr><name>n</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"out of memory in extra slots"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>
    }</block></then></if>

    <comment type="line">// Set up arguments for the JSNative or JSFastNative.</comment>
    <decl_stmt><decl><type><name>uint32</name></type> <name>typesig</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_FAST_NATIVE</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>mode</name> == <name>JSOP_NEW</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"untraceable fast native constructor"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>native_rval_ins</name> = <name>invokevp_ins</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> = <name>invokevp_ins</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>1</expr>]</index></name> = <call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>2</expr>]</index></name> = <name>cx_ins</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>typesig</name> = <name>ARGTYPE_I</name> &lt;&lt; (0*<name>ARGTYPE_SHIFT</name>) |
                  <name>ARGTYPE_P</name> &lt;&lt; (1*<name>ARGTYPE_SHIFT</name>) |
                  <name>ARGTYPE_I</name> &lt;&lt; (2*<name>ARGTYPE_SHIFT</name>) |
                  <name>ARGTYPE_P</name> &lt;&lt; (3*<name>ARGTYPE_SHIFT</name>)</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>int32_t</name></type> <name>offset</name> <init>= <expr>(<name>vplen</name> - 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>native_rval_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>invokevp_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> = <name>native_rval_ins</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>1</expr>]</index></name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>invokevp_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr>2 * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>2</expr>]</index></name> = <call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>3</expr>]</index></name> = <name>this_ins</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>4</expr>]</index></name> = <name>cx_ins</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>typesig</name> = <name>ARGTYPE_I</name> &lt;&lt; (0*<name>ARGTYPE_SHIFT</name>) |
                  <name>ARGTYPE_P</name> &lt;&lt; (1*<name>ARGTYPE_SHIFT</name>) |
                  <name>ARGTYPE_P</name> &lt;&lt; (2*<name>ARGTYPE_SHIFT</name>) |
                  <name>ARGTYPE_I</name> &lt;&lt; (3*<name>ARGTYPE_SHIFT</name>) |
                  <name>ARGTYPE_P</name> &lt;&lt; (4*<name>ARGTYPE_SHIFT</name>) |
                  <name>ARGTYPE_P</name> &lt;&lt; (5*<name>ARGTYPE_SHIFT</name>)</expr>;</expr_stmt>
    }</block></else></if>

    <comment type="line">// Generate CallInfo and a JSSpecializedNative structure on the fly.</comment>
    <comment type="line">// Do not use JSTN_UNBOX_AFTER for mode JSOP_NEW because</comment>
    <comment type="line">// record_NativeCallComplete unboxes the result specially.</comment>

    <decl_stmt><decl><type><name>CallInfo</name>*</type> <name>ci</name> <init>= <expr>new (<call><name>traceAlloc</name><argument_list>()</argument_list></call>) <call><name>CallInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_address</name></name> = <call><name>uintptr_t</name><argument_list>(<argument><expr><name><name>fun</name>-&gt;<name>u</name>.<name>n</name>.<name>native</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_isPure</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_storeAccSet</name></name> = <name>ACC_STORE_ANY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_abi</name></name> = <name>ABI_CDECL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_typesig</name></name> = <name>typesig</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>_name</name></name> = <call><name>JS_GetFunctionName</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Generate a JSSpecializedNative structure on the fly.</comment>
    <expr_stmt><expr><name><name>generatedSpecializedNative</name>.<name>builtin</name></name> = <name>ci</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>generatedSpecializedNative</name>.<name>flags</name></name> = <name>FAIL_STATUS</name> | ((<name>mode</name> == <name>JSOP_NEW</name>)
                                                        ? <name>JSTN_CONSTRUCTOR</name>
                                                        : <name>JSTN_UNBOX_AFTER</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>generatedSpecializedNative</name>.<name>prefix</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>generatedSpecializedNative</name>.<name>argtypes</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <comment type="line">// We only have to ensure that the values we wrote into the stack buffer</comment>
    <comment type="line">// are rooted if we actually make it to the call, so only set nativeVp and</comment>
    <comment type="line">// nativeVpLen immediately before emitting the call code. This way we avoid</comment>
    <comment type="line">// leaving trace with a bogus nativeVp because we fall off trace while unboxing</comment>
    <comment type="line">// values into the stack buffer.</comment>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name>vplen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>nativeVpLen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>invokevp_ins</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>nativeVp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// argc is the original argc here. It is used to calculate where to place</comment>
    <comment type="line">// the return value.</comment>
    <return>return <expr><call><name>emitNativeCall</name><argument_list>(<argument><expr>&amp;<name>generatedSpecializedNative</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>functionCall</name></name><parameter_list>(<param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>fval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>0 - (2 + <name>argc</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>&amp;<name>fval</name> &gt;= <call><name>StackBase</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>VALUE_IS_FUNCTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"callee is not a function"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>tval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>0 - (1 + <name>argc</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If callee is not constant, it's a shapeless call and we have to guard
     * explicitly that we will get this callee again at runtime.
     */</comment>
    <if>if <condition>(<expr>!<call><name>get</name><argument_list>(<argument><expr>&amp;<name>fval</name></expr></argument>)</argument_list></call>-&gt;<call><name>isconstp</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>guardCallee</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * Require that the callee be a function object, to avoid guarding on its
     * class here. We know if the callee and this were pushed by JSOP_CALLNAME
     * or JSOP_CALLPROP that callee is a *particular* function, since these hit
     * the property cache and guard on the object (this) in which the callee
     * was found. So it's sufficient to test here that the particular function
     * is interpreted, not guard on that condition.
     *
     * Bytecode sequences that push shapeless callees must guard on the callee
     * class being Function and the function being interpreted.
     */</comment>
    <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name> <init>= <expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>mode</name> == <name>JSOP_NEW</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>fval</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr>&amp;<name>js_ObjectClass</name></expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>tv_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_NewInstance_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>tv_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>tval</name></expr></argument>, <argument><expr><name>tv_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><call><name>interpretedFunctionCall</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>fun</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>mode</name> == <name>JSOP_NEW</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>FUN_SLOW_NATIVE</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSNative</name></type> <name>native</name> <init>= <expr><name><name>fun</name>-&gt;<name>u</name>.<name>n</name>.<name>native</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsval</name>*</type> <name>argv</name> <init>= <expr>&amp;<name>tval</name> + 1</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>native</name> == <name>js_Array</name></expr>)</condition><then>
            <return>return <expr><call><name>newArray</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr>&amp;<name>fval</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><name>native</name> == <name>js_String</name> &amp;&amp; <name>argc</name> == 1</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>mode</name> == <name>JSOP_NEW</name></expr>)</condition><then>
                <return>return <expr><call><name>newString</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr>&amp;<name>fval</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>RETURN_IF_XML</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>call_imacros</name>.<name>String</name></name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>fval</name></expr></argument>, <argument><expr><call><name>stringify</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pendingSpecializedNative</name> = <name>IGNORE_NATIVE_CALL_COMPLETE_CALLBACK</name></expr>;</expr_stmt>
            <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><call><name>callNative</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NEW</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>argc</name> <init>= <expr><call><name>GET_ARGC</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>assertValidStackDepth</name></name><argument_list>(<argument><expr><name>argc</name> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>functionCall</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>JSOP_NEW</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DELNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DELPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DELELEM</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TYPEOF</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>r</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>type</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>type</name> = <call><name>INS_ATOM</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>typeAtoms</name><index>[<expr><name>JSTYPE_STRING</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>type</name> = <call><name>INS_ATOM</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>typeAtoms</name><index>[<expr><name>JSTYPE_NUMBER</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>VALUE_IS_FUNCTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>type</name> = <call><name>INS_ATOM</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>typeAtoms</name><index>[<expr><name>JSTYPE_FUNCTION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// We specialize identically for boolean and undefined. We must not have a hole here.</comment>
            <comment type="line">// Pass the unboxed type here, since TypeOfBoolean knows how to handle it.</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>r</name> == <name>JSVAL_TRUE</name> || <name>r</name> == <name>JSVAL_FALSE</name> || <name>r</name> == <name>JSVAL_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>type</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_TypeOfBoolean_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_TAG</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> == <name>JSVAL_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>type</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_TypeOfObject_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if></else></if></else></if>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_VOID</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name>INS_VOID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INCNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>incName</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INCPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>incProp</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INCELEM</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>incElem</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DECNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>incName</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DECPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>incProp</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DECELEM</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>incElem</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>incName</name></name><parameter_list>(<param><decl><type><name>jsint</name></type> <name>incr</name></decl></param>, <param><decl><type><name>bool</name></type> <name>pre</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_after</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameResult</name></type> <name>nr</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>name</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name> <init>= <expr><name><name>nr</name>.<name>tracked</name></name> ? *<name>vp</name> : <name><name>nr</name>.<name>v</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>incHelper</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>v_after</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_result</name> <init>= <expr><name>pre</name> ? <name>v_after</name> : <name>v_ins</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>nr</name>.<name>tracked</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>v_after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>v_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>nr</name>.<name>obj</name></name></expr></argument>)</argument_list></call> != &amp;<name>js_CallClass</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"incName on unsupported object class"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>setCallProp</name><argument_list>(<argument><expr><name><name>nr</name>.<name>obj</name></name></expr></argument>, <argument><expr><name><name>nr</name>.<name>obj_ins</name></name></expr></argument>, <argument><expr><name><name>nr</name>.<name>sprop</name></name></expr></argument>, <argument><expr><name>v_after</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>v_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NAMEINC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>incName</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_PROPINC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>incProp</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// XXX consolidate with record_JSOP_GETELEM code...</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ELEMINC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>incElem</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NAMEDEC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>incName</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_PROPDEC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>incProp</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ELEMDEC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>incElem</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>getProp</name><argument_list>(<argument><expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"primitive this for SETPROP"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>obj</name>-&gt;<name>map</name>-&gt;<name>ops</name>-&gt;<name>setProperty</name></name> != <name>js_SetProperty</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"non-native JSObjectOps::setProperty"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="block">/* Emit a specialized, inlined copy of js_NativeSet. */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>nativeSet</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl></param>,
                         <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSScope</name>*</type> <name>scope</name> <init>= <expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name> <init>= <expr><name><name>sprop</name>-&gt;<name>slot</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We do not trace assignment to properties that have both a nonstub setter
     * and a slot, for several reasons.
     *
     * First, that would require sampling rt-&gt;propertyRemovals before and after
     * (see js_NativeSet), and even more code to handle the case where the two
     * samples differ. A mere guard is not enough, because you can't just bail
     * off trace in the middle of a property assignment without storing the
     * value and making the stack right.
     *
     * If obj is the global object, there are two additional problems. We would
     * have to emit still more code to store the result in the object (not the
     * native global frame) if the setter returned successfully after
     * deep-bailing.  And we would have to cope if the run-time type of the
     * setter's return value differed from the record-time type of v, in which
     * case unboxing would fail and, having called a native setter, we could
     * not just retry the instruction in the interpreter.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>sprop</name>-&gt;<name>hasDefaultSetter</name></name><argument_list>()</argument_list></call> || <name>slot</name> == <name>SPROP_INVALID_SLOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Box the value to be stored, if necessary.</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>boxed_ins</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>sprop</name>-&gt;<name>hasDefaultSetter</name></name><argument_list>()</argument_list></call> || (<name>slot</name> != <name>SPROP_INVALID_SLOT</name> &amp;&amp; <name>obj</name> != <name>globalObj</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>boxed_ins</name> = <call><name>box_jsval</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// Call the setter, if any.</comment>
    <if>if <condition>(<expr>!<call><name><name>sprop</name>-&gt;<name>hasDefaultSetter</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>emitNativePropertyOp</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>sprop</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr><name>boxed_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// Store the value, if this property has a slot.</comment>
    <if>if <condition>(<expr><name>slot</name> != <name>SPROP_INVALID_SLOT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>SPROP_HAS_VALID_SLOT</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>sprop</name>-&gt;<name>hasSlot</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>obj</name> == <name>globalObj</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>lazilyImportGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"lazy import of global slot failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<call><name><name>obj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>dslots_ins</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>stobj_set_slot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>, <argument><expr><name>boxed_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>MethodWriteBarrier</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>funobj</name></decl></param>)</parameter_list>
<block>{
    <function_decl><type><name>AutoValueRooter</name></type> <name>tvr</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>funobj</name></type></decl></param>)</parameter_list>;</function_decl>

    <return>return <expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<call><name>methodWriteBarrier</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>sprop</name></expr></argument>, <argument><expr><call><name><name>tvr</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>static</argument>, <argument>BOOL_FAIL</argument>, <argument>MethodWriteBarrier</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>SCOPEPROP</argument>, <argument>OBJECT</argument>,
                     <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>setProp</name></name><parameter_list>(<param><decl><type><name>jsval</name> &amp;</type><name>l</name></decl></param>, <param><decl><type><name>PropertyCacheEntry</name>*</type> <name>entry</name></decl></param>, <param><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl></param>,
                       <param><decl><type><name>jsval</name> &amp;</type><name>v</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>v_ins</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>entry</name> == <name>JS_NO_PROP_CACHE_FILL</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't trace uncacheable property set"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name><name>entry</name>-&gt;<name>vcapTag</name></name><argument_list>()</argument_list></call> &gt;= 1</expr></argument>, <argument><expr>!<call><name><name>sprop</name>-&gt;<name>hasSlot</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>sprop</name>-&gt;<name>hasDefaultSetter</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>sprop</name>-&gt;<name>slot</name></name> != <name>SPROP_INVALID_SLOT</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't trace set of property with setter and slot"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>hasSetterValue</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't trace JavaScript function setter"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// These two cases are errors and can't be traced.</comment>
    <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>hasGetterValue</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't assign to property with script getter but no setter"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>!<call><name><name>sprop</name>-&gt;<name>writable</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't assign to readonly property"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScope</name>*</type> <name>scope</name> <init>= <expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name><name>entry</name>-&gt;<name>directHit</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>scope</name>-&gt;<name>hasProperty</name></name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Fast path for CallClass. This is about 20% faster than the general case.</comment>
    <expr_stmt><expr><name>v_ins</name> = <call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> == &amp;<name>js_CallClass</name></expr>)</condition><then>
        <return>return <expr><call><name>setCallProp</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>sprop</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="line">// Find obj2. If entry-&gt;adding(), the TAG bits are all 0.</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj2</name> <init>= <expr><name>obj</name></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>jsuword</name></type> <name>i</name> <init>= <expr><call><name><name>entry</name>-&gt;<name>scopeIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
        <expr_stmt><expr><name>obj2</name> = <call><name><name>obj2</name>-&gt;<name>getParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
    <for>for (<init><decl><type><name>jsuword</name></type> <name>j</name> <init>= <expr><call><name><name>entry</name>-&gt;<name>protoIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>j</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>)
        <expr_stmt><expr><name>obj2</name> = <call><name><name>obj2</name>-&gt;<name>getProto</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><name>scope</name> = <call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name><name>entry</name>-&gt;<name>adding</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>obj2</name> == <name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Guard before anything else.</comment>
    <decl_stmt><decl><type><name>PCVal</name></type> <name>pcval</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>guardPropertyCacheHit</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pcval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>scope</name>-&gt;<name>object</name></name> == <name>obj2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>scope</name>-&gt;<name>hasProperty</name></name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>obj2</name> != <name>obj</name></expr></argument>, <argument><expr>!<call><name><name>sprop</name>-&gt;<name>hasSlot</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Setting a function-valued property might need to rebrand the object, so
     * we emit a call to the method write barrier. There's no need to guard on
     * this, because functions have distinct trace-type from other values and
     * branded-ness is implied by the shape, which we've already guarded on.
     */</comment>
    <if>if <condition>(<expr><call><name><name>scope</name>-&gt;<name>brandedOrHasMethodBarrier</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name>VALUE_IS_FUNCTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>entry</name>-&gt;<name>directHit</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>obj</name> == <name>globalObj</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't trace function-valued property set in branded global scope"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>v_ins</name></expr>, <expr><call><name>INS_CONSTSPROP</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>MethodWriteBarrier_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>ok_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leaveDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Add a property to the object if necessary.</comment>
    <if>if <condition>(<expr><call><name><name>entry</name>-&gt;<name>adding</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>sprop</name>-&gt;<name>hasSlot</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>obj</name> == <name>globalObj</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"adding a property to the global object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>INS_CONSTSPROP</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_AddProperty_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>ok_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><call><name>nativeSet</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>sprop</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>setCallProp</name></name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>callobj</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>callobj_ins</name></decl></param>, <param><decl><type><name>JSScopeProperty</name> *</type><name>sprop</name></decl></param>,
                           <param><decl><type><name>LIns</name> *</type><name>v_ins</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Set variables in on-trace-stack call objects by updating the tracker.</comment>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><call><name>frameIfInRange</name><argument_list>(<argument><expr><name>callobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>fp</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>setterOp</name></name><argument_list>()</argument_list></call> == <name>SetCallArg</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>sprop</name>-&gt;<name>hasShortID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>uintN</name></type> <name>slot</name> <init>= <expr><call><name>uint16</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>shortid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jsval</name> *</type><name>vp2</name> <init>= <expr>&amp;<name><name>fp</name>-&gt;<name>argv</name><index>[<expr><name>slot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>vp2</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>setterOp</name></name><argument_list>()</argument_list></call> == <name>SetCallVar</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>sprop</name>-&gt;<name>hasShortID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>uintN</name></type> <name>slot</name> <init>= <expr><call><name>uint16</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>shortid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jsval</name> *</type><name>vp2</name> <init>= <expr>&amp;<name><name>fp</name>-&gt;<name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>vp2</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't trace special CallClass setter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name><name>callobj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// Because the parent guard in guardCallee ensures this Call object</comment>
        <comment type="line">// will be the same object now and on trace, and because once a Call</comment>
        <comment type="line">// object loses its frame it never regains one, on trace we will also</comment>
        <comment type="line">// have a null private in the Call object. So all we need to do is</comment>
        <comment type="line">// write the value to the Call object's slot.</comment>
        <decl_stmt><decl><type><name>int32</name></type> <name>dslot_index</name> <init>= <expr><call><name>uint16</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>shortid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>setterOp</name></name><argument_list>()</argument_list></call> == <name>SetCallArg</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>dslot_index</name> &lt; <call><name><name>ArgClosureTraits</name>::<name>slot_count</name></name><argument_list>(<argument><expr><name>callobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dslot_index</name> += <call><name><name>ArgClosureTraits</name>::<name>slot_offset</name></name><argument_list>(<argument><expr><name>callobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>setterOp</name></name><argument_list>()</argument_list></call> == <name>SetCallVar</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>dslot_index</name> &lt; <call><name><name>VarClosureTraits</name>::<name>slot_count</name></name><argument_list>(<argument><expr><name>callobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dslot_index</name> += <call><name><name>VarClosureTraits</name>::<name>slot_offset</name></name><argument_list>(<argument><expr><name>callobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't trace special CallClass setter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>

        <comment type="line">// Now assert that the shortid get we did above was ok. Have to do it</comment>
        <comment type="line">// after the RETURN_STOP above, since in that case we may in fact not</comment>
        <comment type="line">// have a valid shortid; but we don't use it in that case anyway.</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>sprop</name>-&gt;<name>hasShortID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>base</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>callobj_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>dslots</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>box_jsval</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>dslot_index</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// This is the hard case: we have a JSStackFrame private, but it's not in</comment>
    <comment type="line">// range.  During trace execution we may or may not have a JSStackFrame</comment>
    <comment type="line">// anymore.  Call the standard builtins, which handle that situation.</comment>

    <comment type="line">// Set variables in off-trace-stack call objects by calling standard builtins.</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CallInfo</name>*</type> <name>ci</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>setterOp</name></name><argument_list>()</argument_list></call> == <name>SetCallArg</name></expr>)</condition><then>
        <expr_stmt><expr><name>ci</name> = &amp;<name>js_SetCallArg_ci</name></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>setterOp</name></name><argument_list>()</argument_list></call> == <name>SetCallVar</name></expr>)</condition><then>
        <expr_stmt><expr><name>ci</name> = &amp;<name>js_SetCallVar_ci</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't trace special CallClass setter"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

    <comment type="line">// Even though the frame is out of range, later we might be called as an</comment>
    <comment type="line">// inner trace such that the target variable is defined in the outer trace</comment>
    <comment type="line">// entry frame. In that case, we must store to the native stack area for</comment>
    <comment type="line">// that frame.</comment>

    <decl_stmt><decl><type><name>LIns</name> *</type><name>fp_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>cx_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSContext</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>fpcallobj_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>fp_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSStackFrame</name></expr></argument>, <argument><expr><name>callobj</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>br1</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>fpcallobj_ins</name></expr></argument>, <argument><expr><name>callobj_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Case 1: storing to native stack area.</comment>

    <comment type="line">// Compute native stack slot and address offset we are storing to.</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>slot</name> <init>= <expr><call><name>uint16</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>shortid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>slot_ins</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>setterOp</name></name><argument_list>()</argument_list></call> == <name>SetCallArg</name></expr>)</condition><then>
        <expr_stmt><expr><name>slot_ins</name> = <call><name><name>ArgClosureTraits</name>::<name>adj_slot_lir</name></name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>fp_ins</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>slot_ins</name> = <call><name><name>VarClosureTraits</name>::<name>adj_slot_lir</name></name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>fp_ins</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>offset_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_mul</name></expr></argument>, <argument><expr><name>slot_ins</name></expr></argument>, <argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Guard that we are not changing the type of the slot we are storing to.</comment>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>callstackBase_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>,
                                           <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>callstackBase</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>frameInfo_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>callstackBase_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>typemap_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>frameInfo_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>type_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldzb</name></expr></argument>,
                                  <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>typemap_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_u2p</name></name><argument_list>(<argument><expr><name>slot_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>,
                                  <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name></type> <name>type</name> <init>= <expr><call><name>getCoercedType</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>type</name> == <name>TT_INT32</name> &amp;&amp; !<call><name>isPromoteInt</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>type</name> = <name>TT_DOUBLE</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
          <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>type_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr>"guard(type-stable set upvar)"</expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Store to the native stack slot.</comment>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>stackBase_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>,
                                       <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>stackBase</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>storeValue_ins</name> <init>= <expr><call><name>isPromoteInt</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call> ? <call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call> : <name>v_ins</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>storeValue_ins</name></expr></argument>,
                   <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>stackBase_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_u2p</name></name><argument_list>(<argument><expr><name>offset_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_STORE_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>br2</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Case 2: calling builtin.</comment>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>label1</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>br1</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{
        <expr><call><name>box_jsval</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><call><name>SPROP_USERID</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
        <expr><name>callobj_ins</name></expr>,
        <expr><name>cx_ins</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>call_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"guard(set upvar)"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STATUS_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name> *</type><name>label2</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>br2</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_SetPropHit</name></name><parameter_list>(<param><decl><type><name>PropertyCacheEntry</name>*</type> <name>entry</name></decl></param>, <param><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>r</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>setProp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>sprop</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr>*<name>pc</name></expr>)</condition> <block>{
      <case>case <expr><name>JSOP_SETPROP</name></expr>:
      </case><case>case <expr><name>JSOP_SETNAME</name></expr>:
      </case><case>case <expr><name>JSOP_SETMETHOD</name></expr>:
        <if>if <condition>(<expr><name><name>pc</name><index>[<expr><name>JSOP_SETPROP_LENGTH</name></expr>]</index></name> != <name>JSOP_POP</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>

      </case><default>default:<empty_stmt>;</empty_stmt>
    </default>}</block></switch>

    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>VMSideExit</name>*</type>
<name><name>TraceRecorder</name>::<name>enterDeepBailCall</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// Take snapshot for DeepBail and store it in cx-&gt;bailExit.</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>DEEP_BAIL_EXIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cx_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSContext</name></expr></argument>, <argument><expr><name>bailExit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Tell nanojit not to discard or defer stack writes before this call.</comment>
    <decl_stmt><decl><type><name>GuardRecord</name>*</type> <name>guardRec</name> <init>= <expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_xbarrier</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>guardRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Forget about guarded shapes, since deep bailers can reshape the world.</comment>
    <expr_stmt><expr><call><name>forgetGuardedShapes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>exit</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>leaveDeepBailCall</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// Keep cx-&gt;bailExit null when it's invalid.</comment>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cx_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSContext</name></expr></argument>, <argument><expr><name>bailExit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>finishGetProp</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>vp_ins</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>ok_ins</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>outp</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Store the boxed result (and this-object, if JOF_CALLOP) before the</comment>
    <comment type="line">// guard. The deep-bail case requires this. If the property get fails,</comment>
    <comment type="line">// these slots will be ignored anyway.</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>result_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>vp_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>outp</name></expr></argument>, <argument><expr><name>result_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>js_CodeSpec</name><index>[<expr>*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr>]</index></name>.<name>format</name> &amp; <name>JOF_CALLOP</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>outp</name> + 1</expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// We need to guard on ok_ins, but this requires a snapshot of the state</comment>
    <comment type="line">// after this op. monitorRecording will do it for us.</comment>
    <expr_stmt><expr><name>pendingGuardCondition</name> = <name>ok_ins</name></expr>;</expr_stmt>

    <comment type="line">// Note there is a boxed result sitting on the stack. The caller must leave</comment>
    <comment type="line">// it there for the time being, since the return type is not yet</comment>
    <comment type="line">// known. monitorRecording will emit the code to unbox it.</comment>
    <expr_stmt><expr><name>pendingUnboxSlot</name> = <name>outp</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>RootedStringToId</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSString</name>**</type> <name>namep</name></decl></param>, <param><decl><type><name>jsid</name>*</type> <name>idp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSString</name>*</type> <name>name</name> <init>= <expr>*<name>namep</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>name</name>-&gt;<name>isAtomized</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>idp</name> = <call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr>(<name>JSAtom</name>*) <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSAtom</name>*</type> <name>atom</name> <init>= <expr><call><name>js_AtomizeString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>atom</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr>*<name>namep</name> = <call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* write back to GC root */</comment>
    <expr_stmt><expr>*<name>idp</name> = <call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>GetPropertyByName</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>JSString</name>**</type> <name>namep</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LeaveTraceIfGlobalObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsid</name></type> <name>id</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>RootedStringToId</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>namep</name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>)</argument_list></call> || !<call><name><name>obj</name>-&gt;<name>getProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>false</expr>;</return>
    }</block></then></if>
    <return>return <expr><name><name>cx</name>-&gt;<name>interpState</name>-&gt;<name>builtinStatus</name></name> == 0</expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>static</argument>, <argument>BOOL_FAIL</argument>, <argument>GetPropertyByName</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>STRINGPTR</argument>, <argument>JSVALPTR</argument>,
                     <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<comment type="line">// Convert the value in a slot to a string and store the resulting string back</comment>
<comment type="line">// in the slot (typically in order to root it).</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>primitiveToStringInPlace</name></name><parameter_list>(<param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name> <init>= <expr>*<name>vp</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// v is not a string. Turn it into one. js_ValueToString is safe</comment>
        <comment type="line">// because v is not an object.</comment>
        <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name>js_ValueToString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_ERROR</name><argument_list>(<argument><expr>"failed to stringify element id"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>v</name> = <call><name>STRING_TO_JSVAL</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><call><name>stringify</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Write the string back to the stack to save the interpreter some work</comment>
        <comment type="line">// and to ensure snapshots get the correct type for this slot.</comment>
        <expr_stmt><expr>*<name>vp</name> = <name>v</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>getPropertyByName</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>idvalp</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>outp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>primitiveToStringInPlace</name><argument_list>(<argument><expr><name>idvalp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Call GetPropertyByName. The vp parameter points to stack because this is</comment>
    <comment type="line">// what the interpreter currently does. obj and id are rooted on the</comment>
    <comment type="line">// interpreter stack, but the slot at vp is not a root.</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>vp_ins</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"vp"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>idvalp_ins</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><call><name>addr</name><argument_list>(<argument><expr><name>idvalp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"idvalp"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{<expr><name>vp_ins</name></expr>, <expr><name>idvalp_ins</name></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>GetPropertyByName_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// GetPropertyByName can assign to *idvalp, so the tracker has an incorrect</comment>
    <comment type="line">// entry for that address. Correct it. (If the value in the address is</comment>
    <comment type="line">// never used again, the usual case, Nanojit will kill this load.)</comment>
    <comment type="line">// The AccSet could be made more precise with some effort (idvalp_ins may</comment>
    <comment type="line">// equal 'sp+k'), but it's not worth it because this case is rare.</comment>
    <expr_stmt><expr><call><name><name>tracker</name>.<name>set</name></name><argument_list>(<argument><expr><name>idvalp</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>idvalp_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_STACK</name>|<name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>finishGetProp</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>vp_ins</name></expr></argument>, <argument><expr><name>ok_ins</name></expr></argument>, <argument><expr><name>outp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>leaveDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>GetPropertyByIndex</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>int32</name></type> <name>index</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LeaveTraceIfGlobalObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>AutoIdRooter</name></type> <name>idr</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr>!<call><name>js_Int32ToId</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>idr</name>.<name>addr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> || !<call><name><name>obj</name>-&gt;<name>getProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>idr</name>.<name>id</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name><name>cx</name>-&gt;<name>interpState</name>-&gt;<name>builtinStatus</name></name> == 0</expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>static</argument>, <argument>BOOL_FAIL</argument>, <argument>GetPropertyByIndex</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>INT32</argument>, <argument>JSVALPTR</argument>, <argument>0</argument>,
                     <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>getPropertyByIndex</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>index_ins</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>outp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>index_ins</name> = <call><name>makeNumberInt32</name><argument_list>(<argument><expr><name>index_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// See note in getPropertyByName about vp.</comment>
    <expr_stmt><expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>vp_ins</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"vp"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{<expr><name>vp_ins</name></expr>, <expr><name>index_ins</name></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>GetPropertyByIndex_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>finishGetProp</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>vp_ins</name></expr></argument>, <argument><expr><name>ok_ins</name></expr></argument>, <argument><expr><name>outp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>leaveDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>GetPropertyById</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>jsid</name></type> <name>id</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LeaveTraceIfGlobalObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>obj</name>-&gt;<name>getProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name><name>cx</name>-&gt;<name>interpState</name>-&gt;<name>builtinStatus</name></name> == 0</expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>static</argument>, <argument>BOOL_FAIL</argument>, <argument>GetPropertyById</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>JSVAL</argument>, <argument>JSVALPTR</argument>,
                     <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>getPropertyById</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>outp</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// Find the atom.</comment>
    <decl_stmt><decl><type><name>JSAtom</name>*</type> <name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name>&amp;</type> <name>cs</name> <init>= <expr><name><name>js_CodeSpec</name><index>[<expr>*<name>pc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_LENGTH</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>atom</name> = <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lengthAtom</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JOF_TYPE</name><argument_list>(<argument><expr><name><name>cs</name>.<name>format</name></name></expr></argument>)</argument_list></call> == <name>JOF_ATOM</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>atom</name> = <name><name>atoms</name><index>[<expr><call><name>GET_INDEX</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JOF_TYPE</name><argument_list>(<argument><expr><name><name>cs</name>.<name>format</name></name></expr></argument>)</argument_list></call> == <name>JOF_SLOTATOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>atom</name> = <name><name>atoms</name><index>[<expr><call><name>GET_INDEX</name><argument_list>(<argument><expr><name>pc</name> + <name>SLOTNO_LEN</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <comment type="line">// Call GetPropertyById. See note in getPropertyByName about vp.</comment>
    <expr_stmt><expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>jsid</name></type> <name>id</name> <init>= <expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>vp_ins</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"vp"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{<expr><name>vp_ins</name></expr>, <expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>GetPropertyById_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>finishGetProp</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>vp_ins</name></expr></argument>, <argument><expr><name>ok_ins</name></expr></argument>, <argument><expr><name>outp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>leaveDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="block">/* Manually inlined, specialized copy of js_NativeGet. */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>GetPropertyWithNativeGetter</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LeaveTraceIfGlobalObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSProperty</name>*</type> <name>prop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>pobj</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>lookupProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>sprop</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr>&amp;<name>pobj</name></expr></argument>, <argument><expr>&amp;<name>prop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>prop</name> == (<name>JSProperty</name>*) <name>sprop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>pobj</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// JSScopeProperty::get contains a special case for With objects. We can</comment>
    <comment type="line">// elide it here because With objects are, we claim, never on the operand</comment>
    <comment type="line">// stack while recording.</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> != &amp;<name>js_WithClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr>*<name>vp</name> = <name>JSVAL_VOID</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><call><name><name>sprop</name>-&gt;<name>getterOp</name></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>SPROP_USERID</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name><name>cx</name>-&gt;<name>interpState</name>-&gt;<name>builtinStatus</name></name> == 0</expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>static</argument>, <argument>BOOL_FAIL</argument>, <argument>GetPropertyWithNativeGetter</argument>,
                     <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>SCOPEPROP</argument>, <argument>JSVALPTR</argument>, <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>getPropertyWithNativeGetter</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>outp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>sprop</name>-&gt;<name>hasGetterValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>slot</name></name> == <name>SPROP_INVALID_SLOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name><name>sprop</name>-&gt;<name>hasDefaultGetterOrIsMethod</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Call GetPropertyWithNativeGetter. See note in getPropertyByName about vp.</comment>
    <comment type="line">// FIXME - We should call the getter directly. Using a builtin function for</comment>
    <comment type="line">// now because it buys some extra asserts. See bug 508310.</comment>
    <expr_stmt><expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>vp_ins</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"vp"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{<expr><name>vp_ins</name></expr>, <expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>GetPropertyWithNativeGetter_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>finishGetProp</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>vp_ins</name></expr></argument>, <argument><expr><name>ok_ins</name></expr></argument>, <argument><expr><name>outp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>leaveDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="line">// Typed array tracing depends on EXPANDED_LOADSTORE and F2I</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NJ_EXPANDED_LOADSTORE_SUPPORTED</name> &amp;&amp; <name>NJ_F2I_SUPPORTED</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>OkToTraceTypedArrays</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>OkToTraceTypedArrays</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETELEM</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bool</name></type> <name>call</name> <init>= <expr>*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_CALLELEM</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>idx</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>lval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>idx_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Special case for array-like access of strings.</comment>
    <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>isInt32</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>call</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"JSOP_CALLELEM on a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>asInt32</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>size_t</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> &gt;= <call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call>-&gt;<call><name>length</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"Invalid string index in JSOP_GETELEM"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>idx_ins</name> = <call><name>makeNumberInt32</name><argument_list>(<argument><expr><name>idx_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>idx_ins</name></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>unitstr_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_String_getelem_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>unitstr_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>, <argument><expr><name>unitstr_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"JSOP_GETLEM on a primitive"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>obj</name> == <name>globalObj</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"JSOP_GETELEM on global"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl>;</decl_stmt>

    <comment type="block">/* Property access using a string name or something we have to stringify. */</comment>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"object used as index"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>getPropertyByName</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>idx</name></expr></argument>, <argument><expr>&amp;<name>lval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name><name>obj</name>-&gt;<name>isArguments</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>depth</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>afp</name> <init>= <expr><call><name>guardArguments</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>afp</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>uintN</name></type> <name>int_idx</name> <init>= <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name> <init>= <expr>&amp;<name><name>afp</name>-&gt;<name>argv</name><index>[<expr><name>int_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>idx_ins</name>-&gt;<name>isconstf</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>int_idx</name> &gt;= 0 &amp;&amp; <name>int_idx</name> &lt; <name><name>afp</name>-&gt;<name>argc</name></name></expr>)</condition><then>
                    <expr_stmt><expr><name>v_ins</name> = <call><name>get</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><name>v_ins</name> = <call><name>INS_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>
            }</block></then> <else>else <block>{
                <comment type="line">// If the index is not a constant expression, we generate LIR to load the value from</comment>
                <comment type="line">// the native stack area. The guard on js_ArgumentClass above ensures the up-to-date</comment>
                <comment type="line">// value has been written back to the native stack area.</comment>
                <expr_stmt><expr><name>idx_ins</name> = <call><name>makeNumberInt32</name><argument_list>(<argument><expr><name>idx_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>int_idx</name> <argument_list>&lt; <argument><expr>0 || <name>int_idx</name></expr></argument> &gt;</argument_list></name>= <name><name>afp</name>-&gt;<name>argc</name></name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"cannot trace arguments with out of range index"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
                      <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ge</name></expr></argument>, <argument><expr><name>idx_ins</name></expr></argument>, <argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr>"guard(upvar index &gt;= 0)"</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
                      <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_lt</name></expr></argument>, <argument><expr><name>idx_ins</name></expr></argument>, <argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name><name>afp</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr>"guard(upvar index in range)"</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>TraceType</name></type> <name>type</name> <init>= <expr><call><name>getCoercedType</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Guard that the argument has the same type on trace as during recording.</comment>
                <decl_stmt><decl><type><name>LIns</name>*</type> <name>typemap_ins</name></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>depth</name> == 0</expr>)</condition><then> <block>{
                    <comment type="line">// In this case, we are in the same frame where the arguments object was created.</comment>
                    <comment type="line">// The entry type map is not necessarily up-to-date, so we capture a new type map</comment>
                    <comment type="line">// for this point in the code.</comment>
                    <decl_stmt><decl><type><name>unsigned</name></type> <name>stackSlots</name> <init>= <expr><call><name>NativeStackSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument> <comment type="block">/* callDepth */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>TraceType</name>*</type> <name>typemap</name> <init>= <expr>new (<call><name>traceAlloc</name><argument_list>()</argument_list></call>) <name><name>TraceType</name><index>[<expr><name>stackSlots</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>DetermineTypesVisitor</name></type> <name>detVisitor</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><name>typemap</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>detVisitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>typemap_ins</name> = <call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>typemap</name> + 2</expr></argument> <comment type="block">/* callee, this */</comment>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <comment type="line">// In this case, we are in a deeper frame from where the arguments object was</comment>
                    <comment type="line">// created. The type map at the point of the call out from the creation frame</comment>
                    <comment type="line">// is accurate.</comment>
                    <comment type="line">// Note: this relies on the assumption that we abort on setting an element of</comment>
                    <comment type="line">// an arguments object in any deeper frame.</comment>
                    <decl_stmt><decl><type><name>LIns</name>*</type> <name>fip_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>rp</name></name></expr></argument>,
                                                 <argument><expr>(<name>callDepth</name>-<name>depth</name>)*<sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name>*</expr></argument>)</argument_list></sizeof></expr></argument>,
                                                 <argument><expr><name>ACC_RSTACK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>typemap_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>fip_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name></expr></argument>)</argument_list></sizeof> + 2<comment type="block">/*callee,this*/</comment> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

                <decl_stmt><decl><type><name>LIns</name>*</type> <name>typep_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>typemap_ins</name></expr></argument>,
                                            <argument><expr><call><name><name>lir</name>-&gt;<name>ins_u2p</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_mul</name></expr></argument>,
                                                                   <argument><expr><name>idx_ins</name></expr></argument>,
                                                                   <argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>LIns</name>*</type> <name>type_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldzb</name></expr></argument>, <argument><expr><name>typep_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
                      <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>type_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr>"guard(type-stable upvar)"</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Read the value out of the native stack area.</comment>
                <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ult</name></expr></argument>, <argument><expr><name>idx_ins</name></expr></argument>, <argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name><name>afp</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>size_t</name></type> <name>stackOffset</name> <init>= <expr><call><name>nativespOffset</name><argument_list>(<argument><expr>&amp;<name><name>afp</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>LIns</name>*</type> <name>args_addr_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>sp</name></name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>stackOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>LIns</name>*</type> <name>argi_addr_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>,
                                                <argument><expr><name>args_addr_ins</name></expr></argument>,
                                                <argument><expr><call><name><name>lir</name>-&gt;<name>ins_u2p</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_mul</name></expr></argument>,
                                                                       <argument><expr><name>idx_ins</name></expr></argument>,
                                                                       <argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// The AccSet could be more precise, but ValidateWriter</comment>
                <comment type="line">// doesn't recognise the complex expression involving 'sp' as</comment>
                <comment type="line">// a STACK access, and it's not worth the effort to be more</comment>
                <comment type="line">// precise because this case is rare.</comment>
                <expr_stmt><expr><name>v_ins</name> = <call><name>stackLoad</name><argument_list>(<argument><expr><name>argi_addr_ins</name></expr></argument>, <argument><expr><name>ACC_LOAD_ANY</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>call</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>idx</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't reach arguments object's frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name><name>obj</name>-&gt;<name>isDenseArray</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// Fast path for dense arrays accessed with a integer index.</comment>
        <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>addr_ins</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>guardDenseArray</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>denseArrayElement</name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>call</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>idx</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>OkToTraceTypedArrays</name> &amp;&amp; <call><name>js_IsTypedArray</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// Fast path for typed arrays accessed with a integer index.</comment>
        <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>addr_ins</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>guardClass</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>typedArrayElement</name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>call</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>idx</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>getPropertyByIndex</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>idx_ins</name></expr></argument>, <argument><expr>&amp;<name>lval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Functions used by JSOP_SETELEM */</comment>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>SetPropertyByName</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>JSString</name>**</type> <name>namep</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LeaveTraceIfGlobalObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsid</name></type> <name>id</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>RootedStringToId</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>namep</name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>)</argument_list></call> || !<call><name><name>obj</name>-&gt;<name>setProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name><name>cx</name>-&gt;<name>interpState</name>-&gt;<name>builtinStatus</name></name> == 0</expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>static</argument>, <argument>BOOL_FAIL</argument>, <argument>SetPropertyByName</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>STRINGPTR</argument>, <argument>JSVALPTR</argument>,
                     <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>InitPropertyByName</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>JSString</name>**</type> <name>namep</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>val</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LeaveTraceIfGlobalObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsid</name></type> <name>id</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>RootedStringToId</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>namep</name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>)</argument_list></call> ||
        !<call><name><name>obj</name>-&gt;<name>defineProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSPROP_ENUMERATE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name><name>cx</name>-&gt;<name>interpState</name>-&gt;<name>builtinStatus</name></name> == 0</expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>static</argument>, <argument>BOOL_FAIL</argument>, <argument>InitPropertyByName</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>STRINGPTR</argument>, <argument>JSVAL</argument>,
                     <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>initOrSetPropertyByName</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>idvalp</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>rvalp</name></decl></param>, <param><decl><type><name>bool</name></type> <name>init</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>primitiveToStringInPlace</name><argument_list>(<argument><expr><name>idvalp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>rval_ins</name> <init>= <expr><call><name>box_jsval</name><argument_list>(<argument><expr>*<name>rvalp</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr><name>rvalp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>idvalp_ins</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><call><name>addr</name><argument_list>(<argument><expr><name>idvalp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"idvalp"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>init</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{<expr><name>rval_ins</name></expr>, <expr><name>idvalp_ins</name></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr>}</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ok_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>InitPropertyByName_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// See note in getPropertyByName about vp.</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>vp_ins</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"vp"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>rval_ins</name></expr></argument>, <argument><expr><name>vp_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{<expr><name>vp_ins</name></expr>, <expr><name>idvalp_ins</name></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr>}</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ok_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>SetPropertyByName_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pendingGuardCondition</name> = <name>ok_ins</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>leaveDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>SetPropertyByIndex</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>int32</name></type> <name>index</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LeaveTraceIfGlobalObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>AutoIdRooter</name></type> <name>idr</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr>!<call><name>js_Int32ToId</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>idr</name>.<name>addr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> || !<call><name><name>obj</name>-&gt;<name>setProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>idr</name>.<name>id</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name><name>cx</name>-&gt;<name>interpState</name>-&gt;<name>builtinStatus</name></name> == 0</expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>static</argument>, <argument>BOOL_FAIL</argument>, <argument>SetPropertyByIndex</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>INT32</argument>, <argument>JSVALPTR</argument>, <argument>0</argument>,
                     <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>InitPropertyByIndex</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>int32</name></type> <name>index</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>val</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>LeaveTraceIfGlobalObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <function_decl><type><name>AutoIdRooter</name></type> <name>idr</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr>!<call><name>js_Int32ToId</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name><name>idr</name>.<name>addr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> ||
        !<call><name><name>obj</name>-&gt;<name>defineProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>idr</name>.<name>id</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSPROP_ENUMERATE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name><name>cx</name>-&gt;<name>interpState</name>-&gt;<name>builtinStatus</name></name> == 0</expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>static</argument>, <argument>BOOL_FAIL</argument>, <argument>InitPropertyByIndex</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>INT32</argument>, <argument>JSVAL</argument>, <argument>0</argument>,
                     <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>initOrSetPropertyByIndex</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>index_ins</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>rvalp</name></decl></param>, <param><decl><type><name>bool</name></type> <name>init</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>index_ins</name> = <call><name>makeNumberInt32</name><argument_list>(<argument><expr><name>index_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>rval_ins</name> <init>= <expr><call><name>box_jsval</name><argument_list>(<argument><expr>*<name>rvalp</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr><name>rvalp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>init</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{<expr><name>rval_ins</name></expr>, <expr><name>index_ins</name></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr>}</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ok_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>InitPropertyByIndex_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// See note in getPropertyByName about vp.</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>vp_ins</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"vp"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>rval_ins</name></expr></argument>, <argument><expr><name>vp_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{<expr><name>vp_ins</name></expr>, <expr><name>index_ins</name></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr>}</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ok_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>SetPropertyByIndex_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pendingGuardCondition</name> = <name>ok_ins</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>leaveDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>setElem</name></name><parameter_list>(<param><decl><type><name>int</name></type> <name>lval_spindex</name></decl></param>, <param><decl><type><name>int</name></type> <name>idx_spindex</name></decl></param>, <param><decl><type><name>int</name></type> <name>v_spindex</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr><name>v_spindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>idx</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr><name>idx_spindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>lval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr><name>lval_spindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"left JSOP_SETELEM operand is not an object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>idx_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JS_InstanceOf</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>js_ArgumentsClass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't trace setting elements of the |arguments| object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>!<call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"non-primitive index"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>initOrSetPropertyByName</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>idx</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>,
                                             <argument><expr>*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_INITELEM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>OkToTraceTypedArrays</name> &amp;&amp; <call><name>js_IsTypedArray</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// Fast path: assigning to element of typed array.</comment>

        <comment type="line">// Ensure array is a typed array and is the same type as what was written</comment>
        <expr_stmt><expr><call><name>guardClass</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>js</name>::<name>TypedArray</name></name>*</type> <name>tarray</name> <init>= <expr><call><name><name>js</name>::<name>TypedArray</name>::<name>fromJSObject</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>priv_ins</name> <init>= <expr><call><name>stobj_get_const_fslot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>JSSLOT_PRIVATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// The index was on the stack and is therefore a LIR float; force it to</comment>
        <comment type="line">// be an integer.                              </comment>
        <expr_stmt><expr><name>idx_ins</name> = <call><name>makeNumberInt32</name><argument_list>(<argument><expr><name>idx_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
                                                       
        <comment type="line">// Ensure idx &gt;= 0 &amp;&amp; idx &lt; length (by using uint32)</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_xf</name></expr></argument>,
                      <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ult</name></expr></argument>,
                                <argument><expr><name>idx_ins</name></expr></argument>,
                                <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>priv_ins</name></expr></argument>, <argument><expr><call><name><name>js</name>::<name>TypedArray</name>::<name>lengthOffset</name></name><argument_list>()</argument_list></call></expr></argument>,
                                             <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>OVERFLOW_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// We're now ready to store</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>data_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>priv_ins</name></expr></argument>, <argument><expr><call><name><name>js</name>::<name>TypedArray</name>::<name>dataOffset</name></name><argument_list>()</argument_list></call></expr></argument>,
                                      <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>pidx_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins_u2p</name></name><argument_list>(<argument><expr><name>idx_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>addr_ins</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <comment type="line">// If it's not a number, convert objects to NaN,</comment>
        <comment type="line">// null to 0, and call StringToNumber or BooleanOrUndefinedToNumber</comment>
        <comment type="line">// for those.</comment>
        <if>if <condition>(<expr>!<call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>v_ins</name> = <call><name>INS_CONST</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name>js_NaN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>v_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_StringToNumber_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_BOOLEAN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>v_ins</name> = <call><name>i2f</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name>js_NaN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if></else></if></else></if>
        }</block></then></if>

        <switch>switch <condition>(<expr><name><name>tarray</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
          <case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_INT8</name></name></expr>:
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_INT16</name></name></expr>:
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_INT32</name></name></expr>:
            <expr_stmt><expr><name>v_ins</name> = <call><name>f2i</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT8</name></name></expr>:
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT16</name></name></expr>:
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT32</name></name></expr>:
            <expr_stmt><expr><name>v_ins</name> = <call><name>f2u</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT8_CLAMPED</name></name></expr>:
            <if>if <condition>(<expr><call><name>isPromoteInt</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>v_ins</name> = <call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins_choose</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_lt</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name><name>lir</name>-&gt;<name>ins_choose</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_gt</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr>0xff</expr></argument>)</argument_list></call></expr></argument>,
                                                        <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0xff</expr></argument>)</argument_list></call></expr></argument>,
                                                        <argument><expr><name>v_ins</name></expr></argument>,
                                                        <argument><expr><call><name><name>avmplus</name>::<name>AvmCore</name>::<name>use_cmov</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name><name>avmplus</name>::<name>AvmCore</name>::<name>use_cmov</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_TypedArray_uint8_clamp_double_ci</name></expr></argument>, <argument><expr>&amp;<name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <break>break;</break>
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_FLOAT32</name></name></expr>:
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_FLOAT64</name></name></expr>:
            <comment type="line">// Do nothing, this is already a float</comment>
            <break>break;</break>
          </case><default>default:
            <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"Unknown typed array type in tracer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>       
        </default>}</block></switch>

        <switch>switch <condition>(<expr><name><name>tarray</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
          <case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_INT8</name></name></expr>:
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT8_CLAMPED</name></name></expr>:
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT8</name></name></expr>:
            <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStore</name></name><argument_list>(<argument><expr><name>LIR_stb</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_INT16</name></name></expr>:
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT16</name></name></expr>:
            <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStore</name></name><argument_list>(<argument><expr><name>LIR_sts</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_INT32</name></name></expr>:
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT32</name></name></expr>:
            <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStore</name></name><argument_list>(<argument><expr><name>LIR_sti</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_FLOAT32</name></name></expr>:
            <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStore</name></name><argument_list>(<argument><expr><name>LIR_st32f</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_FLOAT64</name></name></expr>:
            <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStore</name></name><argument_list>(<argument><expr><name>LIR_stfi</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><default>default:
            <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"Unknown typed array type in tracer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>       
        </default>}</block></switch>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call> &lt; 0 || !<call><name><name>obj</name>-&gt;<name>isDenseArray</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>initOrSetPropertyByIndex</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>idx_ins</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>,
                                                <argument><expr>*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> == <name>JSOP_INITELEM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="line">// Fast path: assigning to element of dense array.</comment>

        <comment type="line">// Make sure the array is actually dense.</comment>
        <if>if <condition>(<expr>!<call><name>guardDenseArray</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>ARECORD_STOP</name></expr>;</return></then></if>

        <comment type="line">// The index was on the stack and is therefore a LIR float. Force it to</comment>
        <comment type="line">// be an integer.</comment>
        <expr_stmt><expr><name>idx_ins</name> = <call><name>makeNumberInt32</name><argument_list>(<argument><expr><name>idx_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Box the value so we can use one builtin instead of having to add one</comment>
        <comment type="line">// builtin for every storage type. Special case for integers though,</comment>
        <comment type="line">// since they are so common.</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>res_ins</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>idx_ins</name></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>isNumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>isPromoteInt</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> = <call><name>demote</name><argument_list>(<argument><expr><name>lir</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>res_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_Array_dense_setelem_int_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> = <name>v_ins</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>res_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_Array_dense_setelem_double_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>box_jsval</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>, <expr><name>idx_ins</name></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>res_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_Array_dense_setelem_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>res_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>

    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_SETELEM</name> &amp;&amp; <name><name>pc</name><index>[<expr><name>JSOP_SETELEM_LENGTH</name></expr>]</index></name> != <name>JSOP_POP</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETELEM</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>setElem</name><argument_list>(<argument><expr>-3</expr></argument>, <argument><expr>-2</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>obj</name> != <name>globalObj</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>ins</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>NameResult</name></type> <name>nr</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>scopeChainProp</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PCVal</name></type> <name>pcval</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>test_property_cache</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>pcval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>pcval</name>.<name>isNull</name></name><argument_list>()</argument_list></call> || !<call><name><name>pcval</name>.<name>isObject</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"callee is not an object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><call><name><name>pcval</name>.<name>toObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><call><name><name>pcval</name>.<name>toObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<macro><name>JS_DEFINE_CALLINFO_5</name><argument_list>(<argument>extern</argument>, <argument>UINT32</argument>, <argument>GetUpvarArgOnTrace</argument>, <argument>CONTEXT</argument>, <argument>UINT32</argument>, <argument>INT32</argument>, <argument>UINT32</argument>,
                     <argument>DOUBLEPTR</argument>, <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>
<macro><name>JS_DEFINE_CALLINFO_5</name><argument_list>(<argument>extern</argument>, <argument>UINT32</argument>, <argument>GetUpvarVarOnTrace</argument>, <argument>CONTEXT</argument>, <argument>UINT32</argument>, <argument>INT32</argument>, <argument>UINT32</argument>,
                     <argument>DOUBLEPTR</argument>, <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>
<macro><name>JS_DEFINE_CALLINFO_5</name><argument_list>(<argument>extern</argument>, <argument>UINT32</argument>, <argument>GetUpvarStackOnTrace</argument>, <argument>CONTEXT</argument>, <argument>UINT32</argument>, <argument>INT32</argument>, <argument>UINT32</argument>,
                     <argument>DOUBLEPTR</argument>, <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<comment type="block">/*
 * Record LIR to get the given upvar. Return the LIR instruction for the upvar
 * value. NULL is returned only on a can't-happen condition with an invalid
 * typemap. The value of the upvar is returned as v.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>upvar</name></name><parameter_list>(<param><decl><type><name>JSScript</name>*</type> <name>script</name></decl></param>, <param><decl><type><name>JSUpvarArray</name>*</type> <name>uva</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>index</name></decl></param>, <param><decl><type><name>jsval</name>&amp;</type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Try to find the upvar in the current trace's tracker. For &amp;vr to be
     * the address of the jsval found in js_GetUpvar, we must initialize
     * vr directly with the result, so it is a reference to the same location.
     * It does not work to assign the result to v, because v is an already
     * existing reference that points to something else.
     */</comment>
    <decl_stmt><decl><type><name>uint32</name></type> <name>cookie</name> <init>= <expr><name><name>uva</name>-&gt;<name>vector</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>vr</name> <init>= <expr><call><name>js_GetUpvar</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>script</name>-&gt;<name>staticLevel</name></name></expr></argument>, <argument><expr><name>cookie</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>v</name> = <name>vr</name></expr>;</expr_stmt>

    <if>if <condition>(<decl><type><name>LIns</name>*</type> <name>ins</name> <init>= <expr><call><name>attemptImport</name><argument_list>(<argument><expr>&amp;<name>vr</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then>
        <return>return <expr><name>ins</name></expr>;</return></then></if>

    <comment type="block">/*
     * The upvar is not in the current trace, so get the upvar value exactly as
     * the interpreter does and unbox.
     */</comment>
    <decl_stmt><decl><type><name>uint32</name></type> <name>level</name> <init>= <expr><name><name>script</name>-&gt;<name>staticLevel</name></name> - <call><name>UPVAR_FRAME_SKIP</name><argument_list>(<argument><expr><name>cookie</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>cookieSlot</name> <init>= <expr><call><name>UPVAR_FRAME_SLOT</name><argument_list>(<argument><expr><name>cookie</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>display</name><index>[<expr><name>level</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CallInfo</name>*</type> <name>ci</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>slot</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name><name>fp</name>-&gt;<name>fun</name></name> || (<name><name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_EVAL</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ci</name> = &amp;<name>GetUpvarStackOnTrace_ci</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot</name> = <name>cookieSlot</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>cookieSlot</name> &lt; <name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ci</name> = &amp;<name>GetUpvarArgOnTrace_ci</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot</name> = <name>cookieSlot</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>cookieSlot</name> == <name>CALLEE_UPVAR_SLOT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ci</name> = &amp;<name>GetUpvarArgOnTrace_ci</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot</name> = -2</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>ci</name> = &amp;<name>GetUpvarVarOnTrace_ci</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot</name> = <name>cookieSlot</name> - <name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>nargs</name></name></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>outp</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{
        <expr><name>outp</name></expr>,
        <expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>,
        <expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>,
        <expr><name>cx_ins</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name></type> <name>type</name> <init>= <expr><call><name>getCoercedType</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
          <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>call_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr>"guard(type-stable upvar)"</expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>stackLoad</name><argument_list>(<argument><expr><name>outp</name></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Generate LIR to load a value from the native stack. This method ensures that
 * the correct LIR load operator is used.
 */</comment>
<function><type><name>LIns</name>*</type> <name><name>TraceRecorder</name>::<name>stackLoad</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>base</name></decl></param>, <param><decl><type><name>AccSet</name></type> <name>accSet</name></decl></param>, <param><decl><type><name>uint8</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LOpcode</name></type> <name>loadOp</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
      <case>case <expr><name>TT_DOUBLE</name></expr>:
        <expr_stmt><expr><name>loadOp</name> = <name>LIR_ldf</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>TT_OBJECT</name></expr>:
      </case><case>case <expr><name>TT_STRING</name></expr>:
      </case><case>case <expr><name>TT_FUNCTION</name></expr>:
      </case><case>case <expr><name>TT_NULL</name></expr>:
        <expr_stmt><expr><name>loadOp</name> = <name>LIR_ldp</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>TT_INT32</name></expr>:
      </case><case>case <expr><name>TT_SPECIAL</name></expr>:
      </case><case>case <expr><name>TT_VOID</name></expr>:
        <expr_stmt><expr><name>loadOp</name> = <name>LIR_ld</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>TT_JSVAL</name></expr>:
      </case><default>default:
        <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"found jsval type in an upvar type map entry"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </default>}</block></switch>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>result</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>loadOp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>accSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>type</name> == <name>TT_INT32</name></expr>)</condition><then>
        <expr_stmt><expr><name>result</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETUPVAR</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>index</name> <init>= <expr><call><name>GET_UINT16</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name> *</type><name>script</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSUpvarArray</name>*</type> <name>uva</name> <init>= <expr><call><name><name>script</name>-&gt;<name>upvars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>index</name> &lt; <name><name>uva</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>upvar_ins</name> <init>= <expr><call><name>upvar</name><argument_list>(<argument><expr><name>script</name></expr></argument>, <argument><expr><name>uva</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>upvar_ins</name></expr>)</condition><then>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>upvar_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLUPVAR</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>record_JSOP_GETUPVAR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETDSLOT</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>callee</name> <init>= <expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>calleeObject</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>callee_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>unsigned</name></type> <name>index</name> <init>= <expr><call><name>GET_UINT16</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>dslots_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>callee_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>dslots</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>, <argument><expr><name>index</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>unbox_jsval</name><argument_list>(<argument><expr><name><name>callee</name>-&gt;<name>dslots</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLDSLOT</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>record_JSOP_GETDSLOT</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>guardCallee</name></name><parameter_list>(<param><decl><type><name>jsval</name>&amp;</type> <name>callee</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>callee_obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>callee</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>callee_obj</name>-&gt;<name>isFunction</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>callee_fun</name> <init>= <expr>(<name>JSFunction</name>*) <call><name><name>callee_obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * First, guard on the callee's function (JSFunction*) identity. This is
     * necessary since tracing always inlines function calls. But note that
     * TR::functionCall avoids calling TR::guardCallee for constant methods
     * (those hit in the property cache from JSOP_CALLPROP).
     */</comment>
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>branchExit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>callee_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>callee</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>gcthings</name>.<name>addUnique</name></name><argument_list>(<argument><expr><name>callee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
          <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>,
                    <argument><expr><call><name>stobj_get_private</name><argument_list>(<argument><expr><name>callee_ins</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>callee_fun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>branchExit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Second, consider guarding on the parent scope of the callee.
     *
     * As long as we guard on parent scope, we are guaranteed when recording
     * variable accesses for a Call object having no private data that we can
     * emit code that avoids checking for an active JSStackFrame for the Call
     * object (which would hold fresh variable values -- the Call object's
     * dslots would be stale until the stack frame is popped). This is because
     * Call objects can't pick up a new stack frame in their private slot once
     * they have none. TR::callProp and TR::setCallProp depend on this fact and
     * document where; if this guard is removed make sure to fix those methods.
     * Search for the "parent guard" comments in them.
     *
     * In general, a loop in an escaping function scoped by Call objects could
     * be traced before the function has returned, and the trace then triggered
     * after, or vice versa. The function must escape, i.e., be a "funarg", or
     * else there's no need to guard callee parent at all. So once we know (by
     * static analysis) that a function may escape, we cannot avoid guarding on
     * either the private data of the Call object or the Call object itself, if
     * we wish to optimize for the particular deactivated stack frame (null
     * private data) case as noted above.
     */</comment>
    <if>if <condition>(<expr><call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name>callee_fun</name></expr></argument>)</argument_list></call> &amp;&amp;
        (!<call><name>FUN_NULL_CLOSURE</name><argument_list>(<argument><expr><name>callee_fun</name></expr></argument>)</argument_list></call> || <name><name>callee_fun</name>-&gt;<name>u</name>.<name>i</name>.<name>nupvars</name></name> != 0)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSObject</name>*</type> <name>parent</name> <init>= <expr><call><name><name>callee_obj</name>-&gt;<name>getParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>parent</name> != <name>globalObj</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name><name>parent</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> != &amp;<name>js_CallClass</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"closure scoped by neither the global object nor a Call object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
                  <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>,
                            <argument><expr><call><name>stobj_get_parent</name><argument_list>(<argument><expr><name>callee_ins</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><name>branchExit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Prepare the given |arguments| object to be accessed on trace. If the return
 * value is non-NULL, then the given |arguments| object refers to a frame on
 * the current trace and is guaranteed to refer to the same frame on trace for
 * all later executions.
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>JSStackFrame</name> *</type>
<name><name>TraceRecorder</name>::<name>guardArguments</name></name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>unsigned</name> *</type><name>depthp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>isArguments</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>afp</name> <init>= <expr><call><name>frameIfInRange</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>depthp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>afp</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>VMSideExit</name> *</type><name>exit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guardClass</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>js_ArgumentsClass</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>args_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>afp</name>-&gt;<name>argsobj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>cmp</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>args_ins</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_xf</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>afp</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>interpretedFunctionCall</name></name><parameter_list>(<param><decl><type><name>jsval</name>&amp;</type> <name>fval</name></decl></param>, <param><decl><type><name>JSFunction</name>*</type> <name>fun</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>bool</name></type> <name>constructing</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * The function's identity (JSFunction and therefore JSScript) is guarded,
     * so we can optimize for the empty script singleton right away. No need to
     * worry about crossing globals or relocating argv, even, in this case!
     *
     * Note that the interpreter shortcuts empty-script call and construct too,
     * and does not call any TR::record_*CallComplete hook.
     */</comment>
    <if>if <condition>(<expr><call><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>rval_ins</name> <init>= <expr><name>constructing</name> ? <call><name>stack</name><argument_list>(<argument><expr>-1 - <name>argc</name></expr></argument>)</argument_list></call> : <call><name>INS_VOID</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>-2 - <name>argc</name></expr></argument>, <argument><expr><name>rval_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call>-&gt;<call><name>getGlobal</name><argument_list>()</argument_list></call> != <name>globalObj</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"JSOP_CALL or JSOP_NEW crosses global scopes"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>

    <comment type="line">// TODO: track the copying via the tracker...</comment>
    <if>if <condition>(<expr><name><name>argc</name> <argument_list>&lt; <argument><expr><name><name>fun</name>-&gt;<name>nargs</name></name> &amp;&amp;
        <name>jsuword</name>(<name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> + (<name><name>fun</name>-&gt;<name>nargs</name></name> - <name>argc</name>))</expr></argument> &gt;</argument_list></name> <name><name>cx</name>-&gt;<name>stackPool</name>.<name>current</name>-&gt;<name>limit</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"can't trace calls with too few args requiring argv move"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Generate a type map for the outgoing frame and stash it in the LIR</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>stackSlots</name> <init>= <expr><call><name>NativeStackSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument> <comment type="block">/* callDepth */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FrameInfo</name>*</type> <name>fi</name> <init>= <expr>(<name>FrameInfo</name>*)
        <call><name>tempAlloc</name><argument_list>()</argument_list></call>.<call><name>alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name></expr></argument>)</argument_list></sizeof> + <name>stackSlots</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>TraceType</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TraceType</name>*</type> <name>typemap</name> <init>= <expr>(<name>TraceType</name>*)(<name>fi</name> + 1)</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>DetermineTypesVisitor</name></type> <name>detVisitor</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><name>typemap</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>detVisitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>argc</name> &lt; <name><name>FrameInfo</name>::<name>CONSTRUCTING_FLAG</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>gcthings</name>.<name>addUnique</name></name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fi</name>-&gt;<name>block</name></name> = <name><name>fp</name>-&gt;<name>blockChain</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>blockChain</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>tree</name>-&gt;<name>gcthings</name>.<name>addUnique</name></name><argument_list>(<argument><expr><call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>blockChain</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>fi</name>-&gt;<name>pc</name></name> = <name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fi</name>-&gt;<name>imacpc</name></name> = <name><name>fp</name>-&gt;<name>imacpc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fi</name>-&gt;<name>spdist</name></name> = <name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> - <name><name>fp</name>-&gt;<name>slots</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>fi</name>-&gt;<name>set_argc</name></name><argument_list>(<argument><expr><call><name>uint16</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>constructing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fi</name>-&gt;<name>callerHeight</name></name> = <name>stackSlots</name> - (2 + <name>argc</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fi</name>-&gt;<name>callerArgc</name></name> = <name><name>fp</name>-&gt;<name>argc</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>callDepth</name> &gt;= <name><name>tree</name>-&gt;<name>maxCallDepth</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tree</name>-&gt;<name>maxCallDepth</name></name> = <name>callDepth</name> + 1</expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>fi</name> = <call><name><name>traceMonitor</name>-&gt;<name>frameCache</name>-&gt;<name>memoize</name></name><argument_list>(<argument><expr><name>fi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>fi</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"out of memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>fi</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>rp</name></name></expr></argument>, <argument><expr><name>callDepth</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>FrameInfo</name>*</expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_RSTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_JIT_SPEW</name></expr></cpp:if>
    <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"iFC frameinfo=%p, stack=%d, map="</expr></argument>, <argument><expr>(<name>void</name>*)<name>fi</name></expr></argument>,
                      <argument><expr><name><name>fi</name>-&gt;<name>callerHeight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>fi</name>-&gt;<name>callerHeight</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr><call><name><name>fi</name>-&gt;<name>get_typemap</name></name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMTracer</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>atoms</name> = <name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>atomMap</name>.<name>vector</name></name></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALL</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>argc</name> <init>= <expr><call><name>GET_ARGC</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>assertValidStackDepth</name></name><argument_list>(<argument><expr><name>argc</name> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>functionCall</name><argument_list>(<argument><expr><name>argc</name></expr></argument>,
                                     <argument><expr>(<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name> &amp;&amp; *<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name> == <name>JSOP_APPLY</name>)
                                        ? <name>JSOP_APPLY</name>
                                        : <name>JSOP_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>jsbytecode</name>*</type> <name><name>apply_imacro_table</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name><name>apply_imacros</name>.<name>apply0</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>apply1</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>apply2</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>apply3</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>apply4</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>apply5</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>apply6</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>apply7</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>apply8</name></name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>jsbytecode</name>*</type> <name><name>call_imacro_table</name><index>[]</index></name> <init>= <expr><block>{
    <expr><name><name>apply_imacros</name>.<name>call0</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>call1</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>call2</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>call3</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>call4</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>call5</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>call6</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>call7</name></name></expr>,
    <expr><name><name>apply_imacros</name>.<name>call8</name></name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_APPLY</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name> <init>= <expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>argc</name> <init>= <expr><call><name>GET_ARGC</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>assertValidStackDepth</name></name><argument_list>(<argument><expr><name>argc</name> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name> <init>= <expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> - (<name>argc</name> + 2)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsuint</name></type> <name>length</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>aobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>aobj_ins</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>fp</name>-&gt;<name>imacpc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>VALUE_IS_FUNCTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>record_JSOP_CALL</name><argument_list>()</argument_list></call></expr>;</return></then></if>
    <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name> <init>= <expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>record_JSOP_CALL</name><argument_list>()</argument_list></call></expr>;</return></then></if>

    <decl_stmt><decl><type><name>bool</name></type> <name>apply</name> <init>= <expr>(<name>JSFastNative</name>)<name><name>fun</name>-&gt;<name>u</name>.<name>n</name>.<name>native</name></name> == <name>js_fun_apply</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>apply</name> &amp;&amp; (<name>JSFastNative</name>)<name><name>fun</name>-&gt;<name>u</name>.<name>n</name>.<name>native</name></name> != <name>js_fun_call</name></expr>)</condition><then>
        <return>return <expr><call><name>record_JSOP_CALL</name><argument_list>()</argument_list></call></expr>;</return></then></if>

    <comment type="block">/*
     * We don't trace apply and call with a primitive 'this', which is the
     * first positional parameter.
     */</comment>
    <if>if <condition>(<expr><name>argc</name> &gt; 0 &amp;&amp; !<call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>record_JSOP_CALL</name><argument_list>()</argument_list></call></expr>;</return></then></if>

    <comment type="block">/*
     * Guard on the identity of this, which is the function we are applying.
     */</comment>
    <if>if <condition>(<expr>!<call><name>VALUE_IS_FUNCTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"callee is not a function"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>guardCallee</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>apply</name> &amp;&amp; <name>argc</name> &gt;= 2</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>argc</name> != 2</expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"apply with excess arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"arguments parameter of apply is primitive"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>aobj</name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>aobj_ins</name> = <call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>vp</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We trace dense arrays and arguments objects. The code we generate
         * for apply uses imacros to handle a specific number of arguments.
         */</comment>
        <if>if <condition>(<expr><call><name><name>aobj</name>-&gt;<name>isDenseArray</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>guardDenseArray</name><argument_list>(<argument><expr><name>aobj</name></expr></argument>, <argument><expr><name>aobj_ins</name></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> = <call><name>jsuint</name><argument_list>(<argument><expr><name><name>aobj</name>-&gt;<name>fslots</name><index>[<expr><name>JSSLOT_ARRAY_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
                  <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>,
                             <argument><expr><call><name>p2i</name><argument_list>(<argument><expr><call><name>stobj_get_fslot</name><argument_list>(<argument><expr><name>aobj_ins</name></expr></argument>, <argument><expr><name>JSSLOT_ARRAY_LENGTH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name><name>aobj</name>-&gt;<name>isArguments</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>unsigned</name></type> <name>depth</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>afp</name> <init>= <expr><call><name>guardArguments</name><argument_list>(<argument><expr><name>aobj</name></expr></argument>, <argument><expr><name>aobj_ins</name></expr></argument>, <argument><expr>&amp;<name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>afp</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't reach arguments object's frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>length</name> = <name><name>afp</name>-&gt;<name>argc</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"arguments parameter of apply is not a dense array or argments object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>

        <if>if <condition>(<expr><name>length</name> &gt;= <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>apply_imacro_table</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"too many arguments to apply"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>apply_imacro_table</name><index>[<expr><name>length</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>argc</name> &gt;= <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>call_imacro_table</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"too many arguments to call"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>call_imacro_table</name><index>[<expr><name>argc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>CatchStopIteration_tn</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>ok</name></decl></param>, <param><decl><type><name>jsval</name>*</type> <name>vp</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>ok</name> &amp;&amp; <name><name>cx</name>-&gt;<name>throwing</name></name> &amp;&amp; <call><name>js_ValueIsStopIteration</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>exception</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>throwing</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>exception</name></name> = <name>JSVAL_VOID</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>vp</name> = <name>JSVAL_HOLE</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<macro><name>JS_DEFINE_TRCINFO_1</name><argument_list>(<argument>CatchStopIteration_tn</argument>,
    <argument>(3, (static, BOOL, CatchStopIteration_tn, CONTEXT, BOOL, JSVALPTR, 0, ACC_STORE_ANY))</argument>)</argument_list></macro>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_NativeCallComplete</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name>pendingSpecializedNative</name> == <name>IGNORE_NATIVE_CALL_COMPLETE_CALLBACK</name></expr>)</condition><then>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>jsbytecode</name>*</type> <name>pc</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pendingSpecializedNative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>pc</name> == <name>JSOP_CALL</name> || *<name>pc</name> == <name>JSOP_APPLY</name> || *<name>pc</name> == <name>JSOP_NEW</name> || *<name>pc</name> == <name>JSOP_SETPROP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * At this point the generated code has already called the native function
     * and we can no longer fail back to the original pc location (JSOP_CALL)
     * because that would cause the interpreter to re-execute the native
     * function, which might have side effects.
     *
     * Instead, the snapshot() call below sees that we are currently parked on
     * a traceable native's JSOP_CALL instruction, and it will advance the pc
     * to restore by the length of the current opcode.  If the native's return
     * type is jsval, snapshot() will also indicate in the type map that the
     * element on top of the stack is a boxed value which doesn't need to be
     * boxed if the type guard generated by unbox_jsval() fails.
     */</comment>

    <if>if <condition>(<expr><call><name>JSTN_ERRTYPE</name><argument_list>(<argument><expr><name>pendingSpecializedNative</name></expr></argument>)</argument_list></call> == <name>FAIL_STATUS</name></expr>)</condition><then> <block>{
        <comment type="block">/* Keep cx-&gt;bailExit null when it's invalid. */</comment>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cx_ins</name></expr></argument>, <argument><expr>(<name>int</name>) <call><name>offsetof</name><argument_list>(<argument><expr><name>JSContext</name></expr></argument>, <argument><expr><name>bailExit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>status</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>,
                                    <argument><expr>(<name>int</name>) <call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>builtinStatus</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>pendingSpecializedNative</name> == &amp;<name>generatedSpecializedNative</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name> <init>= <expr><name>v_ins</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * Custom implementations of Iterator.next() throw a StopIteration exception.
             * Catch and clear it and set the return value to JSVAL_HOLE in this case.
             */</comment>
            <if>if <condition>(<expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>pc</name> - <name><name>nextiter_imacros</name>.<name>custom_iter_next</name></name></expr></argument>)</argument_list></call> &lt;
                <sizeof>sizeof<argument_list>(<argument><expr><name><name>nextiter_imacros</name>.<name>custom_iter_next</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>native_rval_ins</name></expr>, <expr><name>ok_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt> <comment type="block">/* reverse order */</comment>
                <expr_stmt><expr><name>ok_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>CatchStopIteration_tn_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/*
             * If we run a generic traceable native, the return value is in the argument
             * vector for native function calls. The actual return value of the native is a JSBool
             * indicating the error status.
             */</comment>
            <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>native_rval_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>*<name>pc</name> == <name>JSOP_NEW</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piand</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr><name>JSVAL_TAGMASK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>ins_choose</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>avmplus</name>::<name>AvmCore</name>::<name>use_cmov</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins_choose</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newobj_ins</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><call><name><name>avmplus</name>::<name>AvmCore</name>::<name>use_cmov</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>propagateFailureToBuiltinStatus</name><argument_list>(<argument><expr><name>ok_ins</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STATUS_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>pendingSpecializedNative</name>-&gt;<name>flags</name></name> &amp; <name>JSTN_UNBOX_AFTER</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If we side exit on the unboxing code due to a type change, make sure that the boxed
         * value is actually currently associated with that location, and that we are talking
         * about the top of the stack here, which is where we expected boxed values.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>&amp;<name>v</name> == &amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name><index>[<expr>-1</expr>]</index></name> &amp;&amp; <call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call> == <name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name>unbox_jsval</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSTN_ERRTYPE</name><argument_list>(<argument><expr><name>pendingSpecializedNative</name></expr></argument>)</argument_list></call> == <name>FAIL_NEG</name></expr>)</condition><then> <block>{
        <comment type="block">/* Already added i2f in functionCall. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_NUMBER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/* Convert the result to double if the builtin returns int32. */</comment>
        <if>if <condition>(<expr><call><name>JSVAL_IS_NUMBER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp;
            <call><name><name>pendingSpecializedNative</name>-&gt;<name>builtin</name>-&gt;<name>returnType</name></name><argument_list>()</argument_list></call> == <name>ARGTYPE_I</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if></else></if>

    <comment type="line">// We'll null pendingSpecializedNative in monitorRecording, on the next op</comment>
    <comment type="line">// cycle.  There must be a next op since the stack is non-empty.</comment>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>name</name></name><parameter_list>(<param><decl><type><name>jsval</name>*&amp;</type> <name>vp</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>ins</name></decl></param>, <param><decl><type><name>NameResult</name>&amp;</type> <name>nr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>obj</name> != <name>globalObj</name></expr>)</condition><then>
        <return>return <expr><call><name>scopeChainProp</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <comment type="block">/* Can't use prop here, because we don't want unboxing from global slots. */</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PCVal</name></type> <name>pcval</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Property cache ensures that we are dealing with an existing property,
     * and guards the shape for us.
     */</comment>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>test_property_cache</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>pcval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Abort if property doesn't exist (interpreter will report an error.) */</comment>
    <if>if <condition>(<expr><call><name><name>pcval</name>.<name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"named property not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Insist on obj being the directly addressed object. */</comment>
    <if>if <condition>(<expr><name>obj2</name> != <name>obj</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"name() hit prototype chain"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* Don't trace getter or setter calls, our caller wants a direct slot. */</comment>
    <if>if <condition>(<expr><call><name><name>pcval</name>.<name>isSprop</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name> <init>= <expr><call><name><name>pcval</name>.<name>toSprop</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>isValidSlot</name><argument_list>(<argument><expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"name() not accessing a valid slot"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>slot</name> = <name><name>sprop</name>-&gt;<name>slot</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<call><name><name>pcval</name>.<name>isSlot</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"PCE is not a slot"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>slot</name> = <call><name><name>pcval</name>.<name>toSlot</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr>!<call><name>lazilyImportGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"lazy import of global slot failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>vp</name> = &amp;<call><name><name>obj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ins</name> = <call><name>get</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nr</name>.<name>tracked</name></name> = true</expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSObject</name>* <name>FASTCALL</name></type>
<name>MethodReadBarrier</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>funobj</name></decl></param>)</parameter_list>
<block>{
    <function_decl><type><name>AutoValueRooter</name></type> <name>tvr</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>funobj</name></type></decl></param>)</parameter_list>;</function_decl>

    <if>if <condition>(<expr>!<call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<call><name>methodReadBarrier</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>sprop</name></expr></argument>, <argument><expr><call><name><name>tvr</name>.<name>addr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>VALUE_IS_FUNCTION</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>tvr</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><call><name><name>tvr</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_4</name><argument_list>(<argument>static</argument>, <argument>OBJECT_FAIL</argument>, <argument>MethodReadBarrier</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>SCOPEPROP</argument>, <argument>OBJECT</argument>,
                     <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<comment type="block">/*
 * Get a property. The current opcode has JOF_ATOM.
 *
 * There are two modes. The caller must pass nonnull pointers for either outp
 * or both slotp and v_insp. In the latter case, we require a plain old
 * property with a slot; if the property turns out to be anything else, abort
 * tracing (rather than emit a call to a native getter or GetAnyProperty).
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>prop</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>uint32</name> *</type><name>slotp</name></decl></param>, <param><decl><type><name>LIns</name>**</type> <name>v_insp</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>outp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>slotp</name> &amp;&amp; <name>v_insp</name> &amp;&amp; !<name>outp</name>) || (!<name>slotp</name> &amp;&amp; !<name>v_insp</name> &amp;&amp; <name>outp</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Can't specialize to assert obj != global, must guard to avoid aliasing
     * stale homes of stacked global variables.
     */</comment>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>guardNotGlobalObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Property cache ensures that we are dealing with an existing property,
     * and guards the shape for us.
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PCVal</name></type> <name>pcval</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>test_property_cache</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>pcval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check for non-existent property reference, which results in undefined. */</comment>
    <if>if <condition>(<expr><call><name><name>pcval</name>.<name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>slotp</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"property not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="block">/*
         * We could specialize to guard on just JSClass.getProperty, but a mere
         * class guard is simpler and slightly faster.
         */</comment>
        <if>if <condition>(<expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>getProperty</name> != <name>JS_PropertyStub</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't trace through access to undefined property if "
                          "JSClass.getProperty hook isn't stubbed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>guardClass</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * This trace will be valid as long as neither the object nor any object
         * on its prototype chain changes shape.
         *
         * FIXME: This loop can become a single shape guard once bug 497789 has
         * been fixed.
         */</comment>
        <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <do>do <block>{
            <if>if <condition>(<expr><call><name>OBJ_IS_NATIVE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>guardShape</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>OBJ_SHAPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr>"guard(shape)"</expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr>!<call><name>guardDenseArray</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"non-native object involved in undefined property access"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block> while <condition>(<expr><call><name>guardHasPrototype</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>, <argument><expr>&amp;<name>obj_ins</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>outp</name></expr></argument>, <argument><expr><call><name>INS_VOID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>propTail</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>pcval</name></expr></argument>, <argument><expr><name>slotp</name></expr></argument>, <argument><expr><name>v_insp</name></expr></argument>, <argument><expr><name>outp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>propTail</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj2</name></decl></param>, <param><decl><type><name>PCVal</name></type> <name>pcval</name></decl></param>,
                        <param><decl><type><name>uint32</name> *</type><name>slotp</name></decl></param>, <param><decl><type><name>LIns</name>**</type> <name>v_insp</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>outp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name>&amp;</type> <name>cs</name> <init>= <expr><name><name>js_CodeSpec</name><index>[<expr>*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>setflags</name> <init>= <expr>(<name><name>cs</name>.<name>format</name></name> &amp; (<name>JOF_INCDEC</name> | <name>JOF_FOR</name>))</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!(<name><name>cs</name>.<name>format</name></name> &amp; <name>JOF_SET</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSScopeProperty</name>*</type> <name>sprop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>isMethod</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>pcval</name>.<name>isSprop</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>sprop</name> = <call><name><name>pcval</name>.<name>toSprop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call>-&gt;<call><name>hasProperty</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>setflags</name> &amp;&amp; !<call><name><name>sprop</name>-&gt;<name>hasDefaultSetter</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"non-stub setter"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>setflags</name> &amp;&amp; !<call><name><name>sprop</name>-&gt;<name>writable</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"writing to a readonly property"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr>!<call><name><name>sprop</name>-&gt;<name>hasDefaultGetterOrIsMethod</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>slotp</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't trace non-stub getter for this opcode"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><call><name><name>sprop</name>-&gt;<name>hasGetterValue</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"script getter"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name><name>sprop</name>-&gt;<name>slot</name></name> == <name>SPROP_INVALID_SLOT</name></expr>)</condition><then>
                <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>getPropertyWithNativeGetter</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>sprop</name></expr></argument>, <argument><expr><name>outp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
            <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>getPropertyById</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>outp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!<call><name>SPROP_HAS_VALID_SLOT</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>, <argument><expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"no valid slot"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>slot</name> = <name><name>sprop</name>-&gt;<name>slot</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>isMethod</name> = <call><name><name>sprop</name>-&gt;<name>isMethod</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>isMethod</name></expr></argument>, <argument><expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call>-&gt;<call><name>hasMethodBarrier</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<call><name><name>pcval</name>.<name>isSlot</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"PCE is not a slot"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>slot</name> = <call><name><name>pcval</name>.<name>toSlot</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sprop</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>isMethod</name> = false</expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* We have a slot. Check whether it is direct or in a prototype. */</comment>
    <if>if <condition>(<expr><name>obj2</name> != <name>obj</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>setflags</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"JOF_INCDEC|JOF_FOR opcode hit prototype chain"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="block">/*
         * We're getting a prototype property. Two cases:
         *
         * 1. If obj2 is obj's immediate prototype we must walk up from obj,
         * since direct and immediate-prototype cache hits key on obj's shape,
         * not its identity.
         *
         * 2. Otherwise obj2 is higher up the prototype chain and we've keyed
         * on obj's identity, and since setting __proto__ reshapes all objects
         * along the old prototype chain, then provided we shape-guard obj2,
         * we can "teleport" directly to obj2 by embedding it as a constant
         * (this constant object instruction will be CSE'ed with the constant
         * emitted by test_property_cache, whose shape is guarded).
         */</comment>
        <expr_stmt><expr><name>obj_ins</name> = (<name>obj2</name> == <call><name><name>obj</name>-&gt;<name>getProto</name></name><argument_list>()</argument_list></call>) ? <call><name>stobj_get_proto</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call> : <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>obj</name> = <name>obj2</name></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>dslots_ins</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name>unbox_jsval</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>getSlot</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>stobj_get_slot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Joined function object stored as a method must be cloned when extracted
     * as a property value other than a callee. Note that shapes cover method
     * value as well as other property attributes and order, so this condition
     * is trace-invariant.
     *
     * We do not impose the method read barrier if in an imacro, assuming any
     * property gets it does (e.g., for 'toString' from JSOP_NEW) will not be
     * leaked to the calling script.
     */</comment>
    <if>if <condition>(<expr><name>isMethod</name> &amp;&amp; !<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>v_ins</name></expr>, <expr><call><name>INS_CONSTSPROP</name><argument_list>(<argument><expr><name>sprop</name></expr></argument>)</argument_list></call></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>MethodReadBarrier_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leaveDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>slotp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>slotp</name> = <name>slot</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>v_insp</name> = <name>v_ins</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>outp</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>outp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>denseArrayElement</name></name><parameter_list>(<param><decl><type><name>jsval</name>&amp;</type> <name>oval</name></decl></param>, <param><decl><type><name>jsval</name>&amp;</type> <name>ival</name></decl></param>, <param><decl><type><name>jsval</name>*&amp;</type> <name>vp</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>v_ins</name></decl></param>,
                                 <param><decl><type><name>LIns</name>*&amp;</type> <name>addr_ins</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name>oval</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>oval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>oval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>idx</name> <init>= <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>idx_ins</name> <init>= <expr><call><name>makeNumberInt32</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>ival</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>pidx_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins_u2p</name></name><argument_list>(<argument><expr><name>idx_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check that the index is within bounds */</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>dslots_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSObject</name></expr></argument>, <argument><expr><name>dslots</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsuint</name></type> <name>capacity</name> <init>= <expr><call><name>js_DenseArrayCapacity</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>within</name> <init>= <expr>(<call><name>jsuint</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call> &lt; <call><name>jsuint</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>fslots</name><index>[<expr><name>JSSLOT_ARRAY_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>jsuint</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call> &lt; <name>capacity</name>)</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>within</name></expr>)</condition><then> <block>{
        <comment type="block">/* If idx &lt; 0, stay on trace (and read value as undefined, since this is a dense array). */</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>br1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>MAX_DSLOTS_LENGTH</name> &gt; <name>MAX_DSLOTS_LENGTH32</name> &amp;&amp; !<call><name><name>idx_ins</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* Only 64-bit machines support large enough arrays for this. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof> == 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>br1</name> = <call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>,
                                 <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_lt</name></expr></argument>, <argument><expr><name>idx_ins</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* If not idx &lt; length, stay on trace (and read value as undefined). */</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>br2</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>,
                                   <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_pult</name></expr></argument>,
                                             <argument><expr><name>pidx_ins</name></expr></argument>,
                                             <argument><expr><call><name>stobj_get_fslot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>JSSLOT_ARRAY_LENGTH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If dslots is NULL, stay on trace (and read value as undefined). */</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>br3</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>dslots_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If not idx &lt; capacity, stay on trace (and read value as undefined). */</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>br4</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>,
                                   <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_pult</name></expr></argument>,
                                             <argument><expr><name>pidx_ins</name></expr></argument>,
                                             <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>,
                                                          <argument><expr>-(<name>int</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>LIR_x</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>createGuardRecord</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>label</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>br1</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>br1</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name><name>br2</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>br3</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>br4</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>guardPrototypeHasNoIndexedProperties</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Return undefined and indicate that we didn't actually read this (addr_ins).</comment>
        <expr_stmt><expr><name>v_ins</name> = <call><name>INS_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>addr_ins</name> = <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Guard against negative index */</comment>
    <if>if <condition>(<expr><name>MAX_DSLOTS_LENGTH</name> &gt; <name>MAX_DSLOTS_LENGTH32</name> &amp;&amp; !<call><name><name>idx_ins</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Only 64-bit machines support large enough arrays for this. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof> == 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>,
              <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_lt</name></expr></argument>, <argument><expr><name>idx_ins</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Guard array length */</comment>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
          <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_pult</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr><call><name>stobj_get_fslot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>JSSLOT_ARRAY_LENGTH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* dslots must not be NULL */</comment>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>,
          <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>dslots_ins</name></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Guard array capacity */</comment>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
          <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_pult</name></expr></argument>,
                    <argument><expr><name>pidx_ins</name></expr></argument>,
                    <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>, <argument><expr>0 - (<name>int</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Load the value and guard on its type to unbox it. */</comment>
    <expr_stmt><expr><name>vp</name> = &amp;<name><name>obj</name>-&gt;<name>dslots</name><index>[<expr><call><name>jsuint</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>,
                         <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>(<sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof> == 4) ? 2 : 3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v_ins</name> = <call><name>unbox_jsval</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If we read a hole from the array, convert it to undefined and guard
         * that there are no indexed properties along the prototype chain.
         */</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>br</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>,
                                  <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>JSVAL_HOLE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CHECK_STATUS</name><argument_list>(<argument><expr><call><name>guardPrototypeHasNoIndexedProperties</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>br</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Don't let the hole value escape. Turn it into an undefined. */</comment>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_and</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr>~(<name>JSVAL_HOLE_FLAG</name> &gt;&gt; <name>JSVAL_TAGBITS</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>typedArrayElement</name></name><parameter_list>(<param><decl><type><name>jsval</name>&amp;</type> <name>oval</name></decl></param>, <param><decl><type><name>jsval</name>&amp;</type> <name>ival</name></decl></param>, <param><decl><type><name>jsval</name>*&amp;</type> <name>vp</name></decl></param>, <param><decl><type><name>LIns</name>*&amp;</type> <name>v_ins</name></decl></param>,
                                 <param><decl><type><name>LIns</name>*&amp;</type> <name>addr_ins</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name>oval</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>oval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>oval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>idx</name> <init>= <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>idx_ins</name> <init>= <expr><call><name>makeNumberInt32</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>ival</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>pidx_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins_u2p</name></name><argument_list>(<argument><expr><name>idx_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>js</name>::<name>TypedArray</name></name>*</type> <name>tarray</name> <init>= <expr><call><name><name>js</name>::<name>TypedArray</name>::<name>fromJSObject</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* priv_ins will load the TypedArray* */</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>priv_ins</name> <init>= <expr><call><name>stobj_get_const_fslot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>JSSLOT_PRIVATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* for out-of-range, do the same thing that the interpreter does, which is return undefined */</comment>
    <if>if <condition>(<expr>(<name>jsuint</name>) <name>idx</name> &gt;= <name><name>tarray</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>,
              <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ult</name></expr></argument>,
                        <argument><expr><name>idx_ins</name></expr></argument>,
                        <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>priv_ins</name></expr></argument>, <argument><expr><call><name><name>js</name>::<name>TypedArray</name>::<name>lengthOffset</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name>INS_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Ensure idx &lt; length
     *
     * NOTE! mLength is uint32, but it's guaranteed to fit in a jsval
     * int, so we can treat it as either signed or unsigned.
     * If the index happens to be negative, when it's treated as
     * unsigned it'll be a very large int, and thus won't be less than
     * length.
     */</comment>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
          <argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_ult</name></expr></argument>,
                    <argument><expr><name>idx_ins</name></expr></argument>,
                    <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>priv_ins</name></expr></argument>, <argument><expr><call><name><name>js</name>::<name>TypedArray</name>::<name>lengthOffset</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We are now ready to load.  Do a different type of load
     * depending on what type of thing we're loading. */</comment>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>data_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><name>priv_ins</name></expr></argument>, <argument><expr><call><name><name>js</name>::<name>TypedArray</name>::<name>dataOffset</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>tarray</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
      <case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_INT8</name></name></expr>:
        <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldsb</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT8</name></name></expr>:
      </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT8_CLAMPED</name></name></expr>:
        <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_u2f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldzb</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_INT16</name></name></expr>:
        <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldss</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT16</name></name></expr>:
        <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_u2f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldzs</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_INT32</name></name></expr>:
        <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_UINT32</name></name></expr>:
        <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_u2f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_FLOAT32</name></name></expr>:
        <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld32f</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name><name>js</name>::<name>TypedArray</name>::<name>TYPE_FLOAT64</name></name></expr>:
        <expr_stmt><expr><name>addr_ins</name> = <call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piadd</name></expr></argument>, <argument><expr><name>data_ins</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_pilsh</name></expr></argument>, <argument><expr><name>pidx_ins</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldf</name></expr></argument>, <argument><expr><name>addr_ins</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"Unknown typed array type in tracer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>

    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>getProp</name></name><parameter_list>(<param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name> <init>= <expr><call><name>JSOp</name><argument_list>(<argument><expr>*<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name>&amp;</type> <name>cs</name> <init>= <expr><name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cs</name>.<name>ndefs</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>prop</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<call><name>stackval</name><argument_list>(<argument><expr>-<name><name>cs</name>.<name>nuses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>getProp</name></name><parameter_list>(<param><decl><type><name>jsval</name>&amp;</type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"primitive lhs"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><call><name>getProp</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NAME</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameResult</name></type> <name>nr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>name</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DOUBLE</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name> <init>= <expr><call><name>jsval</name><argument_list>(<argument><expr><name><name>atoms</name><index>[<expr><call><name>GET_INDEX</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr>*<call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_STRING</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSAtom</name>*</type> <name>atom</name> <init>= <expr><name><name>atoms</name><index>[<expr><call><name>GET_INDEX</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>ATOM_IS_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_ATOM</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ZERO</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ONE</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NULL</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_THIS</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>this_ins</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>getThis</name><argument_list>(<argument><expr><name>this_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>this_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_FALSE</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TRUE</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_OR</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>ifop</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_AND</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>ifop</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TABLESWITCH</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NANOJIT_IA32</name></cpp:ifdef>
    <comment type="block">/* Handle tableswitches specially -- prepare a jump table if needed. */</comment>
    <return>return <expr><call><name>tableswitch</name><argument_list>()</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>switchop</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LOOKUPSWITCH</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>switchop</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_STRICTEQ</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>strictEquality</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_STRICTNE</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>strictEquality</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_OBJECT</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name>*</type> <name>script</name> <init>= <expr><name><name>fp</name>-&gt;<name>script</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>index</name> <init>= <expr><name>atoms</name> - <name><name>script</name>-&gt;<name>atomMap</name>.<name>vector</name></name> + <call><name>GET_INDEX</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>obj</name> = <call><name><name>script</name>-&gt;<name>getObject</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_POP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TRAP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETARG</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>arg</name><argument_list>(<argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETARG</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>arg</name><argument_list>(<argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>stack</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETLOCAL</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>var</name><argument_list>(<argument><expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETLOCAL</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>var</name><argument_list>(<argument><expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>stack</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_UINT16</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><call><name>GET_UINT16</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NEWINIT</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSProtoKey</name></type> <name>key</name> <init>= <expr><call><name>JSProtoKey</name><argument_list>(<argument><expr><call><name>GET_INT8</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>proto_ins</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>getClassPrototype</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>proto_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>proto_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>CallInfo</name> *</type><name>ci</name> <init>= <expr>(<name>key</name> == <name>JSProto_Array</name>)
                         ? &amp;<name>js_NewEmptyArray_ci</name>
                         : (<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name><index>[<expr><name>JSOP_NEWINIT_LENGTH</name></expr>]</index></name> != <name>JSOP_ENDINIT</name>)
                         ? &amp;<name>js_NonEmptyObject_ci</name>
                         : &amp;<name>js_Object_tn_ci</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ENDINIT</name></name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INITPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// All the action is in record_SetPropHit.</comment>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INITELEM</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>setElem</name><argument_list>(<argument><expr>-3</expr></argument>, <argument><expr>-2</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEFSHARP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_USESHARP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INCARG</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name>argval</name><argument_list>(<argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INCLOCAL</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name>varval</name><argument_list>(<argument><expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DECARG</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name>argval</name><argument_list>(<argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DECLOCAL</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name>varval</name><argument_list>(<argument><expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ARGINC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name>argval</name><argument_list>(<argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LOCALINC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name>varval</name><argument_list>(<argument><expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ARGDEC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name>argval</name><argument_list>(<argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LOCALDEC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name>varval</name><argument_list>(<argument><expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_IMACOP</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ITER</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"for-in on a primitive value"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>jsuint</name></type> <name>flags</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RecordingStatus</name></type> <name>status</name> <init>= <expr><call><name>hasIteratorMethod</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>status</name> != <name>RECORD_CONTINUE</name></expr>)</condition><then>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr><name>found</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>flags</name> == <name>JSITER_ENUMERATE</name></expr>)</condition><then>
            <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>iter_imacros</name>.<name>for_in</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><name>flags</name> == (<name>JSITER_ENUMERATE</name> | <name>JSITER_FOREACH</name>)</expr>)</condition><then>
            <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>iter_imacros</name>.<name>for_each</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr><name>flags</name> == <name>JSITER_ENUMERATE</name></expr>)</condition><then>
            <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>iter_imacros</name>.<name>for_in_native</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><name>flags</name> == (<name>JSITER_ENUMERATE</name> | <name>JSITER_FOREACH</name>)</expr>)</condition><then>
            <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>iter_imacros</name>.<name>for_each_native</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"unimplemented JSITER_* flags"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NEXTITER</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>iterobj_val</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>iterobj_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"for-in on a primitive value"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>RETURN_IF_XML_A</name><argument_list>(<argument><expr><name>iterobj_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>iterobj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>iterobj_val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSClass</name>*</type> <name>clasp</name> <init>= <expr><call><name><name>iterobj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>iterobj_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>iterobj_val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guardClass</name><argument_list>(<argument><expr><name>iterobj</name></expr></argument>, <argument><expr><name>iterobj_ins</name></expr></argument>, <argument><expr><name>clasp</name></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>clasp</name> == &amp;<name>js_IteratorClass</name> || <name>clasp</name> == &amp;<name>js_GeneratorClass</name></expr>)</condition><then>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>nextiter_imacros</name>.<name>native_iter_next</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>nextiter_imacros</name>.<name>custom_iter_next</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ENDITER</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>stack</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>ok_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_CloseIterator_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>ok_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_FORNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>x_ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameResult</name></type> <name>nr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>name</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>x_ins</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>nr</name>.<name>tracked</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"forname on non-tracked value not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><call><name>stack</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_FORPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_FORELEM</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_DUP</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_FORARG</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_SETARG</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_FORLOCAL</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_SETLOCAL</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_POPN</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Generate LIR to reach |obj2| from |obj| by traversing the scope chain. The
 * generated code also ensures that any call objects found have not changed shape.
 *
 *      obj               starting object
 *      obj_ins           LIR instruction representing obj
 *      targetObj         end object for traversal
 *      targetIns [out]   LIR instruction representing obj2
 */</comment>
<function><type><name>JS_REQUIRES_STACK</name> <name>RecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>traverseScopeChain</name></name><parameter_list>(<param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>obj_ins</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>targetObj</name></decl></param>,
                                  <param><decl><type><name>LIns</name> *&amp;</type><name>targetIns</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>VMSideExit</name>*</type> <name>exit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Scope chains are often left "incomplete", and reified lazily when
     * necessary, since doing so is expensive. When creating null and flat
     * closures on trace (the only kinds supported), the global object is
     * hardcoded as the parent, since reifying the scope chain on trace
     * would be extremely difficult. This is because block objects need frame
     * pointers, which do not exist on trace, and thus would require magic
     * similar to arguments objects or reification of stack frames. Luckily,
     * for null and flat closures, these blocks are unnecessary.
     *
     * The problem, as exposed by bug 523793, is that this means creating a
     * fixed traversal on trace can be inconsistent with the shorter scope
     * chain used when executing a trace. To address this, perform an initial
     * sweep of the scope chain to make sure that if there is a heavyweight
     * function with a call object, and there is also a block object, the
     * trace is safely aborted.
     *
     * If there is no call object, we must have arrived at the global object,
     * and can bypass the scope chain traversal completely.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>foundCallObj</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>foundBlockObj</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>searchObj</name> <init>= <expr><name>obj</name></expr></init></decl>;</decl_stmt>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <if>if <condition>(<expr><name>searchObj</name> != <name>globalObj</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSClass</name>*</type> <name>cls</name> <init>= <expr><call><name><name>searchObj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>cls</name> == &amp;<name>js_BlockClass</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>foundBlockObj</name> = true</expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>cls</name> == &amp;<name>js_CallClass</name> &amp;&amp;
                       <call><name>JSFUN_HEAVYWEIGHT_TEST</name><argument_list>(<argument><expr><call><name>js_GetCallObjectFunction</name><argument_list>(<argument><expr><name>searchObj</name></expr></argument>)</argument_list></call>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>foundCallObj</name> = true</expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></then></if>

        <if>if <condition>(<expr><name>searchObj</name> == <name>targetObj</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <expr_stmt><expr><name>searchObj</name> = <call><name><name>searchObj</name>-&gt;<name>getParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>searchObj</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"cannot traverse this scope chain on trace"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>

    <if>if <condition>(<expr>!<name>foundCallObj</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>targetObj</name> == <name>globalObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targetIns</name> = <call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>foundBlockObj</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"cannot traverse this scope chain on trace"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* There was a call object, or should be a call object now. */</comment>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <if>if <condition>(<expr><name>obj</name> != <name>globalObj</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_IsCacheableNonGlobalScope</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP</name><argument_list>(<argument><expr>"scope chain lookup crosses non-cacheable object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <comment type="line">// We must guard on the shape of all call objects for heavyweight functions</comment>
            <comment type="line">// that we traverse on the scope chain: if the shape changes, a variable with</comment>
            <comment type="line">// the same name may have been inserted in the scope chain.</comment>
            <if>if <condition>(<expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> == &amp;<name>js_CallClass</name> &amp;&amp;
                <call><name>JSFUN_HEAVYWEIGHT_TEST</name><argument_list>(<argument><expr><call><name>js_GetCallObjectFunction</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>LIns</name>*</type> <name>map_ins</name> <init>= <expr><call><name>map</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>LIns</name>*</type> <name>shape_ins</name> <init>= <expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>, <argument><expr><name>map_ins</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSScope</name></expr></argument>, <argument><expr><name>shape</name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr>"obj_shape"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<name>exit</name></expr>)</condition><then>
                    <expr_stmt><expr><name>exit</name> = <call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>,
                      <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>shape_ins</name></expr></argument>, <argument><expr><call><name>OBJ_SHAPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"guard_shape"</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> != &amp;<name>js_BlockClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>obj</name> == <name>targetObj</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <expr_stmt><expr><name>obj</name> = <call><name><name>obj</name>-&gt;<name>getParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>obj_ins</name> = <call><name>stobj_get_parent</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><name>targetIns</name> = <name>obj_ins</name></expr>;</expr_stmt>
    <return>return <expr><name>RECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_BINDNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>fp</name>-&gt;<name>fun</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>obj</name> = <name><name>fp</name>-&gt;<name>scopeChain</name></name></expr>;</expr_stmt>

        <comment type="line">// In global code, fp-&gt;scopeChain can only contain blocks whose values</comment>
        <comment type="line">// are still on the stack.  We never use BINDNAME to refer to these.</comment>
        <while>while <condition>(<expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> == &amp;<name>js_BlockClass</name></expr>)</condition> <block>{
            <comment type="line">// The block's values are still on the stack.</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>obj</name>-&gt;<name>getPrivate</name></name><argument_list>()</argument_list></call> == <name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>obj</name> = <call><name><name>obj</name>-&gt;<name>getParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Blocks always have parents.</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr><name>obj</name> != <name>globalObj</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"BINDNAME in global code resolved to non-global object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="block">/*
         * The trace is specialized to this global object. Furthermore, we know it
         * is the sole 'global' object on the scope chain: we set globalObj to the
         * scope chain element with no parent, and we reached it starting from the
         * function closure or the current scopeChain, so there is nothing inner to
         * it. Therefore this must be the right base object.
         */</comment>
        <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// We can't trace BINDNAME in functions that contain direct calls to eval,</comment>
    <comment type="line">// as they might add bindings which previously-traced references would have</comment>
    <comment type="line">// to see.</comment>
    <if>if <condition>(<expr><call><name>JSFUN_HEAVYWEIGHT_TEST</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"BINDNAME in heavyweight function."</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// We don't have the scope chain on trace, so instead we get a start object</comment>
    <comment type="line">// that is on the scope chain and doesn't skip the target object (the one</comment>
    <comment type="line">// that contains the property).</comment>
    <decl_stmt><decl><type><name>jsval</name> *</type><name>callee</name> <init>= <expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>obj</name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr>*<name>callee</name></expr></argument>)</argument_list></call>-&gt;<call><name>getParent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>obj</name> == <name>globalObj</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>obj_ins</name> <init>= <expr><call><name>stobj_get_parent</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr><name>callee</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// Find the target object.</comment>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name> <init>= <expr><name><name>atoms</name><index>[<expr><call><name>GET_INDEX</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsid</name></type> <name>id</name> <init>= <expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj2</name> <init>= <expr><call><name>js_FindIdentifierBase</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>scopeChain</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>obj2</name> != <name>globalObj</name> &amp;&amp; <call><name><name>obj2</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call> != &amp;<name>js_CallClass</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"BINDNAME on non-global, non-call object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// Generate LIR to get to the target object from the start object.</comment>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>obj2_ins</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>traverseScopeChain</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>obj2_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// If |obj2| is the global object, we can refer to it directly instead of walking up</comment>
    <comment type="line">// the scope chain. There may still be guards on intervening call objects.</comment>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>obj2</name> == <name>globalObj</name> ? <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call> : <name>obj2_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Trace only cases that are global code, in lightweight functions
     * scoped by the global object only, or in call objects.
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> == &amp;<name>js_CallClass</name></expr>)</condition><then>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>obj</name> != <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name></name> || <name>obj</name> != <name>globalObj</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"JSOP_SETNAME left operand is not the global object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// The rest of the work is in record_SetPropHit.</comment>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_THROW</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_IN</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>rval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>lval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"JSOP_IN on non-object right operand"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>rval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>jsid</name></type> <name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>id</name> = <call><name>INT_JSVAL_TO_JSID</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>makeNumberInt32</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_HasNamedPropertyInt32_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>js_ValueToStringId</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_ERROR_A</name><argument_list>(<argument><expr>"left operand of JSOP_IN didn't convert to a string-id"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>)</argument_list></call></expr>, <expr><name>obj_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_HasNamedProperty_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"string or integer expected"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>JSVAL_VOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> = <call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>TraceMonitor</name> &amp;</type><name>localtm</name> <init>= <expr>*<name>traceMonitor</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>localcx</name> <init>= <expr><name>cx</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSProperty</name>*</type> <name>prop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name> <init>= <expr><call><name><name>obj</name>-&gt;<name>lookupProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr>&amp;<name>obj2</name></expr></argument>, <argument><expr>&amp;<name>prop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* lookupProperty can reenter the interpreter and kill |this|. */</comment>
    <if>if <condition>(<expr>!<name><name>localtm</name>.<name>recorder</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>prop</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>obj2</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>localcx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_ERROR_A</name><argument_list>(<argument><expr>"obj-&gt;lookupProperty failed in JSOP_IN"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <decl_stmt><decl><type><name>bool</name></type> <name>cond</name> <init>= <expr><name>prop</name> != <name>NULL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>prop</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>obj2</name>-&gt;<name>dropProperty</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
     * The interpreter fuses comparisons and the following branch, so we have
     * to do that here as well.
     */</comment>
    <expr_stmt><expr><call><name>fuseIf</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> + 1</expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We update the stack after the guard. This is safe since the guard bails
     * out at the comparison and the interpreter will therefore re-execute the
     * comparison. This way the value of the condition doesn't have to be
     * calculated and saved on the stack in most cases.
     */</comment>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>lval</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name> <name>FASTCALL</name></type>
<name>HasInstance</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>ctor</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>val</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>result</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name><name>ctor</name>-&gt;<name>map</name>-&gt;<name>ops</name>-&gt;<name>hasInstance</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ctor</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>
<macro><name>JS_DEFINE_CALLINFO_3</name><argument_list>(<argument>static</argument>, <argument>BOOL_FAIL</argument>, <argument>HasInstance</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>JSVAL</argument>, <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INSTANCEOF</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// If the rhs isn't an object, we are headed for a TypeError.</comment>
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>ctor</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>ctor</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"non-object on rhs of instanceof"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>val</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>val_ins</name> <init>= <expr><call><name>box_jsval</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>enterDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{<expr><name>val_ins</name></expr>, <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>ctor</name></expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>-2</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>HasInstance_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>status_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>,
                                    <argument><expr><name><name>lirbuf</name>-&gt;<name>state</name></name></expr></argument>,
                                    <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>InterpState</name></expr></argument>, <argument><expr><name>builtinStatus</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pendingGuardCondition</name> = <call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>status_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>leaveDeepBailCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEBUGGER</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GOSUB</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_RETSUB</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_EXCEPTION</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LINENO</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CONDSWITCH</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CASE</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>strictEquality</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEFAULT</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_EVAL</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ENUMELEM</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/*
     * To quote from jsops.cpp's JSOP_ENUMELEM case:
     * Funky: the value to set is under the [obj, id] pair.
     */</comment>
    <return>return <expr><call><name>setElem</name><argument_list>(<argument><expr>-2</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>-3</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETTER</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETTER</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEFFUN</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEFFUN_FC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEFCONST</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEFVAR</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>jsatomid</name></type>
<name><name>TraceRecorder</name>::<name>getFullIndex</name></name><parameter_list>(<param><decl><type><name>ptrdiff_t</name></type> <name>pcoff</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsatomid</name></type> <name>index</name> <init>= <expr><call><name>GET_INDEX</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name> + <name>pcoff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>index</name> += <name>atoms</name> - <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>atomMap</name>.<name>vector</name></name></expr>;</expr_stmt>
    <return>return <expr><name>index</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LAMBDA</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>fun</name> = <call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>getFunction</name></name><argument_list>(<argument><expr><call><name>getFullIndex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Emit code to clone a null closure parented by this recorder's global
     * object, in order to preserve function object evaluation rules observable
     * via identity and mutation. But don't clone if our result is consumed by
     * JSOP_SETMETHOD or JSOP_INITMETHOD, since we optimize away the clone for
     * these combinations and clone only if the "method value" escapes.
     *
     * See jsops.cpp, the JSOP_LAMBDA null closure case. The JSOP_SETMETHOD and
     * JSOP_INITMETHOD logic governing the early ARECORD_CONTINUE returns below
     * must agree with the corresponding break-from-do-while(0) logic there.
     */</comment>
    <if>if <condition>(<expr><call><name>FUN_NULL_CLOSURE</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call>-&gt;<call><name>getParent</name><argument_list>()</argument_list></call> != <name>globalObj</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"Null closure function object parent must be global object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>JSOp</name></type> <name>op2</name> <init>= <expr><call><name>JSOp</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name><index>[<expr><name>JSOP_LAMBDA_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>op2</name> == <name>JSOP_SETMETHOD</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jsval</name></type> <name>lval</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call> &amp;&amp;
                <call><name>OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == &amp;<name>js_ObjectClass</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
            }</block></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><name>op2</name> == <name>JSOP_INITMETHOD</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
        }</block></then></if></else></if>

        <decl_stmt><decl><type><name>LIns</name> *</type><name>proto_ins</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>getClassPrototype</name><argument_list>(<argument><expr><name>JSProto_Function</name></expr></argument>, <argument><expr><name>proto_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr>, <expr><name>proto_ins</name></expr>, <expr><call><name>INS_CONSTFUN</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_NewNullClosure_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>LIns</name> *</type><name>proto_ins</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>getClassPrototype</name><argument_list>(<argument><expr><name>JSProto_Function</name></expr></argument>, <argument><expr><name>proto_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>scopeChain_ins</name> <init>= <expr><call><name>scopeChain</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>scopeChain_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>proto_ins</name></expr>, <expr><name>scopeChain_ins</name></expr>, <expr><call><name>INS_CONSTPTR</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_CloneFunctionObject_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>,
          <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>call_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"guard(js_CloneFunctionObject)"</expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>call_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LAMBDA_FC</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>fun</name> = <call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>getFunction</name></name><argument_list>(<argument><expr><call><name>getFullIndex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call>-&gt;<call><name>getParent</name><argument_list>()</argument_list></call> != <name>globalObj</name></expr>)</condition><then>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{
        <expr><call><name>scopeChain</name><argument_list>()</argument_list></call></expr>,
        <expr><call><name>INS_CONSTFUN</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>,
        <expr><name>cx_ins</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_AllocFlatClosure_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>,
          <argument><expr><call><name>addName</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_peq</name></expr></argument>, <argument><expr><name>call_ins</name></expr></argument>, <argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr>"guard(js_AllocFlatClosure)"</expr></argument>)</argument_list></call></expr></argument>,
          <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>nupvars</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSUpvarArray</name> *</type><name>uva</name> <init>= <expr><call><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name>-&gt;<name>upvars</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>uint32</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>n</name> <init>= <expr><name><name>uva</name>-&gt;<name>length</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>upvar_ins</name> <init>= <expr><call><name>upvar</name><argument_list>(<argument><expr><name><name>fun</name>-&gt;<name>u</name>.<name>i</name>.<name>script</name></name></expr></argument>, <argument><expr><name>uva</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>upvar_ins</name></expr>)</condition><then>
                <return>return <expr><name>ARECORD_STOP</name></expr>;</return></then></if>
            <decl_stmt><decl><type><name>LIns</name>*</type> <name>dslots_ins</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>stobj_set_dslot</name><argument_list>(<argument><expr><name>call_ins</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>, <argument><expr><call><name>box_jsval</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>upvar_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>call_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLEE</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETLOCALPOP</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>var</name><argument_list>(<argument><expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>stack</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_IFPRIMTOP</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// Traces are type-specialized, including null vs. object, so we need do</comment>
    <comment type="line">// nothing here. The upstream unbox_jsval called after valueOf or toString</comment>
    <comment type="line">// from an imacro (e.g.) will fork the trace for us, allowing us to just</comment>
    <comment type="line">// follow along mindlessly :-).</comment>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETCALL</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TRY</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_FINALLY</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NOP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ARGSUB</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!(<name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_HEAVYWEIGHT</name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>uintN</name></type> <name>slot</name> <init>= <expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>slot</name> &lt; <name><name>fp</name>-&gt;<name>argc</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argv</name><index>[<expr><name>slot</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_VOID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't trace JSOP_ARGSUB hard case"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>LIns</name>*</type>
<name><name>TraceRecorder</name>::<name>guardArgsLengthNotAssigned</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>argsobj_ins</name></decl></param>)</parameter_list>
<block>{
    <comment type="line">// The following implements IsOverriddenArgsLength on trace.</comment>
    <comment type="line">// The '2' bit is set if length was overridden.</comment>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>len_ins</name> <init>= <expr><call><name>stobj_get_fslot</name><argument_list>(<argument><expr><name>argsobj_ins</name></expr></argument>, <argument><expr><name>JSSLOT_ARGS_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>ovr_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>LIR_piand</name></expr></argument>, <argument><expr><name>len_ins</name></expr></argument>, <argument><expr><call><name>INS_CONSTWORD</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>ovr_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>len_ins</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ARGCNT</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_HEAVYWEIGHT</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't trace heavyweight JSOP_ARGCNT"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// argc is fixed on trace, so ideally we would simply generate LIR for</comment>
    <comment type="line">// constant argc. But the user can mutate arguments.length in the</comment>
    <comment type="line">// interpreter, so we have to check for that in the trace entry frame.</comment>
    <comment type="line">// We also have to check that arguments.length has not been mutated</comment>
    <comment type="line">// at record time, because if so we will generate incorrect constant</comment>
    <comment type="line">// LIR, which will assert in alu().</comment>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argsobj</name></name> &amp;&amp; <call><name>IsOverriddenArgsLength</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't trace JSOP_ARGCNT if arguments.length has been modified"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>a_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>callDepth</name> == 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name> *</type><name>br</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>a_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>guardArgsLengthNotAssigned</name><argument_list>(<argument><expr><name>a_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>label</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>br</name>-&gt;<name>setTarget</name></name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>argc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_DefLocalFunSetSlot</name></name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>slot</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name> <init>= <expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>FUN_NULL_CLOSURE</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call>-&gt;<call><name>getParent</name><argument_list>()</argument_list></call> == <name>globalObj</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>LIns</name> *</type><name>proto_ins</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>getClassPrototype</name><argument_list>(<argument><expr><name>JSProto_Function</name></expr></argument>, <argument><expr><name>proto_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>globalObj</name></expr></argument>)</argument_list></call></expr>, <expr><name>proto_ins</name></expr>, <expr><call><name>INS_CONSTFUN</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>x</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_NewNullClosure_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>var</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEFLOCALFUN</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEFLOCALFUN_FC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GOTOX</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_GOTO</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_IFEQX</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_IFEQ</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_IFNEX</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_IFNE</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ORX</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_OR</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ANDX</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_AND</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GOSUBX</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_GOSUB</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CASEX</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>strictEquality</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEFAULTX</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TABLESWITCHX</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_TABLESWITCH</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LOOKUPSWITCHX</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>switchop</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_BACKPATCH</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_BACKPATCH_POP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_THROWING</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETRVAL</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="line">// If we implement this, we need to update JSOP_STOP.</comment>
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_RETRVAL</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETGVAR</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>slotval</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if> <comment type="line">// We will see JSOP_NAME from the interpreter's jump, so no-op here.</comment>

    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name> <init>= <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>lazilyImportGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
         <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"lazy import of global slot failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETGVAR</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>slotval</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if> <comment type="line">// We will see JSOP_NAME from the interpreter's jump, so no-op here.</comment>

    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name> <init>= <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>lazilyImportGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
         <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"lazy import of global slot failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>stack</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INCGVAR</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>slotval</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <comment type="line">// We will see JSOP_INCNAME from the interpreter's jump, so no-op here.</comment>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name> <init>= <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>lazilyImportGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
         <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"lazy import of global slot failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DECGVAR</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>slotval</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <comment type="line">// We will see JSOP_INCNAME from the interpreter's jump, so no-op here.</comment>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name> <init>= <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>lazilyImportGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
         <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"lazy import of global slot failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GVARINC</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>slotval</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <comment type="line">// We will see JSOP_INCNAME from the interpreter's jump, so no-op here.</comment>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name> <init>= <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>lazilyImportGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
         <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"lazy import of global slot failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GVARDEC</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>slotval</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <comment type="line">// We will see JSOP_INCNAME from the interpreter's jump, so no-op here.</comment>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name> <init>= <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>lazilyImportGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
         <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"lazy import of global slot failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>inc</name><argument_list>(<argument><expr><call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_REGEXP</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name>*</type> <name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScript</name>*</type> <name>script</name> <init>= <expr><name><name>fp</name>-&gt;<name>script</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>index</name> <init>= <expr><name>atoms</name> - <name><name>script</name>-&gt;<name>atomMap</name>.<name>vector</name></name> + <call><name>GET_INDEX</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>proto_ins</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>getClassPrototype</name><argument_list>(<argument><expr><name>JSProto_RegExp</name></expr></argument>, <argument><expr><name>proto_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{
        <expr><name>proto_ins</name></expr>,
        <expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><call><name><name>script</name>-&gt;<name>getRegExp</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
        <expr><name>cx_ins</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>regex_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_CloneRegExpObject_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>regex_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>regex_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="line">// begin JS_HAS_XML_SUPPORT</comment>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DEFXMLNS</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ANYNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_QNAMEPART</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_STRING</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_QNAMECONST</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_QNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TOATTRNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TOATTRVAL</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ADDATTRNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ADDATTRVAL</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_BINDXMLNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETXMLNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_XMLNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DESCENDANTS</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_FILTER</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ENDFILTER</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TOXML</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TOXMLLIST</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_XMLTAGEXPR</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_XMLELTEXPR</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_XMLOBJECT</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_XMLCDATA</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_XMLCOMMENT</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_XMLPI</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETFUNNS</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_STARTXML</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_STARTXMLEXPR</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<comment type="line">// end JS_HAS_XML_SUPPORT</comment>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>this_ins</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>obj</name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>obj_ins</name> = <call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>this_ins</name> = <name>obj_ins</name></expr>;</expr_stmt> <comment type="line">// |this| for subsequent call</comment>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>JSProtoKey</name></type> <name>protoKey</name></decl>;</decl_stmt>
        <macro><name>debug_only_stmt</name><argument_list>(<argument>const char* protoname = NULL;</argument>)</argument_list></macro>
        <if>if <condition>(<expr><call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>protoKey</name> = <name>JSProto_String</name></expr>;</expr_stmt>
            <macro><name>debug_only_stmt</name><argument_list>(<argument>protoname = "String.prototype";</argument>)</argument_list></macro>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_NUMBER</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>protoKey</name> = <name>JSProto_Number</name></expr>;</expr_stmt>
            <macro><name>debug_only_stmt</name><argument_list>(<argument>protoname = "Number.prototype";</argument>)</argument_list></macro>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_SPECIAL</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>l</name> == <name>JSVAL_VOID</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"callprop on void"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>JSVAL_VOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MISMATCH_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>protoKey</name> = <name>JSProto_Boolean</name></expr>;</expr_stmt>
            <macro><name>debug_only_stmt</name><argument_list>(<argument>protoname = "Boolean.prototype";</argument>)</argument_list></macro>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> || <call><name>JSVAL_IS_VOID</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"callprop on null or void"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>

        <if>if <condition>(<expr>!<call><name>js_GetClassPrototype</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>protoKey</name></expr></argument>, <argument><expr>&amp;<name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_ERROR_A</name><argument_list>(<argument><expr>"GetClassPrototype failed!"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><name>obj_ins</name> = <call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>debug_only_stmt</name><argument_list>(<argument>obj_ins = addName(obj_ins, protoname);</argument>)</argument_list></macro>
        <expr_stmt><expr><name>this_ins</name> = <call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// use primitive as |this|</comment>
    }</block></else></if>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PCVal</name></type> <name>pcval</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>test_property_cache</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>pcval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>pcval</name>.<name>isObject</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name><name>pcval</name>.<name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"callprop of missing method"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>HAS_FUNCTION_CLASS</name><argument_list>(<argument><expr><call><name><name>pcval</name>.<name>toObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSFunction</name>*</type> <name>fun</name> <init>= <expr><call><name>GET_FUNCTION_PRIVATE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>pcval</name>.<name>toObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name>PRIMITIVE_THIS_TEST</name><argument_list>(<argument><expr><name>fun</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"callee does not accept primitive |this|"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><call><name><name>pcval</name>.<name>toObject</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"callprop of primitive method"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><call><name><name>pcval</name>.<name>isSprop</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>!<call><name><name>pcval</name>.<name>toSprop</name></name><argument_list>()</argument_list></call>-&gt;<call><name>isMethod</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>AbortableRecordingStatus</name></type> <name>status</name> <init>= <expr><call><name>propTail</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>pcval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>status</name> != <name>ARECORD_CONTINUE</name></expr>)</condition><then>
            <return>return <expr><name>status</name></expr>;</return></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>this_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_DELDESC</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_UINT24</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><call><name>GET_UINT24</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INDEXBASE</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>atoms</name> += <call><name>GET_INDEXBASE</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_RESETBASE</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>atoms</name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>atomMap</name>.<name>vector</name></name></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_RESETBASE0</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>atoms</name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>atomMap</name>.<name>vector</name></name></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLELEM</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_GETELEM</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_STOP</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name>callDepth</name> == 0 &amp;&amp; <call><name>IsTraceableRecursion</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> &amp;&amp;
        <name><name>tree</name>-&gt;<name>recursion</name></name> != <name>Recursion_Disallowed</name> &amp;&amp;
        <name><name>tree</name>-&gt;<name>script</name></name> == <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name></name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>upRecursion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>imacpc</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * End of imacro, so return true to the interpreter immediately. The
         * interpreter's JSOP_STOP case will return from the imacro, back to
         * the pc after the calling op, still in the same JSStackFrame.
         */</comment>
        <expr_stmt><expr><name>atoms</name> = <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>atomMap</name>.<name>vector</name></name></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>putActivationObjects</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We know falling off the end of a constructor returns the new object that
     * was passed in via fp-&gt;argv[-1], while falling off the end of a function
     * returns undefined.
     *
     * NB: we do not support script rval (eval, API users who want the result
     * of the last expression-statement, debugger API calls).
     */</comment>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_CONSTRUCTING</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>thisv</name></name> == <name><name>fp</name>-&gt;<name>argv</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rval_ins</name> = <call><name>get</name><argument_list>(<argument><expr>&amp;<name><name>fp</name>-&gt;<name>argv</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>rval_ins</name> = <call><name>INS_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>clearCurrentFrameSlotsFromTracker</name><argument_list>(<argument><expr><name>nativeFrameTracker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETXPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"primitive-this for GETXPROP?"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>jsval</name>*</type> <name>vp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameResult</name></type> <name>nr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>name</name><argument_list>(<argument><expr><name>vp</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLXMLNAME</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TYPEOFEXPR</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_TYPEOF</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ENTERBLOCK</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>obj</name> = <call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>getObject</name></name><argument_list>(<argument><expr><call><name>getFullIndex</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>void_ins</name> <init>= <expr><call><name>INS_VOID</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>n</name> <init>= <expr><call><name>OBJ_BLOCK_COUNT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>void_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LEAVEBLOCK</name></name><parameter_list>()</parameter_list>
<block>{
    <comment type="block">/* We mustn't exit the lexical block we began recording in. */</comment>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>blockChain</name></name> == <name>lexicalBlock</name></expr>)</condition><then>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return></then></if>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GENERATOR</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_YIELD</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ARRAYPUSH</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>slot</name> <init>= <expr><call><name>GET_UINT16</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name> &lt;= <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name></name> + <name>slot</name> &lt; <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>jsval</name> &amp;</type><name>arrayval</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><name>slot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call>-&gt;<call><name>isDenseArray</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>array_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>arrayval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name> &amp;</type><name>elt</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>elt_ins</name> <init>= <expr><call><name>box_jsval</name><argument_list>(<argument><expr><name>elt</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>elt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>LIns</name> *</type><name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>elt_ins</name></expr>, <expr><name>array_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>ok_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_ArrayCompPush_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_eq0</name></name><argument_list>(<argument><expr><name>ok_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_ENUMCONSTELEM</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LEAVEBLOCKEXPR</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name>stack</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>-1 - <call><name>GET_UINT16</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETTHISPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>this_ins</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>getThis</name><argument_list>(<argument><expr><name>this_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * It's safe to just use cx-&gt;fp-&gt;thisv here because getThis() returns
     * ARECORD_STOP if thisv is not available.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_COMPUTED_THIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>getProp</name><argument_list>(<argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>thisv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>this_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETARGPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>getProp</name><argument_list>(<argument><expr><call><name>argval</name><argument_list>(<argument><expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_GETLOCALPROP</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>getProp</name><argument_list>(<argument><expr><call><name>varval</name><argument_list>(<argument><expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INDEXBASE1</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>atoms</name> += 1 &lt;&lt; 16</expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INDEXBASE2</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>atoms</name> += 2 &lt;&lt; 16</expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INDEXBASE3</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><name>atoms</name> += 3 &lt;&lt; 16</expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLGVAR</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>slotval</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>slots</name><index>[<expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <comment type="line">// We will see JSOP_CALLNAME from the interpreter's jump, so no-op here.</comment>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>

    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name> <init>= <expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>slotval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>lazilyImportGlobalSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><then>
         <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"lazy import of global slot failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name><name>globalObj</name>-&gt;<name>getSlotRef</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLLOCAL</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>slot</name> <init>= <expr><call><name>GET_SLOTNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>var</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLARG</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>slot</name> <init>= <expr><call><name>GET_ARGNO</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>arg</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>INS_NULL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<comment type="block">/* Functions for use with JSOP_CALLBUILTIN. */</comment>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>ObjectToIterator</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name> *</type><name>argv</name> <init>= <expr><call><name>JS_ARGV</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_SET_RVAL</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><call><name>JS_THIS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>js_ValueToIterator</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<call><name>JS_RVAL</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSObject</name>* <name>FASTCALL</name></type>
<name>ObjectToIterator_tn</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>int32</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name> <init>= <expr><call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name> <init>= <expr><call><name>js_ValueToIterator</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>CallIteratorNext</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>js_CallIteratorNext</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>JS_THIS_OBJECT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<call><name>JS_RVAL</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>jsval</name> <name>FASTCALL</name></type>
<name>CallIteratorNext_tn</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>jsbytecode</name>*</type> <name>pc</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>iterobj</name></decl></param>)</parameter_list>
<block>{
    <function_decl><type><name>AutoValueRooter</name></type> <name>tvr</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name> <init>= <expr><call><name>js_CallIteratorNext</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>iterobj</name></expr></argument>, <argument><expr><call><name><name>tvr</name>.<name>addr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SetBuiltinError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JSVAL_ERROR_COOKIE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name><name>tvr</name>.<name>value</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<macro><name>JS_DEFINE_TRCINFO_1</name><argument_list>(<argument>ObjectToIterator</argument>,
    <argument>(4, (static, OBJECT_FAIL, ObjectToIterator_tn, CONTEXT, PC, THIS, INT32, 0, ACC_STORE_ANY))</argument>)</argument_list></macro>
<macro><name>JS_DEFINE_TRCINFO_1</name><argument_list>(<argument>CallIteratorNext</argument>,
    <argument>(3, (static, JSVAL_FAIL,  CallIteratorNext_tn, CONTEXT, PC, THIS,        0, ACC_STORE_ANY))</argument>)</argument_list></macro>

<struct><specifier>static</specifier> <specifier>const</specifier> struct <name>BuiltinFunctionInfo</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSNativeTraceInfo</name> *</type><name>ti</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
</public>}</block> <decl><name><name>builtinFunctionInfo</name><index>[<expr><name>JSBUILTIN_LIMIT</name></expr>]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>&amp;<name>ObjectToIterator_trcinfo</name></expr>,   <expr>1</expr>}</block></expr>,
    <expr><block>{<expr>&amp;<name>CallIteratorNext_trcinfo</name></expr>,   <expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</struct>

<function><type><name>JSObject</name> *</type>
<name>GetBuiltinFunction</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>funobj</name> <init>= <expr><name><name>rt</name>-&gt;<name>builtinFunctions</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>funobj</name></expr>)</condition><then> <block>{
        <comment type="block">/* Use NULL parent and atom. Builtin functions never escape to scripts. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>index</name> &lt; <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>builtinFunctionInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>BuiltinFunctionInfo</name> *</type><name>bfi</name> <init>= <expr>&amp;<name><name>builtinFunctionInfo</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSFunction</name> *</type><name>fun</name> <init>= <expr><call><name>js_NewFunction</name><argument_list>(<argument><expr><name>cx</name></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><call><name>JS_DATA_TO_FUNC_PTR</name><argument_list>(<argument><expr><name>JSNative</name></expr></argument>, <argument><expr><name><name>bfi</name>-&gt;<name>ti</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>bfi</name>-&gt;<name>nargs</name></name></expr></argument>,
                                         <argument><expr><name>JSFUN_FAST_NATIVE</name> | <name>JSFUN_TRCINFO</name></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>fun</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>funobj</name> = <call><name>FUN_OBJECT</name><argument_list>(<argument><expr><name>fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>funobj</name>-&gt;<name>clearProto</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>funobj</name>-&gt;<name>clearParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>builtinFunctions</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition><then> <comment type="block">/* retest now that the lock is held */</comment>
                <expr_stmt><expr><name><name>rt</name>-&gt;<name>builtinFunctions</name><index>[<expr><name>index</name></expr>]</index></name> = <name>funobj</name></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><name>funobj</name> = <name><name>rt</name>-&gt;<name>builtinFunctions</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt></else></if>
            <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>funobj</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CALLBUILTIN</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><call><name>GetBuiltinFunction</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>GET_INDEX</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>RETURN_ERROR_A</name><argument_list>(<argument><expr>"error in js_GetBuiltinFunction"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><call><name>INS_CONSTOBJ</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INT8</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><call><name>GET_INT8</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INT32</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insImmf</name></name><argument_list>(<argument><expr><call><name>GET_INT32</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_LENGTH</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>l</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"non-string primitive JSOP_LENGTH unsupported"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>,
                          <argument><expr><call><name>p2i</name><argument_list>(<argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ldp</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSString</name></expr></argument>, <argument><expr><name>mLength</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>JSObject</name>*</type> <name>obj</name> <init>= <expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>obj_ins</name> <init>= <expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name><name>obj</name>-&gt;<name>isArguments</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>depth</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>afp</name> <init>= <expr><call><name>guardArguments</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>afp</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't reach arguments object's frame"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// We must both check at record time and guard at run time that</comment>
        <comment type="line">// arguments.length has not been reassigned, redefined or deleted.</comment>
        <if>if <condition>(<expr><call><name>IsOverriddenArgsLength</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't trace JSOP_ARGCNT if arguments.length has been modified"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>slot_ins</name> <init>= <expr><call><name>guardArgsLengthNotAssigned</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// slot_ins is the value from the slot; right-shift by 2 bits to get</comment>
        <comment type="line">// the length (see GetArgsLength in jsfun.cpp).</comment>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins2i</name></name><argument_list>(<argument><expr><name>LIR_rsh</name></expr></argument>, <argument><expr><call><name>p2i</name><argument_list>(<argument><expr><name>slot_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>obj</name>-&gt;<name>isArray</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name><name>obj</name>-&gt;<name>isDenseArray</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>guardDenseArray</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_NOT_REACHED</name><argument_list>(<argument><expr>"obj-&gt;isDenseArray() but not?!?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>guardClass</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr>&amp;<name>js_SlowArrayClass</name></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't trace length property access on non-array"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></else></if>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><call><name>p2i</name><argument_list>(<argument><expr><call><name>stobj_get_fslot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>JSSLOT_ARRAY_LENGTH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>OkToTraceTypedArrays</name> &amp;&amp; <call><name>js_IsTypedArray</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// Ensure array is a typed array and is the same type as what was written</comment>
        <expr_stmt><expr><call><name>guardClass</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><call><name><name>obj</name>-&gt;<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>snapshot</name><argument_list>(<argument><expr><name>BRANCH_EXIT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v_ins</name> = <call><name><name>lir</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>LIR_i2f</name></expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>LIR_ld</name></expr></argument>,
                                                <argument><expr><call><name>stobj_get_const_fslot</name><argument_list>(<argument><expr><name>obj_ins</name></expr></argument>, <argument><expr><name>JSSLOT_PRIVATE</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><call><name><name>js</name>::<name>TypedArray</name>::<name>lengthOffset</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACC_READONLY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<call><name>OBJ_IS_NATIVE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>RETURN_STOP_A</name><argument_list>(<argument><expr>"can't trace length property access on non-array, non-native object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><call><name>getProp</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>obj_ins</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_NEWARRAY</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name> *</type><name>proto_ins</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_STATUS_A</name><argument_list>(<argument><expr><call><name>getClassPrototype</name><argument_list>(<argument><expr><name>JSProto_Array</name></expr></argument>, <argument><expr><name>proto_ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>uint32</name></type> <name>len</name> <init>= <expr><call><name>GET_UINT16</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>regs</name>-&gt;<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>assertValidStackDepth</name></name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>, <expr><name>proto_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>v_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_NewArrayWithSlots_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name>dslots_ins</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>uint32</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>jsval</name>&amp;</type> <name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr><call><name>int</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> - <call><name>int</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>v</name> != <name>JSVAL_HOLE</name></expr>)</condition><then>
            <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>elt_ins</name> <init>= <expr><call><name>box_jsval</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>get</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>stobj_set_dslot</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>dslots_ins</name></expr></argument>, <argument><expr><name>elt_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr><name>count</name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>stobj_set_fslot</name><argument_list>(<argument><expr><name>v_ins</name></expr></argument>, <argument><expr><name>JSSLOT_ARRAY_COUNT</name></expr></argument>, <argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>-<call><name>int</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_HOLE</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>stack</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>INS_CONST</name><argument_list>(<argument><expr><call><name>JSVAL_TO_SPECIAL</name><argument_list>(<argument><expr><name>JSVAL_HOLE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_TRACE</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name>sMaxConcatNSize</name> <init>= <expr>32</expr></init></decl>;</decl_stmt>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_OBJTOSTR</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name> &amp;</type><name>v</name> <init>= <expr><call><name>stackval</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name></expr></argument>, <argument><expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp;
                                 *<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>imacpc</name></name> == <name>JSOP_OBJTOSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return></then></if>
    <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><call><name>call_imacro</name><argument_list>(<argument><expr><name><name>objtostr_imacros</name>.<name>toString</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_CONCATN</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name> <init>= <expr><name><name>cx</name>-&gt;<name>fp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSFrameRegs</name> &amp;</type><name>regs</name> <init>= <expr>*<name><name>fp</name>-&gt;<name>regs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>argc</name> <init>= <expr><call><name>GET_ARGC</name><argument_list>(<argument><expr><name><name>regs</name>.<name>pc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name> *</type><name>argBase</name> <init>= <expr><name><name>regs</name>.<name>sp</name></name> - <name>argc</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Prevent code/alloca explosion. */</comment>
    <if>if <condition>(<expr><name>argc</name> &gt; <name>sMaxConcatNSize</name></expr>)</condition><then>
        <return>return <expr><name>ARECORD_STOP</name></expr>;</return></then></if>

    <comment type="block">/* Build an array of the stringified primitives. */</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>bufSize</name> <init>= <expr><name>argc</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>JSString</name> *</expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>buf_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><name>bufSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>d</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>jsval</name> *</type><name>vp</name> <init>= <expr><name>argBase</name></expr></init></decl>;</init> <condition><expr><name>vp</name> != <name><name>regs</name>.<name>sp</name></name></expr>;</condition> <incr><expr>++<name>vp</name></expr>, <expr><name>d</name> += <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr></incr>) <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>lir</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><call><name>stringify</name><argument_list>(<argument><expr>*<name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf_ins</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>ACC_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* Perform concatenation using a builtin. */</comment>
    <decl_stmt><decl><type><name>LIns</name> *</type><name><name>args</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name><name>lir</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>, <expr><name>buf_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name> *</type><name>result_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_ConcatN_ci</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><call><name><name>lir</name>-&gt;<name>ins_peq0</name></name><argument_list>(<argument><expr><name>result_ins</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update tracker with result. */</comment>
    <expr_stmt><expr><call><name>set</name><argument_list>(<argument><expr><name>argBase</name></expr></argument>, <argument><expr><name>result_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SETMETHOD</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_SETPROP</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_INITMETHOD</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><call><name>record_JSOP_INITPROP</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSBool</name> <name>FASTCALL</name></type>
<name>js_Unbrand</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>obj</name>-&gt;<name>unbrand</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>JS_DEFINE_CALLINFO_2</name><argument_list>(<argument>extern</argument>, <argument>BOOL</argument>, <argument>js_Unbrand</argument>, <argument>CONTEXT</argument>, <argument>OBJECT</argument>, <argument>0</argument>, <argument>ACC_STORE_ANY</argument>)</argument_list></macro>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_UNBRAND</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args_ins</name><index>[]</index></name> <init>= <expr><block>{ <expr><call><name>stack</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_Unbrand_ci</name></expr></argument>, <argument><expr><name>args_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>call_ins</name></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_UNBRANDTHIS</name></name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>this_ins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RecordingStatus</name></type> <name>status</name> <init>= <expr><call><name>getThis</name><argument_list>(<argument><expr><name>this_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>status</name> != <name>RECORD_CONTINUE</name></expr>)</condition><then>
        <return>return <expr><call><name>InjectStatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <decl_stmt><decl><type><name>LIns</name>*</type> <name><name>args_ins</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>this_ins</name></expr>, <expr><name>cx_ins</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LIns</name>*</type> <name>call_ins</name> <init>= <expr><call><name><name>lir</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr>&amp;<name>js_Unbrand_ci</name></expr></argument>, <argument><expr><name>args_ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>guard</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>call_ins</name></expr></argument>, <argument><expr><name>OOM_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ARECORD_CONTINUE</name></expr>;</return>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>AbortableRecordingStatus</name></type>
<name><name>TraceRecorder</name>::<name>record_JSOP_SHARPINIT</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>ARECORD_STOP</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBG_STUB</name><parameter_list>(<param><type><name>OP</name></type></param>)</parameter_list></cpp:macro>                                                          \
    <cpp:value>JS_REQUIRES_STACK AbortableRecordingStatus                                \
    TraceRecorder::record_##OP()                                              \
    {                                                                         \
        RETURN_STOP_A("can't trace " #OP);                                    \
    }</cpp:value></cpp:define>

<macro><name>DBG_STUB</name><argument_list>(<argument>JSOP_GETUPVAR_DBG</argument>)</argument_list></macro>
<macro><name>DBG_STUB</name><argument_list>(<argument>JSOP_CALLUPVAR_DBG</argument>)</argument_list></macro>
<macro><name>DBG_STUB</name><argument_list>(<argument>JSOP_DEFFUN_DBGFC</argument>)</argument_list></macro>
<macro><name>DBG_STUB</name><argument_list>(<argument>JSOP_DEFLOCALFUN_DBGFC</argument>)</argument_list></macro>
<macro><name>DBG_STUB</name><argument_list>(<argument>JSOP_LAMBDA_DBGFC</argument>)</argument_list></macro>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_JIT_SPEW</name></cpp:ifdef>
<comment type="block">/*
 * Print information about entry typemaps and unstable exits for all peers
 * at a PC.
 */</comment>
<function><type><name>void</name></type>
<name>DumpPeerStability</name><parameter_list>(<param><decl><type><name>TraceMonitor</name>*</type> <name>tm</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>ip</name></decl></param>, <param><decl><type><name>JSObject</name>*</type> <name>globalObj</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>globalShape</name></decl></param>,
                  <param><decl><type><name>uint32</name></type> <name>argc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>TreeFragment</name>*</type> <name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>looped</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>length</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>f</name> = <call><name>LookupLoop</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>globalObj</name></expr></argument>, <argument><expr><name>globalShape</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>f</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>peer</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name><name>f</name>-&gt;<name>code</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>
        <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>"Stability of fragment %p:\nENTRY STACK="</expr></argument>, <argument><expr>(<name>void</name>*)<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>looped</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>nStackTypes</name></name> == <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>f</name>-&gt;<name>nStackTypes</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr><call><name><name>f</name>-&gt;<name>stackTypeMap</name></name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>" GLOBALS="</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>f</name>-&gt;<name>nGlobalTypes</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr><call><name><name>f</name>-&gt;<name>globalTypeMap</name></name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>UnstableExit</name>*</type> <name>uexit</name> <init>= <expr><name><name>f</name>-&gt;<name>unstableExits</name></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>uexit</name> != <name>NULL</name></expr>)</condition> <block>{
            <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>"EXIT  "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>TraceType</name>*</type> <name>m</name> <init>= <expr><call><name><name>uexit</name>-&gt;<name>exit</name>-&gt;<name>fullTypeMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>"STACK="</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>uexit</name>-&gt;<name>exit</name>-&gt;<name>numStackSlots</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr><name><name>typeChar</name><index>[<expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>" GLOBALS="</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>uexit</name>-&gt;<name>exit</name>-&gt;<name>numGlobalSlots</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><call><name>debug_only_printf</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>"%c"</expr></argument>,
                                  <argument><expr><name><name>typeChar</name><index>[<expr><name><name>m</name><index>[<expr><name><name>uexit</name>-&gt;<name>exit</name>-&gt;<name>numStackSlots</name></name> + <name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name>debug_only_print0</name><argument_list>(<argument><expr><name>LC_TMRecorder</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>uexit</name> = <name><name>uexit</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name>length</name> = <name><name>f</name>-&gt;<name>nStackTypes</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>looped</name> = true</expr>;</expr_stmt>
    }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_TRACEVIS</name></cpp:ifdef>

<decl_stmt><decl><type><name>FILE</name>*</type> <name>traceVisLogFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>JSHashTable</name> *</type><name>traceVisScriptTable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>bool</argument>)</argument_list></macro>
<macro><name>StartTraceVis</name><argument_list>(<argument>const char* filename = "tracevis.dat"</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr><name>traceVisLogFile</name></expr>)</condition><then> <block>{
        <comment type="line">// If we're currently recording, first we must stop.</comment>
        <expr_stmt><expr><call><name>StopTraceVis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>traceVisLogFile</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>traceVisLogFile</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <return>return <expr>true</expr>;</return>
}</block>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>JSBool</argument>)</argument_list></macro>
<macro><name>StartTraceVisNative</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSObject *obj</argument>, <argument>uintN argc</argument>, <argument>jsval *argv</argument>, <argument>jsval *rval</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>argc</name> &gt; 0 &amp;&amp; <call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name>JSVAL_TO_STRING</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>filename</name> <init>= <expr><call><name>js_DeflateString</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name><name>str</name>-&gt;<name>chars</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>str</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>filename</name></expr>)</condition><then>
            <goto>goto <name>error</name>;</goto></then></if>
        <expr_stmt><expr><name>ok</name> = <call><name>StartTraceVis</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>ok</name> = <call><name>StartTraceVis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"started TraceVis recording\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

  <label><name>error</name>:</label>
    <expr_stmt><expr><call><name>JS_ReportError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"failed to start TraceVis recording"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>bool</argument>)</argument_list></macro>
<macro><name>StopTraceVis</name><argument_list>()</argument_list></macro>
<block>{
    <if>if <condition>(<expr>!<name>traceVisLogFile</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>traceVisLogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// not worth checking the result</comment>
    <expr_stmt><expr><name>traceVisLogFile</name> = <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr>true</expr>;</return>
}</block>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>JSBool</argument>)</argument_list></macro>
<macro><name>StopTraceVisNative</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSObject *obj</argument>, <argument>uintN argc</argument>, <argument>jsval *argv</argument>, <argument>jsval *rval</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name> <init>= <expr><call><name>StopTraceVis</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>ok</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"stopped TraceVis recording\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><call><name>JS_ReportError</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>"TraceVis isn't running"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <return>return <expr><name>ok</name></expr>;</return>
}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MOZ_TRACEVIS */</comment>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name>CaptureStackTypes</name><parameter_list>(<param><decl><type><name>JSContext</name>*</type> <name>cx</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>callDepth</name></decl></param>, <param><decl><type><name>TraceType</name>*</type> <name>typeMap</name></decl></param>)</parameter_list>
<block>{
    <function_decl><type><name>CaptureTypesVisitor</name></type> <name>capVisitor</name><parameter_list>(<param><decl><type><name>cx</name></type></decl></param>, <param><decl><type><name>typeMap</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>VisitStackSlots</name><argument_list>(<argument><expr><name>capVisitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>callDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name><name>TraceRecorder</name>::<name>determineGlobalTypes</name></name><parameter_list>(<param><decl><type><name>TraceType</name>*</type> <name>typeMap</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>DetermineTypesVisitor</name></type> <name>detVisitor</name><argument_list>(<argument><expr>*<name>this</name></expr></argument>, <argument><expr><name>typeMap</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VisitGlobalSlots</name><argument_list>(<argument><expr><name>detVisitor</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr>*<name><name>tree</name>-&gt;<name>globalSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsrecursion.cpp"</cpp:file></cpp:include>

} <comment type="block">/* namespace js */</comment>
</unit>
