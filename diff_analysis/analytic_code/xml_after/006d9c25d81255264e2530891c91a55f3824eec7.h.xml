<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="006d9c25d81255264e2530891c91a55f3824eec7.h"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* vim: set ts=2 sw=2 et tw=78: */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NS_IPARSER___</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER___</name></cpp:macro></cpp:define>


<comment type="block">/**
 * MODULE NOTES:
 *  
 *  This class defines the iparser interface. This XPCOM
 *  inteface is all that parser clients ever need to see.
 *
 **/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISupports.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIStreamListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDTD.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsStringGlue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTArray.h"</cpp:file></cpp:include>

<comment type="line">// 3007e9c0-4d3e-4c80-8cae-fbb4723d88f2</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_IID</name></cpp:macro> \
<cpp:value>{ 0x3007e9c0, 0x4d3e, 0x4c80, \
  { 0x8c, 0xae, 0xfb, 0xb4, 0x72, 0x3d, 0x88, 0xf2 } }</cpp:value></cpp:define>

<comment type="line">// {41421C60-310A-11d4-816F-000064657374}</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IDEBUG_DUMP_CONTENT_IID</name></cpp:macro> \
<cpp:value>{ 0x41421c60, 0x310a, 0x11d4, \
{ 0x81, 0x6f, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }</cpp:value></cpp:define>

<decl_stmt><decl><type><name>class</name></type> <name>nsIContentSink</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIRequestObserver</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIParserFilter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsString</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIURI</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>nsIChannel</name></decl>;</decl_stmt>

<enum>enum <name>eParserCommands</name> <block>{
  <decl><name>eViewNormal</name></decl>,
  <decl><name>eViewSource</name></decl>,
  <decl><name>eViewFragment</name></decl>,
  <decl><name>eViewErrors</name></decl>
}</block>;</enum>

<enum>enum <name>eParserDocType</name> <block>{
  <decl><name>ePlainText</name> <init>= <expr>0</expr></init></decl>,
  <decl><name>eXML</name></decl>,
  <decl><name>eHTML_Quirks</name></decl>,
  <decl><name>eHTML_Strict</name></decl>
}</block>;</enum>


<comment type="line">// define Charset source constants</comment>
<comment type="line">// note: the value order defines the priority; higher numbers take priority</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetUninitialized</name></cpp:macro>           <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromWeakDocTypeDefault</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromUserDefault</name></cpp:macro>         <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromDocTypeDefault</name></cpp:macro>      <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromCache</name></cpp:macro>               <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromParentFrame</name></cpp:macro>         <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromBookmarks</name></cpp:macro>           <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromAutoDetection</name></cpp:macro>       <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromHintPrevDoc</name></cpp:macro>         <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromMetaTag</name></cpp:macro>             <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromByteOrderMark</name></cpp:macro>      <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromChannel</name></cpp:macro>            <cpp:value>11</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromOtherComponent</name></cpp:macro>     <cpp:value>12</cpp:value></cpp:define>
<comment type="line">// Levels below here will be forced onto childframes too</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromParentForced</name></cpp:macro>       <cpp:value>13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromUserForced</name></cpp:macro>         <cpp:value>14</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kCharsetFromPreviousLoading</name></cpp:macro>    <cpp:value>15</cpp:value></cpp:define>

<enum>enum <name>eStreamState</name> <block>{<decl><name>eNone</name></decl>,<decl><name>eOnStart</name></decl>,<decl><name>eOnDataAvail</name></decl>,<decl><name>eOnStop</name></decl>}</block>;</enum>

<comment type="block">/** 
 *  FOR DEBUG PURPOSE ONLY
 *
 *  Use this interface to query objects that contain content information.
 *  Ex. Parser can trigger dump content by querying the sink that has
 *      access to the content.
 *  
 *  @update  harishd 05/25/00
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsIDebugDumpContent</name> : <name>public</name> <name>nsISupports</name> <block>{
<expr><name>public</name>:
  <macro><name>NS_DECLARE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>NS_IDEBUG_DUMP_CONTENT_IID</argument>)</argument_list></macro>
  <name>NS_IMETHOD</name> <call><name>DumpContentModel</name><argument_list>()</argument_list></call>=0</expr>;
}</block></expr>;</expr_stmt>

<macro><name>NS_DEFINE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>nsIDebugDumpContent</argument>, <argument>NS_IDEBUG_DUMP_CONTENT_IID</argument>)</argument_list></macro>

<comment type="block">/**
 *  This class defines the iparser interface. This XPCOM
 *  inteface is all that parser clients ever need to see.
 */</comment>
<expr_stmt><expr><name>class</name> <name>nsIParser</name> : <name>public</name> <name>nsISupports</name> <block>{
  <expr><name>public</name>:

    <macro><name>NS_DECLARE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>NS_IPARSER_IID</argument>)</argument_list></macro>

    <comment type="block">/**
     * Select given content sink into parser for parser output
     * @update	gess5/11/98
     * @param   aSink is the new sink to be used by parser
     * @return  
     */</comment>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <call><name>SetContentSink</name><argument_list>(<argument><expr><name>nsIContentSink</name>* <name>aSink</name></expr></argument>)</argument_list></call>=0</expr>;


    <comment type="block">/**
     * retrieve the sink set into the parser 
     * @update	gess5/11/98
     * @return  current sink
     */</comment>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>nsIContentSink*</argument>)</argument_list></macro> <expr><call><name>GetContentSink</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call>=0</expr>;

    <comment type="block">/**
     *  Call this method once you've created a parser, and want to instruct it
	   *  about the command which caused the parser to be constructed. For example,
     *  this allows us to select a DTD which can do, say, view-source.
     *  
     *  @update  gess 3/25/98
     *  @param   aCommand -- ptrs to string that contains command
     *  @return	 nada
     */</comment>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr><call><name>GetCommand</name><argument_list>(<argument><expr><name>nsCString</name>&amp; <name>aCommand</name></expr></argument>)</argument_list></call>=0</expr>;
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr><call><name>SetCommand</name><argument_list>(<argument><expr>const <name>char</name>* <name>aCommand</name></expr></argument>)</argument_list></call>=0</expr>;
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>SetCommand</name><argument_list>(<argument>eParserCommands aParserCommand</argument>)</argument_list></macro><expr>=0</expr>;

    <comment type="block">/**
     *  Call this method once you've created a parser, and want to instruct it
     *  about what charset to load
     *  
     *  @update  ftang 4/23/99
     *  @param   aCharset- the charest of a document
     *  @param   aCharsetSource- the soure of the chares
     *  @return	 nada
     */</comment>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>SetDocumentCharset</name><argument_list>(<argument>const nsACString&amp; aCharset</argument>, <argument>PRInt32 aSource</argument>)</argument_list></macro><expr>=0</expr>;
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr><call><name>GetDocumentCharset</name><argument_list>(<argument><expr><name>nsACString</name>&amp; <name>oCharset</name></expr></argument>, <argument><expr><name>PRInt32</name>&amp; <name>oSource</name></expr></argument>)</argument_list></call>=0</expr>;

    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr><call><name>SetParserFilter</name><argument_list>(<argument><expr><name>nsIParserFilter</name>* <name>aFilter</name></expr></argument>)</argument_list></call> = 0</expr>;

    <comment type="block">/** 
     * Get the channel associated with this parser
     * @update harishd,gagan 07/17/01
     * @param aChannel out param that will contain the result
     * @return NS_OK if successful
     */</comment>
    <expr><name>NS_IMETHOD</name> <call><name>GetChannel</name><argument_list>(<argument><expr><name>nsIChannel</name>** <name>aChannel</name></expr></argument>)</argument_list></call> = 0</expr>;

    <comment type="block">/** 
     * Get the DTD associated with this parser
     * @update vidur 9/29/99
     * @param aDTD out param that will contain the result
     * @return NS_OK if successful, NS_ERROR_FAILURE for runtime error
     */</comment>
    <expr><name>NS_IMETHOD</name> <call><name>GetDTD</name><argument_list>(<argument><expr><name>nsIDTD</name>** <name>aDTD</name></expr></argument>)</argument_list></call> = 0</expr>;

    <comment type="block">/**************************************************************************
     *  Parse methods always begin with an input source, and perform
     *  conversions until you wind up being emitted to the given contentsink
     *  (which may or may not be a proxy for the NGLayout content model).
     ************************************************************************/</comment>
    
    <comment type="line">// Call this method to resume the parser from the blocked state.</comment>
    <expr><name>NS_IMETHOD</name> <call><name>ContinueParsing</name><argument_list>()</argument_list></call> = 0</expr>;

    <comment type="line">// Call this method to resume the parser from an unblocked state.</comment>
    <comment type="line">// This can happen, for example, if parsing was interrupted and then the</comment>
    <comment type="line">// consumer needed to restart the parser without waiting for more data.</comment>
    <comment type="line">// This also happens after loading scripts, which unblock the parser in</comment>
    <comment type="line">// order to process the output of document.write() and then need to</comment>
    <comment type="line">// continue on with the page load on an enabled parser.</comment>
    <expr><name>NS_IMETHOD</name> <call><name>ContinueInterruptedParsing</name><argument_list>()</argument_list></call> = 0</expr>;
    
    <comment type="line">// Stops parsing temporarily.</comment>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr><call><name>BlockParser</name><argument_list>()</argument_list></call> = 0</expr>;
    
    <comment type="line">// Open up the parser for tokenization, building up content </comment>
    <comment type="line">// model..etc. However, this method does not resume parsing </comment>
    <comment type="line">// automatically. It's the callers' responsibility to restart</comment>
    <comment type="line">// the parsing engine.</comment>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr><call><name>UnblockParser</name><argument_list>()</argument_list></call> = 0</expr>;

    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro> <expr><call><name>IsParserEnabled</name><argument_list>()</argument_list></call> = 0</expr>;
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>PRBool</argument>)</argument_list></macro> <expr><call><name>IsComplete</name><argument_list>()</argument_list></call> = 0</expr>;
    
    <expr><name>NS_IMETHOD</name> <macro><name>Parse</name><argument_list>(<argument>nsIURI* aURL</argument>,
                     <argument>nsIRequestObserver* aListener = nsnull</argument>,
                     <argument>void* aKey = 0</argument>,
                     <argument>nsDTDMode aMode = eDTDMode_autodetect</argument>)</argument_list></macro> = 0</expr>;
    <expr><name>NS_IMETHOD</name> <macro><name>Parse</name><argument_list>(<argument>const nsAString&amp; aSourceBuffer</argument>,
                     <argument>void* aKey</argument>,
                     <argument>const nsACString&amp; aMimeType</argument>,
                     <argument>PRBool aLastCall</argument>,
                     <argument>nsDTDMode aMode = eDTDMode_autodetect</argument>)</argument_list></macro> = 0</expr>;

    <comment type="line">// Return a key, suitable for passing into one of the Parse methods above,</comment>
    <comment type="line">// that will cause this parser to use the root context.</comment>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr><call><name>GetRootContextKey</name><argument_list>()</argument_list></call> = 0</expr>;
    
    <expr><name>NS_IMETHOD</name> <call><name>Terminate</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call> = 0</expr>;

    <comment type="block">/**
     * This method gets called when you want to parse a fragment of HTML or XML
     * surrounded by the context |aTagStack|. It requires that the parser have
     * been given a fragment content sink.
     *
     * @param aSourceBuffer The XML or HTML that hasn't been parsed yet.
     * @param aKey The key used by the parser.
     * @param aTagStack The context of the source buffer.
     * @param aXMLMode Whether this is XML or HTML
     * @param aContentType The content-type of this document.
     * @param aMode The DTDMode that the parser should parse this fragment in.
     * @return Success or failure.
     */</comment>
    <expr><name>NS_IMETHOD</name> <macro><name>ParseFragment</name><argument_list>(<argument>const nsAString&amp; aSourceBuffer</argument>,
                             <argument>void* aKey</argument>,
                             <argument>nsTArray&lt;nsString&gt;&amp; aTagStack</argument>,
                             <argument>PRBool aXMLMode</argument>,
                             <argument>const nsACString&amp; aContentType</argument>,
                             <argument>nsDTDMode aMode = eDTDMode_autodetect</argument>)</argument_list></macro> = 0</expr>;

    <comment type="block">/**
     * This method gets called when the tokens have been consumed, and it's time
     * to build the model via the content sink.
     * @update	gess5/11/98
     * @return  error code -- 0 if model building went well .
     */</comment>
    <expr><name>NS_IMETHOD</name> <call><name>BuildModel</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call> = 0</expr>;


    <comment type="block">/**
     *  Retrieve the parse mode from the parser...
     *  
     *  @update  gess 6/9/98
     *  @return  ptr to scanner
     */</comment>
    <macro><name>NS_IMETHOD_</name><argument_list>(<argument>nsDTDMode</argument>)</argument_list></macro> <expr><call><name>GetParseMode</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call> = 0</expr>;

    <comment type="block">/**
     *  Call this method to cancel any pending parsing events.
     *  Parsing events may be pending if all of the document's content
     *  has been passed to the parser but the parser has been interrupted
     *  because processing the tokens took too long.
     *  
     *  @update  kmcclusk 05/18/01
     *  @return  NS_OK if succeeded else ERROR.
     */</comment>

    <expr><name>NS_IMETHOD</name> <call><name>CancelParsingEvents</name><argument_list>()</argument_list></call> = 0</expr>;

    <expr><name>virtual</name> <name>void</name> <call><name>Reset</name><argument_list>()</argument_list></call> = 0</expr>;

    <comment type="block">/**
     * Tells the parser that a script is now executing. The only data we
     * should resume parsing for is document.written data. We'll deal with any
     * data that comes in over the network later.
     */</comment>
    <expr><name>virtual</name> <name>void</name> <call><name>ScriptExecuting</name><argument_list>()</argument_list></call> = 0</expr>;

    <comment type="block">/**
     * Tells the parser that the script is done executing. We should now
     * continue the regular parsing process.
     */</comment>
    <expr><name>virtual</name> <name>void</name> <call><name>ScriptDidExecute</name><argument_list>()</argument_list></call> = 0</expr>;
}</block></expr>;</expr_stmt>

<macro><name>NS_DEFINE_STATIC_IID_ACCESSOR</name><argument_list>(<argument>nsIParser</argument>, <argument>NS_IPARSER_IID</argument>)</argument_list></macro>

<comment type="block">/* ===========================================================*
  Some useful constants...
 * ===========================================================*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prtypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsError.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_EOF</name></cpp:macro>                            <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1000)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_UNKNOWN</name></cpp:macro>                        <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1001)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_CANTPROPAGATE</name></cpp:macro>                  <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1002)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_CONTEXTMISMATCH</name></cpp:macro>                <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1003)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_BADFILENAME</name></cpp:macro>                    <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1004)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_BADURL</name></cpp:macro>                         <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1005)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT</name></cpp:macro>           <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1006)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_INTERRUPTED</name></cpp:macro>                    <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1007)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_BLOCK</name></cpp:macro>                          <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1008)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_BADTOKENIZER</name></cpp:macro>                   <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1009)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_BADATTRIBUTE</name></cpp:macro>                   <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1010)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_UNRESOLVEDDTD</name></cpp:macro>                  <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1011)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_MISPLACEDTABLECONTENT</name></cpp:macro>          <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1012)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_BADDTD</name></cpp:macro>                         <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1013)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_BADCONTEXT</name></cpp:macro>                     <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1014)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_STOPPARSING</name></cpp:macro>                    <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1015)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL</name></cpp:macro>      <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1016)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP</name></cpp:macro>               <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1017)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_FAKE_ENDTAG</name></cpp:macro>                    <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1018)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_INVALID_COMMENT</name></cpp:macro>                <cpp:value>NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_HTMLPARSER,1019)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_ERROR_HTMLPARSER_CONTINUE</name></cpp:macro>              <cpp:value>NS_OK</cpp:value></cpp:define>


<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kEOF</name>              <init>= <expr><name>NS_ERROR_HTMLPARSER_EOF</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kUnknownError</name>     <init>= <expr><name>NS_ERROR_HTMLPARSER_UNKNOWN</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kCantPropagate</name>    <init>= <expr><name>NS_ERROR_HTMLPARSER_CANTPROPAGATE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kContextMismatch</name>  <init>= <expr><name>NS_ERROR_HTMLPARSER_CONTEXTMISMATCH</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kBadFilename</name>      <init>= <expr><name>NS_ERROR_HTMLPARSER_BADFILENAME</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kBadURL</name>           <init>= <expr><name>NS_ERROR_HTMLPARSER_BADURL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kInvalidParserContext</name> <init>= <expr><name>NS_ERROR_HTMLPARSER_INVALIDPARSERCONTEXT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kBlocked</name>          <init>= <expr><name>NS_ERROR_HTMLPARSER_BLOCK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kBadStringLiteral</name> <init>= <expr><name>NS_ERROR_HTMLPARSER_UNTERMINATEDSTRINGLITERAL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kHierarchyTooDeep</name> <init>= <expr><name>NS_ERROR_HTMLPARSER_HIERARCHYTOODEEP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kFakeEndTag</name>       <init>= <expr><name>NS_ERROR_HTMLPARSER_FAKE_ENDTAG</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type>  <name>kNotAComment</name>      <init>= <expr><name>NS_ERROR_HTMLPARSER_INVALID_COMMENT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kNewLine</name>          <init>= <expr>'\n'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kCR</name>               <init>= <expr>'\r'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kLF</name>               <init>= <expr>'\n'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kTab</name>              <init>= <expr>'\t'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kSpace</name>            <init>= <expr>' '</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kQuote</name>            <init>= <expr>'"'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kApostrophe</name>       <init>= <expr>'\''</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kLessThan</name>         <init>= <expr>'&lt;'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kGreaterThan</name>      <init>= <expr>'&gt;'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kAmpersand</name>        <init>= <expr>'&amp;'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kForwardSlash</name>     <init>= <expr>'/'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kBackSlash</name>        <init>= <expr>'\\'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kEqual</name>            <init>= <expr>'='</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kMinus</name>            <init>= <expr>'-'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kPlus</name>             <init>= <expr>'+'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kExclamation</name>      <init>= <expr>'!'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kSemicolon</name>        <init>= <expr>';'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kHashsign</name>         <init>= <expr>'#'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kAsterisk</name>         <init>= <expr>'*'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kUnderbar</name>         <init>= <expr>'_'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kComma</name>            <init>= <expr>','</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kLeftParen</name>        <init>= <expr>'('</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kRightParen</name>       <init>= <expr>')'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kLeftBrace</name>        <init>= <expr>'{'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kRightBrace</name>       <init>= <expr>'}'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kQuestionMark</name>     <init>= <expr>'?'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kLeftSquareBracket</name>  <init>= <expr>'['</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type>  <name>kRightSquareBracket</name> <init>= <expr>']'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name></type> <name>kNullCh</name>           <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>

<comment type="line">// XXXbz these type defines should really just go away....  Until they</comment>
<comment type="line">// do, changes here should be reflected in nsContentDLF.cpp</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kHTMLTextContentType</name></cpp:macro>  <cpp:value>"text/html"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kXMLTextContentType</name></cpp:macro>   <cpp:value>"text/xml"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kXMLApplicationContentType</name></cpp:macro> <cpp:value>"application/xml"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kXHTMLApplicationContentType</name></cpp:macro> <cpp:value>"application/xhtml+xml"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kXULTextContentType</name></cpp:macro>   <cpp:value>"application/vnd.mozilla.xul+xml"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kRDFTextContentType</name></cpp:macro>   <cpp:value>"text/rdf"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kRDFApplicationContentType</name></cpp:macro> <cpp:value>"application/rdf+xml"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kXIFTextContentType</name></cpp:macro>   <cpp:value>"text/xif"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kPlainTextContentType</name></cpp:macro> <cpp:value>"text/plain"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kViewSourceCommand</name></cpp:macro>    <cpp:value>"view-source"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kViewFragmentCommand</name></cpp:macro>  <cpp:value>"view-fragment"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kTextCSSContentType</name></cpp:macro>   <cpp:value>"text/css"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kApplicationJSContentType</name></cpp:macro> <cpp:value>"application/javascript"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kApplicationXJSContentType</name></cpp:macro> <cpp:value>"application/x-javascript"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kTextECMAScriptContentType</name></cpp:macro> <cpp:value>"text/ecmascript"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kApplicationECMAScriptContentType</name></cpp:macro> <cpp:value>"application/ecmascript"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kTextJSContentType</name></cpp:macro>    <cpp:value>"text/javascript"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kSGMLTextContentType</name></cpp:macro>   <cpp:value>"text/sgml"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kSVGTextContentType</name></cpp:macro>   <cpp:value>"image/svg+xml"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_UNKNOWN_MODE</name></cpp:macro>         <cpp:value>0x00000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_QUIRKS_MODE</name></cpp:macro>          <cpp:value>0x00000002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_STRICT_MODE</name></cpp:macro>          <cpp:value>0x00000004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_AUTO_DETECT_MODE</name></cpp:macro>     <cpp:value>0x00000010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_VIEW_NORMAL</name></cpp:macro>          <cpp:value>0x00000020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_VIEW_SOURCE</name></cpp:macro>          <cpp:value>0x00000040</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_VIEW_ERRORS</name></cpp:macro>          <cpp:value>0x00000080</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_PLAIN_TEXT</name></cpp:macro>           <cpp:value>0x00000100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_XML</name></cpp:macro>                  <cpp:value>0x00000200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_HTML</name></cpp:macro>                 <cpp:value>0x00000400</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_SCRIPT_ENABLED</name></cpp:macro>       <cpp:value>0x00000800</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS_IPARSER_FLAG_FRAMES_ENABLED</name></cpp:macro>       <cpp:value>0x00001000</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
