<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0053f39ea6f884f447768ff6bf1b1cf3753a9507.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla test code
 *
 * The Initial Developer of the Original Code is
 * Mozilla Foundation
 * Portions created by the Initial Developer are Copyright (C) 2008
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Ted Mielczarek &lt;ted.mielczarek@gmail.com&gt;
 *   Honza Bambas &lt;honzab@firemni.cz&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * WARNING: DO NOT USE THIS CODE IN PRODUCTION SYSTEMS.  It is highly likely to
 *          be plagued with the usual problems endemic to C (buffer overflows
 *          and the like).  We don't especially care here (but would accept
 *          patches!) because this is only intended for use in our test
 *          harnesses in controlled situations where input is guaranteed not to
 *          be malicious.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prinit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prerror.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prnetdb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prtpool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prtypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nss.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pk11func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"key.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"keyt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ssl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plhash.h"</cpp:file></cpp:include>

<using>using <name><name>std</name>::<name>string</name></name>;</using>
<using>using <name><name>std</name>::<name>vector</name></name>;</using>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_DELIM</name><parameter_list>(<param><type><name>m</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>          <cpp:value>((m)[(c) &gt;&gt; 3] &amp; (1 &lt;&lt; ((c) &amp; 7)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_DELIM</name><parameter_list>(<param><type><name>m</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>((m)[(c) &gt;&gt; 3] |= (1 &lt;&lt; ((c) &amp; 7)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELIM_TABLE_SIZE</name></cpp:macro>        <cpp:value>32</cpp:value></cpp:define>

<comment type="line">// Copied from nsCRT</comment>
<function><type><name>char</name>*</type> <name>strtok2</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>string</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>delims</name></decl></param>, <param><decl><type><name>char</name>* *</type><name>newStr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_ASSERT</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>char</name></type> <name><name>delimTable</name><index>[<expr><name>DELIM_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>*</type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>*</type> <name>str</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>
  
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>DELIM_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <expr_stmt><expr><name><name>delimTable</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt></for>
  
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>delims</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><call><name>SET_DELIM</name><argument_list>(<argument><expr><name>delimTable</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>PRUint8</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>delims</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  
  <comment type="line">// skip to beginning</comment>
  <while>while <condition>(<expr>*<name>str</name> &amp;&amp; <call><name>IS_DELIM</name><argument_list>(<argument><expr><name>delimTable</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>PRUint8</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
    <expr_stmt><expr><name>str</name>++</expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><name>result</name> = <name>str</name></expr>;</expr_stmt>
  
  <comment type="line">// fix up the end of the token</comment>
  <while>while <condition>(<expr>*<name>str</name></expr>)</condition> <block>{
    <if>if <condition>(<expr><call><name>IS_DELIM</name><argument_list>(<argument><expr><name>delimTable</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>PRUint8</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr>*<name>str</name>++ = '\0'</expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>str</name>++</expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr>*<name>newStr</name> = <name>str</name></expr>;</expr_stmt>
  
  <return>return <expr><name>str</name> == <name>result</name> ? <name>NULL</name> : <name>result</name></expr>;</return>
}</block></function>



<enum>enum <name>client_auth_option</name> <block>{
  <decl><name>caNone</name> <init>= <expr>0</expr></init></decl>,
  <decl><name>caRequire</name> <init>= <expr>1</expr></init></decl>,
  <decl><name>caRequest</name> <init>= <expr>2</expr></init></decl>
}</block>;</enum>

<comment type="line">// Structs for passing data into jobs on the thread pool</comment>
<typedef>typedef <type><struct>struct <block>{<public type="default">
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>listen_port</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>string</name></type> <name>cert_nickname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PLHashTable</name>*</type> <name>host_cert_table</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PLHashTable</name>*</type> <name>host_clientauth_table</name></decl>;</decl_stmt>
  <comment type="line">// If not empty, and this server is using HTTP CONNECT, connections</comment>
  <comment type="line">// will be proxied to this address.</comment>
  <decl_stmt><decl><type><name>PRNetAddr</name></type> <name>remote_addr</name></decl>;</decl_stmt>
  <comment type="line">// True if no SSL should be used for this server's connections.</comment>
  <decl_stmt><decl><type><name>bool</name></type> <name>http_proxy_only</name></decl>;</decl_stmt>
  <comment type="line">// The original host in the Host: header for the initial connection is</comment>
  <comment type="line">// stored here, for proxied connections.</comment>
  <decl_stmt><decl><type><name>string</name></type> <name>original_host</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>server_info_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{<public type="default">
  <decl_stmt><decl><type><name>PRFileDesc</name>*</type> <name>client_sock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRNetAddr</name></type> <name>client_addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>server_info_t</name>*</type> <name>server_info</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>connection_info_t</name>;</typedef>

<decl_stmt><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name>BUF_SIZE</name> <init>= <expr>16384</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name>BUF_MARGIN</name> <init>= <expr>1024</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRInt32</name></type> <name>BUF_TOTAL</name> <init>= <expr><name>BUF_SIZE</name> + <name>BUF_MARGIN</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>HEADER_HOST</name><index>[]</index></name> <init>= <expr>"Host:"</expr></init></decl>;</decl_stmt>

<struct>struct <name>relayBuffer</name>
<block>{<public type="default">
  <decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>, *<decl><type ref="prev"/><name>bufferhead</name></decl>, *<decl><type ref="prev"/><name>buffertail</name></decl>, *<decl><type ref="prev"/><name>bufferend</name></decl>;</decl_stmt>

  <constructor><name>relayBuffer</name><parameter_list>()</parameter_list>
  <block>{
    <comment type="line">// Leave 1024 bytes more for request line manipulations</comment>
    <expr_stmt><expr><name>bufferhead</name> = <name>buffertail</name> = <name>buffer</name> = new <name><name>char</name><index>[<expr><name>BUF_TOTAL</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufferend</name> = <name>buffer</name> + <name>BUF_SIZE</name></expr>;</expr_stmt>
  }</block></constructor>

  <destructor><name>~<name>relayBuffer</name></name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr>delete <index>[]</index> <name>buffer</name></expr>;</expr_stmt>
  }</block></destructor>

  <function><type><name>void</name></type> <name>compact</name><parameter_list>()</parameter_list> <block>{
    <if>if <condition>(<expr><name>buffertail</name> == <name>bufferhead</name></expr>)</condition><then>
      <expr_stmt><expr><name>buffertail</name> = <name>bufferhead</name> = <name>buffer</name></expr>;</expr_stmt></then></if>
  }</block></function>

  <function><type><name>bool</name></type> <name>empty</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>bufferhead</name> == <name>buffertail</name></expr>;</return> }</block></function>
  <function><type><name>size_t</name></type> <name>free</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>bufferend</name> - <name>buffertail</name></expr>;</return> }</block></function>
  <function><type><name>size_t</name></type> <name>margin</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name>free</name><argument_list>()</argument_list></call> + <name>BUF_MARGIN</name></expr>;</return> }</block></function>
  <function><type><name>size_t</name></type> <name>present</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>buffertail</name> - <name>bufferhead</name></expr>;</return> }</block></function>
</public>}</block>;</struct>

<comment type="line">// A couple of stack classes for managing NSS/NSPR resources</comment>
<class>class <name>AutoCert</name> <block>{<private type="default">
</private><public>public:
  <constructor><name>AutoCert</name><parameter_list>(<param><decl><type><name>CERTCertificate</name>*</type> <name>cert</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>cert_</name> = <name>cert</name></expr>;</expr_stmt> }</block></constructor>
  <destructor><name>~<name>AutoCert</name></name><parameter_list>()</parameter_list> <block>{ <if>if <condition>(<expr><name>cert_</name></expr>)</condition><then> <expr_stmt><expr><call><name>CERT_DestroyCertificate</name><argument_list>(<argument><expr><name>cert_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> }</block></destructor>
  <function><name>operator CERTCertificate*</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>cert_</name></expr>;</return> }</block></function>
</public><private>private:
  <decl_stmt><decl><type><name>CERTCertificate</name>*</type> <name>cert_</name></decl>;</decl_stmt>
</private>}</block>;</class>

<class>class <name>AutoKey</name> <block>{<private type="default">
</private><public>public:
  <constructor><name>AutoKey</name><parameter_list>(<param><decl><type><name>SECKEYPrivateKey</name>*</type> <name>key</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>key_</name> = <name>key</name></expr>;</expr_stmt> }</block></constructor>
  <destructor><name>~<name>AutoKey</name></name><parameter_list>()</parameter_list> <block>{ <if>if <condition>(<expr><name>key_</name></expr>)</condition><then>   <expr_stmt><expr><call><name>SECKEY_DestroyPrivateKey</name><argument_list>(<argument><expr><name>key_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> }</block></destructor>
  <function><name>operator SECKEYPrivateKey*</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>key_</name></expr>;</return> }</block></function>
</public><private>private:
  <decl_stmt><decl><type><name>SECKEYPrivateKey</name>*</type> <name>key_</name></decl>;</decl_stmt>
</private>}</block>;</class>

<class>class <name>AutoFD</name> <block>{<private type="default">
</private><public>public:
  <constructor><name>AutoFD</name><parameter_list>(<param><decl><type><name>PRFileDesc</name>*</type> <name>fd</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><name>fd_</name> = <name>fd</name></expr>;</expr_stmt> }</block></constructor>
  <destructor><name>~<name>AutoFD</name></name><parameter_list>()</parameter_list> <block>{
    <if>if <condition>(<expr><name>fd_</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>PR_Shutdown</name><argument_list>(<argument><expr><name>fd_</name></expr></argument>, <argument><expr><name>PR_SHUTDOWN_BOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PR_Close</name><argument_list>(<argument><expr><name>fd_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></destructor>
  <function><name>operator PRFileDesc*</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>fd_</name></expr>;</return> }</block></function>
  <function><type><name>PRFileDesc</name>*</type> <name>reset</name><parameter_list>(<param><decl><type><name>PRFileDesc</name>*</type> <name>newfd</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>PRFileDesc</name>*</type> <name>oldfd</name> <init>= <expr><name>fd_</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>fd_</name> = <name>newfd</name></expr>;</expr_stmt>
    <return>return <expr><name>oldfd</name></expr>;</return>
  }</block></function>
</public><private>private:
  <decl_stmt><decl><type><name>PRFileDesc</name>*</type> <name>fd_</name></decl>;</decl_stmt>
</private>}</block>;</class>

<comment type="line">// These are suggestions. If the number of ports to proxy on * 2</comment>
<comment type="line">// is greater than either of these, then we'll use that value instead.</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>INITIAL_THREADS</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>MAX_THREADS</name> <init>= <expr>5</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PRUint32</name></type> <name>DEFAULT_STACKSIZE</name> <init>= <expr>(512 * 1024)</expr></init></decl>;</decl_stmt>

<comment type="line">// global data</comment>
<decl_stmt><decl><type><name>string</name></type> <name>nssconfigdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>vector</name><argument_list>&lt;<argument><expr><name>server_info_t</name></expr></argument>&gt;</argument_list></name></type> <name>servers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRNetAddr</name></type> <name>remote_addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRThreadPool</name>*</type> <name>threads</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRLock</name>*</type> <name>shutdown_lock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRCondVar</name>*</type> <name>shutdown_condvar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="line">// Not really used, unless something fails to start</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>shutdown_server</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>do_http_proxy</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>any_host_spec_config</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>

<function><type><name>PR_CALLBACK</name> <name>PRIntn</name></type> <name>ClientAuthValueComparator</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>v1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>v2</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>a</name> <init>= <expr>*<call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>client_auth_option</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call> -
          *<call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>client_auth_option</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>a</name> == 0</expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>
  <if>if <condition>(<expr><name>a</name> &gt; 0</expr>)</condition><then>
    <return>return <expr>1</expr>;</return></then>
  <else>else <comment type="line">// (a &lt; 0)</comment>
    <return>return <expr>-1</expr>;</return></else></if>
}</block></function>

<comment type="block">/*
 * Signal the main thread that the application should shut down.
 */</comment>
<function><type><name>void</name></type> <name>SignalShutdown</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_Lock</name><argument_list>(<argument><expr><name>shutdown_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_NotifyCondVar</name><argument_list>(<argument><expr><name>shutdown_condvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_Unlock</name><argument_list>(<argument><expr><name>shutdown_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>bool</name></type> <name>ReadConnectRequest</name><parameter_list>(<param><decl><type><name>server_info_t</name>*</type> <name>server_info</name></decl></param>, 
    <param><decl><type><name>relayBuffer</name>&amp;</type> <name>buffer</name></decl></param>, <param><decl><type><name>PRInt32</name>*</type> <name>result</name></decl></param>, <param><decl><type><name>string</name>&amp;</type> <name>certificate</name></decl></param>,
    <param><decl><type><name>client_auth_option</name>*</type> <name>clientauth</name></decl></param>, <param><decl><type><name>string</name>&amp;</type> <name>host</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>buffer</name>.<name>present</name></name><argument_list>()</argument_list></call> &lt; 4</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" !! only %d bytes present in the buffer"</expr></argument>, <argument><expr>(<name>int</name>)<call><name><name>buffer</name>.<name>present</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>false</expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>buffer</name>.<name>buffertail</name></name>-4</expr></argument>, <argument><expr>"\r\n\r\n"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" !! request is not tailed with CRLFCRLF but with %x %x %x %x"</expr></argument>, 
           <argument><expr>*(<name><name>buffer</name>.<name>buffertail</name></name>-4)</expr></argument>,
           <argument><expr>*(<name><name>buffer</name>.<name>buffertail</name></name>-3)</expr></argument>,
           <argument><expr>*(<name><name>buffer</name>.<name>buffertail</name></name>-2)</expr></argument>,
           <argument><expr>*(<name><name>buffer</name>.<name>buffertail</name></name>-1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>false</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" parsing initial connect request, dump:\n%.*s\n"</expr></argument>, <argument><expr>(<name>int</name>)<call><name><name>buffer</name>.<name>present</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>buffer</name>.<name>bufferhead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>result</name> = 400</expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name>*</type> <name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>*</type> <name>_caret</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>token</name> = <call><name>strtok2</name><argument_list>(<argument><expr><name><name>buffer</name>.<name>bufferhead</name></name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>token</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" no space found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"CONNECT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" not CONNECT request but %s"</expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>token</name> = <call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>void</name>*</type> <name>c</name> <init>= <expr><call><name>PL_HashTableLookup</name><argument_list>(<argument><expr><name><name>server_info</name>-&gt;<name>host_cert_table</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>c</name></expr>)</condition><then>
    <expr_stmt><expr><name>certificate</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>char</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>host</name> = "https://"</expr>;</expr_stmt>
  <expr_stmt><expr><name>host</name> += <name>token</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>c</name> = <call><name>PL_HashTableLookup</name><argument_list>(<argument><expr><name><name>server_info</name>-&gt;<name>host_clientauth_table</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>c</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>clientauth</name> = *<call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>client_auth_option</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>clientauth</name> = <name>caNone</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>token</name> = <call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"HTTP"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" not tailed with HTTP but with %s"</expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>result</name> = 200</expr>;</expr_stmt>
  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name>ConfigureSSLServerSocket</name><parameter_list>(<param><decl><type><name>PRFileDesc</name>*</type> <name>socket</name></decl></param>, <param><decl><type><name>server_info_t</name>*</type> <name>si</name></decl></param>, <param><decl><type><name>string</name> &amp;</type><name>certificate</name></decl></param>, <param><decl><type><name>client_auth_option</name></type> <name>clientAuth</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>certnick</name> <init>= <expr><call><name><name>certificate</name>.<name>empty</name></name><argument_list>()</argument_list></call> ?
      <call><name><name>si</name>-&gt;<name>cert_nickname</name>.<name>c_str</name></name><argument_list>()</argument_list></call> : <call><name><name>certificate</name>.<name>c_str</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>AutoCert</name></type> <name>cert</name><argument_list>(<argument><expr><call><name>PK11_FindCertFromNickname</name><argument_list>(
      <argument><expr><name>certnick</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>cert</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Failed to find cert %s\n"</expr></argument>, <argument><expr><name>certnick</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>false</expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>AutoKey</name></type> <name>privKey</name><argument_list>(<argument><expr><call><name>PK11_FindKeyByAnyCert</name><argument_list>(<argument><expr><name>cert</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>privKey</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Failed to find private key\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>false</expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRFileDesc</name>*</type> <name>ssl_socket</name> <init>= <expr><call><name>SSL_ImportFD</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>socket</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>ssl_socket</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Error importing SSL socket\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>false</expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>SSLKEAType</name></type> <name>certKEA</name> <init>= <expr><call><name>NSS_FindCertKEAType</name><argument_list>(<argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>SSL_ConfigSecureServer</name><argument_list>(<argument><expr><name>ssl_socket</name></expr></argument>, <argument><expr><name>cert</name></expr></argument>, <argument><expr><name>privKey</name></expr></argument>, <argument><expr><name>certKEA</name></expr></argument>)</argument_list></call>
      != <name>SECSuccess</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Error configuring SSL server socket\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>false</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>ssl_socket</name></expr></argument>, <argument><expr><name>SSL_SECURITY</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>ssl_socket</name></expr></argument>, <argument><expr><name>SSL_HANDSHAKE_AS_CLIENT</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>ssl_socket</name></expr></argument>, <argument><expr><name>SSL_HANDSHAKE_AS_SERVER</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>clientAuth</name> != <name>caNone</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>ssl_socket</name></expr></argument>, <argument><expr><name>SSL_REQUEST_CERTIFICATE</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>ssl_socket</name></expr></argument>, <argument><expr><name>SSL_REQUIRE_CERTIFICATE</name></expr></argument>, <argument><expr><name>clientAuth</name> == <name>caRequire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>SSL_ResetHandshake</name><argument_list>(<argument><expr><name>ssl_socket</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * This function examines the buffer for a S5ec-WebSocket-Location: field, 
 * and if it's present, it replaces the hostname in that field with the
 * value in the server's original_host field.  This function works
 * in the reverse direction as AdjustHost(), replacing the real hostname
 * of a response with the potentially fake hostname that is expected
 * by the browser (e.g., mochi.test).
 *
 * @return true if the header was adjusted successfully, or not found, false
 * if the header is present but the url is not, which should indicate
 * that more data needs to be read from the socket
 */</comment>
<function><type><name>bool</name></type> <name>AdjustWebSocketLocation</name><parameter_list>(<param><decl><type><name>relayBuffer</name>&amp;</type> <name>buffer</name></decl></param>, <param><decl><type><name>server_info_t</name> *</type><name>si</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>buffer</name>.<name>margin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>buffer</name>.<name>buffertail</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name>*</type> <name>wsloc</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>buffer</name>.<name>bufferhead</name></name></expr></argument>, <argument><expr>"Sec-WebSocket-Location:"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>wsloc</name></expr>)</condition><then>
    <return>return <expr>true</expr>;</return></then></if>
  <comment type="line">// advance pointer to the start of the hostname</comment>
  <expr_stmt><expr><name>wsloc</name> = <call><name>strstr</name><argument_list>(<argument><expr><name>wsloc</name></expr></argument>, <argument><expr>"ws://"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>wsloc</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>
  <expr_stmt><expr><name>wsloc</name> += 5</expr>;</expr_stmt>
  <comment type="line">// find the end of the hostname</comment>
  <decl_stmt><decl><type><name>char</name>*</type> <name>wslocend</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>wsloc</name> + 1</expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>wslocend</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>
  <decl_stmt><decl><type><name>char</name> *</type><name>crlf</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>wsloc</name></expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>crlf</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>
  <if>if <condition>(<expr><call><name><name>si</name>-&gt;<name>original_host</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr>true</expr>;</return></then></if>

  <decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr><call><name><name>si</name>-&gt;<name>original_host</name>.<name>length</name></name><argument_list>()</argument_list></call> - (<name>wslocend</name>-<name>wsloc</name>)</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>diff</name> &gt; 0</expr>)</condition><then>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call> &lt;= <call><name><name>buffer</name>.<name>margin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>wslocend</name> + <name>diff</name></expr></argument>, <argument><expr><name>wslocend</name></expr></argument>, <argument><expr><name><name>buffer</name>.<name>buffertail</name></name> - <name>wsloc</name> - <name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>buffer</name>.<name>buffertail</name></name> += <name>diff</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>wsloc</name></expr></argument>, <argument><expr><call><name><name>si</name>-&gt;<name>original_host</name>.<name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>si</name>-&gt;<name>original_host</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * This function examines the buffer for a Host: field, and if it's present,
 * it replaces the hostname in that field with the hostname in the server's
 * remote_addr field.  This is needed because proxy requests may be coming
 * from mochitest with fake hosts, like mochi.test, and these need to be
 * replaced with the host that the destination server is actually running
 * on.
 */</comment>
<function><type><name>bool</name></type> <name>AdjustHost</name><parameter_list>(<param><decl><type><name>relayBuffer</name>&amp;</type> <name>buffer</name></decl></param>, <param><decl><type><name>server_info_t</name> *</type><name>si</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name><name>si</name>-&gt;<name>remote_addr</name>.<name>inet</name>.<name>port</name></name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>buffer</name>.<name>margin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Cannot use strnchr so add a null char at the end. There is always some</comment>
  <comment type="line">// space left because we preserve a margin.</comment>
  <expr_stmt><expr><name><name>buffer</name>.<name>buffertail</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name>*</type> <name>host</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>buffer</name>.<name>bufferhead</name></name></expr></argument>, <argument><expr><name>HEADER_HOST</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>host</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>
  <comment type="line">// advance pointer to beginning of hostname</comment>
  <expr_stmt><expr><name>host</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>HEADER_HOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>host</name> += <call><name>strspn</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr>" \t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name>*</type> <name>endhost</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>endhost</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <comment type="line">// Save the original host, so we can use it later on responses from the</comment>
  <comment type="line">// server.</comment>
  <expr_stmt><expr><call><name><name>si</name>-&gt;<name>original_host</name>.<name>assign</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name>endhost</name>-<name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name></type> <name><name>newhost</name><index>[<expr>40</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PR_NetAddrToString</name><argument_list>(<argument><expr>&amp;<name><name>si</name>-&gt;<name>remote_addr</name></name></expr></argument>, <argument><expr><name>newhost</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>newhost</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>newhost</name></expr></argument>)</argument_list></call> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>newhost</name></expr></argument>)</argument_list></sizeof> - 7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>newhost</name></expr></argument>, <argument><expr>"%s:%d"</expr></argument>, <argument><expr><name>newhost</name></expr></argument>, <argument><expr><call><name>PR_ntohs</name><argument_list>(<argument><expr><name><name>si</name>-&gt;<name>remote_addr</name>.<name>inet</name>.<name>port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>newhost</name></expr></argument>)</argument_list></call> - (<name>endhost</name>-<name>host</name>)</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>diff</name> &gt; 0</expr>)</condition><then>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>size_t</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call> &lt;= <call><name><name>buffer</name>.<name>margin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>endhost</name> + <name>diff</name></expr></argument>, <argument><expr><name>endhost</name></expr></argument>, <argument><expr><name><name>buffer</name>.<name>buffertail</name></name> - <name>host</name> - <name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>buffer</name>.<name>buffertail</name></name> += <name>diff</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name>newhost</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>newhost</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * This function prefixes Request-URI path with a full scheme-host-port
 * string.
 */</comment>
<function><type><name>bool</name></type> <name>AdjustRequestURI</name><parameter_list>(<param><decl><type><name>relayBuffer</name>&amp;</type> <name>buffer</name></decl></param>, <param><decl><type><name>string</name> *</type><name>host</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>buffer</name>.<name>margin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Cannot use strnchr so add a null char at the end. There is always some space left</comment>
  <comment type="line">// because we preserve a margin.</comment>
  <expr_stmt><expr><name><name>buffer</name>.<name>buffertail</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" incoming request to adjust:\n%s\n"</expr></argument>, <argument><expr><name><name>buffer</name>.<name>bufferhead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name> *</type><name>token</name></decl>, *<decl><type ref="prev"/><name>path</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>path</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>buffer</name>.<name>bufferhead</name></name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>path</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <comment type="line">// If the path doesn't start with a slash don't change it, it is probably '*' or a full</comment>
  <comment type="line">// path already. Return true, we are done with this request adjustment.</comment>
  <if>if <condition>(<expr>*<name>path</name> != '/'</expr>)</condition><then>
    <return>return <expr>true</expr>;</return></then></if>

  <expr_stmt><expr><name>token</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>token</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"HTTP/"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <decl_stmt><decl><type><name>size_t</name></type> <name>hostlength</name> <init>= <expr><call><name><name>host</name>-&gt;<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>hostlength</name> &lt;= <call><name><name>buffer</name>.<name>margin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>path</name> + <name>hostlength</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>buffer</name>.<name>buffertail</name></name> - <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name><name>host</name>-&gt;<name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hostlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>buffer</name>.<name>buffertail</name></name> += <name>hostlength</name></expr>;</expr_stmt>

  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name>ConnectSocket</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>PRNetAddr</name> *</type><name>addr</name></decl></param>, <param><decl><type><name>PRIntervalTime</name></type> <name>timeout</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRStatus</name></type> <name>stat</name> <init>= <expr><call><name>PR_Connect</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>stat</name> != <name>PR_SUCCESS</name></expr>)</condition><then>
    <return>return <expr>false</expr>;</return></then></if>

  <decl_stmt><decl><type><name>PRSocketOptionData</name></type> <name>option</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>option</name>.<name>option</name></name> = <name>PR_SockOpt_Nonblocking</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>option</name>.<name>value</name>.<name>non_blocking</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_SetSocketOption</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr>true</expr>;</return>
}</block></function>

<comment type="block">/*
 * Handle an incoming client connection. The server thread has already
 * accepted the connection, so we just need to connect to the remote
 * port and then proxy data back and forth.
 * The data parameter is a connection_info_t*, and must be deleted
 * by this function.
 */</comment>
<function><type><name>void</name></type> <name>HandleConnection</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>data</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>connection_info_t</name>*</type> <name>ci</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>connection_info_t</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRIntervalTime</name></type> <name>connect_timeout</name> <init>= <expr><call><name>PR_SecondsToInterval</name><argument_list>(<argument><expr>30</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>AutoFD</name></type> <name>other_sock</name><argument_list>(<argument><expr><call><name>PR_NewTCPSocket</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>client_done</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>client_error</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>connect_accepted</name> <init>= <expr>!<name>do_http_proxy</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>ssl_updated</name> <init>= <expr>!<name>do_http_proxy</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>expect_request_start</name> <init>= <expr><name>do_http_proxy</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>string</name></type> <name>certificateToUse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>client_auth_option</name></type> <name>clientAuth</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>string</name></type> <name>fullHost</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SSLTUNNEL(%p): incoming connection csock(0)=%p, ssock(1)=%p\n"</expr></argument>,
         <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>client_sock</name></name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>other_sock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>other_sock</name></expr>)</condition><then> 
  <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>numberOfSockets</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>relayBuffer</name></type> <name><name>buffers</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>do_http_proxy</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>!<name><name>ci</name>-&gt;<name>server_info</name>-&gt;<name>http_proxy_only</name></name> &amp;&amp; 
          !<call><name>ConfigureSSLServerSocket</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>client_sock</name></name></expr></argument>, <argument><expr><name><name>ci</name>-&gt;<name>server_info</name></name></expr></argument>, <argument><expr><name>certificateToUse</name></expr></argument>, <argument><expr><name>caNone</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>client_error</name> = true</expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>!<call><name>ConnectSocket</name><argument_list>(<argument><expr><name>other_sock</name></expr></argument>, <argument><expr>&amp;<name>remote_addr</name></expr></argument>, <argument><expr><name>connect_timeout</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>client_error</name> = true</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>numberOfSockets</name> = 2</expr>;</expr_stmt></else></if></else></if>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRPollDesc</name></type> <name><name>sockets</name><index>[<expr>2</expr>]</index></name> <init>= 
    <expr><block>{ 
      <expr><block>{<expr><name><name>ci</name>-&gt;<name>client_sock</name></name></expr>, <expr><name>PR_POLL_READ</name></expr>, <expr>0</expr>}</block></expr>,
      <expr><block>{<expr><name>other_sock</name></expr>, <expr><name>PR_POLL_READ</name></expr>, <expr>0</expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name><name>socketErrorState</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{<expr><name>PR_FALSE</name></expr>, <expr><name>PR_FALSE</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr>!((<name>client_error</name>||<name>client_done</name>) &amp;&amp; <name><name>buffers</name><index>[<expr>0</expr>]</index></name>.<call><name>empty</name><argument_list>()</argument_list></call> &amp;&amp; <name><name>buffers</name><index>[<expr>1</expr>]</index></name>.<call><name>empty</name><argument_list>()</argument_list></call>)</expr>)</condition>
    <block>{
      <expr_stmt><expr><name><name>sockets</name><index>[<expr>0</expr>]</index></name>.<name>in_flags</name> |= <name>PR_POLL_EXCEPT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>sockets</name><index>[<expr>1</expr>]</index></name>.<name>in_flags</name> |= <name>PR_POLL_EXCEPT</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SSLTUNNEL(%p): polling flags csock(0)=%c%c, ssock(1)=%c%c\n"</expr></argument>,
             <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><name><name>sockets</name><index>[<expr>0</expr>]</index></name>.<name>in_flags</name> &amp; <name>PR_POLL_READ</name>  ? 'R' : '-'</expr></argument>,
             <argument><expr><name><name>sockets</name><index>[<expr>0</expr>]</index></name>.<name>in_flags</name> &amp; <name>PR_POLL_WRITE</name> ? 'W' : '-'</expr></argument>,
             <argument><expr><name><name>sockets</name><index>[<expr>1</expr>]</index></name>.<name>in_flags</name> &amp; <name>PR_POLL_READ</name>  ? 'R' : '-'</expr></argument>,
             <argument><expr><name><name>sockets</name><index>[<expr>1</expr>]</index></name>.<name>in_flags</name> &amp; <name>PR_POLL_WRITE</name> ? 'W' : '-'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>PRInt32</name></type> <name>pollStatus</name> <init>= <expr><call><name>PR_Poll</name><argument_list>(<argument><expr><name>sockets</name></expr></argument>, <argument><expr><name>numberOfSockets</name></expr></argument>, <argument><expr><call><name>PR_MillisecondsToInterval</name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>pollStatus</name> &lt; 0</expr>)</condition><then>
      <block>{
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SSLTUNNEL(%p): pollStatus=%d, exiting\n"</expr></argument>,
               <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pollStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>client_error</name> = true</expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>

      <if>if <condition>(<expr><name>pollStatus</name> == 0</expr>)</condition><then>
      <block>{
        <comment type="line">// timeout</comment>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SSLTUNNEL(%p): poll timeout, looping\n"</expr></argument>,
               <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      }</block></then></if>

      <for>for (<init><decl><type><name>PRInt32</name></type> <name>s</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>s</name> &lt; <name>numberOfSockets</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>)
      <block>{
        <decl_stmt><decl><type><name>PRInt32</name></type> <name>s2</name> <init>= <expr><name>s</name> == 1 ? 0 : 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt16</name></type> <name>out_flags</name> <init>= <expr><name><name>sockets</name><index>[<expr><name>s</name></expr>]</index></name>.<name>out_flags</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt16</name> &amp;</type><name>in_flags</name> <init>= <expr><name><name>sockets</name><index>[<expr><name>s</name></expr>]</index></name>.<name>in_flags</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PRInt16</name> &amp;</type><name>in_flags2</name> <init>= <expr><name><name>sockets</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>in_flags</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>sockets</name><index>[<expr><name>s</name></expr>]</index></name>.<name>out_flags</name> = 0</expr>;</expr_stmt>

        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SSLTUNNEL(%p): %csock(%d)=%p out_flags=%d"</expr></argument>,
               <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>s</name> == 0 ? 'c' : 's'</expr></argument>,
               <argument><expr><name>s</name></expr></argument>,
               <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>s</name></expr>]</index></name>.<name>fd</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>out_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>out_flags</name> &amp; (<name>PR_POLL_EXCEPT</name> | <name>PR_POLL_ERR</name> | <name>PR_POLL_HUP</name>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" :exception\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>client_error</name> = true</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>socketErrorState</name><index>[<expr><name>s</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
          <comment type="line">// We got a fatal error state on the socket. Clear the output buffer</comment>
          <comment type="line">// for this socket to break the main loop, we will never more be able</comment>
          <comment type="line">// to send those data anyway.</comment>
          <expr_stmt><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>bufferhead</name> = <name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffertail</name> = <name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffer</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        }</block></then></if> <comment type="line">// PR_POLL_EXCEPT, PR_POLL_ERR, PR_POLL_HUP handling</comment>

        <if>if <condition>(<expr><name>out_flags</name> &amp; <name>PR_POLL_READ</name> &amp;&amp; !<name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name>.<call><name>free</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
           <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" no place in read buffer but got read flag, dropping it now!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><name>in_flags</name> &amp;= ~<name>PR_POLL_READ</name></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>out_flags</name> &amp; <name>PR_POLL_READ</name> &amp;&amp; <name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name>.<call><name>free</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" :reading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>bytesRead</name> <init>= <expr><call><name>PR_Recv</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>s</name></expr>]</index></name>.<name>fd</name></expr></argument>, <argument><expr><name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name>.<name>buffertail</name></expr></argument>, 
              <argument><expr><name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name>.<call><name>free</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>PR_INTERVAL_NO_TIMEOUT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name>bytesRead</name> == 0</expr>)</condition><then>
          <block>{
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" socket gracefully closed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>client_done</name> = true</expr>;</expr_stmt>
            <expr_stmt><expr><name>in_flags</name> &amp;= ~<name>PR_POLL_READ</name></expr>;</expr_stmt>
          }</block></then>
          <else>else <if>if <condition>(<expr><name>bytesRead</name> &lt; 0</expr>)</condition><then>
          <block>{
            <if>if <condition>(<expr><call><name>PR_GetError</name><argument_list>()</argument_list></call> != <name>PR_WOULD_BLOCK_ERROR</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" error=%d"</expr></argument>, <argument><expr><call><name>PR_GetError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <comment type="line">// We are in error state, indicate that the connection was </comment>
              <comment type="line">// not closed gracefully</comment>
              <expr_stmt><expr><name>client_error</name> = true</expr>;</expr_stmt>
              <expr_stmt><expr><name><name>socketErrorState</name><index>[<expr><name>s</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
              <comment type="line">// Wipe out our send buffer, we cannot send it anyway.</comment>
              <expr_stmt><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>bufferhead</name> = <name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffertail</name> = <name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffer</name></expr>;</expr_stmt>
            }</block></then>
            <else>else
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" would block"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          }</block></then>
          <else>else
          <block>{
            <comment type="line">// If the other socket is in error state (unable to send/receive)</comment>
            <comment type="line">// throw this data away and continue loop</comment>
            <if>if <condition>(<expr><name><name>socketErrorState</name><index>[<expr><name>s2</name></expr>]</index></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" have read but other socket is in error state\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name>.<name>buffertail</name> += <name>bytesRead</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>", read %d bytes"</expr></argument>, <argument><expr><name>bytesRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// We have to accept and handle the initial CONNECT request here</comment>
            <decl_stmt><decl><type><name>PRInt32</name></type> <name>response</name></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>connect_accepted</name> &amp;&amp; <call><name>ReadConnectRequest</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>server_info</name></name></expr></argument>, <argument><expr><name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name></expr></argument>,
                <argument><expr>&amp;<name>response</name></expr></argument>, <argument><expr><name>certificateToUse</name></expr></argument>, <argument><expr>&amp;<name>clientAuth</name></expr></argument>, <argument><expr><name>fullHost</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <comment type="line">// Clean the request as it would be read</comment>
              <expr_stmt><expr><name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name>.<name>bufferhead</name> = <name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name>.<name>buffertail</name> = <name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name>.<name>buffer</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>in_flags</name> |= <name>PR_POLL_WRITE</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>connect_accepted</name> = true</expr>;</expr_stmt>

              <comment type="line">// Store response to the oposite buffer</comment>
              <if>if <condition>(<expr><name>response</name> != 200</expr>)</condition><then>
              <block>{
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" could not read the connect request, closing connection with %d"</expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>client_done</name> = true</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffer</name></expr></argument>, <argument><expr>"HTTP/1.1 %d ERROR\r\nConnection: close\r\n\r\n"</expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffertail</name> = <name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffer</name> + <call><name>strlen</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              }</block></then></if>

              <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffer</name></expr></argument>, <argument><expr>"HTTP/1.1 200 Connected\r\nConnection: keep-alive\r\n\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffertail</name> = <name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffer</name> + <call><name>strlen</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <decl_stmt><decl><type><name>PRNetAddr</name>*</type> <name>addr</name> <init>= <expr>&amp;<name>remote_addr</name></expr></init></decl>;</decl_stmt>
              <if>if <condition>(<expr><name><name>ci</name>-&gt;<name>server_info</name>-&gt;<name>remote_addr</name>.<name>inet</name>.<name>port</name></name> &gt; 0</expr>)</condition><then>
                <expr_stmt><expr><name>addr</name> = &amp;<name><name>ci</name>-&gt;<name>server_info</name>-&gt;<name>remote_addr</name></name></expr>;</expr_stmt></then></if>
              <if>if <condition>(<expr>!<call><name>ConnectSocket</name><argument_list>(<argument><expr><name>other_sock</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>connect_timeout</name></expr></argument>)</argument_list></call></expr>)</condition><then>
              <block>{
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" could not open connection to the real server\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>client_error</name> = true</expr>;</expr_stmt>
                <break>break;</break>
              }</block></then></if>

              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" accepted CONNECT request, connected to the server, sending OK to the client\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <comment type="line">// Send the response to the client socket</comment>
              <break>break;</break>
            }</block></then></if> <comment type="line">// end of CONNECT handling</comment>

            <if>if <condition>(<expr>!<name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name>.<call><name>free</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
              <comment type="line">// Do not poll for read when the buffer is full</comment>
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" no place in our read buffer, stop reading"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>in_flags</name> &amp;= ~<name>PR_POLL_READ</name></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>ssl_updated</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name>s</name> == 0 &amp;&amp; <name>expect_request_start</name></expr>)</condition><then> 
              <block>{
                <if>if <condition>(<expr><name><name>ci</name>-&gt;<name>server_info</name>-&gt;<name>http_proxy_only</name></name></expr>)</condition><then>
                  <expr_stmt><expr><name>expect_request_start</name> = !<call><name>AdjustHost</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ci</name>-&gt;<name>server_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                  <expr_stmt><expr><name>expect_request_start</name> = !<call><name>AdjustRequestURI</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>fullHost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
              }</block></then>
              <else>else
              <block>{
                <if>if <condition>(<expr>!<call><name>AdjustWebSocketLocation</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>s</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ci</name>-&gt;<name>server_info</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                  <continue>continue;</continue></then></if>
              }</block></else></if>

              <expr_stmt><expr><name>in_flags2</name> |= <name>PR_POLL_WRITE</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" telling the other socket to write"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" we have something for the other socket to write, but ssl has not been administered on it"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          }</block></else></if></else></if>
        }</block></then></if> <comment type="line">// PR_POLL_READ handling</comment>

        <if>if <condition>(<expr><name>out_flags</name> &amp; <name>PR_POLL_WRITE</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" :writting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <decl_stmt><decl><type><name>PRInt32</name></type> <name>bytesWrite</name> <init>= <expr><call><name>PR_Send</name><argument_list>(<argument><expr><name><name>sockets</name><index>[<expr><name>s</name></expr>]</index></name>.<name>fd</name></expr></argument>, <argument><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>bufferhead</name></expr></argument>, 
              <argument><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<call><name>present</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>PR_INTERVAL_NO_TIMEOUT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name>bytesWrite</name> &lt; 0</expr>)</condition><then>
          <block>{
            <if>if <condition>(<expr><call><name>PR_GetError</name><argument_list>()</argument_list></call> != <name>PR_WOULD_BLOCK_ERROR</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" error=%d"</expr></argument>, <argument><expr><call><name>PR_GetError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>client_error</name> = true</expr>;</expr_stmt>
              <expr_stmt><expr><name><name>socketErrorState</name><index>[<expr><name>s</name></expr>]</index></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
              <comment type="line">// We got a fatal error while writting the buffer. Clear it to break</comment>
              <comment type="line">// the main loop, we will never more be able to send it.</comment>
              <expr_stmt><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>bufferhead</name> = <name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffertail</name> = <name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>buffer</name></expr>;</expr_stmt>
            }</block></then>
            <else>else
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" would block"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          }</block></then>
          <else>else
          <block>{
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>", written %d bytes"</expr></argument>, <argument><expr><name>bytesWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name><name>buffertail</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" dump:\n%.*s\n"</expr></argument>, <argument><expr><name>bytesWrite</name></expr></argument>, <argument><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>bufferhead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<name>bufferhead</name> += <name>bytesWrite</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<call><name>present</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" still have to write %d bytes"</expr></argument>, <argument><expr>(<name>int</name>)<name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<call><name>present</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>in_flags</name> |= <name>PR_POLL_WRITE</name></expr>;</expr_stmt>
            }</block></then>              
            <else>else
            <block>{
              <if>if <condition>(<expr>!<name>ssl_updated</name></expr>)</condition><then>
              <block>{
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" proxy response sent to the client"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Proxy response has just been writen, update to ssl</comment>
                <expr_stmt><expr><name>ssl_updated</name> = true</expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name><name>ci</name>-&gt;<name>server_info</name>-&gt;<name>http_proxy_only</name></name> &amp;&amp; 
                    !<call><name>ConfigureSSLServerSocket</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>client_sock</name></name></expr></argument>, <argument><expr><name><name>ci</name>-&gt;<name>server_info</name></name></expr></argument>, <argument><expr><name>certificateToUse</name></expr></argument>, <argument><expr><name>clientAuth</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" but failed to config server socket\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name>client_error</name> = true</expr>;</expr_stmt>
                  <break>break;</break>
                }</block></then></if>

                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" client socket updated to SSL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>numberOfSockets</name> = 2</expr>;</expr_stmt>
              }</block></then></if> <comment type="line">// sslUpdate</comment>

              <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" dropping our write flag and setting other socket read flag"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>in_flags</name> &amp;= ~<name>PR_POLL_WRITE</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>in_flags2</name> |= <name>PR_POLL_READ</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>buffers</name><index>[<expr><name>s2</name></expr>]</index></name>.<call><name>compact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
          }</block></else></if>
        }</block></then></if> <comment type="line">// PR_POLL_WRITE handling</comment>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// end the log</comment>
      }</block></for> <comment type="line">// for...</comment>
    }</block></while> <comment type="line">// while, poll</comment>
  }</block></then>
  <else>else
    <expr_stmt><expr><name>client_error</name> = true</expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SSLTUNNEL(%p): exiting root function for csock=%p, ssock=%p\n"</expr></argument>,
         <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>client_sock</name></name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>void</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>other_sock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>client_error</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>PR_Shutdown</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>client_sock</name></name></expr></argument>, <argument><expr><name>PR_SHUTDOWN_SEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>PR_Close</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>client_sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>delete <name>ci</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Start listening for SSL connections on a specified port, handing
 * them off to client threads after accepting the connection.
 * The data parameter is a server_info_t*, owned by the calling
 * function.
 */</comment>
<function><type><name>void</name></type> <name>StartServer</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>data</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_info_t</name>*</type> <name>si</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>server_info_t</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">//TODO: select ciphers?</comment>
  <decl_stmt><decl><type><name>AutoFD</name></type> <name>listen_socket</name><argument_list>(<argument><expr><call><name>PR_NewTCPSocket</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>listen_socket</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"failed to create socket\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SignalShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <comment type="line">// In case the socket is still open in the TIME_WAIT state from a previous</comment>
  <comment type="line">// instance of ssltunnel we ask to reuse the port.</comment>
  <decl_stmt><decl><type><name>PRSocketOptionData</name></type> <name>socket_option</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>socket_option</name>.<name>option</name></name> = <name>PR_SockOpt_Reuseaddr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>socket_option</name>.<name>value</name>.<name>reuse_addr</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_SetSocketOption</name><argument_list>(<argument><expr><name>listen_socket</name></expr></argument>, <argument><expr>&amp;<name>socket_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRNetAddr</name></type> <name>server_addr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PR_InitializeNetAddr</name><argument_list>(<argument><expr><name>PR_IpAddrAny</name></expr></argument>, <argument><expr><name><name>si</name>-&gt;<name>listen_port</name></name></expr></argument>, <argument><expr>&amp;<name>server_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>PR_Bind</name><argument_list>(<argument><expr><name>listen_socket</name></expr></argument>, <argument><expr>&amp;<name>server_addr</name></expr></argument>)</argument_list></call> != <name>PR_SUCCESS</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"failed to bind socket\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SignalShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <if>if <condition>(<expr><call><name>PR_Listen</name><argument_list>(<argument><expr><name>listen_socket</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> != <name>PR_SUCCESS</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"failed to listen on socket\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SignalShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Server listening on port %d with cert %s\n"</expr></argument>, <argument><expr><name><name>si</name>-&gt;<name>listen_port</name></name></expr></argument>,
         <argument><expr><call><name><name>si</name>-&gt;<name>cert_nickname</name>.<name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr>!<name>shutdown_server</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>connection_info_t</name>*</type> <name>ci</name> <init>= <expr>new <call><name>connection_info_t</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>server_info</name></name> = <name>si</name></expr>;</expr_stmt>
    <comment type="line">// block waiting for connections</comment>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>client_sock</name></name> = <call><name>PR_Accept</name><argument_list>(<argument><expr><name>listen_socket</name></expr></argument>, <argument><expr>&amp;<name><name>ci</name>-&gt;<name>client_addr</name></name></expr></argument>,
                                <argument><expr><name>PR_INTERVAL_NO_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <decl_stmt><decl><type><name>PRSocketOptionData</name></type> <name>option</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>option</name>.<name>option</name></name> = <name>PR_SockOpt_Nonblocking</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>option</name>.<name>value</name>.<name>non_blocking</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_SetSocketOption</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>client_sock</name></name></expr></argument>, <argument><expr>&amp;<name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>ci</name>-&gt;<name>client_sock</name></name></expr>)</condition><then>
      <comment type="line">// Not actually using this PRJob*...</comment>
      <comment type="line">//PRJob* job =</comment>
      <expr_stmt><expr><call><name>PR_QueueJob</name><argument_list>(<argument><expr><name>threads</name></expr></argument>, <argument><expr><name>HandleConnection</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr>delete <name>ci</name></expr>;</expr_stmt></else></if>
  }</block></while>
}</block></function>

<comment type="line">// bogus password func, just don't use passwords. :-P</comment>
<function><type><name>char</name>*</type> <name>password_func</name><parameter_list>(<param><decl><type><name>PK11SlotInfo</name>*</type> <name>slot</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>retry</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>arg</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>retry</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <return>return <expr><call><name>PL_strdup</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>server_info_t</name>*</type> <name>findServerInfo</name><parameter_list>(<param><decl><type><name>int</name></type> <name>portnumber</name></decl></param>)</parameter_list>
<block>{
  <for>for (<init><decl><type><name><name><name>vector</name><argument_list>&lt;<argument><expr><name>server_info_t</name></expr></argument>&gt;</argument_list></name>::<name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>servers</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
       <condition><expr><name>it</name> != <call><name><name>servers</name>.<name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>it</name>++</expr></incr>) 
  <block>{
    <if>if <condition>(<expr><name><name>it</name>-&gt;<name>listen_port</name></name> == <name>portnumber</name></expr>)</condition><then>
      <return>return <expr>&amp;(*<name>it</name>)</expr>;</return></then></if>
  }</block></for>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>processConfigLine</name><parameter_list>(<param><decl><type><name>char</name>*</type> <name>configLine</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>*<name>configLine</name> == 0 || *<name>configLine</name> == '#'</expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <decl_stmt><decl><type><name>char</name>*</type> <name>_caret</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>*</type> <name>keyword</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>configLine</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Configure usage of http/ssl tunneling proxy behavior</comment>
  <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr>"httpproxy"</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>char</name>*</type> <name>value</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>)</condition><then>
      <expr_stmt><expr><name>do_http_proxy</name> = true</expr>;</expr_stmt></then></if>

    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="line">// Configure the forward address of the target server</comment>
  <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr>"forward"</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>char</name>*</type> <name>ipstring</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>PR_StringToNetAddr</name><argument_list>(<argument><expr><name>ipstring</name></expr></argument>, <argument><expr>&amp;<name>remote_addr</name></expr></argument>)</argument_list></call> != <name>PR_SUCCESS</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Invalid remote IP address: %s\n"</expr></argument>, <argument><expr><name>ipstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>char</name>*</type> <name>serverportstring</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>serverportstring</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>port</name> &lt;= 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Invalid remote port: %s\n"</expr></argument>, <argument><expr><name>serverportstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>remote_addr</name>.<name>inet</name>.<name>port</name></name> = <call><name>PR_htons</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr>"proxy"</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>server_info_t</name></type> <name>server</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>server</name>.<name>host_cert_table</name></name> = <call><name>PL_NewHashTable</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>PL_HashString</name></expr></argument>, <argument><expr><name>PL_CompareStrings</name></expr></argument>, <argument><expr><name>PL_CompareStrings</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name>.<name>host_clientauth_table</name></name> = <call><name>PL_NewHashTable</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>PL_HashString</name></expr></argument>, <argument><expr><name>PL_CompareStrings</name></expr></argument>, <argument><expr><name>ClientAuthValueComparator</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name>.<name>http_proxy_only</name></name> = true</expr>;</expr_stmt>

    <decl_stmt><decl><type><name>char</name>*</type> <name>listenport</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>server</name>.<name>listen_port</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><name>listenport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>server</name>.<name>listen_port</name></name> &lt;= 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Invalid listen port in proxy config: %s\n"</expr></argument>, <argument><expr><name>listenport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>char</name>*</type> <name>ipstring</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>PR_StringToNetAddr</name><argument_list>(<argument><expr><name>ipstring</name></expr></argument>, <argument><expr>&amp;<name><name>server</name>.<name>remote_addr</name></name></expr></argument>)</argument_list></call> != <name>PR_SUCCESS</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Invalid IP address in proxy config: %s\n"</expr></argument>, <argument><expr><name>ipstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <decl_stmt><decl><type><name>char</name>*</type> <name>remoteport</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>remoteport</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>port</name> &lt;= 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Invalid remote port in proxy config: %s\n"</expr></argument>, <argument><expr><name>remoteport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>server</name>.<name>remote_addr</name>.<name>inet</name>.<name>port</name></name> = <call><name>PR_htons</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>servers</name>.<name>push_back</name></name><argument_list>(<argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="line">// Configure all listen sockets and port+certificate bindings</comment>
  <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr>"listen"</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>char</name>*</type> <name>hostname</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>hostportstring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>any_host_spec_config</name> = true</expr>;</expr_stmt>
      <expr_stmt><expr><name>hostportstring</name> = <call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>char</name>*</type> <name>serverportstring</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>certnick</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>serverportstring</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>port</name> &lt;= 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Invalid port specified: %s\n"</expr></argument>, <argument><expr><name>serverportstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<decl><type><name>server_info_t</name>*</type> <name>existingServer</name> <init>= <expr><call><name>findServerInfo</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>certnick_copy</name> <init>= <expr>new <name><name>char</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>certnick</name></expr></argument>)</argument_list></call>+1</expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>hostname_copy</name> <init>= <expr>new <name><name>char</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call>+<call><name>strlen</name><argument_list>(<argument><expr><name>hostportstring</name></expr></argument>)</argument_list></call>+2</expr>]</index></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>hostname_copy</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>hostname_copy</name></expr></argument>, <argument><expr>":"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>hostname_copy</name></expr></argument>, <argument><expr><name>hostportstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>certnick_copy</name></expr></argument>, <argument><expr><name>certnick</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>PLHashEntry</name>*</type> <name>entry</name> <init>= <expr><call><name>PL_HashTableAdd</name><argument_list>(<argument><expr><name><name>existingServer</name>-&gt;<name>host_cert_table</name></name></expr></argument>, <argument><expr><name>hostname_copy</name></expr></argument>, <argument><expr><name>certnick_copy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Out of memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
      }</block></then></if>
    }</block></then>
    <else>else
    <block>{
      <decl_stmt><decl><type><name>server_info_t</name></type> <name>server</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>server</name>.<name>remote_addr</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PRNetAddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>server</name>.<name>cert_nickname</name></name> = <name>certnick</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>server</name>.<name>listen_port</name></name> = <name>port</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>server</name>.<name>http_proxy_only</name></name> = false</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>server</name>.<name>host_cert_table</name></name> = <call><name>PL_NewHashTable</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>PL_HashString</name></expr></argument>, <argument><expr><name>PL_CompareStrings</name></expr></argument>, <argument><expr><name>PL_CompareStrings</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name><name>server</name>.<name>host_cert_table</name></name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Internal, could not create hash table\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>server</name>.<name>host_clientauth_table</name></name> = <call><name>PL_NewHashTable</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>PL_HashString</name></expr></argument>, <argument><expr><name>PL_CompareStrings</name></expr></argument>, <argument><expr><name>ClientAuthValueComparator</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name><name>server</name>.<name>host_clientauth_table</name></name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Internal, could not create hash table\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>servers</name>.<name>push_back</name></name><argument_list>(<argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  
  <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr>"clientauth"</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>char</name>*</type> <name>hostname</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>hostportstring</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>serverportstring</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>serverportstring</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>port</name> &lt;= 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Invalid port specified: %s\n"</expr></argument>, <argument><expr><name>serverportstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<decl><type><name>server_info_t</name>*</type> <name>existingServer</name> <init>= <expr><call><name>findServerInfo</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>char</name>*</type> <name>authoptionstring</name> <init>= <expr><call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>client_auth_option</name>*</type> <name>authoption</name> <init>= <expr>new <name>client_auth_option</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>authoption</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Out of memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
      }</block></then></if>

      <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>authoptionstring</name></expr></argument>, <argument><expr>"require"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>*<name>authoption</name> = <name>caRequire</name></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>authoptionstring</name></expr></argument>, <argument><expr>"request"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>*<name>authoption</name> = <name>caRequest</name></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>authoptionstring</name></expr></argument>, <argument><expr>"none"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr>*<name>authoption</name> = <name>caNone</name></expr>;</expr_stmt></then>
      <else>else
      <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Incorrect client auth option modifier for host '%s'"</expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
      }</block></else></if></else></if></else></if>

      <expr_stmt><expr><name>any_host_spec_config</name> = true</expr>;</expr_stmt>

      <decl_stmt><decl><type><name>char</name> *</type><name>hostname_copy</name> <init>= <expr>new <name><name>char</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call>+<call><name>strlen</name><argument_list>(<argument><expr><name>hostportstring</name></expr></argument>)</argument_list></call>+2</expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>hostname_copy</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Out of memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
      }</block></then></if>

      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>hostname_copy</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>hostname_copy</name></expr></argument>, <argument><expr>":"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>hostname_copy</name></expr></argument>, <argument><expr><name>hostportstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>PLHashEntry</name>*</type> <name>entry</name> <init>= <expr><call><name>PL_HashTableAdd</name><argument_list>(<argument><expr><name><name>existingServer</name>-&gt;<name>host_clientauth_table</name></name></expr></argument>, <argument><expr><name>hostname_copy</name></expr></argument>, <argument><expr><name>authoption</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Out of memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
      }</block></then></if>
    }</block></then>
    <else>else
    <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Server on port %d for client authentication option is not defined, use 'listen' option first"</expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></else></if>

    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="line">// Configure the NSS certificate database directory</comment>
  <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr>"certdbdir"</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>nssconfigdir</name> = <call><name>strtok2</name><argument_list>(<argument><expr><name>_caret</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>&amp;<name>_caret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Error: keyword \"%s\" unexpected\n"</expr></argument>, <argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>parseConfigFile</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>filePath</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>FILE</name>*</type> <name>f</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filePath</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>f</name></expr>)</condition><then>
    <return>return <expr>1</expr>;</return></then></if>

  <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>1024</expr>]</index></name></decl>, *<decl><type ref="prev"/><name>b</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr>!<call><name>feof</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fscanf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
    <block>{
    <case>case <expr>'\n'</expr>:
      <expr_stmt><expr>*<name>b</name>++ = 0</expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>processConfigLine</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>1</expr>;</return></then></if>
      <expr_stmt><expr><name>b</name> = <name>buffer</name></expr>;</expr_stmt>
    </case><case>case <expr>'\r'</expr>:
      <continue>continue;</continue>
    </case><default>default:
      <expr_stmt><expr>*<name>b</name>++ = <name>c</name></expr>;</expr_stmt>
    </default>}</block></switch>
  }</block></while>

  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Check mandatory items</comment>
  <if>if <condition>(<expr><call><name><name>nssconfigdir</name>.<name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Error: missing path to NSS certification database\n,use certdbdir:&lt;path&gt; in the config file\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>any_host_spec_config</name> &amp;&amp; !<name>do_http_proxy</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Warning: any host-specific configurations are ignored, add httpproxy:1 to allow them\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>PRIntn</name></type> <name>freeHostCertHashItems</name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>delete <lambda><capture>[]</capture> <parameter_list>(<param><decl><type><name>char</name>*</type></decl></param>)</parameter_list><name>he</name>-&gt;<type><name>key</name></type></lambda></expr>;</expr_stmt>
  <expr_stmt><expr>delete <lambda><capture>[]</capture> <parameter_list>(<param><decl><type><name>char</name>*</type></decl></param>)</parameter_list><name>he</name>-&gt;<type><name>value</name></type></lambda></expr>;</expr_stmt>
  <return>return <expr><name>HT_ENUMERATE_REMOVE</name></expr>;</return>
}</block></function>

<function><type><name>PRIntn</name></type> <name>freeClientAuthHashItems</name><parameter_list>(<param><decl><type><name>PLHashEntry</name> *</type><name>he</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>delete <lambda><capture>[]</capture> <parameter_list>(<param><decl><type><name>char</name>*</type></decl></param>)</parameter_list><name>he</name>-&gt;<type><name>key</name></type></lambda></expr>;</expr_stmt>
  <expr_stmt><expr>delete (<name>client_auth_option</name>*)<name><name>he</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
  <return>return <expr><name>HT_ENUMERATE_REMOVE</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name>**</type> <name>argv</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>configFilePath</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>argc</name> == 1</expr>)</condition><then>
    <expr_stmt><expr><name>configFilePath</name> = "ssltunnel.cfg"</expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>configFilePath</name> = <name><name>argv</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><call><name>parseConfigFile</name><argument_list>(<argument><expr><name>configFilePath</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Error: config file \"%s\" missing or formating incorrect\n"
      "Specify path to the config file as parameter to ssltunnel or \n"
      "create ssltunnel.cfg in the working directory.\n\n"
      "Example format of the config file:\n\n"
      "       # Enable http/ssl tunneling proxy-like behavior.\n"
      "       # If not specified ssltunnel simply does direct forward.\n"
      "       httpproxy:1\n\n"
      "       # Specify path to the certification database used.\n"
      "       certdbdir:/path/to/certdb\n\n"
      "       # Forward/proxy all requests in raw to 127.0.0.1:8888.\n"
      "       forward:127.0.0.1:8888\n\n"
      "       # Accept connections on port 4443 or 5678 resp. and authenticate\n"
      "       # to any host ('*') using the 'server cert' or 'server cert 2' resp.\n"
      "       listen:*:4443:server cert\n"
      "       listen:*:5678:server cert 2\n\n"
      "       # Accept connections on port 4443 and authenticate using\n"
      "       # 'a different cert' when target host is 'my.host.name:443'.\n"
      "       # This only works in httpproxy mode and has higher priority\n"
      "       # than the previous option.\n"
      "       listen:my.host.name:443:4443:a different cert\n\n"
      "       # To make a specific host require or just request a client certificate\n"
      "       # to authenticate use the following options. This can only be used\n"
      "       # in httpproxy mode and only after the 'listen' option has been\n"
      "       # specified. You also have to specify the tunnel listen port.\n"
      "       clientauth:requesting-client-cert.host.com:443:4443:request\n"
      "       clientauth:requiring-client-cert.host.com:443:4443:require\n"
      "       # Act as a simple proxy for incoming connections on port 7777,\n"
      "       # tunneling them to the server at 127.0.0.1:9999. Not affected\n"
      "       # by the 'forward' option.\n"
      "       proxy:7777:127.0.0.1:9999\n"</expr></argument>,
      <argument><expr><name>configFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>

  <comment type="line">// create a thread pool to handle connections</comment>
  <expr_stmt><expr><name>threads</name> = <call><name>PR_CreateThreadPool</name><argument_list>(<argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>INITIAL_THREADS</name></expr></argument>, <argument><expr><call><name><name>servers</name>.<name>size</name></name><argument_list>()</argument_list></call>*2</expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>PR_MAX</name><argument_list>(<argument><expr><name>MAX_THREADS</name></expr></argument>, <argument><expr><call><name><name>servers</name>.<name>size</name></name><argument_list>()</argument_list></call>*2</expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>DEFAULT_STACKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>threads</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Failed to create thread pool\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>shutdown_lock</name> = <call><name>PR_NewLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>shutdown_lock</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Failed to create lock\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_ShutdownThreadPool</name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>shutdown_condvar</name> = <call><name>PR_NewCondVar</name><argument_list>(<argument><expr><name>shutdown_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>shutdown_condvar</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Failed to create condvar\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_ShutdownThreadPool</name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_DestroyLock</name><argument_list>(<argument><expr><name>shutdown_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>PK11_SetPasswordFunc</name><argument_list>(<argument><expr><name>password_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Initialize NSS</comment>
  <if>if <condition>(<expr><call><name>NSS_Init</name><argument_list>(<argument><expr><call><name><name>nssconfigdir</name>.<name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> != <name>SECSuccess</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>errorlen</name> <init>= <expr><call><name>PR_GetErrorTextLength</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>err</name> <init>= <expr>new <name><name>char</name><index>[<expr><name>errorlen</name>+1</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PR_GetErrorText</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Failed to init NSS: %s"</expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>delete<index>[]</index> <name>err</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_ShutdownThreadPool</name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_DestroyCondVar</name><argument_list>(<argument><expr><name>shutdown_condvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_DestroyLock</name><argument_list>(<argument><expr><name>shutdown_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><call><name>NSS_SetDomesticPolicy</name><argument_list>()</argument_list></call> != <name>SECSuccess</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"NSS_SetDomesticPolicy failed\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_ShutdownThreadPool</name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_DestroyCondVar</name><argument_list>(<argument><expr><name>shutdown_condvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_DestroyLock</name><argument_list>(<argument><expr><name>shutdown_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NSS_Shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>

  <comment type="line">// these values should make NSS use the defaults</comment>
  <if>if <condition>(<expr><call><name>SSL_ConfigServerSessionIDCache</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != <name>SECSuccess</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"SSL_ConfigServerSessionIDCache failed\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_ShutdownThreadPool</name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_DestroyCondVar</name><argument_list>(<argument><expr><name>shutdown_condvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_DestroyLock</name><argument_list>(<argument><expr><name>shutdown_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NSS_Shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>

  <for>for (<init><decl><type><name><name><name>vector</name><argument_list>&lt;<argument><expr><name>server_info_t</name></expr></argument>&gt;</argument_list></name>::<name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>servers</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
       <condition><expr><name>it</name> != <call><name><name>servers</name>.<name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>it</name>++</expr></incr>) <block>{
    <comment type="line">// Not actually using this PRJob*...</comment>
    <comment type="line">// PRJob* server_job =</comment>
    <expr_stmt><expr><call><name>PR_QueueJob</name><argument_list>(<argument><expr><name>threads</name></expr></argument>, <argument><expr><name>StartServer</name></expr></argument>, <argument><expr>&amp;(*<name>it</name>)</expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <comment type="line">// now wait for someone to tell us to quit</comment>
  <expr_stmt><expr><call><name>PR_Lock</name><argument_list>(<argument><expr><name>shutdown_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_WaitCondVar</name><argument_list>(<argument><expr><name>shutdown_condvar</name></expr></argument>, <argument><expr><name>PR_INTERVAL_NO_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_Unlock</name><argument_list>(<argument><expr><name>shutdown_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>shutdown_server</name> = true</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Shutting down...\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">// cleanup</comment>
  <expr_stmt><expr><call><name>PR_ShutdownThreadPool</name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_JoinThreadPool</name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_DestroyCondVar</name><argument_list>(<argument><expr><name>shutdown_condvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_DestroyLock</name><argument_list>(<argument><expr><name>shutdown_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NSS_Shutdown</name><argument_list>()</argument_list></call> == <name>SECFailure</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Leaked NSS objects!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  
  <for>for (<init><decl><type><name><name><name>vector</name><argument_list>&lt;<argument><expr><name>server_info_t</name></expr></argument>&gt;</argument_list></name>::<name>iterator</name></name></type> <name>it</name> <init>= <expr><call><name><name>servers</name>.<name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init>
       <condition><expr><name>it</name> != <call><name><name>servers</name>.<name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>it</name>++</expr></incr>) 
  <block>{
    <expr_stmt><expr><call><name>PL_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>host_cert_table</name></name></expr></argument>, <argument><expr><name>freeHostCertHashItems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PL_HashTableEnumerateEntries</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>host_clientauth_table</name></name></expr></argument>, <argument><expr><name>freeClientAuthHashItems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PL_HashTableDestroy</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>host_cert_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PL_HashTableDestroy</name><argument_list>(<argument><expr><name><name>it</name>-&gt;<name>host_clientauth_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <expr_stmt><expr><call><name>PR_Cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>
</unit>
