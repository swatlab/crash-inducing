<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="00317f8837b8cf93982c89b73d6979a7a2eda788.h"><comment type="block">/* -*- Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 4 -*- */</comment>
<comment type="block">/* vi: set ts=4 sw=4 expandtab: (add to ~/.vimrc: set modeline modelines=5) */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is [Open Source Virtual Machine].
 *
 * The Initial Developer of the Original Code is
 * Adobe System Incorporated.
 * Portions created by the Initial Developer are Copyright (C) 2004-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Adobe AS3 Team
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__nanojit_LIR__</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__nanojit_LIR__</name></cpp:macro></cpp:define>

<comment type="block">/**
 * Fundamentally, the arguments to the various operands can be grouped along
 * two dimensions.  One dimension is size: can the arguments fit into a 32-bit
 * register, or not?  The other dimension is whether the argument is an integer
 * (including pointers) or a floating-point value.  In all comments below,
 * "integer" means integer of any size, including 64-bit, unless otherwise
 * specified.  All floating-point values are always 64-bit.  Below, "quad" is
 * used for a 64-bit value that might be either integer or floating-point.
 */</comment>
<decl_stmt><decl><type><name>namespace</name></type> <name>nanojit</name>
<block>{
    <decl_stmt><decl><type><name>using</name> <name>namespace</name></type> <name>MMgc</name></decl>;</decl_stmt>

    <enum>enum <name>LOpcode</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> &amp;&amp; <name>_MSC_VER</name> &gt;= 1400</expr></cpp:if>
          : <type><name>unsigned</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
        <comment type="line">// flags; upper bits reserved</comment>
        <decl><name>LIR64</name>    <init>= <expr>0x40</expr></init></decl>,            <comment type="line">// result is double or quad</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPDEF</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>number</name></type></param>, <param><type><name>args</name></type></param>, <param><type><name>repkind</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>LIR_##op = (number),</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPDEF64</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>number</name></type></param>, <param><type><name>args</name></type></param>, <param><type><name>repkind</name></type></param>)</parameter_list></cpp:macro> \
        <cpp:value>LIR_##op = ((number) | LIR64),</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"LIRopcode.tbl"</cpp:file></cpp:include>
        <decl><name>LIR_sentinel</name></decl>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPDEF</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPDEF64</name></cpp:undef>
    }</block>;</enum>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NANOJIT_64BIT</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PTR_SIZE</name><parameter_list>(<param><type><name>a</name></type></param>,<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>b</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PTR_SIZE</name><parameter_list>(<param><type><name>a</name></type></param>,<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>a</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_64BIT</name></expr></cpp:if>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_ldp</name></cpp:macro>     <cpp:value>LIR_ldq</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_piadd</name></cpp:macro>   <cpp:value>LIR_qiadd</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_piand</name></cpp:macro>   <cpp:value>LIR_qiand</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_pilsh</name></cpp:macro>   <cpp:value>LIR_qilsh</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_pcmov</name></cpp:macro>    <cpp:value>LIR_qcmov</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_pior</name></cpp:macro>    <cpp:value>LIR_qior</cpp:value></cpp:define>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_ldp</name></cpp:macro>     <cpp:value>LIR_ld</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_piadd</name></cpp:macro>   <cpp:value>LIR_add</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_piand</name></cpp:macro>   <cpp:value>LIR_and</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_pilsh</name></cpp:macro>   <cpp:value>LIR_lsh</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_pcmov</name></cpp:macro>    <cpp:value>LIR_cmov</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIR_pior</name></cpp:macro>    <cpp:value>LIR_or</cpp:value></cpp:define>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <struct_decl>struct <name>GuardRecord</name>;</struct_decl>
    <struct_decl>struct <name>SideExit</name>;</struct_decl>
    <struct_decl>struct <name>Page</name>;</struct_decl>

    <enum>enum <name>AbiKind</name> <block>{
        <decl><name>ABI_FASTCALL</name></decl>,
        <decl><name>ABI_THISCALL</name></decl>,
        <decl><name>ABI_STDCALL</name></decl>,
        <decl><name>ABI_CDECL</name></decl>
    }</block>;</enum>

    <enum>enum <name>ArgSize</name> <block>{
        <decl><name>ARGSIZE_NONE</name> <init>= <expr>0</expr></init></decl>,
        <decl><name>ARGSIZE_F</name> <init>= <expr>1</expr></init></decl>,      <comment type="line">// double (64bit)</comment>
        <decl><name>ARGSIZE_I</name> <init>= <expr>2</expr></init></decl>,      <comment type="line">// int32_t</comment>
        <decl><name>ARGSIZE_Q</name> <init>= <expr>3</expr></init></decl>,      <comment type="line">// uint64_t</comment>
        <decl><name>ARGSIZE_U</name> <init>= <expr>6</expr></init></decl>,      <comment type="line">// uint32_t</comment>
        <decl><name>ARGSIZE_MASK_ANY</name> <init>= <expr>7</expr></init></decl>,
        <decl><name>ARGSIZE_MASK_INT</name> <init>= <expr>2</expr></init></decl>,
        <decl><name>ARGSIZE_SHIFT</name> <init>= <expr>3</expr></init></decl>,

        <comment type="line">// aliases</comment>
        <decl><name>ARGSIZE_P</name> <init>= <expr><call><name>PTR_SIZE</name><argument_list>(<argument><expr><name>ARGSIZE_I</name></expr></argument>, <argument><expr><name>ARGSIZE_Q</name></expr></argument>)</argument_list></call></expr></init></decl>, <comment type="line">// pointer</comment>
        <decl><name>ARGSIZE_LO</name> <init>= <expr><name>ARGSIZE_I</name></expr></init></decl>, <comment type="line">// int32_t</comment>
        <decl><name>ARGSIZE_B</name> <init>= <expr><name>ARGSIZE_I</name></expr></init></decl>, <comment type="line">// bool</comment>
        <decl><name>ARGSIZE_V</name> <init>= <expr><name>ARGSIZE_NONE</name></expr></init></decl>  <comment type="line">// void</comment>
    }</block>;</enum>

    <struct>struct <name>CallInfo</name>
    <block>{
        <decl_stmt><decl><type><name>uintptr_t</name></type>   <name>_address</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>uint32_t</name>    <name>_argtypes</name>:27</expr>;</expr_stmt>    <comment type="line">// 9 3-bit fields indicating arg type, by ARGSIZE above (including ret type): a1 a2 a3 a4 a5 ret</comment>
        <expr_stmt><expr><name>uint8_t</name>     <name>_cse</name>:1</expr>;</expr_stmt>          <comment type="line">// true if no side effects</comment>
        <expr_stmt><expr><name>uint8_t</name>     <name>_fold</name>:1</expr>;</expr_stmt>         <comment type="line">// true if no side effects</comment>
        <expr_stmt><expr><name>AbiKind</name>     <name>_abi</name>:3</expr>;</expr_stmt>
        <macro><name>verbose_only</name> <argument_list>( <argument>const char* _name;</argument> )</argument_list></macro>

        <decl_stmt><decl><type><name>uint32_t</name> <name>FASTCALL</name></type> <name>_count_args</name><argument_list>(<argument><expr><name>uint32_t</name> <name>mask</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>get_sizes</name><argument_list>(<argument><expr><name>ArgSize</name>*</expr></argument>)</argument_list> const</decl>;</decl_stmt>

        <expr_stmt><expr>inline <name>uint32_t</name> <name>FASTCALL</name> <macro><name>count_args</name><argument_list>()</argument_list></macro> const <block>{
            <return>return <expr><call><name>_count_args</name><argument_list>(<argument><expr><name>ARGSIZE_MASK_ANY</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></expr></expr_stmt>
        <expr_stmt><expr>inline <name>uint32_t</name> <name>FASTCALL</name> <macro><name>count_iargs</name><argument_list>()</argument_list></macro> const <block>{
            <return>return <expr><call><name>_count_args</name><argument_list>(<argument><expr><name>ARGSIZE_MASK_INT</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></expr></expr_stmt>
        <comment type="line">// fargs = args - iargs</comment>
    }</block>;</struct>

    <comment type="block">/*
     * Record for extra data used to compile switches as jump tables.
     */</comment>
    <struct>struct <name>SwitchInfo</name>
    <block>{
        <decl_stmt><decl><type><name>NIns</name>**</type>      <name>table</name></decl>;</decl_stmt>       <comment type="line">// Jump table; a jump address is NIns*</comment>
        <decl_stmt><decl><type><name>uint32_t</name></type>    <name>count</name></decl>;</decl_stmt>       <comment type="line">// Number of table entries</comment>
        <comment type="line">// Index value at last execution of the switch. The index value</comment>
        <comment type="line">// is the offset into the jump table. Thus it is computed as</comment>
        <comment type="line">// (switch expression) - (lowest case value).</comment>
        <decl_stmt><decl><type><name>uint32_t</name></type>    <name>index</name></decl>;</decl_stmt>
    }</block>;</struct>

    <function><type><specifier>inline</specifier> <name>bool</name></type> <name>isCseOpcode</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><name>op</name> = <call><name>LOpcode</name><argument_list>(<argument><expr><name>op</name> &amp; ~<name>LIR64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>op</name> &gt;= <name>LIR_int</name> &amp;&amp; <name>op</name> &lt;= <name>LIR_uge</name></expr>;</return>
    }</block></function>
    <function><type><specifier>inline</specifier> <name>bool</name></type> <name>isRetOpcode</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
        <return>return <expr>(<name>op</name> &amp; ~<name>LIR64</name>) == <name>LIR_ret</name></expr>;</return>
    }</block></function>

    <comment type="line">// The opcode is not logically part of the Reservation, but we include it</comment>
    <comment type="line">// in this struct to ensure that opcode plus the Reservation fits in a</comment>
    <comment type="line">// single word.  Yuk.</comment>
    <struct>struct <name>Reservation</name>
    <block>{
        <expr_stmt><expr><name>uint32_t</name> <name>arIndex</name>:16</expr>;</expr_stmt>    <comment type="line">// index into stack frame.  displ is -4*arIndex</comment>
        <expr_stmt><expr><name>Register</name> <name>reg</name>:7</expr>;</expr_stmt>         <comment type="line">// register UnknownReg implies not in register</comment>
        <expr_stmt><expr><name>uint32_t</name> <name>used</name>:1</expr>;</expr_stmt>        <comment type="line">// when set, the reservation is active</comment>
        <expr_stmt><expr><name>LOpcode</name>  <name>opcode</name>:8</expr>;</expr_stmt>

        <function><type><specifier>inline</specifier> <name>void</name></type> <name>init</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><name>reg</name> = <name>UnknownReg</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>arIndex</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>used</name> = 1</expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>inline</specifier> <name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{
            <expr_stmt><expr><name>used</name> = 0</expr>;</expr_stmt>
        }</block></function>
    }</block>;</struct>

    <comment type="line">//-----------------------------------------------------------------------</comment>
    <comment type="line">// Low-level instructions.  This is a bit complicated, because we have a</comment>
    <comment type="line">// variable-width representation to minimise space usage.</comment>
    <comment type="line">//</comment>
    <comment type="line">// - Instruction size is always an integral multiple of word size.</comment>
    <comment type="line">//</comment>
    <comment type="line">// - Every instruction has at least one word, holding the opcode and the</comment>
    <comment type="line">//   reservation info.  That word is in class LIns.</comment>
    <comment type="line">//</comment>
    <comment type="line">// - Beyond that, most instructions have 1, 2 or 3 extra words.  These</comment>
    <comment type="line">//   extra words are in classes LInsOp1, LInsOp2, etc (collectively called</comment>
    <comment type="line">//   "LInsXYZ" in what follows).  Each LInsXYZ class also contains a word,</comment>
    <comment type="line">//   accessible by the 'ins' member, which holds the LIns data;  its type</comment>
    <comment type="line">//   is void* (which is the same size as LIns) rather than LIns to avoid a</comment>
    <comment type="line">//   recursive dependency between LIns and LInsXYZ.</comment>
    <comment type="line">//</comment>
    <comment type="line">// - LIR is written forward, but read backwards.  When reading backwards,</comment>
    <comment type="line">//   in order to find the opcode, it must be in a predictable place in the</comment>
    <comment type="line">//   LInsXYZ isn't affected by instruction width.  Therefore, the LIns</comment>
    <comment type="line">//   word (which contains the opcode) is always the *last* word in an</comment>
    <comment type="line">//   instruction.</comment>
    <comment type="line">//</comment>
    <comment type="line">// - Each instruction is created by casting pre-allocated bytes from a</comment>
    <comment type="line">//   LirBuffer to the LInsXYZ type.  Therefore there are no constructors</comment>
    <comment type="line">//   for LIns or LInsXYZ.</comment>
    <comment type="line">//</comment>
    <comment type="line">// - The standard handle for an instruction is a LIns*.  This actually</comment>
    <comment type="line">//   points to the LIns word, ie. to the final word in the instruction.</comment>
    <comment type="line">//   This is a bit odd, but it allows the instruction's opcode to be</comment>
    <comment type="line">//   easily accessed.  Once you've looked at the opcode and know what kind</comment>
    <comment type="line">//   of instruction it is, if you want to access any of the other words,</comment>
    <comment type="line">//   you need to use toLInsXYZ(), which takes the LIns* and gives you an</comment>
    <comment type="line">//   LInsXYZ*, ie. the pointer to the actual start of the instruction's</comment>
    <comment type="line">//   bytes.  From there you can access the instruction-specific extra</comment>
    <comment type="line">//   words.</comment>
    <comment type="line">//</comment>
    <comment type="line">// - However, from outside class LIns, LInsXYZ isn't visible, nor is</comment>
    <comment type="line">//   toLInsXYZ() -- from outside LIns, all LIR instructions are handled</comment>
    <comment type="line">//   via LIns pointers and get/set methods are used for all LIns/LInsXYZ</comment>
    <comment type="line">//   accesses.  In fact, all data members in LInsXYZ are private and can</comment>
    <comment type="line">//   only be accessed by LIns, which is a friend class.  The only thing</comment>
    <comment type="line">//   anyone outside LIns can do with a LInsXYZ is call getLIns().</comment>
    <comment type="line">//</comment>
    <comment type="line">// - An example Op2 instruction and the likely pointers to it (each line</comment>
    <comment type="line">//   represents a word, and pointers to a line point to the start of the</comment>
    <comment type="line">//   word on that line):</comment>
    <comment type="line">//</comment>
    <comment type="line">//      [ oprnd_2         &lt;-- LInsOp2* insOp2 == toLInsOp2(ins)</comment>
    <comment type="line">//        oprnd_1</comment>
    <comment type="line">//        opcode + resv ] &lt;-- LIns* ins</comment>
    <comment type="line">//</comment>
    <comment type="line">// - LIR_skip instructions are more complicated.  They allow an arbitrary</comment>
    <comment type="line">//   blob of data (the "payload") to be placed in the LIR stream.  The</comment>
    <comment type="line">//   size of the payload is always a multiple of the word size.  A skip</comment>
    <comment type="line">//   instruction's operand points to the previous instruction, which lets</comment>
    <comment type="line">//   the payload be skipped over when reading backwards.  Here's an</comment>
    <comment type="line">//   example of a skip instruction with a 3-word payload preceded by an</comment>
    <comment type="line">//   LInsOp1:</comment>
    <comment type="line">//</comment>
    <comment type="line">//      [ oprnd_1</comment>
    <comment type="line">//  +-&gt;   opcode + resv           ]</comment>
    <comment type="line">//  |   [ data</comment>
    <comment type="line">//  |     data</comment>
    <comment type="line">//  |     data</comment>
    <comment type="line">//  +---- prevLIns                  &lt;-- LInsSk* insSk == toLInsSk(ins)</comment>
    <comment type="line">//        opcode==LIR_skip + resv ] &lt;-- LIns* ins</comment>
    <comment type="line">//</comment>
    <comment type="line">//   Skips are also used to link code pages.  If the first instruction on</comment>
    <comment type="line">//   a page isn't a LIR_start, it will be a skip, and the skip's operand</comment>
    <comment type="line">//   will point to the last LIns on the previous page.  In this case there</comment>
    <comment type="line">//   isn't a payload as such;  in fact, the previous page might be at a</comment>
    <comment type="line">//   higher address, ie. the operand might point forward rather than</comment>
    <comment type="line">//   backward.</comment>
    <comment type="line">//</comment>
    <comment type="line">//   LInsSk has the same layout as LInsOp1, but we represent it as a</comment>
    <comment type="line">//   different class because there are some places where we treat</comment>
    <comment type="line">//   skips specially and so having it separate seems like a good idea.</comment>
    <comment type="line">//</comment>
    <comment type="line">// - Call instructions (LIR_call, LIR_fcall, LIR_calli, LIR_fcalli) are</comment>
    <comment type="line">//   also more complicated.  They are preceded by the arguments to the</comment>
    <comment type="line">//   call, which are laid out in reverse order.  For example, a call with</comment>
    <comment type="line">//   3 args will look like this:</comment>
    <comment type="line">//</comment>
    <comment type="line">//      [ arg #2</comment>
    <comment type="line">//        arg #1</comment>
    <comment type="line">//        arg #0</comment>
    <comment type="line">//        argc            &lt;-- LInsC insC == toLInsC(ins)</comment>
    <comment type="line">//        ci</comment>
    <comment type="line">//        opcode + resv ] &lt;-- LIns* ins</comment>
    <comment type="line">//</comment>
    <comment type="line">// - Various things about the size and layout of LIns and LInsXYZ are</comment>
    <comment type="line">//   statically checked in staticSanityCheck().  In particular, this is</comment>
    <comment type="line">//   worthwhile because there's nothing that guarantees that all the</comment>
    <comment type="line">//   LInsXYZ classes have a size that is a multiple of word size (but in</comment>
    <comment type="line">//   practice all sane compilers use a layout that results in this).  We</comment>
    <comment type="line">//   also check that every LInsXYZ is word-aligned in</comment>
    <comment type="line">//   LirBuffer::makeRoom();  this seems sensible to avoid potential</comment>
    <comment type="line">//   slowdowns due to misalignment.  It relies on pages themselves being</comment>
    <comment type="line">//   word-aligned, which is extremely likely.</comment>
    <comment type="line">//</comment>
    <comment type="line">// - There is an enum, LInsRepKind, with one member for each of the</comment>
    <comment type="line">//   LInsXYZ kinds.  Each opcode is categorised with its LInsRepKind value</comment>
    <comment type="line">//   in LIRopcode.tbl, and this is used in various places.</comment>
    <comment type="line">//-----------------------------------------------------------------------</comment>

    <enum>enum <name>LInsRepKind</name> <block>{
        <comment type="line">// LRK_XYZ corresponds to class LInsXYZ.</comment>
        <decl><name>LRK_Op0</name></decl>,
        <decl><name>LRK_Op1</name></decl>,
        <decl><name>LRK_Op2</name></decl>,
        <decl><name>LRK_Op3</name></decl>,
        <decl><name>LRK_Ld</name></decl>,
        <decl><name>LRK_Sti</name></decl>,
        <decl><name>LRK_Sk</name></decl>,
        <decl><name>LRK_C</name></decl>,
        <decl><name>LRK_P</name></decl>,
        <decl><name>LRK_I</name></decl>,
        <decl><name>LRK_I64</name></decl>,
        <decl><name>LRK_None</name></decl>    <comment type="line">// this one is used for unused opcode numbers</comment>
    }</block>;</enum>

    <comment type="line">// 0-operand form.  Used for LIR_start and LIR_label.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsOp0</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// 1-operand form.  Used for LIR_ret, LIR_ov, unary arithmetic/logic ops,</comment>
    <comment type="line">// etc.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsOp1</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type>       <name>oprnd_1</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// 2-operand form.  Used for loads, guards, branches, comparisons, binary</comment>
    <comment type="line">// arithmetic/logic ops, etc.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsOp2</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type>       <name>oprnd_2</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type>       <name>oprnd_1</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// 3-operand form.  Used for conditional moves.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsOp3</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type>       <name>oprnd_3</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type>       <name>oprnd_2</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type>       <name>oprnd_1</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// Used for all loads.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsLd</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int32_t</name></type>     <name>disp</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type>       <name>oprnd_1</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// Used for LIR_sti and LIR_stqi.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsSti</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int32_t</name></type>     <name>disp</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type>       <name>oprnd_2</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type>       <name>oprnd_1</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// Used for LIR_skip.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsSk</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type>       <name>prevLIns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// Used for all variants of LIR_call.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsC</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>uintptr_t</name>   <name>argc</name>:8</expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>CallInfo</name>*</type> <name>ci</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// Used for LIR_iparam.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsP</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>uintptr_t</name>   <name>arg</name>:8</expr>;</expr_stmt>
        <expr_stmt><expr><name>uintptr_t</name>   <name>kind</name>:8</expr>;</expr_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// Used for LIR_int and LIR_ialloc.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsI</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int32_t</name></type>     <name>imm32</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// Used for LIR_quad.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsI64</name>
    <block>{
    <label><name>private</name>:</label>
        <decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LIns</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int32_t</name></type>     <name>imm64_0</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int32_t</name></type>     <name>imm64_1</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>void</name>*</type>       <name>ins</name></decl>;</decl_stmt>

    <label><name>public</name>:</label>
        <function><type><name>LIns</name>*</type> <name>getLIns</name><parameter_list>()</parameter_list> <block>{ <return>return <expr>(<name>LIns</name>*)&amp;<name>ins</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// Used only as a placeholder for OPDEF macros for unused opcodes in</comment>
    <comment type="line">// LIRopcode.tbl.</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsNone</name>
    <block>{
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <decl_stmt><decl><type><name>class</name></type> <name>LIns</name>
    <block>{
    <label><name>private</name>:</label>
        <comment type="line">// Last word: fields shared by all LIns kinds.  The reservation fields</comment>
        <comment type="line">// are read/written during assembly.</comment>
        <decl_stmt><decl><type><name>Reservation</name></type> <name>lastWord</name></decl>;</decl_stmt>

        <comment type="line">// LIns-to-LInsXYZ converters.</comment>
        <expr_stmt><expr><name>LInsOp0</name>* <macro><name>toLInsOp0</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call>(<name>LInsOp0</name>*)<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsOp0</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LInsOp1</name>* <macro><name>toLInsOp1</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call>(<name>LInsOp1</name>*)<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsOp1</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LInsOp2</name>* <macro><name>toLInsOp2</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call>(<name>LInsOp2</name>*)<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsOp2</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LInsOp3</name>* <macro><name>toLInsOp3</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call>(<name>LInsOp3</name>*)<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsOp3</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LInsLd</name>*  <macro><name>toLInsLd</name><argument_list>()</argument_list></macro>  const <block>{ <return>return <expr><call>(<name>LInsLd</name>* )<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsLd</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LInsSti</name>* <macro><name>toLInsSti</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call>(<name>LInsSti</name>*)<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsSti</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LInsSk</name>*  <macro><name>toLInsSk</name><argument_list>()</argument_list></macro>  const <block>{ <return>return <expr><call>(<name>LInsSk</name>* )<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsSk</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LInsC</name>*   <macro><name>toLInsC</name><argument_list>()</argument_list></macro>   const <block>{ <return>return <expr><call>(<name>LInsC</name>*  )<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsC</name></expr></argument>  )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LInsP</name>*   <macro><name>toLInsP</name><argument_list>()</argument_list></macro>   const <block>{ <return>return <expr><call>(<name>LInsP</name>*  )<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsP</name></expr></argument>  )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LInsI</name>*   <macro><name>toLInsI</name><argument_list>()</argument_list></macro>   const <block>{ <return>return <expr><call>(<name>LInsI</name>*  )<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsI</name></expr></argument>  )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LInsI64</name>* <macro><name>toLInsI64</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call>(<name>LInsI64</name>*)<argument_list>( <argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>this</name>+1</expr></argument>)</argument_list></call> - <sizeof>sizeof<argument_list>(<argument><expr><name>LInsI64</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

        <comment type="line">// This is never called, but that's ok because it contains only static</comment>
        <comment type="line">// assertions.</comment>
        <function><type><name>void</name></type> <name>staticSanityCheck</name><parameter_list>()</parameter_list>
        <block>{
            <comment type="line">// LIns must be word-sized.</comment>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LIns</name></expr></argument>)</argument_list></sizeof> == 1*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// LInsXYZ have expected sizes too.</comment>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsOp0</name></expr></argument>)</argument_list></sizeof> == 1*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsOp1</name></expr></argument>)</argument_list></sizeof> == 2*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsOp2</name></expr></argument>)</argument_list></sizeof> == 3*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsOp3</name></expr></argument>)</argument_list></sizeof> == 4*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsLd</name></expr></argument>)</argument_list></sizeof>  == 3*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsSti</name></expr></argument>)</argument_list></sizeof> == 4*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsSk</name></expr></argument>)</argument_list></sizeof>  == 2*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsC</name></expr></argument>)</argument_list></sizeof>   == 3*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsP</name></expr></argument>)</argument_list></sizeof>   == 2*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsI</name></expr></argument>)</argument_list></sizeof>   == 2*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NANOJIT_64BIT</name></expr></cpp:if>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsI64</name></expr></argument>)</argument_list></sizeof> == 2*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LInsI64</name></expr></argument>)</argument_list></sizeof> == 3*<sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">// oprnd_1 must be in the same position in LIns{Op1,Op2,Op3,Ld,Sti}</comment>
            <comment type="line">// because oprnd1() is used for all of them.</comment>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>( <argument><expr>(<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp1</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp1</name></expr></argument>, <argument><expr><name>oprnd_1</name></expr></argument>)</argument_list></call>) ==
                              (<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp2</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp2</name></expr></argument>, <argument><expr><name>oprnd_1</name></expr></argument>)</argument_list></call>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>( <argument><expr>(<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp2</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp2</name></expr></argument>, <argument><expr><name>oprnd_1</name></expr></argument>)</argument_list></call>) ==
                              (<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp3</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp3</name></expr></argument>, <argument><expr><name>oprnd_1</name></expr></argument>)</argument_list></call>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>( <argument><expr>(<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp3</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp3</name></expr></argument>, <argument><expr><name>oprnd_1</name></expr></argument>)</argument_list></call>) ==
                              (<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsLd</name></expr></argument>,  <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsLd</name></expr></argument>,  <argument><expr><name>oprnd_1</name></expr></argument>)</argument_list></call>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>( <argument><expr>(<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsLd</name></expr></argument>,  <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsLd</name></expr></argument>,  <argument><expr><name>oprnd_1</name></expr></argument>)</argument_list></call>) ==
                              (<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsSti</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsSti</name></expr></argument>, <argument><expr><name>oprnd_1</name></expr></argument>)</argument_list></call>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// oprnd_2 must be in the same position in LIns{Op2,Op3,Sti}</comment>
            <comment type="line">// because oprnd2() is used for both of them.</comment>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>( <argument><expr>(<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp2</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp2</name></expr></argument>, <argument><expr><name>oprnd_2</name></expr></argument>)</argument_list></call>) ==
                              (<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp3</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp3</name></expr></argument>, <argument><expr><name>oprnd_2</name></expr></argument>)</argument_list></call>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoStaticAssert</name><argument_list>( <argument><expr>(<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp3</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsOp3</name></expr></argument>, <argument><expr><name>oprnd_2</name></expr></argument>)</argument_list></call>) ==
                              (<call><name>offsetof</name><argument_list>(<argument><expr><name>LInsSti</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call> - <call><name>offsetof</name><argument_list>(<argument><expr><name>LInsSti</name></expr></argument>, <argument><expr><name>oprnd_2</name></expr></argument>)</argument_list></call>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        }</block></function>

    <label><name>public</name>:</label>
        <function><type><name>void</name></type> <name>initLInsOp0</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>opcode</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsOp0</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
        <function><type><name>void</name></type> <name>initLInsOp1</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>oprnd1</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsOp1</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_1</name> = <name>oprnd1</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsOp1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
        <function><type><name>void</name></type> <name>initLInsOp2</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>oprnd1</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>oprnd2</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsOp2</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_1</name> = <name>oprnd1</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsOp2</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_2</name> = <name>oprnd2</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsOp2</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
        <function><type><name>void</name></type> <name>initLInsOp3</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>oprnd1</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>oprnd2</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>oprnd3</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsOp3</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_1</name> = <name>oprnd1</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsOp3</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_2</name> = <name>oprnd2</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsOp3</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_3</name> = <name>oprnd3</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsOp3</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
        <function><type><name>void</name></type> <name>initLInsLd</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>val</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>d</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsLd</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_1</name> = <name>val</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsLd</name><argument_list>()</argument_list></call>-&gt;<name>disp</name> = <name>d</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsLd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
        <function><type><name>void</name></type> <name>initLInsSti</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>val</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>base</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>d</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsSti</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_1</name> = <name>val</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsSti</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_2</name> = <name>base</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsSti</name><argument_list>()</argument_list></call>-&gt;<name>disp</name> = <name>d</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsSti</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
        <function><type><name>void</name></type> <name>initLInsSk</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>prevLIns</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>LIR_skip</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsSk</name><argument_list>()</argument_list></call>-&gt;<name>prevLIns</name> = <name>prevLIns</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsSk</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
        <comment type="line">// Nb: this does NOT initialise the arguments.  That must be done</comment>
        <comment type="line">// separately.</comment>
        <function><type><name>void</name></type> <name>initLInsC</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>argc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>CallInfo</name>*</type> <name>ci</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isU8</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsC</name><argument_list>()</argument_list></call>-&gt;<name>argc</name> = <name>argc</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsC</name><argument_list>()</argument_list></call>-&gt;<name>ci</name> = <name>ci</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsC</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
        <function><type><name>void</name></type> <name>initLInsP</name><parameter_list>(<param><decl><type><name>int32_t</name></type> <name>arg</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>kind</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>LIR_iparam</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isU8</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>isU8</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsP</name><argument_list>()</argument_list></call>-&gt;<name>arg</name> = <name>arg</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsP</name><argument_list>()</argument_list></call>-&gt;<name>kind</name> = <name>kind</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
        <function><type><name>void</name></type> <name>initLInsI</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>imm32</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsI</name><argument_list>()</argument_list></call>-&gt;<name>imm32</name> = <name>imm32</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsI</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
        <function><type><name>void</name></type> <name>initLInsI64</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>int64_t</name></type> <name>imm64</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name><name>lastWord</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lastWord</name>.<name>opcode</name></name> = <name>opcode</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsI64</name><argument_list>()</argument_list></call>-&gt;<name>imm64_0</name> = <call><name>int32_t</name><argument_list>(<argument><expr><name>imm64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>toLInsI64</name><argument_list>()</argument_list></call>-&gt;<name>imm64_1</name> = <call><name>int32_t</name><argument_list>(<argument><expr><name>imm64</name> &gt;&gt; 32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsI64</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <expr_stmt><expr><name>LIns</name>* <macro><name>oprnd1</name><argument_list>()</argument_list></macro> const <block>{
            <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsOp1</name><argument_list>()</argument_list></call> || <call><name>isLInsOp2</name><argument_list>()</argument_list></call> || <call><name>isLInsOp3</name><argument_list>()</argument_list></call> || <call><name>isLInsLd</name><argument_list>()</argument_list></call> || <call><name>isLInsSti</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
            <return>return <expr><call><name>toLInsOp2</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_1</name></expr>;</return>
        }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LIns</name>* <macro><name>oprnd2</name><argument_list>()</argument_list></macro> const <block>{
            <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsOp2</name><argument_list>()</argument_list></call> || <call><name>isLInsOp3</name><argument_list>()</argument_list></call> || <call><name>isLInsSti</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
            <return>return <expr><call><name>toLInsOp2</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_2</name></expr>;</return>
        }</block></expr></expr_stmt>
        <expr_stmt><expr><name>LIns</name>* <macro><name>oprnd3</name><argument_list>()</argument_list></macro> const <block>{
            <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsOp3</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
            <return>return <expr><call><name>toLInsOp3</name><argument_list>()</argument_list></call>-&gt;<name>oprnd_3</name></expr>;</return>
        }</block></expr></expr_stmt>

        <expr_stmt><expr><name>LIns</name>* <macro><name>prevLIns</name><argument_list>()</argument_list></macro> const <block>{
            <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsSk</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
            <return>return <expr><call><name>toLInsSk</name><argument_list>()</argument_list></call>-&gt;<name>prevLIns</name></expr>;</return>
        }</block></expr></expr_stmt>

        <expr_stmt><expr>inline <name>LOpcode</name> <macro><name>opcode</name><argument_list>()</argument_list></macro>    const <block>{ <return>return <expr><name><name>lastWord</name>.<name>opcode</name></name></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr>inline <name>uint8_t</name> <macro><name>paramArg</name><argument_list>()</argument_list></macro>  const <block>{ <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isop</name><argument_list>(<argument><expr><name>LIR_iparam</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>; <return>return <expr><call><name>toLInsP</name><argument_list>()</argument_list></call>-&gt;<name>arg</name></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr>inline <name>uint8_t</name> <macro><name>paramKind</name><argument_list>()</argument_list></macro> const <block>{ <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isop</name><argument_list>(<argument><expr><name>LIR_iparam</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>; <return>return <expr><call><name>toLInsP</name><argument_list>()</argument_list></call>-&gt;<name>kind</name></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr>inline <name>int32_t</name> <macro><name>imm32</name><argument_list>()</argument_list></macro>     const <block>{ <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isconst</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;  <return>return <expr><call><name>toLInsI</name><argument_list>()</argument_list></call>-&gt;<name>imm32</name></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr>inline <name>int32_t</name> <macro><name>imm64_0</name><argument_list>()</argument_list></macro>   const <block>{ <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isconstq</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>; <return>return <expr><call><name>toLInsI64</name><argument_list>()</argument_list></call>-&gt;<name>imm64_0</name></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr>inline <name>int32_t</name> <macro><name>imm64_1</name><argument_list>()</argument_list></macro>   const <block>{ <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isconstq</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>; <return>return <expr><call><name>toLInsI64</name><argument_list>()</argument_list></call>-&gt;<name>imm64_1</name></expr>;</return> }</block></expr></expr_stmt>
        <expr_stmt><expr><name>uint64_t</name>       <macro><name>imm64</name><argument_list>()</argument_list></macro>     const</expr>;</expr_stmt>
        <expr_stmt><expr><name>double</name>         <macro><name>imm64f</name><argument_list>()</argument_list></macro>    const</expr>;</expr_stmt>
        <function><type><name>Reservation</name>*</type>   <name>resv</name><parameter_list>()</parameter_list>            <block>{ <return>return <expr>&amp;<name>lastWord</name></expr>;</return> }</block></function>
        <expr_stmt><expr><name>void</name>*          <macro><name>payload</name><argument_list>()</argument_list></macro>   const</expr>;</expr_stmt>
        <function><type><specifier>inline</specifier> <name>Page</name>*</type>   <name>page</name><parameter_list>()</parameter_list>            <block>{ <return>return <expr>(<name>Page</name>*) <call><name>alignTo</name><argument_list>(<argument><expr><name>this</name></expr></argument>,<argument><expr><name>NJ_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
        <expr_stmt><expr>inline <name>int32_t</name> <macro><name>size</name><argument_list>()</argument_list></macro>      const <block>{
            <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isop</name><argument_list>(<argument><expr><name>LIR_ialloc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
            <return>return <expr><call><name>toLInsI</name><argument_list>()</argument_list></call>-&gt;<name>imm32</name> &lt;&lt; 2</expr>;</return>
        }</block></expr></expr_stmt>

        <function_decl><type><name>LIns</name>*</type> <name>arg</name><parameter_list>(<param><decl><type><name>uint32_t</name></type> <name>i</name></decl></param>)</parameter_list>;</function_decl>

        <expr_stmt><expr>inline <name>int32_t</name> <macro><name>disp</name><argument_list>()</argument_list></macro> const
        <block>{
            <if>if <condition>(<expr><call><name>isLInsSti</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><call><name>toLInsSti</name><argument_list>()</argument_list></call>-&gt;<name>disp</name></expr>;</return>
            <expr_stmt/>}</block> <else>else <block>{
                <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isLInsLd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>toLInsLd</name><argument_list>()</argument_list></call>-&gt;<name>disp</name></expr>;</return>
            <expr_stmt/>}</block>
        <expr_stmt/></else></then></if>}</block>

        inline <name>void</name>* <macro><name>constvalp</name><argument_list>()</argument_list></macro> const
        <block>{
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AVMPLUS_64BIT</name></cpp:ifdef>
            <return>return <expr>(<name>void</name>*)<call><name>imm64</name><argument_list>()</argument_list></call></expr>;</return></block></expr></expr_stmt>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <return>return <expr>(<name>void</name>*)<call><name>imm32</name><argument_list>()</argument_list></call></expr>;</return>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></decl></decl_stmt>

        <expr_stmt><expr><name>bool</name> <macro><name>isCse</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isRet</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><name>nanojit</name>::<call><name>isRetOpcode</name><argument_list>(<argument><expr><call><name>opcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>isop</name><argument_list>(<argument><expr><name>LOpcode</name> <name>o</name></expr></argument>)</argument_list> const <block>{ <return>return <expr><call><name>opcode</name><argument_list>()</argument_list></call> == <name>o</name></expr>;</return> }</block></decl></decl_stmt>
        <comment type="line">// isLInsXYZ() returns true if the instruction has the LInsXYZ form.</comment>
        <comment type="line">// Note that there is some overlap with other predicates, eg.</comment>
        <comment type="line">// isStore()==isLInsSti(), isCall()==isLInsC(), but that's ok;  these</comment>
        <comment type="line">// ones are used only to check that opcodes are appropriate for</comment>
        <comment type="line">// instruction layouts, the others are used for non-debugging</comment>
        <comment type="line">// purposes.</comment>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsOp0</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsOp1</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsOp2</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsOp3</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsSti</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsLd</name><argument_list>()</argument_list></macro>  const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsSk</name><argument_list>()</argument_list></macro>  const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsC</name><argument_list>()</argument_list></macro>   const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsP</name><argument_list>()</argument_list></macro>   const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsI</name><argument_list>()</argument_list></macro>   const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLInsI64</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isQuad</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isCond</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isFloat</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isCmp</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isCall</name><argument_list>()</argument_list></macro> const <block>{
            <expr><name>LOpcode</name> <name>op</name> = <call><name>LOpcode</name><argument_list>(<argument><expr><call><name>opcode</name><argument_list>()</argument_list></call> &amp; ~<name>LIR64</name></expr></argument>)</argument_list></call></expr>;
            <return>return <expr><name>op</name> == <name>LIR_call</name></expr>;</return>
        }</block></expr></expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isStore</name><argument_list>()</argument_list></macro> const <block>{
            <expr><name>LOpcode</name> <name>op</name> = <call><name>LOpcode</name><argument_list>(<argument><expr><call><name>opcode</name><argument_list>()</argument_list></call> &amp; ~<name>LIR64</name></expr></argument>)</argument_list></call></expr>;
            <return>return <expr><name>op</name> == <name>LIR_sti</name></expr>;</return>
        }</block></expr></expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isLoad</name><argument_list>()</argument_list></macro> const <block>{
            <expr><name>LOpcode</name> <name>op</name> = <call><name>opcode</name><argument_list>()</argument_list></call></expr>;
            <return>return <expr><name>op</name> == <name>LIR_ldq</name>  || <name>op</name> == <name>LIR_ld</name> || <name>op</name> == <name>LIR_ldc</name> ||
                   <name>op</name> == <name>LIR_ldqc</name> || <name>op</name> == <name>LIR_ldcs</name> || <name>op</name> == <name>LIR_ldcb</name></expr>;</return>
        }</block></expr></expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isGuard</name><argument_list>()</argument_list></macro> const <block>{
            <expr><name>LOpcode</name> <name>op</name> = <call><name>opcode</name><argument_list>()</argument_list></call></expr>;
            <return>return <expr><name>op</name> == <name>LIR_x</name> || <name>op</name> == <name>LIR_xf</name> || <name>op</name> == <name>LIR_xt</name> ||
                   <name>op</name> == <name>LIR_loop</name> || <name>op</name> == <name>LIR_xbarrier</name> || <name>op</name> == <name>LIR_xtbl</name></expr>;</return>
        }</block></expr></expr_stmt>
        <comment type="line">// True if the instruction is a 32-bit or smaller constant integer.</comment>
        <expr_stmt><expr><name>bool</name> <macro><name>isconst</name><argument_list>()</argument_list></macro> const <block>{ <return>return <expr><call><name>opcode</name><argument_list>()</argument_list></call> == <name>LIR_int</name></expr>;</return> }</block></expr></expr_stmt>
        <comment type="line">// True if the instruction is a 32-bit or smaller constant integer and</comment>
        <comment type="line">// has the value val when treated as a 32-bit signed integer.</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>isconstval</name><argument_list>(<argument><expr><name>int32_t</name> <name>val</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
        <comment type="line">// True if the instruction is a constant quad value.</comment>
        <expr_stmt><expr><name>bool</name> <macro><name>isconstq</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <comment type="line">// True if the instruction is a constant pointer value.</comment>
        <expr_stmt><expr><name>bool</name> <macro><name>isconstp</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
        <expr_stmt><expr><name>bool</name> <macro><name>isBranch</name><argument_list>()</argument_list></macro> const <block>{
            <return>return <expr><call><name>isop</name><argument_list>(<argument><expr><name>LIR_jt</name></expr></argument>)</argument_list></call> || <call><name>isop</name><argument_list>(<argument><expr><name>LIR_jf</name></expr></argument>)</argument_list></call> || <call><name>isop</name><argument_list>(<argument><expr><name>LIR_j</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></expr></expr_stmt>

        <comment type="line">// Return true if removal of 'ins' from a LIR fragment could</comment>
        <comment type="line">// possibly change the behaviour of that fragment, even if any</comment>
        <comment type="line">// value computed by 'ins' is not used later in the fragment.</comment>
        <comment type="line">// In other words, can 'ins' possible alter control flow or memory?</comment>
        <comment type="line">// Note, this assumes that loads will never fault and hence cannot</comment>
        <comment type="line">// affect the control flow.</comment>
        <function><type><name>bool</name></type> <name>isStmt</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name>isGuard</name><argument_list>()</argument_list></call> || <call><name>isBranch</name><argument_list>()</argument_list></call> ||
                   (<call><name>isCall</name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>isCse</name><argument_list>()</argument_list></call>) ||
                   <call><name>isStore</name><argument_list>()</argument_list></call> ||
                   <call><name>isop</name><argument_list>(<argument><expr><name>LIR_loop</name></expr></argument>)</argument_list></call> || <call><name>isop</name><argument_list>(<argument><expr><name>LIR_label</name></expr></argument>)</argument_list></call> || <call><name>isop</name><argument_list>(<argument><expr><name>LIR_live</name></expr></argument>)</argument_list></call> ||
                   <call><name>isRet</name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>

        <function_decl><type><name>void</name></type> <name>setTarget</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>t</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LIns</name>*</type> <name>getTarget</name><parameter_list>()</parameter_list>;</function_decl>

        <function_decl><type><name>GuardRecord</name> *</type><name>record</name><parameter_list>()</parameter_list>;</function_decl>

        <expr_stmt><expr>inline <name>uint32_t</name> <macro><name>argc</name><argument_list>()</argument_list></macro> const <block>{
            <expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>isCall</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
            <return>return <expr><call><name>toLInsC</name><argument_list>()</argument_list></call>-&gt;<name>argc</name></expr>;</return>
        }</block></expr></expr_stmt>
        <expr_stmt><expr>const <name>CallInfo</name> *<macro><name>callInfo</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <typedef>typedef <type><name>LIns</name>*</type> <name>LInsp</name>;</typedef>

    <function_decl><type><name>LIns</name>* <name>FASTCALL</name></type> <name>callArgN</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>i</name></decl></param>, <param><decl><type><name>uint32_t</name></type> <name>n</name></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>operandCount</name><index>[]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>class</name></type> <name>Fragmento</name></decl>;</decl_stmt>    <comment type="line">// @todo remove this ; needed for minbuild for some reason?!?  Should not be compiling this code at all</comment>

    <comment type="line">// make it a GCObject so we can explicitly delete it early</comment>
    <expr_stmt><expr><name>class</name> <name>LirWriter</name> : <name>public</name> <name>GCObject</name>
    <block>{
    <expr><name>public</name>:
        <name>LirWriter</name> *<name>out</name></expr>;

        <expr><name>virtual</name> ~<macro><name>LirWriter</name><argument_list>()</argument_list></macro> <block>{}</block>
        <call><name>LirWriter</name><argument_list>(<argument><expr><name>LirWriter</name>* <name>out</name></expr></argument>)</argument_list></call>
            : <macro><name>out</name><argument_list>(<argument>out</argument>)</argument_list></macro> <block>{}</block>

        <name>virtual</name> <name>LInsp</name> <macro><name>ins0</name><argument_list>(<argument>LOpcode v</argument>)</argument_list></macro> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
        }</block>
        <name>virtual</name> <name>LInsp</name> <macro><name>ins1</name><argument_list>(<argument>LOpcode v</argument>, <argument>LIns* a</argument>)</argument_list></macro> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></expr></expr_stmt>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>ins2</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>a</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>b</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>ins3</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>a</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>b</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>c</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>ins3</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>insGuard</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>c</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>x</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>insBranch</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>condition</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>to</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>condition</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <comment type="line">// arg: 0=first, 1=second, ...</comment>
        <comment type="line">// kind: 0=arg 1=saved-reg</comment>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>insParam</name><parameter_list>(<param><decl><type><name>int32_t</name></type> <name>arg</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>kind</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>insParam</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>insImm</name><parameter_list>(<param><decl><type><name>int32_t</name></type> <name>imm</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>insImmq</name><parameter_list>(<param><decl><type><name>uint64_t</name></type> <name>imm</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>insImmq</name></name><argument_list>(<argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>insLoad</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>base</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>d</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>insStorei</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>value</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>base</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>d</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>insCall</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CallInfo</name> *</type><name>call</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name><name>args</name><index>[]</index></name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr><name>call</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>insAlloc</name><parameter_list>(<param><decl><type><name>int32_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>size</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>out</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>insSkip</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name><name>out</name>-&gt;<name>insSkip</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="line">// convenience functions</comment>

        <comment type="line">// Inserts a conditional to execute and branches to execute if</comment>
        <comment type="line">// the condition is true and false respectively.</comment>
        <function_decl><type><name>LIns</name>*</type>        <name>ins_choose</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>cond</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>iftrue</name></decl></param>, <param><decl><type><name>LIns</name>*</type> <name>iffalse</name></decl></param>)</parameter_list>;</function_decl>
        <comment type="line">// Inserts an integer comparison to 0</comment>
        <function_decl><type><name>LIns</name>*</type>        <name>ins_eq0</name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>oprnd1</name></decl></param>)</parameter_list>;</function_decl>
        <comment type="line">// Inserts a binary operation where the second operand is an</comment>
        <comment type="line">// integer immediate.</comment>
        <function_decl><type><name>LIns</name>*</type>       <name>ins2i</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>oprnd1</name></decl></param>, <param><decl><type><name>int32_t</name></type></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LIns</name>*</type>        <name>qjoin</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>lo</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>hi</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LIns</name>*</type>        <name>insImmPtr</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LIns</name>*</type>        <name>insImmf</name><parameter_list>(<param><decl><type><name>double</name></type> <name>f</name></decl></param>)</parameter_list>;</function_decl>
    };


    <comment type="line">// Each page has a header;  the rest of it holds code.</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NJ_PAGE_CODE_AREA_SZB</name></cpp:macro>       <cpp:value>(NJ_PAGE_SIZE - sizeof(PageHeader))</cpp:value></cpp:define>

    <comment type="line">// The first instruction on a page is always a start instruction, or a</comment>
    <comment type="line">// payload-less skip instruction linking to the previous page.  The</comment>
    <comment type="line">// biggest possible instruction would take up the entire rest of the page.</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NJ_MAX_LINS_SZB</name></cpp:macro>             <cpp:value>(NJ_PAGE_CODE_AREA_SZB - sizeof(LInsSk))</cpp:value></cpp:define>

    <comment type="line">// The maximum skip payload size is determined by the maximum instruction</comment>
    <comment type="line">// size.  We require that a skip's payload be adjacent to the skip LIns</comment>
    <comment type="line">// itself.</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NJ_MAX_SKIP_PAYLOAD_SZB</name></cpp:macro>     <cpp:value>(NJ_MAX_LINS_SZB - sizeof(LInsSk))</cpp:value></cpp:define>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NJ_VERBOSE</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name>*</type> <name><name>lirNames</name><index>[]</index></name></decl>;</decl_stmt>

    <comment type="block">/**
     * map address ranges to meaningful names.
     */</comment>
    <decl_stmt><decl><type><name>class</name> <name>LabelMap</name></type> <name>MMGC_SUBCLASS_DECL</name>
    <block>{
        <decl_stmt><decl><type><name>class</name> <name>Entry</name></type> <name>MMGC_SUBCLASS_DECL</name>
        <block>{
        <label><name>public</name>:</label>
            <expr_stmt><expr><call><name>Entry</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call> : <call><name>name</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <expr><call><name>size</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <macro><name>align</name><argument_list>(<argument>0</argument>)</argument_list></macro> <expr><block>{}</block>
            <macro><name>Entry</name><argument_list>(<argument>avmplus::String *n</argument>, <argument>size_t s</argument>, <argument>size_t a</argument>)</argument_list></macro> : <call><name>name</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>,<expr><call><name>size</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>,<macro><name>align</name><argument_list>(<argument>a</argument>)</argument_list></macro> <expr><block>{}</block>
            ~<call><name>Entry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <macro><name>DRCWB</name><argument_list>(<argument>avmplus::String*</argument>)</argument_list></macro> <expr_stmt><expr><name>name</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>size_t</name> <name>size</name>:29</expr>, <expr><name>align</name>:3</expr>;</expr_stmt>
        }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
        <expr_stmt><expr><name>avmplus</name>::<name>SortedMap</name>&lt;const <name>void</name>*</expr>, <expr><name>Entry</name>*</expr>, <expr><name>avmplus</name>::<name>LIST_GCObjects</name>&gt; <name>names</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>addrs</name></decl>, <decl><type ref="prev"/><name><name>pad</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>1000</expr>]</index></name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
        <function_decl><type><name>void</name></type> <name>formatAddr</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list>;</function_decl>
    <label><name>public</name>:</label>
        <expr_stmt><expr><name>avmplus</name>::<name>AvmCore</name> *<name>core</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LabelMap</name><argument_list>(<argument><expr><name>avmplus</name>::<name>AvmCore</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>~<call><name>LabelMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <function_decl><type><name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>align</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>
        <decl_stmt><decl><type><name>void</name></type> <name>add</name><argument_list>(<argument><expr>const <name>void</name> *<name>p</name></expr></argument>, <argument><expr><name>size_t</name> <name>size</name></expr></argument>, <argument><expr><name>size_t</name> <name>align</name></expr></argument>, <argument><expr><name>avmplus</name>::<name>String</name>*</expr></argument>)</argument_list></decl>;</decl_stmt>
        <function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>dup</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list>;</function_decl>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <decl_stmt><decl><type><name>class</name> <name>LirNameMap</name></type> <name>MMGC_SUBCLASS_DECL</name>
    <block>{
        <expr_stmt><expr><name>template</name> &lt;<name>class</name> <name>Key</name>&gt;
        <name>class</name> <name>CountMap</name>: <name>public</name> <name>avmplus</name>::<name>SortedMap</name>&lt;<name>Key</name></expr>, <expr><name>int</name></expr>, <expr><name>avmplus</name>::<name>LIST_NonGCObjects</name>&gt; <block>{
        <expr><name>public</name>:
            <call><name>CountMap</name><argument_list>(<argument><expr><name>GC</name>*<name>gc</name></expr></argument>)</argument_list></call> : <name>avmplus</name>::<name>SortedMap</name>&lt;<name>Key</name></expr>, <expr><name>int</name></expr>, <expr><name>avmplus</name>::<name>LIST_NonGCObjects</name>&gt;(<name>gc</name>) <block>{}</block>
            <name>int</name> <macro><name>add</name><argument_list>(<argument>Key k</argument>)</argument_list></macro> <block>{
                <expr><name>int</name> <name>c</name> = 1</expr>;
                <if>if <condition>(<expr><call><name>containsKey</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>c</name> = 1+<call><name>get</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt/>}</block>
                <expr_stmt><expr><call><name>put</name><argument_list>(<argument><expr><name>k</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></block></expr>
                <return>return <expr><name>c</name></expr>;</return>
            }</block></expr></expr_stmt>
        }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
        <expr_stmt><expr><name>CountMap</name>&lt;<name>int</name>&gt; <name>lircounts</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>CountMap</name>&lt;const <name>CallInfo</name> *&gt; <name>funccounts</name></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>class</name> <name>Entry</name></type> <name>MMGC_SUBCLASS_DECL</name>
        <block>{
        <label><name>public</name>:</label>
            <expr_stmt><expr><call><name>Entry</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call> : <macro><name>name</name><argument_list>(<argument>0</argument>)</argument_list></macro> <block>{}</block>
            <call><name>Entry</name><argument_list>(<argument><expr><name>avmplus</name>::<name>String</name> *<name>n</name></expr></argument>)</argument_list></call> : <macro><name>name</name><argument_list>(<argument>n</argument>)</argument_list></macro> <block>{}</block>
            ~<call><name>Entry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <macro><name>DRCWB</name><argument_list>(<argument>avmplus::String*</argument>)</argument_list></macro> <expr_stmt><expr><name>name</name></expr>;</expr_stmt>
        }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
        <expr_stmt><expr><name>avmplus</name>::<name>SortedMap</name>&lt;<name>LInsp</name></expr>, <expr><name>Entry</name>*</expr>, <expr><name>avmplus</name>::<name>LIST_GCObjects</name>&gt; <name>names</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LabelMap</name> *</type><name>labels</name></decl>;</decl_stmt>
        <function_decl><type><name>void</name></type> <name>formatImm</name><parameter_list>(<param><decl><type><name>int32_t</name></type> <name>c</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list>;</function_decl>
    <label><name>public</name>:</label>

        <expr_stmt><expr><call><name>LirNameMap</name><argument_list>(<argument><expr><name>GC</name> *<name>gc</name></expr></argument>, <argument><expr><name>LabelMap</name> *<name>r</name></expr></argument>)</argument_list></call>
            : <call><name>lircounts</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>,
            <expr><call><name>funccounts</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>,
            <expr><call><name>names</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>,
            <macro><name>labels</name><argument_list>(<argument>r</argument>)</argument_list></macro>
        <expr><block>{}</block>
        ~<call><name>LirNameMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <function_decl><type><name>void</name></type> <name>addName</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>i</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
        <decl_stmt><decl><type><name>bool</name></type> <name>addName</name><argument_list>(<argument><expr><name>LInsp</name> <name>i</name></expr></argument>, <argument><expr><name>avmplus</name>::<name>String</name> *<name>s</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <function_decl><type><name>void</name></type> <name>copyName</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>i</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>suffix</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>formatRef</name><parameter_list>(<param><decl><type><name>LIns</name> *</type><name>ref</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>formatIns</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>i</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>void</name></type> <name>formatGuard</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>i</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list>;</function_decl>
    };


    <expr_stmt><expr><name>class</name> <name>VerboseWriter</name> : <name>public</name> <name>LirWriter</name>
    <block>{
        <expr><name>InsList</name> <name>code</name></expr>;
        <macro><name>DWB</name><argument_list>(<argument>LirNameMap*</argument>)</argument_list></macro> <expr><name>names</name></expr>;
        <expr><name>LogControl</name>* <name>logc</name></expr>;
    <expr><name>public</name>:
        <call><name>VerboseWriter</name><argument_list>(<argument><expr><name>GC</name> *<name>gc</name></expr></argument>, <argument><expr><name>LirWriter</name> *<name>out</name></expr></argument>,
                      <argument><expr><name>LirNameMap</name>* <name>names</name></expr></argument>, <argument><expr><name>LogControl</name>* <name>logc</name></expr></argument>)</argument_list></call>
            : <call><name>LirWriter</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>code</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>names</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>, <macro><name>logc</name><argument_list>(<argument>logc</argument>)</argument_list></macro>
        <expr><block>{}</block>

        <name>LInsp</name> <macro><name>add</name><argument_list>(<argument>LInsp i</argument>)</argument_list></macro> <block>{
            <if>if <condition>(<expr><name>i</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>code</name>.<name>add</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></block></expr>
            <return>return <expr><name>i</name></expr>;</return>
        }</block></expr></expr_stmt>

        <function><type><name>LInsp</name></type> <name>add_flush</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>i</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr>(<name>i</name> = <call><name>add</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
                <expr_stmt><expr><call><name>flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
            <return>return <expr><name>i</name></expr>;</return>
        }</block></function>

        <function><type><name>void</name></type> <name>flush</name><parameter_list>()</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name><name>code</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>n</name></expr>)</condition><then> <block>{
                <for>for (<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                    <expr_stmt><expr><call><name><name>logc</name>-&gt;<name>printf</name></name><argument_list>(<argument><expr>"    %s\n"</expr></argument>,<argument><expr><call><name><name>names</name>-&gt;<name>formatIns</name></name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
                <expr_stmt><expr><call><name><name>code</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>n</name> &gt; 1</expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logc</name>-&gt;<name>printf</name></name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></function>

        <function><type><name>LIns</name>*</type> <name>insGuard</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>cond</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>x</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add_flush</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>insGuard</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>,<argument><expr><name>cond</name></expr></argument>,<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><name>LIns</name>*</type> <name>insBranch</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>condition</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>to</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add_flush</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>insBranch</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>condition</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><name>LIns</name>*</type> <name>ins0</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>)</parameter_list> <block>{
            <if>if <condition>(<expr><name>v</name> == <name>LIR_label</name> || <name>v</name> == <name>LIR_start</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>ins0</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><name>LIns</name>*</type> <name>ins1</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>a</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>isRetOpcode</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> ? <call><name>add_flush</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> : <call><name>add</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>ins1</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>LIns</name>*</type> <name>ins2</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>a</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>b</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>ins2</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>LIns</name>*</type> <name>ins3</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>a</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>b</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>ins3</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>LIns</name>*</type> <name>insCall</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CallInfo</name> *</type><name>call</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name><name>args</name><index>[]</index></name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add_flush</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>insCall</name></name><argument_list>(<argument><expr><name>call</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>LIns</name>*</type> <name>insParam</name><parameter_list>(<param><decl><type><name>int32_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>kind</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>insParam</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>LIns</name>*</type> <name>insLoad</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>base</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>disp</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>insLoad</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>LIns</name>*</type> <name>insStorei</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>b</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>d</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>insStorei</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>LIns</name>*</type> <name>insAlloc</name><parameter_list>(<param><decl><type><name>int32_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>insAlloc</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>LIns</name>*</type> <name>insImm</name><parameter_list>(<param><decl><type><name>int32_t</name></type> <name>imm</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>insImm</name></name><argument_list>(<argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
        <function><type><name>LIns</name>*</type> <name>insImmq</name><parameter_list>(<param><decl><type><name>uint64_t</name></type> <name>imm</name></decl></param>)</parameter_list> <block>{
            <return>return <expr><call><name>add</name><argument_list>(<argument><expr><call><name><name>out</name>-&gt;<name>insImmq</name></name><argument_list>(<argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    };

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>class</name> <name>ExprFilter</name>: <name>public</name> <name>LirWriter</name>
    <block>{
    <expr><name>public</name>:
        <call><name>ExprFilter</name><argument_list>(<argument><expr><name>LirWriter</name> *<name>out</name></expr></argument>)</argument_list></call> : <macro><name>LirWriter</name><argument_list>(<argument>out</argument>)</argument_list></macro> <block>{}</block>
        <name>LIns</name>* <macro><name>ins1</name><argument_list>(<argument>LOpcode v</argument>, <argument>LIns* a</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <macro><name>ins2</name><argument_list>(<argument>LOpcode v</argument>, <argument>LIns* a</argument>, <argument>LIns* b</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <macro><name>ins3</name><argument_list>(<argument>LOpcode v</argument>, <argument>LIns* a</argument>, <argument>LIns* b</argument>, <argument>LIns* c</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <call><name>insGuard</name><argument_list>(<argument><expr><name>LOpcode</name></expr></argument>, <argument><expr><name>LIns</name> *<name>cond</name></expr></argument>, <argument><expr><name>LIns</name> *</expr></argument>)</argument_list></call></expr>;
        <expr><name>LIns</name>* <call><name>insBranch</name><argument_list>(<argument><expr><name>LOpcode</name></expr></argument>, <argument><expr><name>LIns</name> *<name>cond</name></expr></argument>, <argument><expr><name>LIns</name> *<name>target</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr>;</expr_stmt>

    <comment type="line">// @todo, this could be replaced by a generic HashMap or HashSet, if we had one</comment>
    <decl_stmt><decl><type><name>class</name></type> <name>LInsHashSet</name>
    <block>{
        <comment type="line">// must be a power of 2.</comment>
        <comment type="line">// don't start too small, or we'll waste time growing and rehashing.</comment>
        <comment type="line">// don't start too large, will waste memory.</comment>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>kInitialCap</name> <init>= <expr>64</expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LInsp</name> *</type><name>m_list</name></decl>;</decl_stmt> <comment type="line">// explicit WB's are used, no DWB needed.</comment>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>m_used</name></decl>, <decl><type ref="prev"/><name>m_cap</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GC</name>*</type> <name>m_gc</name></decl>;</decl_stmt>

        <function_decl><type><specifier>static</specifier> <name>uint32_t</name> <name>FASTCALL</name></type> <name>hashcode</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>i</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>uint32_t</name> <name>FASTCALL</name></type> <name>find</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>name</name></decl></param>, <param><decl><type><name>uint32_t</name></type> <name>hash</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>LInsp</name> *</type><name>list</name></decl></param>, <param><decl><type><name>uint32_t</name></type> <name>cap</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>static</specifier> <name>bool</name> <name>FASTCALL</name></type> <name>equals</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>a</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>b</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>void</name> <name>FASTCALL</name></type> <name>grow</name><parameter_list>()</parameter_list>;</function_decl>

    <label><name>public</name>:</label>
        <expr_stmt><expr><call><name>LInsHashSet</name><argument_list>(<argument><expr><name>GC</name>* <name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>~<call><name>LInsHashSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <function_decl><type><name>LInsp</name></type> <name>find32</name><parameter_list>(<param><decl><type><name>int32_t</name></type> <name>a</name></decl></param>, <param><decl><type><name>uint32_t</name> &amp;</type><name>i</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LInsp</name></type> <name>find64</name><parameter_list>(<param><decl><type><name>uint64_t</name></type> <name>a</name></decl></param>, <param><decl><type><name>uint32_t</name> &amp;</type><name>i</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LInsp</name></type> <name>find1</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>a</name></decl></param>, <param><decl><type><name>uint32_t</name> &amp;</type><name>i</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LInsp</name></type> <name>find2</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>a</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>b</name></decl></param>, <param><decl><type><name>uint32_t</name> &amp;</type><name>i</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LInsp</name></type> <name>find3</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>a</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>b</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>c</name></decl></param>, <param><decl><type><name>uint32_t</name> &amp;</type><name>i</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LInsp</name></type> <name>findLoad</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>a</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>b</name></decl></param>, <param><decl><type><name>uint32_t</name> &amp;</type><name>i</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LInsp</name></type> <name>findcall</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CallInfo</name> *</type><name>call</name></decl></param>, <param><decl><type><name>uint32_t</name></type> <name>argc</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name><name>args</name><index>[]</index></name></decl></param>, <param><decl><type><name>uint32_t</name> &amp;</type><name>i</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>LInsp</name></type> <name>add</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>i</name></decl></param>, <param><decl><type><name>uint32_t</name></type> <name>k</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>void</name></type> <name>replace</name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>i</name></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list>;</function_decl>

        <function_decl><type><specifier>static</specifier> <name>uint32_t</name> <name>FASTCALL</name></type> <name>hashimm</name><parameter_list>(<param><decl><type><name>int32_t</name></type></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>static</specifier> <name>uint32_t</name> <name>FASTCALL</name></type> <name>hashimmq</name><parameter_list>(<param><decl><type><name>uint64_t</name></type></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>static</specifier> <name>uint32_t</name> <name>FASTCALL</name></type> <name>hash1</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>static</specifier> <name>uint32_t</name> <name>FASTCALL</name></type> <name>hash2</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type></decl></param>, <param><decl><type><name>LInsp</name></type></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>static</specifier> <name>uint32_t</name> <name>FASTCALL</name></type> <name>hash3</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type></decl></param>, <param><decl><type><name>LInsp</name></type></decl></param>, <param><decl><type><name>LInsp</name></type></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>static</specifier> <name>uint32_t</name> <name>FASTCALL</name></type> <name>hashLoad</name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>v</name></decl></param>, <param><decl><type><name>LInsp</name></type></decl></param>, <param><decl><type><name>int32_t</name></type></decl></param>)</parameter_list>;</function_decl>
        <function_decl><type><specifier>static</specifier> <name>uint32_t</name> <name>FASTCALL</name></type> <name>hashcall</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>CallInfo</name> *</type><name>call</name></decl></param>, <param><decl><type><name>uint32_t</name></type> <name>argc</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name><name>args</name><index>[]</index></name></decl></param>)</parameter_list>;</function_decl>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>class</name> <name>CseFilter</name>: <name>public</name> <name>LirWriter</name>
    <block>{
    <expr><name>public</name>:
        <name>LInsHashSet</name> <name>exprs</name></expr>;
        <expr><call><name>CseFilter</name><argument_list>(<argument><expr><name>LirWriter</name> *<name>out</name></expr></argument>, <argument><expr><name>GC</name> *<name>gc</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>LIns</name>* <macro><name>insImm</name><argument_list>(<argument>int32_t imm</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <macro><name>insImmq</name><argument_list>(<argument>uint64_t q</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <macro><name>ins0</name><argument_list>(<argument>LOpcode v</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <macro><name>ins1</name><argument_list>(<argument>LOpcode v</argument>, <argument>LInsp</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <macro><name>ins2</name><argument_list>(<argument>LOpcode v</argument>, <argument>LInsp</argument>, <argument>LInsp</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <macro><name>ins3</name><argument_list>(<argument>LOpcode v</argument>, <argument>LInsp</argument>, <argument>LInsp</argument>, <argument>LInsp</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <macro><name>insLoad</name><argument_list>(<argument>LOpcode op</argument>, <argument>LInsp cond</argument>, <argument>int32_t d</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <macro><name>insCall</name><argument_list>(<argument>const CallInfo *call</argument>, <argument>LInsp args[]</argument>)</argument_list></macro></expr>;
        <expr><name>LIns</name>* <macro><name>insGuard</name><argument_list>(<argument>LOpcode op</argument>, <argument>LInsp cond</argument>, <argument>LIns *x</argument>)</argument_list></macro></expr>;
    }</block></expr>;</expr_stmt>

    <expr_stmt><expr><name>class</name> <name>LirBuffer</name> : <name>public</name> <name>GCFinalizedObject</name>
    <block>{
        <expr><name>public</name>:
            <macro><name>DWB</name><argument_list>(<argument>Fragmento*</argument>)</argument_list></macro>        <name>_frago</name></expr>;
            <expr><call><name>LirBuffer</name><argument_list>(<argument><expr><name>Fragmento</name>* <name>frago</name></expr></argument>)</argument_list></call></expr>;
            <expr><name>virtual</name> ~<call><name>LirBuffer</name><argument_list>()</argument_list></call></expr>;
            <expr><name>void</name>        <call><name>clear</name><argument_list>()</argument_list></call></expr>;
            <expr><name>void</name>        <call><name>rewind</name><argument_list>()</argument_list></call></expr>;
            <expr><name>uintptr_t</name>   <macro><name>makeRoom</name><argument_list>(<argument>size_t szB</argument>)</argument_list></macro></expr>;   <comment type="line">// make room for an instruction</comment>
            <expr><name>bool</name>        <macro><name>outOMem</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>_noMem</name> != 0</expr>;</return></block></expr> }</block>

            <macro><name>debug_only</name> <argument_list>(<argument>void validate() const;</argument>)</argument_list></macro>
            <macro><name>verbose_only</name><argument_list>(<argument>DWB(LirNameMap*) names;</argument>)</argument_list></macro>

            <name>int32_t</name> <call><name>insCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <function_decl><type><name>size_t</name></type>  <name>byteCount</name><parameter_list>()</parameter_list>;</function_decl>

            <comment type="line">// stats</comment>
            <struct>struct
            <block>{
                <decl_stmt><decl><type><name>uint32_t</name></type> <name>lir</name></decl>;</decl_stmt>    <comment type="line">// # instructions</comment>
            }</block>
            <decl><name>_stats</name></decl>;</struct>

            <decl_stmt><decl><type><name>AbiKind</name></type> <name>abi</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LInsp</name></type> <name>state</name></decl>,<decl><type ref="prev"/><name>param1</name></decl>,<decl><type ref="prev"/><name>sp</name></decl>,<decl><type ref="prev"/><name>rp</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>LInsp</name></type> <name><name>savedRegs</name><index>[<expr><name>NumSavedRegs</name></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>explicitSavedRegs</name></decl>;</decl_stmt>

        <label><name>protected</name>:</label>
            <function_decl><type><name>Page</name>*</type>        <name>pageAlloc</name><parameter_list>()</parameter_list>;</function_decl>
            <function_decl><type><name>void</name></type>        <name>moveToNewPage</name><parameter_list>(<param><decl><type><name>uintptr_t</name></type> <name>addrOfLastLInsOnCurrentPage</name></decl></param>)</parameter_list>;</function_decl>

            <decl_stmt><decl><type><name>PageList</name></type>    <name>_pages</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Page</name>*</type>        <name>_nextPage</name></decl>;</decl_stmt> <comment type="line">// allocated in preperation of a needing to growing the buffer</comment>
            <decl_stmt><decl><type><name>uintptr_t</name></type>   <name>_unused</name></decl>;</decl_stmt>    <comment type="line">// next unused instruction slot</comment>
            <decl_stmt><decl><type><name>int</name></type>            <name>_noMem</name></decl>;</decl_stmt>        <comment type="line">// set if ran out of memory when writing to buffer</comment>
    };

    <expr_stmt><expr><name>class</name> <name>LirBufWriter</name> : <name>public</name> <name>LirWriter</name>
    <block>{
        <macro><name>DWB</name><argument_list>(<argument>LirBuffer*</argument>)</argument_list></macro>    <expr><name>_buf</name></expr>;        <comment type="line">// underlying buffer housing the instructions</comment>

        <expr><name>public</name>:
            <call><name>LirBufWriter</name><argument_list>(<argument><expr><name>LirBuffer</name>* <name>buf</name></expr></argument>)</argument_list></call>
                : <call><name>LirWriter</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <macro><name>_buf</name><argument_list>(<argument>buf</argument>)</argument_list></macro> <expr><block>{
            }</block>

            <comment type="line">// LirWriter interface</comment>
            <name>LInsp</name>   <macro><name>insLoad</name><argument_list>(<argument>LOpcode op</argument>, <argument>LInsp base</argument>, <argument>int32_t disp</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>insStorei</name><argument_list>(<argument>LInsp o1</argument>, <argument>LInsp o2</argument>, <argument>int32_t disp</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>ins0</name><argument_list>(<argument>LOpcode op</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>ins1</name><argument_list>(<argument>LOpcode op</argument>, <argument>LInsp o1</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>ins2</name><argument_list>(<argument>LOpcode op</argument>, <argument>LInsp o1</argument>, <argument>LInsp o2</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>ins3</name><argument_list>(<argument>LOpcode op</argument>, <argument>LInsp o1</argument>, <argument>LInsp o2</argument>, <argument>LInsp o3</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>insParam</name><argument_list>(<argument>int32_t i</argument>, <argument>int32_t kind</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>insImm</name><argument_list>(<argument>int32_t imm</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>insImmq</name><argument_list>(<argument>uint64_t imm</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>insCall</name><argument_list>(<argument>const CallInfo *call</argument>, <argument>LInsp args[]</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>insGuard</name><argument_list>(<argument>LOpcode op</argument>, <argument>LInsp cond</argument>, <argument>LIns *x</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>    <macro><name>insBranch</name><argument_list>(<argument>LOpcode v</argument>, <argument>LInsp condition</argument>, <argument>LInsp to</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>   <macro><name>insAlloc</name><argument_list>(<argument>int32_t size</argument>)</argument_list></macro></expr>;
            <expr><name>LInsp</name>   <call><name>insSkip</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;
    }</block></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>class</name></type> <name>LirFilter</name>
    <block>{
    <label><name>public</name>:</label>
        <decl_stmt><decl><type><name>LirFilter</name> *</type><name>in</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LirFilter</name><argument_list>(<argument><expr><name>LirFilter</name> *<name>in</name></expr></argument>)</argument_list></call> : <macro><name>in</name><argument_list>(<argument>in</argument>)</argument_list></macro> <block>{}</block>
        <name>virtual</name> ~<macro><name>LirFilter</name><argument_list>()</argument_list></macro><block>{}</block>

        <name>virtual</name> <name>LInsp</name> <macro><name>read</name><argument_list>()</argument_list></macro> <block>{
            <return>return <expr><call><name><name>in</name>-&gt;<name>read</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></expr></expr_stmt>
        <function><type><name>virtual</name> <name>LInsp</name></type> <name>pos</name><parameter_list>()</parameter_list> <block>{
            <return>return <expr><call><name><name>in</name>-&gt;<name>pos</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>
    }</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

    <comment type="line">// concrete</comment>
    <expr_stmt><expr><name>class</name> <name>LirReader</name> : <name>public</name> <name>LirFilter</name>
    <block>{
        <expr><name>LInsp</name> <name>_i</name></expr>; <comment type="line">// current instruction that this decoder is operating on.</comment>

    <expr><name>public</name>:
        <macro><name>LirReader</name><argument_list>(<argument>LInsp i</argument>)</argument_list></macro> : <call><name>LirFilter</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>, <macro><name>_i</name><argument_list>(<argument>i</argument>)</argument_list></macro> <expr><block>{ }</block>
        <name>virtual</name> ~<macro><name>LirReader</name><argument_list>()</argument_list></macro> <block>{}</block>

        <comment type="line">// LirReader i/f</comment>
        <name>LInsp</name> <call><name>read</name><argument_list>()</argument_list></call></expr>; <comment type="line">// advance to the prior instruction</comment>
        <expr><name>LInsp</name> <macro><name>pos</name><argument_list>()</argument_list></macro> <block>{
            <return>return <expr><name>_i</name></expr>;</return></block></expr>
        }</block>
        <name>void</name> <macro><name>setpos</name><argument_list>(<argument>LIns *i</argument>)</argument_list></macro> <block>{
            <expr><name>_i</name> = <name>i</name></expr>;
        }</block></expr></expr_stmt>
    };

    <decl_stmt><decl><type><name>class</name></type> <name>Assembler</name></decl>;</decl_stmt>

    <function_decl><type><name>void</name></type> <name>compile</name><parameter_list>(<param><decl><type><name>Assembler</name> *</type><name>assm</name></decl></param>, <param><decl><type><name>Fragment</name> *</type><name>frag</name></decl></param>)</parameter_list>;</function_decl>
    <macro><name>verbose_only</name><argument_list>(<argument>void live(GC *gc, LirBuffer *lirbuf);</argument>)</argument_list></macro>

    <expr_stmt><expr><name>class</name> <name>StackFilter</name>: <name>public</name> <name>LirFilter</name>
    <block>{
        <expr><name>GC</name> *<name>gc</name></expr>;
        <expr><name>LirBuffer</name> *<name>lirbuf</name></expr>;
        <expr><name>LInsp</name> <name>sp</name></expr>;
        <expr><name>avmplus</name>::<name>BitSet</name> <name>stk</name></expr>;
        <expr><name>int</name> <name>top</name></expr>;
        <expr><name>int</name> <macro><name>getTop</name><argument_list>(<argument>LInsp br</argument>)</argument_list></macro></expr>;
    <expr><name>public</name>:
        <macro><name>StackFilter</name><argument_list>(<argument>LirFilter *in</argument>, <argument>GC *gc</argument>, <argument>LirBuffer *lirbuf</argument>, <argument>LInsp sp</argument>)</argument_list></macro></expr>;
        <expr><name>virtual</name> ~<macro><name>StackFilter</name><argument_list>()</argument_list></macro> <block>{}</block>
        <name>LInsp</name> <call><name>read</name><argument_list>()</argument_list></call></expr>;
    }</block></expr>;</expr_stmt>

    <expr_stmt><expr><name>class</name> <name>CseReader</name>: <name>public</name> <name>LirFilter</name>
    <block>{
        <expr><name>LInsHashSet</name> *<name>exprs</name></expr>;
    <expr><name>public</name>:
        <call><name>CseReader</name><argument_list>(<argument><expr><name>LirFilter</name> *<name>in</name></expr></argument>, <argument><expr><name>LInsHashSet</name> *<name>exprs</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>LInsp</name> <call><name>read</name><argument_list>()</argument_list></call></expr>;
    }</block></expr>;</expr_stmt>

    <comment type="line">// eliminate redundant loads by watching for stores &amp; mutator calls</comment>
    <expr_stmt><expr><name>class</name> <name>LoadFilter</name>: <name>public</name> <name>LirWriter</name>
    <block>{
    <expr><name>public</name>:
        <name>LInsp</name> <name>sp</name></expr>, <expr><name>rp</name></expr>;
        <expr><name>LInsHashSet</name> <name>exprs</name></expr>;
        <expr><name>void</name> <macro><name>clear</name><argument_list>(<argument>LInsp p</argument>)</argument_list></macro></expr>;
    <expr><name>public</name>:
        <call><name>LoadFilter</name><argument_list>(<argument><expr><name>LirWriter</name> *<name>out</name></expr></argument>, <argument><expr><name>GC</name> *<name>gc</name></expr></argument>)</argument_list></call>
            : <call><name>LirWriter</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>, <macro><name>exprs</name><argument_list>(<argument>gc</argument>)</argument_list></macro> <expr><block>{ }</block>

        <name>LInsp</name> <call><name>ins0</name><argument_list>(<argument><expr><name>LOpcode</name></expr></argument>)</argument_list></call></expr>;
        <expr><name>LInsp</name> <macro><name>insLoad</name><argument_list>(<argument>LOpcode</argument>, <argument>LInsp base</argument>, <argument>int32_t disp</argument>)</argument_list></macro></expr>;
        <expr><name>LInsp</name> <macro><name>insStorei</name><argument_list>(<argument>LInsp v</argument>, <argument>LInsp b</argument>, <argument>int32_t d</argument>)</argument_list></macro></expr>;
        <expr><name>LInsp</name> <macro><name>insCall</name><argument_list>(<argument>const CallInfo *call</argument>, <argument>LInsp args[]</argument>)</argument_list></macro></expr>;
    }</block></expr>;</expr_stmt>
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// __nanojit_LIR__</comment>
</unit>
