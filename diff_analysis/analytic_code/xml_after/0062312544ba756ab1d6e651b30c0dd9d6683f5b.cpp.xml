<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0062312544ba756ab1d6e651b30c0dd9d6683f5b.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   IBM Corp.
 *   Henry Sobotka
 *   Benjamin Smedberg &lt;benjamin@smedbergs.us&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDebugImpl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prinit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plstr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsError.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prerror.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prerr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prenv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pratom.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ANDROID</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;android/log.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_BEOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* For DEBUGGER macros */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Debug.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_UNIX</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>XP_OS2</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>XP_BEOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* for abort() and getenv() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTraceRefcntImpl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISupportsUtils.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_WIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tchar.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsString.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mozilla/mozalloc_abort.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>Abort</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aMsg</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>RealBreak</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>Break</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aMsg</name></decl></param>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_WINDIALOGS</name></cpp:macro></cpp:define>  <comment type="line">// need for WinMessageBox</comment>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;os2.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XP_OS2 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include> <comment type="line">// for _alloca</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>PRInt32</name></type> <name>gAssertionCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<macro><name>NS_IMPL_QUERY_INTERFACE2</name><argument_list>(<argument>nsDebugImpl</argument>, <argument>nsIDebug</argument>, <argument>nsIDebug2</argument>)</argument_list></macro>

<macro><name>NS_IMETHODIMP_</name><argument_list>(<argument>nsrefcnt</argument>)</argument_list></macro>
<macro><name>nsDebugImpl</name></macro><expr_stmt><expr><name>::<name>AddRef</name></name>()
<block>{
  <return>return <expr>2</expr>;</return>
}</block></expr></expr_stmt>

<macro><name>NS_IMETHODIMP_</name><argument_list>(<argument>nsrefcnt</argument>)</argument_list></macro>
<macro><name>nsDebugImpl</name></macro><expr_stmt><expr><name>::<name>Release</name></name>()
<block>{
  <return>return <expr>1</expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsDebugImpl</name>::<name>Assertion</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aStr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aExpr</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aFile</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aLine</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_DebugBreak</name><argument_list>(<argument><expr><name>NS_DEBUG_ASSERTION</name></expr></argument>, <argument><expr><name>aStr</name></expr></argument>, <argument><expr><name>aExpr</name></expr></argument>, <argument><expr><name>aFile</name></expr></argument>, <argument><expr><name>aLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsDebugImpl</name>::<name>Warning</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aStr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aFile</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aLine</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_DebugBreak</name><argument_list>(<argument><expr><name>NS_DEBUG_WARNING</name></expr></argument>, <argument><expr><name>aStr</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aFile</name></expr></argument>, <argument><expr><name>aLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsDebugImpl</name>::<name>Break</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aFile</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aLine</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_DebugBreak</name><argument_list>(<argument><expr><name>NS_DEBUG_BREAK</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aFile</name></expr></argument>, <argument><expr><name>aLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsDebugImpl</name>::<name>Abort</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aFile</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>aLine</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_DebugBreak</name><argument_list>(<argument><expr><name>NS_DEBUG_ABORT</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>aFile</name></expr></argument>, <argument><expr><name>aLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsDebugImpl</name>::<name>GetIsDebugBuild</name></name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr>*<name>aResult</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr>*<name>aResult</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsDebugImpl</name>::<name>GetAssertionCount</name></name><parameter_list>(<param><decl><type><name>PRInt32</name>*</type> <name>aResult</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aResult</name> = <name>gAssertionCount</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Implementation of the nsDebug methods. Note that this code is
 * always compiled in, in case some other module that uses it is
 * compiled with debugging even if this library is not.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PRLogModuleInfo</name>*</type> <name>gDebugLog</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>InitLog</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>0 == <name>gDebugLog</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>gDebugLog</name> = <call><name>PR_NewLogModule</name><argument_list>(<argument><expr>"nsDebug"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gDebugLog</name>-&gt;<name>level</name></name> = <name>PR_LOG_DEBUG</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<enum>enum <name>nsAssertBehavior</name> <block>{
  <decl><name>NS_ASSERT_UNINITIALIZED</name></decl>,
  <decl><name>NS_ASSERT_WARN</name></decl>,
  <decl><name>NS_ASSERT_SUSPEND</name></decl>,
  <decl><name>NS_ASSERT_STACK</name></decl>,
  <decl><name>NS_ASSERT_TRAP</name></decl>,
  <decl><name>NS_ASSERT_ABORT</name></decl>,
  <decl><name>NS_ASSERT_STACK_AND_ABORT</name></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>nsAssertBehavior</name></type> <name>GetAssertBehavior</name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <name>nsAssertBehavior</name></type> <name>gAssertBehavior</name> <init>= <expr><name>NS_ASSERT_UNINITIALIZED</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>gAssertBehavior</name> != <name>NS_ASSERT_UNINITIALIZED</name></expr>)</condition><then>
    <return>return <expr><name>gAssertBehavior</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_WIN</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>XP_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>gAssertBehavior</name> = <name>NS_ASSERT_TRAP</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>gAssertBehavior</name> = <name>NS_ASSERT_WARN</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>assertString</name> <init>= <expr><call><name>PR_GetEnv</name><argument_list>(<argument><expr>"XPCOM_DEBUG_BREAK"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>assertString</name> || !*<name>assertString</name></expr>)</condition><then>
    <return>return <expr><name>gAssertBehavior</name></expr>;</return></then></if>

   <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>assertString</name></expr></argument>, <argument><expr>"warn"</expr></argument>)</argument_list></call></expr>)</condition><then>
     <return>return <expr><name>gAssertBehavior</name> = <name>NS_ASSERT_WARN</name></expr>;</return></then></if>

   <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>assertString</name></expr></argument>, <argument><expr>"suspend"</expr></argument>)</argument_list></call></expr>)</condition><then>
     <return>return <expr><name>gAssertBehavior</name> = <name>NS_ASSERT_SUSPEND</name></expr>;</return></then></if>

   <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>assertString</name></expr></argument>, <argument><expr>"stack"</expr></argument>)</argument_list></call></expr>)</condition><then>
     <return>return <expr><name>gAssertBehavior</name> = <name>NS_ASSERT_STACK</name></expr>;</return></then></if>

   <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>assertString</name></expr></argument>, <argument><expr>"abort"</expr></argument>)</argument_list></call></expr>)</condition><then>
     <return>return <expr><name>gAssertBehavior</name> = <name>NS_ASSERT_ABORT</name></expr>;</return></then></if>

   <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>assertString</name></expr></argument>, <argument><expr>"trap"</expr></argument>)</argument_list></call> || !<call><name>strcmp</name><argument_list>(<argument><expr><name>assertString</name></expr></argument>, <argument><expr>"break"</expr></argument>)</argument_list></call></expr>)</condition><then>
     <return>return <expr><name>gAssertBehavior</name> = <name>NS_ASSERT_TRAP</name></expr>;</return></then></if>

   <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>assertString</name></expr></argument>, <argument><expr>"stack-and-abort"</expr></argument>)</argument_list></call></expr>)</condition><then>
     <return>return <expr><name>gAssertBehavior</name> = <name>NS_ASSERT_STACK_AND_ABORT</name></expr>;</return></then></if>

   <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Unrecognized value of XPCOM_DEBUG_BREAK\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <return>return <expr><name>gAssertBehavior</name></expr>;</return>
}</block></function>

<struct>struct <name>FixedBuffer</name>
<block>{<public type="default">
  <constructor><name>FixedBuffer</name><parameter_list>()</parameter_list> <member_list>: <call><name>curlen</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call> </member_list><block>{ <expr_stmt><expr><name><name>buffer</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt> }</block></constructor>

  <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>1000</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>curlen</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>PRIntn</name></type>
<name>StuffFixedBuffer</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>closure</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>len</name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>
  
  <decl_stmt><decl><type><name>FixedBuffer</name> *</type><name>fb</name> <init>= <expr>(<name>FixedBuffer</name>*) <name>closure</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// strip the trailing null, we add it again later</comment>
  <if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>len</name> - 1</expr>]</index></name> == '\0'</expr>)</condition><then>
    <expr_stmt><expr>--<name>len</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>curlen</name></name> + <name>len</name> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>buffer</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
    <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>buffer</name></name></expr></argument>)</argument_list></sizeof> - <name><name>fb</name>-&gt;<name>curlen</name></name> - 1</expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>len</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>buffer</name></name> + <name><name>fb</name>-&gt;<name>curlen</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fb</name>-&gt;<name>curlen</name></name> += <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fb</name>-&gt;<name>buffer</name><index>[<expr><name><name>fb</name>-&gt;<name>curlen</name></name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>len</name></expr>;</return>
}</block></function>

<macro><name>EXPORT_XPCOM_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>NS_DebugBreak</name><argument_list>(<argument>PRUint32 aSeverity</argument>, <argument>const char *aStr</argument>, <argument>const char *aExpr</argument>,
              <argument>const char *aFile</argument>, <argument>PRInt32 aLine</argument>)</argument_list></macro>
<block>{
   <expr_stmt><expr><call><name>InitLog</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

   <decl_stmt><decl><type><name>FixedBuffer</name></type> <name>buf</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>PRLogModuleLevel</name></type> <name>ll</name> <init>= <expr><name>PR_LOG_WARNING</name></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sevString</name> <init>= <expr>"WARNING"</expr></init></decl>;</decl_stmt>

   <switch>switch <condition>(<expr><name>aSeverity</name></expr>)</condition> <block>{
   <case>case <expr><name>NS_DEBUG_ASSERTION</name></expr>:
     <expr_stmt><expr><name>sevString</name> = "###!!! ASSERTION"</expr>;</expr_stmt>
     <expr_stmt><expr><name>ll</name> = <name>PR_LOG_ERROR</name></expr>;</expr_stmt>
     <break>break;</break>

   </case><case>case <expr><name>NS_DEBUG_BREAK</name></expr>:
     <expr_stmt><expr><name>sevString</name> = "###!!! BREAK"</expr>;</expr_stmt>
     <expr_stmt><expr><name>ll</name> = <name>PR_LOG_ALWAYS</name></expr>;</expr_stmt>
     <break>break;</break>

   </case><case>case <expr><name>NS_DEBUG_ABORT</name></expr>:
     <expr_stmt><expr><name>sevString</name> = "###!!! ABORT"</expr>;</expr_stmt>
     <expr_stmt><expr><name>ll</name> = <name>PR_LOG_ALWAYS</name></expr>;</expr_stmt>
     <break>break;</break>

   </case><default>default:
     <expr_stmt><expr><name>aSeverity</name> = <name>NS_DEBUG_WARNING</name></expr>;</expr_stmt>
   </default>}</block></switch><empty_stmt>;</empty_stmt>

   <expr_stmt><expr><call><name>PR_sxprintf</name><argument_list>(<argument><expr><name>StuffFixedBuffer</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>"%s: "</expr></argument>, <argument><expr><name>sevString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <if>if <condition>(<expr><name>aStr</name></expr>)</condition><then>
     <expr_stmt><expr><call><name>PR_sxprintf</name><argument_list>(<argument><expr><name>StuffFixedBuffer</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>"%s: "</expr></argument>, <argument><expr><name>aStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

   <if>if <condition>(<expr><name>aExpr</name></expr>)</condition><then>
     <expr_stmt><expr><call><name>PR_sxprintf</name><argument_list>(<argument><expr><name>StuffFixedBuffer</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>"'%s', "</expr></argument>, <argument><expr><name>aExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

   <if>if <condition>(<expr><name>aFile</name></expr>)</condition><then>
     <expr_stmt><expr><call><name>PR_sxprintf</name><argument_list>(<argument><expr><name>StuffFixedBuffer</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>"file %s, "</expr></argument>, <argument><expr><name>aFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

   <if>if <condition>(<expr><name>aLine</name> != -1</expr>)</condition><then>
     <expr_stmt><expr><call><name>PR_sxprintf</name><argument_list>(<argument><expr><name>StuffFixedBuffer</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>"line %d"</expr></argument>, <argument><expr><name>aLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

   <comment type="line">// Write out the message to the debug log</comment>
   <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gDebugLog</name></expr></argument>, <argument><expr><name>ll</name></expr></argument>, <argument><expr>("%s", <name><name>buf</name>.<name>buffer</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>PR_LogFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

   <comment type="line">// errors on platforms without a debugdlg ring a bell on stderr</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>XP_WIN</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>XP_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
   <if>if <condition>(<expr><name>ll</name> != <name>PR_LOG_WARNING</name></expr>)</condition><then>
     <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"\07"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ANDROID</name></cpp:ifdef>
   <expr_stmt><expr><call><name>__android_log_print</name><argument_list>(<argument><expr><name>ANDROID_LOG_INFO</name></expr></argument>, <argument><expr>"Gecko"</expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name><name>buf</name>.<name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

   <comment type="line">// Write the message to stderr</comment>
   <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name><name>buf</name>.<name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <switch>switch <condition>(<expr><name>aSeverity</name></expr>)</condition> <block>{
   <case>case <expr><name>NS_DEBUG_WARNING</name></expr>:
     <return>return;</return>

   </case><case>case <expr><name>NS_DEBUG_BREAK</name></expr>:
     <expr_stmt><expr><call><name>Break</name><argument_list>(<argument><expr><name><name>buf</name>.<name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <return>return;</return>

   </case><case>case <expr><name>NS_DEBUG_ABORT</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
     <expr_stmt><expr><call><name>RealBreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
     <expr_stmt><expr><call><name><name>nsTraceRefcntImpl</name>::<name>WalkTheStack</name></name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>Abort</name><argument_list>(<argument><expr><name><name>buf</name>.<name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <return>return;</return>
   </case>}</block></switch>

   <comment type="line">// Now we deal with assertions</comment>
   <expr_stmt><expr><call><name>PR_AtomicIncrement</name><argument_list>(<argument><expr>&amp;<name>gAssertionCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <switch>switch <condition>(<expr><call><name>GetAssertBehavior</name><argument_list>()</argument_list></call></expr>)</condition> <block>{
   <case>case <expr><name>NS_ASSERT_WARN</name></expr>:
     <return>return;</return>

   </case><case>case <expr><name>NS_ASSERT_SUSPEND</name></expr>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_UNIX</name></cpp:ifdef>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Suspending process; attach with the debugger.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>SIGSTOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>Break</name><argument_list>(<argument><expr><name><name>buf</name>.<name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <return>return;</return>

   </case><case>case <expr><name>NS_ASSERT_STACK</name></expr>:
     <expr_stmt><expr><call><name><name>nsTraceRefcntImpl</name>::<name>WalkTheStack</name></name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <return>return;</return>

   </case><case>case <expr><name>NS_ASSERT_STACK_AND_ABORT</name></expr>:
     <expr_stmt><expr><call><name><name>nsTraceRefcntImpl</name>::<name>WalkTheStack</name></name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="line">// Fall through to abort</comment>

   </case><case>case <expr><name>NS_ASSERT_ABORT</name></expr>:
     <expr_stmt><expr><call><name>Abort</name><argument_list>(<argument><expr><name><name>buf</name>.<name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <return>return;</return>

   </case><case>case <expr><name>NS_ASSERT_TRAP</name></expr>:
   </case><case>case <expr><name>NS_ASSERT_UNINITIALIZED</name></expr>: <comment type="line">// Default to "trap" behavior</comment>
     <expr_stmt><expr><call><name>Break</name><argument_list>(<argument><expr><name><name>buf</name>.<name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <return>return;</return>
   </case>}</block></switch>   
}</block>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Abort</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aMsg</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>mozalloc_abort</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RealBreak</name><parameter_list>()</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>::<name>DebugBreak</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
   <asm>asm("int $3");</asm>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_BEOS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_MACOSX</name></expr></argument>)</argument_list></call></expr></cpp:elif>
   <expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGTRAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> &amp;&amp; (<call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call>)</expr></cpp:elif>
   <asm>asm("int $3");</asm>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
   <comment type="line">// don't know how to break on this platform</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="line">// Abort() calls this function, don't call it!</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>Break</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>aMsg</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WINCE</name></cpp:ifndef> <comment type="line">// we really just want to crash for now</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ignoreDebugger</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>ignoreDebugger</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>shouldIgnoreDebugger</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"XPCOM_DEBUG_DLG"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>ignoreDebugger</name> = 1 + (<name>shouldIgnoreDebugger</name> &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>shouldIgnoreDebugger</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr>(<name>ignoreDebugger</name> == 2) || !<call><name>::<name>IsDebuggerPresent</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>DWORD</name></type> <name>code</name> <init>= <expr><name>IDRETRY</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Create the debug dialog out of process to avoid the crashes caused by 
     * Windows events leaking into our event loop from an in process dialog.
     * We do this by launching windbgdlg.exe (built in xpcom/windbgdlg).
     * See http://bugzilla.mozilla.org/show_bug.cgi?id=54792
     */</comment>
    <decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>pi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>STARTUPINFOW</name></type> <name>si</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUnichar</name></type> <name><name>executable</name><index>[<expr><name>MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUnichar</name>*</type> <name>pName</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>pi</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>si</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name>.<name>cb</name></name>          = <sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name>.<name>wShowWindow</name></name> = <name>SW_SHOW</name></expr>;</expr_stmt>

    <comment type="line">// 2nd arg of CreateProcess is in/out</comment>
    <decl_stmt><decl><type><name>PRUnichar</name> *</type><name>msgCopy</name> <init>= <expr>(<name>PRUnichar</name>*) <call><name>_alloca</name><argument_list>(<argument><expr>(<call><name>strlen</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>)</argument_list></call> + 1)*<sizeof>sizeof<argument_list>(<argument><expr><name>PRUnichar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>wcscpy</name><argument_list>(<argument><expr><name>msgCopy</name></expr></argument>  , <argument><expr>(<name>PRUnichar</name>*)<call><name>NS_ConvertUTF8toUTF16</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>(<expr><call><name>GetModuleFileNameW</name><argument_list>(<argument><expr><call><name>GetModuleHandleW</name><argument_list>(<argument><expr>L"xpcom.dll"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>LPWCH</name>)<name>executable</name></expr></argument>, <argument><expr><name>MAX_PATH</name></expr></argument>)</argument_list></call> &amp;&amp;
       <name>NULL</name> != (<name>pName</name> = <call><name>wcsrchr</name><argument_list>(<argument><expr><name>executable</name></expr></argument>, <argument><expr>'\\'</expr></argument>)</argument_list></call>) &amp;&amp;
       <name>NULL</name> != 
       <call><name>wcscpy</name><argument_list>(<argument><expr>(<name>WCHAR</name>*)
       <name>pName</name>+1</expr></argument>, <argument><expr>L"windbgdlg.exe"</expr></argument>)</argument_list></call> &amp;&amp;
       <call><name>CreateProcessW</name><argument_list>(<argument><expr>(<name>LPCWSTR</name>)<name>executable</name></expr></argument>, <argument><expr>(<name>LPWSTR</name>)<name>msgCopy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                     <argument><expr><name>DETACHED_PROCESS</name> | <name>NORMAL_PRIORITY_CLASS</name></expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>si</name></expr></argument>, <argument><expr>&amp;<name>pi</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name><name>pi</name>.<name>hProcess</name></name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GetExitCodeProcess</name><argument_list>(<argument><expr><name><name>pi</name>.<name>hProcess</name></name></expr></argument>, <argument><expr>&amp;<name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name>.<name>hProcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name>.<name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <switch>switch<condition>(<expr><name>code</name></expr>)</condition> <block>{
    <case>case <expr><name>IDABORT</name></expr>:
      <comment type="line">//This should exit us</comment>
      <expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGABRT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//If we are ignored exit this way..</comment>
      <expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         
    </case><case>case <expr><name>IDIGNORE</name></expr>:
      <return>return;</return>
    </case>}</block></switch>
  }</block></then></if>

  <expr_stmt><expr><call><name>RealBreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// WINCE</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
   <decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr>1200</expr>]</index></name></decl>;</decl_stmt>
   <expr_stmt><expr><call><name>PR_snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>,
               <argument><expr>"%s\n\nClick Cancel to Debug Application.\n"
               "Click Enter to continue running the Application."</expr></argument>, <argument><expr><name>aMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <decl_stmt><decl><type><name>ULONG</name></type> <name>code</name> <init>= <expr><name>MBID_ERROR</name></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name>code</name> = <call><name>WinMessageBox</name><argument_list>(<argument><expr><name>HWND_DESKTOP</name></expr></argument>, <argument><expr><name>HWND_DESKTOP</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, 
                        <argument><expr>"NSGlue_Assertion"</expr></argument>, <argument><expr>0</expr></argument>,
                        <argument><expr><name>MB_ERROR</name> | <name>MB_ENTERCANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <comment type="block">/* It is possible that we are executing on a thread that doesn't have a
    * message queue.  In that case, the message won't appear, and code will
    * be 0xFFFF.  We'll give the user a chance to debug it by calling
    * Break()
    * Actually, that's a really bad idea since this happens a lot with threadsafe
    * assertions and since it means that you can't actually run the debug build
    * outside a debugger without it crashing constantly.
    */</comment>
   <if>if <condition>(<expr>( <name>code</name> == <name>MBID_ENTER</name> ) || (<name>code</name> == <name>MBID_ERROR</name>)</expr>)</condition><then>
     <return>return;</return></then></if>

   <expr_stmt><expr><call><name>RealBreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_BEOS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
   <expr_stmt><expr><call><name>DEBUGGER</name><argument_list>(<argument><expr><name>aMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>RealBreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_MACOSX</name></expr></argument>)</argument_list></call></expr></cpp:elif>
   <comment type="block">/* Note that we put this Mac OS X test above the GNUC/x86 test because the
    * GNUC/x86 test is also true on Intel Mac OS X and we want the PPC/x86
    * impls to be the same.
    */</comment>
   <expr_stmt><expr><call><name>RealBreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> &amp;&amp; (<call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call>)</expr></cpp:elif>
   <expr_stmt><expr><call><name>RealBreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
   <comment type="line">// don't know how to break on this platform</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>nsDebugImpl</name></type> <name>kImpl</name></decl>;</decl_stmt>

<function><type><name>NS_METHOD</name></type>
<name><name>nsDebugImpl</name>::<name>Create</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>*</type> <name>outer</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsIID</name>&amp;</type> <name>aIID</name></decl></param>, <param><decl><type><name>void</name>* *</type><name>aInstancePtr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_NO_AGGREGATION</name><argument_list>(<argument><expr><name>outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>const_cast</name><argument_list>&lt;<argument><expr><name>nsDebugImpl</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr>&amp;<name>kImpl</name></expr></argument>)</argument_list></call>-&gt;
    <call><name>QueryInterface</name><argument_list>(<argument><expr><name>aIID</name></expr></argument>, <argument><expr><name>aInstancePtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////////////</comment>

<function><type><name>NS_COM</name> <name>nsresult</name></type>
<name>NS_ErrorAccordingToNSPR</name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>PRErrorCode</name></type> <name>err</name> <init>= <expr><call><name>PR_GetError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>err</name></expr>)</condition> <block>{
      <case>case <expr><name>PR_OUT_OF_MEMORY_ERROR</name></expr>:              <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return>
      </case><case>case <expr><name>PR_WOULD_BLOCK_ERROR</name></expr>:                <return>return <expr><name>NS_BASE_STREAM_WOULD_BLOCK</name></expr>;</return>
      </case><case>case <expr><name>PR_FILE_NOT_FOUND_ERROR</name></expr>:             <return>return <expr><name>NS_ERROR_FILE_NOT_FOUND</name></expr>;</return>
      </case><case>case <expr><name>PR_READ_ONLY_FILESYSTEM_ERROR</name></expr>:       <return>return <expr><name>NS_ERROR_FILE_READ_ONLY</name></expr>;</return>
      </case><case>case <expr><name>PR_NOT_DIRECTORY_ERROR</name></expr>:              <return>return <expr><name>NS_ERROR_FILE_NOT_DIRECTORY</name></expr>;</return>
      </case><case>case <expr><name>PR_IS_DIRECTORY_ERROR</name></expr>:               <return>return <expr><name>NS_ERROR_FILE_IS_DIRECTORY</name></expr>;</return>
      </case><case>case <expr><name>PR_LOOP_ERROR</name></expr>:                       <return>return <expr><name>NS_ERROR_FILE_UNRESOLVABLE_SYMLINK</name></expr>;</return>
      </case><case>case <expr><name>PR_FILE_EXISTS_ERROR</name></expr>:                <return>return <expr><name>NS_ERROR_FILE_ALREADY_EXISTS</name></expr>;</return>
      </case><case>case <expr><name>PR_FILE_IS_LOCKED_ERROR</name></expr>:             <return>return <expr><name>NS_ERROR_FILE_IS_LOCKED</name></expr>;</return>
      </case><case>case <expr><name>PR_FILE_TOO_BIG_ERROR</name></expr>:               <return>return <expr><name>NS_ERROR_FILE_TOO_BIG</name></expr>;</return>
      </case><case>case <expr><name>PR_NO_DEVICE_SPACE_ERROR</name></expr>:            <return>return <expr><name>NS_ERROR_FILE_NO_DEVICE_SPACE</name></expr>;</return>
      </case><case>case <expr><name>PR_NAME_TOO_LONG_ERROR</name></expr>:              <return>return <expr><name>NS_ERROR_FILE_NAME_TOO_LONG</name></expr>;</return>
      </case><case>case <expr><name>PR_DIRECTORY_NOT_EMPTY_ERROR</name></expr>:        <return>return <expr><name>NS_ERROR_FILE_DIR_NOT_EMPTY</name></expr>;</return>
      </case><case>case <expr><name>PR_NO_ACCESS_RIGHTS_ERROR</name></expr>:           <return>return <expr><name>NS_ERROR_FILE_ACCESS_DENIED</name></expr>;</return>
      </case><default>default:                                  <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    </default>}</block></switch>
}</block></function>

<comment type="line" format="doxygen">////////////////////////////////////////////////////////////////////////////////</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_WIN</name></cpp:ifdef>
<decl_stmt><decl><type><name>NS_COM</name> <name>PRBool</name></type> <name>sXPCOMHasLoadedNewDLLs</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<function><type><name>NS_EXPORT</name> <name>void</name></type>
<name>NS_SetHasLoadedNewDLLs</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>sXPCOMHasLoadedNewDLLs</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
