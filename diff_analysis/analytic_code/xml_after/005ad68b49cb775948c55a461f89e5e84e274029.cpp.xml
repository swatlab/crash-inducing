<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="005ad68b49cb775948c55a461f89e5e84e274029.cpp"><comment type="block">/* -*- Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 4 -*- */</comment>
<comment type="block">/* vi: set ts=4 sw=4 expandtab: (add to ~/.vimrc: set modeline modelines=5) */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is [Open Source Virtual Machine].
 *
 * The Initial Developer of the Original Code is
 * Adobe System Incorporated.
 * Portions created by the Initial Developer are Copyright (C) 2004-2007
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Adobe AS3 Team
 *   leon.sha@sun.com
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nanojit.h"</cpp:file></cpp:include>

<namespace>namespace <name>nanojit</name>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FEATURE_NANOJIT</name></cpp:ifdef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NJ_VERBOSE</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>regNames</name><index>[]</index></name> <init>= <expr><block>{
        <expr>"%g0"</expr>, <expr>"%g1"</expr>, <expr>"%g2"</expr>, <expr>"%g3"</expr>, <expr>"%g4"</expr>, <expr>"%g5"</expr>, <expr>"%g6"</expr>, <expr>"%g7"</expr>,
        <expr>"%o0"</expr>, <expr>"%o1"</expr>, <expr>"%o2"</expr>, <expr>"%o3"</expr>, <expr>"%o4"</expr>, <expr>"%o5"</expr>, <expr>"%sp"</expr>, <expr>"%o7"</expr>,
        <expr>"%l0"</expr>, <expr>"%l1"</expr>, <expr>"%l2"</expr>, <expr>"%l3"</expr>, <expr>"%l4"</expr>, <expr>"%l5"</expr>, <expr>"%l6"</expr>, <expr>"%l7"</expr>,
        <expr>"%i0"</expr>, <expr>"%i1"</expr>, <expr>"%i2"</expr>, <expr>"%i3"</expr>, <expr>"%i4"</expr>, <expr>"%i5"</expr>, <expr>"%fp"</expr>, <expr>"%i7"</expr>,
        <expr>"%f0"</expr>, <expr>"%f1"</expr>, <expr>"%f2"</expr>, <expr>"%f3"</expr>, <expr>"%f4"</expr>, <expr>"%f5"</expr>, <expr>"%f6"</expr>, <expr>"%f7"</expr>,
        <expr>"%f8"</expr>, <expr>"%f9"</expr>, <expr>"%f10"</expr>, <expr>"%f11"</expr>, <expr>"%f12"</expr>, <expr>"%f13"</expr>, <expr>"%f14"</expr>, <expr>"%f15"</expr>,
        <expr>"%f16"</expr>, <expr>"%f17"</expr>, <expr>"%f18"</expr>, <expr>"%f19"</expr>, <expr>"%f20"</expr>, <expr>"%f21"</expr>, <expr>"%f22"</expr>, <expr>"%f23"</expr>,
        <expr>"%f24"</expr>, <expr>"%f25"</expr>, <expr>"%f26"</expr>, <expr>"%f27"</expr>, <expr>"%f28"</expr>, <expr>"%f29"</expr>, <expr>"%f30"</expr>, <expr>"%f31"</expr>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><specifier>const</specifier> <name>Register</name></type> <name><name>Assembler</name>::<name>argRegs</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>I0</name></expr>, <expr><name>I1</name></expr>, <expr><name>I2</name></expr>, <expr><name>I3</name></expr>, <expr><name>I4</name></expr>, <expr><name>I5</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Register</name></type> <name><name>Assembler</name>::<name>retRegs</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>O0</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>Register</name></type> <name><name>Assembler</name>::<name>savedRegs</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>L1</name></expr> }</block></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>kLinkageAreaSize</name> <init>= <expr>68</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>kcalleeAreaSize</name> <init>= <expr>80</expr></init></decl>;</decl_stmt> <comment type="line">// The max size.</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_ROUND_UP</name><parameter_list>(<param><type><name>v</name></type></param>,<param><type><name>q</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>( (((uintptr_t)v)+(q)-1) &amp; ~((q)-1) )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TODO</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do{ verbose_only(outputf(#x);) NanoAssertMsgf(false, "%s", #x); } while(0)</cpp:value></cpp:define>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>nInit</name></name><parameter_list>(<param><decl><type><name>AvmCore</name>*</type> <name>core</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name>has_cmov</name> = true</expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>nBeginAssembly</name></name><parameter_list>()</parameter_list> <block>{
    }</block></function>

    <function><type><name>NIns</name>*</type> <name><name>Assembler</name>::<name>genPrologue</name></name><parameter_list>()</parameter_list>
    <block>{
        <comment type="block" format="doxygen">/**
         * Prologue
         */</comment>
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>stackNeeded</name> <init>= <expr><name>STACK_GRANULARITY</name> * <name><name>_activation</name>.<name>tos</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>frameSize</name> <init>= <expr><name>stackNeeded</name> + <name>kcalleeAreaSize</name> + <name>kLinkageAreaSize</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>frameSize</name> = <call><name>BIT_ROUND_UP</name><argument_list>(<argument><expr><name>frameSize</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>frameSize</name> &lt;= 4096</expr>)</condition><then>
            <expr_stmt><expr><call><name>SUBI</name><argument_list>(<argument><expr><name>FP</name></expr></argument>, <argument><expr><name>frameSize</name></expr></argument>, <argument><expr><name>SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>SUB</name><argument_list>(<argument><expr><name>FP</name></expr></argument>, <argument><expr><name>G1</name></expr></argument>, <argument><expr><name>SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ORI</name><argument_list>(<argument><expr><name>G1</name></expr></argument>, <argument><expr><name>frameSize</name> &amp; 0x3FF</expr></argument>, <argument><expr><name>G1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SETHI</name><argument_list>(<argument><expr><name>frameSize</name></expr></argument>, <argument><expr><name>G1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <macro><name>verbose_only</name><argument_list>(
        <argument>if (_logc-&gt;lcbits &amp; LC_Assembly) {
            outputf("        %p:",_nIns);
            outputf("        patch entry:");
        }</argument>)</argument_list></macro>
        <decl_stmt><decl><type><name>NIns</name> *</type><name>patchEntry</name> <init>= <expr><name>_nIns</name></expr></init></decl>;</decl_stmt>

        <comment type="line">// The frame size in SAVE is faked. We will still re-caculate SP later.</comment>
        <comment type="line">// We can use 0 here but it is not good for debuggers.</comment>
        <expr_stmt><expr><call><name>SAVEI</name><argument_list>(<argument><expr><name>SP</name></expr></argument>, <argument><expr>-148</expr></argument>, <argument><expr><name>SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// align the entry point</comment>
        <expr_stmt><expr><call><name>asm_align_code</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>patchEntry</name></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_align_code</name></name><parameter_list>()</parameter_list> <block>{
        <while>while<condition>(<expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>_nIns</name></expr></argument>)</argument_list></call> &amp; 15</expr>)</condition> <block>{
            <expr_stmt><expr><call><name>NOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>nFragExit</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>guard</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>SideExit</name>*</type> <name>exit</name> <init>= <expr><call><name><name>guard</name>-&gt;<name>record</name></name><argument_list>()</argument_list></call>-&gt;<name>exit</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Fragment</name> *</type><name>frag</name> <init>= <expr><name><name>exit</name>-&gt;<name>target</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GuardRecord</name> *</type><name>lr</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>frag</name> &amp;&amp; <name><name>frag</name>-&gt;<name>fragEntry</name></name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name>JMP</name><argument_list>(<argument><expr><name><name>frag</name>-&gt;<name>fragEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lr</name> = 0</expr>;</expr_stmt>
            }</block></then>
        <else>else
            <block>{
                <comment type="line">// Target doesn't exit yet. Emit jump to epilog, and set up to patch later.</comment>
                <if>if <condition>(<expr>!<name>_epilogue</name></expr>)</condition><then>
                    <expr_stmt><expr><name>_epilogue</name> = <call><name>genEpilogue</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>lr</name> = <call><name><name>guard</name>-&gt;<name>record</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JMP_long</name><argument_list>(<argument><expr>(<name>intptr_t</name>)<name>_epilogue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lr</name>-&gt;<name>jmp</name></name> = <name>_nIns</name></expr>;</expr_stmt>
            }</block></else></if>

        <comment type="line">// return value is GuardRecord*</comment>
        <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><call><name>int</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>O0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>NIns</name> *</type><name><name>Assembler</name>::<name>genEpilogue</name></name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RESTORE</name><argument_list>(<argument><expr><name>G0</name></expr></argument>, <argument><expr><name>G0</name></expr></argument>, <argument><expr><name>G0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//restore</comment>
        <expr_stmt><expr><call><name>JMPLI</name><argument_list>(<argument><expr><name>I7</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><name>G0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//ret</comment>
        <expr_stmt><expr><call><name>ORI</name><argument_list>(<argument><expr><name>O0</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>I0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return  <expr><name>_nIns</name></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_call</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Register</name></type> <name>retReg</name> <init>= <expr>( <call><name><name>ins</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_fcall</name></expr></argument>)</argument_list></call> ? <name>F0</name> : <name><name>retRegs</name><index>[<expr>0</expr>]</index></name> )</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><call><name>rmask</name><argument_list>(<argument><expr><name>retReg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Do this after we've handled the call result, so we don't</comment>
        <comment type="line">// force the call result to be spilled unnecessarily.</comment>

        <expr_stmt><expr><call><name>evictScratchRegs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>CallInfo</name>*</type> <name>call</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>callInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>ArgSize</name></type> <name><name>sizes</name><index>[<expr><name>MAXARGS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>argc</name> <init>= <expr><call><name><name>call</name>-&gt;<name>get_sizes</name></name><argument_list>(<argument><expr><name>sizes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name><name>ins</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_pcall</name></expr></argument>)</argument_list></call> || <call><name><name>ins</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_fcall</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>verbose_only</name><argument_list>(<argument>if (_logc-&gt;lcbits &amp; LC_Assembly)
                     outputf("        %p:", _nIns);</argument>
                     )</argument_list></macro>
        <decl_stmt><decl><type><name>bool</name></type> <name>indirect</name> <init>= <expr><call><name><name>call</name>-&gt;<name>isIndirect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>indirect</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>CALL</name><argument_list>(<argument><expr><name>call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>argc</name>--</expr>;</expr_stmt>
            <decl_stmt><decl><type><name>Register</name></type> <name>r</name> <init>= <expr><call><name>findSpecificRegFor</name><argument_list>(<argument><expr><call><name><name>ins</name>-&gt;<name>arg</name></name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>I0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JMPL</name><argument_list>(<argument><expr><name>G0</name></expr></argument>, <argument><expr><name>I0</name></expr></argument>, <argument><expr>15</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <decl_stmt><decl><type><name>uint32_t</name></type> <name>GPRIndex</name> <init>= <expr><name>O0</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>offset</name> <init>= <expr><name>kLinkageAreaSize</name></expr></init></decl>;</decl_stmt> <comment type="line">// start of parameters stack postion.</comment>

        <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name>&lt;<name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <decl_stmt><decl><type><name>uint32_t</name></type> <name>j</name> <init>= <expr><name>argc</name>-<name>i</name>-1</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ArgSize</name></type> <name>sz</name> <init>= <expr><name><name>sizes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>sz</name> == <name>ARGSIZE_F</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>Register</name></type> <name>r</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><call><name><name>ins</name>-&gt;<name>arg</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>GPRIndex</name> += 2</expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> += 8</expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>48</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// We might be calling a varargs function.</comment>
                    <comment type="line">// So, make sure the GPR's are also loaded with</comment>
                    <comment type="line">// the value, or the stack contains it.</comment>
                    <if>if <condition>(<expr><name>GPRIndex</name>-2 &lt;= <name>O5</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>LDSW32</name><argument_list>(<argument><expr><name>SP</name></expr></argument>, <argument><expr><name>offset</name>-8</expr></argument>, <argument><expr><call>(<name>Register</name>)<argument_list>(<argument><expr><name>GPRIndex</name>-2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>GPRIndex</name>-1 &lt;= <name>O5</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>LDSW32</name><argument_list>(<argument><expr><name>SP</name></expr></argument>, <argument><expr><name>offset</name>-4</expr></argument>, <argument><expr><call>(<name>Register</name>)<argument_list>(<argument><expr><name>GPRIndex</name>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><call><name>STDF32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>offset</name>-8</expr></argument>, <argument><expr><name>SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr><name>GPRIndex</name> &gt; <name>O5</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name>Register</name></type> <name>r</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><call><name><name>ins</name>-&gt;<name>arg</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <decl_stmt><decl><type><name>Register</name></type> <name>r</name> <init>= <expr><call><name>findSpecificRegFor</name><argument_list>(<argument><expr><call><name><name>ins</name>-&gt;<name>arg</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>Register</name>)<name>GPRIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    }</block></else></if>
                    <expr_stmt><expr><name>GPRIndex</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name> += 4</expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>
    }</block></function>

    <function><type><name>Register</name></type> <name><name>Assembler</name>::<name>nRegisterAllocFromSet</name></name><parameter_list>(<param><decl><type><name>RegisterMask</name></type> <name>set</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// need to implement faster way</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr>!(<name>set</name> &amp; <call><name>rmask</name><argument_list>(<argument><expr>(<name>Register</name>)<name>i</name></expr></argument>)</argument_list></call>)</expr>)</condition>
            <expr_stmt><expr><name>i</name> ++</expr>;</expr_stmt></while>
        <expr_stmt><expr><name><name>_allocator</name>.<name>free</name></name> &amp;= ~<call><name>rmask</name><argument_list>(<argument><expr>(<name>Register</name>)<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>Register</name>) <name>i</name></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>nRegisterResetAll</name></name><parameter_list>(<param><decl><type><name>RegAlloc</name>&amp;</type> <name>a</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>a</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>.<name>free</name></name> = <name>GpRegs</name> | <name>FpRegs</name></expr>;</expr_stmt>
        <macro><name>debug_only</name><argument_list>( <argument>a.managed = a.free;</argument> )</argument_list></macro>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>nPatchBranch</name></name><parameter_list>(<param><decl><type><name>NIns</name>*</type> <name>branch</name></decl></param>, <param><decl><type><name>NIns</name>*</type> <name>location</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr>*(<name>uint32_t</name>*)&amp;<name><name>branch</name><index>[<expr>0</expr>]</index></name> &amp;= 0xFFC00000</expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>uint32_t</name>*)&amp;<name><name>branch</name><index>[<expr>0</expr>]</index></name> |= ((<name>intptr_t</name>)<name>location</name> &gt;&gt; 10) &amp; 0x3FFFFF</expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>uint32_t</name>*)&amp;<name><name>branch</name><index>[<expr>1</expr>]</index></name> &amp;= 0xFFFFFC00</expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>uint32_t</name>*)&amp;<name><name>branch</name><index>[<expr>1</expr>]</index></name> |= (<name>intptr_t</name>)<name>location</name> &amp; 0x3FF</expr>;</expr_stmt>
    }</block></function>

    <function><type><name>RegisterMask</name></type> <name><name>Assembler</name>::<name>hint</name></name><parameter_list>(<param><decl><type><name>LIns</name>*</type> <name>i</name></decl></param>, <param><decl><type><name>RegisterMask</name></type> <name>allow</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><name>allow</name></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_qjoin</name></name><parameter_list>(<param><decl><type><name>LIns</name> *</type><name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>40</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>findMemFor</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>AvmAssert</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>lo</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>hi</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>getReg</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>isKnownReg</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call> &amp;&amp; (<call><name>rmask</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call> &amp; <name>FpRegs</name>)</expr>)</condition><then>
            <expr_stmt><expr><call><name>evict</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><call><name><name>hi</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>L2</name></expr></argument>, <argument><expr><name>d</name>+4</expr></argument>, <argument><expr><name>FP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><call><name><name>hi</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>Register</name></type> <name>rh</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>rh</name></expr></argument>, <argument><expr><name>d</name>+4</expr></argument>, <argument><expr><name>FP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><call><name><name>lo</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>L2</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>FP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><call><name><name>lo</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="line">// okay if r gets recycled.</comment>
            <decl_stmt><decl><type><name>Register</name></type> <name>rl</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>rl</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>FP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><call><name>freeRsrcOf</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="line">// if we had a reg in use, emit a ST to flush it to mem</comment>
    }</block></function>


    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_restore</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>i</name></decl></param>, <param><decl><type><name>Register</name></type> <name>r</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>i</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_alloc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ADD</name><argument_list>(<argument><expr><name>FP</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int32_t</name></type> <name>d</name> <init>= <expr><call><name>disp</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name><name>i</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name><name>i</name>-&gt;<name>getArIndex</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name><name>i</name>-&gt;<name>markAsClear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><call><name><name>i</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>findMemFor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>rmask</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> &amp; <name>FpRegs</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>LDDF32</name><argument_list>(<argument><expr><name>FP</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>LDSW32</name><argument_list>(<argument><expr><name>FP</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if></else></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_store32</name></name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>value</name></decl></param>, <param><decl><type><name>int</name></type> <name>dr</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>base</name></decl></param>)</parameter_list>
    <block>{
        <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
            <case>case <expr><name>LIR_sti</name></expr>:
                <comment type="line">// handled by mainline code below for now</comment>
                <break>break;</break>
            </case><case>case <expr><name>LIR_stb</name></expr>:
            </case><case>case <expr><name>LIR_sts</name></expr>:
                <expr_stmt><expr><call><name>NanoAssertMsg</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"NJ_EXPANDED_LOADSTORE_SUPPORTED not yet supported for this architecture"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </case><default>default:
                <expr_stmt><expr><call><name>NanoAssertMsg</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"asm_store32 should never receive this LIR opcode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
        </default>}</block></switch>

        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>20</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>value</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>Register</name></type> <name>rb</name> <init>= <expr><call><name>getBaseReg</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>dr</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>value</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>L2</name></expr></argument>, <argument><expr><name>dr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
        <else>else
            <block>{
                <comment type="line">// make sure what is in a register</comment>
                <decl_stmt><decl><type><name>Register</name></type> <name>ra</name></decl>, <decl><type ref="prev"/><name>rb</name></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>base</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_alloc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rb</name> = <name>FP</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>dr</name> += <call><name>findMemFor</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ra</name> = <call><name>findRegFor</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><call><name><name>base</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="line">// absolute address</comment>
                    <expr_stmt><expr><name>dr</name> += <call><name><name>base</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ra</name> = <call><name>findRegFor</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rb</name> = <name>G0</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>findRegFor2</name><argument_list>(<argument><expr><name>GpRegs</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if></else></if>
                <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>dr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_spill</name></name><parameter_list>(<param><decl><type><name>Register</name></type> <name>rr</name></decl></param>, <param><decl><type><name>int</name></type> <name>d</name></decl></param>, <param><decl><type><name>bool</name></type> <name>pop</name></decl></param>, <param><decl><type><name>bool</name></type> <name>quad</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>(<name>void</name>)<name>quad</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>d</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>rmask</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call> &amp; <name>FpRegs</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>STDF32</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>FP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>FP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_load64</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <switch>switch <condition>(<expr><call><name><name>ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
            <case>case <expr><name>LIR_ldq</name></expr>:
            </case><case>case <expr><name>LIR_ldqc</name></expr>:
                <comment type="line">// handled by mainline code below for now</comment>
                <break>break;</break>
            </case><case>case <expr><name>LIR_ld32f</name></expr>:
            </case><case>case <expr><name>LIR_ldc32f</name></expr>:
                <expr_stmt><expr><call><name>NanoAssertMsg</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"NJ_EXPANDED_LOADSTORE_SUPPORTED not yet supported for this architecture"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </case><default>default:
                <expr_stmt><expr><call><name>NanoAssertMsg</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"asm_load64 should never receive this LIR opcode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
        </default>}</block></switch>

        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>72</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>base</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>db</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>disp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>getReg</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>dr</name> <init>= <expr><call><name>disp</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rb</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>base</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_alloc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rb</name> = <name>FP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>db</name> += <call><name>findMemFor</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>rb</name> = <call><name>findRegFor</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name><name>ins</name>-&gt;<name>setReg</name></name><argument_list>(<argument><expr><name>UnknownReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// don't use an fpu reg to simply load &amp; store the value.</comment>
        <if>if <condition>(<expr><name>dr</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>asm_mmq</name><argument_list>(<argument><expr><name>FP</name></expr></argument>, <argument><expr><name>dr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>freeRsrcOf</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rr</name> != <name>UnknownReg</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name>rmask</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call>&amp;<name>FpRegs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>_allocator</name>.<name>retire</name></name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>LDDF32</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_store64</name></name><parameter_list>(<param><decl><type><name>LOpcode</name></type> <name>op</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>value</name></decl></param>, <param><decl><type><name>int</name></type> <name>dr</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>base</name></decl></param>)</parameter_list>
    <block>{
        <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
            <case>case <expr><name>LIR_stqi</name></expr>:
                <comment type="line">// handled by mainline code below for now</comment>
                <break>break;</break>
            </case><case>case <expr><name>LIR_st32f</name></expr>:
                <expr_stmt><expr><call><name>NanoAssertMsg</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"NJ_EXPANDED_LOADSTORE_SUPPORTED not yet supported for this architecture"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </case><default>default:
                <expr_stmt><expr><call><name>NanoAssertMsg</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"asm_store64 should never receive this LIR opcode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
        </default>}</block></switch>

        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>48</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>value</name>-&gt;<name>isconstq</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <comment type="line">// if a constant 64-bit value just store it now rather than</comment>
                <comment type="line">// generating a pointless store/load/store sequence</comment>
                <decl_stmt><decl><type><name>Register</name></type> <name>rb</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>L2</name></expr></argument>, <argument><expr><name>dr</name>+4</expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><call><name><name>value</name>-&gt;<name>imm64_0</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>L2</name></expr></argument>, <argument><expr><name>dr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><call><name><name>value</name>-&gt;<name>imm64_1</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

        <if>if <condition>(<expr><call><name><name>value</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_ldq</name></expr></argument>)</argument_list></call> || <call><name><name>value</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_ldqc</name></expr></argument>)</argument_list></call> || <call><name><name>value</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_qjoin</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <comment type="line">// value is 64bit struct or int64_t, or maybe a double.</comment>
                <comment type="line">// it may be live in an FPU reg.  Either way, don't</comment>
                <comment type="line">// put it in an FPU reg just to load &amp; store it.</comment>

                <comment type="line">// a) if we know it's not a double, this is right.</comment>
                <comment type="line">// b) if we guarded that its a double, this store could be on</comment>
                <comment type="line">// the side exit, copying a non-double.</comment>
                <comment type="line">// c) maybe its a double just being stored.  oh well.</comment>

                <decl_stmt><decl><type><name>int</name></type> <name>da</name> <init>= <expr><call><name>findMemFor</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Register</name></type> <name>rb</name></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>base</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_alloc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rb</name> = <name>FP</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>dr</name> += <call><name>findMemFor</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>rb</name> = <call><name>findRegFor</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><call><name>asm_mmq</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>dr</name></expr></argument>, <argument><expr><name>FP</name></expr></argument>, <argument><expr><name>da</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

        <decl_stmt><decl><type><name>Register</name></type> <name>rb</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>base</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_alloc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rb</name> = <name>FP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>dr</name> += <call><name>findMemFor</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>rb</name> = <call><name>findRegFor</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="line">// if value already in a reg, use that, otherwise</comment>
        <comment type="line">// try to get it into XMM regs before FPU regs.</comment>
        <decl_stmt><decl><type><name>Register</name></type> <name>rv</name> <init>= <expr>( <call><name><name>value</name>-&gt;<name>isUnusedOrHasUnknownReg</name></name><argument_list>()</argument_list></call>
                      ? <call><name>findRegFor</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>FpRegs</name></expr></argument>)</argument_list></call>
                      : <call><name><name>value</name>-&gt;<name>getReg</name></name><argument_list>()</argument_list></call> )</expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>STDF32</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>dr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="doxygen">/**
     * copy 64 bits: (rd+dd) &lt;- (rs+ds)
     */</comment>
    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_mmq</name></name><parameter_list>(<param><decl><type><name>Register</name></type> <name>rd</name></decl></param>, <param><decl><type><name>int</name></type> <name>dd</name></decl></param>, <param><decl><type><name>Register</name></type> <name>rs</name></decl></param>, <param><decl><type><name>int</name></type> <name>ds</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// value is either a 64bit struct or maybe a float</comment>
        <comment type="line">// that isn't live in an FPU reg.  Either way, don't</comment>
        <comment type="line">// put it in an FPU reg just to load &amp; store it.</comment>
        <decl_stmt><decl><type><name>Register</name></type> <name>t</name> <init>= <expr><call><name>registerAllocTmp</name><argument_list>(<argument><expr><name>GpRegs</name> &amp; ~(<call><name>rmask</name><argument_list>(<argument><expr><name>rd</name></expr></argument>)</argument_list></call>|<call><name>rmask</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>dd</name>+4</expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LDSW32</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><name>ds</name>+4</expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>dd</name></expr></argument>, <argument><expr><name>rd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LDSW32</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><name>ds</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>NIns</name>*</type> <name><name>Assembler</name>::<name>asm_branch</name></name><parameter_list>(<param><decl><type><name>bool</name></type> <name>branchOnFalse</name></decl></param>, <param><decl><type><name>LInsp</name></type> <name>cond</name></decl></param>, <param><decl><type><name>NIns</name>*</type> <name>targ</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>NIns</name>*</type> <name>at</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>condop</name> <init>= <expr><call><name><name>cond</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name><name>cond</name>-&gt;<name>isCond</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>condop</name> &gt;= <name>LIR_feq</name> &amp;&amp; <name>condop</name> &lt;= <name>LIR_fge</name></expr>)</condition><then>
            <block>{
                <return>return <expr><call><name>asm_fbranch</name><argument_list>(<argument><expr><name>branchOnFalse</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name>targ</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>intptr_t</name></type> <name>tt</name> <init>= <expr>((<name>intptr_t</name>)<name>targ</name> - (<name>intptr_t</name>)<name>_nIns</name> + 8) &gt;&gt; 2</expr></init></decl>;</decl_stmt>
        <comment type="line">// !targ means that it needs patch.</comment>
        <if>if<condition>( <expr>!(<call><name>isIMM22</name><argument_list>(<argument><expr>(<name>int32_t</name>)<name>tt</name></expr></argument>)</argument_list></call>) || !<name>targ</name></expr> )</condition><then> <block>{
            <expr_stmt><expr><call><name>JMP_long_nocheck</name><argument_list>(<argument><expr>(<name>intptr_t</name>)<name>targ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>at</name> = <name>_nIns</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BA</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tt</name> = 4</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>NOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


        <comment type="line">// produce the branch</comment>
        <if>if <condition>(<expr><name>branchOnFalse</name></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><name>condop</name> == <name>LIR_eq</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BNE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_ov</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BVC</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_lt</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BGE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_le</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BG</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_gt</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BLE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_ge</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BL</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_ult</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BCC</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_ule</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BGU</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_ugt</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BLEU</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <comment type="line">//if (condop == LIR_uge)</comment>
                    <expr_stmt><expr><call><name>BCS</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
            }</block></then>
        <else>else <comment type="line">// op == LIR_xt</comment>
            <block>{
                <if>if <condition>(<expr><name>condop</name> == <name>LIR_eq</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_ov</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BVS</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_lt</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BL</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_le</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BLE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_gt</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BG</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_ge</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BGE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_ult</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BCS</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_ule</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BLEU</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_ugt</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>BGU</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <comment type="line">//if (condop == LIR_uge)</comment>
                    <expr_stmt><expr><call><name>BCC</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
            }</block></else></if>
        <expr_stmt><expr><call><name>asm_cmp</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>at</name></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_cmp</name></name><parameter_list>(<param><decl><type><name>LIns</name> *</type><name>cond</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>condop</name> <init>= <expr><call><name><name>cond</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// LIR_ov recycles the flags set by arithmetic ops</comment>
        <if>if <condition>(<expr><name>condop</name> == <name>LIR_ov</name></expr>)</condition><then>
            <return>return;</return></then></if>

        <decl_stmt><decl><type><name>LInsp</name></type> <name>lhs</name> <init>= <expr><call><name><name>cond</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LInsp</name></type> <name>rhs</name> <init>= <expr><call><name><name>cond</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr>(!<call><name><name>lhs</name>-&gt;<name>isQuad</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>rhs</name>-&gt;<name>isQuad</name></name><argument_list>()</argument_list></call>) || (<call><name><name>lhs</name>-&gt;<name>isQuad</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>rhs</name>-&gt;<name>isQuad</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr>!<call><name><name>lhs</name>-&gt;<name>isQuad</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>rhs</name>-&gt;<name>isQuad</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// ready to issue the compare</comment>
        <if>if <condition>(<expr><call><name><name>rhs</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>rhs</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Register</name></type> <name>r</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>c</name> == 0 &amp;&amp; <call><name><name>cond</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_eq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ANDCC</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>G0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><call><name>SUBCC</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>G0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then>
        <else>else
            <block>{
                <decl_stmt><decl><type><name>Register</name></type> <name>ra</name></decl>, <decl><type ref="prev"/><name>rb</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>findRegFor2</name><argument_list>(<argument><expr><name>GpRegs</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SUBCC</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>G0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_fcond</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// only want certain regs</comment>
        <decl_stmt><decl><type><name>Register</name></type> <name>r</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>AllowableFlagRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>condop</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>condop</name> &gt;= <name>LIR_feq</name> &amp;&amp; <name>condop</name> &lt;= <name>LIR_fge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>condop</name> == <name>LIR_feq</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVFEI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_fle</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVFLEI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_flt</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVFLI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_fge</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVFGEI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <comment type="line">// if (condop == LIR_fgt)</comment>
            <expr_stmt><expr><call><name>MOVFGI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if>
        <expr_stmt><expr><call><name>ORI</name><argument_list>(<argument><expr><name>G0</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>asm_fcmp</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_cond</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// only want certain regs</comment>
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>op</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>r</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>AllowableFlagRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>op</name> == <name>LIR_eq</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVEI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_ov</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVVSI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_lt</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVLI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_le</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVLEI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_gt</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVGI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_ge</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVGEI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_ult</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVEI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_ule</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVLEUI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_ugt</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>MOVGUI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <comment type="line">// if (op == LIR_uge)</comment>
            <expr_stmt><expr><call><name>MOVCCI</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
        <expr_stmt><expr><call><name>ORI</name><argument_list>(<argument><expr><name>G0</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>asm_cmp</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_arith</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>28</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>op</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LInsp</name></type> <name>lhs</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LInsp</name></type> <name>rhs</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Register</name></type> <name>rb</name> <init>= <expr><name>UnknownReg</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RegisterMask</name></type> <name>allow</name> <init>= <expr><name>GpRegs</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>forceReg</name> <init>= <expr>(<name>op</name> == <name>LIR_mul</name> || !<call><name><name>rhs</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call>)</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>lhs</name> != <name>rhs</name> &amp;&amp; <name>forceReg</name></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr>(<name>rb</name> = <call><name>asm_binop_rhs_reg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call>) == <name>UnknownReg</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rb</name> = <call><name>findRegFor</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>allow</name> &amp;= ~<call><name>rmask</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
        <else>else <if>if <condition>(<expr>(<name>op</name> == <name>LIR_add</name>||<name>op</name> == <name>LIR_iaddp</name>) &amp;&amp; <call><name><name>lhs</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_alloc</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>rhs</name>-&gt;<name>isconst</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// add alloc+const, use lea</comment>
            <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>findMemFor</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> + <call><name><name>rhs</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ADD</name><argument_list>(<argument><expr><name>FP</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>

        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// if this is last use of lhs in reg, we can re-use result reg</comment>
        <comment type="line">// else, lhs already has a register assigned.</comment>
        <decl_stmt><decl><type><name>Register</name></type> <name>ra</name> <init>= <expr>( <call><name><name>lhs</name>-&gt;<name>isUnusedOrHasUnknownReg</name></name><argument_list>()</argument_list></call>
                      ? <call><name>findSpecificRegFor</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call>
                      : <call><name><name>lhs</name>-&gt;<name>getReg</name></name><argument_list>()</argument_list></call> )</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>forceReg</name></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><name>lhs</name> == <name>rhs</name></expr>)</condition><then>
                    <expr_stmt><expr><name>rb</name> = <name>ra</name></expr>;</expr_stmt></then></if>

                <if>if <condition>(<expr><name>op</name> == <name>LIR_add</name> || <name>op</name> == <name>LIR_iaddp</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>ADDCC</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_sub</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>SUBCC</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_mul</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>MULX</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_and</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>AND</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_or</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>OR</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_xor</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>XOR</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_lsh</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>SLL</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_rsh</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>SRA</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_ush</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>SRL</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><call><name>NanoAssertMsg</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"Unsupported"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
            }</block></then>
        <else>else
            <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>rhs</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>op</name> == <name>LIR_add</name> || <name>op</name> == <name>LIR_iaddp</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ADDCC</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_sub</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>SUBCC</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_and</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>AND</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_or</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>OR</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_xor</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>XOR</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_lsh</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>SLL</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_rsh</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>SRA</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_ush</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>SRL</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><call><name>NanoAssertMsg</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"Unsupported"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
                <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

        <if>if <condition>( <expr><name>rr</name> != <name>ra</name></expr> )</condition><then>
            <expr_stmt><expr><call><name>ORI</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_neg_not</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>op</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>LIns</name>*</type> <name>lhs</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// if this is last use of lhs in reg, we can re-use result reg</comment>
        <comment type="line">// else, lhs already has a register assigned.</comment>
        <decl_stmt><decl><type><name>Register</name></type> <name>ra</name> <init>= <expr>( <call><name><name>lhs</name>-&gt;<name>isUnusedOrHasUnknownReg</name></name><argument_list>()</argument_list></call>
                      ? <call><name>findSpecificRegFor</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call>
                      : <call><name><name>lhs</name>-&gt;<name>getReg</name></name><argument_list>()</argument_list></call> )</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>op</name> == <name>LIR_not</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ORN</name><argument_list>(<argument><expr><name>G0</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>SUB</name><argument_list>(<argument><expr><name>G0</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

        <if>if <condition>( <expr><name>rr</name> != <name>ra</name></expr> )</condition><then>
            <expr_stmt><expr><call><name>ORI</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_load32</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>op</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>base</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>disp</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>ra</name> <init>= <expr><call><name>getBaseReg</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>(<expr><name>op</name></expr>)</condition> <block>{
            <case>case <expr><name>LIR_ldzb</name></expr>:
            </case><case>case <expr><name>LIR_ldcb</name></expr>:
                <expr_stmt><expr><call><name>LDUB32</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr><name>LIR_ldzs</name></expr>:
            </case><case>case <expr><name>LIR_ldcs</name></expr>:
                <expr_stmt><expr><call><name>LDUH32</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr><name>LIR_ld</name></expr>:
            </case><case>case <expr><name>LIR_ldc</name></expr>:
                <expr_stmt><expr><call><name>LDSW32</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr><name>LIR_ldsb</name></expr>:
            </case><case>case <expr><name>LIR_ldss</name></expr>:
            </case><case>case <expr><name>LIR_ldcsb</name></expr>:
            </case><case>case <expr><name>LIR_ldcss</name></expr>:
                <expr_stmt><expr><call><name>NanoAssertMsg</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"NJ_EXPANDED_LOADSTORE_SUPPORTED not yet supported for this architecture"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </case><default>default:
                <expr_stmt><expr><call><name>NanoAssertMsg</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"asm_load32 should never receive this LIR opcode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
        </default>}</block></switch>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_cmov</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>op</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>condval</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>iftrue</name>  <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>iffalse</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd3</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><call><name><name>condval</name>-&gt;<name>isCmp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>op</name> == <name>LIR_qcmov</name> || (!<call><name><name>iftrue</name>-&gt;<name>isQuad</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>iffalse</name>-&gt;<name>isQuad</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// this code assumes that neither LD nor MR nor MRcc set any of the condition flags.</comment>
        <comment type="line">// (This is true on Intel, is it true on all architectures?)</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>Register</name></type> <name>iffalsereg</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><name>iffalse</name></expr></argument>, <argument><expr><name>GpRegs</name> &amp; ~<call><name>rmask</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>op</name> == <name>LIR_cmov</name></expr>)</condition><then> <block>{
            <switch>switch <condition>(<expr><call><name><name>condval</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
                <comment type="line">// note that these are all opposites...</comment>
            <case>case <expr><name>LIR_eq</name></expr>:  <expr_stmt><expr><call><name>MOVNE</name> <argument_list>(<argument><expr><name>iffalsereg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            </case><case>case <expr><name>LIR_ov</name></expr>:  <expr_stmt><expr><call><name>MOVVC</name> <argument_list>(<argument><expr><name>iffalsereg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            </case><case>case <expr><name>LIR_lt</name></expr>:  <expr_stmt><expr><call><name>MOVGE</name> <argument_list>(<argument><expr><name>iffalsereg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            </case><case>case <expr><name>LIR_le</name></expr>:  <expr_stmt><expr><call><name>MOVG</name>  <argument_list>(<argument><expr><name>iffalsereg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            </case><case>case <expr><name>LIR_gt</name></expr>:  <expr_stmt><expr><call><name>MOVLE</name> <argument_list>(<argument><expr><name>iffalsereg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            </case><case>case <expr><name>LIR_ge</name></expr>:  <expr_stmt><expr><call><name>MOVL</name>  <argument_list>(<argument><expr><name>iffalsereg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            </case><case>case <expr><name>LIR_ult</name></expr>: <expr_stmt><expr><call><name>MOVCC</name> <argument_list>(<argument><expr><name>iffalsereg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            </case><case>case <expr><name>LIR_ule</name></expr>: <expr_stmt><expr><call><name>MOVGU</name> <argument_list>(<argument><expr><name>iffalsereg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            </case><case>case <expr><name>LIR_ugt</name></expr>: <expr_stmt><expr><call><name>MOVLEU</name><argument_list>(<argument><expr><name>iffalsereg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
            </case><case>case <expr><name>LIR_uge</name></expr>: <expr_stmt><expr><call><name>MOVCS</name> <argument_list>(<argument><expr><name>iffalsereg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                <macro><name>debug_only</name><argument_list>( <argument>default: NanoAssert(0); break;</argument> )</argument_list></macro>
                    </case>}</block></switch>
        }</block></then> <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_qcmov</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <comment type="block">/*const Register iftruereg =*/</comment> <expr_stmt><expr><call><name>findSpecificRegFor</name><argument_list>(<argument><expr><name>iftrue</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>asm_cmp</name><argument_list>(<argument><expr><name>condval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_qhi</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>q</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>findMemFor</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LDSW32</name><argument_list>(<argument><expr><name>FP</name></expr></argument>, <argument><expr><name>d</name>+4</expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_param</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>a</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>paramArg</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>kind</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>paramKind</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><call><name>rmask</name><argument_list>(<argument><expr><name><name>argRegs</name><index>[<expr><name>a</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_int</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>val</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>imm32</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>val</name> == 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>XOR</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_quad</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>64</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>getReg</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>rr</name> != <name>UnknownReg</name></expr>)</condition><then>
            <block>{
                <comment type="line">// @todo -- add special-cases for 0 and 1</comment>
                <expr_stmt><expr><call><name><name>_allocator</name>.<name>retire</name></name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>ins</name>-&gt;<name>setReg</name></name><argument_list>(<argument><expr><name>UnknownReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr>(<call><name>rmask</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call> &amp; <name>FpRegs</name>) != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>findMemFor</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>disp</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>LDDF32</name><argument_list>(<argument><expr><name>FP</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

        <comment type="line">// @todo, if we used xor, ldsd, fldz, etc above, we don't need mem here</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>disp</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>freeRsrcOf</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>d</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>L2</name></expr></argument>, <argument><expr><name>d</name>+4</expr></argument>, <argument><expr><name>FP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><call><name><name>ins</name>-&gt;<name>imm64_0</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>STW32</name><argument_list>(<argument><expr><name>L2</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>FP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SET32</name><argument_list>(<argument><expr><call><name><name>ins</name>-&gt;<name>imm64_1</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>L2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_qlo</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_fneg</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>FpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>lhs</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// lhs into reg, prefer same reg as result</comment>
        <comment type="line">// if this is last use of lhs in reg, we can re-use result reg</comment>
        <comment type="line">// else, lhs already has a different reg assigned</comment>
        <decl_stmt><decl><type><name>Register</name></type> <name>ra</name> <init>= <expr>( <call><name><name>lhs</name>-&gt;<name>isUnusedOrHasUnknownReg</name></name><argument_list>()</argument_list></call>
                      ? <call><name>findSpecificRegFor</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call>
                      : <call><name>findRegFor</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>FpRegs</name></expr></argument>)</argument_list></call> )</expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>FNEGD</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_fop</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>op</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>lhs</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>rhs</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>RegisterMask</name></type> <name>allow</name> <init>= <expr><name>FpRegs</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>ra</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>FpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rb</name> <init>= <expr>(<name>rhs</name> == <name>lhs</name>) ? <name>ra</name> : <call><name>findRegFor</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>FpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>allow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>op</name> == <name>LIR_fadd</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>FADDD</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_fsub</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>FSUBD</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>op</name> == <name>LIR_fmul</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>FMULD</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <comment type="line">//if (op == LIR_fdiv)</comment>
            <expr_stmt><expr><call><name>FDIVD</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if>

    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_i2f</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// where our result goes</comment>
        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>FpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>findMemFor</name><argument_list>(<argument><expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FITOD</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LDDF32</name><argument_list>(<argument><expr><name>FP</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_u2f</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>72</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// where our result goes</comment>
        <decl_stmt><decl><type><name>Register</name></type> <name>rr</name> <init>= <expr><call><name>prepResultReg</name><argument_list>(<argument><expr><name>ins</name></expr></argument>, <argument><expr><name>FpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rt</name> <init>= <expr><call><name>registerAllocTmp</name><argument_list>(<argument><expr><name>FpRegs</name> &amp; ~(<call><name>rmask</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>gr</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>GpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>disp</name> <init>= <expr>-8</expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>FABSS</name><argument_list>(<argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FSUBD</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LDDF32</name><argument_list>(<argument><expr><name>SP</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>STWI</name><argument_list>(<argument><expr><name>G0</name></expr></argument>, <argument><expr><name>disp</name>+4</expr></argument>, <argument><expr><name>SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LDDF32</name><argument_list>(<argument><expr><name>SP</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>, <argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>STWI</name><argument_list>(<argument><expr><name>gr</name></expr></argument>, <argument><expr><name>disp</name>+4</expr></argument>, <argument><expr><name>SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>STWI</name><argument_list>(<argument><expr><name>G1</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>, <argument><expr><name>SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SETHI</name><argument_list>(<argument><expr>0x43300000</expr></argument>, <argument><expr><name>G1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_nongp_copy</name></name><parameter_list>(<param><decl><type><name>Register</name></type> <name>r</name></decl></param>, <param><decl><type><name>Register</name></type> <name>s</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr>(<call><name>rmask</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> &amp; <name>FpRegs</name>) &amp;&amp; (<call><name>rmask</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> &amp; <name>FpRegs</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FMOVD</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>NIns</name> *</type> <name><name>Assembler</name>::<name>asm_fbranch</name></name><parameter_list>(<param><decl><type><name>bool</name></type> <name>branchOnFalse</name></decl></param>, <param><decl><type><name>LIns</name> *</type><name>cond</name></decl></param>, <param><decl><type><name>NIns</name> *</type><name>targ</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>NIns</name> *</type><name>at</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LOpcode</name></type> <name>condop</name> <init>= <expr><call><name><name>cond</name>-&gt;<name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr><name>condop</name> &gt;= <name>LIR_feq</name> &amp;&amp; <name>condop</name> &lt;= <name>LIR_fge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>intptr_t</name></type> <name>tt</name> <init>= <expr>((<name>intptr_t</name>)<name>targ</name> - (<name>intptr_t</name>)<name>_nIns</name> + 8) &gt;&gt; 2</expr></init></decl>;</decl_stmt>
        <comment type="line">// !targ means that it needs patch.</comment>
        <if>if<condition>( <expr>!(<call><name>isIMM22</name><argument_list>(<argument><expr>(<name>int32_t</name>)<name>tt</name></expr></argument>)</argument_list></call>) || !<name>targ</name></expr> )</condition><then> <block>{
            <expr_stmt><expr><call><name>JMP_long_nocheck</name><argument_list>(<argument><expr>(<name>intptr_t</name>)<name>targ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>at</name> = <name>_nIns</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>NOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BA</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tt</name> = 4</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>NOP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// produce the branch</comment>
        <if>if <condition>(<expr><name>branchOnFalse</name></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><name>condop</name> == <name>LIR_feq</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>FBNE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_fle</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>FBUG</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_flt</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>FBUGE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_fge</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>FBUL</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <comment type="line">//if (condop == LIR_fgt)</comment>
                    <expr_stmt><expr><call><name>FBULE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if>
            }</block></then>
        <else>else <comment type="line">// op == LIR_xt</comment>
            <block>{
                <if>if <condition>(<expr><name>condop</name> == <name>LIR_feq</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>FBE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_fle</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>FBLE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_flt</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>FBL</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><name>condop</name> == <name>LIR_fge</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>FBGE</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <comment type="line">//if (condop == LIR_fgt)</comment>
                    <expr_stmt><expr><call><name>FBG</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if></else></if>
            }</block></else></if>
        <expr_stmt><expr><call><name>asm_fcmp</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>at</name></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_fcmp</name></name><parameter_list>(<param><decl><type><name>LIns</name> *</type><name>cond</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>underrunProtect</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>lhs</name> <init>= <expr><call><name><name>cond</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>LIns</name>*</type> <name>rhs</name> <init>= <expr><call><name><name>cond</name>-&gt;<name>oprnd2</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Register</name></type> <name>rLhs</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>FpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Register</name></type> <name>rRhs</name> <init>= <expr><call><name>findRegFor</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>FpRegs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>FCMPD</name><argument_list>(<argument><expr><name>rLhs</name></expr></argument>, <argument><expr><name>rRhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>nativePageReset</name></name><parameter_list>()</parameter_list>
    <block>{
    }</block></function>

    <function><type><name>Register</name></type> <name><name>Assembler</name>::<name>asm_binop_rhs_reg</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><name>UnknownReg</name></expr>;</return>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>nativePageSetup</name></name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>NanoAssert</name><argument_list>(<argument><expr>!<name>_inExit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>_nIns</name></expr>)</condition><then>
            <macro><name>codeAlloc</name><argument_list>(<argument>codeStart</argument>, <argument>codeEnd</argument>, <argument>_nIns verbose_only(, codeBytes)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></then></if>
        <if>if <condition>(<expr>!<name>_nExitIns</name></expr>)</condition><then>
            <macro><name>codeAlloc</name><argument_list>(<argument>exitStart</argument>, <argument>exitEnd</argument>, <argument>_nExitIns verbose_only(, exitBytes)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></then></if>
    }</block></function>

    <comment type="line">// Increment the 32-bit profiling counter at pCtr, without</comment>
    <comment type="line">// changing any registers.</comment>
    <macro><name>verbose_only</name><argument_list>(
    <argument>void Assembler::asm_inc_m32(uint32_t*)
    {
        <comment type="line">// todo: implement this</comment>
    }</argument>
    )</argument_list></macro>

    <function><type><name>void</name></type>
    <name><name>Assembler</name>::<name>underrunProtect</name></name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>NIns</name> *</type><name>eip</name> <init>= <expr><name>_nIns</name></expr></init></decl>;</decl_stmt>
        <comment type="line">// This may be in a normal code chunk or an exit code chunk.</comment>
        <if>if <condition>(<expr><name>eip</name> - <name>n</name> &lt; <name>codeStart</name></expr>)</condition><then> <block>{
            <macro><name>codeAlloc</name><argument_list>(<argument>codeStart</argument>, <argument>codeEnd</argument>, <argument>_nIns verbose_only(, codeBytes)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            <expr_stmt><expr><call><name>JMP_long_nocheck</name><argument_list>(<argument><expr>(<name>intptr_t</name>)<name>eip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_ret</name></name><parameter_list>(<param><decl><type><name>LInsp</name></type> <name>ins</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>genEpilogue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assignSavedRegs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>LIns</name> *</type><name>val</name> <init>= <expr><call><name><name>ins</name>-&gt;<name>oprnd1</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>ins</name>-&gt;<name>isop</name></name><argument_list>(<argument><expr><name>LIR_ret</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>findSpecificRegFor</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>retRegs</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>findSpecificRegFor</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>F0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>asm_promote</name></name><parameter_list>(<param><decl><type><name>LIns</name> *</type></decl></param>)</parameter_list> <block>{
        <comment type="line">// i2q or u2q</comment>
        <expr_stmt><expr><call><name>TODO</name><argument_list>(<argument><expr><name>asm_promote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name><name>Assembler</name>::<name>swapCodeChunks</name></name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>NIns</name>*</expr></argument>, <argument><expr><name>_nIns</name></expr></argument>, <argument><expr><name>_nExitIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>NIns</name>*</expr></argument>, <argument><expr><name>codeStart</name></expr></argument>, <argument><expr><name>exitStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>NIns</name>*</expr></argument>, <argument><expr><name>codeEnd</name></expr></argument>, <argument><expr><name>exitEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>verbose_only</name><argument_list>( <argument>SWAP(size_t, codeBytes, exitBytes);</argument> )</argument_list></macro>
    }</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FEATURE_NANOJIT */</comment>
}</block></namespace>
</unit>
