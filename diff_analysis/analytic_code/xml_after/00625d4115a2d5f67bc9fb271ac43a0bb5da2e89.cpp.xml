<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="00625d4115a2d5f67bc9fb271ac43a0bb5da2e89.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * JS boolean implementation.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstdint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsvector.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterpinlines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobjinlines.h"</cpp:file></cpp:include>

<using>using namespace <name>js</name>;</using>

<decl_stmt><decl><type><name>Class</name></type> <name>js_BooleanClass</name> <init>= <expr><block>{
    <expr>"Boolean"</expr>,
    <expr><call><name>JSCLASS_HAS_RESERVED_SLOTS</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call> |
    <call><name>JSCLASS_HAS_CACHED_PROTO</name><argument_list>(<argument><expr><name>JSProto_Boolean</name></expr></argument>)</argument_list></call></expr>,
    <expr><name>PropertyStub</name></expr>,   <comment type="block">/* addProperty */</comment>
    <expr><name>PropertyStub</name></expr>,   <comment type="block">/* delProperty */</comment>
    <expr><name>PropertyStub</name></expr>,   <comment type="block">/* getProperty */</comment>
    <expr><name>PropertyStub</name></expr>,   <comment type="block">/* setProperty */</comment>
    <expr><name>EnumerateStub</name></expr>,
    <expr><name>ResolveStub</name></expr>,
    <expr><name>ConvertStub</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_TOSOURCE</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprf.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>bool_toSource</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bool</name></type> <name>b</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>GetPrimitiveThis</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>sizeof <name>buf</name></expr></argument>, <argument><expr>"(new Boolean(%s))"</expr></argument>, <argument><expr><call><name>JS_BOOLEAN_STR</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name>JS_NewStringCopyZ</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>true</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>bool_toString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bool</name></type> <name>b</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>GetPrimitiveThis</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>booleanAtoms</name><index>[<expr><name>b</name> ? 1 : 0</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name> <init>= <expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setString</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>bool_valueOf</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bool</name></type> <name>b</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<call><name>GetPrimitiveThis</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>false</expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setBoolean</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSFunctionSpec</name></type> <name><name>boolean_methods</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_TOSOURCE</name></expr></cpp:if>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_toSource_str</name></expr></argument>,  <argument><expr><name>bool_toSource</name></expr></argument>,  <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_toString_str</name></expr></argument>,  <argument><expr><name>bool_toString</name></expr></argument>,  <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_valueOf_str</name></expr></argument>,   <argument><expr><name>bool_valueOf</name></expr></argument>,   <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>JS_FN</name><argument_list>(<argument><expr><name>js_toJSON_str</name></expr></argument>,    <argument><expr><name>bool_valueOf</name></expr></argument>,   <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>,
    <expr><name>JS_FS_END</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>Boolean</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>argc</name></decl></param>, <param><decl><type><name>Value</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>Value</name> *</type><name>argv</name> <init>= <expr><name>vp</name> + 2</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>b</name> <init>= <expr><name>argc</name> != 0 ? <call><name>js_ValueToBoolean</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> : false</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>IsConstructing</name><argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><call><name>NewBuiltinClassInstance</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>js_BooleanClass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <expr_stmt><expr><call><name><name>obj</name>-&gt;<name>setPrimitiveThis</name></name><argument_list>(<argument><expr><call><name>BooleanValue</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setObject</name></name><argument_list>(<argument><expr>*<name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name><name>vp</name>-&gt;<name>setBoolean</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>JSObject</name> *</type>
<name>js_InitBooleanClass</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>proto</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>proto</name> = <call><name>js_InitClass</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>js_BooleanClass</name></expr></argument>, <argument><expr><name>Boolean</name></expr></argument>, <argument><expr>1</expr></argument>,
                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>boolean_methods</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>proto</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name><name>proto</name>-&gt;<name>setPrimitiveThis</name></name><argument_list>(<argument><expr><call><name>BooleanValue</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>proto</name></expr>;</return>
}</block></function>

<function><type><name>JSString</name> *</type>
<name>js_BooleanToString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>b</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>booleanAtoms</name><index>[<expr><name>b</name> ? 1 : 0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* This function implements E-262-3 section 9.8, toString. */</comment>
<function><type><name>JSBool</name></type>
<name>js_BooleanToCharBuffer</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>b</name></decl></param>, <param><decl><type><name>JSCharBuffer</name> &amp;</type><name>cb</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name>b</name> ? <call><name>js_AppendLiteral</name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call> : <call><name>js_AppendLiteral</name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr>"false"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_ValueToBoolean</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Value</name> &amp;</type><name>v</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isInt32</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name><name>v</name>.<name>toInt32</name></name><argument_list>()</argument_list></call> != 0</expr>;</return></then></if>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isString</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name><name>v</name>.<name>toString</name></name><argument_list>()</argument_list></call>-&gt;<call><name>length</name><argument_list>()</argument_list></call> != 0</expr>;</return></then></if>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isObject</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isNullOrUndefined</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name><name>v</name>.<name>isDouble</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>d</name> = <call><name><name>v</name>.<name>toDouble</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>!<call><name>JSDOUBLE_IS_NaN</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> &amp;&amp; <name>d</name> != 0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>v</name>.<name>isBoolean</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>v</name>.<name>toBoolean</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
</unit>
