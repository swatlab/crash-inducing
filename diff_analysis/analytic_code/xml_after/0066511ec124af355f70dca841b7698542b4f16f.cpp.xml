<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0066511ec124af355f70dca841b7698542b4f16f.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * JS Mark-and-Sweep Garbage Collector.
 *
 * This GC allocates fixed-sized things with sizes up to GC_NBYTES_MAX (see
 * jsgc.h). It allocates from a special GC arena pool with each arena allocated
 * using malloc. It uses an ideally parallel array of flag bytes to hold the
 * mark bit, finalizer type index, etc.
 *
 * XXX swizzle page to freelist for better locality of reference
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>     <comment type="block">/* for free */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>     <comment type="block">/* for memset used when DEBUG */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstdint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jshash.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsclist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdbgapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsexn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsfun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsiter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscript.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstaticcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstracer.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsxml.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INCLUDE_MOZILLA_DTRACE</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdtracef.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Check if posix_memalign is available.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_POSIX_C_SOURCE</name> &gt;= 200112L || <name>_XOPEN_SOURCE</name> &gt;= 600 || <name>MOZ_MEMORY</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_POSIX_MEMALIGN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_POSIX_MEMALIGN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * jemalloc provides posix_memalign.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_MEMORY</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../memory/jemalloc/jemalloc.h"</cpp:file></cpp:include>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Include the headers for mmap unless we have posix_memalign and do not
 * insist on mmap.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_GC_USE_MMAP</name> || (!<name>defined</name> <name>JS_GC_USE_MMAP</name> &amp;&amp; !<name>HAS_POSIX_MEMALIGN</name>)</expr></cpp:if>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_WIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>JS_GC_USE_MMAP</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GC_USE_MMAP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__SYMBIAN32__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="line">// Symbian's OpenC has mmap (and #defines _POSIX_MAPPED_FILES), but</comment>
<comment type="line">// doesn't implement MAP_ANON.  If we have MOZ_MEMORY, then we can use</comment>
<comment type="line">// posix_memalign; we've defined HAS_POSIX_MEMALIGN above.  Otherwise,</comment>
<comment type="line">// we overallocate.</comment>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_UNIX</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>XP_BEOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>_POSIX_MAPPED_FILES</name> &gt; 0</expr></cpp:if>
<cpp:ifndef>#   <cpp:directive>ifndef</cpp:directive> <name>JS_GC_USE_MMAP</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GC_USE_MMAP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#   <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>

<comment type="block">/* On Mac OS X MAP_ANONYMOUS is not defined. */</comment>
<cpp:if>#   <cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_ANONYMOUS</name></cpp:macro> <cpp:value>MAP_ANON</cpp:value></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#   <cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MAP_ANONYMOUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_ANONYMOUS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#   <cpp:directive>if</cpp:directive> <expr><name>JS_GC_USE_MMAP</name></expr></cpp:if>
<cpp:error>#    <cpp:directive>error</cpp:directive> "JS_GC_USE_MMAP is set when mmap is not available"</cpp:error>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Check JSTempValueUnion has the size of jsval and void * so we can
 * reinterpret jsval as void* GC-thing pointer and use JSTVU_SINGLE for
 * different GC-things.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSTempValueUnion</name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSTempValueUnion</name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * Check that JSTRACE_XML follows JSTRACE_OBJECT, JSTRACE_DOUBLE and
 * JSTRACE_STRING.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>JSTRACE_OBJECT</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>JSTRACE_DOUBLE</name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>JSTRACE_STRING</name> == 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>JSTRACE_XML</name>    == 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * JS_IS_VALID_TRACE_KIND assumes that JSTRACE_STRING is the last non-xml
 * trace kind when JS_HAS_XML_SUPPORT is false.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>JSTRACE_STRING</name> + 1 == <name>JSTRACE_XML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * The number of used GCX-types must stay within GCX_LIMIT.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>GCX_NTYPES</name> &lt;= <name>GCX_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * Check that we can reinterpret double as JSGCDoubleCell.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSGCDoubleCell</name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Check that we can use memset(p, 0, ...) to implement JS_CLEAR_WEAK_ROOTS.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>JSVAL_NULL</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * A GC arena contains a fixed number of flag bits for each thing in its heap,
 * and supports O(1) lookup of a flag given its thing's address.
 *
 * To implement this, we allocate things of the same size from a GC arena
 * containing GC_ARENA_SIZE bytes aligned on GC_ARENA_SIZE boundary. The
 * following picture shows arena's layout:
 *
 *  +------------------------------+--------------------+---------------+
 *  | allocation area for GC thing | flags of GC things | JSGCArenaInfo |
 *  +------------------------------+--------------------+---------------+
 *
 * To find the flag bits for the thing we calculate the thing index counting
 * from arena's start using:
 *
 *   thingIndex = (thingAddress &amp; GC_ARENA_MASK) / thingSize
 *
 * The details of flag's lookup depend on thing's kind. For all GC things
 * except doubles we use one byte of flags where the 4 bits determine thing's
 * type and the rest is used to implement GC marking, finalization and
 * locking. We calculate the address of flag's byte using:
 *
 *   flagByteAddress =
 *       (thingAddress | GC_ARENA_MASK) - sizeof(JSGCArenaInfo) - thingIndex
 *
 * where
 *
 *   (thingAddress | GC_ARENA_MASK) - sizeof(JSGCArenaInfo)
 *
 * is the last byte of flags' area.
 *
 * This implies that the things are allocated from the start of their area and
 * flags are allocated from the end. This arrangement avoids a relatively
 * expensive calculation of the location of the boundary separating things and
 * flags. The boundary's offset from the start of the arena is given by:
 *
 *   thingsPerArena * thingSize
 *
 * where thingsPerArena is the number of things that the arena can hold:
 *
 *   (GC_ARENA_SIZE - sizeof(JSGCArenaInfo)) / (thingSize + 1).
 *
 * To allocate doubles we use a specialized arena. It can contain only numbers
 * so we do not need the type bits. Moreover, since the doubles do not require
 * a finalizer and very few of them are locked via js_LockGCThing API, we use
 * just one bit of flags per double to denote if it was marked during the
 * marking phase of the GC. The locking is implemented via a hash table. Thus
 * for doubles the flag area becomes a bitmap.
 *
 * JS_GC_USE_MMAP macro governs the choice of the aligned arena allocator.
 * When it is true, a platform-dependent function like mmap is used to get
 * memory aligned on CPU page boundaries. If the macro is false or undefined,
 * posix_memalign is used when available. Otherwise the code uses malloc to
 * over-allocate a chunk with js_gcArenasPerChunk aligned arenas. The
 * approximate space overhead of this is 1/js_gcArenasPerChunk. For details,
 * see NewGCChunk/DestroyGCChunk below.
 *
 * The code also allocates arenas in chunks when JS_GC_USE_MMAP is 1 to
 * minimize the overhead of mmap/munmap. In this case js_gcArenasPerChunk can
 * not be a compile-time constant as the system page size is not known until
 * runtime.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_GC_USE_MMAP</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>js_gcArenasPerChunk</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>JSBool</name></type> <name>js_gcUseMmap</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAS_POSIX_MEMALIGN</name></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>js_gcArenasPerChunk</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>js_gcArenasPerChunk</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>js_gcArenasPerChunk</name></expr></argument>)</argument_list></call> &amp;&amp; <name>js_gcArenasPerChunk</name> == 1</expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNKED_ARENA_ALLOCATION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNKED_ARENA_ALLOCATION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_ARENA_SHIFT</name></cpp:macro>              <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_ARENA_MASK</name></cpp:macro>               <cpp:value>((jsuword) JS_BITMASK(GC_ARENA_SHIFT))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_ARENA_SIZE</name></cpp:macro>               <cpp:value>JS_BIT(GC_ARENA_SHIFT)</cpp:value></cpp:define>

<comment type="block">/*
 * JS_GC_ARENA_PAD defines the number of bytes to pad JSGCArenaInfo structure.
 * It is used to improve allocation efficiency when using posix_memalign. If
 * malloc's implementation uses internal headers, then calling
 *
 *   posix_memalign(&amp;p, GC_ARENA_SIZE, GC_ARENA_SIZE * js_gcArenasPerChunk)
 *
 * in a sequence leaves holes between allocations of the size GC_ARENA_SIZE
 * due to the need to fit headers. JS_GC_ARENA_PAD mitigates that so the code
 * calls
 *
 *     posix_memalign(&amp;p, GC_ARENA_SIZE,
 *                    GC_ARENA_SIZE * js_gcArenasPerChunk - JS_GC_ARENA_PAD)
 *
 * When JS_GC_ARENA_PAD is equal or greater than the number of words in the
 * system header, the system can pack all allocations together without holes.
 *
 * With JS_GC_USE_MEMALIGN we want at least 2 word pad unless posix_memalign
 * comes from jemalloc that does not use any headers/trailers.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JS_GC_ARENA_PAD</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>HAS_POSIX_MEMALIGN</name> &amp;&amp; !<name>MOZ_MEMORY</name></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GC_ARENA_PAD</name></cpp:macro> <cpp:value>(2 * JS_BYTES_PER_WORD)</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GC_ARENA_PAD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>JSGCArenaInfo</name> <block>{<public type="default">
    <comment type="block">/*
     * Allocation list for the arena or NULL if the arena holds double values.
     */</comment>
    <decl_stmt><decl><type><name>JSGCArenaList</name>   *</type><name>list</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Pointer to the previous arena in a linked list. The arena can either
     * belong to one of JSContext.gcArenaList lists or, when it does not have
     * any allocated GC things, to the list of free arenas in the chunk with
     * head stored in JSGCChunkInfo.lastFreeArena.
     */</comment>
    <decl_stmt><decl><type><name>JSGCArenaInfo</name>   *</type><name>prev</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>CHUNKED_ARENA_ALLOCATION</name></expr></cpp:if>
    <decl_stmt><decl><type><name>jsuword</name></type>         <name>prevUntracedPage</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/*
     * A link field for the list of arenas with marked but not yet traced
     * things. The field is encoded as arena's page to share the space with
     * firstArena and arenaIndex fields.
     */</comment>
    <macro><name>jsuword</name></macro>         <label><name>prevUntracedPage</name> :</label>  <macro><name>JS_BITS_PER_WORD</name></macro> <expr_stmt><expr>- <name>GC_ARENA_SHIFT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * When firstArena is false, the index of arena in the chunk. When
     * firstArena is true, the index of a free arena holding JSGCChunkInfo or
     * NO_FREE_ARENAS if there are no free arenas in the chunk.
     *
     * GET_ARENA_INDEX and GET_CHUNK_INFO_INDEX are convenience macros to
     * access either of indexes.
     */</comment>
    <macro><name>jsuword</name></macro>         <label><name>arenaIndex</name> :</label>        <macro><name>GC_ARENA_SHIFT</name></macro> <expr_stmt><expr>- 1</expr>;</expr_stmt>

    <comment type="block">/* Flag indicating if the arena is the first in the chunk. */</comment>
    <macro><name>jsuword</name></macro>         <label><name>firstArena</name> :</label>        <expr_stmt><expr>1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <union>union <block>{<public type="default">
        <decl_stmt><decl><type><name>jsuword</name></type>     <name>untracedThings</name></decl>;</decl_stmt>     <comment type="block">/* bitset for fast search of marked
                                           but not yet traced things */</comment>
        <decl_stmt><decl><type><name>JSBool</name></type>      <name>hasMarkedDoubles</name></decl>;</decl_stmt>   <comment type="block">/* the arena has marked doubles */</comment>
    </public>}</block> <decl><name>u</name></decl>;</union>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_GC_ARENA_PAD</name> != 0</expr></cpp:if>
    <decl_stmt><decl><type><name>uint8</name></type>           <name><name>pad</name><index>[<expr><name>JS_GC_ARENA_PAD</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</public>}</block>;</struct>

<comment type="block">/*
 * Verify that the bit fields are indeed shared and JSGCArenaInfo is as small
 * as possible. The code does not rely on this check so if on a particular
 * platform this does not compile, then, as a workaround, comment the assert
 * out and submit a bug report.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>JSGCArenaInfo</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call> == 3 * <sizeof>sizeof<argument_list>(<argument><expr><name>jsuword</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Macros to convert between JSGCArenaInfo, the start address of the arena and
 * arena's page defined as (start address) &gt;&gt; GC_ARENA_SHIFT.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARENA_INFO_OFFSET</name></cpp:macro> <cpp:value>(GC_ARENA_SIZE - (uint32) sizeof(JSGCArenaInfo))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ARENA_INFO_ADDRESS</name><parameter_list>(<param><type><name>arena</name></type></param>)</parameter_list></cpp:macro>                                          \
    <cpp:value>(((jsuword) (arena) &amp; GC_ARENA_MASK) == ARENA_INFO_OFFSET)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARENA_START_TO_INFO</name><parameter_list>(<param><type><name>arenaStart</name></type></param>)</parameter_list></cpp:macro>                                       \
    <cpp:value>(JS_ASSERT(((arenaStart) &amp; (jsuword) GC_ARENA_MASK) == 0),                \
     (JSGCArenaInfo *) ((arenaStart) + (jsuword) ARENA_INFO_OFFSET))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARENA_INFO_TO_START</name><parameter_list>(<param><type><name>arena</name></type></param>)</parameter_list></cpp:macro>                                            \
    <cpp:value>(JS_ASSERT(IS_ARENA_INFO_ADDRESS(arena)),                                 \
     (jsuword) (arena) &amp; ~(jsuword) GC_ARENA_MASK)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARENA_PAGE_TO_INFO</name><parameter_list>(<param><type><name>arenaPage</name></type></param>)</parameter_list></cpp:macro>                                         \
    <cpp:value>(JS_ASSERT(arenaPage != 0),                                               \
     JS_ASSERT(!((jsuword)(arenaPage) &gt;&gt; (JS_BITS_PER_WORD-GC_ARENA_SHIFT))), \
     ARENA_START_TO_INFO((arenaPage) &lt;&lt; GC_ARENA_SHIFT))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARENA_INFO_TO_PAGE</name><parameter_list>(<param><type><name>arena</name></type></param>)</parameter_list></cpp:macro>                                             \
    <cpp:value>(JS_ASSERT(IS_ARENA_INFO_ADDRESS(arena)),                                 \
     ((jsuword) (arena) &gt;&gt; GC_ARENA_SHIFT))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ARENA_INFO</name><parameter_list>(<param><type><name>chunk</name></type></param>, <param><type><name>index</name></type></param>)</parameter_list></cpp:macro>                                          \
    <cpp:value>(JS_ASSERT((index) &lt; js_gcArenasPerChunk),                                \
     ARENA_START_TO_INFO(chunk + ((index) &lt;&lt; GC_ARENA_SHIFT)))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CHUNKED_ARENA_ALLOCATION</name></expr></cpp:if>
<comment type="block">/*
 * Definitions for allocating arenas in chunks.
 *
 * All chunks that have at least one free arena are put on the doubly-linked
 * list with the head stored in JSRuntime.gcChunkList. JSGCChunkInfo contains
 * the head of the chunk's free arena list together with the link fields for
 * gcChunkList.
 *
 * Structure stored in one of chunk's free arenas. GET_CHUNK_INFO_INDEX gives
 * the index of this arena. When all arenas in the chunk are used, it is
 * removed from the list and the index is set to NO_FREE_ARENAS indicating
 * that the chunk is not on gcChunkList and has no JSGCChunkInfo available.
 */</comment>

<struct>struct <name>JSGCChunkInfo</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSGCChunkInfo</name>   **</type><name>prevp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCChunkInfo</name>   *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaInfo</name>   *</type><name>lastFreeArena</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>numFreeArenas</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_FREE_ARENAS</name></cpp:macro>              <cpp:value>JS_BITMASK(GC_ARENA_SHIFT - 1)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>js_gcArenasPerChunk</name></cpp:ifdef>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr>1 &lt;= <name>js_gcArenasPerChunk</name> &amp;&amp;
                 <name>js_gcArenasPerChunk</name> &lt;= <name>NO_FREE_ARENAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ARENA_CHUNK</name><parameter_list>(<param><type><name>arena</name></type></param>, <param><type><name>index</name></type></param>)</parameter_list></cpp:macro>                                         \
    <cpp:value>(JS_ASSERT(GET_ARENA_INDEX(arena) == index),                              \
     ARENA_INFO_TO_START(arena) - ((index) &lt;&lt; GC_ARENA_SHIFT))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ARENA_INDEX</name><parameter_list>(<param><type><name>arena</name></type></param>)</parameter_list></cpp:macro>                                                \
    <cpp:value>((arena)-&gt;firstArena ? 0 : (uint32) (arena)-&gt;arenaIndex)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_CHUNK_INFO_INDEX</name><parameter_list>(<param><type><name>chunk</name></type></param>)</parameter_list></cpp:macro>                                           \
    <cpp:value>((uint32) ARENA_START_TO_INFO(chunk)-&gt;arenaIndex)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_CHUNK_INFO_INDEX</name><parameter_list>(<param><type><name>chunk</name></type></param>, <param><type><name>index</name></type></param>)</parameter_list></cpp:macro>                                    \
    <cpp:value>(JS_ASSERT((index) &lt; js_gcArenasPerChunk || (index) == NO_FREE_ARENAS),   \
     (void) (ARENA_START_TO_INFO(chunk)-&gt;arenaIndex = (jsuword) (index)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_CHUNK_INFO</name><parameter_list>(<param><type><name>chunk</name></type></param>, <param><type><name>infoIndex</name></type></param>)</parameter_list></cpp:macro>                                      \
    <cpp:value>(JS_ASSERT(GET_CHUNK_INFO_INDEX(chunk) == (infoIndex)),                   \
     JS_ASSERT((uint32) (infoIndex) &lt; js_gcArenasPerChunk),                   \
     (JSGCChunkInfo *) ((chunk) + ((infoIndex) &lt;&lt; GC_ARENA_SHIFT)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_INFO_TO_INDEX</name><parameter_list>(<param><type><name>ci</name></type></param>)</parameter_list></cpp:macro>                                               \
    <cpp:value>GET_ARENA_INDEX(ARENA_START_TO_INFO((jsuword)ci))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Macros for GC-thing operations.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THINGS_PER_ARENA</name><parameter_list>(<param><type><name>thingSize</name></type></param>)</parameter_list></cpp:macro>                                           \
    <cpp:value>((GC_ARENA_SIZE - (uint32) sizeof(JSGCArenaInfo)) / ((thingSize) + 1U))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THING_TO_ARENA</name><parameter_list>(<param><type><name>thing</name></type></param>)</parameter_list></cpp:macro>                                                 \
    <cpp:value>((JSGCArenaInfo *)(((jsuword) (thing) | GC_ARENA_MASK) +                  \
                       1 - sizeof(JSGCArenaInfo)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THING_TO_INDEX</name><parameter_list>(<param><type><name>thing</name></type></param>, <param><type><name>thingSize</name></type></param>)</parameter_list></cpp:macro>                                      \
    <cpp:value>((uint32) ((jsuword) (thing) &amp; GC_ARENA_MASK) / (uint32) (thingSize))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THING_FLAGS_END</name><parameter_list>(<param><type><name>arena</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((uint8 *)(arena))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THING_FLAGP</name><parameter_list>(<param><type><name>arena</name></type></param>, <param><type><name>thingIndex</name></type></param>)</parameter_list></cpp:macro>                                        \
    <cpp:value>(JS_ASSERT((jsuword) (thingIndex)                                         \
               &lt; (jsuword) THINGS_PER_ARENA((arena)-&gt;list-&gt;thingSize)),       \
     (uint8 *)(arena) - 1 - (thingIndex))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THING_TO_FLAGP</name><parameter_list>(<param><type><name>thing</name></type></param>, <param><type><name>thingSize</name></type></param>)</parameter_list></cpp:macro>                                      \
    <cpp:value>THING_FLAGP(THING_TO_ARENA(thing), THING_TO_INDEX(thing, thingSize))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGP_TO_ARENA</name><parameter_list>(<param><type><name>flagp</name></type></param>)</parameter_list></cpp:macro> <cpp:value>THING_TO_ARENA(flagp)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGP_TO_INDEX</name><parameter_list>(<param><type><name>flagp</name></type></param>)</parameter_list></cpp:macro>                                                 \
    <cpp:value>(JS_ASSERT(((jsuword) (flagp) &amp; GC_ARENA_MASK) &lt; ARENA_INFO_OFFSET),      \
     (ARENA_INFO_OFFSET - 1 - (uint32) ((jsuword) (flagp) &amp; GC_ARENA_MASK)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGP_TO_THING</name><parameter_list>(<param><type><name>flagp</name></type></param>, <param><type><name>thingSize</name></type></param>)</parameter_list></cpp:macro>                                      \
    <cpp:value>(JS_ASSERT(((jsuword) (flagp) &amp; GC_ARENA_MASK) &gt;=                         \
               (ARENA_INFO_OFFSET - THINGS_PER_ARENA(thingSize))),            \
     (JSGCThing *)(((jsuword) (flagp) &amp; ~GC_ARENA_MASK) +                     \
                   (thingSize) * FLAGP_TO_INDEX(flagp)))</cpp:value></cpp:define>

<comment type="block">/*
 * Macros for the specialized arena for doubles.
 *
 * DOUBLES_PER_ARENA defines the maximum number of doubles that the arena can
 * hold. We find it as the following. Let n be the number of doubles in the
 * arena. Together with the bitmap of flags and JSGCArenaInfo they should fit
 * the arena. Hence DOUBLES_PER_ARENA or n_max is the maximum value of n for
 * which the following holds:
 *
 *   n*s + ceil(n/B) &lt;= M                                               (1)
 *
 * where "/" denotes normal real division,
 *       ceil(r) gives the least integer not smaller than the number r,
 *       s is the number of words in jsdouble,
 *       B is number of bits per word or B == JS_BITS_PER_WORD
 *       M is the number of words in the arena before JSGCArenaInfo or
 *       M == (GC_ARENA_SIZE - sizeof(JSGCArenaInfo)) / sizeof(jsuword).
 *       M == ARENA_INFO_OFFSET / sizeof(jsuword)
 *
 * We rewrite the inequality as
 *
 *   n*B*s/B + ceil(n/B) &lt;= M,
 *   ceil(n*B*s/B + n/B) &lt;= M,
 *   ceil(n*(B*s + 1)/B) &lt;= M                                           (2)
 *
 * We define a helper function e(n, s, B),
 *
 *   e(n, s, B) := ceil(n*(B*s + 1)/B) - n*(B*s + 1)/B, 0 &lt;= e(n, s, B) &lt; 1.
 *
 * It gives:
 *
 *   n*(B*s + 1)/B + e(n, s, B) &lt;= M,
 *   n + e*B/(B*s + 1) &lt;= M*B/(B*s + 1)
 *
 * We apply the floor function to both sides of the last equation, where
 * floor(r) gives the biggest integer not greater than r. As a consequence we
 * have:
 *
 *   floor(n + e*B/(B*s + 1)) &lt;= floor(M*B/(B*s + 1)),
 *   n + floor(e*B/(B*s + 1)) &lt;= floor(M*B/(B*s + 1)),
 *   n &lt;= floor(M*B/(B*s + 1)),                                         (3)
 *
 * where floor(e*B/(B*s + 1)) is zero as e*B/(B*s + 1) &lt; B/(B*s + 1) &lt; 1.
 * Thus any n that satisfies the original constraint (1) or its equivalent (2),
 * must also satisfy (3). That is, we got an upper estimate for the maximum
 * value of n. Lets show that this upper estimate,
 *
 *   floor(M*B/(B*s + 1)),                                              (4)
 *
 * also satisfies (1) and, as such, gives the required maximum value.
 * Substituting it into (2) gives:
 *
 *   ceil(floor(M*B/(B*s + 1))*(B*s + 1)/B) == ceil(floor(M/X)*X)
 *
 * where X == (B*s + 1)/B &gt; 1. But then floor(M/X)*X &lt;= M/X*X == M and
 *
 *   ceil(floor(M/X)*X) &lt;= ceil(M) == M.
 *
 * Thus the value of (4) gives the maximum n satisfying (1).
 *
 * For the final result we observe that in (4)
 *
 *    M*B == ARENA_INFO_OFFSET / sizeof(jsuword) * JS_BITS_PER_WORD
 *        == ARENA_INFO_OFFSET * JS_BITS_PER_BYTE
 *
 *  and
 *
 *    B*s == JS_BITS_PER_WORD * sizeof(jsdouble) / sizeof(jsuword)
 *        == JS_BITS_PER_DOUBLE.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLES_PER_ARENA</name></cpp:macro>                                                     \
    <cpp:value>((ARENA_INFO_OFFSET * JS_BITS_PER_BYTE) / (JS_BITS_PER_DOUBLE + 1))</cpp:value></cpp:define>

<comment type="block">/*
 * Check that  ARENA_INFO_OFFSET and sizeof(jsdouble) divides sizeof(jsuword).
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ARENA_INFO_OFFSET</name> % <sizeof>sizeof<argument_list>(<argument><expr><name>jsuword</name></expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsdouble</name></expr></argument>)</argument_list></sizeof> % <sizeof>sizeof<argument_list>(<argument><expr><name>jsuword</name></expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsbitmap</name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>jsuword</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLES_ARENA_BITMAP_WORDS</name></cpp:macro>                                            \
    <cpp:value>(JS_HOWMANY(DOUBLES_PER_ARENA, JS_BITS_PER_WORD))</cpp:value></cpp:define>

<comment type="block">/* Check that DOUBLES_PER_ARENA indeed maximises (1). */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>DOUBLES_PER_ARENA</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsdouble</name></expr></argument>)</argument_list></sizeof> +
                 <name>DOUBLES_ARENA_BITMAP_WORDS</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsuword</name></expr></argument>)</argument_list></sizeof> &lt;=
                 <name>ARENA_INFO_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr>(<name>DOUBLES_PER_ARENA</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>jsdouble</name></expr></argument>)</argument_list></sizeof> +
                 <sizeof>sizeof<argument_list>(<argument><expr><name>jsuword</name></expr></argument>)</argument_list></sizeof> *
                 <call><name>JS_HOWMANY</name><argument_list>(<argument><expr>(<name>DOUBLES_PER_ARENA</name> + 1)</expr></argument>, <argument><expr><name>JS_BITS_PER_WORD</name></expr></argument>)</argument_list></call> &gt;
                 <name>ARENA_INFO_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * When DOUBLES_PER_ARENA % BITS_PER_DOUBLE_FLAG_UNIT != 0, some bits in the
 * last byte of the occupation bitmap are unused.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED_DOUBLE_BITMAP_BITS</name></cpp:macro>                                             \
    <cpp:value>(DOUBLES_ARENA_BITMAP_WORDS * JS_BITS_PER_WORD - DOUBLES_PER_ARENA)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>UNUSED_DOUBLE_BITMAP_BITS</name> &lt; <name>JS_BITS_PER_WORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLES_ARENA_BITMAP_OFFSET</name></cpp:macro>                                           \
    <cpp:value>(ARENA_INFO_OFFSET - DOUBLES_ARENA_BITMAP_WORDS * sizeof(jsuword))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_DOUBLE_ARENA_INFO</name><parameter_list>(<param><type><name>arenaInfo</name></type></param>)</parameter_list></cpp:macro>                                    \
    <cpp:value>(JS_ASSERT(IS_ARENA_INFO_ADDRESS(arenaInfo)),                             \
     JS_ASSERT(!(arenaInfo)-&gt;list))</cpp:value></cpp:define>                                           \

<comment type="block">/*
 * Get the start of the bitmap area containing double mark flags in the arena.
 * To access the flag the code uses
 *
 *   JS_TEST_BIT(bitmapStart, index)
 *
 * That is, compared with the case of arenas with non-double things, we count
 * flags from the start of the bitmap area, not from the end.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLE_ARENA_BITMAP</name><parameter_list>(<param><type><name>arenaInfo</name></type></param>)</parameter_list></cpp:macro>                                        \
    <cpp:value>(CHECK_DOUBLE_ARENA_INFO(arenaInfo),                                      \
     (jsbitmap *) arenaInfo - DOUBLES_ARENA_BITMAP_WORDS)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLE_THING_TO_INDEX</name><parameter_list>(<param><type><name>thing</name></type></param>)</parameter_list></cpp:macro>                                          \
    <cpp:value>(CHECK_DOUBLE_ARENA_INFO(THING_TO_ARENA(thing)),                          \
     JS_ASSERT(((jsuword) (thing) &amp; GC_ARENA_MASK) &lt;                          \
               DOUBLES_ARENA_BITMAP_OFFSET),                                  \
     ((uint32) (((jsuword) (thing) &amp; GC_ARENA_MASK) / sizeof(jsdouble))))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ClearDoubleArenaFlags</name><parameter_list>(<param><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsbitmap</name> *</type><name>bitmap</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>nused</name></decl>;</decl_stmt>

    <comment type="block">/*
     * When some high bits in the last byte of the double occupation bitmap
     * are unused, we must set them. Otherwise RefillDoubleFreeList will
     * assume that they corresponds to some free cells and tries to allocate
     * them.
     *
     * Note that the code works correctly with UNUSED_DOUBLE_BITMAP_BITS == 0.
     */</comment>
    <expr_stmt><expr><name>bitmap</name> = <call><name>DOUBLE_ARENA_BITMAP</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bitmap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>DOUBLES_ARENA_BITMAP_WORDS</name> - 1) * sizeof *<name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> = ((<name>jsbitmap</name>) 1 &lt;&lt; <name>UNUSED_DOUBLE_BITMAP_BITS</name>) - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>nused</name> = <name>JS_BITS_PER_WORD</name> - <name>UNUSED_DOUBLE_BITMAP_BITS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bitmap</name><index>[<expr><name>DOUBLES_ARENA_BITMAP_WORDS</name> - 1</expr>]</index></name> = <name>mask</name> &lt;&lt; <name>nused</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_ALWAYS_INLINE</name> <name>JSBool</name></type>
<name>IsMarkedDouble</name><parameter_list>(<param><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsbitmap</name> *</type><name>bitmap</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>u</name>.<name>hasMarkedDoubles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bitmap</name> = <call><name>DOUBLE_ARENA_BITMAP</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>JS_TEST_BIT</name><argument_list>(<argument><expr><name>bitmap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * JSRuntime.gcDoubleArenaList.nextDoubleFlags points either to:
 *
 *   1. The next byte in the bitmap area for doubles to check for unmarked
 *      (or free) doubles.
 *   2. Or to the end of the bitmap area when all GC cells of the arena are
 *      allocated.
 *   3. Or to a special sentinel value indicating that there are no arenas
 *      to check for unmarked doubles.
 *
 * We set the sentinel to ARENA_INFO_OFFSET so the single check
 *
 *   ((jsuword) nextDoubleFlags &amp; GC_ARENA_MASK) == ARENA_INFO_OFFSET
 *
 * will cover both the second and the third cases.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLE_BITMAP_SENTINEL</name></cpp:macro>  <cpp:value>((jsbitmap *) ARENA_INFO_OFFSET)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
<comment type="block">/*
 * The maximum number of things to put on the local free list by taking
 * several things from the global free list or from the tail of the last
 * allocated arena to amortize the cost of rt-&gt;gcLock.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_THREAD_LOCAL_THINGS</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSStackHeader</name></expr></argument>)</argument_list></sizeof> &gt;= 2 * <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSGCThing</name></expr></argument>)</argument_list></sizeof> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>JSString</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSGCThing</name></expr></argument>)</argument_list></sizeof> &gt;= <sizeof>sizeof<argument_list>(<argument><expr><name>jsdouble</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* We want to use all the available GC thing space for object's slots. */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSObject</name></expr></argument>)</argument_list></sizeof> % <sizeof>sizeof<argument_list>(<argument><expr><name>JSGCThing</name></expr></argument>)</argument_list></sizeof> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Ensure that JSObject is allocated from a different GC-list rather than
 * jsdouble and JSString so we can easily finalize JSObject before these 2
 * types of GC things. See comments in js_GC.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>GC_FREELIST_INDEX</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSString</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> !=
                 <call><name>GC_FREELIST_INDEX</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>GC_FREELIST_INDEX</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jsdouble</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> !=
                 <call><name>GC_FREELIST_INDEX</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * JSPtrTable capacity growth descriptor. The table grows by powers of two
 * starting from capacity JSPtrTableInfo.minCapacity, but switching to linear
 * growth when capacity reaches JSPtrTableInfo.linearGrowthThreshold.
 */</comment>
<typedef>typedef <type><struct>struct <name>JSPtrTableInfo</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>uint16</name></type>      <name>minCapacity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>      <name>linearGrowthThreshold</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>JSPtrTableInfo</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_ITERATOR_TABLE_MIN</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_ITERATOR_TABLE_LINEAR</name></cpp:macro>  <cpp:value>1024</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>JSPtrTableInfo</name></type> <name>iteratorTableInfo</name> <init>= <expr><block>{
    <expr><name>GC_ITERATOR_TABLE_MIN</name></expr>,
    <expr><name>GC_ITERATOR_TABLE_LINEAR</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Calculate table capacity based on the current value of JSPtrTable.count. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>PtrTableCapacity</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>count</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>JSPtrTableInfo</name> *</type><name>info</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>linear</name></decl>, <decl><type ref="prev"/><name>log</name></decl>, <decl><type ref="prev"/><name>capacity</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>linear</name> = <name><name>info</name>-&gt;<name>linearGrowthThreshold</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>minCapacity</name></name> &lt;= <name>linear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>capacity</name> = 0</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>count</name> &lt; <name>linear</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>log</name> = <call><name>JS_CEILING_LOG2W</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>log</name> != <name>JS_BITS_PER_WORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>capacity</name> = (<name>size_t</name>)1 &lt;&lt; <name>log</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>capacity</name> &lt; <name><name>info</name>-&gt;<name>minCapacity</name></name></expr>)</condition><then>
            <expr_stmt><expr><name>capacity</name> = <name><name>info</name>-&gt;<name>minCapacity</name></name></expr>;</expr_stmt></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>capacity</name> = <call><name>JS_ROUNDUP</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>linear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>capacity</name> &gt;= <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>capacity</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePtrTable</name><parameter_list>(<param><decl><type><name>JSPtrTable</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>JSPtrTableInfo</name> *</type><name>info</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>table</name>-&gt;<name>array</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>count</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>table</name>-&gt;<name>array</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>table</name>-&gt;<name>count</name></name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>count</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>AddToPtrTable</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSPtrTable</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>JSPtrTableInfo</name> *</type><name>info</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>capacity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> **</type><name>array</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>count</name> = <name><name>table</name>-&gt;<name>count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>capacity</name> = <call><name>PtrTableCapacity</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>count</name> == <name>capacity</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>capacity</name> &lt; <name><name>info</name>-&gt;<name>minCapacity</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>capacity</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>table</name>-&gt;<name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>capacity</name> = <name><name>info</name>-&gt;<name>minCapacity</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * Simplify the overflow detection assuming pointer is bigger
             * than byte.
             */</comment>
            <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr>2 &lt;= sizeof <name><name>table</name>-&gt;<name>array</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>capacity</name> = (<name>capacity</name> &lt; <name><name>info</name>-&gt;<name>linearGrowthThreshold</name></name>)
                       ? 2 * <name>capacity</name>
                       : <name>capacity</name> + <name><name>info</name>-&gt;<name>linearGrowthThreshold</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>capacity</name> &gt; (<name>size_t</name>)-1 / sizeof <name><name>table</name>-&gt;<name>array</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
                <goto>goto <name>bad</name>;</goto></then></if>
        }</block></else></if>
        <expr_stmt><expr><name>array</name> = (<name>void</name> **) <call><name>js_realloc</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>array</name></name></expr></argument>,
                                     <argument><expr><name>capacity</name> * sizeof <name><name>table</name>-&gt;<name>array</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>array</name></expr>)</condition><then>
            <goto>goto <name>bad</name>;</goto></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>array</name> + <name>count</name></expr></argument>, <argument><expr><name>JS_FREE_PATTERN</name></expr></argument>,
               <argument><expr>(<name>capacity</name> - <name>count</name>) * sizeof <name><name>table</name>-&gt;<name>array</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>table</name>-&gt;<name>array</name></name> = <name>array</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>table</name>-&gt;<name>array</name><index>[<expr><name>count</name></expr>]</index></name> = <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>table</name>-&gt;<name>count</name></name> = <name>count</name> + 1</expr>;</expr_stmt>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>

  <label><name>bad</name>:</label>
    <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShrinkPtrTable</name><parameter_list>(<param><decl><type><name>JSPtrTable</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>JSPtrTableInfo</name> *</type><name>info</name></decl></param>,
               <param><decl><type><name>size_t</name></type> <name>newCount</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>oldCapacity</name></decl>, <decl><type ref="prev"/><name>capacity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> **</type><name>array</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>newCount</name> &lt;= <name><name>table</name>-&gt;<name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>newCount</name> == <name><name>table</name>-&gt;<name>count</name></name></expr>)</condition><then>
        <return>return;</return></then></if>

    <expr_stmt><expr><name>oldCapacity</name> = <call><name>PtrTableCapacity</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>count</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>table</name>-&gt;<name>count</name></name> = <name>newCount</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>capacity</name> = <call><name>PtrTableCapacity</name><argument_list>(<argument><expr><name>newCount</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>oldCapacity</name> != <name>capacity</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>array</name> = <name><name>table</name>-&gt;<name>array</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>capacity</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>table</name>-&gt;<name>array</name></name> = <name>NULL</name></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name>array</name> = (<name>void</name> **) <call><name>js_realloc</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>capacity</name> * sizeof <name><name>array</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>array</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>table</name>-&gt;<name>array</name></name> = <name>array</name></expr>;</expr_stmt></then></if>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>array</name></name> + <name>newCount</name></expr></argument>, <argument><expr><name>JS_FREE_PATTERN</name></expr></argument>,
           <argument><expr>(<name>capacity</name> - <name>newCount</name>) * sizeof <name><name>table</name>-&gt;<name>array</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GCMETER</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>METER</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>               <cpp:value>((void) (x))</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>METER_IF</name><parameter_list>(<param><type><name>condition</name></type></param>, <param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void) ((condition) &amp;&amp; (x)))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>METER</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>               <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>METER_IF</name><parameter_list>(<param><type><name>condition</name></type></param>, <param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METER_UPDATE_MAX</name><parameter_list>(<param><type><name>maxLval</name></type></param>, <param><type><name>rval</name></type></param>)</parameter_list></cpp:macro>                                       \
    <cpp:value>METER_IF((maxLval) &lt; (rval), (maxLval) = (rval))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_GC_USE_MMAP</name> || !<name>HAS_POSIX_MEMALIGN</name></expr></cpp:if>

<comment type="block">/*
 * For chunks allocated via over-sized malloc, get a pointer to store the gap
 * between the malloc's result and the first arena in the chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name> *</type>
<name>GetMallocedChunkGapPtr</name><parameter_list>(<param><decl><type><name>jsuword</name></type> <name>chunk</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>chunk</name> &amp; <name>GC_ARENA_MASK</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Use the memory after the chunk, see NewGCChunk for details. */</comment>
    <return>return <expr>(<name>uint32</name> *) (<name>chunk</name> + (<name>js_gcArenasPerChunk</name> &lt;&lt; <name>GC_ARENA_SHIFT</name>))</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>jsuword</name></type>
<name>NewGCChunk</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_GC_USE_MMAP</name></expr></cpp:if>
    <if>if <condition>(<expr><name>js_gcUseMmap</name></expr>)</condition><then> <block>{
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_WIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><name>p</name> = <call><name>VirtualAlloc</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>js_gcArenasPerChunk</name> &lt;&lt; <name>GC_ARENA_SHIFT</name></expr></argument>,
                         <argument><expr><name>MEM_COMMIT</name> | <name>MEM_RESERVE</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>jsuword</name>) <name>p</name></expr>;</return>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>p</name> = <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>js_gcArenasPerChunk</name> &lt;&lt; <name>GC_ARENA_SHIFT</name></expr></argument>,
                 <argument><expr><name>PROT_READ</name> | <name>PROT_WRITE</name></expr></argument>, <argument><expr><name>MAP_PRIVATE</name> | <name>MAP_ANONYMOUS</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>p</name> == <name>MAP_FAILED</name>) ? 0 : (<name>jsuword</name>) <name>p</name></expr>;</return>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAS_POSIX_MEMALIGN</name></expr></cpp:if>
    <if>if <condition>(<expr>0 != <call><name>posix_memalign</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>GC_ARENA_SIZE</name></expr></argument>,
                            <argument><expr><name>GC_ARENA_SIZE</name> * <name>js_gcArenasPerChunk</name> -
                            <name>JS_GC_ARENA_PAD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <return>return <expr>(<name>jsuword</name>) <name>p</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/*
     * Implement chunk allocation using oversized malloc if mmap and
     * posix_memalign are not available.
     *
     * Since malloc allocates pointers aligned on the word boundary, to get
     * js_gcArenasPerChunk aligned arenas, we need to malloc only
     *
     *   ((js_gcArenasPerChunk + 1) &lt;&lt; GC_ARENA_SHIFT) - sizeof(size_t)
     *
     * bytes. But since we stores the gap between the malloced pointer and the
     * first arena in the chunk after the chunk, we need to ask for
     *
     *   ((js_gcArenasPerChunk + 1) &lt;&lt; GC_ARENA_SHIFT)
     *
     * bytes to ensure that we always have room to store the gap.
     */</comment>
    <expr_stmt><expr><name>p</name> = <call><name>js_malloc</name><argument_list>(<argument><expr>(<name>js_gcArenasPerChunk</name> + 1) &lt;&lt; <name>GC_ARENA_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>p</name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <block>{
        <decl_stmt><decl><type><name>jsuword</name></type> <name>chunk</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>chunk</name> = ((<name>jsuword</name>) <name>p</name> + <name>GC_ARENA_MASK</name>) &amp; ~<name>GC_ARENA_MASK</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<call><name>GetMallocedChunkGapPtr</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> = <call>(<name>uint32</name>) <argument_list>(<argument><expr><name>chunk</name> - (<name>jsuword</name>) <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>chunk</name></expr>;</return>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DestroyGCChunk</name><parameter_list>(<param><decl><type><name>jsuword</name></type> <name>chunk</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>chunk</name> &amp; <name>GC_ARENA_MASK</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_GC_USE_MMAP</name></expr></cpp:if>
    <if>if <condition>(<expr><name>js_gcUseMmap</name></expr>)</condition><then> <block>{
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_WIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><call><name>VirtualFree</name><argument_list>(<argument><expr>(<name>void</name> *) <name>chunk</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>MEM_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SOLARIS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
        <expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr>(<name>char</name> *) <name>chunk</name></expr></argument>, <argument><expr><name>js_gcArenasPerChunk</name> &lt;&lt; <name>GC_ARENA_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr>(<name>void</name> *) <name>chunk</name></expr></argument>, <argument><expr><name>js_gcArenasPerChunk</name> &lt;&lt; <name>GC_ARENA_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAS_POSIX_MEMALIGN</name></expr></cpp:if>
    <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr>(<name>void</name> *) <name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* See comments in NewGCChunk. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<call><name>GetMallocedChunkGapPtr</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> &lt; <name>GC_ARENA_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_free</name><argument_list>(<argument><expr>(<name>void</name> *) (<name>chunk</name> - *<call><name>GetMallocedChunkGapPtr</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CHUNKED_ARENA_ALLOCATION</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddChunkToList</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSGCChunkInfo</name> *</type><name>ci</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>prevp</name></name> = &amp;<name><name>rt</name>-&gt;<name>gcChunkList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name>-&gt;<name>next</name></name> = <name><name>rt</name>-&gt;<name>gcChunkList</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcChunkList</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcChunkList</name>-&gt;<name>prevp</name></name> == &amp;<name><name>rt</name>-&gt;<name>gcChunkList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcChunkList</name>-&gt;<name>prevp</name></name> = &amp;<name><name>ci</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcChunkList</name></name> = <name>ci</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveChunkFromList</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSGCChunkInfo</name> *</type><name>ci</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name><name>ci</name>-&gt;<name>prevp</name></name> = <name><name>ci</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>ci</name>-&gt;<name>next</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>next</name>-&gt;<name>prevp</name></name> == &amp;<name><name>ci</name>-&gt;<name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ci</name>-&gt;<name>next</name>-&gt;<name>prevp</name></name> = <name><name>ci</name>-&gt;<name>prevp</name></name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>JSGCArenaInfo</name> *</type>
<name>NewGCArena</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsuword</name></type> <name>chunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcBytes</name></name> &gt;= <name><name>rt</name>-&gt;<name>gcMaxBytes</name></name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CHUNKED_ARENA_ALLOCATION</name></expr></cpp:if>
    <if>if <condition>(<expr><name>js_gcArenasPerChunk</name> == 1</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>chunk</name> = <call><name>NewGCChunk</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>chunk</name> == 0</expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>a</name> = <call><name>ARENA_START_TO_INFO</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CHUNKED_ARENA_ALLOCATION</name></expr></cpp:if>
    }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>JSGCChunkInfo</name> *</type><name>ci</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>aprev</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>ci</name> = <name><name>rt</name>-&gt;<name>gcChunkList</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ci</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>chunk</name> = <call><name>NewGCChunk</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>chunk</name> == 0</expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>chunk</name> &amp; <name>GC_ARENA_MASK</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>a</name> = <call><name>GET_ARENA_INFO</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>firstArena</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>arenaIndex</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>aprev</name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
            <do>do <block>{
                <expr_stmt><expr><name><name>a</name>-&gt;<name>prev</name></name> = <name>aprev</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>aprev</name> = <name>a</name></expr>;</expr_stmt>
                <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>a</name> = <call><name>GET_ARENA_INFO</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>a</name>-&gt;<name>firstArena</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>a</name>-&gt;<name>arenaIndex</name></name> = <name>i</name></expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>i</name> != <name>js_gcArenasPerChunk</name> - 1</expr>)</condition>;</do>
            <expr_stmt><expr><name>ci</name> = <call><name>GET_CHUNK_INFO</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ci</name>-&gt;<name>lastFreeArena</name></name> = <name>aprev</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ci</name>-&gt;<name>numFreeArenas</name></name> = <name>js_gcArenasPerChunk</name> - 1</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>AddChunkToList</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>prevp</name></name> == &amp;<name><name>rt</name>-&gt;<name>gcChunkList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>a</name> = <name><name>ci</name>-&gt;<name>lastFreeArena</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>aprev</name> = <name><name>a</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>aprev</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>numFreeArenas</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>ARENA_INFO_TO_START</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> == (<name>jsuword</name>) <name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>RemoveChunkFromList</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>chunk</name> = <call><name>GET_ARENA_CHUNK</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>GET_ARENA_INDEX</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SET_CHUNK_INFO_INDEX</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>NO_FREE_ARENAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>numFreeArenas</name></name> &gt;= 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>ARENA_INFO_TO_START</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> != (<name>jsuword</name>) <name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ci</name>-&gt;<name>lastFreeArena</name></name> = <name>aprev</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ci</name>-&gt;<name>numFreeArenas</name></name>--</expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcBytes</name></name> += <name>GC_ARENA_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>prevUntracedPage</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>a</name>-&gt;<name>u</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>a</name>-&gt;<name>u</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>a</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DestroyGCArenas</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSGCArenaInfo</name> *</type><name>last</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>last</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>a</name> = <name>last</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>last</name> = <name><name>last</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>afree</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcBytes</name></name> &gt;= <name>GC_ARENA_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcBytes</name></name> -= <name>GC_ARENA_SIZE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CHUNKED_ARENA_ALLOCATION</name></expr></cpp:if>
        <if>if <condition>(<expr><name>js_gcArenasPerChunk</name> == 1</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>DestroyGCChunk</name><argument_list>(<argument><expr><call><name>ARENA_INFO_TO_START</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CHUNKED_ARENA_ALLOCATION</name></expr></cpp:if>
        }</block></then> <else>else <block>{
            <decl_stmt><decl><type><name>uint32</name></type> <name>arenaIndex</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>jsuword</name></type> <name>chunk</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32</name></type> <name>chunkInfoIndex</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JSGCChunkInfo</name> *</type><name>ci</name></decl>;</decl_stmt>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <decl_stmt><decl><type><name>jsuword</name></type> <name>firstArena</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>firstArena</name> = <name><name>a</name>-&gt;<name>firstArena</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>arenaIndex</name> = <name><name>a</name>-&gt;<name>arenaIndex</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>void</name> *) <call><name>ARENA_INFO_TO_START</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>JS_FREE_PATTERN</name></expr></argument>,
                   <argument><expr><name>GC_ARENA_SIZE</name> - <name>JS_GC_ARENA_PAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>firstArena</name></name> = <name>firstArena</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>arenaIndex</name></name> = <name>arenaIndex</name></expr>;</expr_stmt>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>arenaIndex</name> = <call><name>GET_ARENA_INDEX</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>chunk</name> = <call><name>GET_ARENA_CHUNK</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>arenaIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>chunkInfoIndex</name> = <call><name>GET_CHUNK_INFO_INDEX</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>chunkInfoIndex</name> == <name>NO_FREE_ARENAS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>chunkInfoIndex</name> = <name>arenaIndex</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SET_CHUNK_INFO_INDEX</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>arenaIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ci</name> = <call><name>GET_CHUNK_INFO</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>chunkInfoIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>a</name>-&gt;<name>prev</name></name> = <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ci</name>-&gt;<name>lastFreeArena</name></name> = <name>a</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ci</name>-&gt;<name>numFreeArenas</name></name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>AddChunkToList</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>chunkInfoIndex</name> != <name>arenaIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ci</name> = <call><name>GET_CHUNK_INFO</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><name>chunkInfoIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>numFreeArenas</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>lastFreeArena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>a</name> != <name><name>ci</name>-&gt;<name>lastFreeArena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>ci</name>-&gt;<name>numFreeArenas</name></name> == <name>js_gcArenasPerChunk</name> - 1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>RemoveChunkFromList</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DestroyGCChunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr>++<name><name>ci</name>-&gt;<name>numFreeArenas</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>a</name>-&gt;<name>prev</name></name> = <name><name>ci</name>-&gt;<name>lastFreeArena</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ci</name>-&gt;<name>lastFreeArena</name></name> = <name>a</name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if>
        }</block></else></if>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitGCArenaLists</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>thingSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaList</name> *</type><name>arenaList</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>GC_NUM_FREELISTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>arenaList</name> = &amp;<name><name>rt</name>-&gt;<name>gcArenaList</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>thingSize</name> = <call><name>GC_FREELIST_NBYTES</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>last</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name> = <call><name>THINGS_PER_ARENA</name><argument_list>(<argument><expr><name>thingSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>thingSize</name></name> = <name>thingSize</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>freeList</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>nextDoubleFlags</name></name> = <name>DOUBLE_BITMAP_SENTINEL</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishGCArenaLists</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaList</name> *</type><name>arenaList</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>GC_NUM_FREELISTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>arenaList</name> = &amp;<name><name>rt</name>-&gt;<name>gcArenaList</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>DestroyGCArenas</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name><name>arenaList</name>-&gt;<name>last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>last</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name> = <call><name>THINGS_PER_ARENA</name><argument_list>(<argument><expr><name><name>arenaList</name>-&gt;<name>thingSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>freeList</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>DestroyGCArenas</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>nextDoubleFlags</name></name> = <name>DOUBLE_BITMAP_SENTINEL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcBytes</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcChunkList</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * This function must not be called when thing is jsdouble.
 */</comment>
<function><type><specifier>static</specifier> <name>uint8</name> *</type>
<name>GetGCThingFlags</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>thing</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>a</name> = <call><name>THING_TO_ARENA</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>index</name> = <call><name>THING_TO_INDEX</name><argument_list>(<argument><expr><name>thing</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>list</name>-&gt;<name>thingSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>THING_FLAGP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function returns null when thing is jsdouble.
 */</comment>
<function><type><specifier>static</specifier> <name>uint8</name> *</type>
<name>GetGCThingFlagsOrNull</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>thing</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>a</name> = <call><name>THING_TO_ARENA</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>list</name></name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>index</name> = <call><name>THING_TO_INDEX</name><argument_list>(<argument><expr><name>thing</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>list</name>-&gt;<name>thingSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>THING_FLAGP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>intN</name></type>
<name>js_GetExternalStringGCType</name><parameter_list>(<param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>type</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>type</name> = (<name>uintN</name>) *<call><name>GetGCThingFlags</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> &amp; <name>GCF_TYPEMASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> == <name>GCX_STRING</name> || <name>type</name> &gt;= <name>GCX_EXTERNAL_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>type</name> == <name>GCX_STRING</name>) ? -1 : <call>(<name>intN</name>) <argument_list>(<argument><expr><name>type</name> - <name>GCX_EXTERNAL_STRING</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>MapGCFlagsToTraceKind</name><parameter_list>(<param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type> <name>type</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>type</name> = <name>flags</name> &amp; <name>GCF_TYPEMASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> != <name>GCX_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> &lt; <name>GCX_NTYPES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>type</name> &lt; <name>GCX_EXTERNAL_STRING</name>) ? <name>type</name> : <name>JSTRACE_STRING</name></expr>;</return>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>uint32</argument>)</argument_list></macro>
<macro><name>js_GetGCThingTraceKind</name><argument_list>(<argument>void *thing</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>a</name> = <call><name>THING_TO_ARENA</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>list</name></name></expr>)</condition><then>
        <return>return <expr><name>JSTRACE_DOUBLE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>index</name> = <call><name>THING_TO_INDEX</name><argument_list>(<argument><expr><name>thing</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>list</name>-&gt;<name>thingSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>MapGCFlagsToTraceKind</name><argument_list>(<argument><expr>*<call><name>THING_FLAGP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<function><type><name>JSRuntime</name>*</type>
<name>js_GetGCStringRuntime</name><parameter_list>(<param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSGCArenaList</name> *</type><name>list</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>list</name> = <call><name>THING_TO_ARENA</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call>-&gt;<name>list</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>list</name>-&gt;<name>thingSize</name></name> == <sizeof>sizeof<argument_list>(<argument><expr><name>JSGCThing</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>GC_FREELIST_INDEX</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSGCThing</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr>(<name>JSRuntime</name> *)((<name>uint8</name> *)<name>list</name> - <call><name>offsetof</name><argument_list>(<argument><expr><name>JSRuntime</name></expr></argument>, <argument><expr><name>gcArenaList</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_IsAboutToBeFinalized</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>void</name> *</type><name>thing</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>index</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>a</name> = <call><name>THING_TO_ARENA</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>list</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Check if arena has no marked doubles. In that case the bitmap with
         * the mark flags contains all garbage as it is initialized only when
         * marking the first double in the arena.
         */</comment>
        <if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>u</name>.<name>hasMarkedDoubles</name></name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>index</name> = <call><name>DOUBLE_THING_TO_INDEX</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>!<call><name>IsMarkedDouble</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>index</name> = <call><name>THING_TO_INDEX</name><argument_list>(<argument><expr><name>thing</name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>list</name>-&gt;<name>thingSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> = *<call><name>THING_FLAGP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>!(<name>flags</name> &amp; (<name>GCF_MARK</name> | <name>GCF_LOCK</name> | <name>GCF_FINAL</name>))</expr>;</return>
}</block></function>

<comment type="block">/* This is compatible with JSDHashEntryStub. */</comment>
<typedef>typedef <type><struct>struct <name>JSGCRootHashEntry</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type> <name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>            *</type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>      *</type><name>name</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>JSGCRootHashEntry</name>;</typedef>

<comment type="block">/* Initial size of the gcRootsHash table (SWAG, small enough to amortize). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_ROOTS_SIZE</name></cpp:macro>   <cpp:value>256</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CHUNKED_ARENA_ALLOCATION</name></expr></cpp:if>

<comment type="block">/*
 * For a CPU with extremely large pages using them for GC things wastes
 * too much memory.
 */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GC_ARENAS_PER_CPU_PAGE_LIMIT</name></cpp:macro> <cpp:value>JS_BIT(18 - GC_ARENA_SHIFT)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>GC_ARENAS_PER_CPU_PAGE_LIMIT</name> &lt;= <name>NO_FREE_ARENAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>JSBool</name></type>
<name>js_InitGC</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>maxbytes</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_GC_USE_MMAP</name></expr></cpp:if>
    <if>if <condition>(<expr><name>js_gcArenasPerChunk</name> == 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>cpuPageSize</name></decl>, <decl><type ref="prev"/><name>arenasPerPage</name></decl>;</decl_stmt>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_WIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <decl_stmt><decl><type><name>SYSTEM_INFO</name></type> <name>si</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>GetSystemInfo</name><argument_list>(<argument><expr>&amp;<name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cpuPageSize</name> = <name><name>si</name>.<name>dwPageSize</name></name></expr>;</expr_stmt>

<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_UNIX</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>XP_BEOS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
        <expr_stmt><expr><name>cpuPageSize</name> = (<name>size_t</name>) <call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_PAGESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#  <cpp:directive>error</cpp:directive> "Not implemented"</cpp:error>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* cpuPageSize is a power of 2. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>cpuPageSize</name> &amp; (<name>cpuPageSize</name> - 1)) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>arenasPerPage</name> = <name>cpuPageSize</name> &gt;&gt; <name>GC_ARENA_SHIFT</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <if>if <condition>(<expr><name>arenasPerPage</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr>"JS engine warning: the size of the CPU page, %u bytes, is too low to use\n"
"paged allocation for the garbage collector. Please report this.\n"</expr></argument>,
                    <argument><expr>(<name>unsigned</name>) <name>cpuPageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr><name>arenasPerPage</name> - 1 &lt;= <call>(<name>size_t</name>) <argument_list>(<argument><expr><name>GC_ARENAS_PER_CPU_PAGE_LIMIT</name> - 1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Use at least 4 GC arenas per paged allocation chunk to minimize
             * the overhead of mmap/VirtualAlloc.
             */</comment>
            <expr_stmt><expr><name>js_gcUseMmap</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>js_gcArenasPerChunk</name> = <call><name>JS_MAX</name><argument_list>(<argument><expr>(<name>uint32</name>) <name>arenasPerPage</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>js_gcUseMmap</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>js_gcArenasPerChunk</name> = 7</expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>1 &lt;= <name>js_gcArenasPerChunk</name> &amp;&amp;
              <name>js_gcArenasPerChunk</name> &lt;= <name>NO_FREE_ARENAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>InitGCArenaLists</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>JS_DHashTableInit</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcRootsHash</name></name></expr></argument>, <argument><expr><call><name>JS_DHashGetStubOps</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSGCRootHashEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>GC_ROOTS_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcRootsHash</name>.<name>ops</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcLocksHash</name></name> = <name>NULL</name></expr>;</expr_stmt>     <comment type="block">/* create lazily */</comment>

    <comment type="block">/*
     * Separate gcMaxMallocBytes from gcMaxBytes but initialize to maxbytes
     * for default backward API compatibility.
     */</comment>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcMaxBytes</name></name> = <name><name>rt</name>-&gt;<name>gcMaxMallocBytes</name></name> = <name>maxbytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcEmptyArenaPoolLifespan</name></name> = 30000</expr>;</expr_stmt>

    <comment type="block">/*
     * By default the trigger factor gets maximum possible value. This
     * means that GC will not be triggered by growth of GC memory (gcBytes).
     */</comment>
    <expr_stmt><expr><call><name><name>rt</name>-&gt;<name>setGCTriggerFactor</name></name><argument_list>(<argument><expr>(<name>uint32</name>) -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The assigned value prevents GC from running when GC memory is too low
     * (during JS engine start).
     */</comment>
    <expr_stmt><expr><call><name><name>rt</name>-&gt;<name>setGCLastBytes</name></name><argument_list>(<argument><expr>8192</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcStats</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>sizeof <name><name>rt</name>-&gt;<name>gcStats</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GCMETER</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateArenaStats</name><parameter_list>(<param><decl><type><name>JSGCArenaStats</name> *</type><name>st</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>nlivearenas</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>nkilledArenas</name></decl></param>,
                 <param><decl><type><name>uint32</name></type> <name>nthings</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>narenas</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>narenas</name> = <name>nlivearenas</name> + <name>nkilledArenas</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>narenas</name> &gt;= <name><name>st</name>-&gt;<name>livearenas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>st</name>-&gt;<name>newarenas</name></name> = <name>narenas</name> - <name><name>st</name>-&gt;<name>livearenas</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>st</name>-&gt;<name>narenas</name></name> = <name>narenas</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>st</name>-&gt;<name>livearenas</name></name> = <name>nlivearenas</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>st</name>-&gt;<name>maxarenas</name></name> &lt; <name>narenas</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>st</name>-&gt;<name>maxarenas</name></name> = <name>narenas</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>st</name>-&gt;<name>totalarenas</name></name> += <name>narenas</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>st</name>-&gt;<name>nthings</name></name> = <name>nthings</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>st</name>-&gt;<name>maxthings</name></name> &lt; <name>nthings</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>st</name>-&gt;<name>maxthings</name></name> = <name>nthings</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>st</name>-&gt;<name>totalthings</name></name> += <name>nthings</name></expr>;</expr_stmt>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>js_DumpGCStats</name><argument_list>(<argument>JSRuntime *rt</argument>, <argument>FILE *fp</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sumArenas</name></decl>, <decl><type ref="prev"/><name>sumTotalArenas</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sumThings</name></decl>, <decl><type ref="prev"/><name>sumMaxThings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sumThingSize</name></decl>, <decl><type ref="prev"/><name>sumTotalThingSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sumArenaCapacity</name></decl>, <decl><type ref="prev"/><name>sumTotalArenaCapacity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaStats</name> *</type><name>st</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>thingSize</name></decl>, <decl><type ref="prev"/><name>thingsPerArena</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>sumAlloc</name></decl>, <decl><type ref="prev"/><name>sumLocalAlloc</name></decl>, <decl><type ref="prev"/><name>sumFail</name></decl>, <decl><type ref="prev"/><name>sumRetry</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"\nGC allocation statistics:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UL</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>((unsigned long)(x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ULSTAT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>UL(rt-&gt;gcStats.x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PERCENT</name><parameter_list>(<param><type><name>x</name></type></param>,<param><type><name>y</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>(100.0 * (double) (x) / (double) (y))</cpp:value></cpp:define>

    <expr_stmt><expr><name>sumArenas</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumTotalArenas</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumThings</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumMaxThings</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumThingSize</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumTotalThingSize</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumArenaCapacity</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumTotalArenaCapacity</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumAlloc</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumLocalAlloc</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumFail</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sumRetry</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = -1</expr>;</init> <condition><expr><name>i</name> &lt; (<name>int</name>) <name>GC_NUM_FREELISTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name>i</name> == -1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>thingSize</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>jsdouble</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            <expr_stmt><expr><name>thingsPerArena</name> = <name>DOUBLES_PER_ARENA</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>st</name> = &amp;<name><name>rt</name>-&gt;<name>gcStats</name>.<name>doubleArenaStats</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
                    <argument><expr>"Arena list for double values (%lu doubles per arena):"</expr></argument>,
                    <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name>thingsPerArena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>thingSize</name> = <name><name>rt</name>-&gt;<name>gcArenaList</name><index>[<expr><name>i</name></expr>]</index></name>.<name>thingSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>thingsPerArena</name> = <call><name>THINGS_PER_ARENA</name><argument_list>(<argument><expr><name>thingSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>st</name> = &amp;<name><name>rt</name>-&gt;<name>gcStats</name>.<name>arenaStats</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
                    <argument><expr>"Arena list %d (thing size %lu, %lu things per arena):"</expr></argument>,
                    <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><call><name>GC_FREELIST_NBYTES</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name>thingsPerArena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><name><name>st</name>-&gt;<name>maxarenas</name></name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr>" NEVER USED\n"</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>
        <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"           arenas before GC: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>narenas</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"       new arenas before GC: %lu (%.1f%%)\n"</expr></argument>,
                <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>newarenas</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PERCENT</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>newarenas</name></name></expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>narenas</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"            arenas after GC: %lu (%.1f%%)\n"</expr></argument>,
                <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>livearenas</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PERCENT</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>livearenas</name></name></expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>narenas</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"                 max arenas: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>maxarenas</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"                     things: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>nthings</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"        GC cell utilization: %.1f%%\n"</expr></argument>,
                <argument><expr><call><name>PERCENT</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>nthings</name></name></expr></argument>, <argument><expr><name>thingsPerArena</name> * <name><name>st</name>-&gt;<name>narenas</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"   average cell utilization: %.1f%%\n"</expr></argument>,
                <argument><expr><call><name>PERCENT</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>totalthings</name></name></expr></argument>, <argument><expr><name>thingsPerArena</name> * <name><name>st</name>-&gt;<name>totalarenas</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"                 max things: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>maxthings</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"             alloc attempts: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>alloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"        alloc without locks: %1u  (%.1f%%)\n"</expr></argument>,
                <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>localalloc</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PERCENT</name><argument_list>(<argument><expr><name><name>st</name>-&gt;<name>localalloc</name></name></expr></argument>, <argument><expr><name><name>st</name>-&gt;<name>alloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumArenas</name> += <name><name>st</name>-&gt;<name>narenas</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumTotalArenas</name> += <name><name>st</name>-&gt;<name>totalarenas</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumThings</name> += <name><name>st</name>-&gt;<name>nthings</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumMaxThings</name> += <name><name>st</name>-&gt;<name>maxthings</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumThingSize</name> += <name>thingSize</name> * <name><name>st</name>-&gt;<name>nthings</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumTotalThingSize</name> += <name>thingSize</name> * <name><name>st</name>-&gt;<name>totalthings</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumArenaCapacity</name> += <name>thingSize</name> * <name>thingsPerArena</name> * <name><name>st</name>-&gt;<name>narenas</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumTotalArenaCapacity</name> += <name>thingSize</name> * <name>thingsPerArena</name> * <name><name>st</name>-&gt;<name>totalarenas</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumAlloc</name> += <name><name>st</name>-&gt;<name>alloc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumLocalAlloc</name> += <name><name>st</name>-&gt;<name>localalloc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumFail</name> += <name><name>st</name>-&gt;<name>fail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sumRetry</name> += <name><name>st</name>-&gt;<name>retry</name></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"TOTAL STATS:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"            bytes allocated: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcBytes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"            total GC arenas: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name>sumArenas</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"            total GC things: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name>sumThings</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"        max total GC things: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name>sumMaxThings</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"        GC cell utilization: %.1f%%\n"</expr></argument>,
            <argument><expr><call><name>PERCENT</name><argument_list>(<argument><expr><name>sumThingSize</name></expr></argument>, <argument><expr><name>sumArenaCapacity</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"   average cell utilization: %.1f%%\n"</expr></argument>,
            <argument><expr><call><name>PERCENT</name><argument_list>(<argument><expr><name>sumTotalThingSize</name></expr></argument>, <argument><expr><name>sumTotalArenaCapacity</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"allocation retries after GC: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name>sumRetry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"             alloc attempts: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name>sumAlloc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"        alloc without locks: %1u  (%.1f%%)\n"</expr></argument>,
            <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name>sumLocalAlloc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PERCENT</name><argument_list>(<argument><expr><name>sumLocalAlloc</name></expr></argument>, <argument><expr><name>sumAlloc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"        allocation failures: %lu\n"</expr></argument>, <argument><expr><call><name>UL</name><argument_list>(<argument><expr><name>sumFail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"         things born locked: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>lockborn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"           valid lock calls: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"         valid unlock calls: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>unlock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"       mark recursion depth: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"     maximum mark recursion: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>maxdepth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"     mark C recursion depth: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>cdepth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"   maximum mark C recursion: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>maxcdepth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"      delayed tracing calls: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>untraced</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"      max trace later count: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>maxuntraced</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"   maximum GC nesting level: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>maxlevel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"potentially useful GC calls: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>poke</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"  thing arenas freed so far: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>afree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"     stack segments scanned: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>stackseg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"stack segment slots scanned: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>segslots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"reachable closeable objects: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>nclose</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"    max reachable closeable: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>maxnclose</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"      scheduled close hooks: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>closelater</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"  max scheduled close hooks: %lu\n"</expr></argument>, <argument><expr><call><name>ULSTAT</name><argument_list>(<argument><expr><name>maxcloselater</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>UL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ULSTAT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PERCENT</name></cpp:undef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_ARENAMETER</name></cpp:ifdef>
    <expr_stmt><expr><call><name>JS_DumpArenaStats</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>CheckLeakedRoots</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>js_FinishGC</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_ARENAMETER</name></cpp:ifdef>
    <expr_stmt><expr><call><name>JS_DumpArenaStats</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GCMETER</name></cpp:ifdef>
    <expr_stmt><expr><call><name>js_DumpGCStats</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>FreePtrTable</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcIteratorTable</name></name></expr></argument>, <argument><expr>&amp;<name>iteratorTableInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FinishGCArenaLists</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcRootsHash</name>.<name>ops</name></name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>CheckLeakedRoots</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>JS_DHashTableFinish</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcRootsHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcRootsHash</name>.<name>ops</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcLocksHash</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_DHashTableDestroy</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcLocksHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcLocksHash</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_AddRoot</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>void</name> *</type><name>rp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name> <init>= <expr><call><name>js_AddRootRT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_AddRootRT</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>void</name> *</type><name>rp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCRootHashEntry</name> *</type><name>rhe</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Due to the long-standing, but now removed, use of rt-&gt;gcLock across the
     * bulk of js_GC, API users have come to depend on JS_AddRoot etc. locking
     * properly with a racing GC, without calling JS_AddRoot from a request.
     * We have to preserve API compatibility here, now that we avoid holding
     * rt-&gt;gcLock across the mark phase (including the root hashtable mark).
     */</comment>
    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_WaitForGC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rhe</name> = (<name>JSGCRootHashEntry</name> *)
          <call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcRootsHash</name></name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>JS_DHASH_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rhe</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>rhe</name>-&gt;<name>root</name></name> = <name>rp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rhe</name>-&gt;<name>name</name></name> = <name>name</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_RemoveRoot</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>void</name> *</type><name>rp</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Due to the JS_RemoveRootRT API, we may be called outside of a request.
     * Same synchronization drill as above in js_AddRoot.
     */</comment>
    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_WaitForGC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcRootsHash</name></name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>JS_DHASH_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcPoke</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>JSDHashOperator</name></type>
<name>js_root_printer</name><parameter_list>(<param><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl></param>, <param><decl><type><name>JSDHashEntryHdr</name> *</type><name>hdr</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>i</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32</name> *</type><name>leakedroots</name> <init>= <expr>(<name>uint32</name> *)<name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCRootHashEntry</name> *</type><name>rhe</name> <init>= <expr>(<name>JSGCRootHashEntry</name> *)<name>hdr</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>(*<name>leakedroots</name>)++</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
            <argument><expr>"JS engine warning: leaking GC root \'%s\' at %p\n"</expr></argument>,
            <argument><expr><name><name>rhe</name>-&gt;<name>name</name></name> ? (<name>char</name> *)<name><name>rhe</name>-&gt;<name>name</name></name> : ""</expr></argument>, <argument><expr><name><name>rhe</name>-&gt;<name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>JS_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckLeakedRoots</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type> <name>leakedroots</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Warn (but don't assert) debug builds of any remaining roots. */</comment>
    <expr_stmt><expr><call><name>JS_DHashTableEnumerate</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcRootsHash</name></name></expr></argument>, <argument><expr><name>js_root_printer</name></expr></argument>,
                           <argument><expr>&amp;<name>leakedroots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>leakedroots</name> &gt; 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>leakedroots</name> == 1</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr>"JS engine warning: 1 GC root remains after destroying the JSRuntime at %p.\n"
"                   This root may point to freed memory. Objects reachable\n"
"                   through it have not been finalized.\n"</expr></argument>,
                    <argument><expr>(<name>void</name> *) <name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr>"JS engine warning: %lu GC roots remain after destroying the JSRuntime at %p.\n"
"                   These roots may point to freed memory. Objects reachable\n"
"                   through them have not been finalized.\n"</expr></argument>,
                    <argument><expr>(<name>unsigned</name> <name>long</name>) <name>leakedroots</name></expr></argument>, <argument><expr>(<name>void</name> *) <name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
}</block></function>

<typedef>typedef <type><struct>struct <name>NamedRootDumpArgs</name> <block>{<public type="default">
    <function_decl><type><name>void</name></type> (*<name>dump</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>void</name> *</type><name>rp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>void</name> *</type><name>data</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>NamedRootDumpArgs</name>;</typedef>

<function><type><specifier>static</specifier> <name>JSDHashOperator</name></type>
<name>js_named_root_dumper</name><parameter_list>(<param><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl></param>, <param><decl><type><name>JSDHashEntryHdr</name> *</type><name>hdr</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>number</name></decl></param>,
                     <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>NamedRootDumpArgs</name> *</type><name>args</name> <init>= <expr>(<name>NamedRootDumpArgs</name> *) <name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCRootHashEntry</name> *</type><name>rhe</name> <init>= <expr>(<name>JSGCRootHashEntry</name> *)<name>hdr</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>rhe</name>-&gt;<name>name</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>args</name>-&gt;<name>dump</name></name><argument_list>(<argument><expr><name><name>rhe</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>rhe</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>JS_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><name>JS_BEGIN_EXTERN_C</name>
<name>void</name></type>
<name>js_DumpNamedRoots</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>,
                  <param><function_decl><type><name>void</name></type> (*<name>dump</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>void</name> *</type><name>rp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list></function_decl></param>,
                  <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>NamedRootDumpArgs</name></type> <name>args</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>args</name>.<name>dump</name></name> = <name>dump</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name>.<name>data</name></name> = <name>data</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_DHashTableEnumerate</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcRootsHash</name></name></expr></argument>, <argument><expr><name>js_named_root_dumper</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<macro><name>JS_END_EXTERN_C</name></macro>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG */</comment>

<typedef>typedef <type><struct>struct <name>GCRootMapArgs</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSGCRootMapFun</name></type> <name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>data</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>GCRootMapArgs</name>;</typedef>

<function><type><specifier>static</specifier> <name>JSDHashOperator</name></type>
<name>js_gcroot_mapper</name><parameter_list>(<param><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl></param>, <param><decl><type><name>JSDHashEntryHdr</name> *</type><name>hdr</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>number</name></decl></param>,
                 <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>GCRootMapArgs</name> *</type><name>args</name> <init>= <expr>(<name>GCRootMapArgs</name> *) <name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCRootHashEntry</name> *</type><name>rhe</name> <init>= <expr>(<name>JSGCRootHashEntry</name> *)<name>hdr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>intN</name></type> <name>mapflags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>mapflags</name> = <call><name><name>args</name>-&gt;<name>map</name></name><argument_list>(<argument><expr><name><name>rhe</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>rhe</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_MAP_GCROOT_NEXT</name> == <name>JS_DHASH_NEXT</name> &amp;&amp;                                     \
    <name>JS_MAP_GCROOT_STOP</name> == <name>JS_DHASH_STOP</name> &amp;&amp;                                     \
    <name>JS_MAP_GCROOT_REMOVE</name> == <name>JS_DHASH_REMOVE</name></expr></cpp:if>
    <expr_stmt><expr><name>op</name> = (<name>JSDHashOperator</name>)<name>mapflags</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>op</name> = <name>JS_DHASH_NEXT</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mapflags</name> &amp; <name>JS_MAP_GCROOT_STOP</name></expr>)</condition><then>
        <expr_stmt><expr><name>op</name> |= <name>JS_DHASH_STOP</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>mapflags</name> &amp; <name>JS_MAP_GCROOT_REMOVE</name></expr>)</condition><then>
        <expr_stmt><expr><name>op</name> |= <name>JS_DHASH_REMOVE</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr>(<name>JSDHashOperator</name>) <name>op</name></expr>;</return>
}</block></function>

<function><type><name>uint32</name></type>
<name>js_MapGCRoots</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSGCRootMapFun</name></type> <name>map</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>GCRootMapArgs</name></type> <name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>args</name>.<name>map</name></name> = <name>map</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name>.<name>data</name></name> = <name>data</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>JS_DHashTableEnumerate</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcRootsHash</name></name></expr></argument>, <argument><expr><name>js_gcroot_mapper</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_RegisterCloseableIterator</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rt</name> = <name><name>cx</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>rt</name>-&gt;<name>gcRunning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <call><name>AddToPtrTable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcIteratorTable</name></name></expr></argument>, <argument><expr>&amp;<name>iteratorTableInfo</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloseNativeIterators</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>newCount</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> **</type><name>array</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rt</name> = <name><name>cx</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>count</name> = <name><name>rt</name>-&gt;<name>gcIteratorTable</name>.<name>count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>array</name> = <name><name>rt</name>-&gt;<name>gcIteratorTable</name>.<name>array</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>newCount</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><name>obj</name> = (<name>JSObject</name> *)<name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_IsAboutToBeFinalized</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>js_CloseNativeIterator</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name><name>array</name><index>[<expr><name>newCount</name>++</expr>]</index></name> = <name>obj</name></expr>;</expr_stmt></else></if>
    }</block></for>
    <expr_stmt><expr><call><name>ShrinkPtrTable</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcIteratorTable</name></name></expr></argument>, <argument><expr>&amp;<name>iteratorTableInfo</name></expr></argument>, <argument><expr><name>newCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_brendan</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_timeless</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_gchist</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_gchist</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NGCHIST</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<struct><specifier>static</specifier> struct <name>GCHist</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>bool</name></type>        <name>lastDitch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCThing</name>   *</type><name>freeList</name></decl>;</decl_stmt>
</public>}</block> <decl><name><name>gchist</name><index>[<expr><name>NGCHIST</name></expr>]</index></name></decl>;</struct>

<decl_stmt><decl><type><name>unsigned</name></type> <name>gchpos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name><name>JSRuntime</name>::<name>setGCTriggerFactor</name></name><parameter_list>(<param><decl><type><name>uint32</name></type> <name>factor</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>factor</name> &gt;= 100</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>gcTriggerFactor</name> = <name>factor</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setGCLastBytes</name><argument_list>(<argument><expr><name>gcLastBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>JSRuntime</name>::<name>setGCLastBytes</name></name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>lastBytes</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>gcLastBytes</name> = <name>lastBytes</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uint64</name></type> <name>triggerBytes</name> <init>= <expr><call><name>uint64</name><argument_list>(<argument><expr><name>lastBytes</name></expr></argument>)</argument_list></call> * <call><name>uint64</name><argument_list>(<argument><expr><name>gcTriggerFactor</name> / 100</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>triggerBytes</name> != <call><name>size_t</name><argument_list>(<argument><expr><name>triggerBytes</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>triggerBytes</name> = <call><name>size_t</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>gcTriggerBytes</name> = <call><name>size_t</name><argument_list>(<argument><expr><name>triggerBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>bool</name></type>
<name>IsGCThresholdReached</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GC_ZEAL</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcZeal</name></name> &gt;= 1</expr>)</condition><then>
        <return>return <expr>true</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Since the initial value of the gcLastBytes parameter is not equal to
     * zero (see the js_InitGC function) the return value is false when
     * the gcBytes value is close to zero at the JS engine start.
     */</comment>
    <return>return <expr><name><name>rt</name>-&gt;<name>gcMallocBytes</name></name> &gt;= <name><name>rt</name>-&gt;<name>gcMaxMallocBytes</name></name> ||
           <name><name>rt</name>-&gt;<name>gcBytes</name></name> &gt;= <name><name>rt</name>-&gt;<name>gcTriggerBytes</name></name></expr>;</return>
}</block></function>

<template>template <parameter_list>&lt;<param><type><name>class</name></type> <name>T</name></param>&gt;</parameter_list> <function><type><specifier>static</specifier> <name>JS_INLINE</name> <name>T</name>*</type>
<name>NewGCThing</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>doGC</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCThing</name> *</type><name>thing</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name> *</type><name>flagp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaList</name> *</type><name>arenaList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>thingsLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSLocalRootStack</name> *</type><name>lrs</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GCMETER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSGCArenaStats</name> *</type><name>astats</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>gcLocked</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>localMallocBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCThing</name> **</type><name>lastptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCThing</name> *</type><name>tmpthing</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name> *</type><name>tmpflagp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>maxFreeThings</name></decl>;</decl_stmt>         <comment type="block">/* max to take from the global free list */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>flags</name> &amp; <name>GCF_TYPEMASK</name>) != <name>GCX_DOUBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rt</name> = <name><name>cx</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_ROUNDUP</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSGCThing</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> == <name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>flindex</name> <init>= <expr><call><name>GC_FREELIST_INDEX</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Updates of metering counters here may not be thread-safe. */</comment>
    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name>astats</name> = &amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>gcStats</name>.<name>arenaStats</name><index>[<expr><name>flindex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>astats</name>-&gt;<name>alloc</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <expr_stmt><expr><name>gcLocked</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>thread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>JSGCThing</name> *&amp;</type><name>freeList</name> <init>= <expr><name><name>cx</name>-&gt;<name>thread</name>-&gt;<name>gcFreeLists</name><index>[<expr><name>flindex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>thing</name> = <name>freeList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>localMallocBytes</name> = <call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>-&gt;<name>gcMallocBytes</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>thing</name> &amp;&amp; <name><name>rt</name>-&gt;<name>gcMaxMallocBytes</name></name> - <name><name>rt</name>-&gt;<name>gcMallocBytes</name></name> &gt; <name>localMallocBytes</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>flagp</name> = <name><name>thing</name>-&gt;<name>flagp</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>freeList</name> = <name><name>thing</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>astats</name>-&gt;<name>localalloc</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>success</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>gcLocked</name> = <name>JS_TRUE</name></expr>;</expr_stmt>

    <comment type="block">/* Transfer thread-local counter to global one. */</comment>
    <if>if <condition>(<expr><name>localMallocBytes</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_THREAD_DATA</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>-&gt;<name>gcMallocBytes</name> = 0</expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcMaxMallocBytes</name></name> - <name><name>rt</name>-&gt;<name>gcMallocBytes</name></name> &lt; <name>localMallocBytes</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcMallocBytes</name></name> = <name><name>rt</name>-&gt;<name>gcMaxMallocBytes</name></name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcMallocBytes</name></name> += <name>localMallocBytes</name></expr>;</expr_stmt></else></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>rt</name>-&gt;<name>gcRunning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcRunning</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>finalfail</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>JS_GC_ZEAL</name> &amp;&amp; <name>defined</name> <name>JS_TRACER</name></expr></cpp:if>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcZeal</name></name> &gt;= 1 &amp;&amp; <call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>useReservedObjects</name></expr>)</condition><then>
        <goto>goto <name>testReservedObjects</name>;</goto></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>arenaList</name> = &amp;<name><name>rt</name>-&gt;<name>gcArenaList</name><index>[<expr><name>flindex</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>doGC</name> = <call><name>IsGCThresholdReached</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <if>if <condition>(<expr><name>doGC</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
            &amp;&amp; !<call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>useReservedObjects</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            )</condition><then> <block>{
            <comment type="block">/*
             * Keep rt-&gt;gcLock across the call into js_GC so we don't starve
             * and lose to racing threads who deplete the heap just after
             * js_GC has replenished it (or has synchronized with a racing
             * GC that collected a bunch of garbage).  This unfair scheduling
             * can happen on certain operating systems. For the gory details,
             * see bug 162779 at https://bugzilla.mozilla.org/.
             */</comment>
            <expr_stmt><expr><call><name>js_GC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>GC_LAST_DITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>astats</name>-&gt;<name>retry</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Try to get thing from the free list. */</comment>
        <expr_stmt><expr><name>thing</name> = <name><name>arenaList</name>-&gt;<name>freeList</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>thing</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>freeList</name></name> = <name><name>thing</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>flagp</name> = <name><name>thing</name>-&gt;<name>flagp</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>flagp</name> &amp; <name>GCF_FINAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
            <comment type="block">/*
             * Refill the local free list by taking several things from the
             * global free list unless the free list is already populated or
             * we are still at rt-&gt;gcMaxMallocBytes barrier. The former is
             * caused via allocating new things in gcCallback(cx, JSGC_END).
             * The latter happens when GC is canceled due to
             * gcCallback(cx, JSGC_BEGIN) returning false.
             */</comment>
            <if>if <condition>(<expr><name>freeList</name> || <name><name>rt</name>-&gt;<name>gcMallocBytes</name></name> &gt;= <name><name>rt</name>-&gt;<name>gcMaxMallocBytes</name></name></expr>)</condition><then>
                <break>break;</break></then></if>

            <expr_stmt><expr><name>tmpthing</name> = <name><name>arenaList</name>-&gt;<name>freeList</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tmpthing</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>maxFreeThings</name> = <name>MAX_THREAD_LOCAL_THINGS</name></expr>;</expr_stmt>
                <do>do <block>{
                    <if>if <condition>(<expr>!<name><name>tmpthing</name>-&gt;<name>next</name></name></expr>)</condition><then>
                        <break>break;</break></then></if>
                    <expr_stmt><expr><name>tmpthing</name> = <name><name>tmpthing</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
                }</block> while <condition>(<expr>--<name>maxFreeThings</name> != 0</expr>)</condition>;</do>

                <expr_stmt><expr><name>freeList</name> = <name><name>arenaList</name>-&gt;<name>freeList</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>freeList</name></name> = <name><name>tmpthing</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tmpthing</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/*
         * Try to allocate things from the last arena. If it is fully used,
         * check if we can allocate a new one and, if we cannot, consider
         * doing a "last ditch" GC unless already tried.
         */</comment>
        <expr_stmt><expr><name>thingsLimit</name> = <call><name>THINGS_PER_ARENA</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name> != <name>thingsLimit</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name> &lt; <name>thingsLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>a</name> = <name><name>arenaList</name>-&gt;<name>last</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
            <if>if <condition>(<expr><call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>useReservedObjects</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GC_ZEAL</name></cpp:ifdef>
<label><name>testReservedObjects</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <decl_stmt><decl><type><name>JSTraceMonitor</name> *</type><name>tm</name> <init>= <expr>&amp;<call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>thing</name> = (<name>JSGCThing</name> *) <name><name>tm</name>-&gt;<name>reservedObjects</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>flagp</name> = <call><name>GetGCThingFlags</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tm</name>-&gt;<name>reservedObjects</name></name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>tm</name>-&gt;<name>reservedObjects</name>-&gt;<name>fslots</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>a</name> = <call><name>NewGCArena</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>a</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>doGC</name> || <call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <goto>goto <name>fail</name>;</goto></then></if>
                <expr_stmt><expr><name>doGC</name> = true</expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>list</name></name> = <name>arenaList</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>prev</name></name> = <name><name>arenaList</name>-&gt;<name>last</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>prevUntracedPage</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>u</name>.<name>untracedThings</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>last</name></name> = <name>a</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name> = 0</expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><name>flagp</name> = <call><name>THING_FLAGP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>thing</name> = <call><name>FLAGP_TO_THING</name><argument_list>(<argument><expr><name>flagp</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name>++</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <comment type="block">/*
         * Refill the local free list by taking free things from the last
         * arena. Prefer to order free things by ascending address in the
         * (unscientific) hope of better cache locality.
         */</comment>
        <if>if <condition>(<expr><name>freeList</name> || <name><name>rt</name>-&gt;<name>gcMallocBytes</name></name> &gt;= <name><name>rt</name>-&gt;<name>gcMaxMallocBytes</name></name></expr>)</condition><then>
            <break>break;</break></then></if>
        <expr_stmt><expr><name>lastptr</name> = &amp;<name>freeList</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>maxFreeThings</name> = <name>thingsLimit</name> - <name><name>arenaList</name>-&gt;<name>lastCount</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>maxFreeThings</name> &gt; <name>MAX_THREAD_LOCAL_THINGS</name></expr>)</condition><then>
            <expr_stmt><expr><name>maxFreeThings</name> = <name>MAX_THREAD_LOCAL_THINGS</name></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>uint32</name></type> <name>lastCount</name> <init>= <expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>maxFreeThings</name> != 0</expr>)</condition> <block>{
            <expr_stmt><expr>--<name>maxFreeThings</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>tmpflagp</name> = <call><name>THING_FLAGP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>lastCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tmpthing</name> = <call><name>FLAGP_TO_THING</name><argument_list>(<argument><expr><name>tmpflagp</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastCount</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tmpthing</name>-&gt;<name>flagp</name></name> = <name>tmpflagp</name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>tmpflagp</name> = <name>GCF_FINAL</name></expr>;</expr_stmt>    <comment type="block">/* signifying that thing is free */</comment>

            <expr_stmt><expr>*<name>lastptr</name> = <name>tmpthing</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>lastptr</name> = &amp;<name><name>tmpthing</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr>*<name>lastptr</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name> = <name>lastCount</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>
    }</block></for>

    <comment type="block">/* We successfully allocated the thing. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
  <label><name>success</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>lrs</name> = <name><name>cx</name>-&gt;<name>localRootStack</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>lrs</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If we're in a local root scope, don't set newborn[type] at all, to
         * avoid entraining garbage from it for an unbounded amount of time
         * on this context.  A caller will leave the local root scope and pop
         * this reference, allowing thing to be GC'd if it has no other refs.
         * See JS_EnterLocalRootScope and related APIs.
         */</comment>
        <if>if <condition>(<expr><call><name>js_PushLocalRoot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>lrs</name></expr></argument>, <argument><expr>(<name>jsval</name>) <name>thing</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <comment type="block">/*
             * When we fail for a thing allocated through the tail of the last
             * arena, thing's flag byte is not initialized. So to prevent GC
             * accessing the uninitialized flags during the finalization, we
             * always mark the thing as final. See bug 337407.
             */</comment>
            <expr_stmt><expr>*<name>flagp</name> = <name>GCF_FINAL</name></expr>;</expr_stmt>
            <goto>goto <name>fail</name>;</goto>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * No local root scope, so we're stuck with the old, fragile model of
         * depending on a pigeon-hole newborn per type per context.
         */</comment>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>weakRoots</name>.<name>newborn</name><index>[<expr><name>flags</name> &amp; <name>GCF_TYPEMASK</name></expr>]</index></name> = <name>thing</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* We can't fail now, so update flags. */</comment>
    <expr_stmt><expr>*<name>flagp</name> = (<name>uint8</name>)<name>flags</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_gchist</name></cpp:ifdef>
    <expr_stmt><expr><name><name>gchist</name><index>[<expr><name>gchpos</name></expr>]</index></name>.<name>lastDitch</name> = <name>doGC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gchist</name><index>[<expr><name>gchpos</name></expr>]</index></name>.<name>freeList</name> = <name><name>rt</name>-&gt;<name>gcArenaList</name><index>[<expr><name>flindex</name></expr>]</index></name>.<name>freeList</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>++<name>gchpos</name> == <name>NGCHIST</name></expr>)</condition><then>
        <expr_stmt><expr><name>gchpos</name> = 0</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* This is not thread-safe for thread-local allocations. */</comment>
    <expr_stmt><expr><call><name>METER_IF</name><argument_list>(<argument><expr><name>flags</name> &amp; <name>GCF_LOCK</name></expr></argument>, <argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>lockborn</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <if>if <condition>(<expr><name>gcLocked</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>(<name>T</name>*)<name>thing</name></expr>;</return>

<label><name>fail</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <if>if <condition>(<expr><name>gcLocked</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>astats</name>-&gt;<name>fail</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function></template>

<function><type><specifier>extern</specifier> <name>JSObject</name>*</type> <name>js_NewGCObject</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>NewGCThing</name><argument_list>&lt;<argument><expr><name>JSObject</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>extern</specifier> <name>JSString</name>*</type> <name>js_NewGCString</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>NewGCThing</name><argument_list>&lt;<argument><expr><name>JSString</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>extern</specifier> <name>JSFunction</name>*</type> <name>js_NewGCFunction</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>NewGCThing</name><argument_list>&lt;<argument><expr><name>JSFunction</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>extern</specifier> <name>JSXML</name>*</type> <name>js_NewGCXML</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name><name>NewGCThing</name><argument_list>&lt;<argument><expr><name>JSXML</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSGCDoubleCell</name> *</type>
<name>RefillDoubleFreeList</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbitmap</name> *</type><name>doubleFlags</name></decl>, <decl><type ref="prev"/><name>usedBits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>didGC</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>bit</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCDoubleCell</name> *</type><name>cell</name></decl>, *<decl><type ref="prev"/><name>list</name></decl>, *<decl><type ref="prev"/><name>lastcell</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>cx</name>-&gt;<name>doubleFreeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rt</name> = <name><name>cx</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>rt</name>-&gt;<name>gcRunning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcRunning</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>finalfail</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>IsGCThresholdReached</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>do_gc</name>;</goto></then></if>

    <comment type="block">/*
     * Loop until we find a flag bitmap byte with unset bits indicating free
     * double cells, then set all bits as used and put the cells to the free
     * list for the current context.
     */</comment>
    <expr_stmt><expr><name>doubleFlags</name> = <name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>nextDoubleFlags</name></name></expr>;</expr_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <if>if <condition>(<expr>((<name>jsuword</name>) <name>doubleFlags</name> &amp; <name>GC_ARENA_MASK</name>) ==
            <name>ARENA_INFO_OFFSET</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>doubleFlags</name> == <name>DOUBLE_BITMAP_SENTINEL</name> ||
                !((<name>JSGCArenaInfo</name> *) <name>doubleFlags</name>)-&gt;<name>prev</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>a</name> = <call><name>NewGCArena</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>a</name></expr>)</condition><then> <block>{
                  <label><name>do_gc</name>:</label>
                    <if>if <condition>(<expr><name>didGC</name> || <call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>doubleArenaStats</name>.<name>fail</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>js_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>NULL</name></expr>;</return>
                    }</block></then></if>
                    <expr_stmt><expr><call><name>js_GC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>GC_LAST_DITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>doubleArenaStats</name>.<name>retry</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>doubleFlags</name> = <name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>nextDoubleFlags</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>didGC</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>
                <expr_stmt><expr><name><name>a</name>-&gt;<name>list</name></name> = <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>a</name>-&gt;<name>prev</name></name> = <name>NULL</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>doubleFlags</name> == <name>DOUBLE_BITMAP_SENTINEL</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name> = <name>a</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr>((<name>JSGCArenaInfo</name> *) <name>doubleFlags</name>)-&gt;<name>prev</name> = <name>a</name></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><call><name>ClearDoubleArenaFlags</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>doubleFlags</name> = <call><name>DOUBLE_ARENA_BITMAP</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>doubleFlags</name> =
                <call><name>DOUBLE_ARENA_BITMAP</name><argument_list>(<argument><expr>((<name>JSGCArenaInfo</name> *) <name>doubleFlags</name>)-&gt;<name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/*
         * When doubleFlags points the last bitmap's word in the arena, its
         * high bits corresponds to non-existing cells. ClearDoubleArenaFlags
         * sets such bits to 1. Thus even for this last word its bit is unset
         * iff the corresponding cell exists and free.
         */</comment>
        <if>if <condition>(<expr>*<name>doubleFlags</name> != (<name>jsbitmap</name>) -1</expr>)</condition><then>
            <break>break;</break></then></if>
        <expr_stmt><expr>++<name>doubleFlags</name></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>nextDoubleFlags</name></name> = <name>doubleFlags</name> + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>usedBits</name> = *<name>doubleFlags</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>usedBits</name> != (<name>jsbitmap</name>) -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>doubleFlags</name> = (<name>jsbitmap</name>) -1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Find the index corresponding to the first bit in *doubleFlags. The last
     * bit will have "index + JS_BITS_PER_WORD - 1".
     */</comment>
    <expr_stmt><expr><name>index</name> = (<call>(<name>uintN</name>) <argument_list>(<argument><expr>(<name>jsuword</name>) <name>doubleFlags</name> &amp; <name>GC_ARENA_MASK</name></expr></argument>)</argument_list></call> -
             <name>DOUBLES_ARENA_BITMAP_OFFSET</name>) * <name>JS_BITS_PER_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cell</name> = (<name>JSGCDoubleCell</name> *) ((<name>jsuword</name>) <name>doubleFlags</name> &amp; ~<name>GC_ARENA_MASK</name>) + <name>index</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>usedBits</name> == 0</expr>)</condition><then> <block>{
        <comment type="block">/* The common case when all doubles from *doubleFlags are free. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>index</name> + <name>JS_BITS_PER_WORD</name> &lt;= <name>DOUBLES_PER_ARENA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>list</name> = <name>cell</name></expr>;</expr_stmt>
        <for>for (<init><expr><name>lastcell</name> = <name>cell</name> + <name>JS_BITS_PER_WORD</name> - 1</expr>;</init> <condition><expr><name>cell</name> != <name>lastcell</name></expr>;</condition> <incr><expr>++<name>cell</name></expr></incr>)
            <expr_stmt><expr><name><name>cell</name>-&gt;<name>link</name></name> = <name>cell</name> + 1</expr>;</expr_stmt></for>
        <expr_stmt><expr><name><name>lastcell</name>-&gt;<name>link</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * Assemble the free list from free cells from *doubleFlags starting
         * from the tail. In the loop
         *
         *   index + bit &gt;= DOUBLES_PER_ARENA
         *
         * when bit is one of the unused bits. We do not check for such bits
         * explicitly as they must be set and the "if" check filters them out.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>index</name> + <name>JS_BITS_PER_WORD</name> &lt;=
                  <name>DOUBLES_PER_ARENA</name> + <name>UNUSED_DOUBLE_BITMAP_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bit</name> = <name>JS_BITS_PER_WORD</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cell</name> += <name>bit</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>list</name> = <name>NULL</name></expr>;</expr_stmt>
        <do>do <block>{
            <expr_stmt><expr>--<name>bit</name></expr>;</expr_stmt>
            <expr_stmt><expr>--<name>cell</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!(((<name>jsbitmap</name>) 1 &lt;&lt; <name>bit</name>) &amp; <name>usedBits</name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>index</name> + <name>bit</name> &lt; <name>DOUBLES_PER_ARENA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>index</name> + <name>bit</name> == <name>DOUBLES_PER_ARENA</name> - 1</expr></argument>, <argument><expr>!<name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cell</name>-&gt;<name>link</name></name> = <name>list</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>list</name> = <name>cell</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block> while <condition>(<expr><name>bit</name> != 0</expr>)</condition>;</do>
    }</block></else></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We delegate assigning cx-&gt;doubleFreeList to js_NewDoubleInRootedValue as
     * it immediately consumes the head of the list.
     */</comment>
    <return>return <expr><name>list</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_NewDoubleInRootedValue</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsdouble</name></type> <name>d</name></decl></param>, <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GCMETER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSGCArenaStats</name> *</type><name>astats</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>JSGCDoubleCell</name> *</type><name>cell</name></decl>;</decl_stmt>

    <comment type="block">/* Updates of metering counters here are not thread-safe. */</comment>
    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name>astats</name> = &amp;<name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>gcStats</name>.<name>doubleArenaStats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>astats</name>-&gt;<name>alloc</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cell</name> = <name><name>cx</name>-&gt;<name>doubleFreeList</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>cell</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>cell</name> = <call><name>RefillDoubleFreeList</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>cell</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>astats</name>-&gt;<name>fail</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>astats</name>-&gt;<name>localalloc</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name><name>cx</name>-&gt;<name>doubleFreeList</name></name> = <name><name>cell</name>-&gt;<name>link</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cell</name>-&gt;<name>number</name></name> = <name>d</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>vp</name> = <call><name>DOUBLE_TO_JSVAL</name><argument_list>(<argument><expr>&amp;<name><name>cell</name>-&gt;<name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>jsdouble</name> *</type>
<name>js_NewWeaklyRootedDouble</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsdouble</name></type> <name>d</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name> *</type><name>dp</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>js_NewDoubleInRootedValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dp</name> = <call><name>JSVAL_TO_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>cx</name>-&gt;<name>localRootStack</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>js_PushLocalRoot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cx</name>-&gt;<name>localRootStack</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>weakRoots</name>.<name>newborn</name><index>[<expr><name>GCX_DOUBLE</name></expr>]</index></name> = <name>dp</name></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>dp</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
<function><type><name>JSBool</name></type>
<name>js_ReserveObjects</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nobjects</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Ensure at least nobjects objects are in the list. fslots[1] of each
     * object on the reservedObjects list is the length of the list from there.
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name> *&amp;</type><name>head</name> <init>= <expr><call><name>JS_TRACE_MONITOR</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call>.<name>reservedObjects</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><name>head</name> ? <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name><name>head</name>-&gt;<name>fslots</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>i</name> &lt; <name>nobjects</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><call><name>js_NewGCObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>GCX_OBJECT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>obj</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The class must be set to something for finalization. */</comment>
        <expr_stmt><expr><name><name>obj</name>-&gt;<name>classword</name></name> = (<name>jsuword</name>) &amp;<name>js_ObjectClass</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>obj</name>-&gt;<name>fslots</name><index>[<expr>0</expr>]</index></name> = <call><name>OBJECT_TO_JSVAL</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>obj</name>-&gt;<name>fslots</name><index>[<expr>1</expr>]</index></name> = <call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name> = <name>obj</name></expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>JSBool</name></type>
<name>js_AddAsGCBytes</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>sz</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rt</name> = <name><name>cx</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcBytes</name></name> &gt;= <name><name>rt</name>-&gt;<name>gcMaxBytes</name></name> ||
        <name>sz</name> &gt; <call>(<name>size_t</name>) <argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcMaxBytes</name></name> - <name><name>rt</name>-&gt;<name>gcBytes</name></name></expr></argument>)</argument_list></call> ||
        <call><name>IsGCThresholdReached</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If we can't leave the trace, signal OOM condition, otherwise
             * exit from trace and proceed with GC.
             */</comment>
            <if>if <condition>(<expr>!<call><name>js_CanLeaveTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name>js_LeaveTrace</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>js_GC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>GC_LAST_DITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcBytes</name></name> &gt;= <name><name>rt</name>-&gt;<name>gcMaxBytes</name></name> ||
            <name>sz</name> &gt; <call>(<name>size_t</name>) <argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcMaxBytes</name></name> - <name><name>rt</name>-&gt;<name>gcBytes</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcBytes</name></name> += (<name>uint32</name>) <name>sz</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_RemoveAsGCBytes</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>sz</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>size_t</name>) <name><name>rt</name>-&gt;<name>gcBytes</name></name> &gt;= <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcBytes</name></name> -= (<name>uint32</name>) <name>sz</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Shallow GC-things can be locked just by setting the GCF_LOCK bit, because
 * they have no descendants to mark during the GC. Currently the optimization
 * is only used for non-dependant strings.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_THING_IS_SHALLOW</name><parameter_list>(<param><type><name>flagp</name></type></param>, <param><type><name>thing</name></type></param>)</parameter_list></cpp:macro>                                     \
    <cpp:value>((flagp) &amp;&amp;                                                               \
     ((*(flagp) &amp; GCF_TYPEMASK) &gt;= GCX_EXTERNAL_STRING ||                     \
      ((*(flagp) &amp; GCF_TYPEMASK) == GCX_STRING &amp;&amp;                             \
       !((JSString *) (thing))-&gt;isDependent())))</cpp:value></cpp:define>

<comment type="block">/* This is compatible with JSDHashEntryStub. */</comment>
<typedef>typedef <type><struct>struct <name>JSGCLockHashEntry</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type> <name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name>      *</type><name>thing</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>count</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>JSGCLockHashEntry</name>;</typedef>

<function><type><name>JSBool</name></type>
<name>js_LockGCThingRT</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>void</name> *</type><name>thing</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>shallow</name></decl>, <decl><type ref="prev"/><name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name> *</type><name>flagp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCLockHashEntry</name> *</type><name>lhe</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>thing</name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>flagp</name> = <call><name>GetGCThingFlagsOrNull</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>shallow</name> = <call><name>GC_THING_IS_SHALLOW</name><argument_list>(<argument><expr><name>flagp</name></expr></argument>, <argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Avoid adding a rt-&gt;gcLocksHash entry for shallow things until someone
     * nests a lock.
     */</comment>
    <if>if <condition>(<expr><name>shallow</name> &amp;&amp; !(*<name>flagp</name> &amp; <name>GCF_LOCK</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>flagp</name> |= <name>GCF_LOCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>lock</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>gcLocksHash</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcLocksHash</name></name> = <call><name>JS_NewDHashTable</name><argument_list>(<argument><expr><call><name>JS_DHashGetStubOps</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSGCLockHashEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                           <argument><expr><name>GC_ROOTS_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>gcLocksHash</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <goto>goto <name>out</name>;</goto>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>lhe</name> = (<name>JSGCLockHashEntry</name> *)
          <call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcLocksHash</name></name></expr></argument>, <argument><expr><name>thing</name></expr></argument>, <argument><expr><name>JS_DHASH_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>lhe</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>
    <if>if <condition>(<expr>!<name><name>lhe</name>-&gt;<name>thing</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>lhe</name>-&gt;<name>thing</name></name> = <name>thing</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lhe</name>-&gt;<name>count</name></name> = 1</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>lhe</name>-&gt;<name>count</name></name> &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lhe</name>-&gt;<name>count</name></name>++</expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>lock</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
  <label><name>out</name>:</label>
    <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_UnlockGCThingRT</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>void</name> *</type><name>thing</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint8</name> *</type><name>flagp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>shallow</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCLockHashEntry</name> *</type><name>lhe</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>thing</name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>flagp</name> = <call><name>GetGCThingFlagsOrNull</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>shallow</name> = <call><name>GC_THING_IS_SHALLOW</name><argument_list>(<argument><expr><name>flagp</name></expr></argument>, <argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>shallow</name> &amp;&amp; !(*<name>flagp</name> &amp; <name>GCF_LOCK</name>)</expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>
    <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>gcLocksHash</name></name> ||
        (<name>lhe</name> = (<name>JSGCLockHashEntry</name> *)
         <call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcLocksHash</name></name></expr></argument>, <argument><expr><name>thing</name></expr></argument>,
                              <argument><expr><name>JS_DHASH_LOOKUP</name></expr></argument>)</argument_list></call>,
             <call><name>JS_DHASH_ENTRY_IS_FREE</name><argument_list>(<argument><expr>&amp;<name><name>lhe</name>-&gt;<name>hdr</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <comment type="block">/* Shallow entry is not in the hash -&gt; clear its lock bit. */</comment>
        <if>if <condition>(<expr><name>shallow</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>flagp</name> &amp;= ~<name>GCF_LOCK</name></expr>;</expr_stmt></then>
        <else>else
            <goto>goto <name>out</name>;</goto></else></if>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>--<name><name>lhe</name>-&gt;<name>count</name></name> != 0</expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
        <expr_stmt><expr><call><name>JS_DHashTableOperate</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcLocksHash</name></name></expr></argument>, <argument><expr><name>thing</name></expr></argument>, <argument><expr><name>JS_DHASH_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcPoke</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>unlock</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>out</name>:</label>
    <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<macro><name>JS_PUBLIC_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>JS_TraceChildren</name><argument_list>(<argument>JSTracer *trc</argument>, <argument>void *thing</argument>, <argument>uint32 kind</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>nslots</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name> *</type><name>str</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{
      <case>case <expr><name>JSTRACE_OBJECT</name></expr>:
        <comment type="block">/* If obj has no map, it must be a newborn. */</comment>
        <expr_stmt><expr><name>obj</name> = (<name>JSObject</name> *) <name>thing</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>obj</name>-&gt;<name>map</name></name></expr>)</condition><then>
            <break>break;</break></then></if>
        <if>if <condition>(<expr><name><name>obj</name>-&gt;<name>map</name>-&gt;<name>ops</name>-&gt;<name>trace</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>obj</name>-&gt;<name>map</name>-&gt;<name>ops</name>-&gt;<name>trace</name></name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>nslots</name> = <call><name>STOBJ_NSLOTS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <name>nslots</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <expr_stmt><expr><name>v</name> = <call><name>STOBJ_GET_SLOT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>JSVAL_IS_TRACEABLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_SET_TRACING_INDEX</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>"slot"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_CallTracer</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_TRACEABLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>JSVAL_TRACE_KIND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></else></if>
        <break>break;</break>

      </case><case>case <expr><name>JSTRACE_STRING</name></expr>:
        <expr_stmt><expr><name>str</name> = (<name>JSString</name> *)<name>thing</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>str</name>-&gt;<name>isDependent</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_CALL_STRING_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><call><name><name>str</name>-&gt;<name>dependentBase</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"base"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>JSTRACE_XML</name></expr>:
        <expr_stmt><expr><call><name>js_TraceXML</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>(<name>JSXML</name> *)<name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case>}</block></switch>
}</block>

<comment type="block">/*
 * Number of things covered by a single bit of JSGCArenaInfo.u.untracedThings.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THINGS_PER_UNTRACED_BIT</name><parameter_list>(<param><type><name>thingSize</name></type></param>)</parameter_list></cpp:macro>                                    \
    <cpp:value>JS_HOWMANY(THINGS_PER_ARENA(thingSize), JS_BITS_PER_WORD)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DelayTracingChildren</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>uint8</name> *</type><name>flagp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>untracedBitIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsuword</name></type> <name>bit</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Things with children to be traced later are marked with
     * GCF_MARK | GCF_FINAL flags.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(*<name>flagp</name> &amp; (<name>GCF_MARK</name> | <name>GCF_FINAL</name>)) == <name>GCF_MARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>flagp</name> |= <name>GCF_FINAL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>untraced</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr>++<name><name>rt</name>-&gt;<name>gcTraceLaterCount</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>METER_UPDATE_MAX</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>maxuntraced</name></name></expr></argument>, <argument><expr><name><name>rt</name>-&gt;<name>gcTraceLaterCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>a</name> = <call><name>FLAGP_TO_ARENA</name><argument_list>(<argument><expr><name>flagp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>untracedBitIndex</name> = <call><name>FLAGP_TO_INDEX</name><argument_list>(<argument><expr><name>flagp</name></expr></argument>)</argument_list></call> /
                       <call><name>THINGS_PER_UNTRACED_BIT</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>list</name>-&gt;<name>thingSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>untracedBitIndex</name> &lt; <name>JS_BITS_PER_WORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bit</name> = (<name>jsuword</name>)1 &lt;&lt; <name>untracedBitIndex</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>a</name>-&gt;<name>u</name>.<name>untracedThings</name></name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>a</name>-&gt;<name>u</name>.<name>untracedThings</name></name> &amp; <name>bit</name></expr>)</condition><then> <block>{
            <comment type="block">/* bit already covers things with children to trace later. */</comment>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>u</name>.<name>untracedThings</name></name> |= <name>bit</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * The thing is the first thing with not yet traced children in the
         * whole arena, so push the arena on the stack of arenas with things
         * to be traced later unless the arena has already been pushed. We
         * detect that through checking prevUntracedPage as the field is 0
         * only for not yet pushed arenas. To ensure that
         *   prevUntracedPage != 0
         * even when the stack contains one element, we make prevUntracedPage
         * for the arena at the bottom to point to itself.
         *
         * See comments in TraceDelayedChildren.
         */</comment>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>u</name>.<name>untracedThings</name></name> = <name>bit</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>a</name>-&gt;<name>prevUntracedPage</name></name> == 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name></expr>)</condition><then> <block>{
                <comment type="block">/* Stack was empty, mark the arena as the bottom element. */</comment>
                <expr_stmt><expr><name><name>a</name>-&gt;<name>prevUntracedPage</name></name> = <call><name>ARENA_INFO_TO_PAGE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name>-&gt;<name>prevUntracedPage</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>a</name>-&gt;<name>prevUntracedPage</name></name> =
                    <call><name>ARENA_INFO_TO_PAGE</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name> = <name>a</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>TraceDelayedChildren</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>aprev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>thingSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>thingsPerUntracedBit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>untracedBitIndex</name></decl>, <decl><type ref="prev"/><name>thingIndex</name></decl>, <decl><type ref="prev"/><name>indexLimit</name></decl>, <decl><type ref="prev"/><name>endIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCThing</name> *</type><name>thing</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name> *</type><name>flagp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rt</name> = <name><name>trc</name>-&gt;<name>context</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>a</name> = <name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>a</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcTraceLaterCount</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <comment type="block">/*
         * The following assert verifies that the current arena belongs to the
         * untraced stack, since DelayTracingChildren ensures that even for
         * stack's bottom prevUntracedPage != 0 but rather points to itself.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>prevUntracedPage</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name>-&gt;<name>prevUntracedPage</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>thingSize</name> = <name><name>a</name>-&gt;<name>list</name>-&gt;<name>thingSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>indexLimit</name> = (<name>a</name> == <name><name>a</name>-&gt;<name>list</name>-&gt;<name>last</name></name>)
                     ? <name><name>a</name>-&gt;<name>list</name>-&gt;<name>lastCount</name></name>
                     : <call><name>THINGS_PER_ARENA</name><argument_list>(<argument><expr><name>thingSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>thingsPerUntracedBit</name> = <call><name>THINGS_PER_UNTRACED_BIT</name><argument_list>(<argument><expr><name>thingSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We cannot use do-while loop here as a-&gt;u.untracedThings can be zero
         * before the loop as a leftover from the previous iterations. See
         * comments after the loop.
         */</comment>
        <while>while <condition>(<expr><name><name>a</name>-&gt;<name>u</name>.<name>untracedThings</name></name> != 0</expr>)</condition> <block>{
            <expr_stmt><expr><name>untracedBitIndex</name> = <call><name>JS_FLOOR_LOG2W</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>u</name>.<name>untracedThings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>u</name>.<name>untracedThings</name></name> &amp;= ~((<name>jsuword</name>)1 &lt;&lt; <name>untracedBitIndex</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>thingIndex</name> = <name>untracedBitIndex</name> * <name>thingsPerUntracedBit</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>endIndex</name> = <name>thingIndex</name> + <name>thingsPerUntracedBit</name></expr>;</expr_stmt>

            <comment type="block">/*
             * endIndex can go beyond the last allocated thing as the real
             * limit can be "inside" the bit.
             */</comment>
            <if>if <condition>(<expr><name>endIndex</name> &gt; <name>indexLimit</name></expr>)</condition><then>
                <expr_stmt><expr><name>endIndex</name> = <name>indexLimit</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>thingIndex</name> &lt; <name>indexLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <do>do <block>{
                <comment type="block">/*
                 * Skip free or already traced things that share the bit
                 * with untraced ones.
                 */</comment>
                <expr_stmt><expr><name>flagp</name> = <call><name>THING_FLAGP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>thingIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>(*<name>flagp</name> &amp; (<name>GCF_MARK</name>|<name>GCF_FINAL</name>)) != (<name>GCF_MARK</name>|<name>GCF_FINAL</name>)</expr>)</condition><then>
                    <continue>continue;</continue></then></if>
                <expr_stmt><expr>*<name>flagp</name> &amp;= ~<name>GCF_FINAL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcTraceLaterCount</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>--<name><name>rt</name>-&gt;<name>gcTraceLaterCount</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>thing</name> = <call><name>FLAGP_TO_THING</name><argument_list>(<argument><expr><name>flagp</name></expr></argument>, <argument><expr><name>thingSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_TraceChildren</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>thing</name></expr></argument>, <argument><expr><call><name>MapGCFlagsToTraceKind</name><argument_list>(<argument><expr>*<name>flagp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr>++<name>thingIndex</name> != <name>endIndex</name></expr>)</condition>;</do>
        }</block></while>

        <comment type="block">/*
         * We finished tracing of all things in the the arena but we can only
         * pop it from the stack if the arena is the stack's top.
         *
         * When JS_TraceChildren from the above calls JS_CallTracer that in
         * turn on low C stack calls DelayTracingChildren and the latter
         * pushes new arenas to the untraced stack, we have to skip popping
         * of this arena until it becomes the top of the stack again.
         */</comment>
        <if>if <condition>(<expr><name>a</name> == <name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>aprev</name> = <call><name>ARENA_PAGE_TO_INFO</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>prevUntracedPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>prevUntracedPage</name></name> = 0</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>a</name> == <name>aprev</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * prevUntracedPage points to itself and we reached the
                 * bottom of the stack.
                 */</comment>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name> = <name>a</name> = <name>aprev</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>a</name> = <name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name>-&gt;<name>prevUntracedPage</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcTraceLaterCount</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<macro><name>JS_PUBLIC_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>JS_CallTracer</name><argument_list>(<argument>JSTracer *trc</argument>, <argument>void *thing</argument>, <argument>uint32 kind</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name> *</type><name>flagp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JS_IS_VALID_TRACE_KIND</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>trc</name>-&gt;<name>debugPrinter</name></name> || <name><name>trc</name>-&gt;<name>debugPrintArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>IS_GC_MARKING_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>trc</name>-&gt;<name>callback</name></name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>thing</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><name>cx</name> = <name><name>trc</name>-&gt;<name>context</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rt</name> = <name><name>cx</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcMarkingTracer</name></name> == <name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcLevel</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Optimize for string and double as their size is known and their tracing
     * is not recursive.
     */</comment>
    <switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{
      <case>case <expr><name>JSTRACE_DOUBLE</name></expr>:
        <expr_stmt><expr><name>a</name> = <call><name>THING_TO_ARENA</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>a</name>-&gt;<name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>u</name>.<name>hasMarkedDoubles</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ClearDoubleArenaFlags</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>u</name>.<name>hasMarkedDoubles</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>index</name> = <call><name>DOUBLE_THING_TO_INDEX</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_SET_BIT</name><argument_list>(<argument><expr><call><name>DOUBLE_ARENA_BITMAP</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>

      </case><case>case <expr><name>JSTRACE_STRING</name></expr>:
        <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
            <expr_stmt><expr><name>flagp</name> = <call><name>THING_TO_FLAGP</name><argument_list>(<argument><expr><name>thing</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSGCThing</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(*<name>flagp</name> &amp; <name>GCF_FINAL</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>kind</name> == <call><name>MapGCFlagsToTraceKind</name><argument_list>(<argument><expr>*<name>flagp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!((<name>JSString</name> *) <name>thing</name>)-&gt;<call><name>isDependent</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>flagp</name> |= <name>GCF_MARK</name></expr>;</expr_stmt>
                <goto>goto <name>out</name>;</goto>
            }</block></then></if>
            <if>if <condition>(<expr>*<name>flagp</name> &amp; <name>GCF_MARK</name></expr>)</condition><then>
                <goto>goto <name>out</name>;</goto></then></if>
            <expr_stmt><expr>*<name>flagp</name> |= <name>GCF_MARK</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>thing</name> = ((<name>JSString</name> *) <name>thing</name>)-&gt;<call><name>dependentBase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <comment type="block">/* NOTREACHED */</comment>
    </case>}</block></switch>

    <expr_stmt><expr><name>flagp</name> = <call><name>GetGCThingFlags</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>kind</name> == <call><name>MapGCFlagsToTraceKind</name><argument_list>(<argument><expr>*<name>flagp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>flagp</name> &amp; <name>GCF_MARK</name></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>

    <comment type="block">/*
     * We check for non-final flag only if mark is unset as
     * DelayTracingChildren uses the flag. See comments in the function.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>flagp</name> != <name>GCF_FINAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>flagp</name> |= <name>GCF_MARK</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>cx</name>-&gt;<name>insideGCMarkCallback</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * With JS_GC_ASSUME_LOW_C_STACK defined the mark phase of GC always
         * uses the non-recursive code that otherwise would be called only on
         * a low C stack condition.
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GC_ASSUME_LOW_C_STACK</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>RECURSION_TOO_DEEP</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>JS_TRUE</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <decl_stmt><decl><type><name>int</name></type> <name>stackDummy</name></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>RECURSION_TOO_DEEP</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(!JS_CHECK_STACK_SIZE(cx, stackDummy))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr><call><name>RECURSION_TOO_DEEP</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>DelayTracingChildren</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>flagp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>JS_TraceChildren</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>thing</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * For API compatibility we allow for the callback to assume that
         * after it calls JS_MarkGCThing for the last time, the callback can
         * start to finalize its own objects that are only referenced by
         * unmarked GC things.
         *
         * Since we do not know which call from inside the callback is the
         * last, we ensure that children of all marked things are traced and
         * call TraceDelayedChildren(trc) after tracing the thing.
         *
         * As TraceDelayedChildren unconditionally invokes JS_TraceChildren
         * for the things with untraced children, calling DelayTracingChildren
         * is useless here. Hence we always trace thing's children even with a
         * low native stack.
         */</comment>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>insideGCMarkCallback</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_TraceChildren</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>thing</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TraceDelayedChildren</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>insideGCMarkCallback</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    }</block></else></if>

  <label><name>out</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>trc</name>-&gt;<name>debugPrinter</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>trc</name>-&gt;<name>debugPrintArg</name></name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return;</return>     <comment type="block">/* to avoid out: right_curl when DEBUG is not defined */</comment>
}</block>

<function><type><name>void</name></type>
<name>js_CallValueTracerIfGCThing</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>thing</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>kind</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JSVAL_IS_DOUBLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || <call><name>JSVAL_IS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>thing</name> = <call><name>JSVAL_TO_TRACEABLE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>kind</name> = <call><name>JSVAL_TRACE_KIND</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>kind</name> == <call><name>js_GetGCThingTraceKind</name><argument_list>(<argument><expr><call><name>JSVAL_TO_GCTHING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <name>v</name> != <name>JSVAL_NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* v can be an arbitrary GC thing reinterpreted as an object. */</comment>
        <expr_stmt><expr><name>thing</name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>kind</name> = <call><name>js_GetGCThingTraceKind</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <return>return;</return>
    }</block></else></if></else></if>
    <expr_stmt><expr><call><name>JS_CallTracer</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>thing</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JSDHashOperator</name></type>
<name>gc_root_traversal</name><parameter_list>(<param><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl></param>, <param><decl><type><name>JSDHashEntryHdr</name> *</type><name>hdr</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>num</name></decl></param>,
                  <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSGCRootHashEntry</name> *</type><name>rhe</name> <init>= <expr>(<name>JSGCRootHashEntry</name> *)<name>hdr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTracer</name> *</type><name>trc</name> <init>= <expr>(<name>JSTracer</name> *)<name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name> *</type><name>rp</name> <init>= <expr>(<name>jsval</name> *)<name><name>rhe</name>-&gt;<name>root</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name> <init>= <expr>*<name>rp</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Ignore null object and scalar values. */</comment>
    <if>if <condition>(<expr>!<call><name>JSVAL_IS_NULL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JSVAL_IS_GCTHING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <decl_stmt><decl><type><name>JSBool</name></type> <name>root_points_to_gcArenaList</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsuword</name></type> <name>thing</name> <init>= <expr>(<name>jsuword</name>) <call><name>JSVAL_TO_GCTHING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSGCArenaList</name> *</type><name>arenaList</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>thingSize</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>limit</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rt</name> = <name><name>trc</name>-&gt;<name>context</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>GC_NUM_FREELISTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>arenaList</name> = &amp;<name><name>rt</name>-&gt;<name>gcArenaList</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>thingSize</name> = <name><name>arenaList</name>-&gt;<name>thingSize</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>limit</name> = (<name>size_t</name>) <name><name>arenaList</name>-&gt;<name>lastCount</name></name> * <name>thingSize</name></expr>;</expr_stmt>
            <for>for (<init><expr><name>a</name> = <name><name>arenaList</name>-&gt;<name>last</name></name></expr>;</init> <condition><expr><name>a</name></expr>;</condition> <incr><expr><name>a</name> = <name><name>a</name>-&gt;<name>prev</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr><name>thing</name> - <call><name>ARENA_INFO_TO_START</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; <name>limit</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>root_points_to_gcArenaList</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><name>limit</name> = (<name>size_t</name>) <call><name>THINGS_PER_ARENA</name><argument_list>(<argument><expr><name>thingSize</name></expr></argument>)</argument_list></call> * <name>thingSize</name></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <if>if <condition>(<expr>!<name>root_points_to_gcArenaList</name></expr>)</condition><then> <block>{
            <for>for (<init><expr><name>a</name> = <name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name></expr>;</init> <condition><expr><name>a</name></expr>;</condition> <incr><expr><name>a</name> = <name><name>a</name>-&gt;<name>prev</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr><name>thing</name> - <call><name>ARENA_INFO_TO_START</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt;
                    <name>DOUBLES_PER_ARENA</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>jsdouble</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>root_points_to_gcArenaList</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>root_points_to_gcArenaList</name> &amp;&amp; <name><name>rhe</name>-&gt;<name>name</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr>"JS API usage error: the address passed to JS_AddNamedRoot currently holds an\n"
"invalid jsval.  This is usually caused by a missing call to JS_RemoveRoot.\n"
"The root's name is \"%s\".\n"</expr></argument>,
                    <argument><expr><name><name>rhe</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>root_points_to_gcArenaList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>JS_SET_TRACING_NAME</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>rhe</name>-&gt;<name>name</name></name> ? <name><name>rhe</name>-&gt;<name>name</name></name> : "root"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_CallValueTracerIfGCThing</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>JS_DHASH_NEXT</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSDHashOperator</name></type>
<name>gc_lock_traversal</name><parameter_list>(<param><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl></param>, <param><decl><type><name>JSDHashEntryHdr</name> *</type><name>hdr</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>num</name></decl></param>,
                  <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSGCLockHashEntry</name> *</type><name>lhe</name> <init>= <expr>(<name>JSGCLockHashEntry</name> *)<name>hdr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>thing</name> <init>= <expr>(<name>void</name> *)<name><name>lhe</name>-&gt;<name>thing</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTracer</name> *</type><name>trc</name> <init>= <expr>(<name>JSTracer</name> *)<name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>traceKind</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>lhe</name>-&gt;<name>count</name></name> &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>traceKind</name> = <call><name>js_GetGCThingTraceKind</name><argument_list>(<argument><expr><name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_CALL_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>thing</name></expr></argument>, <argument><expr><name>traceKind</name></expr></argument>, <argument><expr>"locked object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_DHASH_NEXT</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE_JSVALS</name><parameter_list>(<param><type><name>trc</name></type></param>, <param><type><name>len</name></type></param>, <param><type><name>vec</name></type></param>, <param><type><name>name</name></type></param>)</parameter_list></cpp:macro>                                     \
    <cpp:value>JS_BEGIN_MACRO                                                            \
    jsval _v, *_vp, *_end;                                                    \
                                                                              \
        for (_vp = vec, _end = _vp + len; _vp &lt; _end; _vp++) {                \
            _v = *_vp;                                                        \
            if (JSVAL_IS_TRACEABLE(_v)) {                                     \
                JS_SET_TRACING_INDEX(trc, name, _vp - (vec));                 \
                JS_CallTracer(trc, JSVAL_TO_TRACEABLE(_v),                    \
                              JSVAL_TRACE_KIND(_v));                          \
            }                                                                 \
        }                                                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>js_TraceStackFrame</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>nslots</name></decl>, <decl><type ref="prev"/><name>minargs</name></decl>, <decl><type ref="prev"/><name>skip</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>callobj</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>callobj</name></name></expr></argument>, <argument><expr>"call"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>argsobj</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>argsobj</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>varobj</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>varobj</name></name></expr></argument>, <argument><expr>"variables"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>script</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_TraceScript</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>script</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* fp-&gt;slots is null for watch pseudo-frames, see js_watch_set. */</comment>
        <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>slots</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Don't mark what has not been pushed yet, or what has been
             * popped already.
             */</comment>
            <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>regs</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>nslots</name> = <call>(<name>uintN</name>) <argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>regs</name>-&gt;<name>sp</name></name> - <name><name>fp</name>-&gt;<name>slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>nslots</name> &gt;= <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>nslots</name> = <name><name>fp</name>-&gt;<name>script</name>-&gt;<name>nfixed</name></name></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><call><name>TRACE_JSVALS</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>nslots</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>slots</name></name></expr></argument>, <argument><expr>"slot"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>fp</name>-&gt;<name>slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>fp</name>-&gt;<name>regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Allow for primitive this parameter due to JSFUN_THISP_* flags. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_OBJECT</name><argument_list>(<argument><expr>(<name>jsval</name>)<name><name>fp</name>-&gt;<name>thisp</name></name></expr></argument>)</argument_list></call> ||
              (<name><name>fp</name>-&gt;<name>fun</name></name> &amp;&amp; <call><name>JSFUN_THISP_FLAGS</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>flags</name></name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_CALL_VALUE_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>(<name>jsval</name>)<name><name>fp</name>-&gt;<name>thisp</name></name></expr></argument>, <argument><expr>"this"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>callee</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>callee</name></name></expr></argument>, <argument><expr>"callee"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>argv</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nslots</name> = <name><name>fp</name>-&gt;<name>argc</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>skip</name> = 0</expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>fun</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>minargs</name> = <call><name>FUN_MINARGS</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>minargs</name> &gt; <name>nslots</name></expr>)</condition><then>
                <expr_stmt><expr><name>nslots</name> = <name>minargs</name></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr>!<call><name>FUN_INTERPRETED</name><argument_list>(<argument><expr><name><name>fp</name>-&gt;<name>fun</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!(<name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFUN_FAST_NATIVE</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nslots</name> += <name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>u</name>.<name>n</name>.<name>extra</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>fun</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_ROOTED_ARGV</name></expr>)</condition><then>
                <expr_stmt><expr><name>skip</name> = 2 + <name><name>fp</name>-&gt;<name>argc</name></name></expr>;</expr_stmt></then></if>
        }</block></then></if>
        <expr_stmt><expr><call><name>TRACE_JSVALS</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>2 + <name>nslots</name> - <name>skip</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>argv</name></name> - 2 + <name>skip</name></expr></argument>, <argument><expr>"operand"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_CALL_VALUE_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>rval</name></name></expr></argument>, <argument><expr>"rval"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>scopeChain</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>scopeChain</name></name></expr></argument>, <argument><expr>"scope chain"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>sharpArray</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>sharpArray</name></name></expr></argument>, <argument><expr>"sharp array"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>xmlNamespace</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>fp</name>-&gt;<name>xmlNamespace</name></name></expr></argument>, <argument><expr>"xmlNamespace"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>TraceWeakRoots</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSWeakRoots</name> *</type><name>wr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>thing</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>weakRootNames</name><index>[<expr><name>JSTRACE_LIMIT</name></expr>]</index></name> <init>= <expr><block>{
        <expr>"newborn object"</expr>,
        <expr>"newborn double"</expr>,
        <expr>"newborn string"</expr>,
        <expr>"newborn xml"</expr>
    }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <name>JSTRACE_LIMIT</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>thing</name> = <name><name>wr</name>-&gt;<name>newborn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>thing</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_CALL_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>thing</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>weakRootNames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>i</name> == <name>GCX_EXTERNAL_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>i</name> != <name>GCX_NTYPES</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><name>thing</name> = <name><name>wr</name>-&gt;<name>newborn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>thing</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_SET_TRACING_INDEX</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>"newborn external string"</expr></argument>,
                                 <argument><expr><name>i</name> - <name>GCX_EXTERNAL_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_CallTracer</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>thing</name></expr></argument>, <argument><expr><name>JSTRACE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <expr_stmt><expr><call><name>JS_CALL_VALUE_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>wr</name>-&gt;<name>lastAtom</name></name></expr></argument>, <argument><expr>"lastAtom"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_SET_TRACING_NAME</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>"lastInternalResult"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_CallValueTracerIfGCThing</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>wr</name>-&gt;<name>lastInternalResult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><name>JS_REQUIRES_STACK</name></type> <name>JS_FRIEND_API</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
<name>js_TraceContext</name><argument_list>(<argument><expr><name>JSTracer</name> *<name>trc</name></expr></argument>, <argument><expr><name>JSContext</name> *<name>acx</name></expr></argument>)</argument_list>
<argument_list>{
    <argument><expr><name>JSStackFrame</name> *<name>fp</name></expr></argument>, <argument><expr>*<name>nextChain</name></expr></argument>;
    <argument><expr><name>JSStackHeader</name> *<name>sh</name></expr></argument>;
    <argument><expr><name>JSTempValueRooter</name> *<name>tvr</name></expr></argument>;

    if <argument><expr>(<call><name>IS_GC_MARKING_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call>) <block>{

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_OLD_ARENAS</name><parameter_list>(<param><type><name>pool</name></type></param>)</parameter_list></cpp:macro>                                                 \
        <cpp:value>JS_BEGIN_MACRO                                                        \
            int64 _age;                                                       \
            JSArena * _a = (pool).current;                                    \
            if (_a == (pool).first.next &amp;&amp;                                    \
                _a-&gt;avail == _a-&gt;base + sizeof(int64)) {                      \
                _age = JS_Now() - *(int64 *) _a-&gt;base;                        \
                if (_age &gt; (int64) acx-&gt;runtime-&gt;gcEmptyArenaPoolLifespan *   \
                           1000)                                              \
                    JS_FreeArenaPool(&amp;(pool));                                \
            }                                                                 \
        JS_END_MACRO</cpp:value></cpp:define>

        <comment type="block">/*
         * Release the stackPool's arenas if the stackPool has existed for
         * longer than the limit specified by gcEmptyArenaPoolLifespan.
         */</comment>
        <expr><call><name>FREE_OLD_ARENAS</name><argument_list>(<argument><expr><name><name>acx</name>-&gt;<name>stackPool</name></name></expr></argument>)</argument_list></call></expr>;

        <comment type="block">/*
         * Release the regexpPool's arenas based on the same criterion as for
         * the stackPool.
         */</comment>
        <expr><call><name>FREE_OLD_ARENAS</name><argument_list>(<argument><expr><name><name>acx</name>-&gt;<name>regexpPool</name></name></expr></argument>)</argument_list></call></expr>;

        <comment type="block">/*
         * Clear the double free list to release all the pre-allocated doubles.
         */</comment>
        <expr><name><name>acx</name>-&gt;<name>doubleFreeList</name></name> = <name>NULL</name></expr>;
    }</block></expr></argument>

    <comment type="block">/*
     * Iterate frame chain and dormant chains.
     *
     * (NB: see comment on this whole "dormant" thing in js_Execute.)
     *
     * Since js_GetTopStackFrame needs to dereference cx-&gt;thread to check for
     * JIT frames, we check for non-null thread here and avoid null checks
     * there. See bug 471197.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>acx</name>-&gt;<name>thread</name></name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><block>{
        <expr><name>fp</name> = <call><name>js_GetTopStackFrame</name><argument_list>(<argument><expr><name>acx</name></expr></argument>)</argument_list></call></expr>;
        <name>nextChain</name> = <name><name>acx</name>-&gt;<name>dormantFrameChain</name></name></block></expr>;</expr_stmt></then></if></argument_list></decl></decl_stmt>
        <if>if <condition>(<expr>!<name>fp</name></expr>)</condition><then>
            <goto>goto <name>next_chain</name>;</goto></then></if>

        <comment type="block">/* The top frame must not be dormant. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>fp</name>-&gt;<name>dormantNext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
            <do>do <block>{
                <expr_stmt><expr><call><name>js_TraceStackFrame</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr>(<name>fp</name> = <name><name>fp</name>-&gt;<name>down</name></name>) != <name>NULL</name></expr>)</condition>;</do>

          <label><name>next_chain</name>:</label>
            <if>if <condition>(<expr>!<name>nextChain</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr><name>fp</name> = <name>nextChain</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nextChain</name> = <name><name>nextChain</name>-&gt;<name>dormantNext</name></name></expr>;</expr_stmt>
        }</block></for>
    }

    <comment type="block">/* Mark other roots-by-definition in acx. */</comment>
    if <expr_stmt><expr>(<name><name>acx</name>-&gt;<name>globalObject</name></name> &amp;&amp; !<call><name>JS_HAS_OPTION</name><argument_list>(<argument><expr><name>acx</name></expr></argument>, <argument><expr><name>JSOPTION_UNROOTED_GLOBAL</name></expr></argument>)</argument_list></call>)
        <call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>acx</name>-&gt;<name>globalObject</name></name></expr></argument>, <argument><expr>"global object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TraceWeakRoots</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>&amp;<name><name>acx</name>-&gt;<name>weakRoots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>acx</name>-&gt;<name>throwing</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_CALL_VALUE_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>acx</name>-&gt;<name>exception</name></name></expr></argument>, <argument><expr>"exception"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/* Avoid keeping GC-ed junk stored in JSContext.exception. */</comment>
        <expr_stmt><expr><name><name>acx</name>-&gt;<name>exception</name></name> = <name>JSVAL_NULL</name></expr>;</expr_stmt>
    }</block></else></if>

    <for>for (<init><expr><name>sh</name> = <name><name>acx</name>-&gt;<name>stackHeaders</name></name></expr>;</init> <condition><expr><name>sh</name></expr>;</condition> <incr><expr><name>sh</name> = <name><name>sh</name>-&gt;<name>down</name></name></expr></incr>) <block>{
        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>trc</name>-&gt;<name>context</name>-&gt;<name>runtime</name>-&gt;<name>gcStats</name>.<name>stackseg</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>trc</name>-&gt;<name>context</name>-&gt;<name>runtime</name>-&gt;<name>gcStats</name>.<name>segslots</name></name> += <name><name>sh</name>-&gt;<name>nslots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TRACE_JSVALS</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>sh</name>-&gt;<name>nslots</name></name></expr></argument>, <argument><expr><call><name>JS_STACK_SEGMENT</name><argument_list>(<argument><expr><name>sh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"stack"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr><name><name>acx</name>-&gt;<name>localRootStack</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_TraceLocalRoots</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>acx</name>-&gt;<name>localRootStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <for>for (<init><expr><name>tvr</name> = <name><name>acx</name>-&gt;<name>tempValueRooters</name></name></expr>;</init> <condition><expr><name>tvr</name></expr>;</condition> <incr><expr><name>tvr</name> = <name><name>tvr</name>-&gt;<name>down</name></name></expr></incr>) <block>{
        <switch>switch <condition>(<expr><name><name>tvr</name>-&gt;<name>count</name></name></expr>)</condition> <block>{
          <case>case <expr><name>JSTVU_SINGLE</name></expr>:
            <expr_stmt><expr><call><name>JS_SET_TRACING_NAME</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>"tvr-&gt;u.value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_CallValueTracerIfGCThing</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>tvr</name>-&gt;<name>u</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSTVU_TRACE</name></expr>:
            <expr_stmt><expr><call><name><name>tvr</name>-&gt;<name>u</name>.<name>trace</name></name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>tvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSTVU_SPROP</name></expr>:
            <expr_stmt><expr><call><name><name>tvr</name>-&gt;<name>u</name>.<name>sprop</name>-&gt;<name>trace</name></name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSTVU_WEAK_ROOTS</name></expr>:
            <expr_stmt><expr><call><name>TraceWeakRoots</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>tvr</name>-&gt;<name>u</name>.<name>weakRoots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSTVU_COMPILER</name></expr>:
            <expr_stmt><expr><call><name><name>tvr</name>-&gt;<name>u</name>.<name>compiler</name>-&gt;<name>trace</name></name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSTVU_SCRIPT</name></expr>:
            <expr_stmt><expr><call><name>js_TraceScript</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>tvr</name>-&gt;<name>u</name>.<name>script</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><default>default:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>tvr</name>-&gt;<name>count</name></name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TRACE_JSVALS</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>tvr</name>-&gt;<name>count</name></name></expr></argument>, <argument><expr><name><name>tvr</name>-&gt;<name>u</name>.<name>array</name></name></expr></argument>, <argument><expr>"tvr-&gt;u.array"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
    }</block></for>

    <if>if <condition>(<expr><name><name>acx</name>-&gt;<name>sharpObjectMap</name>.<name>depth</name></name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>js_TraceSharpMap</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr>&amp;<name><name>acx</name>-&gt;<name>sharpObjectMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>js_TraceRegExpStatics</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>acx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>acx</name>-&gt;<name>nativeVp</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>TRACE_JSVALS</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>acx</name>-&gt;<name>nativeVpLen</name></name></expr></argument>, <argument><expr><name><name>acx</name>-&gt;<name>nativeVp</name></name></expr></argument>, <argument><expr>"nativeVp"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>

static <function><type><name>void</name></type>
<name>MarkReservedObjects</name><parameter_list>(<param><decl><type><name>JSTraceMonitor</name> *</type><name>tm</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Keep the reserved objects. */</comment>
    <for>for (<init><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><name><name>tm</name>-&gt;<name>reservedObjects</name></name></expr></init></decl>;</init> <condition><expr><name>obj</name></expr>;</condition> <incr><expr><name>obj</name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><name><name>obj</name>-&gt;<name>fslots</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <decl_stmt><decl><type><name>uint8</name> *</type><name>flagp</name> <init>= <expr><call><name>GetGCThingFlags</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(*<name>flagp</name> &amp; <name>GCF_TYPEMASK</name>) == <name>GCX_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>flagp</name> != <name>GCF_FINAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>flagp</name> |= <name>GCF_MARK</name></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>JSDHashOperator</name></type>
<name>reserved_objects_marker</name><parameter_list>(<param><decl><type><name>JSDHashTable</name> *</type><name>table</name></decl></param>, <param><decl><type><name>JSDHashEntryHdr</name> *</type><name>hdr</name></decl></param>,
                        <param><decl><type><name>uint32</name></type></decl></param>, <param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSThread</name> *</type><name>thread</name> <init>= <expr>((<name>JSThreadsHashEntry</name> *) <name>hdr</name>)-&gt;<name>thread</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>MarkReservedObjects</name><argument_list>(<argument><expr>&amp;<name><name>thread</name>-&gt;<name>data</name>.<name>traceMonitor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_DHASH_NEXT</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>JS_REQUIRES_STACK</name> <name>void</name></type>
<name>js_TraceRuntime</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>allAtoms</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name> <init>= <expr><name><name>trc</name>-&gt;<name>context</name>-&gt;<name>runtime</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSContext</name> *</type><name>iter</name></decl>, *<decl><type ref="prev"/><name>acx</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_DHashTableEnumerate</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcRootsHash</name></name></expr></argument>, <argument><expr><name>gc_root_traversal</name></expr></argument>, <argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcLocksHash</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_DHashTableEnumerate</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcLocksHash</name></name></expr></argument>, <argument><expr><name>gc_lock_traversal</name></expr></argument>, <argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>js_TraceAtomState</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>allAtoms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_TraceNativeEnumerators</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_TraceRuntimeNumberState</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>iter</name> = <name>NULL</name></expr>;</expr_stmt>
    <while>while <condition>(<expr>(<name>acx</name> = <call><name>js_ContextIterator</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>, <argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition>
        <expr_stmt><expr><call><name>js_TraceContext</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name>acx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>

    <expr_stmt><expr><call><name>js_TraceThreads</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcExtraRootsTraceOp</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>rt</name>-&gt;<name>gcExtraRootsTraceOp</name></name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>rt</name>-&gt;<name>gcExtraRootsData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>JSBUILTIN_LIMIT</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>builtinFunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_CALL_OBJECT_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>, <argument><expr><name><name>rt</name>-&gt;<name>builtinFunctions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>"builtin function"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>

    <comment type="block">/* Mark the reserved objects unless we are shutting down. */</comment>
    <if>if <condition>(<expr><call><name>IS_GC_MARKING_TRACER</name><argument_list>(<argument><expr><name>trc</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>rt</name>-&gt;<name>state</name></name> != <name>JSRTS_LANDING</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <expr_stmt><expr><call><name>JS_DHashTableEnumerate</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>threads</name></name></expr></argument>, <argument><expr><name>reserved_objects_marker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>MarkReservedObjects</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>threadData</name>.<name>traceMonitor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type>
<name>js_TriggerGC</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>gcLocked</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name> <init>= <expr><name><name>cx</name>-&gt;<name>runtime</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>requestDepth</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>rt</name>-&gt;<name>gcRunning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcIsNeeded</name></name></expr>)</condition><then>
        <return>return;</return></then></if>

    <comment type="block">/*
     * Trigger the GC when it is safe to call an operation callback on any
     * thread.
     */</comment>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcIsNeeded</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_TriggerAllOperationCallbacks</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>gcLocked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessSetSlotRequest</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSSetSlotRequest</name> *</type><name>ssr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name> <init>= <expr><name><name>ssr</name>-&gt;<name>obj</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>pobj</name> <init>= <expr><name><name>ssr</name>-&gt;<name>pobj</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>slot</name> <init>= <expr><name><name>ssr</name>-&gt;<name>slot</name></name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>pobj</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>pobj</name> = <call><name>js_GetWrappedObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pobj</name> == <name>obj</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ssr</name>-&gt;<name>cycle</name></name> = true</expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name>pobj</name> = <call><name>JSVAL_TO_OBJECT</name><argument_list>(<argument><expr><call><name>STOBJ_GET_SLOT</name><argument_list>(<argument><expr><name>pobj</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name>pobj</name> = <name><name>ssr</name>-&gt;<name>pobj</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>slot</name> == <name>JSSLOT_PROTO</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>STOBJ_SET_PROTO</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>slot</name> == <name>JSSLOT_PARENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>STOBJ_SET_PARENT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>pobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><name>void</name></type>
<name>js_DestroyScriptsToGC</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSThreadData</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSScript</name> **</type><name>listp</name></decl>, *<decl><type ref="prev"/><name>script</name></decl>;</decl_stmt>

    <for>for (<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> != <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name><name>data</name>-&gt;<name>scriptsToGC</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><name>listp</name> = &amp;<name><name>data</name>-&gt;<name>scriptsToGC</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <while>while <condition>(<expr>(<name>script</name> = *<name>listp</name>) != <name>NULL</name></expr>)</condition> <block>{
            <expr_stmt><expr>*<name>listp</name> = <name><name>script</name>-&gt;<name>u</name>.<name>nextToGC</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>script</name>-&gt;<name>u</name>.<name>nextToGC</name></name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_DestroyScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinalizeObject</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>obj</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Cope with stillborn objects that have no map. */</comment>
    <if>if <condition>(<expr>!<name><name>obj</name>-&gt;<name>map</name></name></expr>)</condition><then>
        <return>return;</return></then></if>

    <if>if <condition>(<expr><call><name>JS_UNLIKELY</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>objectHook</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>objectHook</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>,
                                   <argument><expr><name><name>cx</name>-&gt;<name>debugHooks</name>-&gt;<name>objectHookData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Finalize obj first, in case it needs map and slots. */</comment>
    <decl_stmt><decl><type><name>JSClass</name> *</type><name>clasp</name> <init>= <expr><call><name>STOBJ_GET_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>clasp</name>-&gt;<name>finalize</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>clasp</name>-&gt;<name>finalize</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INCLUDE_MOZILLA_DTRACE</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>JAVASCRIPT_OBJECT_FINALIZE_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>jsdtrace_object_finalize</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><call><name>JS_LIKELY</name><argument_list>(<argument><expr><call><name>OBJ_IS_NATIVE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<call><name>drop</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>js_FreeSlots</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>JSStringFinalizeOp</name></type> <name><name>str_finalizers</name><index>[<expr><name>GCX_NTYPES</name> - <name>GCX_EXTERNAL_STRING</name></expr>]</index></name> <init>= <expr><block>{
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>intN</name></type>
<name>js_ChangeExternalStringFinalizer</name><parameter_list>(<param><decl><type><name>JSStringFinalizeOp</name></type> <name>oldop</name></decl></param>,
                                 <param><decl><type><name>JSStringFinalizeOp</name></type> <name>newop</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>str_finalizers</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>str_finalizers</name><index>[<expr><name>i</name></expr>]</index></name> == <name>oldop</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>str_finalizers</name><index>[<expr><name>i</name></expr>]</index></name> = <name>newop</name></expr>;</expr_stmt>
            <return>return <expr>(<name>intN</name>) <name>i</name></expr>;</return>
        }</block></then></if>
    }</block></for>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/*
 * cx is NULL when we are called from js_FinishAtomState to force the
 * finalization of the permanently interned strings.
 */</comment>
<function><type><name>void</name></type>
<name>js_FinalizeStringRT</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>str</name></decl></param>, <param><decl><type><name>intN</name></type> <name>type</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jschar</name> *</type><name>chars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>valid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStringFinalizeOp</name></type> <name>finalizer</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_RUNTIME_UNMETER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>liveStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name><name>str</name>-&gt;<name>isDependent</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* A dependent string can not be external and must be valid. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> &lt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name><name>str</name>-&gt;<name>dependentBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_RUNTIME_UNMETER</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>liveDependentStrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>valid</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/* A stillborn string has null chars, so is not valid. */</comment>
        <expr_stmt><expr><name>chars</name> = <call><name><name>str</name>-&gt;<name>flatChars</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>valid</name> = (<name>chars</name> != <name>NULL</name>)</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>valid</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>IN_UNIT_STRING_SPACE_RT</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>unitStrings</name><index>[<expr>*<name>chars</name></expr>]</index></name> == <name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> &lt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rt</name>-&gt;<name>unitStrings</name><index>[<expr>*<name>chars</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr><name>type</name> &lt; 0</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>cx</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><call><name><name>rt</name>-&gt;<name>free</name></name><argument_list>(<argument><expr><name>chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>uintN</name>) <name>type</name> &lt; <call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>str_finalizers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>finalizer</name> = <name><name>str_finalizers</name><index>[<expr><name>type</name></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>finalizer</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * Assume that the finalizer for the permanently interned
                     * string knows how to deal with null context.
                     */</comment>
                    <expr_stmt><expr><call><name>finalizer</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if></else></if>
        }</block></then></if>
    }</block></else></if>
    <if>if <condition>(<expr><name>valid</name> &amp;&amp; <call><name><name>str</name>-&gt;<name>isDeflated</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>js_PurgeDeflatedStringCache</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/*
 * The gckind flag bit GC_LOCK_HELD indicates a call from js_NewGCThing with
 * rt-&gt;gcLock already held, so the lock should be kept on return.
 */</comment>
<function><type><name>void</name></type>
<name>js_GC</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSGCInvocationKind</name></type> <name>gckind</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>keepAtoms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCCallback</name></type> <name>callback</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTracer</name></type> <name>trc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>thingSize</name></decl>, <decl><type ref="prev"/><name>indexLimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaInfo</name> *</type><name>a</name></decl>, **<decl><type ref="prev"/><name>ap</name></decl>, *<decl><type ref="prev"/><name>emptyArenas</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type> <name>flags</name></decl>, *<decl><type ref="prev"/><name>flagp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCThing</name> *</type><name>thing</name></decl>, *<decl><type ref="prev"/><name>freeList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaList</name> *</type><name>arenaList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>allClear</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uint32</name></type> <name>requestDebit</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GCMETER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uint32</name></type> <name>nlivearenas</name></decl>, <decl><type ref="prev"/><name>nkilledarenas</name></decl>, <decl><type ref="prev"/><name>nthings</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>gckind</name> == <name>GC_LAST_DITCH</name></expr></argument>, <argument><expr>!<call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rt</name> = <name><name>cx</name>-&gt;<name>runtime</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/*
     * We allow js_GC calls outside a request but the context must be bound
     * to the current thread.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_THREAD_IS_ME</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>thread</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Avoid deadlock. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JS_IS_RUNTIME_LOCKED</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>gckind</name> &amp; <name>GC_KEEP_ATOMS</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * The set slot request and last ditch GC kinds preserve all atoms and
         * weak roots.
         */</comment>
        <expr_stmt><expr><name>keepAtoms</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/* Keep atoms when a suspended compile is running on another context. */</comment>
        <expr_stmt><expr><name>keepAtoms</name> = (<name><name>rt</name>-&gt;<name>gcKeepAtoms</name></name> != 0)</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_CLEAR_WEAK_ROOTS</name><argument_list>(<argument><expr>&amp;<name><name>cx</name>-&gt;<name>weakRoots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*
     * Don't collect garbage if the runtime isn't up, and cx is not the last
     * context in the runtime.  The last context must force a GC, and nothing
     * should suppress that final collection or there may be shutdown leaks,
     * or runtime bloat until the next context is created.
     */</comment>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>state</name></name> != <name>JSRTS_UP</name> &amp;&amp; <name>gckind</name> != <name>GC_LAST_CONTEXT</name></expr>)</condition><then>
        <return>return;</return></then></if>

  <label><name>restart_at_beginning</name>:</label>
    <comment type="block">/*
     * Let the API user decide to defer a GC if it wants to (unless this
     * is the last context).  Invoke the callback regardless. Sample the
     * callback in case we are freely racing with a JS_SetGCCallback{,RT} on
     * another thread.
     */</comment>
    <if>if <condition>(<expr><name>gckind</name> != <name>GC_SET_SLOT_REQUEST</name> &amp;&amp; (<name>callback</name> = <name><name>rt</name>-&gt;<name>gcCallback</name></name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>gckind</name> &amp; <name>GC_LOCK_HELD</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>ok</name> = <call><name>callback</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSGC_BEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>gckind</name> &amp; <name>GC_LOCK_HELD</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr>!<name>ok</name> &amp;&amp; <name>gckind</name> != <name>GC_LAST_CONTEXT</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * It's possible that we've looped back to this code from the 'goto
             * restart_at_beginning' below in the GC_SET_SLOT_REQUEST code and
             * that rt-&gt;gcLevel is now 0. Don't return without notifying!
             */</comment>
            <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcLevel</name></name> == 0 &amp;&amp; (<name>gckind</name> &amp; <name>GC_LOCK_HELD</name>)</expr>)</condition><then>
                <expr_stmt><expr><call><name>JS_NOTIFY_GC_DONE</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <return>return;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Lock out other GC allocator and collector invocations. */</comment>
    <if>if <condition>(<expr>!(<name>gckind</name> &amp; <name>GC_LOCK_HELD</name>)</expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>poke</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcPoke</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/*
     * Check if the GC is already running on this or another thread and
     * delegate the job to it.
     */</comment>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcLevel</name></name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Bump gcLevel to restart the current GC, so it finds new garbage. */</comment>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcLevel</name></name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>METER_UPDATE_MAX</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>maxlevel</name></name></expr></argument>, <argument><expr><name><name>rt</name>-&gt;<name>gcLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the GC runs on another thread, temporarily suspend the current
         * request and wait until the GC is done.
         */</comment>
        <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcThread</name></name> != <name><name>cx</name>-&gt;<name>thread</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>requestDebit</name> = <call><name>js_DiscountRequestsForGC</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>js_RecountRequestsAfterGC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>requestDebit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>!(<name>gckind</name> &amp; <name>GC_LOCK_HELD</name>)</expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* No other thread is in GC, so indicate that we're now in GC. */</comment>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcLevel</name></name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcThread</name></name> = <name><name>cx</name>-&gt;<name>thread</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Notify all operation callbacks, which will give them a chance to
     * yield their current request. Contexts that are not currently
     * executing will perform their callback at some later point,
     * which then will be unnecessary, but harmless.
     */</comment>
    <expr_stmt><expr><call><name>js_NudgeOtherContexts</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Discount all the requests on the current thread from contributing
     * to rt-&gt;requestCount before we wait for all other requests to finish.
     * JS_NOTIFY_REQUEST_DONE, which will wake us up, is only called on
     * rt-&gt;requestCount transitions to 0.
     */</comment>
    <expr_stmt><expr><name>requestDebit</name> = <call><name>js_CountThreadRequests</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>requestDepth</name></name> != 0</expr></argument>, <argument><expr><name>requestDebit</name> &gt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>requestCount</name></name> -= <name>requestDebit</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>rt</name>-&gt;<name>requestCount</name></name> &gt; 0</expr>)</condition>
        <expr_stmt><expr><call><name>JS_AWAIT_REQUEST_DONE</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>requestCount</name></name> += <name>requestDebit</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* !JS_THREADSAFE */</comment>

    <comment type="block">/* Bump gcLevel and return rather than nest; the outer gc will restart. */</comment>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcLevel</name></name>++</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>METER_UPDATE_MAX</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcStats</name>.<name>maxlevel</name></name></expr></argument>, <argument><expr><name><name>rt</name>-&gt;<name>gcLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcLevel</name></name> &gt; 1</expr>)</condition><then>
        <return>return;</return></then></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !JS_THREADSAFE */</comment>

    <comment type="block">/*
     * Set rt-&gt;gcRunning here within the GC lock, and after waiting for any
     * active requests to end, so that new requests that try to JS_AddRoot,
     * JS_RemoveRoot, or JS_RemoveRootRT block in JS_BeginRequest waiting for
     * rt-&gt;gcLevel to drop to zero, while request-less calls to the *Root*
     * APIs block in js_AddRoot or js_RemoveRoot (see above in this file),
     * waiting for GC to finish.
     */</comment>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcRunning</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>gckind</name> == <name>GC_SET_SLOT_REQUEST</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSSetSlotRequest</name> *</type><name>ssr</name></decl>;</decl_stmt>

        <while>while <condition>(<expr>(<name>ssr</name> = <name><name>rt</name>-&gt;<name>setSlotRequests</name></name>) != <name>NULL</name></expr>)</condition> <block>{
            <expr_stmt><expr><name><name>rt</name>-&gt;<name>setSlotRequests</name></name> = <name><name>ssr</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ssr</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ProcessSetSlotRequest</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>ssr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/*
         * We assume here that killing links to parent and prototype objects
         * does not create garbage (such objects typically are long-lived and
         * widely shared, e.g. global objects, Function.prototype, etc.). We
         * collect garbage only if a racing thread attempted GC and is waiting
         * for us to finish (gcLevel &gt; 1) or if someone already poked us.
         */</comment>
        <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcLevel</name></name> == 1 &amp;&amp; !<name><name>rt</name>-&gt;<name>gcPoke</name></name> &amp;&amp; !<name><name>rt</name>-&gt;<name>gcIsNeeded</name></name></expr>)</condition><then>
            <goto>goto <name>done_running</name>;</goto></then></if>

        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcLevel</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcPoke</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcRunning</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcThread</name></name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>gckind</name> = <name>GC_LOCK_HELD</name></expr>;</expr_stmt>
        <goto>goto <name>restart_at_beginning</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>VOUCH_HAVE_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clear gcIsNeeded now, when we are about to start a normal GC cycle. */</comment>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcIsNeeded</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>

    <comment type="block">/* Reset malloc counter. */</comment>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcMallocBytes</name></name> = 0</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_DUMP_SCOPE_METERS</name></cpp:ifdef>
  <block>{ <function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>js_DumpScopeMeters</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>js_DumpScopeMeters</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
    <expr_stmt><expr><call><name>js_PurgeJITOracle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <label><name>restart</name>:</label>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcNumber</name></name>++</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>rt</name>-&gt;<name>gcUntracedArenaStackTop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcTraceLaterCount</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Reset the property cache's type id generator so we can compress ids.
     * Same for the protoHazardShape proxy-shape standing in for all object
     * prototypes having readonly or setter properties.
     */</comment>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>shapeGen</name></name> &amp; <name>SHAPE_OVERFLOW_BIT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcRegenShapes</name></name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcRegenShapesScopeFlag</name></name> ^= <name><name>JSScope</name>::<name>SHAPE_REGEN</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>shapeGen</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>protoHazardShape</name></name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>js_PurgeThreads</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark phase.
     */</comment>
    <expr_stmt><expr><call><name>JS_TRACER_INIT</name><argument_list>(<argument><expr>&amp;<name>trc</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcMarkingTracer</name></name> = &amp;<name>trc</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>IS_GC_MARKING_TRACER</name><argument_list>(<argument><expr>&amp;<name>trc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>a</name> = <name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name></expr>;</init> <condition><expr><name>a</name></expr>;</condition> <incr><expr><name>a</name> = <name><name>a</name>-&gt;<name>prev</name></name></expr></incr>)
        <expr_stmt><expr><name><name>a</name>-&gt;<name>u</name>.<name>hasMarkedDoubles</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt></for>

    <expr_stmt><expr><call><name>js_TraceRuntime</name><argument_list>(<argument><expr>&amp;<name>trc</name></expr></argument>, <argument><expr><name>keepAtoms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>js_MarkScriptFilenames</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>keepAtoms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Mark children of things that caused too deep recursion during the above
     * tracing.
     */</comment>
    <expr_stmt><expr><call><name>TraceDelayedChildren</name><argument_list>(<argument><expr>&amp;<name>trc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>cx</name>-&gt;<name>insideGCMarkCallback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcCallback</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>insideGCMarkCallback</name></name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr>(<name>void</name>) <call><name><name>rt</name>-&gt;<name>gcCallback</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSGC_MARK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cx</name>-&gt;<name>insideGCMarkCallback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cx</name>-&gt;<name>insideGCMarkCallback</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcTraceLaterCount</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcMarkingTracer</name></name> = <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>createDeallocatorTask</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Sweep phase.
     *
     * Finalize as we sweep, outside of rt-&gt;gcLock but with rt-&gt;gcRunning set
     * so that any attempt to allocate a GC-thing from a finalizer will fail,
     * rather than nest badly and leave the unmarked newborn to be swept.
     *
     * We first sweep atom state so we can use js_IsAboutToBeFinalized on
     * JSString or jsdouble held in a hashtable to check if the hashtable
     * entry can be freed. Note that even after the entry is freed, JSObject
     * finalizers can continue to access the corresponding jsdouble* and
     * JSString* assuming that they are unique. This works since the
     * atomization API must not be called during GC.
     */</comment>
    <expr_stmt><expr><call><name>js_SweepAtomState</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Finalize iterator states before the objects they iterate over. */</comment>
    <expr_stmt><expr><call><name>CloseNativeIterators</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Finalize watch points associated with unreachable objects. */</comment>
    <expr_stmt><expr><call><name>js_SweepWatchPoints</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <comment type="block">/* Save the pre-sweep count of scope-mapped properties. */</comment>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>liveScopePropsPreSweep</name></name> = <name><name>rt</name>-&gt;<name>liveScopeProps</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Here we need to ensure that JSObject instances are finalized before GC-
     * allocated JSString and jsdouble instances so object's finalizer can
     * access them even if they will be freed. For that we simply finalize the
     * list containing JSObject first since the static assert at the beginning
     * of the file guarantees that JSString and jsdouble instances are
     * allocated from a different list.
     */</comment>
    <expr_stmt><expr><name>emptyArenas</name> = <name>NULL</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>GC_NUM_FREELISTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>arenaList</name> = &amp;<name><name>rt</name>-&gt;<name>gcArenaList</name><index>[<expr><name>i</name> == 0
                                     ? <call><name>GC_FREELIST_INDEX</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
                                     : <name>i</name> == <call><name>GC_FREELIST_INDEX</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
                                     ? 0
                                     : <name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ap</name> = &amp;<name><name>arenaList</name>-&gt;<name>last</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!(<name>a</name> = *<name>ap</name>)</expr>)</condition><then>
            <continue>continue;</continue></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>freeList</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>freeList</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>thingSize</name> = <name><name>arenaList</name>-&gt;<name>thingSize</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>indexLimit</name> = <call><name>THINGS_PER_ARENA</name><argument_list>(<argument><expr><name>thingSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>flagp</name> = <call><name>THING_FLAGP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr>(<name>nlivearenas</name> = 0, <name>nkilledarenas</name> = 0, <name>nthings</name> = 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>prevUntracedPage</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>u</name>.<name>untracedThings</name></name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>allClear</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            <do>do <block>{
                <expr_stmt><expr><name>flags</name> = *<name>flagp</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>flags</name> &amp; (<name>GCF_MARK</name> | <name>GCF_LOCK</name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr>*<name>flagp</name> &amp;= ~<name>GCF_MARK</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>allClear</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name>nthings</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>thing</name> = <call><name>FLAGP_TO_THING</name><argument_list>(<argument><expr><name>flagp</name></expr></argument>, <argument><expr><name>thingSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!(<name>flags</name> &amp; <name>GCF_FINAL</name>)</expr>)</condition><then> <block>{
                        <comment type="block">/*
                         * Call the finalizer with GCF_FINAL ORed into flags.
                         */</comment>
                        <expr_stmt><expr>*<name>flagp</name> = <call>(<name>uint8</name>)<argument_list>(<argument><expr><name>flags</name> | <name>GCF_FINAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>type</name> = <name>flags</name> &amp; <name>GCF_TYPEMASK</name></expr>;</expr_stmt>
                        <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
                          <case>case <expr><name>GCX_OBJECT</name></expr>:
                            <expr_stmt><expr><call><name>FinalizeObject</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>JSObject</name> *) <name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
                          </case><case>case <expr><name>GCX_XML</name></expr>:
                            <expr_stmt><expr><call><name>js_FinalizeXML</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>(<name>JSXML</name> *) <name>thing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                          </case><default>default:
                            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> == <name>GCX_STRING</name> ||
                                      <name>type</name> - <name>GCX_EXTERNAL_STRING</name> &lt;
                                      <name>GCX_NTYPES</name> - <name>GCX_EXTERNAL_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>js_FinalizeStringRT</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr>(<name>JSString</name> *) <name>thing</name></expr></argument>,
                                                <argument><expr><call>(<name>intN</name>) <argument_list>(<argument><expr><name>type</name> -
                                                        <name>GCX_EXTERNAL_STRING</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        </default>}</block></switch>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
                        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>thing</name></expr></argument>, <argument><expr><name>JS_FREE_PATTERN</name></expr></argument>, <argument><expr><name>thingSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    }</block></then></if>
                    <expr_stmt><expr><name><name>thing</name>-&gt;<name>flagp</name></name> = <name>flagp</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>thing</name>-&gt;<name>next</name></name> = <name>freeList</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>freeList</name> = <name>thing</name></expr>;</expr_stmt>
                }</block></else></if>
            }</block> while <condition>(<expr>++<name>flagp</name> != <call><name>THING_FLAGS_END</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

            <if>if <condition>(<expr><name>allClear</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * Forget just assembled free list head for the arena and
                 * add the arena itself to the destroy list.
                 */</comment>
                <expr_stmt><expr><name>freeList</name> = <name><name>arenaList</name>-&gt;<name>freeList</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>a</name> == <name><name>arenaList</name>-&gt;<name>last</name></name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>lastCount</name></name> = <name>indexLimit</name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr>*<name>ap</name> = <name><name>a</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>a</name>-&gt;<name>prev</name></name> = <name>emptyArenas</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>emptyArenas</name> = <name>a</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name>nkilledarenas</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name><name>arenaList</name>-&gt;<name>freeList</name></name> = <name>freeList</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ap</name> = &amp;<name><name>a</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name>nlivearenas</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <if>if <condition>(<expr>!(<name>a</name> = *<name>ap</name>)</expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr><name>flagp</name> = <call><name>THING_FLAGP</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>indexLimit</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="block">/*
         * We use arenaList - &amp;rt-&gt;gcArenaList[0], not i, as the stat index
         * due to the enumeration reorder at the beginning of the loop.
         */</comment>
        <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><call><name>UpdateArenaStats</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcStats</name>.<name>arenaStats</name><index>[<expr><name>arenaList</name> -
                                                       &amp;<name><name>rt</name>-&gt;<name>gcArenaList</name><index>[<expr>0</expr>]</index></name></expr>]</index></name></expr></argument>,
                               <argument><expr><name>nlivearenas</name></expr></argument>, <argument><expr><name>nkilledarenas</name></expr></argument>, <argument><expr><name>nthings</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><name>ap</name> = &amp;<name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr>(<name>nlivearenas</name> = 0, <name>nkilledarenas</name> = 0, <name>nthings</name> = 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr>(<name>a</name> = *<name>ap</name>) != <name>NULL</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>!<name><name>a</name>-&gt;<name>u</name>.<name>hasMarkedDoubles</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* No marked double values in the arena. */</comment>
            <expr_stmt><expr>*<name>ap</name> = <name><name>a</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>a</name>-&gt;<name>prev</name></name> = <name>emptyArenas</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>emptyArenas</name> = <name>a</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name>nkilledarenas</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>ap</name> = &amp;<name><name>a</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GCMETER</name></cpp:ifdef>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <name>DOUBLES_PER_ARENA</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <if>if <condition>(<expr><call><name>IsMarkedDouble</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name>nthings</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></for>
            <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><name>nlivearenas</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
    }</block></while>
    <expr_stmt><expr><call><name>METER</name><argument_list>(<argument><expr><call><name>UpdateArenaStats</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>gcStats</name>.<name>doubleArenaStats</name></name></expr></argument>,
                           <argument><expr><name>nlivearenas</name></expr></argument>, <argument><expr><name>nkilledarenas</name></expr></argument>, <argument><expr><name>nthings</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>nextDoubleFlags</name></name> =
        <name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name>
        ? <call><name>DOUBLE_ARENA_BITMAP</name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcDoubleArenaList</name>.<name>first</name></name></expr></argument>)</argument_list></call>
        : <name>DOUBLE_BITMAP_SENTINEL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Sweep the runtime's property tree after finalizing objects, in case any
     * had watchpoints referencing tree nodes.
     */</comment>
    <expr_stmt><expr><call><name>js_SweepScopeProperties</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Sweep script filenames after sweeping functions in the generic loop
     * above. In this way when a scripted function's finalizer destroys the
     * script and calls rt-&gt;destroyScriptHook, the hook can still access the
     * script's filename. See bug 323267.
     */</comment>
    <expr_stmt><expr><call><name>js_SweepScriptFilenames</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Destroy arenas after we finished the sweeping sofinalizers can safely
     * use js_IsAboutToBeFinalized().
     */</comment>
    <expr_stmt><expr><call><name>DestroyGCArenas</name><argument_list>(<argument><expr><name>rt</name></expr></argument>, <argument><expr><name>emptyArenas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <expr_stmt><expr><call><name><name>cx</name>-&gt;<name>submitDeallocatorTask</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name><name>rt</name>-&gt;<name>gcCallback</name></name></expr>)</condition><then>
        <expr_stmt><expr>(<name>void</name>) <call><name><name>rt</name>-&gt;<name>gcCallback</name></name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSGC_FINALIZE_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_srcnotesize</name></cpp:ifdef>
  <block>{ <function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>DumpSrcNoteSizeHist</name><parameter_list>()</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>DumpSrcNoteSizeHist</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"GC HEAP SIZE %lu\n"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)<name><name>rt</name>-&gt;<name>gcBytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_SCOPE_DEPTH_METER</name></cpp:ifdef>
  <block>{ <decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>fp</name></expr>)</condition><then>
        <expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr>"/tmp/scopedepth.stats"</expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><name>fp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_DumpBasicStats</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>protoLookupDepthStats</name></name></expr></argument>, <argument><expr>"proto-lookup depth"</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_DumpBasicStats</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>scopeSearchDepthStats</name></name></expr></argument>, <argument><expr>"scope-search depth"</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_DumpBasicStats</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>hostenvScopeDepthStats</name></name></expr></argument>, <argument><expr>"hostenv scope depth"</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_DumpBasicStats</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>lexicalScopeDepthStats</name></name></expr></argument>, <argument><expr>"lexical scope depth"</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_SCOPE_DEPTH_METER */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_DUMP_LOOP_STATS</name></cpp:ifdef>
  <block>{ <decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> *</type><name>lsfp</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>lsfp</name></expr>)</condition><then>
        <expr_stmt><expr><name>lsfp</name> = <call><name>fopen</name><argument_list>(<argument><expr>"/tmp/loopstats"</expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>lsfp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_DumpBasicStats</name><argument_list>(<argument><expr>&amp;<name><name>rt</name>-&gt;<name>loopStats</name></name></expr></argument>, <argument><expr>"loops"</expr></argument>, <argument><expr><name>lsfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>lsfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_DUMP_LOOP_STATS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_TRACER</name></cpp:ifdef>
<label><name>out</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We want to restart GC if js_GC was called recursively or if any of the
     * finalizers called js_RemoveRoot or js_UnlockGCThingRT.
     */</comment>
    <if>if <condition>(<expr>!<call><name>JS_ON_TRACE</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call> &amp;&amp; (<name><name>rt</name>-&gt;<name>gcLevel</name></name> &gt; 1 || <name><name>rt</name>-&gt;<name>gcPoke</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>VOUCH_HAVE_STACK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcLevel</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcPoke</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>restart</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>rt</name>-&gt;<name>setGCLastBytes</name></name><argument_list>(<argument><expr><name><name>rt</name>-&gt;<name>gcBytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <label><name>done_running</name>:</label>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcLevel</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcRunning</name></name> = <name><name>rt</name>-&gt;<name>gcRegenShapes</name></name> = false</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <expr_stmt><expr><name><name>rt</name>-&gt;<name>gcThread</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_NOTIFY_GC_DONE</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Unlock unless we have GC_LOCK_HELD which requires locked GC on return.
     */</comment>
    <if>if <condition>(<expr>!(<name>gckind</name> &amp; <name>GC_LOCK_HELD</name>)</expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Execute JSGC_END callback outside the lock. Again, sample the callback
     * pointer in case it changes, since we are outside of the GC vs. requests
     * interlock mechanism here.
     */</comment>
    <if>if <condition>(<expr><name>gckind</name> != <name>GC_SET_SLOT_REQUEST</name> &amp;&amp; (<name>callback</name> = <name><name>rt</name>-&gt;<name>gcCallback</name></name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSWeakRoots</name></type> <name>savedWeakRoots</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSTempValueRooter</name></type> <name>tvr</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>gckind</name> &amp; <name>GC_KEEP_ATOMS</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * We allow JSGC_END implementation to force a full GC or allocate
             * new GC things. Thus we must protect the weak roots from garbage
             * collection and overwrites.
             */</comment>
            <expr_stmt><expr><name>savedWeakRoots</name> = <name><name>cx</name>-&gt;<name>weakRoots</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_PUSH_TEMP_ROOT_WEAK_COPY</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>savedWeakRoots</name></expr></argument>, <argument><expr>&amp;<name>tvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_KEEP_ATOMS</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_UNLOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr>(<name>void</name>) <call><name>callback</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSGC_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>gckind</name> &amp; <name>GC_KEEP_ATOMS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_LOCK_GC</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_UNKEEP_ATOMS</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_POP_TEMP_ROOT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr>&amp;<name>tvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>gckind</name> == <name>GC_LAST_CONTEXT</name> &amp;&amp; <name><name>rt</name>-&gt;<name>gcPoke</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * On shutdown iterate until JSGC_END callback stops creating
             * garbage.
             */</comment>
            <goto>goto <name>restart_at_beginning</name>;</goto>
        }</block></then></if></else></if>
    }</block></then></if>
}</block></function>
</unit>
