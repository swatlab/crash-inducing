<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="004177a5237e4fa88ec91baf3faf1008eebcb5f0.c"><comment type="block">/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<comment type="block">/*
 * JS bytecode generation.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsstddef.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MEMORY_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jstypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarena.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsbool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jscntxt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsconfig.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsemit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsfun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsopcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsparse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsregexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsscript.h"</cpp:file></cpp:include>

<comment type="block">/* Allocation chunk counts, must be powers of two in general. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTECODE_CHUNK</name></cpp:macro>  <cpp:value>256</cpp:value></cpp:define>     <comment type="block">/* code allocation increment */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SRCNOTE_CHUNK</name></cpp:macro>   <cpp:value>64</cpp:value></cpp:define>      <comment type="block">/* initial srcnote allocation increment */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRYNOTE_CHUNK</name></cpp:macro>   <cpp:value>64</cpp:value></cpp:define>      <comment type="block">/* trynote allocation increment */</comment>

<comment type="block">/* Macros to compute byte sizes from typed element counts. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTECODE_SIZE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>((n) * sizeof(jsbytecode))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SRCNOTE_SIZE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>((n) * sizeof(jssrcnote))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRYNOTE_SIZE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>((n) * sizeof(JSTryNote))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CG_TS</name><parameter_list>(<param><type><name>cg</name></type></param>)</parameter_list></cpp:macro> <cpp:value>TS((cg)-&gt;treeContext.parseContext)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>JSBool</name></type>
<name>NewTryNote</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSTryNoteKind</name></type> <name>kind</name></decl></param>,
           <param><decl><type><name>uintN</name></type> <name>stackDepth</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>start</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>end</name></decl></param>)</parameter_list>;</function_decl>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>js_InitCodeGenerator</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSCodeGenerator *cg</argument>, <argument>JSParseContext *pc</argument>,
                     <argument>JSArenaPool *codePool</argument>, <argument>JSArenaPool *notePool</argument>,
                     <argument>uintN lineno</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>sizeof *<name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TREE_CONTEXT_INIT</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>codePool</name></name> = <name>codePool</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>notePool</name></name> = <name>notePool</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>codeMark</name></name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr><name>codePool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>noteMark</name></name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr><name>notePool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>current</name></name> = &amp;<name><name>cg</name>-&gt;<name/></name>main</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>firstLine</name></name> = <name><name>cg</name>-&gt;<name>prolog</name>.<name>currentLine</name></name> = <name><name>cg</name>-&gt;<name/></name>main.<name>currentLine</name> = <name>lineno</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ATOM_LIST_INIT</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>prolog</name>.<name>noteMask</name></name> = <name><name>cg</name>-&gt;<name/></name>main.<name>noteMask</name> = <name>SRCNOTE_CHUNK</name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ATOM_LIST_INIT</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>constList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<macro><name>js_FinishCodeGenerator</name><argument_list>(<argument>JSContext *cx</argument>, <argument>JSCodeGenerator *cg</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><call><name>TREE_CONTEXT_FINISH</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>codePool</name></name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>codeMark</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>notePool</name></name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>noteMark</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>spanDeps</name></name></expr>)</condition><then> <comment type="block">/* non-null only after OOM */</comment>
        <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>spanDeps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>EmitCheck</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>delta</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>base</name></decl>, *<decl><type ref="prev"/><name>limit</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>incr</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>base</name> = <call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>next</name> = <call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> = <call><name>CG_LIMIT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> = <call><name>PTRDIFF</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>next</name> + <name>delta</name> &gt; <name>limit</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>length</name> = <name>offset</name> + <name>delta</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> = (<name>length</name> &lt;= <name>BYTECODE_CHUNK</name>)
                 ? <name>BYTECODE_CHUNK</name>
                 : <call><name>JS_BIT</name><argument_list>(<argument><expr><call><name>JS_CeilingLog2</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>incr</name> = <call><name>BYTECODE_SIZE</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>base</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>jsbytecode</name> *</expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>codePool</name></name></expr></argument>, <argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>size</name> = <call><name>BYTECODE_SIZE</name><argument_list>(<argument><expr><call><name>PTRDIFF</name><argument_list>(<argument><expr><name>limit</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>incr</name> -= <name>size</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ARENA_GROW_CAST</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>jsbytecode</name> *</expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>codePool</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr>!<name>base</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>base</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CG_LIMIT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>base</name> + <name>length</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>base</name> + <name>offset</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>offset</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateDepth</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>target</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name> *</type><name>cs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>depth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>intN</name></type> <name>nuses</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pc</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) *<name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_TMPSLOT_MASK</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>depth</name> = (<name>uintN</name>) <name><name>cg</name>-&gt;<name>stackDepth</name></name> +
                ((<name><name>cs</name>-&gt;<name>format</name></name> &amp; <name>JOF_TMPSLOT_MASK</name>) &gt;&gt; <name>JOF_TMPSLOT_SHIFT</name>)</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>depth</name> &gt; <name><name>cg</name>-&gt;<name>maxStackDepth</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>maxStackDepth</name></name> = <name>depth</name></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>nuses</name> = <name><name>cs</name>-&gt;<name>nuses</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>nuses</name> &lt; 0</expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
          <case>case <expr><name>JSOP_POPN</name></expr>:
            <expr_stmt><expr><name>nuses</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSOP_NEW</name></expr>:
          </case><case>case <expr><name>JSOP_CALL</name></expr>:
          </case><case>case <expr><name>JSOP_SETCALL</name></expr>:
          </case><case>case <expr><name>JSOP_EVAL</name></expr>:
            <expr_stmt><expr><name>nuses</name> = 2 + <call><name>GET_ARGC</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* stack: fun, this, [argc arguments] */</comment>
            <break>break;</break>
          </case><default>default:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
    }</block></then></if>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> -= <name>nuses</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> &lt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>numBuf</name><index>[<expr>12</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSTokenStream</name> *</type><name>ts</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>JS_snprintf</name><argument_list>(<argument><expr><name>numBuf</name></expr></argument>, <argument><expr>sizeof <name>numBuf</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ts</name> = &amp;<name><name>cg</name>-&gt;<name>treeContext</name>.<name>parseContext</name>-&gt;<name>tokenStream</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ReportErrorFlagsAndNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSREPORT_WARNING</name></expr></argument>,
                                     <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>JSMSG_STACK_UNDERFLOW</name></expr></argument>,
                                     <argument><expr><name><name>ts</name>-&gt;<name>filename</name></name> ? <name><name>ts</name>-&gt;<name>filename</name></name> : "stdin"</expr></argument>,
                                     <argument><expr><name>numBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> += <name><name>cs</name>-&gt;<name>ndefs</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>uintN</name>)<name><name>cg</name>-&gt;<name>stackDepth</name></name> &gt; <name><name>cg</name>-&gt;<name>maxStackDepth</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>maxStackDepth</name></name> = <name><name>cg</name>-&gt;<name>stackDepth</name></name></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><name>ptrdiff_t</name></type>
<name>js_Emit1</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name> <init>= <expr><call><name>EmitCheck</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>offset</name> &gt;= 0</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call>++ = (<name>jsbytecode</name>)<name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UpdateDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>offset</name></expr>;</return>
}</block></function>

<function><type><name>ptrdiff_t</name></type>
<name>js_Emit2</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>jsbytecode</name></type> <name>op1</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name> <init>= <expr><call><name>EmitCheck</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>offset</name> &gt;= 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>next</name> <init>= <expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>next</name><index>[<expr>0</expr>]</index></name> = (<name>jsbytecode</name>)<name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><index>[<expr>1</expr>]</index></name> = <name>op1</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>next</name> + 2</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UpdateDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>offset</name></expr>;</return>
}</block></function>

<function><type><name>ptrdiff_t</name></type>
<name>js_Emit3</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>jsbytecode</name></type> <name>op1</name></decl></param>,
         <param><decl><type><name>jsbytecode</name></type> <name>op2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name> <init>= <expr><call><name>EmitCheck</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>offset</name> &gt;= 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>next</name> <init>= <expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>next</name><index>[<expr>0</expr>]</index></name> = (<name>jsbytecode</name>)<name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><index>[<expr>1</expr>]</index></name> = <name>op1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><index>[<expr>2</expr>]</index></name> = <name>op2</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>next</name> + 3</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UpdateDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>offset</name></expr>;</return>
}</block></function>

<function><type><name>ptrdiff_t</name></type>
<name>js_EmitN</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>extra</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>length</name> <init>= <expr>1 + (<name>ptrdiff_t</name>)<name>extra</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name> <init>= <expr><call><name>EmitCheck</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>offset</name> &gt;= 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>next</name> <init>= <expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*<name>next</name> = (<name>jsbytecode</name>)<name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>next</name> + 1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>BYTECODE_SIZE</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>next</name> + <name>length</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UpdateDepth</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>offset</name></expr>;</return>
}</block></function>

<comment type="block">/* XXX too many "... statement" L10N gaffes below -- fix via js.msg! */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_with_statement_str</name><index>[]</index></name> <init>= <expr>"with statement"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_finally_block_str</name><index>[]</index></name>  <init>= <expr>"finally block"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>js_script_str</name><index>[]</index></name>         <init>= <expr>"script"</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>statementName</name><index>[]</index></name> <init>= <expr><block>{
    <expr>"label statement"</expr>,       <comment type="block">/* LABEL */</comment>
    <expr>"if statement"</expr>,          <comment type="block">/* IF */</comment>
    <expr>"else statement"</expr>,        <comment type="block">/* ELSE */</comment>
    <expr>"destructuring body"</expr>,    <comment type="block">/* BODY */</comment>
    <expr>"switch statement"</expr>,      <comment type="block">/* SWITCH */</comment>
    <expr>"block"</expr>,                 <comment type="block">/* BLOCK */</comment>
    <expr><name>js_with_statement_str</name></expr>,   <comment type="block">/* WITH */</comment>
    <expr>"catch block"</expr>,           <comment type="block">/* CATCH */</comment>
    <expr>"try block"</expr>,             <comment type="block">/* TRY */</comment>
    <expr><name>js_finally_block_str</name></expr>,    <comment type="block">/* FINALLY */</comment>
    <expr><name>js_finally_block_str</name></expr>,    <comment type="block">/* SUBROUTINE */</comment>
    <expr>"do loop"</expr>,               <comment type="block">/* DO_LOOP */</comment>
    <expr>"for loop"</expr>,              <comment type="block">/* FOR_LOOP */</comment>
    <expr>"for/in loop"</expr>,           <comment type="block">/* FOR_IN_LOOP */</comment>
    <expr>"while loop"</expr>,            <comment type="block">/* WHILE_LOOP */</comment>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>JS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>statementName</name></expr></argument>)</argument_list></call> == <name>STMT_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>StatementName</name><parameter_list>(<param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name></name></expr>)</condition><then>
        <return>return <expr><name>js_script_str</name></expr>;</return></then></if>
    <return>return <expr><name><name>statementName</name><index>[<expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name>-&gt;<name>type</name></name></expr>]</index></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReportStatementTooLarge</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JSMSG_NEED_DIET</name></expr></argument>,
                         <argument><expr><call><name>StatementName</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/**
  Span-dependent instructions in JS bytecode consist of the jump (JOF_JUMP)
  and switch (JOF_LOOKUPSWITCH, JOF_TABLESWITCH) format opcodes, subdivided
  into unconditional (gotos and gosubs), and conditional jumps or branches
  (which pop a value, test it, and jump depending on its value).  Most jumps
  have just one immediate operand, a signed offset from the jump opcode's pc
  to the target bytecode.  The lookup and table switch opcodes may contain
  many jump offsets.

  Mozilla bug #80981 (http://bugzilla.mozilla.org/show_bug.cgi?id=80981) was
  fixed by adding extended "X" counterparts to the opcodes/formats (NB: X is
  suffixed to prefer JSOP_ORX thereby avoiding a JSOP_XOR name collision for
  the extended form of the JSOP_OR branch opcode).  The unextended or short
  formats have 16-bit signed immediate offset operands, the extended or long
  formats have 32-bit signed immediates.  The span-dependency problem consists
  of selecting as few long instructions as possible, or about as few -- since
  jumps can span other jumps, extending one jump may cause another to need to
  be extended.

  Most JS scripts are short, so need no extended jumps.  We optimize for this
  case by generating short jumps until we know a long jump is needed.  After
  that point, we keep generating short jumps, but each jump's 16-bit immediate
  offset operand is actually an unsigned index into cg-&gt;spanDeps, an array of
  JSSpanDep structs.  Each struct tells the top offset in the script of the
  opcode, the "before" offset of the jump (which will be the same as top for
  simplex jumps, but which will index further into the bytecode array for a
  non-initial jump offset in a lookup or table switch), the after "offset"
  adjusted during span-dependent instruction selection (initially the same
  value as the "before" offset), and the jump target (more below).

  Since we generate cg-&gt;spanDeps lazily, from within js_SetJumpOffset, we must
  ensure that all bytecode generated so far can be inspected to discover where
  the jump offset immediate operands lie within CG_CODE(cg).  But the bonus is
  that we generate span-dependency records sorted by their offsets, so we can
  binary-search when trying to find a JSSpanDep for a given bytecode offset,
  or the nearest JSSpanDep at or above a given pc.

  To avoid limiting scripts to 64K jumps, if the cg-&gt;spanDeps index overflows
  65534, we store SPANDEP_INDEX_HUGE in the jump's immediate operand.  This
  tells us that we need to binary-search for the cg-&gt;spanDeps entry by the
  jump opcode's bytecode offset (sd-&gt;before).

  Jump targets need to be maintained in a data structure that lets us look
  up an already-known target by its address (jumps may have a common target),
  and that also lets us update the addresses (script-relative, a.k.a. absolute
  offsets) of targets that come after a jump target (for when a jump below
  that target needs to be extended).  We use an AVL tree, implemented using
  recursion, but with some tricky optimizations to its height-balancing code
  (see http://www.cmcrossroads.com/bradapp/ftp/src/libs/C++/AvlTrees.html).

  A final wrinkle: backpatch chains are linked by jump-to-jump offsets with
  positive sign, even though they link "backward" (i.e., toward lower bytecode
  address).  We don't want to waste space and search time in the AVL tree for
  such temporary backpatch deltas, so we use a single-bit wildcard scheme to
  tag true JSJumpTarget pointers and encode untagged, signed (positive) deltas
  in JSSpanDep.target pointers, depending on whether the JSSpanDep has a known
  target, or is still awaiting backpatching.

  Note that backpatch chains would present a problem for BuildSpanDepTable,
  which inspects bytecode to build cg-&gt;spanDeps on demand, when the first
  short jump offset overflows.  To solve this temporary problem, we emit a
  proxy bytecode (JSOP_BACKPATCH; JSOP_BACKPATCH_POP for branch ops) whose
  nuses/ndefs counts help keep the stack balanced, but whose opcode format
  distinguishes its backpatch delta immediate operand from a normal jump
  offset.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>BalanceJumpTargets</name><parameter_list>(<param><decl><type><name>JSJumpTarget</name> **</type><name>jtp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSJumpTarget</name> *</type><name>jt</name></decl>, *<decl><type ref="prev"/><name>jt2</name></decl>, *<decl><type ref="prev"/><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dir</name></decl>, <decl><type ref="prev"/><name>otherDir</name></decl>, <decl><type ref="prev"/><name>heightChanged</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>doubleRotate</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>jt</name> = *<name>jtp</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>jt</name>-&gt;<name>balance</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>jt</name>-&gt;<name>balance</name></name> &lt; -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>dir</name> = <name>JT_RIGHT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>doubleRotate</name> = (<name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name>-&gt;<name>balance</name> &gt; 0)</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name><name>jt</name>-&gt;<name>balance</name></name> &gt; 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>dir</name> = <name>JT_LEFT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>doubleRotate</name> = (<name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_RIGHT</name></expr>]</index></name>-&gt;<name>balance</name> &lt; 0)</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <return>return <expr>0</expr>;</return>
    }</block></else></if></else></if>

    <expr_stmt><expr><name>otherDir</name> = <call><name>JT_OTHER_DIR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>doubleRotate</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>jt2</name> = <name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>otherDir</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>jtp</name> = <name>root</name> = <name><name>jt2</name>-&gt;<name>kids</name><index>[<expr><name>dir</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>otherDir</name></expr>]</index></name> = <name><name>root</name>-&gt;<name>kids</name><index>[<expr><name>dir</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name>-&gt;<name>kids</name><index>[<expr><name>dir</name></expr>]</index></name> = <name>jt</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>jt2</name>-&gt;<name>kids</name><index>[<expr><name>dir</name></expr>]</index></name> = <name><name>root</name>-&gt;<name>kids</name><index>[<expr><name>otherDir</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name>-&gt;<name>kids</name><index>[<expr><name>otherDir</name></expr>]</index></name> = <name>jt2</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>heightChanged</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name>-&gt;<name>balance</name> = -<call><name>JS_MAX</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>balance</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name>-&gt;<name>kids</name><index>[<expr><name>JT_RIGHT</name></expr>]</index></name>-&gt;<name>balance</name> = -<call><name>JS_MIN</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>balance</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name>-&gt;<name>balance</name></name> = 0</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr>*<name>jtp</name> = <name>root</name> = <name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>otherDir</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>otherDir</name></expr>]</index></name> = <name><name>root</name>-&gt;<name>kids</name><index>[<expr><name>dir</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name>-&gt;<name>kids</name><index>[<expr><name>dir</name></expr>]</index></name> = <name>jt</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>heightChanged</name> = (<name><name>root</name>-&gt;<name>balance</name></name> != 0)</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>jt</name>-&gt;<name>balance</name></name> = -((<name>dir</name> == <name>JT_LEFT</name>) ? --<name><name>root</name>-&gt;<name>balance</name></name> : ++<name><name>root</name>-&gt;<name>balance</name></name>)</expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>heightChanged</name></expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <name>AddJumpTargetArgs</name> <block>{
    <decl_stmt><decl><type><name>JSContext</name>           *</type><name>cx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSCodeGenerator</name>     *</type><name>cg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type>           <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSJumpTarget</name>        *</type><name>node</name></decl>;</decl_stmt>
}</block></struct></type> <name>AddJumpTargetArgs</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>AddJumpTarget</name><parameter_list>(<param><decl><type><name>AddJumpTargetArgs</name> *</type><name>args</name></decl></param>, <param><decl><type><name>JSJumpTarget</name> **</type><name>jtp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSJumpTarget</name> *</type><name>jt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>balanceDelta</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>jt</name> = *<name>jtp</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>jt</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name> <init>= <expr><name><name>args</name>-&gt;<name>cg</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>jt</name> = <name><name>cg</name>-&gt;<name>jtFreeList</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>jt</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>jtFreeList</name></name> = <name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><name>jt</name></expr></argument>, <argument><expr><name>JSJumpTarget</name> *</expr></argument>, <argument><expr>&amp;<name><name>args</name>-&gt;<name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>,
                                   <argument><expr>sizeof *<name>jt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>jt</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>cx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
            }</block></then></if>
        }</block></else></if>
        <expr_stmt><expr><name><name>jt</name>-&gt;<name>offset</name></name> = <name><name>args</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>jt</name>-&gt;<name>balance</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name> = <name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_RIGHT</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>numJumpTargets</name></name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name>-&gt;<name>node</name></name> = <name>jt</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>jtp</name> = <name>jt</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>jt</name>-&gt;<name>offset</name></name> == <name><name>args</name>-&gt;<name>offset</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>args</name>-&gt;<name>node</name></name> = <name>jt</name></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>args</name>-&gt;<name>offset</name></name> &lt; <name><name>jt</name>-&gt;<name>offset</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>balanceDelta</name> = -<call><name>AddJumpTarget</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>balanceDelta</name> = <call><name>AddJumpTarget</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_RIGHT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr>!<name><name>args</name>-&gt;<name>node</name></name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <expr_stmt><expr><name><name>jt</name>-&gt;<name>balance</name></name> += <name>balanceDelta</name></expr>;</expr_stmt>
    <return>return <expr>(<name>balanceDelta</name> &amp;&amp; <name><name>jt</name>-&gt;<name>balance</name></name>)
           ? 1 - <call><name>BalanceJumpTargets</name><argument_list>(<argument><expr><name>jtp</name></expr></argument>)</argument_list></call>
           : 0</expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendan</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>AVLCheck</name><parameter_list>(<param><decl><type><name>JSJumpTarget</name> *</type><name>jt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>lh</name></decl>, <decl><type ref="prev"/><name>rh</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>jt</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>-1 &lt;= <name><name>jt</name>-&gt;<name>balance</name></name> &amp;&amp; <name><name>jt</name>-&gt;<name>balance</name></name> &lt;= 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lh</name> = <call><name>AVLCheck</name><argument_list>(<argument><expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rh</name> = <call><name>AVLCheck</name><argument_list>(<argument><expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_RIGHT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>jt</name>-&gt;<name>balance</name></name> == <name>rh</name> - <name>lh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1 + <call><name>JS_MAX</name><argument_list>(<argument><expr><name>lh</name></expr></argument>, <argument><expr><name>rh</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>SetSpanDepTarget</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSSpanDep</name> *</type><name>sd</name></decl></param>,
                 <param><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>AddJumpTargetArgs</name></type> <name>args</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>off</name> &lt; <name>JUMPX_OFFSET_MIN</name> || <name>JUMPX_OFFSET_MAX</name> &lt; <name>off</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ReportStatementTooLarge</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>args</name>.<name>cx</name></name> = <name>cx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name>.<name>cg</name></name> = <name>cg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name>.<name>offset</name></name> = <name><name>sd</name>-&gt;<name>top</name></name> + <name>off</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>args</name>.<name>node</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AddJumpTarget</name><argument_list>(<argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>jumpTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>args</name>.<name>node</name></name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendan</name></cpp:ifdef>
    <expr_stmt><expr><call><name>AVLCheck</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>jumpTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>SD_SET_TARGET</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name><name>args</name>.<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPANDEPS_MIN</name></cpp:macro>            <cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPANDEPS_SIZE</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>((n) * sizeof(JSSpanDep))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPANDEPS_SIZE_MIN</name></cpp:macro>       <cpp:value>SPANDEPS_SIZE(SPANDEPS_MIN)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>AddSpanDep</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc2</name></decl></param>,
           <param><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSpanDep</name> *</type><name>sdbase</name></decl>, *<decl><type ref="prev"/><name>sd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>index</name> = <name><name>cg</name>-&gt;<name>numSpanDeps</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>index</name> + 1 == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ReportStatementTooLarge</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>index</name> &amp; (<name>index</name> - 1)) == 0 &amp;&amp;
        (!(<name>sdbase</name> = <name><name>cg</name>-&gt;<name>spanDeps</name></name>) || <name>index</name> &gt;= <name>SPANDEPS_MIN</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>size</name> = <name>sdbase</name> ? <call><name>SPANDEPS_SIZE</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> : <name>SPANDEPS_SIZE_MIN</name> / 2</expr>;</expr_stmt>
        <expr_stmt><expr><name>sdbase</name> = (<name>JSSpanDep</name> *) <call><name>JS_realloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>sdbase</name></expr></argument>, <argument><expr><name>size</name> + <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>sdbase</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>spanDeps</name></name> = <name>sdbase</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>cg</name>-&gt;<name>numSpanDeps</name></name> = <name>index</name> + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>sd</name> = <name><name>cg</name>-&gt;<name>spanDeps</name></name> + <name>index</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sd</name>-&gt;<name>top</name></name> = <call><name>PTRDIFF</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sd</name>-&gt;<name>offset</name></name> = <name><name>sd</name>-&gt;<name>before</name></name> = <call><name>PTRDIFF</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>, <argument><expr><call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>js_CodeSpec</name><index>[<expr>*<name>pc</name></expr>]</index></name>.<name>format</name> &amp; <name>JOF_BACKPATCH</name></expr>)</condition><then> <block>{
        <comment type="block">/* Jump offset will be backpatched if off is a non-zero "bpdelta". */</comment>
        <if>if <condition>(<expr><name>off</name> != 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>off</name> &gt;= 1 + <name>JUMP_OFFSET_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>off</name> &gt; <name>BPDELTA_MAX</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ReportStatementTooLarge</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><call><name>SD_SET_BPDELTA</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>off</name> == 0</expr>)</condition><then> <block>{
        <comment type="block">/* Jump offset will be patched directly, without backpatch chaining. */</comment>
        <expr_stmt><expr><call><name>SD_SET_TARGET</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/* The jump offset in off is non-zero, therefore it's already known. */</comment>
        <if>if <condition>(<expr>!<call><name>SetSpanDepTarget</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>sd</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></else></if></else></if>

    <if>if <condition>(<expr><name>index</name> &gt; <name>SPANDEP_INDEX_MAX</name></expr>)</condition><then>
        <expr_stmt><expr><name>index</name> = <name>SPANDEP_INDEX_HUGE</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>SET_SPANDEP_INDEX</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>jsbytecode</name> *</type>
<name>AddSwitchSpanDeps</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>njumps</name></decl>, <decl><type ref="prev"/><name>indexlen</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) *<name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_TABLESWITCH</name> || <name>op</name> == <name>JSOP_LOOKUPSWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc2</name> = <name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>off</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>AddSpanDep</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>pc2</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>op</name> == <name>JSOP_TABLESWITCH</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>low</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>high</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>njumps</name> = <call>(<name>uintN</name>) <argument_list>(<argument><expr><name>high</name> - <name>low</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>indexlen</name> = 0</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>njumps</name> = <call><name>GET_UINT16</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> += <name>UINT16_LEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>indexlen</name> = <name>INDEX_LEN</name></expr>;</expr_stmt>
    }</block></else></if>
    <while>while <condition>(<expr><name>njumps</name></expr>)</condition> <block>{
        <expr_stmt><expr>--<name>njumps</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc2</name> += <name>indexlen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>off</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>AddSpanDep</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc2</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pc2</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr>1 + <name>pc2</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>BuildSpanDepTable</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>JSCodeSpec</name> *</type><name>cs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pc</name> = <call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> + <name><name>cg</name>-&gt;<name>spanDepTodo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pc</name> != <name>end</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pc</name> &lt; <name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = (<name>JSOp</name>)*<name>pc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cs</name> = &amp;<name><name>js_CodeSpec</name><index>[<expr><name>op</name></expr>]</index></name></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><call><name>JOF_TYPE</name><argument_list>(<argument><expr><name><name>cs</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
          <case>case <expr><name>JOF_TABLESWITCH</name></expr>:
          </case><case>case <expr><name>JOF_LOOKUPSWITCH</name></expr>:
            <expr_stmt><expr><name>pc</name> = <call><name>AddSwitchSpanDeps</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pc</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>

          </case><case>case <expr><name>JOF_JUMP</name></expr>:
            <expr_stmt><expr><name>off</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>AddSpanDep</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <comment type="block">/* FALL THROUGH */</comment>
          </case><default>default:
            <expr_stmt><expr><name>pc</name> += <name><name>cs</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </default>}</block></switch>
    }</block></while>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSSpanDep</name> *</type>
<name>GetSpanDep</name><parameter_list>(<param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSpanDep</name> *</type><name>sd</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>index</name> = <call><name>GET_SPANDEP_INDEX</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>index</name> != <name>SPANDEP_INDEX_HUGE</name></expr>)</condition><then>
        <return>return <expr><name><name>cg</name>-&gt;<name>spanDeps</name></name> + <name>index</name></expr>;</return></then></if>

    <expr_stmt><expr><name>offset</name> = <call><name>PTRDIFF</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lo</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>hi</name> = <name><name>cg</name>-&gt;<name>numSpanDeps</name></name> - 1</expr>;</expr_stmt>
    <while>while <condition>(<expr><name>lo</name> &lt;= <name>hi</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>mid</name> = (<name>lo</name> + <name>hi</name>) / 2</expr>;</expr_stmt>
        <expr_stmt><expr><name>sd</name> = <name><name>cg</name>-&gt;<name>spanDeps</name></name> + <name>mid</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>sd</name>-&gt;<name>before</name></name> == <name>offset</name></expr>)</condition><then>
            <return>return <expr><name>sd</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>sd</name>-&gt;<name>before</name></name> &lt; <name>offset</name></expr>)</condition><then>
            <expr_stmt><expr><name>lo</name> = <name>mid</name> + 1</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>hi</name> = <name>mid</name> - 1</expr>;</expr_stmt></else></if>
    }</block></while>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>SetBackPatchDelta</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>,
                  <param><decl><type><name>ptrdiff_t</name></type> <name>delta</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSSpanDep</name> *</type><name>sd</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>delta</name> &gt;= 1 + <name>JUMP_OFFSET_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>cg</name>-&gt;<name>spanDeps</name></name> &amp;&amp; <name>delta</name> &lt; <name>JUMP_OFFSET_MAX</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>delta</name> &gt; <name>BPDELTA_MAX</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ReportStatementTooLarge</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name><name>cg</name>-&gt;<name>spanDeps</name></name> &amp;&amp; !<call><name>BuildSpanDepTable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>sd</name> = <call><name>GetSpanDep</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>SD_GET_BPDELTA</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SD_SET_BPDELTA</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateJumpTargets</name><parameter_list>(<param><decl><type><name>JSJumpTarget</name> *</type><name>jt</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>pivot</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>delta</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>jt</name>-&gt;<name>offset</name></name> &gt; <name>pivot</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>jt</name>-&gt;<name>offset</name></name> += <name>delta</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>UpdateJumpTargets</name><argument_list>(<argument><expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_RIGHT</name></expr>]</index></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>UpdateJumpTargets</name><argument_list>(<argument><expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_RIGHT</name></expr>]</index></name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>JSSpanDep</name> *</type>
<name>FindNearestSpanDep</name><parameter_list>(<param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl></param>, <param><decl><type><name>int</name></type> <name>lo</name></decl></param>,
                   <param><decl><type><name>JSSpanDep</name> *</type><name>guard</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSpanDep</name> *</type><name>sdbase</name></decl>, *<decl><type ref="prev"/><name>sd</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>num</name> = <name><name>cg</name>-&gt;<name>numSpanDeps</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>num</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hi</name> = <name>num</name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>sdbase</name> = <name><name>cg</name>-&gt;<name>spanDeps</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>lo</name> &lt;= <name>hi</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>mid</name> = (<name>lo</name> + <name>hi</name>) / 2</expr>;</expr_stmt>
        <expr_stmt><expr><name>sd</name> = <name>sdbase</name> + <name>mid</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>sd</name>-&gt;<name>before</name></name> == <name>offset</name></expr>)</condition><then>
            <return>return <expr><name>sd</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>sd</name>-&gt;<name>before</name></name> &lt; <name>offset</name></expr>)</condition><then>
            <expr_stmt><expr><name>lo</name> = <name>mid</name> + 1</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>hi</name> = <name>mid</name> - 1</expr>;</expr_stmt></else></if>
    }</block></while>
    <if>if <condition>(<expr><name>lo</name> == <name>num</name></expr>)</condition><then>
        <return>return <expr><name>guard</name></expr>;</return></then></if>
    <expr_stmt><expr><name>sd</name> = <name>sdbase</name> + <name>lo</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>sd</name>-&gt;<name>before</name></name> &gt;= <name>offset</name> &amp;&amp; (<name>lo</name> == 0 || <name><name>sd</name><index>[<expr>-1</expr>]</index></name>.<name>before</name> &lt; <name>offset</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>sd</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreeJumpTargets</name><parameter_list>(<param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSJumpTarget</name> *</type><name>jt</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>FreeJumpTargets</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_RIGHT</name></expr>]</index></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>FreeJumpTargets</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_RIGHT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name><name>jt</name>-&gt;<name>kids</name><index>[<expr><name>JT_LEFT</name></expr>]</index></name> = <name><name>cg</name>-&gt;<name>jtFreeList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>jtFreeList</name></name> = <name>jt</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>OptimizeSpanDeps</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>, *<decl><type ref="prev"/><name>oldpc</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>, *<decl><type ref="prev"/><name>limit</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSpanDep</name> *</type><name>sd</name></decl>, *<decl><type ref="prev"/><name>sd2</name></decl>, *<decl><type ref="prev"/><name>sdbase</name></decl>, *<decl><type ref="prev"/><name>sdlimit</name></decl>, *<decl><type ref="prev"/><name>sdtop</name></decl>, <decl><type ref="prev"/><name>guard</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>growth</name></decl>, <decl><type ref="prev"/><name>delta</name></decl>, <decl><type ref="prev"/><name>top</name></decl>, <decl><type ref="prev"/><name>pivot</name></decl>, <decl><type ref="prev"/><name>span</name></decl>, <decl><type ref="prev"/><name>length</name></decl>, <decl><type ref="prev"/><name>target</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>done</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>incr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>, *<decl><type ref="prev"/><name>snlimit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSrcNoteSpec</name> *</type><name>spec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>noteIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTryNode</name> *</type><name>tryNode</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendan</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>passes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>base</name> = <call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sdbase</name> = <name><name>cg</name>-&gt;<name>spanDeps</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sdlimit</name> = <name>sdbase</name> + <name><name>cg</name>-&gt;<name>numSpanDeps</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>growth</name> = 0</expr>;</expr_stmt>

    <do>do <block>{
        <expr_stmt><expr><name>done</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>delta</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>top</name> = <name>pivot</name> = -1</expr>;</expr_stmt>
        <expr_stmt><expr><name>sdtop</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> = 0</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendan</name></cpp:ifdef>
        <expr_stmt><expr><name>passes</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <for>for (<init><expr><name>sd</name> = <name>sdbase</name></expr>;</init> <condition><expr><name>sd</name> &lt; <name>sdlimit</name></expr>;</condition> <incr><expr><name>sd</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JT_HAS_TAG</name><argument_list>(<argument><expr><name><name>sd</name>-&gt;<name>target</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sd</name>-&gt;<name>offset</name></name> += <name>delta</name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name><name>sd</name>-&gt;<name>top</name></name> != <name>top</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>sdtop</name> = <name>sd</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>top</name> = <name><name>sd</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>top</name> == <name><name>sd</name>-&gt;<name>before</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pivot</name> = <name><name>sd</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pc</name> = <name>base</name> + <name>top</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) *<name>pc</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>type</name> = <call><name>JOF_OPTYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>JOF_TYPE_IS_EXTENDED_JUMP</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * We already extended all the jump offset operands for
                     * the opcode at sd-&gt;top.  Jumps and branches have only
                     * one jump offset operand, but switches have many, all
                     * of which are adjacent in cg-&gt;spanDeps.
                     */</comment>
                    <continue>continue;</continue>
                }</block></then></if>

                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> == <name>JOF_JUMP</name> ||
                          <name>type</name> == <name>JOF_TABLESWITCH</name> ||
                          <name>type</name> == <name>JOF_LOOKUPSWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr>!<call><name>JOF_TYPE_IS_EXTENDED_JUMP</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>span</name> = <call><name>SD_SPAN</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>span</name> &lt; <name>JUMP_OFFSET_MIN</name> || <name>JUMP_OFFSET_MAX</name> &lt; <name>span</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>deltaFromTop</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>done</name> = <name>JS_FALSE</name></expr>;</expr_stmt>

                    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
                      <case>case <expr><name>JSOP_GOTO</name></expr>:         <expr_stmt><expr><name>op</name> = <name>JSOP_GOTOX</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_IFEQ</name></expr>:         <expr_stmt><expr><name>op</name> = <name>JSOP_IFEQX</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_IFNE</name></expr>:         <expr_stmt><expr><name>op</name> = <name>JSOP_IFNEX</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_OR</name></expr>:           <expr_stmt><expr><name>op</name> = <name>JSOP_ORX</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_AND</name></expr>:          <expr_stmt><expr><name>op</name> = <name>JSOP_ANDX</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_GOSUB</name></expr>:        <expr_stmt><expr><name>op</name> = <name>JSOP_GOSUBX</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_CASE</name></expr>:         <expr_stmt><expr><name>op</name> = <name>JSOP_CASEX</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_DEFAULT</name></expr>:      <expr_stmt><expr><name>op</name> = <name>JSOP_DEFAULTX</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_TABLESWITCH</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_TABLESWITCHX</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_LOOKUPSWITCH</name></expr>: <expr_stmt><expr><name>op</name> = <name>JSOP_LOOKUPSWITCHX</name></expr>;</expr_stmt> <break>break;</break>
                      </case><default>default:
                        <expr_stmt><expr><call><name>ReportStatementTooLarge</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return>
                    </default>}</block></switch>
                    <expr_stmt><expr>*<name>pc</name> = (<name>jsbytecode</name>) <name>op</name></expr>;</expr_stmt>

                    <for>for (<init><expr><name>sd2</name> = <name>sdtop</name></expr>;</init> <condition><expr><name>sd2</name> &lt; <name>sdlimit</name> &amp;&amp; <name><name>sd2</name>-&gt;<name>top</name></name> == <name>top</name></expr>;</condition> <incr><expr><name>sd2</name>++</expr></incr>) <block>{
                        <if>if <condition>(<expr><name>sd2</name> &lt;= <name>sd</name></expr>)</condition><then> <block>{
                            <comment type="block">/*
                             * sd2-&gt;offset already includes delta as it stood
                             * before we entered this loop, but it must also
                             * include the delta relative to top due to all the
                             * extended jump offset immediates for the opcode
                             * starting at top, which we extend in this loop.
                             *
                             * If there is only one extended jump offset, then
                             * sd2-&gt;offset won't change and this for loop will
                             * iterate once only.
                             */</comment>
                            <expr_stmt><expr><name><name>sd2</name>-&gt;<name>offset</name></name> += <name>deltaFromTop</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>deltaFromTop</name> += <name>JUMPX_OFFSET_LEN</name> - <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
                        }</block></then> <else>else <block>{
                            <comment type="block">/*
                             * sd2 comes after sd, and won't be revisited by
                             * the outer for loop, so we have to increase its
                             * offset by delta, not merely by deltaFromTop.
                             */</comment>
                            <expr_stmt><expr><name><name>sd2</name>-&gt;<name>offset</name></name> += <name>delta</name></expr>;</expr_stmt>
                        }</block></else></if>

                        <expr_stmt><expr><name>delta</name> += <name>JUMPX_OFFSET_LEN</name> - <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>UpdateJumpTargets</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>jumpTargets</name></name></expr></argument>, <argument><expr><name><name>sd2</name>-&gt;<name>offset</name></name></expr></argument>,
                                          <argument><expr><name>JUMPX_OFFSET_LEN</name> - <name>JUMP_OFFSET_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>
                    <expr_stmt><expr><name>sd</name> = <name>sd2</name> - 1</expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></for>

        <expr_stmt><expr><name>growth</name> += <name>delta</name></expr>;</expr_stmt>
    }</block> while <condition>(<expr>!<name>done</name></expr>)</condition>;</do>

    <if>if <condition>(<expr><name>growth</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendan</name></cpp:ifdef>
        <decl_stmt><decl><type><name>JSTokenStream</name> *</type><name>ts</name> <init>= <expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name>.<name>parseContext</name>-&gt;<name>tokenStream</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s:%u: %u/%u jumps extended in %d passes (%d=%d+%d)\n"</expr></argument>,
               <argument><expr><name><name>ts</name>-&gt;<name>filename</name></name> ? <name><name>ts</name>-&gt;<name>filename</name></name> : "stdin"</expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>firstLine</name></name></expr></argument>,
               <argument><expr><name>growth</name> / (<name>JUMPX_OFFSET_LEN</name> - <name>JUMP_OFFSET_LEN</name>)</expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>numSpanDeps</name></name></expr></argument>,
               <argument><expr><name>passes</name></expr></argument>, <argument><expr><name>offset</name> + <name>growth</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>growth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Ensure that we have room for the extended jumps, but don't round up
         * to a power of two -- we're done generating code, so we cut to fit.
         */</comment>
        <expr_stmt><expr><name>limit</name> = <call><name>CG_LIMIT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> = <name>offset</name> + <name>growth</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>next</name> = <name>base</name> + <name>length</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>next</name> &gt; <name>limit</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>length</name> &gt; <name>BYTECODE_CHUNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>size</name> = <call><name>BYTECODE_SIZE</name><argument_list>(<argument><expr><call><name>PTRDIFF</name><argument_list>(<argument><expr><name>limit</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>incr</name> = <call><name>BYTECODE_SIZE</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call> - <name>size</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ARENA_GROW_CAST</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>jsbytecode</name> *</expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>codePool</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>incr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>base</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>base</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CG_LIMIT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>next</name> = <name>base</name> + <name>length</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>next</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Set up a fake span dependency record to guard the end of the code
         * being generated.  This guard record is returned as a fencepost by
         * FindNearestSpanDep if there is no real spandep at or above a given
         * unextended code offset.
         */</comment>
        <expr_stmt><expr><name><name>guard</name>.<name>top</name></name> = -1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>guard</name>.<name>offset</name></name> = <name>offset</name> + <name>growth</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>guard</name>.<name>before</name></name> = <name>offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>guard</name>.<name>target</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Now work backwards through the span dependencies, copying chunks of
     * bytecode between each extended jump toward the end of the grown code
     * space, and restoring immediate offset operands for all jump bytecodes.
     * The first chunk of bytecodes, starting at base and ending at the first
     * extended jump offset (NB: this chunk includes the operation bytecode
     * just before that immediate jump offset), doesn't need to be copied.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>sd</name> == <name>sdlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>top</name> = -1</expr>;</expr_stmt>
    <while>while <condition>(<expr>--<name>sd</name> &gt;= <name>sdbase</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name><name>sd</name>-&gt;<name>top</name></name> != <name>top</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>top</name> = <name><name>sd</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) <name><name>base</name><index>[<expr><name>top</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>type</name> = <call><name>JOF_OPTYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for (<init><expr><name>sd2</name> = <name>sd</name> - 1</expr>;</init> <condition><expr><name>sd2</name> &gt;= <name>sdbase</name> &amp;&amp; <name><name>sd2</name>-&gt;<name>top</name></name> == <name>top</name></expr>;</condition> <incr><expr><name>sd2</name>--</expr></incr>)
                <continue>continue;</continue></for>
            <expr_stmt><expr><name>sd2</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>pivot</name> = <name><name>sd2</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>top</name> == <name><name>sd2</name>-&gt;<name>before</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>oldpc</name> = <name>base</name> + <name><name>sd</name>-&gt;<name>before</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>span</name> = <call><name>SD_SPAN</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If this jump didn't need to be extended, restore its span immediate
         * offset operand now, overwriting the index of sd within cg-&gt;spanDeps
         * that was stored temporarily after *pc when BuildSpanDepTable ran.
         *
         * Note that span might fit in 16 bits even for an extended jump op,
         * if the op has multiple span operands, not all of which overflowed
         * (e.g. JSOP_LOOKUPSWITCH or JSOP_TABLESWITCH where some cases are in
         * range for a short jump, but others are not).
         */</comment>
        <if>if <condition>(<expr>!<call><name>JOF_TYPE_IS_EXTENDED_JUMP</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>JUMP_OFFSET_MIN</name> &lt;= <name>span</name> &amp;&amp; <name>span</name> &lt;= <name>JUMP_OFFSET_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>oldpc</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/*
         * Set up parameters needed to copy the next run of bytecode starting
         * at offset (which is a cursor into the unextended, original bytecode
         * vector), down to sd-&gt;before (a cursor of the same scale as offset,
         * it's the index of the original jump pc).  Reuse delta to count the
         * nominal number of bytes to copy.
         */</comment>
        <expr_stmt><expr><name>pc</name> = <name>base</name> + <name><name>sd</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>delta</name> = <name>offset</name> - <name><name>sd</name>-&gt;<name>before</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>delta</name> &gt;= 1 + <name>JUMP_OFFSET_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Don't bother copying the jump offset we're about to reset, but do
         * copy the bytecode at oldpc (which comes just before its immediate
         * jump offset operand), on the next iteration through the loop, by
         * including it in offset's new value.
         */</comment>
        <expr_stmt><expr><name>offset</name> = <name><name>sd</name>-&gt;<name>before</name></name> + 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> = <call><name>BYTECODE_SIZE</name><argument_list>(<argument><expr><name>delta</name> - (1 + <name>JUMP_OFFSET_LEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>size</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pc</name> + 1 + <name>JUMPX_OFFSET_LEN</name></expr></argument>,
                    <argument><expr><name>oldpc</name> + 1 + <name>JUMP_OFFSET_LEN</name></expr></argument>,
                    <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>SET_JUMPX_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr><name>growth</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Fix source note deltas.  Don't hardwire the delta fixup adjustment,
         * even though currently it must be JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN
         * at each sd that moved.  The future may bring different offset sizes
         * for span-dependent instruction operands.  However, we fix only main
         * notes here, not prolog notes -- we know that prolog opcodes are not
         * span-dependent, and aren't likely ever to be.
         */</comment>
        <expr_stmt><expr><name>offset</name> = <name>growth</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>sd</name> = <name>sdbase</name></expr>;</expr_stmt>
        <for>for (<init><expr><name>sn</name> = <name><name>cg</name>-&gt;<name/></name>main.<name>notes</name></expr>, <expr><name>snlimit</name> = <name>sn</name> + <name><name>cg</name>-&gt;<name/></name>main.<name>noteCount</name></expr>;</init>
             <condition><expr><name>sn</name> &lt; <name>snlimit</name></expr>;</condition>
             <incr><expr><name>sn</name> = <call><name>SN_NEXT</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
            <comment type="block">/*
             * Recall that the offset of a given note includes its delta, and
             * tells the offset of the annotated bytecode from the main entry
             * point of the script.
             */</comment>
            <expr_stmt><expr><name>offset</name> += <call><name>SN_DELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>sd</name> &lt; <name>sdlimit</name> &amp;&amp; <name><name>sd</name>-&gt;<name>before</name></name> &lt; <name>offset</name></expr>)</condition> <block>{
                <comment type="block">/*
                 * To compute the delta to add to sn, we need to look at the
                 * spandep after sd, whose offset - (before + growth) tells by
                 * how many bytes sd's instruction grew.
                 */</comment>
                <expr_stmt><expr><name>sd2</name> = <name>sd</name> + 1</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>sd2</name> == <name>sdlimit</name></expr>)</condition><then>
                    <expr_stmt><expr><name>sd2</name> = &amp;<name>guard</name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>delta</name> = <name><name>sd2</name>-&gt;<name>offset</name></name> - (<name><name>sd2</name>-&gt;<name>before</name></name> + <name>growth</name>)</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>delta</name> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>delta</name> == <name>JUMPX_OFFSET_LEN</name> - <name>JUMP_OFFSET_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>sn</name> = <call><name>js_AddToSrcNoteDelta</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>sn</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>sn</name></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>snlimit</name> = <name><name>cg</name>-&gt;<name/></name>main.<name>notes</name> + <name><name>cg</name>-&gt;<name/></name>main.<name>noteCount</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>growth</name> += <name>delta</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>sd</name>++</expr>;</expr_stmt>
            }</block></while>

            <comment type="block">/*
             * If sn has span-dependent offset operands, check whether each
             * covers further span-dependencies, and increase those operands
             * accordingly.  Some source notes measure offset not from the
             * annotated pc, but from that pc plus some small bias.  NB: we
             * assume that spec-&gt;offsetBias can't itself span span-dependent
             * instructions!
             */</comment>
            <expr_stmt><expr><name>spec</name> = &amp;<name><name>js_SrcNoteSpec</name><index>[<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>spec</name>-&gt;<name>isSpanDep</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pivot</name> = <name>offset</name> + <name><name>spec</name>-&gt;<name>offsetBias</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>n</name> = <name><name>spec</name>-&gt;<name>arity</name></name></expr>;</expr_stmt>
                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>span</name> = <call><name>js_GetSrcNoteOffset</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>span</name> == 0</expr>)</condition><then>
                        <continue>continue;</continue></then></if>
                    <expr_stmt><expr><name>target</name> = <name>pivot</name> + <name>span</name> * <name><name>spec</name>-&gt;<name>isSpanDep</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>sd2</name> = <call><name>FindNearestSpanDep</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                             <argument><expr>(<name>target</name> &gt;= <name>pivot</name>)
                                             ? <name>sd</name> - <name>sdbase</name>
                                             : 0</expr></argument>,
                                             <argument><expr>&amp;<name>guard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Increase target by sd2's before-vs-after offset delta,
                     * which is absolute (i.e., relative to start of script,
                     * as is target).  Recompute the span by subtracting its
                     * adjusted pivot from target.
                     */</comment>
                    <expr_stmt><expr><name>target</name> += <name><name>sd2</name>-&gt;<name>offset</name></name> - <name><name>sd2</name>-&gt;<name>before</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>span</name> = <name>target</name> - (<name>pivot</name> + <name>growth</name>)</expr>;</expr_stmt>
                    <expr_stmt><expr><name>span</name> *= <name><name>spec</name>-&gt;<name>isSpanDep</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>noteIndex</name> = <name>sn</name> - <name><name>cg</name>-&gt;<name/></name>main.<name>notes</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>noteIndex</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>sn</name> = <name><name>cg</name>-&gt;<name/></name>main.<name>notes</name> + <name>noteIndex</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>snlimit</name> = <name><name>cg</name>-&gt;<name/></name>main.<name>notes</name> + <name><name>cg</name>-&gt;<name/></name>main.<name>noteCount</name></expr>;</expr_stmt>
                }</block></for>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name/></name>main.<name>lastNoteOffset</name> += <name>growth</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Fix try/catch notes (O(numTryNotes * log2(numSpanDeps)), but it's
         * not clear how we can beat that).
         */</comment>
        <for>for (<init><expr><name>tryNode</name> = <name><name>cg</name>-&gt;<name>lastTryNode</name></name></expr>;</init> <condition><expr><name>tryNode</name></expr>;</condition> <incr><expr><name>tryNode</name> = <name><name>tryNode</name>-&gt;<name>prev</name></name></expr></incr>) <block>{
            <comment type="block">/*
             * First, look for the nearest span dependency at/above tn-&gt;start.
             * There may not be any such spandep, in which case the guard will
             * be returned.
             */</comment>
            <expr_stmt><expr><name>offset</name> = <name><name>tryNode</name>-&gt;<name>note</name>.<name>start</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>sd</name> = <call><name>FindNearestSpanDep</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>guard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>delta</name> = <name><name>sd</name>-&gt;<name>offset</name></name> - <name><name>sd</name>-&gt;<name>before</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tryNode</name>-&gt;<name>note</name>.<name>start</name></name> = <name>offset</name> + <name>delta</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Next, find the nearest spandep at/above tn-&gt;start + tn-&gt;length.
             * Use its delta minus tn-&gt;start's delta to increase tn-&gt;length.
             */</comment>
            <expr_stmt><expr><name>length</name> = <name><name>tryNode</name>-&gt;<name>note</name>.<name>length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>sd2</name> = <call><name>FindNearestSpanDep</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>offset</name> + <name>length</name></expr></argument>, <argument><expr><name>sd</name> - <name>sdbase</name></expr></argument>, <argument><expr>&amp;<name>guard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>sd2</name> != <name>sd</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>tryNode</name>-&gt;<name>note</name>.<name>length</name></name> =
                    <name>length</name> + <name><name>sd2</name>-&gt;<name>offset</name></name> - <name><name>sd2</name>-&gt;<name>before</name></name> - <name>delta</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_brendan</name></cpp:ifdef>
  <block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>bigspans</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>top</name> = -1</expr>;</expr_stmt>
    <for>for (<init><expr><name>sd</name> = <name>sdbase</name></expr>;</init> <condition><expr><name>sd</name> &lt; <name>sdlimit</name></expr>;</condition> <incr><expr><name>sd</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>offset</name> = <name><name>sd</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>

        <comment type="block">/* NB: sd-&gt;top cursors into the original, unextended bytecode vector. */</comment>
        <if>if <condition>(<expr><name><name>sd</name>-&gt;<name>top</name></name> != <name>top</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>top</name> == -1 ||
                      !<call><name>JOF_TYPE_IS_EXTENDED_JUMP</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> ||
                      <name>bigspans</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>bigspans</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>top</name> = <name><name>sd</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>top</name> == <name><name>sd</name>-&gt;<name>before</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = (<name>JSOp</name>) <name><name>base</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>type</name> = <call><name>JOF_OPTYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> == <name>JOF_JUMP</name> ||
                      <name>type</name> == <name>JOF_JUMPX</name> ||
                      <name>type</name> == <name>JOF_TABLESWITCH</name> ||
                      <name>type</name> == <name>JOF_TABLESWITCHX</name> ||
                      <name>type</name> == <name>JOF_LOOKUPSWITCH</name> ||
                      <name>type</name> == <name>JOF_LOOKUPSWITCHX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pivot</name> = <name>offset</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>pc</name> = <name>base</name> + <name>offset</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>JOF_TYPE_IS_EXTENDED_JUMP</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>span</name> = <call><name>GET_JUMPX_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>span</name> &lt; <name>JUMP_OFFSET_MIN</name> || <name>JUMP_OFFSET_MAX</name> &lt; <name>span</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>bigspans</name>++</expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>type</name> == <name>JOF_TABLESWITCHX</name> ||
                          <name>type</name> == <name>JOF_LOOKUPSWITCHX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>span</name> = <call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>SD_SPAN</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>)</argument_list></call> == <name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<call><name>JOF_TYPE_IS_EXTENDED_JUMP</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> || <name>bigspans</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Reset so we optimize at most once -- cg may be used for further code
     * generation of successive, independent, top-level statements.  No jump
     * can span top-level statements, because JS lacks goto.
     */</comment>
    <expr_stmt><expr><name>size</name> = <call><name>SPANDEPS_SIZE</name><argument_list>(<argument><expr><call><name>JS_BIT</name><argument_list>(<argument><expr><call><name>JS_CeilingLog2</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>numSpanDeps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>spanDeps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>spanDeps</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FreeJumpTargets</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>jumpTargets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>jumpTargets</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>numSpanDeps</name></name> = <name><name>cg</name>-&gt;<name>numJumpTargets</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>spanDepTodo</name></name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitJump</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>extend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>jmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>extend</name> = <name>off</name> &lt; <name>JUMP_OFFSET_MIN</name> || <name>JUMP_OFFSET_MAX</name> &lt; <name>off</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>extend</name> &amp;&amp; !<name><name>cg</name>-&gt;<name>spanDeps</name></name> &amp;&amp; !<call><name>BuildSpanDepTable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>jmp</name> = <call><name>js_Emit3</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>JUMP_OFFSET_HI</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>JUMP_OFFSET_LO</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>jmp</name> &gt;= 0 &amp;&amp; (<name>extend</name> || <name><name>cg</name>-&gt;<name>spanDeps</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pc</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>jmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>AddSpanDep</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then></if>
    <return>return <expr><name>jmp</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>GetJumpOffset</name><parameter_list>(<param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSSpanDep</name> *</type><name>sd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSJumpTarget</name> *</type><name>jt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>top</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>cg</name>-&gt;<name>spanDeps</name></name></expr>)</condition><then>
        <return>return <expr><call><name>GET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>sd</name> = <call><name>GetSpanDep</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jt</name> = <name><name>sd</name>-&gt;<name>target</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>JT_HAS_TAG</name><argument_list>(<argument><expr><name>jt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>JT_TO_BPDELTA</name><argument_list>(<argument><expr><name>jt</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>top</name> = <name><name>sd</name>-&gt;<name>top</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr>--<name>sd</name> &gt;= <name><name>cg</name>-&gt;<name>spanDeps</name></name> &amp;&amp; <name><name>sd</name>-&gt;<name>top</name></name> == <name>top</name></expr>)</condition>
        <continue>continue;</continue></while>
    <expr_stmt><expr><name>sd</name>++</expr>;</expr_stmt>
    <return>return <expr><call><name>JT_CLR_TAG</name><argument_list>(<argument><expr><name>jt</name></expr></argument>)</argument_list></call>-&gt;<name>offset</name> - <name><name>sd</name>-&gt;<name>offset</name></name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_SetJumpOffset</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl></param>,
                 <param><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name><name>cg</name>-&gt;<name>spanDeps</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>JUMP_OFFSET_MIN</name> &lt;= <name>off</name> &amp;&amp; <name>off</name> &lt;= <name>JUMP_OFFSET_MAX</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>SET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr>!<call><name>BuildSpanDepTable</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then></if>

    <return>return <expr><call><name>SetSpanDepTarget</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>GetSpanDep</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_InStatement</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>JSStmtType</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>stmt</name> = <name><name>tc</name>-&gt;<name>topStmt</name></name></expr>;</init> <condition><expr><name>stmt</name></expr>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>type</name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
    }</block></for>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_IsGlobalReference</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>JSBool</name> *</type><name>loopyp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScope</name> *</type><name>scope</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>loopyp</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>stmt</name> = <name><name>tc</name>-&gt;<name>topStmt</name></name></expr>;</init> <condition><expr><name>stmt</name></expr>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_WITH</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>STMT_IS_LOOP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>loopyp</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>STOBJ_GET_CLASS</name><argument_list>(<argument><expr><name><name>stmt</name>-&gt;<name>u</name>.<name>blockObj</name></name></expr></argument>)</argument_list></call> == &amp;<name>js_BlockClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>scope</name> = <call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name><name>stmt</name>-&gt;<name>u</name>.<name>blockObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>SCOPE_GET_PROPERTY</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>
    }</block></for>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_PushStatement</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl></param>, <param><decl><type><name>JSStmtType</name></type> <name>type</name></decl></param>,
                 <param><decl><type><name>ptrdiff_t</name></type> <name>top</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>stmt</name>-&gt;<name>type</name></name> = <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name>-&gt;<name>flags</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_STATEMENT_TOP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name>-&gt;<name>u</name>.<name>label</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>stmt</name>-&gt;<name>u</name>.<name>blockObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name>-&gt;<name>down</name></name> = <name><name>tc</name>-&gt;<name>topStmt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>topStmt</name></name> = <name>stmt</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>STMT_LINKS_SCOPE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>stmt</name>-&gt;<name>downScope</name></name> = <name><name>tc</name>-&gt;<name>topScopeStmt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name> = <name>stmt</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>stmt</name>-&gt;<name>downScope</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><name>void</name></type>
<name>js_PushBlockScope</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl></param>, <param><decl><type><name>JSObject</name> *</type><name>blockObj</name></decl></param>,
                  <param><decl><type><name>ptrdiff_t</name></type> <name>top</name></decl></param>)</parameter_list>
<block>{

    <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>STMT_BLOCK</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name>-&gt;<name>flags</name></name> |= <name>SIF_SCOPE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>STOBJ_SET_PARENT</name><argument_list>(<argument><expr><name>blockObj</name></expr></argument>, <argument><expr><name><name>tc</name>-&gt;<name>blockChain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name>-&gt;<name>downScope</name></name> = <name><name>tc</name>-&gt;<name>topScopeStmt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name> = <name>stmt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>blockChain</name></name> = <name>blockObj</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>stmt</name>-&gt;<name>u</name>.<name>blockObj</name></name> = <name>blockObj</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Emit a backpatch op with offset pointing to the previous jump of this type,
 * so that we can walk back up the chain fixing up the op and jump offset.
 */</comment>
<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>EmitBackPatchOp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>ptrdiff_t</name> *</type><name>lastp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>delta</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>offset</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>delta</name> = <name>offset</name> - *<name>lastp</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>lastp</name> = <name>offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>delta</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * Macro to emit a bytecode followed by a uint16 immediate operand stored in
 * big-endian order, used for arg and var numbers as well as for atomIndexes.
 * NB: We use cx and cg from our caller's lexical environment, and return
 * false on error.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMIT_UINT16_IMM_OP</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>i</name></type></param>)</parameter_list></cpp:macro>                                             \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        if (js_Emit3(cx, cg, op, UINT16_HI(i), UINT16_LO(i)) &lt; 0)             \
            return JS_FALSE;                                                  \
    JS_END_MACRO</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>FlushPops</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>intN</name> *</type><name>npops</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>npops</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_POPN</name></expr></argument>, <argument><expr>*<name>npops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>npops</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Emit additional bytecode(s) for non-local jumps.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitNonLocalJumpFixup</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSStmtInfo</name> *</type><name>toStmt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>intN</name></type> <name>depth</name></decl>, <decl><type ref="prev"/><name>npops</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The non-local jump fixup we emit will unbalance cg-&gt;stackDepth, because
     * the fixup replicates balanced code such as JSOP_LEAVEWITH emitted at the
     * end of a with statement, so we save cg-&gt;stackDepth here and restore it
     * just before a successful return.
     */</comment>
    <expr_stmt><expr><name>depth</name> = <name><name>cg</name>-&gt;<name>stackDepth</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>npops</name> = 0</expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLUSH_POPS</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>if (npops &amp;&amp; !FlushPops(cx, cg, &amp;npops)) return JS_FALSE</cpp:value></cpp:define>

    <for>for (<init><expr><name>stmt</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name></name></expr>;</init> <condition><expr><name>stmt</name> != <name>toStmt</name></expr>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr></incr>) <block>{
        <switch>switch <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
          <case>case <expr><name>STMT_FINALLY</name></expr>:
            <expr_stmt><expr><call><name>FLUSH_POPS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>EmitBackPatchOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BACKPATCH</name></expr></argument>, <argument><expr>&amp;<call><name>GOSUBS</name><argument_list>(<argument><expr>*<name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>

          </case><case>case <expr><name>STMT_WITH</name></expr>:
            <comment type="block">/* There's a With object on the stack that we need to pop. */</comment>
            <expr_stmt><expr><call><name>FLUSH_POPS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_LEAVEWITH</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>

          </case><case>case <expr><name>STMT_FOR_IN_LOOP</name></expr>:
            <comment type="block">/*
             * The iterator and the object being iterated need to be popped.
             */</comment>
            <expr_stmt><expr><call><name>FLUSH_POPS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ENDITER</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>

          </case><case>case <expr><name>STMT_SUBROUTINE</name></expr>:
            <comment type="block">/*
             * There's a [exception or hole, retsub pc-index] pair on the
             * stack that we need to pop.
             */</comment>
            <expr_stmt><expr><name>npops</name> += 2</expr>;</expr_stmt>
            <break>break;</break>

          </case><default>default:<empty_stmt>;</empty_stmt>
        </default>}</block></switch>

        <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>uintN</name></type> <name>i</name></decl>;</decl_stmt>

            <comment type="block">/* There is a Block object with locals on the stack to pop. */</comment>
            <expr_stmt><expr><call><name>FLUSH_POPS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>i</name> = <call><name>OBJ_BLOCK_COUNT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>stmt</name>-&gt;<name>u</name>.<name>blockObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_LEAVEBLOCK</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <expr_stmt><expr><call><name>FLUSH_POPS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> = <name>depth</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FLUSH_POPS</name></cpp:undef>
}</block></function>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>EmitGoto</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSStmtInfo</name> *</type><name>toStmt</name></decl></param>,
         <param><decl><type><name>ptrdiff_t</name> *</type><name>lastp</name></decl></param>, <param><decl><type><name>JSAtomListElement</name> *</type><name>label</name></decl></param>, <param><decl><type><name>JSSrcNoteType</name></type> <name>noteType</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>intN</name></type> <name>index</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>EmitNonLocalJumpFixup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>toStmt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <if>if <condition>(<expr><name>label</name></expr>)</condition><then>
        <expr_stmt><expr><name>index</name> = <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>noteType</name></expr></argument>, <argument><expr>(<name>ptrdiff_t</name>) <call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>noteType</name> != <name>SRC_NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>index</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>noteType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt></else></if></else></if>
    <if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <return>return <expr><call><name>EmitBackPatchOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BACKPATCH</name></expr></argument>, <argument><expr><name>lastp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>BackPatch</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>last</name></decl></param>,
          <param><decl><type><name>jsbytecode</name> *</type><name>target</name></decl></param>, <param><decl><type><name>jsbytecode</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>, *<decl><type ref="prev"/><name>stop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>delta</name></decl>, <decl><type ref="prev"/><name>span</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pc</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stop</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pc</name> != <name>stop</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>delta</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>span</name> = <call><name>PTRDIFF</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>jsbytecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Set *pc after jump offset in case bpdelta didn't overflow, but span
         * does (if so, CHECK_AND_SET_JUMP_OFFSET might call BuildSpanDepTable
         * and need to see the JSOP_BACKPATCH* op at *pc).
         */</comment>
        <expr_stmt><expr>*<name>pc</name> = <name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> -= <name>delta</name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_PopStatement</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>stmt</name> = <name><name>tc</name>-&gt;<name>topStmt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tc</name>-&gt;<name>topStmt</name></name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>STMT_LINKS_SCOPE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name> = <name><name>stmt</name>-&gt;<name>downScope</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>blockChain</name></name> = <call><name>STOBJ_GET_PARENT</name><argument_list>(<argument><expr><name><name>stmt</name>-&gt;<name>u</name>.<name>blockObj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>--<name><name>tc</name>-&gt;<name>scopeDepth</name></name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_PopStatementCG</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>stmt</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>STMT_IS_TRYING</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> &amp;&amp;
        (!<call><name>BackPatch</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>stmt</name>-&gt;<name>breaks</name></name></expr></argument>, <argument><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>JSOP_GOTO</name></expr></argument>)</argument_list></call> ||
         !<call><name>BackPatch</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>stmt</name>-&gt;<name>continues</name></name></expr></argument>, <argument><expr><call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>stmt</name>-&gt;<name>update</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>JSOP_GOTO</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>js_PopStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_DefineCompileTimeConstant</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>,
                             <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>dval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>ival</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>valueAtom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>

    <comment type="block">/* XXX just do numbers for now */</comment>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>dval</name> = <name><name>pn</name>-&gt;<name>pn_dval</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>JSDOUBLE_IS_INT</name><argument_list>(<argument><expr><name>dval</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>INT_FITS_IN_JSVAL</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>v</name> = <call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * We atomize double to root a jsdouble instance that we wrap as
             * jsval and store in cg-&gt;constList. This works because atoms are
             * protected from GC during compilation.
             */</comment>
            <expr_stmt><expr><name>valueAtom</name> = <call><name>js_AtomizeDouble</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>valueAtom</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>v</name> = <call><name>ATOM_KEY</name><argument_list>(<argument><expr><name>valueAtom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>constList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>ale</name>-&gt;<name>entry</name>.<name>value</name></name> = (<name>void</name> *)<name>v</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LET_DECL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR_DECL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<function><type><name>JSStmtInfo</name> *</type>
<name>js_LexicalLookup</name><parameter_list>(<param><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>, <param><decl><type><name>jsint</name> *</type><name>slotp</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>decltype</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScope</name> *</type><name>scope</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScopeProperty</name> *</type><name>sprop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>stmt</name> = <name><name>tc</name>-&gt;<name>topScopeStmt</name></name></expr>;</init> <condition><expr><name>stmt</name></expr>;</condition> <incr><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>downScope</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_WITH</name></expr>)</condition><then> <block>{
            <comment type="block">/* Ignore with statements enclosing a single let declaration. */</comment>
            <if>if <condition>(<expr><name>decltype</name> == <name>LET_DECL</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/* Skip "maybe scope" statements that don't contain let bindings. */</comment>
        <if>if <condition>(<expr>!(<name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name>)</expr>)</condition><then>
            <continue>continue;</continue></then></if>

        <expr_stmt><expr><name>obj</name> = <name><name>stmt</name>-&gt;<name>u</name>.<name>blockObj</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>LOCKED_OBJ_GET_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> == &amp;<name>js_BlockClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scope</name> = <call><name>OBJ_SCOPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sprop</name> = <call><name>SCOPE_GET_PROPERTY</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>sprop</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>sprop</name>-&gt;<name>flags</name></name> &amp; <name>SPROP_HAS_SHORTID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>slotp</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * Use LOCKED_OBJ_GET_SLOT since we know obj is single-
                 * threaded and owned by this compiler activation.
                 */</comment>
                <expr_stmt><expr><name>v</name> = <call><name>LOCKED_OBJ_GET_SLOT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>JSSLOT_BLOCK_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>slotp</name> = <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name><name>sprop</name>-&gt;<name>shortid</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>stmt</name></expr>;</return>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>slotp</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>slotp</name> = -1</expr>;</expr_stmt></then></if>
    <return>return <expr><name>stmt</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Check if the attributes describe a property holding a compile-time constant
 * or a permanent, read-only property without a getter.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_CONSTANT_PROPERTY</name><parameter_list>(<param><type><name>attrs</name></type></param>)</parameter_list></cpp:macro>                                           \
    <cpp:value>(((attrs) &amp; (JSPROP_READONLY | JSPROP_PERMANENT | JSPROP_GETTER)) ==      \
     (JSPROP_READONLY | JSPROP_PERMANENT))</cpp:value></cpp:define>

<comment type="block">/*
 * The function sets vp to JSVAL_HOLE when the atom does not corresponds to a
 * name defining a constant.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>LookupCompileTimeConstant</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSAtom</name> *</type><name>atom</name></decl></param>,
                          <param><decl><type><name>jsval</name> *</type><name>vp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>, *<decl><type ref="prev"/><name>pobj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSProperty</name> *</type><name>prop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>attrs</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Chase down the cg stack, but only until we reach the outermost cg.
     * This enables propagating consts from top-level into switch cases in a
     * function compiled along with the top-level script.
     */</comment>
    <expr_stmt><expr>*<name>vp</name> = <name>JSVAL_HOLE</name></expr>;</expr_stmt>
    <do>do <block>{
        <if>if <condition>(<expr>(<name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>) ||
            <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>varobj</name></name> == <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>scopeChain</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* XXX this will need revising when 'let const' is added. */</comment>
            <expr_stmt><expr><name>stmt</name> = <call><name>js_LexicalLookup</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>&amp;<name>slot</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>stmt</name></expr>)</condition><then>
                <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

            <expr_stmt><expr><call><name>ATOM_LIST_SEARCH</name><argument_list>(<argument><expr><name>ale</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>constList</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>ale</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>ALE_VALUE</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call> != <name>JSVAL_HOLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>vp</name> = <call><name>ALE_VALUE</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_TRUE</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/*
             * Try looking in the variable object for a direct property that
             * is readonly and permanent.  We know such a property can't be
             * shadowed by another property on obj's prototype chain, or a
             * with object or catch variable; nor can prop's value be changed,
             * nor can prop be deleted.
             */</comment>
            <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>js_LookupLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>FUN_TO_SCRIPTED</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>funobj</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>atom</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != <name>JSLOCAL_NONE</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
            }</block></then> <else>else <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_COMPILE_N_GO</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>obj</name> = <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>varobj</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ok</name> = <call><name>OBJ_LOOKUP_PROPERTY</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>pobj</name></expr></argument>,
                                         <argument><expr>&amp;<name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr><name>pobj</name> == <name>obj</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * We're compiling code that will be executed immediately,
                     * not re-executed against a different scope chain and/or
                     * variable object.  Therefore we can get constant values
                     * from our variable object here.
                     */</comment>
                    <expr_stmt><expr><name>ok</name> = <call><name>OBJ_GET_ATTRIBUTES</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prop</name></expr></argument>,
                                            <argument><expr>&amp;<name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>ok</name> &amp;&amp; <call><name>IS_CONSTANT_PROPERTY</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>ok</name> = <call><name>OBJ_GET_PROPERTY</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>ATOM_TO_JSID</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>JS_ASSERT_IF</name><argument_list>(<argument><expr><name>ok</name></expr></argument>, <argument><expr>*<name>vp</name> != <name>JSVAL_HOLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <if>if <condition>(<expr><name>prop</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>OBJ_DROP_PROPERTY</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pobj</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr><name>prop</name></expr>)</condition><then>
                    <break>break;</break></then></if>
            }</block></then></if></else></if>
        }</block></then></if>
    }</block> while <condition>(<expr>(<name>cg</name> = <name><name>cg</name>-&gt;<name>parent</name></name>) != <name>NULL</name></expr>)</condition>;</do>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Return JSOP_NOP to indicate that index fits 2 bytes and no index segment
 * reset instruction is necessary, JSOP_FALSE to indicate an error or either
 * JSOP_RESETBASE0 or JSOP_RESETBASE1 to indicate the reset bytecode to issue
 * after the main bytecode sequence.
 */</comment>
<function><type><specifier>static</specifier> <name>JSOp</name></type>
<name>EmitBigIndexPrefix</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>indexBase</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We have max 3 bytes for indexes and check for INDEX_LIMIT overflow only
     * for big indexes.
     */</comment>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>INDEX_LIMIT</name> &lt;= <call><name>JS_BIT</name><argument_list>(<argument><expr>24</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>INDEX_LIMIT</name> &gt;=
                     (<name>JSOP_INDEXBASE3</name> - <name>JSOP_INDEXBASE1</name> + 2) &lt;&lt; 16</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>index</name> &lt; <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JSOP_NOP</name></expr>;</return></then></if>
    <expr_stmt><expr><name>indexBase</name> = <name>index</name> &gt;&gt; 16</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>indexBase</name> &lt;= <name>JSOP_INDEXBASE3</name> - <name>JSOP_INDEXBASE1</name> + 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call>(<name>JSOp</name>)<argument_list>(<argument><expr><name>JSOP_INDEXBASE1</name> + <name>indexBase</name> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JSOP_FALSE</name></expr>;</return></then></if>
        <return>return <expr><name>JSOP_RESETBASE0</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>index</name> &gt;= <name>INDEX_LIMIT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ReportErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>js_GetErrorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>JSMSG_TOO_MANY_LITERALS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JSOP_FALSE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>js_Emit2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_INDEXBASE</name></expr></argument>, <argument><expr>(<name>JSOp</name>)<name>indexBase</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>JSOP_FALSE</name></expr>;</return></then></if>
    <return>return <expr><name>JSOP_RESETBASE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Emit a bytecode and its 2-byte constant index immediate operand. If the
 * index requires more than 2 bytes, emit a prefix op whose 8-bit immediate
 * operand effectively extends the 16-bit immediate of the prefixed opcode,
 * by changing index "segment" (see jsinterp.c). We optimize segments 1-3
 * with single-byte JSOP_INDEXBASE[123] codes.
 *
 * Such prefixing currently requires a suffix to restore the "zero segment"
 * register setting, but this could be optimized further.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitIndexOp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>index</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>bigSuffix</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bigSuffix</name> = <call><name>EmitBigIndexPrefix</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>bigSuffix</name> == <name>JSOP_FALSE</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>bigSuffix</name> == <name>JSOP_NOP</name> || <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>bigSuffix</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
}</block></function>

<comment type="block">/*
 * Slight sugar for EmitIndexOp, again accessing cx and cg from the macro
 * caller's lexical environment, and embedding a false return on error.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMIT_INDEX_OP</name><parameter_list>(<param><type><name>op</name></type></param>, <param><type><name>index</name></type></param>)</parameter_list></cpp:macro>                                              \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        if (!EmitIndexOp(cx, op, index, cg))                                  \
            return JS_FALSE;                                                  \
    JS_END_MACRO</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitAtomOp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JOF_OPTYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> == <name>JOF_ATOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>op</name> == <name>JSOP_GETPROP</name> &amp;&amp;
        <name><name>pn</name>-&gt;<name>pn_atom</name></name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lengthAtom</name></name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_LENGTH</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <return>return <expr><call><name>EmitIndexOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>uintN</name></type>
<name>IndexParsedObject</name><parameter_list>(<param><decl><type><name>JSParsedObjectBox</name> *</type><name>pob</name></decl></param>, <param><decl><type><name>JSEmittedObjectList</name> *</type><name>list</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitObjectOp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParsedObjectBox</name> *</type><name>pob</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>,
             <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JOF_OPTYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> == <name>JOF_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>EmitIndexOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>IndexParsedObject</name><argument_list>(<argument><expr><name>pob</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>objectList</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * What good are ARGNO_LEN and VARNO_LEN, you ask?  The answer is that, apart
 * from EmitSlotIndexOp, they abstract out the detail that both are 2, and in
 * other parts of the code there's no necessary relationship between the two.
 * The abstraction cracks here in order to share EmitSlotIndexOp code among
 * the JSOP_DEFLOCALFUN and JSOP_GET{ARG,VAR,LOCAL}PROP cases.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>ARGNO_LEN</name> == 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><name>VARNO_LEN</name> == 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitSlotIndexOp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>slot</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>index</name></decl></param>,
                 <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>bigSuffix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JOF_OPTYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> == <name>JOF_SLOTATOM</name> ||
              <call><name>JOF_OPTYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> == <name>JOF_SLOTOBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bigSuffix</name> = <call><name>EmitBigIndexPrefix</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>bigSuffix</name> == <name>JSOP_FALSE</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/* Emit [op, slot, index]. */</comment>
    <expr_stmt><expr><name>off</name> = <call><name>js_EmitN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>2 + <name>INDEX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>pc</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_UINT16</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> += 2</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_INDEX</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>bigSuffix</name> == <name>JSOP_NOP</name> || <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>bigSuffix</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
}</block></function>

<comment type="block">/*
 * This routine tries to optimize name gets and sets to stack slot loads and
 * stores, given the variables object and scope chain in cx's top frame, the
 * compile-time context in tc, and a TOK_NAME node pn.  It returns false on
 * error, true on success.
 *
 * The caller can inspect pn-&gt;pn_slot for a non-negative slot number to tell
 * whether optimization occurred, in which case BindNameToSlot also updated
 * pn-&gt;pn_op.  If pn-&gt;pn_slot is still -1 on return, pn-&gt;pn_op nevertheless
 * may have been optimized, e.g., from JSOP_NAME to JSOP_ARGUMENTS.  Whether
 * or not pn-&gt;pn_op was modified, if this function finds an argument or local
 * variable name, pn-&gt;pn_const will be true for const properties after a
 * successful return.
 *
 * NB: if you add more opcodes specialized from JSOP_NAME, etc., don't forget
 * to update the TOK_FOR (for-in) and TOK_ASSIGN (op=, e.g. +=) special cases
 * in js_EmitTree.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>BindNameToSlot</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>,
               <param><decl><type><name>uintN</name></type> <name>decltype</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name> *</type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSLocalKind</name></type> <name>localKind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>constOp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_slot</name></name> &gt;= 0 || <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_ARGUMENTS</name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <comment type="block">/* QNAME references can never be optimized to use arg/var storage. */</comment>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_QNAMEPART</name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <comment type="block">/*
     * We can't optimize if we are compiling a with statement and its body,
     * or we're in a catch block whose exception variable has the same name
     * as this node.  FIXME: we should be able to optimize catch vars to be
     * block-locals.
     */</comment>
    <expr_stmt><expr><name>tc</name> = &amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>atom</name> = <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decltype</name> != <name>VAR_DECL</name> &amp;&amp;
        (<name>stmt</name> = <call><name>js_LexicalLookup</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>&amp;<name>slot</name></expr></argument>, <argument><expr><name>decltype</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_WITH</name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>slot</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
          <case>case <expr><name>JSOP_NAME</name></expr>:     <expr_stmt><expr><name>op</name> = <name>JSOP_GETLOCAL</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_SETNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_SETLOCAL</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_INCNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_INCLOCAL</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_NAMEINC</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_LOCALINC</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_DECNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_DECLOCAL</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_NAMEDEC</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_LOCALDEC</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_FORNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_FORLOCAL</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_DELNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_FALSE</name></expr>;</expr_stmt> <break>break;</break>
          </case><default>default: <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
        <if>if <condition>(<expr><name>op</name> != <name><name>pn</name>-&gt;<name>pn_op</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>op</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_slot</name></name> = <name>slot</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * We can't optimize if var and closure (a local function not in a larger
     * expression and not at top-level within another's body) collide.
     * XXX suboptimal: keep track of colliding names and deoptimize only those
     */</comment>
    <if>if <condition>(<expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_FUN_CLOSURE_VS_VAR</name></expr>)</condition><then>
        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!(<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>) &amp;&amp;
        !((<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_SPECIAL</name>) &amp;&amp; <name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>fun</name></name>)</expr>)</condition><then> <block>{
        <comment type="block">/*
         * We are compiling a script or eval and eval is not inside a function
         * frame.
         *
         * We can't optimize if we are in an eval called inside a with
         * statement.
         */</comment>
        <expr_stmt><expr><name>fp</name> = <name><name>cx</name>-&gt;<name>fp</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>scopeChain</name></name> != <name><name>fp</name>-&gt;<name>varobj</name></name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

        <comment type="block">/*
         * A Script object can be used to split an eval into a compile step
         * done at construction time, and an execute step done separately,
         * possibly in a different scope altogether.  We therefore cannot do
         * any name-to-slot optimizations, but must lookup names at runtime.
         * Note that script_exec ensures that its caller's frame has a Call
         * object, so arg and var name lookups will succeed.
         */</comment>
        <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_SCRIPT_OBJECT</name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

        <comment type="block">/*
         * We cannot optimize the name access when compiling with an eval or
         * debugger frame.
         */</comment>
        <if>if <condition>(<expr><name><name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_SPECIAL</name></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

        <comment type="block">/*
         * We are compiling a top-level script. Optimize global variable
         * accesses if there are at least 100 uses in unambiguous contexts,
         * or failing that, if least half of all the uses of global
         * vars/consts/functions are in loops.
         */</comment>
        <if>if <condition>(<expr>!(<name><name>tc</name>-&gt;<name>globalUses</name></name> &gt;= 100 ||
              (<name><name>tc</name>-&gt;<name>loopyGlobalUses</name></name> &amp;&amp;
               <name><name>tc</name>-&gt;<name>loopyGlobalUses</name></name> &gt;= <name><name>tc</name>-&gt;<name>globalUses</name></name> / 2))</expr>)</condition><then> <block>{
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/*
         * We are optimizing global variables and there may be no pre-existing
         * global property named atom.  If atom was declared via const or var,
         * optimize pn to access fp-&gt;vars using the appropriate JSOP_*GVAR op.
         */</comment>
        <expr_stmt><expr><call><name>ATOM_LIST_SEARCH</name><argument_list>(<argument><expr><name>ale</name></expr></argument>, <argument><expr>&amp;<name><name>tc</name>-&gt;<name>decls</name></name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then> <block>{
            <comment type="block">/* Use precedes declaration, or name is never declared. */</comment>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>constOp</name> = (<call><name>ALE_JSOP</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call> == <name>JSOP_DEFCONST</name>)</expr>;</expr_stmt>

        <comment type="block">/* Index atom so we can map fast global number to name. */</comment>
        <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/* Defend against tc-&gt;ngvars 16-bit overflow. */</comment>
        <expr_stmt><expr><name>slot</name> = <call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>slot</name> + 1) &gt;&gt; 16</expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>

        <if>if <condition>(<expr><call>(<name>uint16</name>)<argument_list>(<argument><expr><name>slot</name> + 1</expr></argument>)</argument_list></call> &gt; <name><name>tc</name>-&gt;<name>ngvars</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>tc</name>-&gt;<name>ngvars</name></name> = <call>(<name>uint16</name>)<argument_list>(<argument><expr><name>slot</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
          <case>case <expr><name>JSOP_NAME</name></expr>:     <expr_stmt><expr><name>op</name> = <name>JSOP_GETGVAR</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_SETNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_SETGVAR</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_SETCONST</name></expr>: <comment type="block">/* NB: no change */</comment> <break>break;</break>
          </case><case>case <expr><name>JSOP_INCNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_INCGVAR</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_NAMEINC</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_GVARINC</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_DECNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_DECGVAR</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_NAMEDEC</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_GVARDEC</name></expr>;</expr_stmt> <break>break;</break>
          </case><case>case <expr><name>JSOP_FORNAME</name></expr>:  <comment type="block">/* NB: no change */</comment> <break>break;</break>
          </case><case>case <expr><name>JSOP_DELNAME</name></expr>:  <comment type="block">/* NB: no change */</comment> <break>break;</break>
          </case><default>default: <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_const</name></name> = <name>constOp</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> != <name><name>pn</name>-&gt;<name>pn_op</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>op</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_slot</name></name> = <name>slot</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * We are compiling a function body and may be able to optimize name
         * to stack slot. Look for an argument or variable in the function and
         * rewrite pn_op and update pn accordingly.
         */</comment>
        <expr_stmt><expr><name>localKind</name> = <call><name>js_LookupLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>FUN_TO_SCRIPTED</name><argument_list>(<argument><expr><name><name>tc</name>-&gt;<name>funobj</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>atom</name></expr></argument>,
                                   <argument><expr>&amp;<name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>localKind</name> != <name>JSLOCAL_NONE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>localKind</name> == <name>JSLOCAL_ARG</name></expr>)</condition><then> <block>{
                <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
                  <case>case <expr><name>JSOP_NAME</name></expr>:     <expr_stmt><expr><name>op</name> = <name>JSOP_GETARG</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_SETNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_SETARG</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_INCNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_INCARG</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_NAMEINC</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_ARGINC</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_DECNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_DECARG</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_NAMEDEC</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_ARGDEC</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_FORNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_FORARG</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_DELNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_FALSE</name></expr>;</expr_stmt> <break>break;</break>
                  </case><default>default: <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </default>}</block></switch>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_const</name></name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>localKind</name> == <name>JSLOCAL_VAR</name> ||
                          <name>localKind</name> == <name>JSLOCAL_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
                  <case>case <expr><name>JSOP_NAME</name></expr>:     <expr_stmt><expr><name>op</name> = <name>JSOP_GETVAR</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_SETNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_SETVAR</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_SETCONST</name></expr>: <expr_stmt><expr><name>op</name> = <name>JSOP_SETVAR</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_INCNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_INCVAR</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_NAMEINC</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_VARINC</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_DECNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_DECVAR</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_NAMEDEC</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_VARDEC</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_FORNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_FORVAR</name></expr>;</expr_stmt> <break>break;</break>
                  </case><case>case <expr><name>JSOP_DELNAME</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_FALSE</name></expr>;</expr_stmt> <break>break;</break>
                  </case><default>default: <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </default>}</block></switch>
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_const</name></name> = (<name>localKind</name> == <name>JSLOCAL_CONST</name>)</expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>op</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_slot</name></name> = <name>index</name></expr>;</expr_stmt>
            <return>return <expr><name>JS_TRUE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>tc</name>-&gt;<name>flags</name></name> |= <name>TCF_FUN_USES_NONLOCALS</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Here we either compiling a function body or an eval script inside a
     * function and couldn't optimize pn, so it's not a global or local slot
     * name.
     *
     * Now we must check for the predefined arguments variable.  It may be
     * overridden by assignment, in which case the function is heavyweight
     * and the interpreter will look up 'arguments' in the function's call
     * object.
     */</comment>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NAME</name> &amp;&amp;
        <name>atom</name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>argumentsAtom</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> = <name>JSOP_ARGUMENTS</name></expr>;</expr_stmt>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * If pn contains a useful expression, return true with *answer set to true.
 * If pn contains a useless expression, return true with *answer set to false.
 * Return false on error.
 *
 * The caller should initialize *answer to false and invoke this function on
 * an expression statement or similar subtree to decide whether the tree could
 * produce code that has any side effects.  For an expression statement, we
 * define useless code as code with no side effects, because the main effect,
 * the value left on the stack after the code executes, will be discarded by a
 * pop bytecode.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>CheckSideEffects</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>,
                 <param><decl><type><name>JSBool</name> *</type><name>answer</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScriptedFunction</name> *</type><name>fun</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>pn</name> || *<name>answer</name></expr>)</condition><then>
        <return>return <expr><name>ok</name></expr>;</return></then></if>

    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name></expr>)</condition> <block>{
      <case>case <expr><name>PN_FUNC</name></expr>:
        <comment type="block">/*
         * A named function is presumed useful: we can't yet know that it is
         * not called.  The side effects are the creation of a scope object
         * to parent this function object, and the binding of the function's
         * name in that scope object.  See comments at case JSOP_NAMEDFUNOBJ:
         * in jsinterp.c.
         */</comment>
        <expr_stmt><expr><name>fun</name> = <call><name>FUN_TO_SCRIPTED</name><argument_list>(<argument><expr><call><name>OBJ_TO_FUNCTION</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_funpob</name>-&gt;<name>object</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>fun</name>-&gt;<name>atom</name></name></expr>)</condition><then>
            <expr_stmt><expr>*<name>answer</name> = <name>JS_TRUE</name></expr>;</expr_stmt></then></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_LIST</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_NEW</name> ||
            <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_LP</name> ||
            <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_LB</name> ||
            <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> ||
            <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * All invocation operations (construct: TOK_NEW, call: TOK_LP)
             * are presumed to be useful, because they may have side effects
             * even if their main effect (their return value) is discarded.
             *
             * TOK_LB binary trees of 3 or more nodes are flattened into lists
             * to avoid too much recursion.  All such lists must be presumed
             * to be useful because each index operation could invoke a getter
             * (the JSOP_ARGUMENTS special case below, in the PN_BINARY case,
             * does not apply here: arguments[i][j] might invoke a getter).
             *
             * Array and object initializers (TOK_RB and TOK_RC lists) must be
             * considered useful, because they are sugar for constructor calls
             * (to Array and Object, respectively).
             */</comment>
            <expr_stmt><expr>*<name>answer</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>)
                <expr_stmt><expr><name>ok</name> &amp;= <call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></else></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_TERNARY</name></expr>:
        <expr_stmt><expr><name>ok</name> = <call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call> &amp;&amp;
             <call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call> &amp;&amp;
             <call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_BINARY</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Assignment is presumed to be useful, even if the next operation
             * is another assignment overwriting this one's ostensible effect,
             * because the left operand may be a property with a setter that
             * has side effects.
             *
             * The only exception is assignment of a useless value to a const
             * declared in the function currently being compiled.
             */</comment>
            <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_NAME</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>answer</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!*<name>answer</name> &amp;&amp;
                    (<name><name>pn</name>-&gt;<name>pn_op</name></name> != <name>JSOP_NOP</name> ||
                     <name><name>pn2</name>-&gt;<name>pn_slot</name></name> &lt; 0 ||
                     !<name><name>pn2</name>-&gt;<name>pn_const</name></name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr>*<name>answer</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * We can't easily prove that neither operand ever denotes an
             * object with a toString or valueOf method.
             */</comment>
            <expr_stmt><expr>*<name>answer</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

      </case><case>case <expr><name>PN_UNARY</name></expr>:
        <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
          <case>case <expr><name>TOK_RP</name></expr>:
            <expr_stmt><expr><name>ok</name> = <call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr><name>TOK_DELETE</name></expr>:
            <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
              <case>case <expr><name>TOK_NAME</name></expr>:
              </case><case>case <expr><name>TOK_DOT</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
              </case><case>case <expr><name>TOK_DBLDOT</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
              </case><case>case <expr><name>TOK_LP</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              </case><case>case <expr><name>TOK_LB</name></expr>:
                <comment type="block">/* All these delete addressing modes have effects too. */</comment>
                <expr_stmt><expr>*<name>answer</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                <break>break;</break>
              </case><default>default:
                <expr_stmt><expr><name>ok</name> = <call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </default>}</block></switch>
            <break>break;</break>

          </case><default>default:
            <comment type="block">/*
             * All of TOK_INC, TOK_DEC, TOK_THROW, TOK_YIELD, and TOK_DEFSHARP
             * have direct effects. Of the remaining unary-arity node types,
             * we can't easily prove that the operand never denotes an object
             * with a toString or valueOf method.
             */</comment>
            <expr_stmt><expr>*<name>answer</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            <break>break;</break>
        </default>}</block></switch>
        <break>break;</break>

      </case><case>case <expr><name>PN_NAME</name></expr>:
        <comment type="block">/*
         * Take care to avoid trying to bind a label name (labels, both for
         * statements and property values in object initialisers, have pn_op
         * defaulted to JSOP_NOP).
         */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name> &amp;&amp; <name><name>pn</name>-&gt;<name>pn_op</name></name> != <name>JSOP_NOP</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_slot</name></name> &lt; 0 &amp;&amp; <name><name>pn</name>-&gt;<name>pn_op</name></name> != <name>JSOP_ARGUMENTS</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * Not an argument or local variable use, so this expression
                 * could invoke a getter that has side effects.
                 */</comment>
                <expr_stmt><expr>*<name>answer</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_DOT</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name> &amp;&amp; !<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr>!(<name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_ARGUMENTS</name> &amp;&amp;
                  <name><name>pn</name>-&gt;<name>pn_atom</name></name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lengthAtom</name></name>)</expr>)</condition><then> <block>{
                <comment type="block">/*
                 * Any dotted property reference could call a getter, except
                 * for arguments.length where arguments is unambiguous.
                 */</comment>
                <expr_stmt><expr>*<name>answer</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>ok</name> = <call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>PN_NULLARY</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_DEBUGGER</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>answer</name> = <name>JS_TRUE</name></expr>;</expr_stmt></then></if>
        <break>break;</break>
    </case>}</block></switch>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitNameOp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>,
           <param><decl><type><name>JSBool</name></type> <name>callContext</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>callContext</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
          <case>case <expr><name>JSOP_NAME</name></expr>:
            <expr_stmt><expr><name>op</name> = <name>JSOP_CALLNAME</name></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSOP_GETVAR</name></expr>:
            <expr_stmt><expr><name>op</name> = <name>JSOP_CALLVAR</name></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSOP_GETGVAR</name></expr>:
            <expr_stmt><expr><name>op</name> = <name>JSOP_CALLGVAR</name></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSOP_GETARG</name></expr>:
            <expr_stmt><expr><name>op</name> = <name>JSOP_CALLARG</name></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>JSOP_GETLOCAL</name></expr>:
            <expr_stmt><expr><name>op</name> = <name>JSOP_CALLLOCAL</name></expr>;</expr_stmt>
            <break>break;</break>
          </case><default>default:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </default>}</block></switch>
    }</block></then></if>

    <if>if <condition>(<expr><name>op</name> == <name>JSOP_ARGUMENTS</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>callContext</name> &amp;&amp; <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_slot</name></name> &gt;= 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>
    }</block></else></if>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitXMLName</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_UNARYOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_XMLNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_XMLNAME</name> || <name>op</name> == <name>JSOP_CALLXMLNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldflags</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> |= <name>oldflags</name> &amp; <name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>,
                       <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name><name>pn2</name>-&gt;<name>pn_offset</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitPropOp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>,
           <param><decl><type><name>JSBool</name></type> <name>callContext</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pndot</name></decl>, *<decl><type ref="prev"/><name>pnup</name></decl>, *<decl><type ref="prev"/><name>pndown</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>top</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>callContext</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_DOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_GETPROP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <name>JSOP_CALLPROP</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>op</name> == <name>JSOP_GETPROP</name> &amp;&amp; <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_DOT</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_THIS</name></expr>)</condition><then> <block>{
            <comment type="block">/* Fast path for gets of |this.foo|. */</comment>
            <return>return <expr><call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSOP_GETTHISPROP</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Try to optimize:
             *  - arguments.length into JSOP_ARGCNT
             *  - argname.prop into JSOP_GETARGPROP
             *  - varname.prop into JSOP_GETVARPROP
             *  - localname.prop into JSOP_GETLOCALPROP
             */</comment>
            <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_op</name></name></expr>)</condition> <block>{
              <case>case <expr><name>JSOP_ARGUMENTS</name></expr>:
                <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_atom</name></name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lengthAtom</name></name></expr>)</condition><then>
                    <return>return <expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ARGCNT</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return></then></if>
                <break>break;</break>

              </case><case>case <expr><name>JSOP_GETARG</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETARGPROP</name></expr>;</expr_stmt>
                <goto>goto <name>do_indexconst</name>;</goto>
              </case><case>case <expr><name>JSOP_GETVAR</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETVARPROP</name></expr>;</expr_stmt>
                <goto>goto <name>do_indexconst</name>;</goto>
              </case><case>case <expr><name>JSOP_GETLOCAL</name></expr>:
                <expr_stmt><expr><name>op</name> = <name>JSOP_GETLOCALPROP</name></expr>;</expr_stmt>
              <label><name>do_indexconst</name>:</label> <block>{
                <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>jsatomid</name></type> <name>atomIndex</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>atomIndex</name> = <call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>EmitSlotIndexOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_slot</name></name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</return>
              }</block>

              </case><default>default:<empty_stmt>;</empty_stmt>
            </default>}</block></switch>
        }</block></then></if>
    }</block></then></if></else></if>

    <comment type="block">/*
     * If the object operand is also a dotted property reference, reverse the
     * list linked via pn_expr temporarily so we can iterate over it from the
     * bottom up (reversing again as we go), to avoid excessive recursion.
     */</comment>
    <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_DOT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pndot</name> = <name>pn2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pnup</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
            <comment type="block">/* Reverse pndot-&gt;pn_expr to point up, not down. */</comment>
            <expr_stmt><expr><name><name>pndot</name>-&gt;<name>pn_offset</name></name> = <name>top</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pndown</name> = <name><name>pndot</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pndot</name>-&gt;<name>pn_expr</name></name> = <name>pnup</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pndown</name>-&gt;<name>pn_type</name></name> != <name>TOK_DOT</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr><name>pnup</name> = <name>pndot</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pndot</name> = <name>pndown</name></expr>;</expr_stmt>
        }</block></for>

        <comment type="block">/* pndown is a primary expression, not a dotted property reference. */</comment>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pndown</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <do>do <block>{
            <comment type="block">/* Walk back up the list, emitting annotated name ops. */</comment>
            <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>,
                               <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name><name>pndown</name>-&gt;<name>pn_offset</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pndot</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pndot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <comment type="block">/* Reverse the pn_expr link again. */</comment>
            <expr_stmt><expr><name>pnup</name> = <name><name>pndot</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pndot</name>-&gt;<name>pn_expr</name></name> = <name>pndown</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pndown</name> = <name>pndot</name></expr>;</expr_stmt>
        }</block> while <condition>(<expr>(<name>pndot</name> = <name>pnup</name>) != <name>NULL</name></expr>)</condition>;</do>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></else></if>

    <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>,
                       <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name><name>pn2</name>-&gt;<name>pn_offset</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_IMPORTALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>!<call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></else></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitElemOp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>top</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>left</name></decl>, *<decl><type ref="prev"/><name>right</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, <decl><type ref="prev"/><name>ltmp</name></decl>, <decl><type ref="prev"/><name>rtmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>slot</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr>)</condition><then> <block>{
        <comment type="block">/* Left-associative operator chain to avoid too much recursion. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_GETELEM</name> || <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_IMPORTELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> &gt;= 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>left</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>right</name> = <call><name>PN_LAST</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>next</name> = <name><name>left</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>next</name> != <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Try to optimize arguments[0][j]... into JSOP_ARGSUB&lt;0&gt; followed by
         * one or more index expression and JSOP_GETELEM op pairs.
         */</comment>
        <if>if <condition>(<expr><name><name>left</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name> &amp;&amp; <name><name>next</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name><name>left</name>-&gt;<name>pn_op</name></name> == <name>JSOP_ARGUMENTS</name> &amp;&amp;
                <call><name>JSDOUBLE_IS_INT</name><argument_list>(<argument><expr><name><name>next</name>-&gt;<name>pn_dval</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call> &amp;&amp;
                (<name>jsuint</name>)<name>slot</name> &lt; <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * arguments[i]() requires arguments object as "this".
                 * Check that we never generates list for that usage.
                 */</comment>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> != <name>JSOP_CALLELEM</name> || <name><name>next</name>-&gt;<name>pn_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_offset</name></name> = <name><name>next</name>-&gt;<name>pn_offset</name></name> = <name>top</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_ARGSUB</name></expr></argument>, <argument><expr>(<name>jsatomid</name>)<name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>left</name> = <name>next</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>next</name> = <name><name>left</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/*
         * Check whether we generated JSOP_ARGSUB, just above, and have only
         * one more index expression to emit.  Given arguments[0][j], we must
         * skip the while loop altogether, falling through to emit code for j
         * (in the subtree referenced by right), followed by the annotated op,
         * at the bottom of this function.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>next</name> != <name>right</name> || <name><name>pn</name>-&gt;<name>pn_count</name></name> == 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>left</name> == <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>
        <while>while <condition>(<expr><name>next</name> != <name>right</name></expr>)</condition> <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>, <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_GETELEM</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>next</name> = <name><name>next</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
        }</block></while>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_NAME</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Set left and right so pn appears to be a TOK_LB node, instead
             * of a TOK_DOT node.  See the TOK_FOR/IN case in js_EmitTree, and
             * EmitDestructuringOps nearer below.  In the destructuring case,
             * the base expression (pn_expr) of the name may be null, which
             * means we have to emit a JSOP_BINDNAME.
             */</comment>
            <expr_stmt><expr><name>left</name> = <name><name>pn</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>left</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>left</name> = &amp;<name>ltmp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_type</name></name> = <name>TOK_STRING</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_op</name></name> = <name>JSOP_BINDNAME</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_pos</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_atom</name></name> = <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>right</name> = &amp;<name>rtmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>right</name>-&gt;<name>pn_type</name></name> = <name>TOK_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>ATOM_IS_STRING</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>right</name>-&gt;<name>pn_op</name></name> = <call><name>js_IsIdentifier</name><argument_list>(<argument><expr><call><name>ATOM_TO_STRING</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                           ? <name>JSOP_QNAMEPART</name>
                           : <name>JSOP_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>right</name>-&gt;<name>pn_arity</name></name> = <name>PN_NULLARY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>right</name>-&gt;<name>pn_pos</name></name> = <name><name>pn</name>-&gt;<name>pn_pos</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>right</name>-&gt;<name>pn_atom</name></name> = <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>left</name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>right</name> = <name><name>pn</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/* Try to optimize arguments[0] (e.g.) into JSOP_ARGSUB&lt;0&gt;. */</comment>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_GETELEM</name> &amp;&amp;
            <name><name>left</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name> &amp;&amp;
            <name><name>right</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name><name>left</name>-&gt;<name>pn_op</name></name> == <name>JSOP_ARGUMENTS</name> &amp;&amp;
                <call><name>JSDOUBLE_IS_INT</name><argument_list>(<argument><expr><name><name>right</name>-&gt;<name>pn_dval</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call> &amp;&amp;
                (<name>jsuint</name>)<name>slot</name> &lt; <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>left</name>-&gt;<name>pn_offset</name></name> = <name><name>right</name>-&gt;<name>pn_offset</name></name> = <name>top</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_ARGSUB</name></expr></argument>, <argument><expr>(<name>jsatomid</name>)<name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_TRUE</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>

        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></else></if>

    <comment type="block">/* The right side of the descendant operator is implicitly quoted. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> != <name>JSOP_DESCENDANTS</name> || <name><name>right</name>-&gt;<name>pn_type</name></name> != <name>TOK_STRING</name> ||
              <name><name>right</name>-&gt;<name>pn_op</name></name> == <name>JSOP_QNAMEPART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>, <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <return>return <expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitNumberOp</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsdouble</name></type> <name>dval</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsint</name></type> <name>ival</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>u</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>JSDOUBLE_IS_INT</name><argument_list>(<argument><expr><name>dval</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>INT_FITS_IN_JSVAL</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>ival</name> == 0</expr>)</condition><then>
            <return>return <expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ZERO</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return></then></if>
        <if>if <condition>(<expr><name>ival</name> == 1</expr>)</condition><then>
            <return>return <expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ONE</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return></then></if>
        <if>if <condition>(<expr>(<name>jsint</name>)(<name>int8</name>)<name>ival</name> == <name>ival</name></expr>)</condition><then>
            <return>return <expr><call><name>js_Emit2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_INT8</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>)(<name>int8</name>)<name>ival</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return></then></if>

        <expr_stmt><expr><name>u</name> = (<name>uint32</name>)<name>ival</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>u</name> &lt; <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_UINT16</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>u</name> &lt; <call><name>JS_BIT</name><argument_list>(<argument><expr>24</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>off</name> = <call><name>js_EmitN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_UINT24</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>pc</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET_UINT24</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>off</name> = <call><name>js_EmitN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_INT32</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>pc</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET_INT32</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <return>return <expr><name>JS_TRUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>atom</name> = <call><name>js_AtomizeDouble</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>atom</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    <return>return <expr><call><name>EmitIndexOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSOP_DOUBLE</name></expr></argument>, <argument><expr><call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitSwitch</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>,
           <param><decl><type><name>JSStmtInfo</name> *</type><name>stmtInfo</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>switchOp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>, <decl><type ref="prev"/><name>hasDefault</name></decl>, <decl><type ref="prev"/><name>constPropagated</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>top</name></decl>, <decl><type ref="prev"/><name>off</name></decl>, <decl><type ref="prev"/><name>defaultOffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>, *<decl><type ref="prev"/><name>pn4</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>caseCount</name></decl>, <decl><type ref="prev"/><name>tableLength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> **</type><name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsval</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParsedObjectBox</name> *</type><name>pob</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>intN</name></type> <name>noteIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>switchSize</name></decl>, <decl><type ref="prev"/><name>tableSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>, *<decl><type ref="prev"/><name>savepc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
    <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsint</name></type> <name>count</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Try for most optimal, fall back if not dense ints, and per ECMAv2. */</comment>
    <expr_stmt><expr><name>switchOp</name> = <name>JSOP_TABLESWITCH</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hasDefault</name> = <name>constPropagated</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>defaultOffset</name> = -1</expr>;</expr_stmt>

    <comment type="block">/*
     * If the switch contains let variables scoped by its body, model the
     * resulting block on the stack first, before emitting the discriminant's
     * bytecode (in case the discriminant contains a stack-model dependency
     * such as a let expression).
     */</comment>
    <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
    <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LEXICALSCOPE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pob</name> = <name><name>pn2</name>-&gt;<name>pn_pob</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>obj</name> = <name><name>pob</name>-&gt;<name>object</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OBJ_SET_BLOCK_DEPTH</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Push the body's block scope before discriminant code-gen for proper
         * static block scope linkage in case the discriminant contains a let
         * expression.  The block's locals must lie under the discriminant on
         * the stack so that case-dispatch bytecodes can find the discriminant
         * on top of stack.
         */</comment>
        <expr_stmt><expr><call><name>js_PushBlockScope</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr><name>stmtInfo</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmtInfo</name>-&gt;<name>type</name></name> = <name>STMT_SWITCH</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>count</name> = <call><name>OBJ_BLOCK_COUNT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> += <name>count</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>uintN</name>)<name><name>cg</name>-&gt;<name>stackDepth</name></name> &gt; <name><name>cg</name>-&gt;<name>maxStackDepth</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>maxStackDepth</name></name> = <name><name>cg</name>-&gt;<name>stackDepth</name></name></expr>;</expr_stmt></then></if>

        <comment type="block">/* Emit JSOP_ENTERBLOCK before code to evaluate the discriminant. */</comment>
        <if>if <condition>(<expr>!<call><name>EmitObjectOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pob</name></expr></argument>, <argument><expr><name>JSOP_ENTERBLOCK</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/*
         * Pop the switch's statement info around discriminant code-gen.  Note
         * how this leaves cg-&gt;treeContext.blockChain referencing the switch's
         * block scope object, which is necessary for correct block parenting
         * in the case where the discriminant contains a let expression.
         */</comment>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name></name> = <name><name>stmtInfo</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>topScopeStmt</name></name> = <name><name>stmtInfo</name>-&gt;<name>downScope</name></name></expr>;</expr_stmt>
    }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
    <else>else <block>{
        <expr_stmt><expr><name>count</name> = -1</expr>;</expr_stmt>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Emit code for the discriminant first (or nearly first, in the case of a
     * switch whose body is a block scope).
     */</comment>
    <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/* Switch bytecodes run from here till end of final case. */</comment>
    <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
    <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr><name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_SWITCH</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr><name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_SWITCH</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/* Re-push the switch's statement info record. */</comment>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name></name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>topScopeStmt</name></name> = <name>stmtInfo</name></expr>;</expr_stmt>

        <comment type="block">/* Set the statement info record's idea of top. */</comment>
        <expr_stmt><expr><name><name>stmtInfo</name>-&gt;<name>update</name></name> = <name>top</name></expr>;</expr_stmt>

        <comment type="block">/* Advance pn2 to refer to the switch case list. */</comment>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>caseCount</name> = <name><name>pn2</name>-&gt;<name>pn_count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tableLength</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>table</name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>caseCount</name> == 0 ||
        (<name>caseCount</name> == 1 &amp;&amp;
         (<name>hasDefault</name> = (<name><name>pn2</name>-&gt;<name>pn_head</name>-&gt;<name>pn_type</name></name> == <name>TOK_DEFAULT</name>)))</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>caseCount</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>low</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>high</name> = -1</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTMAP_LENGTH</name></cpp:macro>   <cpp:value>256</cpp:value></cpp:define>
        <decl_stmt><decl><type><name>jsbitmap</name></type> <name><name>intmap_space</name><index>[<expr><name>INTMAP_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsbitmap</name> *</type><name>intmap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type> <name>intmap_bitlen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>low</name>  = <name>JSVAL_INT_MAX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>high</name> = <name>JSVAL_INT_MIN</name></expr>;</expr_stmt>

        <for>for (<init><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn3</name></expr>;</condition> <incr><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_DEFAULT</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>hasDefault</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>caseCount</name>--</expr>;</expr_stmt>    <comment type="block">/* one of the "cases" was the default */</comment>
                <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_CASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_CONDSWITCH</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>

            <expr_stmt><expr><name>pn4</name> = <name><name>pn3</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name><name>pn4</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
              <case>case <expr><name>TOK_NUMBER</name></expr>:
                <expr_stmt><expr><name>d</name> = <name><name>pn4</name>-&gt;<name>pn_dval</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>JSDOUBLE_IS_INT</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>INT_FITS_IN_JSVAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name> = <call><name>INT_TO_JSVAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>atom</name> = <call><name>js_AtomizeDouble</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>atom</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                        <goto>goto <name>release</name>;</goto>
                    }</block></then></if>
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name> = <call><name>ATOM_KEY</name><argument_list>(<argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>
              </case><case>case <expr><name>TOK_STRING</name></expr>:
                <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name> = <call><name>ATOM_KEY</name><argument_list>(<argument><expr><name><name>pn4</name>-&gt;<name>pn_atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr><name>TOK_NAME</name></expr>:
                <if>if <condition>(<expr>!<name><name>pn4</name>-&gt;<name>pn_expr</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ok</name> = <call><name>LookupCompileTimeConstant</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn4</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                        <goto>goto <name>release</name>;</goto></then></if>
                    <if>if <condition>(<expr><name>v</name> != <name>JSVAL_HOLE</name></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr>!<call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <comment type="block">/*
                             * XXX JSOP_LOOKUPSWITCH does not support const-
                             * propagated object values, see bug 407186.
                             */</comment>
                            <expr_stmt><expr><name>switchOp</name> = <name>JSOP_CONDSWITCH</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                        <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name> = <name>v</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>constPropagated</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></then></if>
                <comment type="block">/* FALL THROUGH */</comment>
              </case><case>case <expr><name>TOK_PRIMARY</name></expr>:
                <if>if <condition>(<expr><name><name>pn4</name>-&gt;<name>pn_op</name></name> == <name>JSOP_TRUE</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name> = <name>JSVAL_TRUE</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>pn4</name>-&gt;<name>pn_op</name></name> == <name>JSOP_FALSE</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name> = <name>JSVAL_FALSE</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <comment type="block">/* FALL THROUGH */</comment>
              </case><default>default:
                <expr_stmt><expr><name>switchOp</name> = <name>JSOP_CONDSWITCH</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </default>}</block></switch>

            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>JSVAL_IS_PRIMITIVE</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>switchOp</name> != <name>JSOP_TABLESWITCH</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <if>if <condition>(<expr>!<call><name>JSVAL_IS_INT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>switchOp</name> = <name>JSOP_LOOKUPSWITCH</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>i</name> = <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call>(<name>jsuint</name>)<argument_list>(<argument><expr><name>i</name> + (<name>jsint</name>)<call><name>JS_BIT</name><argument_list>(<argument><expr>15</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= (<name>jsuint</name>)<call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>switchOp</name> = <name>JSOP_LOOKUPSWITCH</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <if>if <condition>(<expr><name>i</name> &lt; <name>low</name></expr>)</condition><then>
                <expr_stmt><expr><name>low</name> = <name>i</name></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name>high</name> &lt; <name>i</name></expr>)</condition><then>
                <expr_stmt><expr><name>high</name> = <name>i</name></expr>;</expr_stmt></then></if>

            <comment type="block">/*
             * Check for duplicates, which require a JSOP_LOOKUPSWITCH.
             * We bias i by 65536 if it's negative, and hope that's a rare
             * case (because it requires a malloc'd bitmap).
             */</comment>
            <if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
                <expr_stmt><expr><name>i</name> += <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name>i</name> &gt;= <name>intmap_bitlen</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<name>intmap</name> &amp;&amp;
                    <name>i</name> &lt; (<name>INTMAP_LENGTH</name> &lt;&lt; <name>JS_BITS_PER_WORD_LOG2</name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>intmap</name> = <name>intmap_space</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>intmap_bitlen</name> = <name>INTMAP_LENGTH</name> &lt;&lt; <name>JS_BITS_PER_WORD_LOG2</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <comment type="block">/* Just grab 8K for the worst-case bitmap. */</comment>
                    <expr_stmt><expr><name>intmap_bitlen</name> = <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>intmap</name> = (<name>jsbitmap</name> *)
                        <call><name>JS_malloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>,
                                  <argument><expr>(<call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call> &gt;&gt; <name>JS_BITS_PER_WORD_LOG2</name>)
                                  * <sizeof>sizeof<argument_list>(<argument><expr><name>jsbitmap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<name>intmap</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>JS_ReportOutOfMemory</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return>
                    }</block></then></if>
                }</block></else></if>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>intmap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>intmap_bitlen</name> &gt;&gt; <name>JS_BITS_PER_BYTE_LOG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>JS_TEST_BIT</name><argument_list>(<argument><expr><name>intmap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>switchOp</name> = <name>JSOP_LOOKUPSWITCH</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><call><name>JS_SET_BIT</name><argument_list>(<argument><expr><name>intmap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

      <label><name>release</name>:</label>
        <if>if <condition>(<expr><name>intmap</name> &amp;&amp; <name>intmap</name> != <name>intmap_space</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>intmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/*
         * Compute table length and select lookup instead if overlarge or
         * more than half-sparse.
         */</comment>
        <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_TABLESWITCH</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>tableLength</name> = <call>(<name>uint32</name>)<argument_list>(<argument><expr><name>high</name> - <name>low</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>tableLength</name> &gt;= <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call> || <name>tableLength</name> &gt; 2 * <name>caseCount</name></expr>)</condition><then>
                <expr_stmt><expr><name>switchOp</name> = <name>JSOP_LOOKUPSWITCH</name></expr>;</expr_stmt></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_LOOKUPSWITCH</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Lookup switch supports only atom indexes below 64K limit.
             * Conservatively estimate the maximum possible index during
             * switch generation and use conditional switch if it exceeds
             * the limit.
             */</comment>
            <if>if <condition>(<expr><name>caseCount</name> + <name><name>cg</name>-&gt;<name>atomList</name>.<name>count</name></name> &gt; <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>switchOp</name> = <name>JSOP_CONDSWITCH</name></expr>;</expr_stmt></then></if>
        }</block></then></if></else></if>
    }</block></else></if>

    <comment type="block">/*
     * Emit a note with two offsets: first tells total switch code length,
     * second tells offset to first JSOP_CASE if condswitch.
     */</comment>
    <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote3</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_SWITCH</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>noteIndex</name> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_CONDSWITCH</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * 0 bytes of immediate for unoptimized ECMAv2 switch.
         */</comment>
        <expr_stmt><expr><name>switchSize</name> = 0</expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_TABLESWITCH</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * 3 offsets (len, low, high) before the table, 1 per entry.
         */</comment>
        <expr_stmt><expr><name>switchSize</name> = <call>(<name>size_t</name>)<argument_list>(<argument><expr><call><name>JUMP_OFFSET_LEN</name> * <argument_list>(<argument><expr>3 + <name>tableLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * JSOP_LOOKUPSWITCH:
         * 1 offset (len) and 1 atom index (npairs) before the table,
         * 1 atom index and 1 jump offset per entry.
         */</comment>
        <expr_stmt><expr><name>switchSize</name> = <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>JUMP_OFFSET_LEN</name> + <name>INDEX_LEN</name> +
                              (<name>INDEX_LEN</name> + <name>JUMP_OFFSET_LEN</name>) * <name>caseCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <comment type="block">/*
     * Emit switchOp followed by switchSize bytes of jump or lookup table.
     *
     * If switchOp is JSOP_LOOKUPSWITCH or JSOP_TABLESWITCH, it is crucial
     * to emit the immediate operand(s) by which bytecode readers such as
     * BuildSpanDepTable discover the length of the switch opcode *before*
     * calling js_SetJumpOffset (which may call BuildSpanDepTable).  It's
     * also important to zero all unknown jump offset immediate operands,
     * so they can be converted to span dependencies with null targets to
     * be computed later (js_EmitN zeros switchSize bytes after switchOp).
     */</comment>
    <if>if <condition>(<expr><call><name>js_EmitN</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>switchOp</name></expr></argument>, <argument><expr><name>switchSize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>off</name> = -1</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_CONDSWITCH</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>intN</name></type> <name>caseNoteIndex</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSBool</name></type> <name>beforeCases</name> <init>= <expr><name>JS_TRUE</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Emit code for evaluating cases and jumping to case statements. */</comment>
        <for>for (<init><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn3</name></expr>;</condition> <incr><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <expr_stmt><expr><name>pn4</name> = <name><name>pn3</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>pn4</name> &amp;&amp; !<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn4</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name>caseNoteIndex</name> &gt;= 0</expr>)</condition><then> <block>{
                <comment type="block">/* off is the previous JSOP_CASE's bytecode offset. */</comment>
                <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>caseNoteIndex</name></expr></argument>, <argument><expr>0</expr></argument>,
                                         <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>off</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
            }</block></then></if>
            <if>if <condition>(<expr>!<name>pn4</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>caseNoteIndex</name> = <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCDELTA</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>caseNoteIndex</name> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>off</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_CASE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_offset</name></name> = <name>off</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>beforeCases</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>uintN</name></type> <name>noteCount</name></decl>, <decl><type ref="prev"/><name>noteCountDelta</name></decl>;</decl_stmt>

                <comment type="block">/* Switch note's second offset is to first JSOP_CASE. */</comment>
                <expr_stmt><expr><name>noteCount</name> = <call><name>CG_NOTE_COUNT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>1</expr></argument>,
                                         <argument><expr><name>off</name> - <name>top</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>noteCountDelta</name> = <call><name>CG_NOTE_COUNT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>noteCount</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>noteCountDelta</name> != 0</expr>)</condition><then>
                    <expr_stmt><expr><name>caseNoteIndex</name> += <name>noteCountDelta</name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>beforeCases</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <comment type="block">/*
         * If we didn't have an explicit default (which could fall in between
         * cases, preventing us from fusing this js_SetSrcNoteOffset with the
         * call in the loop above), link the last case to the implicit default
         * for the decompiler.
         */</comment>
        <if>if <condition>(<expr>!<name>hasDefault</name> &amp;&amp;
            <name>caseNoteIndex</name> &gt;= 0 &amp;&amp;
            !<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>caseNoteIndex</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>off</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Emit default even if no explicit default statement. */</comment>
        <expr_stmt><expr><name>defaultOffset</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_DEFAULT</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>defaultOffset</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>pc</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>top</name> + <name>JUMP_OFFSET_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_TABLESWITCH</name></expr>)</condition><then> <block>{
            <comment type="block">/* Fill in switch bounds, which we know fit in 16-bit offsets. */</comment>
            <expr_stmt><expr><call><name>SET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>low</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Use malloc to avoid arena bloat for programs with many switches.
             * We free table if non-null at label out, so all control flow must
             * exit this function through goto out or goto bad.
             */</comment>
            <if>if <condition>(<expr><name>tableLength</name> != 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>tableSize</name> = (<name>size_t</name>)<name>tableLength</name> * sizeof *<name>table</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>table</name> = (<name>JSParseNode</name> **) <call><name>JS_malloc</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>tableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>table</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for (<init><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn3</name></expr>;</condition> <incr><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
                    <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_DEFAULT</name></expr>)</condition><then>
                        <continue>continue;</continue></then></if>
                    <expr_stmt><expr><name>i</name> = <call><name>JSVAL_TO_INT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>i</name> -= <name>low</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>uint32</name>)<name>i</name> &lt; <name>tableLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pn3</name></expr>;</expr_stmt>
                }</block></for>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>switchOp</name> == <name>JSOP_LOOKUPSWITCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Fill in the number of cases. */</comment>
            <expr_stmt><expr><call><name>SET_INDEX</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><name>caseCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>INDEX_LEN</name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/*
         * After this point, all control flow involving JSOP_TABLESWITCH
         * must set ok and goto out to exit this function.  To keep things
         * simple, all switchOp cases exit that way.
         */</comment>
        <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>spanDeps</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * We have already generated at least one big jump so we must
             * explicitly add span dependencies for the switch jumps. When
             * called below, js_SetJumpOffset can only do it when patching
             * the first big jump or when cg-&gt;spanDeps is null.
             */</comment>
            <if>if <condition>(<expr>!<call><name>AddSwitchSpanDeps</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>bad</name>;</goto></then></if>
        }</block></then></if>

        <if>if <condition>(<expr><name>constPropagated</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Skip switchOp, as we are not setting jump offsets in the two
             * for loops below.  We'll restore CG_NEXT(cg) from savepc after,
             * unless there was an error.
             */</comment>
            <expr_stmt><expr><name>savepc</name> = <call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>pc</name> + 1</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_TABLESWITCH</name></expr>)</condition><then> <block>{
                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (<name>jsint</name>)<name>tableLength</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>pn3</name> = <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>pn3</name> &amp;&amp;
                        (<name>pn4</name> = <name><name>pn3</name>-&gt;<name>pn_left</name></name>) != <name>NULL</name> &amp;&amp;
                        <name><name>pn4</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
                        <comment type="block">/* Note a propagated constant with the const's name. */</comment>
                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn4</name>-&gt;<name>pn_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn4</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                            <goto>goto <name>bad</name>;</goto></then></if>
                        <expr_stmt><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>pc</name></expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_LABEL</name></expr></argument>, <argument><expr>(<name>ptrdiff_t</name>)
                                           <call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                            <goto>goto <name>bad</name>;</goto>
                        }</block></then></if>
                    }</block></then></if>
                    <expr_stmt><expr><name>pc</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
                }</block></for>
            }</block></then> <else>else <block>{
                <for>for (<init><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn3</name></expr>;</condition> <incr><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
                    <expr_stmt><expr><name>pn4</name> = <name><name>pn3</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>pn4</name> &amp;&amp; <name><name>pn4</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr>)</condition><then> <block>{
                        <comment type="block">/* Note a propagated constant with the const's name. */</comment>
                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn4</name>-&gt;<name>pn_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn4</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                            <goto>goto <name>bad</name>;</goto></then></if>
                        <expr_stmt><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>pc</name></expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_LABEL</name></expr></argument>, <argument><expr>(<name>ptrdiff_t</name>)
                                           <call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                            <goto>goto <name>bad</name>;</goto>
                        }</block></then></if>
                    }</block></then></if>
                    <expr_stmt><expr><name>pc</name> += <name>INDEX_LEN</name> + <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
                }</block></for>
            }</block></else></if>
            <expr_stmt><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>savepc</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

    <comment type="block">/* Emit code for each case's statements, copying pn_offset up to pn3. */</comment>
    <for>for (<init><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn3</name></expr>;</condition> <incr><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_CONDSWITCH</name> &amp;&amp; <name><name>pn3</name>-&gt;<name>pn_type</name></name> != <name>TOK_DEFAULT</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET_AT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn3</name>-&gt;<name>pn_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>pn4</name> = <name><name>pn3</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
        <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_offset</name></name> = <name><name>pn4</name>-&gt;<name>pn_offset</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_DEFAULT</name></expr>)</condition><then>
            <expr_stmt><expr><name>off</name> = <name><name>pn3</name>-&gt;<name>pn_offset</name></name> - <name>top</name></expr>;</expr_stmt></then></if>
    }</block></for>

    <if>if <condition>(<expr>!<name>hasDefault</name></expr>)</condition><then> <block>{
        <comment type="block">/* If no default case, offset for default is to end of switch. */</comment>
        <expr_stmt><expr><name>off</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* We better have set "off" by now. */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>off</name> != -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set the default offset (to end of switch if no default). */</comment>
    <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_CONDSWITCH</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pc</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>defaultOffset</name> != -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <call><name>js_SetJumpOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>defaultOffset</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>off</name> - (<name>defaultOffset</name> - <name>top</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>pc</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <call><name>js_SetJumpOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
            <goto>goto <name>out</name>;</goto></then></if>
        <expr_stmt><expr><name>pc</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Set the SRC_SWITCH note's offset operand to tell end of switch. */</comment>
    <expr_stmt><expr><name>off</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ok</name> = <call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
        <goto>goto <name>out</name>;</goto></then></if>

    <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_TABLESWITCH</name></expr>)</condition><then> <block>{
        <comment type="block">/* Skip over the already-initialized switch bounds. */</comment>
        <expr_stmt><expr><name>pc</name> += 2 * <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>

        <comment type="block">/* Fill in the jump table, if there is one. */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (<name>jsint</name>)<name>tableLength</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>pn3</name> = <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>off</name> = <name>pn3</name> ? <name><name>pn3</name>-&gt;<name>pn_offset</name></name> - <name>top</name> : 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>ok</name> = <call><name>js_SetJumpOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                <goto>goto <name>out</name>;</goto></then></if>
            <expr_stmt><expr><name>pc</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
        }</block></for>
    }</block></then> <else>else <if>if <condition>(<expr><name>switchOp</name> == <name>JSOP_LOOKUPSWITCH</name></expr>)</condition><then> <block>{
        <comment type="block">/* Skip over the already-initialized number of cases. */</comment>
        <expr_stmt><expr><name>pc</name> += <name>INDEX_LEN</name></expr>;</expr_stmt>

        <for>for (<init><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn3</name></expr>;</condition> <incr><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_DEFAULT</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <if>if <condition>(<expr>!<call><name>js_AtomizePrimitiveValue</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn3</name>-&gt;<name>pn_val</name></name></expr></argument>, <argument><expr>&amp;<name>atom</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <goto>goto <name>bad</name>;</goto></then></if>
            <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                <goto>goto <name>bad</name>;</goto></then></if>
            <expr_stmt><expr><call><name>SET_INDEX</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> += <name>INDEX_LEN</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>off</name> = <name><name>pn3</name>-&gt;<name>pn_offset</name></name> - <name>top</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ok</name> = <call><name>js_SetJumpOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
                <goto>goto <name>out</name>;</goto></then></if>
            <expr_stmt><expr><name>pc</name> += <name>JUMP_OFFSET_LEN</name></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if></else></if>

<label><name>out</name>:</label>
    <if>if <condition>(<expr><name>table</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>JS_free</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>ok</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ok</name> = <call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
        <if>if <condition>(<expr><name>ok</name> &amp;&amp; <name><name>pn</name>-&gt;<name>pn_right</name>-&gt;<name>pn_type</name></name> == <name>TOK_LEXICALSCOPE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_LEAVEBLOCK</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> -= <name>count</name></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <return>return <expr><name>ok</name></expr>;</return>

<label><name>bad</name>:</label>
    <expr_stmt><expr><name>ok</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
    <goto>goto <name>out</name>;</goto>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_EmitFunctionScript</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>body</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_FUN_IS_GENERATOR</name></expr>)</condition><then> <block>{
        <comment type="block">/* JSOP_GENERATOR must be the first instruction. */</comment>
        <expr_stmt><expr><call><name>CG_SWITCH_TO_PROLOG</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> == <call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_GENERATOR</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>CG_SWITCH_TO_MAIN</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call> &amp;&amp;
           <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_STOP</name></expr></argument>)</argument_list></call> &gt;= 0 &amp;&amp;
           <call><name>js_NewScriptFromCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* A macro for inlining at the top of js_EmitTree (whence it came). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_LINE_NUMBER_NOTES</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>cg</name></type></param>, <param><type><name>pn</name></type></param>)</parameter_list></cpp:macro>                                  \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        uintN line_ = (pn)-&gt;pn_pos.begin.lineno;                              \
        uintN delta_ = line_ - CG_CURRENT_LINE(cg);                           \
        if (delta_ != 0) {                                                    \
            <comment type="block">/*                                                                \
             * Encode any change in the current source line number by using   \
             * either several SRC_NEWLINE notes or just one SRC_SETLINE note, \
             * whichever consumes less space.                                 \
             *                                                                \
             * NB: We handle backward line number deltas (possible with for   \
             * loops where the update part is emitted after the body, but its \
             * line number is &lt;= any line number in the body) here by letting \
             * unsigned delta_ wrap to a very large number, which triggers a  \
             * SRC_SETLINE.                                                   \
             */</comment>                                                               \
            CG_CURRENT_LINE(cg) = line_;                                      \
            if (delta_ &gt;= (uintN)(2 + ((line_ &gt; SN_3BYTE_OFFSET_MASK)&lt;&lt;1))) { \
                if (js_NewSrcNote2(cx, cg, SRC_SETLINE, (ptrdiff_t)line_) &lt; 0)\
                    return JS_FALSE;                                          \
            } else {                                                          \
                do {                                                          \
                    if (js_NewSrcNote(cx, cg, SRC_NEWLINE) &lt; 0)               \
                        return JS_FALSE;                                      \
                } while (--delta_ != 0);                                      \
            }                                                                 \
        }                                                                     \
    JS_END_MACRO</cpp:value></cpp:define>

<comment type="block">/* A function, so that we avoid macro-bloating all the other callsites. */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>UpdateLineNumberNotes</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>UPDATE_LINE_NUMBER_NOTES</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>MaybeEmitVarDecl</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>prologOp</name></decl></param>,
                 <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>jsatomid</name> *</type><name>result</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsatomid</name></type> <name>atomIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_slot</name></name> &gt;= 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>atomIndex</name> = (<name>jsatomid</name>) <name><name>pn</name>-&gt;<name>pn_slot</name></name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>atomIndex</name> = <call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><call><name>JOF_OPTYPE</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name></expr></argument>)</argument_list></call> == <name>JOF_ATOM</name> &amp;&amp;
        (!(<name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>) ||
         (<name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_FUN_HEAVYWEIGHT</name>))</expr>)</condition><then> <block>{
        <comment type="block">/* Emit a prolog bytecode to predefine the variable. */</comment>
        <expr_stmt><expr><call><name>CG_SWITCH_TO_PROLOG</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>UpdateLineNumberNotes</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>prologOp</name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CG_SWITCH_TO_MAIN</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>result</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>result</name> = <name>atomIndex</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>

<typedef>typedef <function_decl><type><name>JSBool</name></type>
(*<name>DestructuringDeclEmitter</name>)<parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>prologOp</name></decl></param>,
                            <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitDestructuringDecl</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>prologOp</name></decl></param>,
                      <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSOp</name></type> <name>decltype</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>decltype</name> = <call>(<name>JSOp</name>) <argument_list>(<argument><expr>(<name>prologOp</name> == <name>JSOP_NOP</name>) ? <name>LET_DECL</name> : <name>VAR_DECL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>decltype</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> != <name>JSOP_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>MaybeEmitVarDecl</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>prologOp</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitDestructuringDecls</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>prologOp</name></decl></param>,
                       <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DestructuringDeclEmitter</name></type> <name>emitter</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name></expr>)</condition><then> <block>{
        <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_COMMA</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <expr_stmt><expr><name>emitter</name> = (<name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name>)
                      ? <name>EmitDestructuringDecl</name>
                      : <name>EmitDestructuringDecls</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>emitter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>prologOp</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></for>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>emitter</name> = (<name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name>)
                      ? <name>EmitDestructuringDecl</name>
                      : <name>EmitDestructuringDecls</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>emitter</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>prologOp</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></for>
    }</block></else></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitDestructuringOpsHelper</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitDestructuringLHS</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsuint</name></type> <name>slot</name></decl>;</decl_stmt>

    <comment type="block">/* Skip any parenthesization. */</comment>
    <while>while <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>)</condition>
        <expr_stmt><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt></while>

    <comment type="block">/*
     * Now emit the lvalue opcode sequence.  If the lvalue is a nested
     * destructuring initialiser-form, call ourselves to handle it, then
     * pop the matched value.  Otherwise emit an lvalue bytecode sequence
     * ending with a JSOP_ENUMELEM or equivalent op.
     */</comment>
    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>EmitDestructuringOpsHelper</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name> &amp;&amp; !<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name></expr>)</condition> <block>{
          <case>case <expr><name>JSOP_SETNAME</name></expr>:
            <comment type="block">/*
             * NB: pn is a PN_NAME node, not a PN_BINARY.  Nevertheless,
             * we want to emit JSOP_ENUMELEM, which has format JOF_ELEM.
             * So here and for JSOP_ENUMCONSTELEM, we use EmitElemOp.
             */</comment>
            <if>if <condition>(<expr>!<call><name>EmitElemOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSOP_ENUMELEM</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>

          </case><case>case <expr><name>JSOP_SETCONST</name></expr>:
            <if>if <condition>(<expr>!<call><name>EmitElemOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSOP_ENUMCONSTELEM</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>

          </case><case>case <expr><name>JSOP_SETLOCAL</name></expr>:
            <expr_stmt><expr><name>slot</name> = (<name>jsuint</name>) <name><name>pn</name>-&gt;<name>pn_slot</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_SETLOCALPOP</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><case>case <expr><name>JSOP_SETARG</name></expr>:
          </case><case>case <expr><name>JSOP_SETVAR</name></expr>:
          </case><case>case <expr><name>JSOP_SETGVAR</name></expr>:
            <expr_stmt><expr><name>slot</name> = (<name>jsuint</name>) <name><name>pn</name>-&gt;<name>pn_slot</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>

          </case><default>default:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name> || <name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
          <block>{
            <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>top</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>, <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ENUMELEM</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
          }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </default><case>case <expr><name>JSOP_ENUMELEM</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </case>}</block></switch>
    }</block></else></if>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Recursive helper for EmitDestructuringOps.
 *
 * Given a value to destructure on the stack, walk over an object or array
 * initialiser at pn, emitting bytecodes to match property values and store
 * them in the lvalues identified by the matched property names.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitDestructuringOpsHelper</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsuint</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>doElemOp</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>intN</name></type> <name>stackDepth</name> <init>= <expr><name><name>cg</name>-&gt;<name>stackDepth</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>stackDepth</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 0</expr>)</condition><then> <block>{
        <comment type="block">/* Emit a DUP;POP sequence for the decompiler. */</comment>
        <return>return <expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_DUP</name></expr></argument>)</argument_list></call> &gt;= 0 &amp;&amp;
               <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>index</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
        <comment type="block">/*
         * Duplicate the value being destructured to use as a reference base.
         */</comment>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_DUP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/*
         * Now push the property name currently being matched, which is either
         * the array initialiser's current index, or the current property name
         * "label" on the left of a colon in the object initialiser.  Set pn3
         * to the lvalue node, which is in the value-initializing position.
         */</comment>
        <expr_stmt><expr><name>doElemOp</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>EmitNumberOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>pn3</name> = <name>pn2</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * If we are emitting an object destructuring initialiser,
                 * annotate the index op with SRC_INITPROP so we know we are
                 * not decompiling an array initialiser.
                 */</comment>
                <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_INITPROP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<call><name>EmitNumberOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn3</name>-&gt;<name>pn_dval</name></name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_STRING</name> ||
                          <name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>JSOP_GETPROP</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>doElemOp</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name>doElemOp</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Ok, get the value of the matching property name.  This leaves
             * that value on top of the value being destructured, so the stack
             * is one deeper than when we started.
             */</comment>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_GETELEM</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> == <name>stackDepth</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Nullary comma node makes a hole in the array destructurer. */</comment>
        <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_COMMA</name> &amp;&amp; <name><name>pn3</name>-&gt;<name>pn_arity</name></name> == <name>PN_NULLARY</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn2</name> == <name>pn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>EmitDestructuringLHS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> == <name>stackDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>index</name></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ptrdiff_t</name></type>
<name>OpToDeclType</name><parameter_list>(<param><decl><type><name>JSOp</name></type> <name>op</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
      <case>case <expr><name>JSOP_NOP</name></expr>:
        <return>return <expr><name>SRC_DECL_LET</name></expr>;</return>
      </case><case>case <expr><name>JSOP_DEFCONST</name></expr>:
        <return>return <expr><name>SRC_DECL_CONST</name></expr>;</return>
      </case><case>case <expr><name>JSOP_DEFVAR</name></expr>:
        <return>return <expr><name>SRC_DECL_VAR</name></expr>;</return>
      </case><default>default:
        <return>return <expr><name>SRC_DECL_NONE</name></expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitDestructuringOps</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>declOp</name></decl></param>,
                     <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * If we're called from a variable declaration, help the decompiler by
     * annotating the first JSOP_DUP that EmitDestructuringOpsHelper emits.
     * If the destructuring initialiser is empty, our helper will emit a
     * JSOP_DUP followed by a JSOP_POP for the decompiler.
     */</comment>
    <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_DESTRUCT</name></expr></argument>, <argument><expr><call><name>OpToDeclType</name><argument_list>(<argument><expr><name>declOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <comment type="block">/*
     * Call our recursive helper to emit the destructuring assignments and
     * related stack manipulations.
     */</comment>
    <return>return <expr><call><name>EmitDestructuringOpsHelper</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitGroupAssignment</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>declOp</name></decl></param>,
                    <param><decl><type><name>JSParseNode</name> *</type><name>lhs</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>rhs</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jsuint</name></type> <name>depth</name></decl>, <decl><type ref="prev"/><name>limit</name></decl>, <decl><type ref="prev"/><name>slot</name></decl>, <decl><type ref="prev"/><name>nslots</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>depth</name> = <name>limit</name> = (<name>uintN</name>) <name><name>cg</name>-&gt;<name>stackDepth</name></name></expr>;</expr_stmt>
    <for>for (<init><expr><name>pn</name> = <name><name>rhs</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn</name></expr>;</condition> <incr><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name>limit</name> == <call><name>JS_BIT</name><argument_list>(<argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>CG_TS</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_ARRAY_INIT_TOO_BIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_COMMA</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_PUSH</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> != <name>TOK_DEFSHARP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>
        <expr_stmt><expr>++<name>limit</name></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_GROUPASSIGN</name></expr></argument>, <argument><expr><call><name>OpToDeclType</name><argument_list>(<argument><expr><name>declOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>slot</name> = <name>depth</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>pn</name> = <name><name>lhs</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn</name></expr>;</condition> <incr><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name>slot</name> &lt; <name>limit</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_GETLOCAL</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_PUSH</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_COMMA</name> &amp;&amp; <name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_NULLARY</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>EmitDestructuringLHS</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>
        <expr_stmt><expr>++<name>slot</name></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><name>nslots</name> = <name>limit</name> - <name>depth</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_POPN</name></expr></argument>, <argument><expr><name>nslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> = (<name>uintN</name>) <name>depth</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Helper called with pop out param initialized to a JSOP_POP* opcode.  If we
 * can emit a group assignment sequence, which results in 0 stack depth delta,
 * we set *pop to JSOP_NOP so callers can veto emitting pn followed by a pop.
 */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>MaybeEmitGroupAssignment</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSOp</name></type> <name>declOp</name></decl></param>,
                         <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>, <param><decl><type><name>JSOp</name> *</type><name>pop</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>lhs</name></decl>, *<decl><type ref="prev"/><name>rhs</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>*<name>pop</name> == <name>JSOP_POP</name> || *<name>pop</name> == <name>JSOP_POPV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lhs</name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rhs</name> = <name><name>pn</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>lhs</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> &amp;&amp; <name><name>rhs</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> &amp;&amp;
        <name><name>lhs</name>-&gt;<name>pn_count</name></name> &lt;= <name><name>rhs</name>-&gt;<name>pn_count</name></name> &amp;&amp;
        (<name><name>rhs</name>-&gt;<name>pn_count</name></name> == 0 ||
         <name><name>rhs</name>-&gt;<name>pn_head</name>-&gt;<name>pn_type</name></name> != <name>TOK_DEFSHARP</name>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>EmitGroupAssignment</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>declOp</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr>*<name>pop</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_DESTRUCTURING */</comment>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitVariables</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>,
              <param><decl><type><name>JSBool</name></type> <name>inLetHead</name></decl></param>, <param><decl><type><name>ptrdiff_t</name> *</type><name>headNoteIndex</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTreeContext</name> *</type><name>tc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>let</name></decl>, <decl><type ref="prev"/><name>forInVar</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
    <decl_stmt><decl><type><name>JSBool</name></type> <name>forInLet</name></decl>, <decl><type ref="prev"/><name>popScope</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl>, *<decl><type ref="prev"/><name>scopeStmt</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>off</name></decl>, <decl><type ref="prev"/><name>noteIndex</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsatomid</name></type> <name>atomIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>;</decl_stmt>

    <comment type="block">/* Default in case of JS_HAS_BLOCK_SCOPE early return, below. */</comment>
    <expr_stmt><expr>*<name>headNoteIndex</name> = -1</expr>;</expr_stmt>

    <comment type="block">/*
     * Let blocks and expressions have a parenthesized head in which the new
     * scope is not yet open. Initializer evaluation uses the parent node's
     * lexical scope. If popScope is true below, then we hide the top lexical
     * block from any calls to BindNameToSlot hiding in pn2-&gt;pn_expr so that
     * it won't find any names in the new let block.
     *
     * The same goes for let declarations in the head of any kind of for loop.
     * Unlike a let declaration 'let x = i' within a block, where x is hoisted
     * to the start of the block, a 'for (let x = i...) ...' loop evaluates i
     * in the containing scope, and puts x in the loop body's scope.
     */</comment>
    <expr_stmt><expr><name>tc</name> = &amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>let</name> = (<name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOP</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>forInVar</name> = (<name><name>pn</name>-&gt;<name>pn_extra</name></name> &amp; <name>PNX_FORINVAR</name>) != 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
    <expr_stmt><expr><name>forInLet</name> = <name>let</name> &amp;&amp; <name>forInVar</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>popScope</name> = (<name>inLetHead</name> || (<name>let</name> &amp;&amp; (<name><name>tc</name>-&gt;<name>flags</name></name> &amp; <name>TCF_IN_FOR_INIT</name>)))</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>popScope</name> || <name>let</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>off</name> = <name>noteIndex</name> = -1</expr>;</expr_stmt>
    <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_NAME</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * Emit variable binding ops, but not destructuring ops.
                 * The parser (see Variables, jsparse.c) has ensured that
                 * our caller will be the TOK_FOR/TOK_IN case in js_EmitTree,
                 * and that case will emit the destructuring code only after
                 * emitting an enumerating opcode and a branch that tests
                 * whether the enumeration ended.
                 */</comment>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>forInVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>EmitDestructuringDecls</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <break>break;</break>
            }</block></then></if>

            <comment type="block">/*
             * A destructuring initialiser assignment preceded by var is
             * always evaluated promptly, even if it is to the left of 'in'
             * in a for-in loop.  As with 'for (var x = i in o)...', this
             * will cause the entire 'var [a, b] = i' to be hoisted out of
             * the head of the loop.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 1 &amp;&amp; !<name>forInLet</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * If this is the only destructuring assignment in the list,
                 * try to optimize to a group assignment.  If we're in a let
                 * head, pass JSOP_POP rather than the pseudo-prolog JSOP_NOP
                 * in pn-&gt;pn_op, to suppress a second (and misplaced) 'let'.
                 */</comment>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>noteIndex</name> &lt; 0 &amp;&amp; !<name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>op</name> = <name>JSOP_POP</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>MaybeEmitGroupAssignment</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>,
                                              <argument><expr><name>inLetHead</name> ? <name>JSOP_POP</name> :
                                              <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>pn2</name></expr></argument>, <argument><expr>&amp;<name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_NOP</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_extra</name></name> = (<name><name>pn</name>-&gt;<name>pn_extra</name></name> &amp; ~<name>PNX_POPVAR</name>) | <name>PNX_GROUPINIT</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></then></if>

            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>EmitDestructuringDecls</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
            <comment type="block">/*
             * If this is a 'for (let [x, y] = i in o) ...' let declaration,
             * throw away i if it is a useless expression.
             */</comment>
            <if>if <condition>(<expr><name>forInLet</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>JSBool</name></type> <name>useful</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_right</name></name></expr></argument>, <argument><expr>&amp;<name>useful</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<name>useful</name></expr>)</condition><then>
                    <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
            <comment type="block">/*
             * The expression i in 'for (let [x, y] = i in o) ...', which is
             * pn2-&gt;pn_right above, appears to have side effects.  We've just
             * emitted code to evaluate i, but we must not destructure i yet.
             * Let the TOK_FOR: code in js_EmitTree do the destructuring to
             * emit the right combination of source notes and bytecode for the
             * decompiler.
             *
             * This has the effect of hoisting the evaluation of i out of the
             * for-in loop, without hoisting the let variables, which must of
             * course be scoped by the loop.  Set PNX_POPVAR to cause JSOP_POP
             * to be emitted, just before returning from this function.
             */</comment>
            <if>if <condition>(<expr><name>forInVar</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_extra</name></name> |= <name>PNX_POPVAR</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>forInLet</name></expr>)</condition><then>
                    <break>break;</break></then></if>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/*
             * Veto pn-&gt;pn_op if inLetHead to avoid emitting a SRC_DESTRUCT
             * that's redundant with respect to the SRC_DECL/SRC_DECL_LET that
             * we will emit at the bottom of this function.
             */</comment>
            <if>if <condition>(<expr>!<call><name>EmitDestructuringOps</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>,
                                      <argument><expr><name>inLetHead</name> ? <name>JSOP_POP</name> : <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <goto>goto <name>emit_note_pop</name>;</goto>
        }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>let</name> ? <name>LET_DECL</name> : <name>VAR_DECL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_slot</name></name> &gt;= 0 || !<name>let</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_ARGUMENTS</name></expr>)</condition><then> <block>{
            <comment type="block">/* JSOP_ARGUMENTS =&gt; no initializer */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pn2</name>-&gt;<name>pn_expr</name></name> &amp;&amp; !<name>let</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn3</name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
            <expr_stmt><expr><name>atomIndex</name> = 0</expr>;</expr_stmt>            <comment type="block">/* quell GCC overwarning */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr>!<call><name>MaybeEmitVarDecl</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr>&amp;<name>atomIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>pn3</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
                <comment type="block">/*
                 * If this is a 'for (let x = i in o) ...' let declaration,
                 * throw away i if it is a useless expression.
                 */</comment>
                <if>if <condition>(<expr><name>forInLet</name></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>JSBool</name></type> <name>useful</name> <init>= <expr><name>JS_FALSE</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr>&amp;<name>useful</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <if>if <condition>(<expr>!<name>useful</name></expr>)</condition><then>
                        <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <if>if <condition>(<expr><name>op</name> == <name>JSOP_SETNAME</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name>let</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>JSOP_BINDNAME</name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_DEFCONST</name> &amp;&amp;
                    !<call><name>js_DefineCompileTimeConstant</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>,
                                                  <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
                <comment type="block">/* Evaluate expr in the outer lexical scope if requested. */</comment>
                <if>if <condition>(<expr><name>popScope</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>stmt</name> = <name><name>tc</name>-&gt;<name>topStmt</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>scopeStmt</name> = <name><name>tc</name>-&gt;<name>topScopeStmt</name></name></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>tc</name>-&gt;<name>topStmt</name></name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name> = <name><name>scopeStmt</name>-&gt;<name>downScope</name></name></expr>;</expr_stmt>
                }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
                <else>else <block>{
                    <expr_stmt><expr><name>stmt</name> = <name>scopeStmt</name> = <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* quell GCC overwarning */</comment>
                }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <expr_stmt><expr><name>oldflags</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> |= <name>oldflags</name> &amp; <name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
                <if>if <condition>(<expr><name>popScope</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>tc</name>-&gt;<name>topStmt</name></name> = <name>stmt</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>tc</name>-&gt;<name>topScopeStmt</name></name> = <name>scopeStmt</name></expr>;</expr_stmt>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            }</block></then></if>
        }</block></else></if>

        <comment type="block">/*
         * 'for (var x in o) ...' and 'for (var x = i in o) ...' call the
         * TOK_VAR case, but only the initialized case (a strange one that
         * falls out of ECMA-262's grammar) wants to run past this point.
         * Both cases must conditionally emit a JSOP_DEFVAR, above.  Note
         * that the parser error-checks to ensure that pn-&gt;pn_count is 1.
         *
         * 'for (let x = i in o) ...' must evaluate i before the loop, and
         * subject it to useless expression elimination.  The variable list
         * in pn is a single let declaration if pn_op == JSOP_NOP.  We test
         * the let local in order to break early in this case, as well as in
         * the 'for (var x in o)' case.
         *
         * XXX Narcissus keeps track of variable declarations in the node
         * for the script being compiled, so there's no need to share any
         * conditional prolog code generation there.  We could do likewise,
         * but it's a big change, requiring extra allocation, so probably
         * not worth the trouble for SpiderMonkey.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>pn3</name> == <name><name>pn2</name>-&gt;<name>pn_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>forInVar</name> &amp;&amp; (!<name>pn3</name> || <name>let</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>

        <if>if <condition>(<expr><name>pn2</name> == <name><name>pn</name>-&gt;<name>pn_head</name></name> &amp;&amp;
            !<name>inLetHead</name> &amp;&amp;
            <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_DECL</name></expr></argument>,
                           <argument><expr>(<name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_DEFCONST</name>)
                           ? <name>SRC_DECL_CONST</name>
                           : (<name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_DEFVAR</name>)
                           ? <name>SRC_DECL_VAR</name>
                           : <name>SRC_DECL_LET</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_ARGUMENTS</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_slot</name></name> &gt;= 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
    <label><name>emit_note_pop</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>tmp</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>noteIndex</name> &gt;= 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name>-<name>off</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>
        <if>if <condition>(<expr>!<name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>)</condition><then>
            <break>break;</break></then></if>
        <expr_stmt><expr><name>off</name> = <name>tmp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCDELTA</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>noteIndex</name> &lt; 0 || <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
    }</block></for>

    <comment type="block">/* If this is a let head, emit and return a srcnote on the pop. */</comment>
    <if>if <condition>(<expr><name>inLetHead</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>headNoteIndex</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_DECL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>headNoteIndex</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!(<name><name>pn</name>-&gt;<name>pn_extra</name></name> &amp; <name>PNX_POPVAR</name>)</expr>)</condition><then>
            <return>return <expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return></then></if>
    }</block></then></if>

    <return>return <expr>!(<name><name>pn</name>-&gt;<name>pn_extra</name></name> &amp; <name>PNX_POPVAR</name>) || <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_brendanXXX</name> || <name>defined</name> <name>DEBUG_mrbkap</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>GettableNoteForNextOp</name><parameter_list>(<param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>target</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>target</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>sn</name> = <call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>, <expr><name>end</name> = <name>sn</name> + <call><name>CG_NOTE_COUNT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>sn</name> &lt; <name>end</name></expr>;</condition>
         <incr><expr><name>sn</name> = <call><name>SN_NEXT</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><name>offset</name> == <name>target</name> &amp;&amp; <call><name>SN_IS_GETTABLE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_TRUE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>offset</name> += <call><name>SN_DELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>JS_FALSE</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Top-level named functions need a nop for decompilation. */</comment>
<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>EmitFunctionDefNop</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>index</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_FUNCDEF</name></expr></argument>, <argument><expr>(<name>ptrdiff_t</name>)<name>index</name></expr></argument>)</argument_list></call> &gt;= 0 &amp;&amp;
           <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
}</block></function>

<function><type><name>JSBool</name></type>
<name>js_EmitTree</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSParseNode</name> *</type><name>pn</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSBool</name></type> <name>ok</name></decl>, <decl><type ref="prev"/><name>useful</name></decl>, <decl><type ref="prev"/><name>wantval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>stmt</name></decl>, <decl><type ref="prev"/><name>stmtInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>top</name></decl>, <decl><type ref="prev"/><name>off</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>, <decl><type ref="prev"/><name>beq</name></decl>, <decl><type ref="prev"/><name>jmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>pn2</name></decl>, *<decl><type ref="prev"/><name>pn3</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtom</name> *</type><name>atom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSAtomListElement</name> *</type><name>ale</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsatomid</name></type> <name>atomIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uintN</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>noteIndex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSSrcNoteType</name></type> <name>noteType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsbytecode</name> *</type><name>pc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSOp</name></type> <name>op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTokenType</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>argc</name></decl>;</decl_stmt>

    <macro><name>JS_CHECK_RECURSION</name><argument_list>(<argument>cx</argument>, <argument>return JS_FALSE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>ok</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>emitLevel</name></name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_offset</name></name> = <name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Emit notes to tell the current bytecode's source line number. */</comment>
    <expr_stmt><expr><call><name>UPDATE_LINE_NUMBER_NOTES</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
      <case>case <expr><name>TOK_FUNCTION</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>JSFunction</name> *</type><name>funobj</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>cg2mark</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSCodeGenerator</name> *</type><name>cg2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uintN</name></type> <name>slot</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_NULLARY</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_GETFUNNS</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>funobj</name> = <call><name>OBJ_TO_FUNCTION</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_funpob</name>-&gt;<name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>FUN_TO_SCRIPTED</name><argument_list>(<argument><expr><name>funobj</name></expr></argument>)</argument_list></call>-&gt;<name>script</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * This second pass is needed to emit JSOP_NOP with a source note
             * for the already-emitted function. See comments in the TOK_LC
             * case.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_index</name></name> != (<name>uint32</name>) -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>EmitFunctionDefNop</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_index</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/* Generate code for the function's body. */</comment>
        <expr_stmt><expr><name>cg2mark</name> = <call><name>JS_ARENA_MARK</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>codePool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_TYPE</name><argument_list>(<argument><expr><name>cg2</name></expr></argument>, <argument><expr><name>JSCodeGenerator</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>codePool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>cg2</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>js_InitCodeGenerator</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg2</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>parseContext</name></name></expr></argument>,
                             <argument><expr><name><name>cg</name>-&gt;<name>codePool</name></name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>notePool</name></name></expr></argument>,
                             <argument><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name>.<name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg2</name>-&gt;<name>treeContext</name>.<name>flags</name></name> = <call>(<name>uint16</name>) <argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_flags</name></name> | <name>TCF_IN_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg2</name>-&gt;<name>treeContext</name>.<name>maxScopeDepth</name></name> = <name><name>pn</name>-&gt;<name>pn_sclen</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg2</name>-&gt;<name>treeContext</name>.<name>funobj</name></name> = <name>funobj</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg2</name>-&gt;<name>parent</name></name> = <name>cg</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_EmitFunctionScript</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg2</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_body</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * We need an activation object if an inner peeks out, or if such
             * inner-peeking caused one of our inners to become heavyweight.
             */</comment>
            <if>if <condition>(<expr><name><name>cg2</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp;
                (<name>TCF_FUN_USES_NONLOCALS</name> | <name>TCF_FUN_HEAVYWEIGHT</name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> |= <name>TCF_FUN_HEAVYWEIGHT</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
        <expr_stmt><expr><call><name>js_FinishCodeGenerator</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ARENA_RELEASE</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>codePool</name></name></expr></argument>, <argument><expr><name>cg2mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cg2</name> = <name>NULL</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>pn</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/* Make the function object a literal in the outer script's pool. */</comment>
        <expr_stmt><expr><name>index</name> = <call><name>IndexParsedObject</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_funpob</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>objectList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Emit a bytecode pointing to the closure object in its immediate. */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> != <name>JSOP_NOP</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>(<name><name>pn</name>-&gt;<name>pn_flags</name></name> &amp; <name>TCF_GENEXP_LAMBDA</name>) &amp;&amp;
                <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_GENEXP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/*
         * For a script we emit the code as we parse. Thus the bytecode for
         * top-level functions should go in the prolog to predefine their
         * names in the variable object before the already-generated main code
         * is executed. This extra work for top-level scripts is not necessary
         * when we emit the code for a function. It is fully parsed prior to
         * invocation of the emitter and calls to js_EmitTree for function
         * definitions can be scheduled before generating the rest of code.
         */</comment>
        <if>if <condition>(<expr>!(<name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>CG_SWITCH_TO_PROLOG</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Emit JSOP_CLOSURE for eval code to do fewer checks when
             * instantiating top-level functions in the non-eval case.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = (<name><name>cx</name>-&gt;<name>fp</name>-&gt;<name>flags</name></name> &amp; <name>JSFRAME_EVAL</name>) ? <name>JSOP_CLOSURE</name> : <name>JSOP_DEFFUN</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CG_SWITCH_TO_MAIN</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Emit NOP for the decompiler. */</comment>
            <if>if <condition>(<expr>!<call><name>EmitFunctionDefNop</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
            <decl_stmt><decl><type><name>JSLocalKind</name></type> <name>localKind</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr><call><name>js_LookupLocal</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>FUN_TO_SCRIPTED</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>funobj</name></name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>FUN_TO_SCRIPTED</name><argument_list>(<argument><expr><name>funobj</name></expr></argument>)</argument_list></call>-&gt;<name>atom</name></expr></argument>, <argument><expr>&amp;<name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>localKind</name> == <name>JSLOCAL_VAR</name> || <name>localKind</name> == <name>JSLOCAL_CONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_index</name></name> == (<name>uint32</name>) -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn</name>-&gt;<name>pn_index</name></name> = <name>index</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>EmitSlotIndexOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSOP_DEFLOCALFUN</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>
        <break>break;</break>
      }</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_EXPORT_IMPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_EXPORT</name></expr>:
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_STAR</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * 'export *' must have no other elements in the list (what would
             * be the point?).
             */</comment>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_EXPORTALL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * If not 'export *', the list consists of NAME nodes identifying
             * properties of the variables object to flag as exported.
             */</comment>
            <do>do <block>{
                <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>JSOP_EXPORTNAME</name></expr></argument>, <argument><expr><call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block> while <condition>(<expr>(<name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name>) != <name>NULL</name></expr>)</condition>;</do>
        }</block></else></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_IMPORT</name></expr>:
        <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <comment type="block">/*
             * Each subtree on an import list is rooted by a DOT or LB node.
             * A DOT may have a null pn_atom member, in which case pn_op must
             * be JSOP_IMPORTALL -- see EmitPropOp above.
             */</comment>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></for>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_EXPORT_IMPORT */</comment>

      </case><case>case <expr><name>TOK_IF</name></expr>:
        <comment type="block">/* Initialize so we can detect else-if chains and avoid recursion. */</comment>
        <expr_stmt><expr><name><name>stmtInfo</name>.<name>type</name></name> = <name>STMT_IF</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>beq</name> = <name>jmp</name> = -1</expr>;</expr_stmt>
        <expr_stmt><expr><name>noteIndex</name> = -1</expr>;</expr_stmt>

      <label><name>if_again</name>:</label>
        <comment type="block">/* Emit code for the condition before pushing stmtInfo. */</comment>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>stmtInfo</name>.<name>type</name></name> == <name>STMT_IF</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_IF</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * We came here from the goto further below that detects else-if
             * chains, so we must mutate stmtInfo back into a STMT_IF record.
             * Also (see below for why) we need a note offset for SRC_IF_ELSE
             * to help the decompiler.  Actually, we need two offsets, one for
             * decompiling any else clause and the second for decompiling an
             * else-if chain without bracing, overindenting, or incorrectly
             * scoping let declarations.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>stmtInfo</name>.<name>type</name></name> == <name>STMT_ELSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmtInfo</name>.<name>type</name></name> = <name>STMT_IF</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmtInfo</name>.<name>update</name></name> = <name>top</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>jmp</name> - <name>beq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>noteIndex</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>top</name> - <name>jmp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>

        <comment type="block">/* Emit an annotated branch-if-false around the then part. */</comment>
        <expr_stmt><expr><name>pn3</name> = <name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name> ? <name>SRC_IF_ELSE</name> : <name>SRC_IF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>noteIndex</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>beq</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_IFEQ</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>beq</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/* Emit code for the then and optional else parts. */</comment>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>pn3</name></expr>)</condition><then> <block>{
            <comment type="block">/* Modify stmtInfo so we know we're in the else part. */</comment>
            <expr_stmt><expr><name><name>stmtInfo</name>.<name>type</name></name> = <name>STMT_ELSE</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Emit a JSOP_BACKPATCH op to jump from the end of our then part
             * around the else part.  The js_PopStatementCG call at the bottom
             * of this switch case will fix up the backpatch chain linked from
             * stmtInfo.breaks.
             */</comment>
            <expr_stmt><expr><name>jmp</name> = <call><name>EmitGoto</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr>&amp;<name><name>stmtInfo</name>.<name>breaks</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SRC_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>jmp</name> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <comment type="block">/* Ensure the branch-if-false comes here, then emit the else. */</comment>
            <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET_AT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>beq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_IF</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>pn</name> = <name>pn3</name></expr>;</expr_stmt>
                <goto>goto <name>if_again</name>;</goto>
            }</block></then></if>

            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <comment type="block">/*
             * Annotate SRC_IF_ELSE with the offset from branch to jump, for
             * the decompiler's benefit.  We can't just "back up" from the pc
             * of the else clause, because we don't know whether an extended
             * jump was required to leap from the end of the then clause over
             * the else clause.
             */</comment>
            <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>jmp</name> - <name>beq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <comment type="block">/* No else part, fixup the branch-if-false to come here. */</comment>
            <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET_AT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>beq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>ok</name> = <call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_SWITCH</name></expr>:
        <comment type="block">/* Out of line to avoid bloating js_EmitTree's stack frame size. */</comment>
        <expr_stmt><expr><name>ok</name> = <call><name>EmitSwitch</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_WHILE</name></expr>:
        <comment type="block">/*
         * Minimize bytecodes issued for one or more iterations by jumping to
         * the condition below the body and closing the loop if the condition
         * is true with a backward branch. For iteration count i:
         *
         *  i    test at the top                 test at the bottom
         *  =    ===============                 ==================
         *  0    ifeq-pass                       goto; ifne-fail
         *  1    ifeq-fail; goto; ifne-pass      goto; ifne-pass; ifne-fail
         *  2    2*(ifeq-fail; goto); ifeq-pass  goto; 2*ifne-pass; ifne-fail
         *  . . .
         *  N    N*(ifeq-fail; goto); ifeq-pass  goto; N*ifne-pass; ifne-fail
         *
         * SpiderMonkey, pre-mozilla.org, emitted while parsing and so used
         * test at the top. When JSParseNode trees were added during the ES3
         * work (1998-9), the code generation scheme was not optimized, and
         * the decompiler continued to take advantage of the branch and jump
         * that bracketed the body. But given the SRC_WHILE note, it is easy
         * to support the more efficient scheme.
         */</comment>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_WHILE_LOOP</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_WHILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>noteIndex</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>jmp</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_GOTO</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>jmp</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET_AT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>jmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>beq</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_IFNE</name></expr></argument>, <argument><expr><name>top</name> - <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>beq</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>beq</name> - <name>jmp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>ok</name> = <call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_DO</name></expr>:
        <comment type="block">/* Emit an annotated nop so we know to decompile a 'do' keyword. */</comment>
        <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_WHILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>noteIndex</name> &lt; 0 || <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/* Compile the loop body. */</comment>
        <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_DO_LOOP</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/* Set loop and enclosing label update offsets, for continue. */</comment>
        <expr_stmt><expr><name>stmt</name> = &amp;<name>stmtInfo</name></expr>;</expr_stmt>
        <do>do <block>{
            <expr_stmt><expr><name><name>stmt</name>-&gt;<name>update</name></name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> while <condition>(<expr>(<name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name>) != <name>NULL</name> &amp;&amp; <name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_LABEL</name></expr>)</condition>;</do>

        <comment type="block">/* Compile the loop condition, now that continues know where to go. */</comment>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/*
         * Since we use JSOP_IFNE for other purposes as well as for do-while
         * loops, we must store 1 + (beq - top) in the SRC_WHILE note offset,
         * and the decompiler must get that delta and decompile recursively.
         */</comment>
        <expr_stmt><expr><name>beq</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_IFNE</name></expr></argument>, <argument><expr><name>top</name> - <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>beq</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1 + (<name>beq</name> - <name>top</name>)</expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>ok</name> = <call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_FOR</name></expr>:
        <expr_stmt><expr><name>beq</name> = 0</expr>;</expr_stmt>                <comment type="block">/* suppress gcc warnings */</comment>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_FOR_LOOP</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_IN</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>JSBool</name></type> <name>emitIFEQ</name></decl>;</decl_stmt>

            <comment type="block">/* Set stmtInfo type for later testing. */</comment>
            <expr_stmt><expr><name><name>stmtInfo</name>.<name>type</name></name> = <name>STMT_FOR_IN_LOOP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>noteIndex</name> = -1</expr>;</expr_stmt>

            <comment type="block">/*
             * If the left part is 'var x', emit code to define x if necessary
             * using a prolog opcode, but do not emit a pop.  If the left part
             * is 'var x = i', emit prolog code to define x if necessary; then
             * emit code to evaluate i, assign the result to x, and pop the
             * result off the stack.
             *
             * All the logic to do this is implemented in the outer switch's
             * TOK_VAR case, conditioned on pn_extra flags set by the parser.
             *
             * In the 'for (var x = i in o) ...' case, the js_EmitTree(...pn3)
             * called here will generate the proper note for the assignment
             * op that sets x = i, hoisting the initialized var declaration
             * out of the loop: 'var x = i; for (x in o) ...'.
             *
             * In the 'for (var x in o) ...' case, nothing but the prolog op
             * (if needed) should be generated here, we must emit the note
             * just before the JSOP_FOR* opcode in the switch on pn3-&gt;pn_type
             * a bit below, so nothing is hoisted: 'for (var x in o) ...'.
             *
             * A 'for (let x = i in o)' loop must not be hoisted, since in
             * this form the let variable is scoped by the loop body (but not
             * the head).  The initializer expression i must be evaluated for
             * any side effects.  So we hoist only i in the let case.
             */</comment>
            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>type</name> = <call><name>PN_TYPE</name><argument_list>(<argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> |= <name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>TOKEN_TYPE_IS_DECL</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>

            <comment type="block">/* Compile the object expression to the right of 'in'. */</comment>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <comment type="block">/*
             * Emit a bytecode to convert top of stack value to the iterator
             * object depending on the loop variant (for-in, for-each-in, or
             * destructuring for-in).
             */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_FORIN</name> ||
                      <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_FOREACHKEYVAL</name> ||
                      <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_FOREACH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_FORIN</name> || <name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_FOREACH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET_STATEMENT_TOP</name><argument_list>(<argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Compile a JSOP_FOR* bytecode based on the left hand side.
             *
             * Initialize op to JSOP_SETNAME in case of |for ([a, b] in o)...|
             * or similar, to signify assignment, rather than declaration, to
             * the decompiler.  EmitDestructuringOps takes a prolog bytecode
             * parameter and emits the appropriate source note, defaulting to
             * assignment, so JSOP_SETNAME is not critical here; many similar
             * ops could be used -- just not JSOP_NOP (which means 'let').
             */</comment>
            <expr_stmt><expr><name>emitIFEQ</name> = <name>JS_TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>op</name> = <name>JSOP_SETNAME</name></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
              <case>case <expr><name>TOK_LET</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              </case><case>case <expr><name>TOK_VAR</name></expr>:
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name> &amp;&amp; <name><name>pn3</name>-&gt;<name>pn_count</name></name> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>destructuring_for</name>;</goto>
                }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
                 * Always annotate JSOP_FORLOCAL if given input of the form
                 * 'for (let x in * o)' -- the decompiler must not hoist the
                 * 'let x' out of the loop head, or x will be bound in the
                 * wrong scope.  Likewise, but in this case only for the sake
                 * of higher decompilation fidelity only, do not hoist 'var x'
                 * when given 'for (var x in o)'.  But 'for (var x = i in o)'
                 * requires hoisting in order to preserve the initializer i.
                 * The decompiler can only handle so much!
                 */</comment>
                <if>if <condition>(<expr>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
                     <name>type</name> == <name>TOK_LET</name> ||
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                     !<name><name>pn3</name>-&gt;<name>pn_expr</name></name>) &amp;&amp;
                    <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_DECL</name></expr></argument>,
                                   <argument><expr><name>type</name> == <name>TOK_VAR</name>
                                   ? <name>SRC_DECL_VAR</name>
                                   : <name>SRC_DECL_LET</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <comment type="block">/* FALL THROUGH */</comment>
              </case><case>case <expr><name>TOK_NAME</name></expr>:
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_slot</name></name> &gt;= 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
                      <case>case <expr><name>JSOP_GETARG</name></expr>:   <comment type="block">/* FALL THROUGH */</comment>
                      </case><case>case <expr><name>JSOP_SETARG</name></expr>:   <expr_stmt><expr><name>op</name> = <name>JSOP_FORARG</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_GETVAR</name></expr>:   <comment type="block">/* FALL THROUGH */</comment>
                      </case><case>case <expr><name>JSOP_SETVAR</name></expr>:   <expr_stmt><expr><name>op</name> = <name>JSOP_FORVAR</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_GETGVAR</name></expr>:  <comment type="block">/* FALL THROUGH */</comment>
                      </case><case>case <expr><name>JSOP_SETGVAR</name></expr>:  <expr_stmt><expr><name>op</name> = <name>JSOP_FORNAME</name></expr>;</expr_stmt> <break>break;</break>
                      </case><case>case <expr><name>JSOP_GETLOCAL</name></expr>: <comment type="block">/* FALL THROUGH */</comment>
                      </case><case>case <expr><name>JSOP_SETLOCAL</name></expr>: <expr_stmt><expr><name>op</name> = <name>JSOP_FORLOCAL</name></expr>;</expr_stmt> <break>break;</break>
                      </case><default>default:            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </default>}</block></switch>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name><name>pn3</name>-&gt;<name>pn_op</name></name> = <name>JSOP_FORNAME</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_slot</name></name> &gt;= 0</expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_const</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>op</name> == <name>JSOP_FORVAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>op</name> = <name>JSOP_FORCONST</name></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>atomIndex</name> = (<name>jsatomid</name>) <name><name>pn3</name>-&gt;<name>pn_slot</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr>!<call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                }</block></else></if>
                <break>break;</break>

              </case><case>case <expr><name>TOK_DOT</name></expr>:
                <expr_stmt><expr><name>useful</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn3</name>-&gt;<name>pn_expr</name></name></expr></argument>, <argument><expr>&amp;<name>useful</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<name>useful</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>EmitPropOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>JSOP_FORPROP</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <break>break;</break>
                }</block></then></if>
                <comment type="block">/* FALL THROUGH */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
              </case><case>case <expr><name>TOK_RB</name></expr>:
              </case><case>case <expr><name>TOK_RC</name></expr>:
              <label><name>destructuring_for</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
              </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
              </case><case>case <expr><name>TOK_LP</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              </case><case>case <expr><name>TOK_LB</name></expr>:
                <comment type="block">/*
                 * We separate the first/next bytecode from the enumerator
                 * variable binding to avoid any side-effects in the index
                 * expression (e.g., for (x[i++] in {}) should not bind x[i]
                 * or increment i at all).
                 */</comment>
                <expr_stmt><expr><name>emitIFEQ</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_FORELEM</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

                <comment type="block">/*
                 * Emit a SRC_WHILE note with offset telling the distance to
                 * the loop-closing jump (we can't reckon from the branch at
                 * the top of the loop, because the loop-closing jump might
                 * need to be an extended jump, independent of whether the
                 * branch is short or long).
                 */</comment>
                <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_WHILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>noteIndex</name> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>beq</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_IFEQ</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>beq</name> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_RB</name> || <name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_RC</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>EmitDestructuringOps</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <break>break;</break>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_LP</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_op</name></name> == <name>JSOP_SETCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <if>if <condition>(<expr>!<call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ENUMELEM</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <break>break;</break>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_UNARYOP</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_op</name></name> == <name>JSOP_BINDXMLNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <if>if <condition>(<expr>!<call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ENUMELEM</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <break>break;</break>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/* Now that we're safely past the IFEQ, commit side effects. */</comment>
                <if>if <condition>(<expr>!<call><name>EmitElemOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr><name>JSOP_ENUMELEM</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <break>break;</break>

              </case><default>default:
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </default>}</block></switch>

            <if>if <condition>(<expr><name>emitIFEQ</name></expr>)</condition><then> <block>{
                <comment type="block">/* Annotate so the decompiler can find the loop-closing jump. */</comment>
                <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_WHILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>noteIndex</name> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

                <comment type="block">/* Pop and test the loop condition generated by JSOP_FOR*. */</comment>
                <expr_stmt><expr><name>beq</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_IFEQ</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>beq</name> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>op</name> = <name>JSOP_POP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_kid1</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>pn3</name></expr>)</condition><then> <block>{
                <comment type="block">/* No initializer: emit an annotated nop for the decompiler. */</comment>
                <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> |= <name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name> &amp;&amp;
                    !<call><name>MaybeEmitGroupAssignment</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr>&amp;<name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_POP</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <if>if <condition>(<expr><call><name>TOKEN_TYPE_IS_DECL</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <comment type="block">/*
                         * Check whether a destructuring-initialized var decl
                         * was optimized to a group assignment.  If so, we do
                         * not need to emit a pop below, so switch to a nop,
                         * just for the decompiler.
                         */</comment>
                        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_extra</name></name> &amp; <name>PNX_GROUPINIT</name></expr>)</condition><then>
                            <expr_stmt><expr><name>op</name> = <name>JSOP_NOP</name></expr>;</expr_stmt></then></if>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_FOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>noteIndex</name> &lt; 0 ||
                <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SET_STATEMENT_TOP</name><argument_list>(<argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>pn2</name>-&gt;<name>pn_kid2</name></name></expr>)</condition><then> <block>{
                <comment type="block">/* No loop condition: flag this fact in the source notes. */</comment>
                <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_kid2</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>,
                                         <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>beq</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_IFEQ</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>beq</name> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></else></if>

            <comment type="block">/* Set pn3 (used below) here to avoid spurious gcc warnings. */</comment>
            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_kid3</name></name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/* Emit code for the loop body. */</comment>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_IN</name></expr>)</condition><then> <block>{
            <comment type="block">/* Set the second note offset so we can find the update part. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>noteIndex</name> != -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>1</expr></argument>,
                                     <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>pn3</name></expr>)</condition><then> <block>{
                <comment type="block">/* Set loop and enclosing "update" offsets, for continue. */</comment>
                <expr_stmt><expr><name>stmt</name> = &amp;<name>stmtInfo</name></expr>;</expr_stmt>
                <do>do <block>{
                    <expr_stmt><expr><name><name>stmt</name>-&gt;<name>update</name></name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> while <condition>(<expr>(<name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name>) != <name>NULL</name> &amp;&amp;
                         <name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_LABEL</name></expr>)</condition>;</do>

                <expr_stmt><expr><name>op</name> = <name>JSOP_POP</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name> &amp;&amp;
                    !<call><name>MaybeEmitGroupAssignment</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>, <argument><expr>&amp;<name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if>if <condition>(<expr><name>op</name> == <name>JSOP_POP</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                }</block></then></if>

                <comment type="block">/* Restore the absolute line number for source note readers. */</comment>
                <expr_stmt><expr><name>off</name> = (<name>ptrdiff_t</name>) <name><name>pn</name>-&gt;<name>pn_pos</name>.<name>end</name>.<name>lineno</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>CG_CURRENT_LINE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> != (<name>uintN</name>) <name>off</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_SETLINE</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <expr_stmt><expr><call><name>CG_CURRENT_LINE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = (<name>uintN</name>) <name>off</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>

            <comment type="block">/* The third note offset helps us find the loop-closing jump. */</comment>
            <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>2</expr></argument>,
                                     <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/* Emit the loop-closing jump and fixup all jump offsets. */</comment>
        <expr_stmt><expr><name>jmp</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_GOTO</name></expr></argument>, <argument><expr><name>top</name> - <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>jmp</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>beq</name> &gt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET_AT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>beq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_IN</name></expr>)</condition><then> <block>{
            <comment type="block">/* Set the SRC_WHILE note offset so we can find the closing jump. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>noteIndex</name> != -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>jmp</name> - <name>beq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>

        <comment type="block">/* Now fixup all breaks and continues (before for/in's JSOP_ENDITER). */</comment>
        <if>if <condition>(<expr>!<call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_IN</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * JSOP_ENDITER needs a slot to save an exception thrown from the
             * body of for-in loop when closing the iterator object.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>js_CodeSpec</name><index>[<expr><name>JSOP_ENDITER</name></expr>]</index></name>.<name>format</name> &amp; <name>JOF_TMPSLOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>NewTryNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSTN_ITER</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name></expr></argument>, <argument><expr><name>top</name></expr></argument>,
                            <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> ||
                <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ENDITER</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_BREAK</name></expr>:
        <expr_stmt><expr><name>stmt</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>atom</name> = <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>atom</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <while>while <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name> != <name>STMT_LABEL</name> || <name><name>stmt</name>-&gt;<name>u</name>.<name>label</name></name> != <name>atom</name></expr>)</condition>
                <expr_stmt><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr>;</expr_stmt></while>
            <expr_stmt><expr><name>noteType</name> = <name>SRC_BREAK2LABEL</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>ale</name> = <name>NULL</name></expr>;</expr_stmt>
            <while>while <condition>(<expr>!<call><name>STMT_IS_LOOP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>stmt</name>-&gt;<name>type</name></name> != <name>STMT_SWITCH</name></expr>)</condition>
                <expr_stmt><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr>;</expr_stmt></while>
            <expr_stmt><expr><name>noteType</name> = <name>SRC_NULL</name></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><call><name>EmitGoto</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr>&amp;<name><name>stmt</name>-&gt;<name>breaks</name></name></expr></argument>, <argument><expr><name>ale</name></expr></argument>, <argument><expr><name>noteType</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_CONTINUE</name></expr>:
        <expr_stmt><expr><name>stmt</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>atom</name> = <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>atom</name></expr>)</condition><then> <block>{
            <comment type="block">/* Find the loop statement enclosed by the matching label. */</comment>
            <decl_stmt><decl><type><name>JSStmtInfo</name> *</type><name>loop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <while>while <condition>(<expr><name><name>stmt</name>-&gt;<name>type</name></name> != <name>STMT_LABEL</name> || <name><name>stmt</name>-&gt;<name>u</name>.<name>label</name></name> != <name>atom</name></expr>)</condition> <block>{
                <if>if <condition>(<expr><call><name>STMT_IS_LOOP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name>loop</name> = <name>stmt</name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><name>stmt</name> = <name>loop</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>noteType</name> = <name>SRC_CONT2LABEL</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>ale</name> = <name>NULL</name></expr>;</expr_stmt>
            <while>while <condition>(<expr>!<call><name>STMT_IS_LOOP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
                <expr_stmt><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr>;</expr_stmt></while>
            <expr_stmt><expr><name>noteType</name> = <name>SRC_CONTINUE</name></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><call><name>EmitGoto</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr>&amp;<name><name>stmt</name>-&gt;<name>continues</name></name></expr></argument>, <argument><expr><name>ale</name></expr></argument>, <argument><expr><name>noteType</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_WITH</name></expr>:
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_WITH</name></expr></argument>, <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ENTERWITH</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_LEAVEWITH</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>ok</name> = <call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_TRY</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>tryStart</name></decl>, <decl><type ref="prev"/><name>tryEnd</name></decl>, <decl><type ref="prev"/><name>catchJump</name></decl>, <decl><type ref="prev"/><name>finallyStart</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>intN</name></type> <name>depth</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSParseNode</name> *</type><name>lastCatch</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>catchJump</name> = -1</expr>;</expr_stmt>

        <comment type="block">/*
         * Push stmtInfo to track jumps-over-catches and gosubs-to-finally
         * for later fixup.
         *
         * When a finally block is 'active' (STMT_FINALLY on the treeContext),
         * non-local jumps (including jumps-over-catches) result in a GOSUB
         * being written into the bytecode stream and fixed-up later (c.f.
         * EmitBackPatchOp and BackPatch).
         */</comment>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>,
                         <argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name> ? <name>STMT_FINALLY</name> : <name>STMT_TRY</name></expr></argument>,
                         <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Since an exception can be thrown at any place inside the try block,
         * we need to restore the stack and the scope chain before we transfer
         * the control to the exception handler.
         *
         * For that we store in a try note associated with the catch or
         * finally block the stack depth upon the try entry. The interpreter
         * uses this depth to properly unwind the stack and the scope chain.
         */</comment>
        <expr_stmt><expr><name>depth</name> = <name><name>cg</name>-&gt;<name>stackDepth</name></name></expr>;</expr_stmt>

        <comment type="block">/* Mark try location for decompilation, then emit try block. */</comment>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_TRY</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>tryStart</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/* GOSUB to finally, if present. */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>jmp</name> = <call><name>EmitBackPatchOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BACKPATCH</name></expr></argument>, <argument><expr>&amp;<call><name>GOSUBS</name><argument_list>(<argument><expr><name>stmtInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>jmp</name> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <comment type="block">/* JSOP_RETSUB pops the return pc-index, balancing the stack. */</comment>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> = <name>depth</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Emit (hidden) jump over catch and/or finally. */</comment>
        <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>jmp</name> = <call><name>EmitBackPatchOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BACKPATCH</name></expr></argument>, <argument><expr>&amp;<name>catchJump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>jmp</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <expr_stmt><expr><name>tryEnd</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If this try has a catch block, emit it. */</comment>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastCatch</name> = <name>NULL</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pn2</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>jsint</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>    <comment type="block">/* previous catch block's population */</comment>

            <comment type="block">/*
             * The emitted code for a catch block looks like:
             *
             * [throwing]                          only if 2nd+ catch block
             * [leaveblock]                        only if 2nd+ catch block
             * enterblock                          with SRC_CATCH
             * exception
             * [dup]                               only if catchguard
             * setlocalpop &lt;slot&gt;                  or destructuring code
             * [&lt; catchguard code &gt;]               if there's a catchguard
             * [ifeq &lt;offset to next catch block&gt;]         " "
             * [pop]                               only if catchguard
             * &lt; catch block contents &gt;
             * leaveblock
             * goto &lt;end of catch blocks&gt;          non-local; finally applies
             *
             * If there's no catch block without a catchguard, the last
             * &lt;offset to next catch block&gt; points to rethrow code.  This
             * code will [gosub] to the finally code if appropriate, and is
             * also used for the catch-all trynote for capturing exceptions
             * thrown from catch{} blocks.
             */</comment>
            <for>for (<init><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn3</name></expr>;</condition> <incr><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
                <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>guardJump</name></decl>, <decl><type ref="prev"/><name>catchNote</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> == <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>guardJump</name> = <call><name>GUARDJUMP</name><argument_list>(<argument><expr><name>stmtInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>guardJump</name> != -1</expr>)</condition><then> <block>{
                    <comment type="block">/* Fix up and clean up previous catch block. */</comment>
                    <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET_AT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>guardJump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Account for the pushed exception object that we still
                     * have after the jumping from the previous guard.
                     */</comment>
                    <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> = <name>depth</name> + 1</expr>;</expr_stmt>

                    <comment type="block">/*
                     * Move exception back to cx-&gt;exception to prepare for
                     * the next catch. We hide [throwing] from the decompiler
                     * since it compensates for the hidden JSOP_DUP at the
                     * start of the previous guarded catch.
                     */</comment>
                    <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0 ||
                        <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_THROWING</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                        <return>return <expr><name>JS_FALSE</name></expr>;</return>
                    }</block></then></if>

                    <comment type="block">/*
                     * Emit an unbalanced [leaveblock] for the previous catch,
                     * whose block object count is saved below.
                     */</comment>
                    <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>count</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_LEAVEBLOCK</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <comment type="block">/*
                 * Annotate the JSOP_ENTERBLOCK that's about to be generated
                 * by the call to js_EmitTree immediately below.  Save this
                 * source note's index in stmtInfo for use by the TOK_CATCH:
                 * case, where the length of the catch guard is set as the
                 * note's offset.
                 */</comment>
                <expr_stmt><expr><name>catchNote</name> = <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_CATCH</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>catchNote</name> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>CATCHNOTE</name><argument_list>(<argument><expr><name>stmtInfo</name></expr></argument>)</argument_list></call> = <name>catchNote</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * Emit the lexical scope and catch body.  Save the catch's
                 * block object population via count, for use when targeting
                 * guardJump at the next catch (the guard mismatch case).
                 */</comment>
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_LEXICALSCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>count</name> = <call><name>OBJ_BLOCK_COUNT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn3</name>-&gt;<name>pn_pob</name>-&gt;<name>object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

                <comment type="block">/* gosub &lt;finally&gt;, if required */</comment>
                <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>jmp</name> = <call><name>EmitBackPatchOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BACKPATCH</name></expr></argument>,
                                          <argument><expr>&amp;<call><name>GOSUBS</name><argument_list>(<argument><expr><name>stmtInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>jmp</name> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> == <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <comment type="block">/*
                 * Jump over the remaining catch blocks.  This will get fixed
                 * up to jump to after catch/finally.
                 */</comment>
                <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>jmp</name> = <call><name>EmitBackPatchOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BACKPATCH</name></expr></argument>, <argument><expr>&amp;<name>catchJump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>jmp</name> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

                <comment type="block">/*
                 * Save a pointer to the last catch node to handle try-finally
                 * and try-catch(guard)-finally special cases.
                 */</comment>
                <expr_stmt><expr><name>lastCatch</name> = <name><name>pn3</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>

        <comment type="block">/*
         * Last catch guard jumps to the rethrow code sequence if none of the
         * guards match. Target guardJump at the beginning of the rethrow
         * sequence, just in case a guard expression throws and leaves the
         * stack unbalanced.
         */</comment>
        <if>if <condition>(<expr><name>lastCatch</name> &amp;&amp; <name><name>lastCatch</name>-&gt;<name>pn_kid2</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET_AT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>GUARDJUMP</name><argument_list>(<argument><expr><name>stmtInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Sync the stack to take into account pushed exception. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> == <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> = <name>depth</name> + 1</expr>;</expr_stmt>

            <comment type="block">/*
             * Rethrow the exception, delegating executing of finally if any
             * to the exception handler.
             */</comment>
            <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0 ||
                <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_THROW</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> == <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Emit finally handler if any. */</comment>
        <expr_stmt><expr><name>finallyStart</name> = 0</expr>;</expr_stmt>   <comment type="block">/* to quell GCC uninitialized warnings */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Fix up the gosubs that might have been emitted before non-local
             * jumps to the finally code.
             */</comment>
            <if>if <condition>(<expr>!<call><name>BackPatch</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>GOSUBS</name><argument_list>(<argument><expr><name>stmtInfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>JSOP_GOSUB</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <expr_stmt><expr><name>finallyStart</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * The stack depth at the begining of finally must match the try
             * depth plus 2 slots. The interpreter uses these two slots to
             * either push (true, exception) pair when it transfers control
             * flow to the finally after capturing an exception, or to push
             * (false, pc-index) when it calls finally from [gosub]. The first
             * element of the pair indicates for [retsub] that it should
             * either rethrow the pending exception or transfer the control
             * back to the caller of finally.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> == <name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>uintN</name>)<name>depth</name> &lt;= <name><name>cg</name>-&gt;<name>maxStackDepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> += 2</expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>uintN</name>)<name><name>cg</name>-&gt;<name>stackDepth</name></name> &gt; <name><name>cg</name>-&gt;<name>maxStackDepth</name></name></expr>)</condition><then>
                <expr_stmt><expr><name><name>cg</name>-&gt;<name>maxStackDepth</name></name> = <name><name>cg</name>-&gt;<name>stackDepth</name></name></expr>;</expr_stmt></then></if>

            <comment type="block">/* Now indicate that we're emitting a subroutine body. */</comment>
            <expr_stmt><expr><name><name>stmtInfo</name>.<name>type</name></name> = <name>STMT_SUBROUTINE</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>UpdateLineNumberNotes</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_FINALLY</name></expr></argument>)</argument_list></call> &lt; 0 ||
                !<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>)</argument_list></call> ||
                <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_RETSUB</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Restore stack depth budget to its balanced state. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> == <name>depth</name> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> = <name>depth</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>!<call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_ENDBRACE</name></expr></argument>)</argument_list></call> &lt; 0 ||
            <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Fix up the end-of-try/catch jumps to come here. */</comment>
        <if>if <condition>(<expr>!<call><name>BackPatch</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>catchJump</name></expr></argument>, <argument><expr><call><name>CG_NEXT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>JSOP_GOTO</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/*
         * Add the try note last, to let post-order give us the right ordering
         * (first to last for a given nesting level, inner to outer by level).
         */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name> &amp;&amp;
            !<call><name>NewTryNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSTN_CATCH</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>tryStart</name></expr></argument>, <argument><expr><name>tryEnd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/*
         * If we've got a finally, mark try+catch region with additional
         * trynote to catch exceptions (re)thrown from a catch block or
         * for the try{}finally{} case.
         */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name> &amp;&amp;
            !<call><name>NewTryNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSTN_FINALLY</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>tryStart</name></expr></argument>, <argument><expr><name>finallyStart</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>TOK_CATCH</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>catchStart</name></decl>, <decl><type ref="prev"/><name>guardJump</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>blockObj</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Morph STMT_BLOCK to STMT_CATCH, note the block entry code offset,
         * and save the block object atom.
         */</comment>
        <expr_stmt><expr><name>stmt</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_BLOCK</name> &amp;&amp; (<name><name>stmt</name>-&gt;<name>flags</name></name> &amp; <name>SIF_SCOPE</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmt</name>-&gt;<name>type</name></name> = <name>STMT_CATCH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>catchStart</name> = <name><name>stmt</name>-&gt;<name>update</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>blockObj</name> = <name><name>stmt</name>-&gt;<name>u</name>.<name>blockObj</name></name></expr>;</expr_stmt>

        <comment type="block">/* Go up one statement info record to the TRY or FINALLY record. */</comment>
        <expr_stmt><expr><name>stmt</name> = <name><name>stmt</name>-&gt;<name>down</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_TRY</name> || <name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_FINALLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Pick up the pending exception and bind it to the catch variable. */</comment>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_EXCEPTION</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/*
         * Dup the exception object if there is a guard for rethrowing to use
         * it later when rethrowing or in other catches.
         */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name> &amp;&amp; <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_DUP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
          <case>case <expr><name>TOK_RB</name></expr>:
          </case><case>case <expr><name>TOK_RC</name></expr>:
            <if>if <condition>(<expr>!<call><name>EmitDestructuringOps</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

          </case><case>case <expr><name>TOK_NAME</name></expr>:
            <comment type="block">/* Inline BindNameToSlot, adding block depth to pn2-&gt;pn_slot. */</comment>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_slot</name></name> += <call><name>OBJ_BLOCK_DEPTH</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>blockObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_SETLOCALPOP</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

          </case><default>default:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>

        <comment type="block">/* Emit the guard expression, if there is one. */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>CATCHNOTE</name><argument_list>(<argument><expr>*<name>stmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>catchStart</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <comment type="block">/* ifeq &lt;next block&gt; */</comment>
            <expr_stmt><expr><name>guardJump</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_IFEQ</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>guardJump</name> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name>GUARDJUMP</name><argument_list>(<argument><expr>*<name>stmt</name></expr></argument>)</argument_list></call> = <name>guardJump</name></expr>;</expr_stmt>

            <comment type="block">/* Pop duplicated exception object as we no longer need it. */</comment>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>

        <comment type="block">/* Emit the catch body. */</comment>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/*
         * Annotate the JSOP_LEAVEBLOCK that will be emitted as we unwind via
         * our TOK_LEXICALSCOPE parent, so the decompiler knows to pop.
         */</comment>
        <expr_stmt><expr><name>off</name> = <name><name>cg</name>-&gt;<name>stackDepth</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_CATCH</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>TOK_VAR</name></expr>:
        <if>if <condition>(<expr>!<call><name>EmitVariables</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>, <argument><expr>&amp;<name>noteIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_RETURN</name></expr>:
        <comment type="block">/* Push a return value */</comment>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pn2</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_PUSH</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>

        <comment type="block">/*
         * EmitNonLocalJumpFixup may add fixup bytecode to close open try
         * blocks having finally clauses and to exit intermingled let blocks.
         * We can't simply transfer control flow to our caller in that case,
         * because we must gosub to those finally clauses from inner to outer,
         * with the correct stack pointer (i.e., after popping any with,
         * for/in, etc., slots nested inside the finally's try).
         *
         * In this case we mutate JSOP_RETURN into JSOP_SETRVAL and add an
         * extra JSOP_RETRVAL after the fixups.
         */</comment>
        <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_RETURN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>EmitNonLocalJumpFixup</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><name>top</name> + <name>JSOP_RETURN_LENGTH</name> != <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>CG_BASE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call><index>[<expr><name>top</name></expr>]</index> = <name>JSOP_SETRVAL</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_RETRVAL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_YIELD</name></expr>:
        <if>if <condition>(<expr>!(<name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>CG_TS</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_BAD_RETURN_OR_YIELD</name></expr></argument>,
                                        <argument><expr><name>js_yield_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_PUSH</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></else></if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_hidden</name></name> &amp;&amp; <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_HIDDEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_YIELD</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      </case><case>case <expr><name>TOK_LC</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_UNARY</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>noteIndex</name> = -1</expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_extra</name></name> &amp; <name>PNX_NEEDBRACES</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_BRACE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>noteIndex</name> &lt; 0 || <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_BLOCK</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_extra</name></name> &amp; <name>PNX_FUNCDEFS</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * This block contains top-level function definitions. To ensure
             * that we emit the bytecode defining them prior the rest of code
             * in the block we use a separate pass over functions. During the
             * main pass later the emitter will add JSOP_NOP with source notes
             * for the function to preserve the original functions position
             * when decompiling.
             *
             * Currently this is used only for functions, as compile-as-we go
             * mode for scripts does not allow separate emitter passes.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_FUNCTION</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_NOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></for>

        <if>if <condition>(<expr><name>noteIndex</name> &gt;= 0 &amp;&amp;
            !<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>ok</name> = <call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_BODY</name></expr>:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_BODY</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></for>
        <expr_stmt><expr><name>ok</name> = <call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_SEMI</name></expr>:
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pn2</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Top-level or called-from-a-native JS_Execute/EvaluateScript,
             * debugger, and eval frames may need the value of the ultimate
             * expression statement as the script's result, despite the fact
             * that it appears useless to the compiler.
             */</comment>
            <expr_stmt><expr><name>useful</name> = <name>wantval</name> = !(<name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>)</expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>useful</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr>&amp;<name>useful</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then></if>

            <comment type="block">/*
             * Don't eliminate apparently useless expressions if they are
             * labeled expression statements.  The tc-&gt;topStmt-&gt;update test
             * catches the case where we are nesting in js_EmitTree for a
             * labeled compound statement.
             */</comment>
            <if>if <condition>(<expr>!<name>useful</name> &amp;&amp;
                (!<name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name></name> ||
                 <name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name>-&gt;<name>type</name></name> != <name>STMT_LABEL</name> ||
                 <name><name>cg</name>-&gt;<name>treeContext</name>.<name>topStmt</name>-&gt;<name>update</name></name> &lt; <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>CG_CURRENT_LINE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name><name>pn2</name>-&gt;<name>pn_pos</name>.<name>begin</name>.<name>lineno</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>CG_TS</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn2</name></expr></argument>,
                                                 <argument><expr><name>JSREPORT_WARNING</name> |
                                                 <name>JSREPORT_STRICT</name></expr></argument>,
                                                 <argument><expr><name>JSMSG_USELESS_EXPR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>op</name> = <name>wantval</name> ? <name>JSOP_POPV</name> : <name>JSOP_POP</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
                <if>if <condition>(<expr>!<name>wantval</name> &amp;&amp;
                    <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_ASSIGN</name> &amp;&amp;
                    !<call><name>MaybeEmitGroupAssignment</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr>&amp;<name>op</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><name>JS_FALSE</name></expr>;</return>
                }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if>if <condition>(<expr><name>op</name> != <name>JSOP_NOP</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                    <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                }</block></then></if>
            }</block></else></if>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_COLON</name></expr>:
        <comment type="block">/* Emit an annotated nop so we know to decompile a label. */</comment>
        <expr_stmt><expr><name>atom</name> = <name><name>pn</name>-&gt;<name>pn_atom</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_expr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>noteType</name> = (<name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name> ||
                    (<name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LEXICALSCOPE</name> &amp;&amp;
                     <name><name>pn2</name>-&gt;<name>pn_expr</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name>))
                   ? <name>SRC_LABELBRACE</name>
                   : <name>SRC_LABEL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>noteType</name></expr></argument>,
                                   <argument><expr>(<name>ptrdiff_t</name>) <call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>noteIndex</name> &lt; 0 ||
            <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Emit code for the labeled statement. */</comment>
        <expr_stmt><expr><call><name>js_PushStatement</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>STMT_LABEL</name></expr></argument>,
                         <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>stmtInfo</name>.<name>u</name>.<name>label</name></name> = <name>atom</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/* If the statement was compound, emit a note for the end brace. */</comment>
        <if>if <condition>(<expr><name>noteType</name> == <name>SRC_LABELBRACE</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_ENDBRACE</name></expr></argument>)</argument_list></call> &lt; 0 ||
                <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NOP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_COMMA</name></expr>:
        <comment type="block">/*
         * Emit SRC_PCDELTA notes on each JSOP_POP between comma operands.
         * These notes help the decompiler bracket the bytecodes generated
         * from each sub-expression that follows a comma.
         */</comment>
        <expr_stmt><expr><name>off</name> = <name>noteIndex</name> = -1</expr>;</expr_stmt>
        <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>tmp</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>noteIndex</name> &gt;= 0</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name>-<name>off</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then></if>
            <if>if <condition>(<expr>!<name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr><name>off</name> = <name>tmp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCDELTA</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>noteIndex</name> &lt; 0 ||
                <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <break>break;</break>

      </case><case>case <expr><name>TOK_ASSIGN</name></expr>:
        <comment type="block">/*
         * Check left operand type and generate specialized code for it.
         * Specialize to avoid ECMA "reference type" values on the operand
         * stack, which impose pervasive runtime "GetValue" costs.
         */</comment>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_RP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>atomIndex</name> = (<name>jsatomid</name>) -1</expr>;</expr_stmt>              <comment type="block">/* quell GCC overwarning */</comment>
        <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
          <case>case <expr><name>TOK_NAME</name></expr>:
            <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_slot</name></name> &gt;= 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>atomIndex</name> = (<name>jsatomid</name>) <name><name>pn2</name>-&gt;<name>pn_slot</name></name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>atomIndex</name> = <call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>JSOP_BINDNAME</name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <break>break;</break>
          </case><case>case <expr><name>TOK_DOT</name></expr>:
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>atomIndex</name> = <call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>TOK_LB</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_arity</name></name> == <name>PN_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
          </case><case>case <expr><name>TOK_RB</name></expr>:
          </case><case>case <expr><name>TOK_RC</name></expr>:
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
          </case><case>case <expr><name>TOK_LP</name></expr>:
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
          </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_SETXMLNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_kid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BINDXMLNAME</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </case><default>default:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>

        <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_GETTER</name> || <name>op</name> == <name>JSOP_SETTER</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name> &amp;&amp; <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call> != <name>JSOP_SETNAME</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * x getter = y where x is a local or let variable is not
                 * supported.
                 */</comment>
                <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>,
                                            <argument><expr><call><name>TS</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>parseContext</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                            <argument><expr><name>JSMSG_BAD_GETTER_OR_SETTER</name></expr></argument>,
                                            <argument><expr>(<name>op</name> == <name>JSOP_GETTER</name>)
                                            ? <name>js_getter_str</name>
                                            : <name>js_setter_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* We'll emit these prefix bytecodes after emitting the r.h.s. */</comment>
        }</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* If += or similar, dup the left operand and get its value. */</comment>
        <if>if <condition>(<expr><name>op</name> != <name>JSOP_NOP</name></expr>)</condition><then> <block>{
            <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
              <case>case <expr><name>TOK_NAME</name></expr>:
                <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> != <name>JSOP_SETNAME</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr>(<name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_SETGVAR</name>)
                                       ? <name>JSOP_GETGVAR</name>
                                       : (<name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_SETARG</name>)
                                       ? <name>JSOP_GETARG</name>
                                       : (<name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_SETLOCAL</name>)
                                       ? <name>JSOP_GETLOCAL</name>
                                       : <name>JSOP_GETVAR</name></expr></argument>,
                                       <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_DUP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>JSOP_GETXPROP</name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
              </case><case>case <expr><name>TOK_DOT</name></expr>:
                <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_DUP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_atom</name></name> == <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>lengthAtom</name></name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_LENGTH</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>JSOP_GETPROP</name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>
              </case><case>case <expr><name>TOK_LB</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
              </case><case>case <expr><name>TOK_LP</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
              </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_DUP2</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_GETELEM</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <break>break;</break>
              </case><default>default:<empty_stmt>;</empty_stmt>
            </default>}</block></switch>
        }</block></then></if></else></if>

        <comment type="block">/* Now emit the right operand (it may affect the namespace). */</comment>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/* If += etc., emit the binary operator with a decompiler note. */</comment>
        <if>if <condition>(<expr><name>op</name> != <name>JSOP_NOP</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Take care to avoid SRC_ASSIGNOP if the left-hand side is a
             * const declared in a function (i.e., with non-negative pn_slot
             * and when pn_const is true), as in this case (just a bit further
             * below) we will avoid emitting the assignment op.
             */</comment>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_NAME</name> ||
                <name><name>pn2</name>-&gt;<name>pn_slot</name></name> &lt; 0 ||
                !<name><name>pn2</name>-&gt;<name>pn_const</name></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_ASSIGNOP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>

        <comment type="block">/* Left parts such as a.b.c and a[b].c need a decompiler note. */</comment>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_NAME</name> &amp;&amp;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
            <name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_RB</name> &amp;&amp;
            <name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_RC</name> &amp;&amp;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>, <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Finally, emit the specialized assignment bytecode. */</comment>
        <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
          <case>case <expr><name>TOK_NAME</name></expr>:
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_slot</name></name> &gt;= 0</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<name><name>pn2</name>-&gt;<name>pn_const</name></name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <break>break;</break>
            }</block></then></if>
            <comment type="line">// FALL THROUGH</comment>
          </case><case>case <expr><name>TOK_DOT</name></expr>:
            <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          </case><case>case <expr><name>TOK_LB</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
          </case><case>case <expr><name>TOK_LP</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_SETELEM</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING</name></expr></cpp:if>
          </case><case>case <expr><name>TOK_RB</name></expr>:
          </case><case>case <expr><name>TOK_RC</name></expr>:
            <if>if <condition>(<expr>!<call><name>EmitDestructuringOps</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_SETNAME</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
          </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_SETXMLNAME</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </case><default>default:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
        <break>break;</break>

      </case><case>case <expr><name>TOK_HOOK</name></expr>:
        <comment type="block">/* Emit the condition, then branch if false to the else part. */</comment>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid1</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_COND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>noteIndex</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>beq</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_IFEQ</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>beq</name> &lt; 0 || !<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid2</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/* Jump around else, fixup the branch, emit else, fixup jump. */</comment>
        <expr_stmt><expr><name>jmp</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_GOTO</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>jmp</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET_AT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>beq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Because each branch pushes a single value, but our stack budgeting
         * analysis ignores branches, we now have to adjust cg-&gt;stackDepth to
         * ignore the value pushed by the first branch.  Execution will follow
         * only one path, so we must decrement cg-&gt;stackDepth.
         *
         * Failing to do this will foil code, such as the try/catch/finally
         * exception handling code generator, that samples cg-&gt;stackDepth for
         * use at runtime (JSOP_SETSP), or in let expression and block code
         * generation, which must use the stack depth to compute local stack
         * indexes correctly.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name>--</expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid3</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET_AT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>jmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>jmp</name> - <name>beq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_OR</name></expr>:
      </case><case>case <expr><name>TOK_AND</name></expr>:
        <comment type="block">/*
         * JSOP_OR converts the operand on the stack to boolean, and if true,
         * leaves the original operand value on the stack and jumps; otherwise
         * it pops and falls into the next bytecode, which evaluates the right
         * operand.  The jump goes around the right operand evaluation.
         *
         * JSOP_AND converts the operand on the stack to boolean, and if false,
         * leaves the original operand value on the stack and jumps; otherwise
         * it pops and falls into the right operand's bytecode.
         */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_BINARY</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>top</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BACKPATCH_POP</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>top</name> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>off</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pc</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>off</name> - <name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>pc</name> = <name><name>pn</name>-&gt;<name>pn_op</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_head</name>-&gt;<name>pn_next</name>-&gt;<name>pn_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Left-associative operator chain: avoid too much recursion. */</comment>
            <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>top</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BACKPATCH_POP</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>top</name> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <comment type="block">/* Emit nodes between the head and the tail. */</comment>
            <expr_stmt><expr><name>jmp</name> = <name>top</name></expr>;</expr_stmt>
            <while>while <condition>(<expr>(<name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name>)-&gt;<name>pn_next</name></expr>)</condition> <block>{
                <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>off</name> = <call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BACKPATCH_POP</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<call><name>SetBackPatchDelta</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>jmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>off</name> - <name>jmp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>jmp</name> = <name>off</name></expr>;</expr_stmt>

            }</block></while>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>off</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <do>do <block>{
                <expr_stmt><expr><name>pc</name> = <call><name>CG_CODE</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tmp</name> = <call><name>GetJumpOffset</name><argument_list>(<argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>off</name> - <name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>pc</name> = <name><name>pn</name>-&gt;<name>pn_op</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>top</name> += <name>tmp</name></expr>;</expr_stmt>
            }</block> while <condition>(<expr>(<name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name>)-&gt;<name>pn_next</name></expr>)</condition>;</do>
        }</block></else></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_BITOR</name></expr>:
      </case><case>case <expr><name>TOK_BITXOR</name></expr>:
      </case><case>case <expr><name>TOK_BITAND</name></expr>:
      </case><case>case <expr><name>TOK_EQOP</name></expr>:
      </case><case>case <expr><name>TOK_RELOP</name></expr>:
      </case><case>case <expr><name>TOK_IN</name></expr>:
      </case><case>case <expr><name>TOK_INSTANCEOF</name></expr>:
      </case><case>case <expr><name>TOK_SHOP</name></expr>:
      </case><case>case <expr><name>TOK_PLUS</name></expr>:
      </case><case>case <expr><name>TOK_MINUS</name></expr>:
      </case><case>case <expr><name>TOK_STAR</name></expr>:
      </case><case>case <expr><name>TOK_DIVOP</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr>)</condition><then> <block>{
            <comment type="block">/* Left-associative operator chain: avoid too much recursion. */</comment>
            <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr>(<name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name>) != <name>NULL</name></expr>)</condition> <block>{
                <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></while>
        }</block></then> <else>else <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
            <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>;</decl_stmt>

      <case>case <expr><name>TOK_DBLCOLON</name></expr>:
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_NAME</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr>!<call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <break>break;</break>
            }</block></then></if>

            <comment type="block">/*
             * Binary :: has a right operand that brackets arbitrary code,
             * possibly including a let (a = b) ... expression.  We must clear
             * TCF_IN_FOR_INIT to avoid mis-compiling such beasts.
             */</comment>
            <expr_stmt><expr><name>oldflags</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* Binary operators that evaluate both operands unconditionally. */</comment>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> |= <name>oldflags</name> &amp; <name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        </case>}</block></else></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_THROW</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_AT</name></expr>:
      </case><case>case <expr><name>TOK_DEFAULT</name></expr>:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_UNARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* FALL THROUGH */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>;</decl_stmt>

        <comment type="block">/* Unary op, including unary +/-. */</comment>
        <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_XMLNAME</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>EmitXMLName</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_TYPEOF</name></expr>)</condition><then> <block>{
            <for>for (<init><expr><name>pn3</name> = <name>pn2</name></expr>;</init> <condition><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_RP</name></expr>;</condition> <incr><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_kid</name></name></expr></incr>)
                <continue>continue;</continue></for>
            <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> != <name>TOK_NAME</name></expr>)</condition><then>
                <expr_stmt><expr><name>op</name> = <name>JSOP_TYPEOFEXPR</name></expr>;</expr_stmt></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>oldflags</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> |= <name>oldflags</name> &amp; <name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>TOK_INC</name></expr>:
      </case><case>case <expr><name>TOK_DEC</name></expr>:
        <comment type="block">/* Emit lvalue-specialized code for ++/-- operators. */</comment>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> != <name>TOK_RP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
          <default>default:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>op</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_slot</name></name> &gt;= 0</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_const</name></name></expr>)</condition><then> <block>{
                    <comment type="block">/* Incrementing a declared const: just get its value. */</comment>
                    <expr_stmt><expr><name>op</name> = (<call><name>JOF_OPTYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> == <name>JOF_ATOM</name>)
                         ? <name>JSOP_GETGVAR</name>
                         : <name>JSOP_GETVAR</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>atomIndex</name> = (<name>jsatomid</name>) <name><name>pn2</name>-&gt;<name>pn_slot</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!<call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></else></if>
            <break>break;</break>
          </default><case>case <expr><name>TOK_DOT</name></expr>:
            <if>if <condition>(<expr>!<call><name>EmitPropOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
          </case><case>case <expr><name>TOK_LB</name></expr>:
            <if>if <condition>(<expr>!<call><name>EmitElemOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
          </case><case>case <expr><name>TOK_LP</name></expr>:
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>,
                               <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name><name>pn2</name>-&gt;<name>pn_offset</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
          </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_SETXMLNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_kid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_BINDXMLNAME</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </case>}</block></switch>
        <break>break;</break>

      </case><case>case <expr><name>TOK_DELETE</name></expr>:
        <comment type="block">/*
         * Under ECMA 3, deleting a non-reference returns true -- but alas we
         * must evaluate the operand if it appears it might have side effects.
         */</comment>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_kid</name></name></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
          <case>case <expr><name>TOK_NAME</name></expr>:
            <expr_stmt><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> = <name>JSOP_DELNAME</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>BindNameToSlot</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>op</name> == <name>JSOP_FALSE</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!<call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></else></if>
            <break>break;</break>
          </case><case>case <expr><name>TOK_DOT</name></expr>:
            <if>if <condition>(<expr>!<call><name>EmitPropOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>JSOP_DELPROP</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
          </case><case>case <expr><name>TOK_DBLDOT</name></expr>:
            <if>if <condition>(<expr>!<call><name>EmitElemOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>JSOP_DELDESC</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
          </case><case>case <expr><name>TOK_LP</name></expr>:
            <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>, <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_DELELEM</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </case><case>case <expr><name>TOK_LB</name></expr>:
            <if>if <condition>(<expr>!<call><name>EmitElemOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>JSOP_DELELEM</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
          </case><default>default:
            <comment type="block">/*
             * If useless, just emit JSOP_TRUE; otherwise convert delete foo()
             * to foo(), true (a comma expression, requiring SRC_PCDELTA, and
             * also JSOP_GROUP for correctly parenthesized decompilation).
             */</comment>
            <expr_stmt><expr><name>useful</name> = <name>JS_FALSE</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>CheckSideEffects</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr>&amp;<name>useful</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr>!<name>useful</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>off</name> = <name>noteIndex</name> = -1</expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>off</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCDELTA</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>noteIndex</name> &lt; 0 || <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_POP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></else></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_TRUE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name>noteIndex</name> &gt;= 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>tmp</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tmp</name>-<name>off</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_GROUP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        </default>}</block></switch>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_FILTER</name></expr>:
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_left</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>jmp</name> = <call><name>js_Emit3</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_FILTER</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>jmp</name> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>top</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>CHECK_AND_SET_JUMP_OFFSET_AT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>jmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>EmitJump</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ENDFILTER</name></expr></argument>, <argument><expr><name>top</name> - <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      </case><case>case <expr><name>TOK_DOT</name></expr>:
        <comment type="block">/*
         * Pop a stack operand, convert it to object, get a property named by
         * this bytecode's immediate-indexed atom operand, and push its value
         * (not a reference to it).
         */</comment>
        <expr_stmt><expr><name>ok</name> = <call><name>EmitPropOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_LB</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_DBLDOT</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Pop two operands, convert the left one to object and the right one
         * to property name (atom or tagged int), get the named property, and
         * push its value.  Set the "obj" register to the result of ToObject
         * on the left operand.
         */</comment>
        <expr_stmt><expr><name>ok</name> = <call><name>EmitElemOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_NEW</name></expr>:
      </case><case>case <expr><name>TOK_LP</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Emit function call or operator new (constructor call) code.
         * First, emit code for the left operand to evaluate the callable or
         * constructable object expression.
         */</comment>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name></expr>)</condition> <block>{
          <case>case <expr><name>TOK_NAME</name></expr>:
            <if>if <condition>(<expr>!<call><name>EmitNameOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
          </case><case>case <expr><name>TOK_DOT</name></expr>:
            <if>if <condition>(<expr>!<call><name>EmitPropOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JS_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
          </case><case>case <expr><name>TOK_LB</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_GETELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>EmitElemOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>JSOP_CALLELEM</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
          </case><case>case <expr><name>TOK_UNARYOP</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_op</name></name> == <name>JSOP_XMLNAME</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>EmitXMLName</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>, <argument><expr><name>JSOP_CALLXMLNAME</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <break>break;</break>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* FALL THROUGH */</comment>
          </case><default>default:
            <comment type="block">/*
             * Push null as a placeholder for the global object, per ECMA-262
             * 11.2.3 step 6.
             */</comment>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call> || !<call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        </default>}</block></switch>

        <comment type="block">/* Remember start of callable-object bytecode for decompilation hint. */</comment>
        <expr_stmt><expr><name>off</name> = <name>top</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Emit code for each argument in order, then emit the JSOP_*CALL or
         * JSOP_NEW bytecode with a two-byte immediate telling how many args
         * were pushed on the operand stack.
         */</comment>
        <expr_stmt><expr><name>oldflags</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
        <for>for (<init><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>;</init> <condition><expr><name>pn3</name></expr>;</condition> <incr><expr><name>pn3</name> = <name><name>pn3</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></for>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> |= <name>oldflags</name> &amp; <name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>, <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>off</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <expr_stmt><expr><name>argc</name> = <name><name>pn</name>-&gt;<name>pn_count</name></name> - 1</expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_Emit3</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARGC_HI</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARGC_LO</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call> == <name>JSOP_EVAL</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_LINENO</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_pos</name>.<name>begin</name>.<name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>TOK_LEXICALSCOPE</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>JSObject</name> *</type><name>obj</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>jsint</name></type> <name>count</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>obj</name> = <name><name>pn</name>-&gt;<name>pn_pob</name>-&gt;<name>object</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>js_PushBlockScope</name><argument_list>(<argument><expr>&amp;<name><name>cg</name>-&gt;<name>treeContext</name></name></expr></argument>, <argument><expr>&amp;<name>stmtInfo</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>OBJ_SET_BLOCK_DEPTH</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name> = <call><name>OBJ_BLOCK_COUNT</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> += <name>count</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>uintN</name>)<name><name>cg</name>-&gt;<name>stackDepth</name></name> &gt; <name><name>cg</name>-&gt;<name>maxStackDepth</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>maxStackDepth</name></name> = <name><name>cg</name>-&gt;<name>stackDepth</name></name></expr>;</expr_stmt></then></if>

        <comment type="block">/*
         * If this lexical scope is not for a catch block, let block or let
         * expression, or any kind of for loop (where the scope starts in the
         * head after the first part if for (;;), else in the body if for-in);
         * and if our container is top-level but not a function body, or else
         * a block statement; then emit a SRC_BRACE note.  All other container
         * statements get braces by default from the decompiler.
         */</comment>
        <expr_stmt><expr><name>noteIndex</name> = -1</expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> = <call><name>PN_TYPE</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>type</name> != <name>TOK_CATCH</name> &amp;&amp; <name>type</name> != <name>TOK_LET</name> &amp;&amp; <name>type</name> != <name>TOK_FOR</name> &amp;&amp;
            (!(<name>stmt</name> = <name><name>stmtInfo</name>.<name>down</name></name>)
             ? !(<name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_IN_FUNCTION</name>)
             : <name><name>stmt</name>-&gt;<name>type</name></name> == <name>STMT_BLOCK</name>)</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_brendanXXX</name> || <name>defined</name> <name>DEBUG_mrbkap</name></expr></cpp:if>
            <comment type="block">/* There must be no source note already output for the next op. */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CG_NOTE_COUNT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> == 0 ||
                      <call><name>CG_LAST_NOTE_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> != <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> ||
                      !<call><name>GettableNoteForNextOp</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>noteIndex</name> = <call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_BRACE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>noteIndex</name> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> == <name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>EmitObjectOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_pob</name></name></expr></argument>, <argument><expr><name>JSOP_ENTERBLOCK</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> == <name>JSOP_LEAVEBLOCKEXPR</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_PCBASE</name></expr></argument>, <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>noteIndex</name> &gt;= 0 &amp;&amp;
                !<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>top</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
        }</block></else></if>

        <comment type="block">/* Emit the JSOP_LEAVEBLOCK or JSOP_LEAVEBLOCKEXPR opcode. */</comment>
        <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> -= <name>count</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>ok</name> = <call><name>js_PopStatementCG</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_BLOCK_SCOPE</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_LET</name></expr>:
        <comment type="block">/* Let statements have their variable declarations on the left. */</comment>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_BINARY</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_right</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn</name> = <name><name>pn</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>pn2</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/* Non-null pn2 means that pn is the variable list from a let head. */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>EmitVariables</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>pn2</name> != <name>NULL</name></expr></argument>, <argument><expr>&amp;<name>noteIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <comment type="block">/* Thus non-null pn2 is the body of the let block or expression. */</comment>
        <expr_stmt><expr><name>tmp</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>pn2</name> &amp;&amp; !<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <if>if <condition>(<expr><name>noteIndex</name> &gt;= 0 &amp;&amp;
            !<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr>(<name>uintN</name>)<name>noteIndex</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr><call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_BLOCK_SCOPE */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
       </case><case>case <expr><name>TOK_ARRAYPUSH</name></expr>:
        <comment type="block">/*
         * The array object's stack index is in cg-&gt;arrayCompSlot.  See below
         * under the array initialiser code generator for array comprehension
         * special casing.
         */</comment>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>arrayCompSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      </case><case>case <expr><name>TOK_RB</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_ARRAYCOMP</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Emit code for [a, b, c] of the form:
         *   t = new Array; t[0] = a; t[1] = b; t[2] = c; t;
         * but use a stack slot for t and avoid dup'ing and popping it via
         * the JSOP_NEWINIT and JSOP_INITELEM bytecodes.
         */</comment>
        <if>if <condition>(<expr><call><name>js_Emit2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NEWINIT</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>) <name>JSProto_Array</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SHARP_VARS</name></expr></cpp:if>
        <if>if <condition>(<expr><name>pn2</name> &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_DEFSHARP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_DEFSHARP</name></expr></argument>, <argument><expr>(<name>jsatomid</name>)<name><name>pn2</name>-&gt;<name>pn_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GENERATORS</name></expr></cpp:if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_ARRAYCOMP</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>uintN</name></type> <name>saveSlot</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Pass the new array's stack index to the TOK_ARRAYPUSH case by
             * storing it in pn-&gt;pn_extra, then simply traverse the TOK_FOR
             * node and its kids under pn2 to generate this comprehension.
             */</comment>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>saveSlot</name> = <name><name>cg</name>-&gt;<name>arrayCompSlot</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>arrayCompSlot</name></name> = <call>(<name>uint32</name>) <argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>stackDepth</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <expr_stmt><expr><name><name>cg</name>-&gt;<name>arrayCompSlot</name></name> = <name>saveSlot</name></expr>;</expr_stmt>

            <comment type="block">/* Emit the usual op needed for decompilation. */</comment>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ENDINIT</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <break>break;</break>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_GENERATORS */</comment>

        <for>for (<init><expr><name>atomIndex</name> = 0</expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>atomIndex</name>++</expr>, <expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<call><name>EmitNumberOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atomIndex</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

            <comment type="block">/* FIXME 260106: holes in a sparse initializer are void-filled. */</comment>
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_COMMA</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_PUSH</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></else></if>

            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_INITELEM</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></for>

        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_extra</name></name> &amp; <name>PNX_ENDCOMMA</name></expr>)</condition><then> <block>{
            <comment type="block">/* Emit a source note so we know to decompile an extra comma. */</comment>
            <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_CONTINUE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then></if>

        <comment type="block">/* Emit an op for sharp array cleanup and decompilation. */</comment>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ENDINIT</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_RC</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DESTRUCTURING_SHORTHAND</name></expr></cpp:if>
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_extra</name></name> &amp; <name>PNX_SHORTHAND</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportCompileErrorNumber</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><call><name>CG_TS</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSREPORT_ERROR</name></expr></argument>,
                                        <argument><expr><name>JSMSG_BAD_OBJECT_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>JS_FALSE</name></expr>;</return>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Emit code for {p:a, '%q':b, 2:c} of the form:
         *   t = new Object; t.p = a; t['%q'] = b; t[2] = c; t;
         * but use a stack slot for t and avoid dup'ing and popping it via
         * the JSOP_NEWINIT and JSOP_INITELEM bytecodes.
         */</comment>
        <if>if <condition>(<expr><call><name>js_Emit2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_NEWINIT</name></expr></argument>, <argument><expr>(<name>jsbytecode</name>) <name>JSProto_Object</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SHARP_VARS</name></expr></cpp:if>
        <if>if <condition>(<expr><name>pn2</name> &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_DEFSHARP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_DEFSHARP</name></expr></argument>, <argument><expr>(<name>jsatomid</name>)<name><name>pn2</name>-&gt;<name>pn_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <for>for (<init>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <comment type="block">/* Emit an index for t[2], else map an atom for t.p or t['%q']. */</comment>
            <expr_stmt><expr><name>pn3</name> = <name><name>pn2</name>-&gt;<name>pn_left</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__GNUC__</name></cpp:ifdef>
                <expr_stmt><expr><name>ale</name> = <name>NULL</name></expr>;</expr_stmt>     <comment type="block">/* quell GCC overwarning */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if>if <condition>(<expr>!<call><name>EmitNumberOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn3</name>-&gt;<name>pn_dval</name></name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_NAME</name> ||
                          <name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn3</name>-&gt;<name>pn_atom</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></else></if>

            <comment type="block">/* Emit code for the property initializer. */</comment>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn2</name>-&gt;<name>pn_right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_GETTER_SETTER</name></expr></cpp:if>
            <expr_stmt><expr><name>op</name> = <call><name>PN_OP</name><argument_list>(<argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>op</name> == <name>JSOP_GETTER</name> || <name>op</name> == <name>JSOP_SETTER</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* Annotate JSOP_INITELEM so we decompile 2:c and not just c. */</comment>
            <if>if <condition>(<expr><name><name>pn3</name>-&gt;<name>pn_type</name></name> == <name>TOK_NUMBER</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_INITPROP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_INITELEM</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>JSOP_INITPROP</name></expr></argument>, <argument><expr><call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

        <comment type="block">/* Emit an op for sharpArray cleanup and decompilation. */</comment>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ENDINIT</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_SHARP_VARS</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_DEFSHARP</name></expr>:
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_DEFSHARP</name></expr></argument>, <argument><expr>(<name>jsatomid</name>) <name><name>pn</name>-&gt;<name>pn_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_USESHARP</name></expr>:
        <expr_stmt><expr><call><name>EMIT_UINT16_IMM_OP</name><argument_list>(<argument><expr><name>JSOP_USESHARP</name></expr></argument>, <argument><expr>(<name>jsatomid</name>) <name><name>pn</name>-&gt;<name>pn_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_SHARP_VARS */</comment>

      </case><case>case <expr><name>TOK_RP</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>uintN</name></type> <name>oldflags</name></decl>;</decl_stmt>

        <comment type="block">/*
         * The node for (e) has e as its kid, enabling users who want to nest
         * assignment expressions in conditions to avoid the error correction
         * done by Condition (from x = y to x == y) by double-parenthesizing.
         */</comment>
        <expr_stmt><expr><name>oldflags</name> = <name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp;= ~<name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_kid</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> |= <name>oldflags</name> &amp; <name>TCF_IN_FOR_INIT</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_GROUP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>TOK_NAME</name></expr>:
        <if>if <condition>(<expr>!<call><name>EmitNameOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JS_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_XMLATTR</name></expr>:
      </case><case>case <expr><name>TOK_XMLSPACE</name></expr>:
      </case><case>case <expr><name>TOK_XMLTEXT</name></expr>:
      </case><case>case <expr><name>TOK_XMLCDATA</name></expr>:
      </case><case>case <expr><name>TOK_XMLCOMMENT</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </case><case>case <expr><name>TOK_STRING</name></expr>:
        <expr_stmt><expr><name>ok</name> = <call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_NUMBER</name></expr>:
        <expr_stmt><expr><name>ok</name> = <call><name>EmitNumberOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_dval</name></name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

      </case><case>case <expr><name>TOK_REGEXP</name></expr>:
        <comment type="block">/*
         * If the regexp's script is one-shot, we can avoid the extra
         * fork-on-exec costs of JSOP_REGEXP by selecting JSOP_OBJECT.
         * Otherwise, to avoid incorrect proto, parent, and lastIndex
         * sharing among threads and sequentially across re-execution,
         * select JSOP_REGEXP.
         */</comment>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>cg</name>-&gt;<name>treeContext</name>.<name>flags</name></name> &amp; <name>TCF_COMPILE_N_GO</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <call><name>EmitObjectOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_pob</name></name></expr></argument>, <argument><expr><name>JSOP_OBJECT</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>ok</name> = <call><name>EmitIndexOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSOP_REGEXP</name></expr></argument>,
                             <argument><expr><call><name>IndexParsedObject</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_pob</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>regexpList</name></name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_ANYNAME</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </case><case>case <expr><name>TOK_PRIMARY</name></expr>:
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_DEBUGGER_KEYWORD</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_DEBUGGER</name></expr>:
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_DEBUGGER</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_DEBUGGER_KEYWORD */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
      </case><case>case <expr><name>TOK_XMLELEM</name></expr>:
      </case><case>case <expr><name>TOK_XMLLIST</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_XMLOBJECT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <call><name>EmitObjectOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_pob</name></name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_XMLLIST</name> || <name><name>pn</name>-&gt;<name>pn_count</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>pn</name>-&gt;<name>pn_head</name></name> ? <name><name>pn</name>-&gt;<name>pn_head</name>-&gt;<name>pn_type</name></name> : <name>TOK_XMLLIST</name></expr>)</condition> <block>{
          <case>case <expr><name>TOK_XMLETAGO</name></expr>:
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* FALL THROUGH */</comment>
          </case><case>case <expr><name>TOK_XMLPTAGC</name></expr>:
          </case><case>case <expr><name>TOK_XMLSTAGO</name></expr>:
            <break>break;</break>
          </case><default>default:
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_STARTXML</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        </default>}</block></switch>

        <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name> &amp;&amp;
                <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_STARTXMLEXPR</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name>pn2</name> != <name><name>pn</name>-&gt;<name>pn_head</name></name> &amp;&amp; <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ADD</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></for>

        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_extra</name></name> &amp; <name>PNX_XMLROOT</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_count</name></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_XMLLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>atom</name> = <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>emptyAtom</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>JSOP_STRING</name></expr></argument>, <argument><expr><call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
        <else>else
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>

      </case><case>case <expr><name>TOK_XMLPTAGC</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_XMLOBJECT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ok</name> = <call><name>EmitObjectOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_pob</name></name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <comment type="block">/* FALL THROUGH */</comment>

      </case><case>case <expr><name>TOK_XMLSTAGO</name></expr>:
      </case><case>case <expr><name>TOK_XMLETAGO</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_STARTXML</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>,
                           <argument><expr>(<name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_XMLETAGO</name>)
                           ? <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>etagoAtom</name></name>
                           : <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>stagoAtom</name></name></expr></argument>,
                           <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>JSOP_STRING</name></expr></argument>, <argument><expr><call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name> &amp;&amp; <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_STARTXMLEXPR</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ADD</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <for>for (<init><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name> &amp;&amp;
                <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_STARTXMLEXPR</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            <if>if <condition>(<expr>(<name>i</name> &amp; 1) &amp;&amp; <name><name>pn2</name>-&gt;<name>pn_type</name></name> == <name>TOK_LC</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_TOATTRVAL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>,
                         <argument><expr>(<name>i</name> &amp; 1) ? <name>JSOP_ADDATTRVAL</name> : <name>JSOP_ADDATTRNAME</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <return>return <expr><name>JS_FALSE</name></expr>;</return>
            }</block></then></if>
        }</block></for>

        <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>,
                           <argument><expr>(<name><name>pn</name>-&gt;<name>pn_type</name></name> == <name>TOK_XMLPTAGC</name>)
                           ? <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>ptagcAtom</name></name>
                           : <name><name>cx</name>-&gt;<name>runtime</name>-&gt;<name>atomState</name>.<name>tagcAtom</name></name></expr></argument>,
                           <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><call><name>EMIT_INDEX_OP</name><argument_list>(<argument><expr><name>JSOP_STRING</name></expr></argument>, <argument><expr><call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ADD</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>

        <if>if <condition>(<expr>(<name><name>pn</name>-&gt;<name>pn_extra</name></name> &amp; <name>PNX_XMLROOT</name>) &amp;&amp; <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>
      }</block>

      </case><case>case <expr><name>TOK_XMLNAME</name></expr>:
        <if>if <condition>(<expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_LIST</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_count</name></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>pn2</name> = <name><name>pn</name>-&gt;<name>pn_head</name></name></expr>;</init> <condition><expr><name>pn2</name></expr>;</condition> <incr><expr><name>pn2</name> = <name><name>pn2</name>-&gt;<name>pn_next</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr>!<call><name>js_EmitTree</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>pn2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <if>if <condition>(<expr><name>pn2</name> != <name><name>pn</name>-&gt;<name>pn_head</name></name> &amp;&amp; <call><name>js_Emit1</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>JSOP_ADD</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
            }</block></for>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>pn</name>-&gt;<name>pn_arity</name></name> == <name>PN_NULLARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ok</name> = (<name><name>pn</name>-&gt;<name>pn_op</name></name> == <name>JSOP_OBJECT</name>)
                 ? <call><name>EmitObjectOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_pob</name></name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call>
                 : <call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><call><name>PN_OP</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

      </case><case>case <expr><name>TOK_XMLPI</name></expr>:
        <expr_stmt><expr><name>ale</name> = <call><name>js_IndexAtom</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name><name>pn</name>-&gt;<name>pn_atom2</name></name></expr></argument>, <argument><expr>&amp;<name><name>cg</name>-&gt;<name>atomList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>ale</name></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>EmitIndexOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>JSOP_QNAMEPART</name></expr></argument>, <argument><expr><call><name>ALE_INDEX</name><argument_list>(<argument><expr><name>ale</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>EmitAtomOp</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><name>JSOP_XMLPI</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_HAS_XML_SUPPORT */</comment>

      </case><default>default:
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>

    <if>if <condition>(<expr><name>ok</name> &amp;&amp; --<name><name>cg</name>-&gt;<name>emitLevel</name></name> == 0 &amp;&amp; <name><name>cg</name>-&gt;<name>spanDeps</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>ok</name> = <call><name>OptimizeSpanDeps</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<comment type="block">/* XXX get rid of offsetBias, it's used only by SRC_FOR and SRC_DECL */</comment>
<macro><name>JS_FRIEND_DATA</name><argument_list>(<argument>JSSrcNoteSpec</argument>)</argument_list></macro> <expr_stmt><expr><name><name>js_SrcNoteSpec</name><index>[]</index></name> = <block>{
    <expr><block>{<expr>"null"</expr>,            <expr>0</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"if"</expr>,              <expr>0</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"if-else"</expr>,         <expr>2</expr>,      <expr>0</expr>,      <expr>1</expr>}</block></expr>,
    <expr><block>{<expr>"while"</expr>,           <expr>1</expr>,      <expr>0</expr>,      <expr>1</expr>}</block></expr>,
    <expr><block>{<expr>"for"</expr>,             <expr>3</expr>,      <expr>1</expr>,      <expr>1</expr>}</block></expr>,
    <expr><block>{<expr>"continue"</expr>,        <expr>0</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"decl"</expr>,            <expr>1</expr>,      <expr>1</expr>,      <expr>1</expr>}</block></expr>,
    <expr><block>{<expr>"pcdelta"</expr>,         <expr>1</expr>,      <expr>0</expr>,      <expr>1</expr>}</block></expr>,
    <expr><block>{<expr>"assignop"</expr>,        <expr>0</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"cond"</expr>,            <expr>1</expr>,      <expr>0</expr>,      <expr>1</expr>}</block></expr>,
    <expr><block>{<expr>"brace"</expr>,           <expr>1</expr>,      <expr>0</expr>,      <expr>1</expr>}</block></expr>,
    <expr><block>{<expr>"hidden"</expr>,          <expr>0</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"pcbase"</expr>,          <expr>1</expr>,      <expr>0</expr>,     <expr>-1</expr>}</block></expr>,
    <expr><block>{<expr>"label"</expr>,           <expr>1</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"labelbrace"</expr>,      <expr>1</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"endbrace"</expr>,        <expr>0</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"break2label"</expr>,     <expr>1</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"cont2label"</expr>,      <expr>1</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"switch"</expr>,          <expr>2</expr>,      <expr>0</expr>,      <expr>1</expr>}</block></expr>,
    <expr><block>{<expr>"funcdef"</expr>,         <expr>1</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"catch"</expr>,           <expr>1</expr>,      <expr>0</expr>,      <expr>1</expr>}</block></expr>,
    <expr><block>{<expr>"extended"</expr>,       <expr>-1</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"newline"</expr>,         <expr>0</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"setline"</expr>,         <expr>1</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>"xdelta"</expr>,          <expr>0</expr>,      <expr>0</expr>,      <expr>0</expr>}</block></expr>,
}</block></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>intN</name></type>
<name>AllocSrcNote</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>intN</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSArenaPool</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>index</name> = <call><name>CG_NOTE_COUNT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>((<name>uintN</name>)<name>index</name> &amp; <call><name>CG_NOTE_MASK</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>pool</name> = <name><name>cg</name>-&gt;<name>notePool</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> = <call><name>SRCNOTE_SIZE</name><argument_list>(<argument><expr><call><name>CG_NOTE_MASK</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* Allocate the first note array lazily; leave noteMask alone. */</comment>
            <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_CAST</name><argument_list>(<argument><expr><call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jssrcnote</name> *</expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/* Grow by doubling note array size; update noteMask on success. */</comment>
            <expr_stmt><expr><call><name>JS_ARENA_GROW_CAST</name><argument_list>(<argument><expr><call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jssrcnote</name> *</expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>CG_NOTE_MASK</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = (<call><name>CG_NOTE_MASK</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> &lt;&lt; 1) | 1</expr>;</expr_stmt></then></if>
        }</block></else></if>
        <if>if <condition>(<expr>!<call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>CG_NOTE_COUNT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>index</name> + 1</expr>;</expr_stmt>
    <return>return <expr><name>index</name></expr>;</return>
}</block></function>

<function><type><name>intN</name></type>
<name>js_NewSrcNote</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSSrcNoteType</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>intN</name></type> <name>index</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>delta</name></decl>, <decl><type ref="prev"/><name>xdelta</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Claim a note slot in CG_NOTES(cg) by growing it if necessary and then
     * incrementing CG_NOTE_COUNT(cg).
     */</comment>
    <expr_stmt><expr><name>index</name> = <call><name>AllocSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
    <expr_stmt><expr><name>sn</name> = &amp;<call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>

    <comment type="block">/*
     * Compute delta from the last annotated bytecode's offset.  If it's too
     * big to fit in sn, allocate one or more xdelta notes and reset sn.
     */</comment>
    <expr_stmt><expr><name>offset</name> = <call><name>CG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>delta</name> = <name>offset</name> - <call><name>CG_LAST_NOTE_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CG_LAST_NOTE_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = <name>offset</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>delta</name> &gt;= <name>SN_DELTA_LIMIT</name></expr>)</condition><then> <block>{
        <do>do <block>{
            <expr_stmt><expr><name>xdelta</name> = <call><name>JS_MIN</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><name>SN_XDELTA_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SN_MAKE_XDELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>xdelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>delta</name> -= <name>xdelta</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>index</name> = <call><name>AllocSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
                <return>return <expr>-1</expr>;</return></then></if>
            <expr_stmt><expr><name>sn</name> = &amp;<call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
        }</block> while <condition>(<expr><name>delta</name> &gt;= <name>SN_DELTA_LIMIT</name></expr>)</condition>;</do>
    }</block></then></if>

    <comment type="block">/*
     * Initialize type and delta, then allocate the minimum number of notes
     * needed for type's arity.  Usually, we won't need more, but if an offset
     * does take two bytes, js_SetSrcNoteOffset will grow CG_NOTES(cg).
     */</comment>
    <expr_stmt><expr><call><name>SN_MAKE_NOTE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>n</name> = (<name>intN</name>)<name><name>js_SrcNoteSpec</name><index>[<expr><name>type</name></expr>]</index></name>.<name>arity</name></expr>;</init> <condition><expr><name>n</name> &gt; 0</expr>;</condition> <incr><expr><name>n</name>--</expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
    }</block></for>
    <return>return <expr><name>index</name></expr>;</return>
}</block></function>

<function><type><name>intN</name></type>
<name>js_NewSrcNote2</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSSrcNoteType</name></type> <name>type</name></decl></param>,
               <param><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>intN</name></type> <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>index</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>index</name> &gt;= 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
    }</block></then></if>
    <return>return <expr><name>index</name></expr>;</return>
}</block></function>

<function><type><name>intN</name></type>
<name>js_NewSrcNote3</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSSrcNoteType</name></type> <name>type</name></decl></param>,
               <param><decl><type><name>ptrdiff_t</name></type> <name>offset1</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>offset2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>intN</name></type> <name>index</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>index</name> = <call><name>js_NewSrcNote</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>index</name> &gt;= 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>offset1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
        <if>if <condition>(<expr>!<call><name>js_SetSrcNoteOffset</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>offset2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
    }</block></then></if>
    <return>return <expr><name>index</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>GrowSrcNotes</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSArenaPool</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

    <comment type="block">/* Grow by doubling note array size; update noteMask on success. */</comment>
    <expr_stmt><expr><name>pool</name> = <name><name>cg</name>-&gt;<name>notePool</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> = <call><name>SRCNOTE_SIZE</name><argument_list>(<argument><expr><call><name>CG_NOTE_MASK</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ARENA_GROW_CAST</name><argument_list>(<argument><expr><call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jssrcnote</name> *</expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>CG_NOTE_MASK</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> = (<call><name>CG_NOTE_MASK</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> &lt;&lt; 1) | 1</expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>jssrcnote</name> *</type>
<name>js_AddToSrcNoteDelta</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl></param>,
                     <param><decl><type><name>ptrdiff_t</name></type> <name>delta</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>base</name></decl>, <decl><type ref="prev"/><name>limit</name></decl>, <decl><type ref="prev"/><name>newdelta</name></decl>, <decl><type ref="prev"/><name>diff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>intN</name></type> <name>index</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Called only from OptimizeSpanDeps and js_FinishTakingSrcNotes to add to
     * main script note deltas, and only by a small positive amount.
     */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>current</name></name> == &amp;<name><name>cg</name>-&gt;<name/></name>main</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>unsigned</name>) <name>delta</name> &lt; (<name>unsigned</name>) <name>SN_XDELTA_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>base</name> = <call><name>SN_DELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> = <call><name>SN_IS_XDELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> ? <name>SN_XDELTA_LIMIT</name> : <name>SN_DELTA_LIMIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newdelta</name> = <name>base</name> + <name>delta</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>newdelta</name> &lt; <name>limit</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SN_SET_DELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>newdelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>index</name> = <name>sn</name> - <name><name>cg</name>-&gt;<name/></name>main.<name>notes</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name><name>cg</name>-&gt;<name/></name>main.<name>noteCount</name> &amp; <name><name>cg</name>-&gt;<name/></name>main.<name>noteMask</name>) == 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>GrowSrcNotes</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>
            <expr_stmt><expr><name>sn</name> = <name><name>cg</name>-&gt;<name/></name>main.<name>notes</name> + <name>index</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>diff</name> = <name><name>cg</name>-&gt;<name/></name>main.<name>noteCount</name> - <name>index</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cg</name>-&gt;<name/></name>main.<name>noteCount</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>sn</name> + 1</expr></argument>, <argument><expr><name>sn</name></expr></argument>, <argument><expr><call><name>SRCNOTE_SIZE</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SN_MAKE_XDELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sn</name>++</expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>sn</name></expr>;</return>
}</block></function>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>uintN</argument>)</argument_list></macro>
<macro><name>js_SrcNoteLength</name><argument_list>(<argument>jssrcnote *sn</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>arity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>base</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>arity</name> = (<name>intN</name>)<name><name>js_SrcNoteSpec</name><index>[<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name>.<name>arity</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>base</name> = <name>sn</name>++</expr>;</init> <condition><expr><name>arity</name></expr>;</condition> <incr><expr><name>sn</name>++</expr>, <expr><name>arity</name>--</expr></incr>) <block>{
        <if>if <condition>(<expr>*<name>sn</name> &amp; <name>SN_3BYTE_OFFSET_FLAG</name></expr>)</condition><then>
            <expr_stmt><expr><name>sn</name> += 2</expr>;</expr_stmt></then></if>
    }</block></for>
    <return>return <expr><name>sn</name> - <name>base</name></expr>;</return>
}</block>

<macro><name>JS_FRIEND_API</name><argument_list>(<argument>ptrdiff_t</argument>)</argument_list></macro>
<macro><name>js_GetSrcNoteOffset</name><argument_list>(<argument>jssrcnote *sn</argument>, <argument>uintN which</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* Find the offset numbered which (i.e., skip exactly which offsets). */</comment>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> != <name>SRC_XDELTA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>which</name> &lt; <name><name>js_SrcNoteSpec</name><index>[<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name>.<name>arity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>sn</name>++</expr>;</init> <condition><expr><name>which</name></expr>;</condition> <incr><expr><name>sn</name>++</expr>, <expr><name>which</name>--</expr></incr>) <block>{
        <if>if <condition>(<expr>*<name>sn</name> &amp; <name>SN_3BYTE_OFFSET_FLAG</name></expr>)</condition><then>
            <expr_stmt><expr><name>sn</name> += 2</expr>;</expr_stmt></then></if>
    }</block></for>
    <if>if <condition>(<expr>*<name>sn</name> &amp; <name>SN_3BYTE_OFFSET_FLAG</name></expr>)</condition><then> <block>{
        <return>return <expr><call>(<name>ptrdiff_t</name>)<argument_list>(<argument><expr>(<call>(<name>uint32</name>)<argument_list>(<argument><expr><name><name>sn</name><index>[<expr>0</expr>]</index></name> &amp; <name>SN_3BYTE_OFFSET_MASK</name></expr></argument>)</argument_list></call> &lt;&lt; 16)
                           | (<name><name>sn</name><index>[<expr>1</expr>]</index></name> &lt;&lt; 8)
                           | <name><name>sn</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr>(<name>ptrdiff_t</name>)*<name>sn</name></expr>;</return>
}</block>

<function><type><name>JSBool</name></type>
<name>js_SetSrcNoteOffset</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>index</name></decl></param>,
                    <param><decl><type><name>uintN</name></type> <name>which</name></decl></param>, <param><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>diff</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>jsuword</name>)<name>offset</name> &gt;= <call>(<name>jsuword</name>)<argument_list>(<argument><expr>(<name>ptrdiff_t</name>)<name>SN_3BYTE_OFFSET_FLAG</name> &lt;&lt; 16</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ReportStatementTooLarge</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Find the offset numbered which (i.e., skip exactly which offsets). */</comment>
    <expr_stmt><expr><name>sn</name> = &amp;<call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call> != <name>SRC_XDELTA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>which</name> &lt; <name><name>js_SrcNoteSpec</name><index>[<expr><call><name>SN_TYPE</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>]</index></name>.<name>arity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>sn</name>++</expr>;</init> <condition><expr><name>which</name></expr>;</condition> <incr><expr><name>sn</name>++</expr>, <expr><name>which</name>--</expr></incr>) <block>{
        <if>if <condition>(<expr>*<name>sn</name> &amp; <name>SN_3BYTE_OFFSET_FLAG</name></expr>)</condition><then>
            <expr_stmt><expr><name>sn</name> += 2</expr>;</expr_stmt></then></if>
    }</block></for>

    <comment type="block">/* See if the new offset requires three bytes. */</comment>
    <if>if <condition>(<expr><name>offset</name> &gt; (<name>ptrdiff_t</name>)<name>SN_3BYTE_OFFSET_MASK</name></expr>)</condition><then> <block>{
        <comment type="block">/* Maybe this offset was already set to a three-byte value. */</comment>
        <if>if <condition>(<expr>!(*<name>sn</name> &amp; <name>SN_3BYTE_OFFSET_FLAG</name>)</expr>)</condition><then> <block>{
            <comment type="block">/* Losing, need to insert another two bytes for this offset. */</comment>
            <expr_stmt><expr><name>index</name> = <call><name>PTRDIFF</name><argument_list>(<argument><expr><name>sn</name></expr></argument>, <argument><expr><call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jssrcnote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Simultaneously test to see if the source note array must grow to
             * accomodate either the first or second byte of additional storage
             * required by this 3-byte offset.
             */</comment>
            <if>if <condition>(<expr>((<call><name>CG_NOTE_COUNT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> + 1) &amp; <call><name>CG_NOTE_MASK</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call>) &lt;= 1</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>GrowSrcNotes</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>sn</name> = <call><name>CG_NOTES</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> + <name>index</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>CG_NOTE_COUNT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> += 2</expr>;</expr_stmt>

            <expr_stmt><expr><name>diff</name> = <call><name>CG_NOTE_COUNT</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - (<name>index</name> + 3)</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>diff</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>diff</name> &gt; 0</expr>)</condition><then>
                <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>sn</name> + 3</expr></argument>, <argument><expr><name>sn</name> + 1</expr></argument>, <argument><expr><call><name>SRCNOTE_SIZE</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
        <expr_stmt><expr>*<name>sn</name>++ = <call>(<name>jssrcnote</name>)<argument_list>(<argument><expr><name>SN_3BYTE_OFFSET_FLAG</name> | (<name>offset</name> &gt;&gt; 16)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>sn</name>++ = <call>(<name>jssrcnote</name>)<argument_list>(<argument><expr><name>offset</name> &gt;&gt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>sn</name> = (<name>jssrcnote</name>)<name>offset</name></expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_notme</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_srcnotesize</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_srcnotesize</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBINS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name><name>hist</name><index>[<expr><name>NBINS</name></expr>]</index></name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>DumpSrcNoteSizeHist</name><parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>fp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr>"/tmp/srcnotes.hist"</expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>fp</name></expr>)</condition><then>
            <return>return;</return></then></if>
        <expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"SrcNote size histogram:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NBINS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>"%4u %4u "</expr></argument>, <argument><expr><call><name>JS_BIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>hist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>n</name> = (<name>int</name>) <call><name>JS_HOWMANY</name><argument_list>(<argument><expr><name><name>hist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>n</name> &gt; 0</expr>;</condition> <incr><expr>--<name>n</name></expr></incr>)
            <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'*'</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\n'</expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Fill in the storage at notes with prolog and main srcnotes; the space at
 * notes was allocated using the CG_COUNT_FINAL_SRCNOTES macro from jsemit.h.
 * SO DON'T CHANGE THIS FUNCTION WITHOUT AT LEAST CHECKING WHETHER jsemit.h's
 * CG_COUNT_FINAL_SRCNOTES MACRO NEEDS CORRESPONDING CHANGES!
 */</comment>
<function><type><name>JSBool</name></type>
<name>js_FinishTakingSrcNotes</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>jssrcnote</name> *</type><name>notes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>uintN</name></type> <name>prologCount</name></decl>, <decl><type ref="prev"/><name>mainCount</name></decl>, <decl><type ref="prev"/><name>totalCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>delta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jssrcnote</name> *</type><name>sn</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>cg</name>-&gt;<name>current</name></name> == &amp;<name><name>cg</name>-&gt;<name/></name>main</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>prologCount</name> = <name><name>cg</name>-&gt;<name>prolog</name>.<name>noteCount</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>prologCount</name> &amp;&amp; <name><name>cg</name>-&gt;<name>prolog</name>.<name>currentLine</name></name> != <name><name>cg</name>-&gt;<name>firstLine</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>CG_SWITCH_TO_PROLOG</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>js_NewSrcNote2</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>SRC_SETLINE</name></expr></argument>, <argument><expr>(<name>ptrdiff_t</name>)<name><name>cg</name>-&gt;<name>firstLine</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
        <expr_stmt><expr><name>prologCount</name> = <name><name>cg</name>-&gt;<name>prolog</name>.<name>noteCount</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CG_SWITCH_TO_MAIN</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * Either no prolog srcnotes, or no line number change over prolog.
         * We don't need a SRC_SETLINE, but we may need to adjust the offset
         * of the first main note, by adding to its delta and possibly even
         * prepending SRC_XDELTA notes to it to account for prolog bytecodes
         * that came at and after the last annotated bytecode.
         */</comment>
        <expr_stmt><expr><name>offset</name> = <call><name>CG_PROLOG_OFFSET</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call> - <name><name>cg</name>-&gt;<name>prolog</name>.<name>lastNoteOffset</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>offset</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>offset</name> &gt; 0 &amp;&amp; <name><name>cg</name>-&gt;<name/></name>main.<name>noteCount</name> != 0</expr>)</condition><then> <block>{
            <comment type="block">/* NB: Use as much of the first main note's delta as we can. */</comment>
            <expr_stmt><expr><name>sn</name> = <name><name>cg</name>-&gt;<name/></name>main.<name>notes</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>delta</name> = <call><name>SN_IS_XDELTA</name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call>
                    ? <name>SN_XDELTA_MASK</name> - (*<name>sn</name> &amp; <name>SN_XDELTA_MASK</name>)
                    : <name>SN_DELTA_MASK</name> - (*<name>sn</name> &amp; <name>SN_DELTA_MASK</name>)</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>offset</name> &lt; <name>delta</name></expr>)</condition><then>
                <expr_stmt><expr><name>delta</name> = <name>offset</name></expr>;</expr_stmt></then></if>
            <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
                <if>if <condition>(<expr>!<call><name>js_AddToSrcNoteDelta</name><argument_list>(<argument><expr><name>cx</name></expr></argument>, <argument><expr><name>cg</name></expr></argument>, <argument><expr><name>sn</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name>JS_FALSE</name></expr>;</return></then></if>
                <expr_stmt><expr><name>offset</name> -= <name>delta</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>offset</name> == 0</expr>)</condition><then>
                    <break>break;</break></then></if>
                <expr_stmt><expr><name>delta</name> = <call><name>JS_MIN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SN_XDELTA_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>sn</name> = <name><name>cg</name>-&gt;<name/></name>main.<name>notes</name></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
    }</block></else></if>

    <expr_stmt><expr><name>mainCount</name> = <name><name>cg</name>-&gt;<name/></name>main.<name>noteCount</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>totalCount</name> = <name>prologCount</name> + <name>mainCount</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>prologCount</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>notes</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name>prolog</name>.<name>notes</name></name></expr></argument>, <argument><expr><call><name>SRCNOTE_SIZE</name><argument_list>(<argument><expr><name>prologCount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>notes</name> + <name>prologCount</name></expr></argument>, <argument><expr><name><name>cg</name>-&gt;<name/></name>main.<name>notes</name></expr></argument>, <argument><expr><call><name>SRCNOTE_SIZE</name><argument_list>(<argument><expr><name>mainCount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SN_MAKE_TERMINATOR</name><argument_list>(<argument><expr>&amp;<name><name>notes</name><index>[<expr><name>totalCount</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_notme</name></cpp:ifdef>
  <block>{ <decl_stmt><decl><type><name>int</name></type> <name>bin</name> <init>= <expr><call><name>JS_CeilingLog2</name><argument_list>(<argument><expr><name>totalCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>bin</name> &gt;= <name>NBINS</name></expr>)</condition><then>
        <expr_stmt><expr><name>bin</name> = <name>NBINS</name> - 1</expr>;</expr_stmt></then></if>
    <expr_stmt><expr>++<name><name>hist</name><index>[<expr><name>bin</name></expr>]</index></name></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>JSBool</name></type>
<name>NewTryNote</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSTryNoteKind</name></type> <name>kind</name></decl></param>,
           <param><decl><type><name>uintN</name></type> <name>stackDepth</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>start</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>end</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTryNode</name> *</type><name>tryNode</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>uintN</name>)(<name>uint16</name>)<name>stackDepth</name> == <name>stackDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>start</name> &lt;= <name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>size_t</name>)(<name>uint32</name>)<name>start</name> == <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>(<name>size_t</name>)(<name>uint32</name>)<name>end</name> == <name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JS_ARENA_ALLOCATE_TYPE</name><argument_list>(<argument><expr><name>tryNode</name></expr></argument>, <argument><expr><name>JSTryNode</name></expr></argument>, <argument><expr>&amp;<name><name>cx</name>-&gt;<name>tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>tryNode</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>js_ReportOutOfScriptQuota</name><argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>JS_FALSE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>tryNode</name>-&gt;<name>note</name>.<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tryNode</name>-&gt;<name>note</name>.<name>stackDepth</name></name> = (<name>uint16</name>)<name>stackDepth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tryNode</name>-&gt;<name>note</name>.<name>start</name></name> = (<name>uint32</name>)<name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tryNode</name>-&gt;<name>note</name>.<name>length</name></name> = <call>(<name>uint32</name>)<argument_list>(<argument><expr><name>end</name> - <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tryNode</name>-&gt;<name>prev</name></name> = <name><name>cg</name>-&gt;<name>lastTryNode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>lastTryNode</name></name> = <name>tryNode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name>-&gt;<name>ntrynotes</name></name>++</expr>;</expr_stmt>
    <return>return <expr><name>JS_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>js_FinishTakingTryNotes</name><parameter_list>(<param><decl><type><name>JSCodeGenerator</name> *</type><name>cg</name></decl></param>, <param><decl><type><name>JSTryNoteArray</name> *</type><name>array</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSTryNode</name> *</type><name>tryNode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTryNote</name> *</type><name>tn</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>array</name>-&gt;<name>length</name></name> &gt; 0 &amp;&amp; <name><name>array</name>-&gt;<name>length</name></name> == <name><name>cg</name>-&gt;<name>ntrynotes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tn</name> = <name><name>array</name>-&gt;<name>vector</name></name> + <name><name>array</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tryNode</name> = <name><name>cg</name>-&gt;<name>lastTryNode</name></name></expr>;</expr_stmt>
    <do>do <block>{
        <expr_stmt><expr>*--<name>tn</name> = <name><name>tryNode</name>-&gt;<name>note</name></name></expr>;</expr_stmt>
    }</block> while <condition>(<expr>(<name>tryNode</name> = <name><name>tryNode</name>-&gt;<name>prev</name></name>) != <name>NULL</name></expr>)</condition>;</do>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>tn</name> == <name><name>array</name>-&gt;<name>vector</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Find the index of the given object for code generator.
 *
 * Since the emitter refers to each parsed object only once, for the index we
 * use the number of already indexes objects. We also add the object to a list
 * to convert the list to a fixed-size array when we complete code generation,
 * see FinishParsedObjects bellow.
 *
 * Most of the objects go to JSCodeGenerator.objectList but for regexp we use
 * a separated JSCodeGenerator.regexpList. In this way the emitted index can
 * be directly used to store and fetch a reference to a cloned RegExp object
 * that shares the same JSRegExp private data created for the object literal
 * in pob. We need clones to hold lastIndex and other direct properties that
 * should not be shared among threads sharing a precompiled function or
 * script.
 *
 * If the code being compiled is function code, allocate a reserved slot in
 * the cloned function object that shares its precompiled script with other
 * cloned function objects and with the compiler-created clone-parent. There
 * are script-&gt;nregexps such reserved slots in each function object cloned
 * from fun-&gt;object. NB: during compilation, funobj slots must never be
 * allocated, because js_AllocSlot could hand out one of the slots that should
 * be given to a regexp clone.
 *
 * If the code being compiled is global code, the cloned regexp are stored in
 * fp-&gt;vars slot after cg-&gt;treeContext.ngvars and to protect regexp slots from
 * GC we set fp-&gt;nvars to ngvars + nregexps.
 *
 * The slots initially contain undefined or null. We populate them lazily when
 * JSOP_REGEXP is executed for the first time.
 *
 * Why clone regexp objects?  ECMA specifies that when a regular expression
 * literal is scanned, a RegExp object is created.  In the spec, compilation
 * and execution happen indivisibly, but in this implementation and many of
 * its embeddings, code is precompiled early and re-executed in multiple
 * threads, or using multiple global objects, or both, for efficiency.
 *
 * In such cases, naively following ECMA leads to wrongful sharing of RegExp
 * objects, which makes for collisions on the lastIndex property (especially
 * for global regexps) and on any ad-hoc properties.  Also, __proto__ and
 * __parent__ refer to the pre-compilation prototype and global objects, a
 * pigeon-hole problem for instanceof tests.
 */</comment>
<function><type><specifier>static</specifier> <name>uintN</name></type>
<name>IndexParsedObject</name><parameter_list>(<param><decl><type><name>JSParsedObjectBox</name> *</type><name>pob</name></decl></param>, <param><decl><type><name>JSEmittedObjectList</name> *</type><name>list</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!<name><name>pob</name>-&gt;<name>emitLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pob</name>-&gt;<name>emitLink</name></name> = <name><name>list</name>-&gt;<name>lastPob</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name>-&gt;<name>lastPob</name></name> = <name>pob</name></expr>;</expr_stmt>
    <return>return <expr><name><name>list</name>-&gt;<name>length</name></name>++</expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>FinishParsedObjects</name><parameter_list>(<param><decl><type><name>JSEmittedObjectList</name> *</type><name>emittedList</name></decl></param>, <param><decl><type><name>JSObjectArray</name> *</type><name>array</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>JSObject</name> **</type><name>cursor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSParsedObjectBox</name> *</type><name>pob</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>emittedList</name>-&gt;<name>length</name></name> &lt;= <name>INDEX_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name><name>emittedList</name>-&gt;<name>length</name></name> == <name><name>array</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cursor</name> = <name><name>array</name>-&gt;<name>vector</name></name> + <name><name>array</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pob</name> = <name><name>emittedList</name>-&gt;<name>lastPob</name></name></expr>;</expr_stmt>
    <do>do <block>{
        <expr_stmt><expr>--<name>cursor</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr>!*<name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>cursor</name> = <name><name>pob</name>-&gt;<name>object</name></name></expr>;</expr_stmt>
    }</block> while <condition>(<expr>(<name>pob</name> = <name><name>pob</name>-&gt;<name>emitLink</name></name>) != <name>NULL</name></expr>)</condition>;</do>
    <expr_stmt><expr><call><name>JS_ASSERT</name><argument_list>(<argument><expr><name>cursor</name> == <name><name>array</name>-&gt;<name>vector</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
