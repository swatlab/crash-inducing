<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="00859c5a407bd8f47a4fc68e44f91218e28ab06b.h"><comment type="block">/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=78:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Communicator client code, released
 * March 31, 1998.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>jscntxt_h___</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>jscntxt_h___</name></cpp:macro></cpp:define>
<comment type="block">/*
 * JS execution context.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsarena.h"</cpp:file></cpp:include> <comment type="block">/* Added by JSIFY */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsclist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jslong.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsatom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsconfig.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsdhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsinterp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsobj.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsprvtd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jspubtd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsregexp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jsutil.h"</cpp:file></cpp:include>

<macro><name>JS_BEGIN_EXTERN_C</name></macro>

<comment type="block">/*
 * js_GetSrcNote cache to avoid O(n^2) growth in finding a source note for a
 * given pc in a script.
 */</comment>
<typedef>typedef <type><struct>struct <name>JSGSNCache</name> <block>{
    <decl_stmt><decl><type><name>JSScript</name>        *</type><name>script</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSDHashTable</name></type>    <name>table</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GSNMETER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>hits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>misses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>fills</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>clears</name></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GSN_CACHE_METER</name><parameter_list>(<param><type><name>cache</name></type></param>,<param><type><name>cnt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(++(cache)-&gt;cnt)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>GSN_CACHE_METER</name><parameter_list>(<param><type><name>cache</name></type></param>,<param><type><name>cnt</name></type></param>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>JSGSNCache</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GSN_CACHE_CLEAR</name><parameter_list>(<param><type><name>cache</name></type></param>)</parameter_list></cpp:macro>                                                \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        (cache)-&gt;script = NULL;                                               \
        if ((cache)-&gt;table.ops) {                                             \
            JS_DHashTableFinish(&amp;(cache)-&gt;table);                             \
            (cache)-&gt;table.ops = NULL;                                        \
        }                                                                     \
        GSN_CACHE_METER(cache, clears);                                       \
    JS_END_MACRO</cpp:value></cpp:define>

<comment type="block">/* These helper macros take a cx as parameter and operate on its GSN cache. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CLEAR_GSN_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>GSN_CACHE_CLEAR(&amp;JS_GSN_CACHE(cx))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_METER_GSN_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>cnt</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>GSN_CACHE_METER(&amp;JS_GSN_CACHE(cx), cnt)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>

<comment type="block">/*
 * Structure uniquely representing a thread.  It holds thread-private data
 * that can be accessed without a global lock.
 */</comment>
<struct>struct <name>JSThread</name> <block>{
    <comment type="block">/* Linked list of all contexts active on this thread. */</comment>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>contextList</name></decl>;</decl_stmt>

    <comment type="block">/* Opaque thread-id, from NSPR's PR_GetCurrentThread(). */</comment>
    <decl_stmt><decl><type><name>jsword</name></type>              <name>id</name></decl>;</decl_stmt>

    <comment type="block">/* Thread-local gc free lists array. */</comment>
    <decl_stmt><decl><type><name>JSGCThing</name>           *</type><name><name>gcFreeLists</name><index>[<expr><name>GC_NUM_FREELISTS</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * Thread-local version of JSRuntime.gcMallocBytes to avoid taking
     * locks on each JS_malloc.
     */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcMallocBytes</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Store the GSN cache in struct JSThread, not struct JSContext, both to
     * save space and to simplify cleanup in js_GC.  Any embedding (Firefox
     * or another Gecko application) that uses many contexts per thread is
     * unlikely to interleave js_GetSrcNote-intensive loops in the decompiler
     * among two or more contexts running script in one thread.
     */</comment>
    <decl_stmt><decl><type><name>JSGSNCache</name></type>          <name>gsnCache</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GSN_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((cx)-&gt;thread-&gt;gsnCache)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>void</name> <name>JS_DLL_CALLBACK</name></type>
<name>js_ThreadDestructorCB</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_SetContextThread</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ClearContextThread</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSThread</name> *</type>
<name>js_GetCurrentThread</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_THREADSAFE */</comment>

<typedef>typedef <type><enum>enum <name>JSDestroyContextMode</name> <block>{
    <decl><name>JSDCM_NO_GC</name></decl>,
    <decl><name>JSDCM_MAYBE_GC</name></decl>,
    <decl><name>JSDCM_FORCE_GC</name></decl>,
    <decl><name>JSDCM_NEW_FAILED</name></decl>
}</block></enum></type> <name>JSDestroyContextMode</name>;</typedef>

<typedef>typedef <type><enum>enum <name>JSRuntimeState</name> <block>{
    <decl><name>JSRTS_DOWN</name></decl>,
    <decl><name>JSRTS_LAUNCHING</name></decl>,
    <decl><name>JSRTS_UP</name></decl>,
    <decl><name>JSRTS_LANDING</name></decl>
}</block></enum></type> <name>JSRuntimeState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>JSPropertyTreeEntry</name> <block>{
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type>     <name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScopeProperty</name>     *</type><name>child</name></decl>;</decl_stmt>
}</block></struct></type> <name>JSPropertyTreeEntry</name>;</typedef>

<comment type="block">/*
 * Forward declaration for opaque JSRuntime.nativeIteratorStates.
 */</comment>
<typedef>typedef <type>struct <name>JSNativeIteratorState</name></type> <name>JSNativeIteratorState</name>;</typedef>

<struct>struct <name>JSRuntime</name> <block>{
    <comment type="block">/* Runtime state, synchronized by the stateChange/gcLock condvar/lock. */</comment>
    <decl_stmt><decl><type><name>JSRuntimeState</name></type>      <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* Context create/destroy callback. */</comment>
    <decl_stmt><decl><type><name>JSContextCallback</name></type>   <name>cxCallback</name></decl>;</decl_stmt>

    <comment type="block">/* Garbage collector state, used by jsgc.c. */</comment>
    <decl_stmt><decl><type><name>JSGCChunkInfo</name>       *</type><name>gcChunkList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaList</name></type>       <name><name>gcArenaList</name><index>[<expr><name>GC_NUM_FREELISTS</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSDHashTable</name></type>        <name>gcRootsHash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSDHashTable</name>        *</type><name>gcLocksHash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>gcKeepAtoms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcLastBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcMaxBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcMaxMallocBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcLevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcNumber</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTracer</name>            *</type><name>gcMarkingTracer</name></decl>;</decl_stmt>

    <comment type="block">/*
     * NB: do not pack another flag here by claiming gcPadding unless the new
     * flag is written only by the GC thread.  Atomic updates to packed bytes
     * are not guaranteed, so stores issued by one thread may be lost due to
     * unsynchronized read-modify-write cycles on other threads.
     */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>gcPoke</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>gcRunning</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>              <name>gcPadding</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GC_ZEAL</name></cpp:ifdef>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>gcZeal</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>JSGCCallback</name></type>        <name>gcCallback</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>gcMallocBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSGCArenaInfo</name>       *</type><name>gcUntracedArenaStackTop</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>gcTraceLaterCount</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Table for tracking iterators to ensure that we close iterator's state
     * before finalizing the iterable object.
     */</comment>
    <decl_stmt><decl><type><name>JSPtrTable</name></type>          <name>gcIteratorTable</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The trace operation and its data argument to trace embedding-specific
     * GC roots.
     */</comment>
    <decl_stmt><decl><type><name>JSTraceDataOp</name></type>       <name>gcExtraRootsTraceOp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>                *</type><name>gcExtraRootsData</name></decl>;</decl_stmt>

    <comment type="block">/* Random number generator state, used by jsmath.c. */</comment>
    <decl_stmt><decl><type><name>JSBool</name></type>              <name>rngInitialized</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>               <name>rngMultiplier</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>               <name>rngAddend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>               <name>rngMask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>               <name>rngSeed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name></type>            <name>rngDscale</name></decl>;</decl_stmt>

    <comment type="block">/* Well-known numbers held for use by this runtime's contexts. */</comment>
    <decl_stmt><decl><type><name>jsdouble</name>            *</type><name>jsNaN</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name>            *</type><name>jsNegativeInfinity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsdouble</name>            *</type><name>jsPositiveInfinity</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSLock</name>              *</type><name>deflatedStringCacheLock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>JSHashTable</name>         *</type><name>deflatedStringCache</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>deflatedStringCacheBytes</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Empty and unit-length strings held for use by this runtime's contexts.
     * The unitStrings array and its elements are created on demand.
     */</comment>
    <decl_stmt><decl><type><name>JSString</name>            *</type><name>emptyString</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSString</name>            **</type><name>unitStrings</name></decl>;</decl_stmt>

    <comment type="block">/* List of active contexts sharing this runtime; protected by gcLock. */</comment>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>contextList</name></decl>;</decl_stmt>

    <comment type="block">/* Per runtime debug hooks -- see jsprvtd.h and jsdbgapi.h. */</comment>
    <decl_stmt><decl><type><name>JSDebugHooks</name></type>        <name>globalDebugHooks</name></decl>;</decl_stmt>

    <comment type="block">/* More debugging state, see jsdbgapi.c. */</comment>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>trapList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>watchPointList</name></decl>;</decl_stmt>

    <comment type="block">/* Client opaque pointer */</comment>
    <decl_stmt><decl><type><name>void</name>                *</type><name>data</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <comment type="block">/* These combine to interlock the GC and new requests. */</comment>
    <decl_stmt><decl><type><name>PRLock</name>              *</type><name>gcLock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRCondVar</name>           *</type><name>gcDone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRCondVar</name>           *</type><name>requestDone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>requestCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSThread</name>            *</type><name>gcThread</name></decl>;</decl_stmt>

    <comment type="block">/* Lock and owning thread pointer for JS_LOCK_RUNTIME. */</comment>
    <decl_stmt><decl><type><name>PRLock</name>              *</type><name>rtLock</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>jsword</name></type>              <name>rtLockOwner</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Used to synchronize down/up state change; protected by gcLock. */</comment>
    <decl_stmt><decl><type><name>PRCondVar</name>           *</type><name>stateChange</name></decl>;</decl_stmt>

    <comment type="block">/* Used to serialize cycle checks when setting __proto__ or __parent__. */</comment>
    <decl_stmt><decl><type><name>PRLock</name>              *</type><name>setSlotLock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRCondVar</name>           *</type><name>setSlotDone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBool</name></type>              <name>setSlotBusy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScope</name>             *</type><name>setSlotScope</name></decl>;</decl_stmt>  <comment type="block">/* deadlock avoidance, see jslock.c */</comment>

    <comment type="block">/*
     * State for sharing single-threaded scopes, once a second thread tries to
     * lock a scope.  The scopeSharingDone condvar is protected by rt-&gt;gcLock,
     * to minimize number of locks taken in JS_EndRequest.
     *
     * The scopeSharingTodo linked list is likewise "global" per runtime, not
     * one-list-per-context, to conserve space over all contexts, optimizing
     * for the likely case that scopes become shared rarely, and among a very
     * small set of threads (contexts).
     */</comment>
    <decl_stmt><decl><type><name>PRCondVar</name>           *</type><name>scopeSharingDone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScope</name>             *</type><name>scopeSharingTodo</name></decl>;</decl_stmt>

<comment type="block">/*
 * Magic terminator for the rt-&gt;scopeSharingTodo linked list, threaded through
 * scope-&gt;u.link.  This hack allows us to test whether a scope is on the list
 * by asking whether scope-&gt;u.link is non-null.  We use a large, likely bogus
 * pointer here to distinguish this value from any valid u.count (small int)
 * value.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_SCOPE_SHARING_TODO</name></cpp:macro>   <cpp:value>((JSScope *) 0xfeedbeef)</cpp:value></cpp:define>

    <comment type="block">/*
     * Lock serializing trapList and watchPointList accesses, and count of all
     * mutations to trapList and watchPointList made by debugger threads.  To
     * keep the code simple, we define debuggerMutations for the thread-unsafe
     * case too.
     */</comment>
    <decl_stmt><decl><type><name>PRLock</name>              *</type><name>debuggerLock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JS_THREADSAFE */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>debuggerMutations</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Check property accessibility for objects of arbitrary class.  Used at
     * present to check f.caller accessibility for any function object f.
     */</comment>
    <decl_stmt><decl><type><name>JSCheckAccessOp</name></type>     <name>checkObjectAccess</name></decl>;</decl_stmt>

    <comment type="block">/* Security principals serialization support. */</comment>
    <decl_stmt><decl><type><name>JSPrincipalsTranscoder</name></type> <name>principalsTranscoder</name></decl>;</decl_stmt>

    <comment type="block">/* Optional hook to find principals for an object in this runtime. */</comment>
    <decl_stmt><decl><type><name>JSObjectPrincipalsFinder</name></type> <name>findObjectPrincipals</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Shared scope property tree, and arena-pool for allocating its nodes.
     * The propertyRemovals counter is incremented for every js_ClearScope,
     * and for each js_RemoveScopeProperty that frees a slot in an object.
     * See js_NativeGet and js_NativeSet in jsobj.c.
     */</comment>
    <decl_stmt><decl><type><name>JSDHashTable</name></type>        <name>propertyTreeHash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScopeProperty</name>     *</type><name>propertyFreeList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSArenaPool</name></type>         <name>propertyArenaPool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>               <name>propertyRemovals</name></decl>;</decl_stmt>

    <comment type="block">/* Script filename table. */</comment>
    <decl_stmt><decl><type>struct <name>JSHashTable</name>  *</type><name>scriptFilenameTable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>scriptFilenamePrefixes</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>PRLock</name>              *</type><name>scriptFilenameTableLock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Number localization, used by jsnum.c */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>          *</type><name>thousandsSeparator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>          *</type><name>decimalSeparator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>          *</type><name>numGrouping</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Weak references to lazily-created, well-known XML singletons.
     *
     * NB: Singleton objects must be carefully disconnected from the rest of
     * the object graph usually associated with a JSContext's global object,
     * including the set of standard class objects.  See jsxml.c for details.
     */</comment>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>anynameObject</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>functionNamespaceObject</name></decl>;</decl_stmt>

    <comment type="block">/*
     * A helper list for the GC, so it can mark native iterator states. See
     * js_TraceNativeIteratorStates for details.
     */</comment>
    <decl_stmt><decl><type><name>JSNativeIteratorState</name> *</type><name>nativeIteratorStates</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifndef>
    <comment type="block">/*
     * For thread-unsafe embeddings, the GSN cache lives in the runtime and
     * not each context, since we expect it to be filled once when decompiling
     * a longer script, then hit repeatedly as js_GetSrcNote is called during
     * the decompiler activation that filled it.
     */</comment>
    <decl_stmt><decl><type><name>JSGSNCache</name></type>          <name>gsnCache</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_GSN_CACHE</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((cx)-&gt;runtime-&gt;gsnCache)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Literal table maintained by jsatom.c functions. */</comment>
    <decl_stmt><decl><type><name>JSAtomState</name></type>         <name>atomState</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Various metering fields are defined at the end of JSRuntime. In this
     * way there is no need to recompile all the code that refers to other
     * fields of JSRuntime after enabling the corresponding metering macro.
     */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG</name> || <name>defined</name> <name>JS_DUMP_PROPTREE_STATS</name></expr></cpp:if>
    <comment type="block">/* Function invocation metering. */</comment>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>inlineCalls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>nativeCalls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>nonInlineCalls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>constructs</name></decl>;</decl_stmt>

    <comment type="block">/* Scope lock and property metering. */</comment>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>claimAttempts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>claimedScopes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>deadContexts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>deadlocksAvoided</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveScopes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>sharedScopes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalScopes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveScopeProps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveScopePropsPreSweep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalScopeProps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>livePropTreeNodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>duplicatePropTreeNodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalPropTreeNodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>propTreeKidsChunks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>middleDeleteFixups</name></decl>;</decl_stmt>

    <comment type="block">/* String instrumentation. */</comment>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveStrings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalStrings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>liveDependentStrings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>totalDependentStrings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>badUndependStrings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>              <name>lengthSum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>              <name>lengthSquaredSum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>              <name>strdepLengthSum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>              <name>strdepLengthSquaredSum</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DEBUG || JS_DUMP_PROPTREE_STATS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_SCOPE_DEPTH_METER</name></cpp:ifdef>
    <comment type="block">/*
     * Stats on runtime prototype chain lookups and scope chain depths, i.e.,
     * counts of objects traversed on a chain until the wanted id is found.
     */</comment>
    <decl_stmt><decl><type><name>JSBasicStats</name></type>        <name>protoLookupDepthStats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBasicStats</name></type>        <name>scopeSearchDepthStats</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Stats on compile-time host environment and lexical scope chain lengths
     * (maximum depths).
     */</comment>
    <decl_stmt><decl><type><name>JSBasicStats</name></type>        <name>hostenvScopeDepthStats</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSBasicStats</name></type>        <name>lexicalScopeDepthStats</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_GCMETER</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSGCStats</name></type>           <name>gcStats</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_METER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>JS_ATOMIC_INCREMENT(&amp;(rt)-&gt;which)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_UNMETER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>JS_ATOMIC_DECREMENT(&amp;(rt)-&gt;which)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_METER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro></cpp:define>    <comment type="block">/* nothing */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_RUNTIME_UNMETER</name><parameter_list>(<param><type><name>rt</name></type></param>, <param><type><name>which</name></type></param>)</parameter_list></cpp:macro></cpp:define>  <comment type="block">/* nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_KEEP_ATOMS</name><parameter_list>(<param><type><name>rt</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>JS_ATOMIC_INCREMENT(&amp;(rt)-&gt;gcKeepAtoms);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_UNKEEP_ATOMS</name><parameter_list>(<param><type><name>rt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>JS_ATOMIC_DECREMENT(&amp;(rt)-&gt;gcKeepAtoms);</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_ARGUMENT_FORMATTER_DEFINED</name></cpp:ifdef>
<comment type="block">/*
 * Linked list mapping format strings for JS_{Convert,Push}Arguments{,VA} to
 * formatter functions.  Elements are sorted in non-increasing format string
 * length order.
 */</comment>
<struct>struct <name>JSArgumentFormatMap</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>          *</type><name>format</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSArgumentFormatter</name></type> <name>formatter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSArgumentFormatMap</name> *</type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>JSStackHeader</name> <block>{
    <decl_stmt><decl><type><name>uintN</name></type>               <name>nslots</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackHeader</name>       *</type><name>down</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_STACK_SEGMENT</name><parameter_list>(<param><type><name>sh</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>((jsval *)(sh) + 2)</cpp:value></cpp:define>

<comment type="block">/*
 * Key and entry types for the JSContext.resolvingTable hash table, typedef'd
 * here because all consumers need to see these declarations (and not just the
 * typedef names, as would be the case for an opaque pointer-to-typedef'd-type
 * declaration), along with cx-&gt;resolvingTable.
 */</comment>
<typedef>typedef <type><struct>struct <name>JSResolvingKey</name> <block>{
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsid</name></type>                <name>id</name></decl>;</decl_stmt>
}</block></struct></type> <name>JSResolvingKey</name>;</typedef>

<typedef>typedef <type><struct>struct <name>JSResolvingEntry</name> <block>{
    <decl_stmt><decl><type><name>JSDHashEntryHdr</name></type>     <name>hdr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSResolvingKey</name></type>      <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>JSResolvingEntry</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSRESFLAG_LOOKUP</name></cpp:macro>        <cpp:value>0x1</cpp:value></cpp:define>     <comment type="block">/* resolving id from lookup */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSRESFLAG_WATCH</name></cpp:macro>         <cpp:value>0x2</cpp:value></cpp:define>     <comment type="block">/* resolving id from watch */</comment>

<typedef>typedef <type>struct <name>JSLocalRootChunk</name></type> <name>JSLocalRootChunk</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSLRS_CHUNK_SHIFT</name></cpp:macro>       <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSLRS_CHUNK_SIZE</name></cpp:macro>        <cpp:value>JS_BIT(JSLRS_CHUNK_SHIFT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSLRS_CHUNK_MASK</name></cpp:macro>        <cpp:value>JS_BITMASK(JSLRS_CHUNK_SHIFT)</cpp:value></cpp:define>

<struct>struct <name>JSLocalRootChunk</name> <block>{
    <decl_stmt><decl><type><name>jsval</name></type>               <name><name>roots</name><index>[<expr><name>JSLRS_CHUNK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSLocalRootChunk</name>    *</type><name>down</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><struct>struct <name>JSLocalRootStack</name> <block>{
    <decl_stmt><decl><type><name>uint32</name></type>              <name>scopeMark</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>rootCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSLocalRootChunk</name>    *</type><name>topChunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSLocalRootChunk</name></type>    <name>firstChunk</name></decl>;</decl_stmt>
}</block></struct></type> <name>JSLocalRootStack</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSLRS_NULL_MARK</name></cpp:macro> <cpp:value>((uint32) -1)</cpp:value></cpp:define>

<comment type="block">/*
 * Macros to push/pop JSTempValueRooter instances to context-linked stack of
 * temporary GC roots. If you need to protect a result value that flows out of
 * a C function across several layers of other functions, use the
 * js_LeaveLocalRootScopeWithResult internal API (see further below) instead.
 *
 * The macros also provide a simple way to get a single rooted pointer via
 * JS_PUSH_TEMP_ROOT_&lt;KIND&gt;(cx, NULL, &amp;tvr). Then &amp;tvr.u.&lt;kind&gt; gives the
 * necessary pointer.
 *
 * JSTempValueRooter.count defines the type of the rooted value referenced by
 * JSTempValueRooter.u union of type JSTempValueUnion. When count is positive
 * or zero, u.array points to a vector of jsvals. Otherwise it must be one of
 * the following constants:
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSTVU_SINGLE</name></cpp:macro>        <cpp:value>(-1)</cpp:value></cpp:define>    <comment type="block">/* u.value or u.&lt;gcthing&gt; is single jsval
                                       or GC-thing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSTVU_TRACE</name></cpp:macro>         <cpp:value>(-2)</cpp:value></cpp:define>    <comment type="block">/* u.trace is a hook to trace a custom
                                     * structure */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSTVU_SPROP</name></cpp:macro>         <cpp:value>(-3)</cpp:value></cpp:define>    <comment type="block">/* u.sprop roots property tree node */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSTVU_WEAK_ROOTS</name></cpp:macro>    <cpp:value>(-4)</cpp:value></cpp:define>    <comment type="block">/* u.weakRoots points to saved weak roots */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSTVU_PARSE_CONTEXT</name></cpp:macro> <cpp:value>(-5)</cpp:value></cpp:define>    <comment type="block">/* u.parseContext roots JSParseContext* */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSTVU_SCRIPT</name></cpp:macro>        <cpp:value>(-6)</cpp:value></cpp:define>    <comment type="block">/* u.script roots JSScript* */</comment>

<comment type="block">/*
 * Here single JSTVU_SINGLE covers both jsval and pointers to any GC-thing via
 * reinterpreting the thing as JSVAL_OBJECT. It works because the GC-thing is
 * aligned on a 0 mod 8 boundary, and object has the 0 jsval tag. So any
 * GC-thing may be tagged as if it were an object and untagged, if it's then
 * used only as an opaque pointer until discriminated by other means than tag
 * bits. This is how, for example, js_GetGCThingTraceKind uses its |thing|
 * parameter -- it consults GC-thing flags stored separately from the thing to
 * decide the kind of thing.
 *
 * The following checks that this type-punning is possible.
 */</comment>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSTempValueUnion</name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>jsval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JS_STATIC_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JSTempValueUnion</name></expr></argument>)</argument_list></sizeof> == <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_COMMON</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>x</name></type></param>,<param><type><name>tvr</name></type></param>,<param><type><name>cnt</name></type></param>,<param><type><name>kind</name></type></param>)</parameter_list></cpp:macro>                           \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        JS_ASSERT((cx)-&gt;tempValueRooters != (tvr));                           \
        (tvr)-&gt;count = (cnt);                                                 \
        (tvr)-&gt;u.kind = (x);                                                  \
        (tvr)-&gt;down = (cx)-&gt;tempValueRooters;                                 \
        (cx)-&gt;tempValueRooters = (tvr);                                       \
    JS_END_MACRO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_POP_TEMP_ROOT</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                                              \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        JS_ASSERT((cx)-&gt;tempValueRooters == (tvr));                           \
        (cx)-&gt;tempValueRooters = (tvr)-&gt;down;                                 \
    JS_END_MACRO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>cnt</name></type></param>,<param><type><name>arr</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                                     \
    <cpp:value>JS_BEGIN_MACRO                                                            \
        JS_ASSERT((int)(cnt) &gt;= 0);                                           \
        JS_PUSH_TEMP_ROOT_COMMON(cx, arr, tvr, (ptrdiff_t) (cnt), array);     \
    JS_END_MACRO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_SINGLE_TEMP_ROOT</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>val</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                                  \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, val, tvr, JSTVU_SINGLE, value)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_OBJECT</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>obj</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                                  \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, obj, tvr, JSTVU_SINGLE, object)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_STRING</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>str</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                                  \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, str, tvr, JSTVU_SINGLE, string)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_FUNCTION</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>fun</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                                \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, fun, tvr, JSTVU_SINGLE, function)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_QNAME</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>qn</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                                    \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, qn, tvr, JSTVU_SINGLE, qname)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_XML</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>xml_</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                                    \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, xml_, tvr, JSTVU_SINGLE, xml)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_TRACE</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>trace_</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                                \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, trace_, tvr, JSTVU_TRACE, trace)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_SPROP</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>sprop_</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                                \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, sprop_, tvr, JSTVU_SPROP, sprop)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_WEAK_COPY</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>weakRoots_</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                        \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, weakRoots_, tvr, JSTVU_WEAK_ROOTS, weakRoots)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_PARSE_CONTEXT</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>pc</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                            \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, pc, tvr, JSTVU_PARSE_CONTEXT, parseContext)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_PUSH_TEMP_ROOT_SCRIPT</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>script_</name></type></param>,<param><type><name>tvr</name></type></param>)</parameter_list></cpp:macro>                              \
    <cpp:value>JS_PUSH_TEMP_ROOT_COMMON(cx, script_, tvr, JSTVU_SCRIPT, script)</cpp:value></cpp:define>

<struct>struct <name>JSContext</name> <block>{
    <comment type="block">/* JSRuntime contextList linkage. */</comment>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>links</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Operation count. It is declared early in the structure as a frequently
     * accessed field.
     */</comment>
    <decl_stmt><decl><type><name>int32</name></type>               <name>operationCount</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_XML_SUPPORT</name></expr></cpp:if>
    <comment type="block">/*
     * Bit-set formed from binary exponentials of the XML_* tiny-ids defined
     * for boolean settings in jsxml.c, plus an XSF_CACHE_VALID bit.  Together
     * these act as a cache of the boolean XML.ignore* and XML.prettyPrinting
     * property values associated with this context's global object.
     */</comment>
    <decl_stmt><decl><type><name>uint8</name></type>               <name>xmlSettingFlags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8</name></type>               <name>padding</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>uint16</name></type>              <name>padding</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Runtime version control identifier. */</comment>
    <decl_stmt><decl><type><name>uint16</name></type>              <name>version</name></decl>;</decl_stmt>

    <comment type="block">/* Per-context options. */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>options</name></decl>;</decl_stmt>            <comment type="block">/* see jsapi.h for JSOPTION_* */</comment>

    <comment type="block">/* Locale specific callbacks for string conversion. */</comment>
    <decl_stmt><decl><type><name>JSLocaleCallbacks</name>   *</type><name>localeCallbacks</name></decl>;</decl_stmt>

    <comment type="block">/*
     * cx-&gt;resolvingTable is non-null and non-empty if we are initializing
     * standard classes lazily, or if we are otherwise recursing indirectly
     * from js_LookupProperty through a JSClass.resolve hook.  It is used to
     * limit runaway recursion (see jsapi.c and jsobj.c).
     */</comment>
    <decl_stmt><decl><type><name>JSDHashTable</name>        *</type><name>resolvingTable</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_HAS_LVALUE_RETURN</name></expr></cpp:if>
    <comment type="block">/*
     * Secondary return value from native method called on the left-hand side
     * of an assignment operator.  The native should store the object in which
     * to set a property in *rval, and return the property's id expressed as a
     * jsval by calling JS_SetCallReturnValue2(cx, idval).
     */</comment>
    <decl_stmt><decl><type><name>jsval</name></type>               <name>rval2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>rval2set</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * True if generating an error, to prevent runaway recursion.
     * NB: generatingError packs with rval2set, #if JS_HAS_LVALUE_RETURN;
     * with insideGCMarkCallback and with throwing below.
     */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>generatingError</name></decl>;</decl_stmt>

    <comment type="block">/* Flag to indicate that we run inside gcCallback(cx, JSGC_MARK_END). */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>insideGCMarkCallback</name></decl>;</decl_stmt>

    <comment type="block">/* Exception state -- the exception member is a GC root by definition. */</comment>
    <decl_stmt><decl><type><name>JSPackedBool</name></type>        <name>throwing</name></decl>;</decl_stmt>           <comment type="block">/* is there a pending exception? */</comment>
    <decl_stmt><decl><type><name>jsval</name></type>               <name>exception</name></decl>;</decl_stmt>          <comment type="block">/* most-recently-thrown exception */</comment>

    <comment type="block">/* Limit pointer for checking native stack consumption during recursion. */</comment>
    <decl_stmt><decl><type><name>jsuword</name></type>             <name>stackLimit</name></decl>;</decl_stmt>

    <comment type="block">/* Quota on the size of arenas used to compile and execute scripts. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>scriptStackQuota</name></decl>;</decl_stmt>

    <comment type="block">/* Data shared by threads in an address space. */</comment>
    <decl_stmt><decl><type><name>JSRuntime</name>           *</type><name>runtime</name></decl>;</decl_stmt>

    <comment type="block">/* Stack arena pool and frame pointer register. */</comment>
    <decl_stmt><decl><type><name>JSArenaPool</name></type>         <name>stackPool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSStackFrame</name>        *</type><name>fp</name></decl>;</decl_stmt>

    <comment type="block">/* Temporary arena pool used while compiling and decompiling. */</comment>
    <decl_stmt><decl><type><name>JSArenaPool</name></type>         <name>tempPool</name></decl>;</decl_stmt>

    <comment type="block">/* Top-level object and pointer to top stack frame's scope chain. */</comment>
    <decl_stmt><decl><type><name>JSObject</name>            *</type><name>globalObject</name></decl>;</decl_stmt>

    <comment type="block">/* Storage to root recently allocated GC things and script result. */</comment>
    <decl_stmt><decl><type><name>JSWeakRoots</name></type>         <name>weakRoots</name></decl>;</decl_stmt>

    <comment type="block">/* Regular expression class statics (XXX not shared globally). */</comment>
    <decl_stmt><decl><type><name>JSRegExpStatics</name></type>     <name>regExpStatics</name></decl>;</decl_stmt>

    <comment type="block">/* State for object and array toSource conversion. */</comment>
    <decl_stmt><decl><type><name>JSSharpObjectMap</name></type>    <name>sharpObjectMap</name></decl>;</decl_stmt>

    <comment type="block">/* Argument formatter support for JS_{Convert,Push}Arguments{,VA}. */</comment>
    <decl_stmt><decl><type><name>JSArgumentFormatMap</name> *</type><name>argumentFormatMap</name></decl>;</decl_stmt>

    <comment type="block">/* Last message string and trace file for debugging. */</comment>
    <decl_stmt><decl><type><name>char</name>                *</type><name>lastMessage</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>void</name>                *</type><name>tracefp</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Per-context optional error reporter. */</comment>
    <decl_stmt><decl><type><name>JSErrorReporter</name></type>     <name>errorReporter</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Flag indicating that the operation callback is set. When the flag is 0
     * but operationCallback is not null, operationCallback stores the branch
     * callback.
     */</comment>
    <expr_stmt><expr><name>uint32</name>              <name>operationCallbackIsSet</name> :    1</expr>;</expr_stmt>
    <expr_stmt><expr><name>uint32</name>              <name>operationLimit</name>         :    31</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>JSOperationCallback</name></type> <name>operationCallback</name></decl>;</decl_stmt>

    <comment type="block">/* Interpreter activation count. */</comment>
    <decl_stmt><decl><type><name>uintN</name></type>               <name>interpLevel</name></decl>;</decl_stmt>

    <comment type="block">/* Client opaque pointer */</comment>
    <decl_stmt><decl><type><name>void</name>                *</type><name>data</name></decl>;</decl_stmt>

    <comment type="block">/* GC and thread-safe state. */</comment>
    <decl_stmt><decl><type><name>JSStackFrame</name>        *</type><name>dormantFrameChain</name></decl>;</decl_stmt> <comment type="block">/* dormant stack frame to scan */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>JSThread</name>            *</type><name>thread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>requestDepth</name></decl>;</decl_stmt>
    <comment type="block">/* Same as requestDepth but ignoring JS_SuspendRequest/JS_ResumeRequest */</comment>
    <decl_stmt><decl><type><name>jsrefcount</name></type>          <name>outstandingRequests</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSScope</name>             *</type><name>scopeToShare</name></decl>;</decl_stmt>      <comment type="block">/* weak reference, see jslock.c */</comment>
    <decl_stmt><decl><type><name>JSScope</name>             *</type><name>lockedSealedScope</name></decl>;</decl_stmt> <comment type="block">/* weak ref, for low-cost sealed
                                               scope locking */</comment>
    <decl_stmt><decl><type><name>JSCList</name></type>             <name>threadLinks</name></decl>;</decl_stmt>        <comment type="block">/* JSThread contextList linkage */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CX_FROM_THREAD_LINKS</name><parameter_list>(<param><type><name>tl</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>((JSContext *)((char *)(tl) - offsetof(JSContext, threadLinks)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* PDL of stack headers describing stack slots not rooted by argv, etc. */</comment>
    <decl_stmt><decl><type><name>JSStackHeader</name>       *</type><name>stackHeaders</name></decl>;</decl_stmt>

    <comment type="block">/* Optional stack of heap-allocated scoped local GC roots. */</comment>
    <decl_stmt><decl><type><name>JSLocalRootStack</name>    *</type><name>localRootStack</name></decl>;</decl_stmt>

    <comment type="block">/* Stack of thread-stack-allocated temporary GC roots. */</comment>
    <decl_stmt><decl><type><name>JSTempValueRooter</name>   *</type><name>tempValueRooters</name></decl>;</decl_stmt>

    <comment type="block">/* Debug hooks associated with the current context. */</comment>
    <decl_stmt><decl><type><name>JSDebugHooks</name>        *</type><name>debugHooks</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JS_THREADSAFE</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_THREAD_ID</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>((cx)-&gt;thread ? (cx)-&gt;thread-&gt;id : 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<comment type="block">/* FIXME(bug 332648): Move this into a public header. */</comment>
<decl_stmt><decl><type><name>class</name></type> <name>JSAutoTempValueRooter</name>
<block>{
  <label><name>public</name>:</label>
    <macro><name>JSAutoTempValueRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>size_t len</argument>, <argument>jsval *vec</argument>)</argument_list></macro>
        : <macro><name>mContext</name><argument_list>(<argument>cx</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><call><name>JS_PUSH_TEMP_ROOT</name><argument_list>(<argument><expr><name>mContext</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr>&amp;<name>mTvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <macro><name>JSAutoTempValueRooter</name><argument_list>(<argument>JSContext *cx</argument>, <argument>jsval v</argument>)</argument_list></macro>
        : <macro><name>mContext</name><argument_list>(<argument>cx</argument>)</argument_list></macro> <block>{
        <expr_stmt><expr><call><name>JS_PUSH_SINGLE_TEMP_ROOT</name><argument_list>(<argument><expr><name>mContext</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>mTvr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>

    <expr_stmt><expr>~<macro><name>JSAutoTempValueRooter</name><argument_list>()</argument_list></macro> <block>{
        <expr><call><name>JS_POP_TEMP_ROOT</name><argument_list>(<argument><expr><name>mContext</name></expr></argument>, <argument><expr>&amp;<name>mTvr</name></expr></argument>)</argument_list></call></expr>;
    }</block>

  <name>private</name>:
    static <name>void</name> *<name>operator</name> <call><name>new</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <function_decl><type><specifier>static</specifier> <name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>, <param><decl><type><name>size_t</name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>JSContext</name> *</type><name>mContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JSTempValueRooter</name></type> <name>mTvr</name></decl>;</decl_stmt>
}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Slightly more readable macros for testing per-context option settings (also
 * to hide bitset implementation detail).
 *
 * JSOPTION_XML must be handled specially in order to propagate from compile-
 * to run-time (from cx-&gt;options to script-&gt;version/cx-&gt;version).  To do that,
 * we copy JSOPTION_XML from cx-&gt;options into cx-&gt;version as JSVERSION_HAS_XML
 * whenever options are set, and preserve this XML flag across version number
 * changes done via the JS_SetVersion API.
 *
 * But when executing a script or scripted function, the interpreter changes
 * cx-&gt;version, including the XML flag, to script-&gt;version.  Thus JSOPTION_XML
 * is a compile-time option that causes a run-time version change during each
 * activation of the compiled script.  That version change has the effect of
 * changing JS_HAS_XML_OPTION, so that any compiling done via eval enables XML
 * support.  If an XML-enabled script or function calls a non-XML function,
 * the flag bit will be cleared during the callee's activation.
 *
 * Note that JS_SetVersion API calls never pass JSVERSION_HAS_XML or'd into
 * that API's version parameter.
 *
 * Note also that script-&gt;version must contain this XML option flag in order
 * for XDR'ed scripts to serialize and deserialize with that option preserved
 * for detection at run-time.  We can't copy other compile-time options into
 * script-&gt;version because that would break backward compatibility (certain
 * other options, e.g. JSOPTION_VAROBJFIX, are analogous to JSOPTION_XML).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>option</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>(((cx)-&gt;options &amp; (option)) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_STRICT_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>JS_HAS_OPTION(cx, JSOPTION_STRICT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_WERROR_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>JS_HAS_OPTION(cx, JSOPTION_WERROR)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_COMPILE_N_GO_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>JS_HAS_OPTION(cx, JSOPTION_COMPILE_N_GO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_ATLINE_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>JS_HAS_OPTION(cx, JSOPTION_ATLINE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSVERSION_MASK</name></cpp:macro>                  <cpp:value>0x0FFF</cpp:value></cpp:define>  <comment type="block">/* see JSVersion in jspubtd.h */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSVERSION_HAS_XML</name></cpp:macro>               <cpp:value>0x1000</cpp:value></cpp:define>  <comment type="block">/* flag induced by XML option */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSVERSION_NUMBER</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>((JSVersion)((cx)-&gt;version &amp;          \
                                                     JSVERSION_MASK))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_HAS_XML_OPTION</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro>           <cpp:value>((cx)-&gt;version &amp; JSVERSION_HAS_XML || \
                                         JSVERSION_NUMBER(cx) &gt;= JSVERSION_1_6)</cpp:value></cpp:define>

<comment type="block">/*
 * Initialize a library-wide thread private data index, and remember that it
 * has already been done, so that it happens only once ever.  Returns true on
 * success.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_InitThreadPrivateIndex</name><parameter_list>(<param><function_decl><type><name>void</name></type> (<name>JS_DLL_CALLBACK</name> *<name>ptr</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Common subroutine of JS_SetVersion and js_SetVersion, to update per-context
 * data that depends on version.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_OnVersionChange</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Unlike the JS_SetVersion API, this function stores JSVERSION_HAS_XML and
 * any future non-version-number flags induced by compiler options.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_SetVersion</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSVersion</name></type> <name>version</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Create and destroy functions for JSContext, which is manually allocated
 * and exclusively owned.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSContext</name> *</type>
<name>js_NewContext</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>stackChunkSize</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_DestroyContext</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSDestroyContextMode</name></type> <name>mode</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Return true if cx points to a context in rt-&gt;contextList, else return false.
 * NB: the caller (see jslock.c:ClaimScope) must hold rt-&gt;gcLock.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ValidContextPointer</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * If unlocked, acquire and release rt-&gt;gcLock around *iterp update; otherwise
 * the caller must be holding rt-&gt;gcLock.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSContext</name> *</type>
<name>js_ContextIterator</name><parameter_list>(<param><decl><type><name>JSRuntime</name> *</type><name>rt</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>unlocked</name></decl></param>, <param><decl><type><name>JSContext</name> **</type><name>iterp</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * JSClass.resolve and watchpoint recursion damping machinery.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_StartResolving</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSResolvingKey</name> *</type><name>key</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>flag</name></decl></param>,
                  <param><decl><type><name>JSResolvingEntry</name> **</type><name>entryp</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_StopResolving</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSResolvingKey</name> *</type><name>key</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>flag</name></decl></param>,
                 <param><decl><type><name>JSResolvingEntry</name> *</type><name>entry</name></decl></param>, <param><decl><type><name>uint32</name></type> <name>generation</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Local root set management.
 *
 * NB: the jsval parameters below may be properly tagged jsvals, or GC-thing
 * pointers cast to (jsval).  This relies on JSObject's tag being zero, but
 * on the up side it lets us push int-jsval-encoded scopeMark values on the
 * local root stack.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_EnterLocalRootScope</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_LeaveLocalRootScope</name><parameter_list>(<param><type><name>cx</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>js_LeaveLocalRootScopeWithResult(cx, JSVAL_NULL)</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_LeaveLocalRootScopeWithResult</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>rval</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ForgetLocalRoot</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>int</name></type>
<name>js_PushLocalRoot</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSLocalRootStack</name> *</type><name>lrs</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_TraceLocalRoots</name><parameter_list>(<param><decl><type><name>JSTracer</name> *</type><name>trc</name></decl></param>, <param><decl><type><name>JSLocalRootStack</name> *</type><name>lrs</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report an exception, which is currently realized as a printf-style format
 * string and its arguments.
 */</comment>
<typedef>typedef <type><enum>enum <name>JSErrNum</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_DEF</name><parameter_list>(<param><type><name>name</name></type></param>, <param><type><name>number</name></type></param>, <param><type><name>count</name></type></param>, <param><type><name>exception</name></type></param>, <param><type><name>format</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>name = number,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"js.msg"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MSG_DEF</name></cpp:undef>
    <decl><name>JSErr_Limit</name></decl>
}</block></enum></type> <name>JSErrNum</name>;</typedef>

<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>JSErrorFormatString</name> *</type>
<name>js_GetErrorMessage</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>userRef</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>locale</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>va_start</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportErrorVA</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportErrorNumberVA</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><name>JSErrorCallback</name></type> <name>callback</name></decl></param>,
                       <param><decl><type><name>void</name> *</type><name>userRef</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                       <param><decl><type><name>JSBool</name></type> <name>charArgs</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ExpandErrorArguments</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>JSErrorCallback</name></type> <name>callback</name></decl></param>,
                        <param><decl><type><name>void</name> *</type><name>userRef</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                        <param><decl><type><name>char</name> **</type><name>message</name></decl></param>, <param><decl><type><name>JSErrorReport</name> *</type><name>reportp</name></decl></param>,
                        <param><decl><type><name>JSBool</name> *</type><name>warningp</name></decl></param>, <param><decl><type><name>JSBool</name></type> <name>charArgs</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportOutOfMemory</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report that cx-&gt;scriptStackQuota is exhausted.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportOutOfScriptQuota</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportOverRecursed</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report an exception using a previously composed JSErrorReport.
 * XXXbe remove from "friend" API
 */</comment>
<extern>extern JS_FRIEND_API(void</extern>)
<expr_stmt><expr><call><name>js_ReportErrorAgain</name><argument_list>(<argument><expr><name>JSContext</name> *<name>cx</name></expr></argument>, <argument><expr>const <name>char</name> *<name>message</name></expr></argument>, <argument><expr><name>JSErrorReport</name> *<name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>extern</specifier> <name>void</name></type>
<name>js_ReportIsNotDefined</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report an attempt to access the property of a null or undefined value (v).
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportIsNullOrUndefined</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>intN</name></type> <name>spindex</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>,
                           <param><decl><type><name>JSString</name> *</type><name>fallback</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report error using js_DecompileValueGenerator(cx, spindex, v, fallback) as
 * the first argument for the error message. If the error message has less
 * then 3 arguments, use null for arg1 or arg2.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ReportValueErrorFlags</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>, <param><decl><type><name>uintN</name></type> <name>flags</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>uintN</name></type> <name>errorNumber</name></decl></param>,
                         <param><decl><type><name>intN</name></type> <name>spindex</name></decl></param>, <param><decl><type><name>jsval</name></type> <name>v</name></decl></param>, <param><decl><type><name>JSString</name> *</type><name>fallback</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg2</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_ReportValueError</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>errorNumber</name></type></param>,<param><type><name>spindex</name></type></param>,<param><type><name>v</name></type></param>,<param><type><name>fallback</name></type></param>)</parameter_list></cpp:macro>                \
    <cpp:value>((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
                                    spindex, v, fallback, NULL, NULL))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_ReportValueError2</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>errorNumber</name></type></param>,<param><type><name>spindex</name></type></param>,<param><type><name>v</name></type></param>,<param><type><name>fallback</name></type></param>,<param><type><name>arg1</name></type></param>)</parameter_list></cpp:macro>          \
    <cpp:value>((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
                                    spindex, v, fallback, arg1, NULL))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>js_ReportValueError3</name><parameter_list>(<param><type><name>cx</name></type></param>,<param><type><name>errorNumber</name></type></param>,<param><type><name>spindex</name></type></param>,<param><type><name>v</name></type></param>,<param><type><name>fallback</name></type></param>,<param><type><name>arg1</name></type></param>,<param><type><name>arg2</name></type></param>)</parameter_list></cpp:macro>     \
    <cpp:value>((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
                                    spindex, v, fallback, arg1, arg2))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>JSErrorFormatString</name></type> <name><name>js_ErrorFormatString</name><index>[<expr><name>JSErr_Limit</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * See JS_SetThreadStackLimit in jsapi.c, where we check that the stack grows
 * in the expected direction.  On Unix-y systems, JS_STACK_GROWTH_DIRECTION is
 * computed on the build host by jscpucfg.c and written into jsautocfg.h.  The
 * macro is hardcoded in jscpucfg.h on Windows and Mac systems (for historical
 * reasons pre-dating autoconf usage).
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>JS_STACK_GROWTH_DIRECTION</name> &gt; 0</expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CHECK_STACK_SIZE</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>lval</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((jsuword)&amp;(lval) &lt; (cx)-&gt;stackLimit)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CHECK_STACK_SIZE</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>lval</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((jsuword)&amp;(lval) &gt; (cx)-&gt;stackLimit)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Update the operation counter according to the given weight and call the
 * operation callback when we reach the operation limit. To make this
 * frequently executed macro faster we decrease the counter from
 * JSContext.operationLimit and compare against zero to check the limit.
 *
 * This macro can run the full GC. Return true if it is OK to continue and
 * false otherwise.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CHECK_OPERATION_LIMIT</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>weight</name></type></param>)</parameter_list></cpp:macro>                                  \
    <cpp:value>(JS_CHECK_OPERATION_WEIGHT(weight),                                       \
     (((cx)-&gt;operationCount -= (weight)) &gt; 0 || js_ResetOperationCount(cx)))</cpp:value></cpp:define>

<comment type="block">/*
 * A version of JS_CHECK_OPERATION_LIMIT that just updates the operation count
 * without calling the operation callback or any other API. This macro resets
 * the count to 0 when it becomes negative to prevent a wrap-around when the
 * macro is called repeatably.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_COUNT_OPERATION</name><parameter_list>(<param><type><name>cx</name></type></param>, <param><type><name>weight</name></type></param>)</parameter_list></cpp:macro>                                        \
    <cpp:value>((void)(JS_CHECK_OPERATION_WEIGHT(weight),                                \
            (cx)-&gt;operationCount = ((cx)-&gt;operationCount &gt; 0)                 \
                                   ? (cx)-&gt;operationCount - (weight)          \
                                   : 0))</cpp:value></cpp:define>

<comment type="block">/*
 * The implementation of the above macros assumes that subtracting weights
 * twice from a positive number does not wrap-around INT32_MIN.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JS_CHECK_OPERATION_WEIGHT</name><parameter_list>(<param><type><name>weight</name></type></param>)</parameter_list></cpp:macro>                                     \
    <cpp:value>(JS_ASSERT((uint32) (weight) &gt; 0),                                        \
     JS_ASSERT((uint32) (weight) &lt; JS_BIT(30)))</cpp:value></cpp:define>

<comment type="block">/* Relative operations weights. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOW_JUMP</name></cpp:macro>                   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOW_ALLOCATION</name></cpp:macro>             <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOW_LOOKUP_PROPERTY</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOW_GET_PROPERTY</name></cpp:macro>           <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOW_SET_PROPERTY</name></cpp:macro>           <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOW_NEW_PROPERTY</name></cpp:macro>           <cpp:value>200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOW_DELETE_PROPERTY</name></cpp:macro>        <cpp:value>30</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOW_ENTER_SHARP</name></cpp:macro>            <cpp:value>JS_OPERATION_WEIGHT_BASE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSOW_SCRIPT_JUMP</name></cpp:macro>            <cpp:value>JS_OPERATION_WEIGHT_BASE</cpp:value></cpp:define>

<comment type="block">/*
 * Reset the operation count and call the operation callback assuming that the
 * operation limit is reached.
 */</comment>
<function_decl><type><specifier>extern</specifier> <name>JSBool</name></type>
<name>js_ResetOperationCount</name><parameter_list>(<param><decl><type><name>JSContext</name> *</type><name>cx</name></decl></param>)</parameter_list>;</function_decl>

<macro><name>JS_END_EXTERN_C</name></macro>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* jscntxt_h___ */</comment>
</unit>
