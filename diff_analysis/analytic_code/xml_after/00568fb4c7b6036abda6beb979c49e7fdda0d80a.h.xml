<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="00568fb4c7b6036abda6beb979c49e7fdda0d80a.h"><comment type="block">/* cairo - a vector graphics library with display and print output
 *
 * Copyright Â© 2004 Red Hat, Inc.
 * Copyright Â© 2005 Red Hat, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it either under the terms of the GNU Lesser General Public
 * License version 2.1 as published by the Free Software Foundation
 * (the "LGPL") or, at your option, under the terms of the Mozilla
 * Public License Version 1.1 (the "MPL"). If you do not alter this
 * notice, a recipient may use your version of this file under either
 * the MPL or the LGPL.
 *
 * You should have received a copy of the LGPL along with this library
 * in the file COPYING-LGPL-2.1; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * You should have received a copy of the MPL along with this library
 * in the file COPYING-MPL-1.1
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
 * OF ANY KIND, either express or implied. See the LGPL or the MPL for
 * the specific language governing rights and limitations.
 *
 * The Original Code is the cairo graphics library.
 *
 * The Initial Developer of the Original Code is Red Hat, Inc.
 *
 * Contributor(s):
 *      Keith Packard &lt;keithp@keithp.com&gt;
 *	Graydon Hoare &lt;graydon@redhat.com&gt;
 *	Carl Worth &lt;cworth@cworth.org&gt;
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CAIRO_CACHE_PRIVATE_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CAIRO_CACHE_PRIVATE_H</name></cpp:macro></cpp:define>

<typedef>typedef <type>struct <name>_cairo_cache</name></type> <name>cairo_cache_t</name>;</typedef>

<comment type="block">/**
 * cairo_cache_entry_t:
 *
 * A #cairo_cache_entry_t contains both a key and a value for
 * cairo_cache_t. User-derived types for cairo_cache_entry_t must
 * have a cairo_cache_entry_t as their first field. For example:
 *
 * 	typedef _my_entry {
 *	    cairo_cache_entry_t base;
 *	    ... Remainder of key and value fields here ..
 *	} my_entry_t;
 *
 * which then allows a pointer to my_entry_t to be passed to any of
 * the cairo_cache functions as follows without requiring a cast:
 *
 *	_cairo_cache_insert (cache, &amp;my_entry-&gt;base, size);
 *
 * IMPORTANT: The caller is responsible for initializing
 * my_entry-&gt;base.hash with a hash code derived from the key.  The
 * essential property of the hash code is that keys_equal must never
 * return %TRUE for two keys that have different hashes. The best hash
 * code will reduce the frequency of two keys with the same code for
 * which keys_equal returns %FALSE.
 *
 * The user must also initialize my_entry-&gt;base.size to indicate
 * the size of the current entry. What units to use for size is
 * entirely up to the caller, (though the same units must be used for
 * the max_size parameter passed to _cairo_cache_create()). If all
 * entries are close to the same size, the simplest thing to do is to
 * just use units of "entries", (eg. set size==1 in all entries and
 * set max_size to the number of entries which you want to be saved
 * in the cache).
 *
 * Which parts of the entry make up the "key" and which part make up
 * the value are entirely up to the caller, (as determined by the
 * computation going into base.hash as well as the keys_equal
 * function). A few of the cairo_cache functions accept an entry which
 * will be used exclusively as a "key", (indicated by a parameter name
 * of key). In these cases, the value-related fields of the entry need
 * not be initialized if so desired.
 **/</comment>
<typedef>typedef <type><struct>struct <name>_cairo_cache_entry</name> <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl>;</decl_stmt>
}</block></struct></type> <name>cairo_cache_entry_t</name>;</typedef>

<typedef>typedef <function_decl><type><name>cairo_bool_t</name></type>
(*<name>cairo_cache_keys_equal_func_t</name>) <parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key_a</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key_b</name></decl></param>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>void</name></type>
(*<name>cairo_cache_callback_func_t</name>) <parameter_list>(<param><decl><type><name>void</name> *</type><name>entry</name></decl></param>,
				<param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list>;</function_decl></typedef>

<function_decl><type><name>cairo_private</name> <name>cairo_cache_t</name> *</type>
<name>_cairo_cache_create</name> <parameter_list>(<param><decl><type><name>cairo_cache_keys_equal_func_t</name></type> <name>keys_equal</name></decl></param>,
		     <param><decl><type><name>cairo_destroy_func_t</name></type>	   <name>entry_destroy</name></decl></param>,
		     <param><decl><type><name>unsigned</name> <name>long</name></type>		   <name>max_size</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>cairo_private</name> <name>void</name></type>
<name>_cairo_cache_destroy</name> <parameter_list>(<param><decl><type><name>cairo_cache_t</name> *</type><name>cache</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>cairo_private</name> <name>void</name></type>
<name>_cairo_cache_freeze</name> <parameter_list>(<param><decl><type><name>cairo_cache_t</name> *</type><name>cache</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>cairo_private</name> <name>void</name></type>
<name>_cairo_cache_thaw</name> <parameter_list>(<param><decl><type><name>cairo_cache_t</name> *</type><name>cache</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>cairo_private</name> <name>cairo_bool_t</name></type>
<name>_cairo_cache_lookup</name> <parameter_list>(<param><decl><type><name>cairo_cache_t</name>	  *</type><name>cache</name></decl></param>,
		     <param><decl><type><name>cairo_cache_entry_t</name>  *</type><name>key</name></decl></param>,
		     <param><decl><type><name>cairo_cache_entry_t</name> **</type><name>entry_return</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>cairo_private</name> <name>cairo_status_t</name></type>
<name>_cairo_cache_insert</name> <parameter_list>(<param><decl><type><name>cairo_cache_t</name>	 *</type><name>cache</name></decl></param>,
		     <param><decl><type><name>cairo_cache_entry_t</name> *</type><name>entry</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>cairo_private</name> <name>void</name></type>
<name>_cairo_cache_foreach</name> <parameter_list>(<param><decl><type><name>cairo_cache_t</name> 	      	 *</type><name>cache</name></decl></param>,
		      <param><decl><type><name>cairo_cache_callback_func_t</name></type> <name>cache_callback</name></decl></param>,
		      <param><decl><type><name>void</name>			 *</type><name>closure</name></decl></param>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
