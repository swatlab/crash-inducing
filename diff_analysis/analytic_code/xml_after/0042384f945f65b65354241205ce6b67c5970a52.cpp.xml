<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="0042384f945f65b65354241205ce6b67c5970a52.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Foundation code.
 *
 * The Initial Developer of the Original Code is Mozilla Foundation.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Stuart Parmenter &lt;stuart@mozilla.com&gt;
 *   Vladimir Vukicevic &lt;vladimir@pobox.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIMemoryReporter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsMemory.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxASurface.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxImageSurface.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cairo.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_WIN32_SURFACE</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxWindowsSurface.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_D2D_SURFACE</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxD2DSurface.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_X11</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxXlibSurface.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_QUARTZ_SURFACE</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxQuartzSurface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxQuartzImageSurface.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_DFB</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxDirectFBSurface.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CAIRO_HAS_QT_SURFACE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>MOZ_WIDGET_QT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxQPainterSurface.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_DDRAW_SURFACE</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxDDrawSurface.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>cairo_user_data_key_t</name></type> <name>gfxasurface_pointer_key</name></decl>;</decl_stmt>

<comment type="line">// Surfaces use refcounting that's tied to the cairo surface refcnt, to avoid</comment>
<comment type="line">// refcount mismatch issues.</comment>
<function><type><name>nsrefcnt</name></type>
<name><name>gfxASurface</name>::<name>AddRef</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mSurfaceValid</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>mFloatingRefs</name></expr>)</condition><then> <block>{
            <comment type="line">// eat a floating ref</comment>
            <expr_stmt><expr><name>mFloatingRefs</name>--</expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>cairo_surface_reference</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <return>return <expr>(<name>nsrefcnt</name>) <call><name>cairo_surface_get_reference_count</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then> <else>else <block>{
        <comment type="line">// the surface isn't valid, but we still need to refcount</comment>
        <comment type="line">// the gfxASurface</comment>
        <return>return <expr>++<name>mFloatingRefs</name></expr>;</return>
    }</block></else></if>
}</block></function>

<function><type><name>nsrefcnt</name></type>
<name><name>gfxASurface</name>::<name>Release</name></name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mSurfaceValid</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mFloatingRefs</name> == 0</expr></argument>, <argument><expr>"gfxASurface::Release with floating refs still hanging around!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Note that there is a destructor set on user data for mSurface,</comment>
        <comment type="line">// which will delete this gfxASurface wrapper when the surface's refcount goes</comment>
        <comment type="line">// out of scope.</comment>
        <decl_stmt><decl><type><name>nsrefcnt</name></type> <name>refcnt</name> <init>= <expr>(<name>nsrefcnt</name>) <call><name>cairo_surface_get_reference_count</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>cairo_surface_destroy</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// |this| may not be valid any more, don't use it!</comment>

        <return>return <expr>--<name>refcnt</name></expr>;</return>
    }</block></then> <else>else <block>{
        <if>if <condition>(<expr>--<name>mFloatingRefs</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr>delete <name>this</name></expr>;</expr_stmt>
            <return>return <expr>0</expr>;</return>
        }</block></then></if>

        <return>return <expr><name>mFloatingRefs</name></expr>;</return>
    }</block></else></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>SurfaceDestroyFunc</name></name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>gfxASurface</name> *</type><name>surf</name> <init>= <expr>(<name>gfxASurface</name>*) <name>data</name></expr></init></decl>;</decl_stmt>
    <comment type="line">// fprintf (stderr, "Deleting wrapper for %p (wrapper: %p)\n", surf-&gt;mSurface, data);</comment>
    <expr_stmt><expr>delete <name>surf</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>gfxASurface</name>*</type>
<name><name>gfxASurface</name>::<name>GetSurfaceWrapper</name></name><parameter_list>(<param><decl><type><name>cairo_surface_t</name> *</type><name>csurf</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<name>gfxASurface</name>*) <call><name>cairo_surface_get_user_data</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>, <argument><expr>&amp;<name>gfxasurface_pointer_key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>SetSurfaceWrapper</name></name><parameter_list>(<param><decl><type><name>cairo_surface_t</name> *</type><name>csurf</name></decl></param>, <param><decl><type><name>gfxASurface</name> *</type><name>asurf</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>cairo_surface_set_user_data</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>, <argument><expr>&amp;<name>gfxasurface_pointer_key</name></expr></argument>, <argument><expr><name>asurf</name></expr></argument>, <argument><expr><name>SurfaceDestroyFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
<name><name>gfxASurface</name>::<name>Wrap</name></name> <parameter_list>(<param><decl><type><name>cairo_surface_t</name> *</type><name>csurf</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>gfxASurface</name> *</type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/* Do we already have a wrapper for this surface? */</comment>
    <expr_stmt><expr><name>result</name> = <call><name>GetSurfaceWrapper</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
        <comment type="line">// fprintf(stderr, "Existing wrapper for %p -&gt; %p\n", csurf, result);</comment>
        <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* No wrapper; figure out the surface type and create it */</comment>
    <decl_stmt><decl><type><name>cairo_surface_type_t</name></type> <name>stype</name> <init>= <expr><call><name>cairo_surface_get_type</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>stype</name> == <name>CAIRO_SURFACE_TYPE_IMAGE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = new <call><name>gfxImageSurface</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_WIN32_SURFACE</name></cpp:ifdef>
    <else>else <if>if <condition>(<expr><name>stype</name> == <name>CAIRO_SURFACE_TYPE_WIN32</name> ||
             <name>stype</name> == <name>CAIRO_SURFACE_TYPE_WIN32_PRINTING</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = new <call><name>gfxWindowsSurface</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_D2D_SURFACE</name></cpp:ifdef>
    <else>else <if>if <condition>(<expr><name>stype</name> == <name>CAIRO_SURFACE_TYPE_D2D</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = new <call><name>gfxD2DSurface</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_X11</name></cpp:ifdef>
    <else>else <if>if <condition>(<expr><name>stype</name> == <name>CAIRO_SURFACE_TYPE_XLIB</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = new <call><name>gfxXlibSurface</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_QUARTZ_SURFACE</name></cpp:ifdef>
    <else>else <if>if <condition>(<expr><name>stype</name> == <name>CAIRO_SURFACE_TYPE_QUARTZ</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = new <call><name>gfxQuartzSurface</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>stype</name> == <name>CAIRO_SURFACE_TYPE_QUARTZ_IMAGE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = new <call><name>gfxQuartzImageSurface</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_DFB</name></cpp:ifdef>
    <else>else <if>if <condition>(<expr><name>stype</name> == <name>CAIRO_SURFACE_TYPE_DIRECTFB</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = new <call><name>gfxDirectFBSurface</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CAIRO_HAS_QT_SURFACE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>MOZ_WIDGET_QT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <else>else <if>if <condition>(<expr><name>stype</name> == <name>CAIRO_SURFACE_TYPE_QT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = new <call><name>gfxQPainterSurface</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_DDRAW_SURFACE</name></cpp:ifdef>
    <else>else <if>if <condition>(<expr><name>stype</name> == <name>CAIRO_SURFACE_TYPE_DDRAW</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>result</name> = new <call><name>gfxDDrawSurface</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <else>else <block>{
        <expr_stmt><expr><name>result</name> = new <call><name>gfxUnknownSurface</name><argument_list>(<argument><expr><name>csurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>

    <comment type="line">// fprintf(stderr, "New wrapper for %p -&gt; %p\n", csurf, result);</comment>

    <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>Init</name></name><parameter_list>(<param><decl><type><name>cairo_surface_t</name>*</type> <name>surface</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>existingSurface</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>cairo_surface_status</name><argument_list>(<argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="line">// the surface has an error on it</comment>
        <expr_stmt><expr><name>mSurfaceValid</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cairo_surface_destroy</name><argument_list>(<argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>SetSurfaceWrapper</name><argument_list>(<argument><expr><name>surface</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>mSurface</name> = <name>surface</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mSurfaceValid</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>existingSurface</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>mFloatingRefs</name> = 0</expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>mFloatingRefs</name> = 1</expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><name><name>gfxASurface</name>::<name>gfxSurfaceType</name></name></type>
<name><name>gfxASurface</name>::<name>GetType</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
    <if>if <condition>(<expr>!<name>mSurfaceValid</name></expr>)</condition><then>
        <return>return <expr>(<name>gfxSurfaceType</name>)-1</expr>;</return></then></if>

    <return>return <expr>(<name>gfxSurfaceType</name>)<call><name>cairo_surface_get_type</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>gfxASurface</name>::<name>gfxContentType</name></name></type>
<name><name>gfxASurface</name>::<name>GetContentType</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
    <if>if <condition>(<expr>!<name>mSurfaceValid</name></expr>)</condition><then>
        <return>return <expr>(<name>gfxContentType</name>)-1</expr>;</return></then></if>

    <return>return <expr>(<name>gfxContentType</name>)<call><name>cairo_surface_get_content</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>SetDeviceOffset</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxPoint</name>&amp;</type> <name>offset</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>cairo_surface_set_device_offset</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>,
                                    <argument><expr><name><name>offset</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>offset</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>gfxPoint</name></type>
<name><name>gfxASurface</name>::<name>GetDeviceOffset</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
    <decl_stmt><decl><type><name>gfxPoint</name></type> <name>pt</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>cairo_surface_get_device_offset</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>, <argument><expr>&amp;<name><name>pt</name>.<name>x</name></name></expr></argument>, <argument><expr>&amp;<name><name>pt</name>.<name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pt</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>Flush</name></name><parameter_list>()</parameter_list> <specifier>const</specifier>
<block>{
    <expr_stmt><expr><call><name>cairo_surface_flush</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>MarkDirty</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>cairo_surface_mark_dirty</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>MarkDirty</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxRect</name>&amp;</type> <name>r</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>cairo_surface_mark_dirty_rectangle</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>,
                                       <argument><expr>(<name>int</name>) <name><name>r</name>.<name>pos</name>.<name>x</name></name></expr></argument>, <argument><expr>(<name>int</name>) <name><name>r</name>.<name>pos</name>.<name>y</name></name></expr></argument>,
                                       <argument><expr>(<name>int</name>) <name><name>r</name>.<name>size</name>.<name>width</name></name></expr></argument>, <argument><expr>(<name>int</name>) <name><name>r</name>.<name>size</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>SetData</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>cairo_user_data_key_t</name> *</type><name>key</name></decl></param>,
                     <param><decl><type><name>void</name> *</type><name>user_data</name></decl></param>,
                     <param><decl><type><name>thebes_destroy_func_t</name></type> <name>destroy</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>cairo_surface_set_user_data</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>user_data</name></expr></argument>, <argument><expr><name>destroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name> *</type>
<name><name>gfxASurface</name>::<name>GetData</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>cairo_user_data_key_t</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>cairo_surface_get_user_data</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>Finish</name></name><parameter_list>()</parameter_list>
<block>{
    <expr_stmt><expr><call><name>cairo_surface_finish</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
<name><name>gfxASurface</name>::<name>CreateSimilarSurface</name></name><parameter_list>(<param><decl><type><name>gfxContentType</name></type> <name>aContent</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>gfxIntSize</name>&amp;</type> <name>aSize</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mSurface</name> || !<name>mSurfaceValid</name></expr>)</condition><then> <block>{
      <return>return <expr><name>nsnull</name></expr>;</return>
    }</block></then></if>
    
    <decl_stmt><decl><type><name>cairo_surface_t</name> *</type><name>surface</name> <init>=
        <expr><call><name>cairo_surface_create_similar</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>, <argument><expr><call><name>cairo_content_t</name><argument_list>(<argument><expr><name>aContent</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name><name>aSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>cairo_surface_status</name><argument_list>(<argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>cairo_surface_destroy</name><argument_list>(<argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>nsnull</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr><call><name>Wrap</name><argument_list>(<argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>cairo_surface_destroy</name><argument_list>(<argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>result</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type>
<name><name>gfxASurface</name>::<name>CairoStatus</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>mSurfaceValid</name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <return>return <expr><call><name>cairo_surface_status</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* static */</comment>
<function><type><name>PRBool</name></type>
<name><name>gfxASurface</name>::<name>CheckSurfaceSize</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxIntSize</name>&amp;</type> <name>sz</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>limit</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>sz</name>.<name>width</name></name> &lt; 0 || <name><name>sz</name>.<name>height</name></name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Surface width or height &lt; 0!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_MACOSX</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="line">// CoreGraphics is limited to images &lt; 32K in *height*, so clamp all surfaces on the Mac to that height</comment>
    <if>if <condition>(<expr><name><name>sz</name>.<name>height</name></name> &gt; <name>SHRT_MAX</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Surface size too large (would overflow)!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// check to make sure we don't overflow a 32-bit</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>tmp</name> <init>= <expr><name><name>sz</name>.<name>width</name></name> * <name><name>sz</name>.<name>height</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>tmp</name> &amp;&amp; <name>tmp</name> / <name><name>sz</name>.<name>height</name></name> != <name><name>sz</name>.<name>width</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Surface size too large (would overflow)!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// always assume 4-byte stride</comment>
    <expr_stmt><expr><name>tmp</name> = <name>tmp</name> * 4</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tmp</name> &amp;&amp; <name>tmp</name> / 4 != <name><name>sz</name>.<name>width</name></name> * <name><name>sz</name>.<name>height</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Surface size too large (would overflow)!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_FALSE</name></expr>;</return>
    }</block></then></if>

    <comment type="line">// reject images with sides bigger than limit</comment>
    <if>if <condition>(<expr><name>limit</name> &amp;&amp;
        (<name><name>sz</name>.<name>width</name></name> &gt; <name>limit</name> || <name><name>sz</name>.<name>height</name></name> &gt; <name>limit</name>)</expr>)</condition><then>
        <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>gfxASurface</name>::<name>BeginPrinting</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aTitle</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsAString</name>&amp;</type> <name>aPrintToFileName</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>gfxASurface</name>::<name>EndPrinting</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>gfxASurface</name>::<name>AbortPrinting</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>gfxASurface</name>::<name>BeginPage</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>gfxASurface</name>::<name>EndPage</name></name><parameter_list>()</parameter_list>
<block>{
    <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name><name>gfxASurface</name>::<name>gfxContentType</name></name></type>
<name><name>gfxASurface</name>::<name>ContentFromFormat</name></name><parameter_list>(<param><decl><type><name>gfxImageFormat</name></type> <name>format</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>format</name></expr>)</condition> <block>{
        <case>case <expr><name>ImageFormatARGB32</name></expr>:
            <return>return <expr><name>CONTENT_COLOR_ALPHA</name></expr>;</return>
        </case><case>case <expr><name>ImageFormatRGB24</name></expr>:
        </case><case>case <expr><name>ImageFormatRGB16_565</name></expr>:
            <return>return <expr><name>CONTENT_COLOR</name></expr>;</return>
        </case><case>case <expr><name>ImageFormatA8</name></expr>:
        </case><case>case <expr><name>ImageFormatA1</name></expr>:
            <return>return <expr><name>CONTENT_ALPHA</name></expr>;</return>

        </case><case>case <expr><name>ImageFormatUnknown</name></expr>:
        </case><default>default:
            <return>return <expr><name>CONTENT_COLOR</name></expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><name><name>gfxASurface</name>::<name>gfxImageFormat</name></name></type>
<name><name>gfxASurface</name>::<name>FormatFromContent</name></name><parameter_list>(<param><decl><type><name><name>gfxASurface</name>::<name>gfxContentType</name></name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
        <case>case <expr><name>CONTENT_COLOR_ALPHA</name></expr>:
            <return>return <expr><name>ImageFormatARGB32</name></expr>;</return>
        </case><case>case <expr><name>CONTENT_ALPHA</name></expr>:
            <return>return <expr><name>ImageFormatA8</name></expr>;</return>
        </case><case>case <expr><name>CONTENT_COLOR</name></expr>:
        </case><default>default:
            <return>return <expr><name>ImageFormatRGB24</name></expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>gfxASurface</name>::<name>BytePerPixelFromFormat</name></name><parameter_list>(<param><decl><type><name>gfxImageFormat</name></type> <name>format</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>format</name></expr>)</condition> <block>{
        <case>case <expr><name>ImageFormatARGB32</name></expr>:
        </case><case>case <expr><name>ImageFormatRGB24</name></expr>:
            <return>return <expr>4</expr>;</return>
        </case><case>case <expr><name>ImageFormatRGB16_565</name></expr>:
            <return>return <expr>2</expr>;</return>
        </case><case>case <expr><name>ImageFormatA8</name></expr>:
            <return>return <expr>1</expr>;</return>
        </case><default>default:
            <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Unknown byte per pixel value for Image format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/** Memory reporting **/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>sSurfaceNamesForSurfaceType</name><index>[]</index></name> <init>= <expr><block>{
    <expr>"gfx/surface/image"</expr>,
    <expr>"gfx/surface/pdf"</expr>,
    <expr>"gfx/surface/ps"</expr>,
    <expr>"gfx/surface/xlib"</expr>,
    <expr>"gfx/surface/xcb"</expr>,
    <expr>"gfx/surface/glitz"</expr>,
    <expr>"gfx/surface/quartz"</expr>,
    <expr>"gfx/surface/win32"</expr>,
    <expr>"gfx/surface/beos"</expr>,
    <expr>"gfx/surface/directfb"</expr>,
    <expr>"gfx/surface/svg"</expr>,
    <expr>"gfx/surface/os2"</expr>,
    <expr>"gfx/surface/win32printing"</expr>,
    <expr>"gfx/surface/quartzimage"</expr>,
    <expr>"gfx/surface/script"</expr>,
    <expr>"gfx/surface/qpainter"</expr>,
    <expr>"gfx/surface/recording"</expr>,
    <expr>"gfx/surface/vg"</expr>,
    <expr>"gfx/surface/gl"</expr>,
    <expr>"gfx/surface/drm"</expr>,
    <expr>"gfx/surface/tee"</expr>,
    <expr>"gfx/surface/xml"</expr>,
    <expr>"gfx/surface/skia"</expr>,
    <expr>"gfx/surface/ddraw"</expr>,
    <expr>"gfx/surface/d2d"</expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PR_STATIC_ASSERT</name><argument_list>(<argument><expr><call><name>NS_ARRAY_LENGTH</name><argument_list>(<argument><expr><name>sSurfaceNamesForSurfaceType</name></expr></argument>)</argument_list></call> == <name><name>gfxASurface</name>::<name>SurfaceTypeMax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CAIRO_HAS_D2D_SURFACE</name></cpp:ifdef>
<expr_stmt><expr><call><name>PR_STATIC_ASSERT</name><argument_list>(<argument><expr><name>CAIRO_SURFACE_TYPE_D2D</name> == <name><name>gfxASurface</name>::<name>SurfaceTypeD2D</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PR_STATIC_ASSERT</name><argument_list>(<argument><expr><name>CAIRO_SURFACE_TYPE_SKIA</name> == <name><name>gfxASurface</name>::<name>SurfaceTypeSkia</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>SurfaceMemoryReporterPathForType</name><parameter_list>(<param><decl><type><name><name>gfxASurface</name>::<name>gfxSurfaceType</name></name></type> <name>aType</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>aType</name> <argument_list>&lt; <argument><expr>0 ||
        <name>aType</name></expr></argument> &gt;</argument_list></name>= <name><name>gfxASurface</name>::<name>SurfaceTypeMax</name></name></expr>)</condition><then>
        <return>return <expr>"gfx/surface/unknown"</expr>;</return></then></if>

    <return>return <expr><name><name>sSurfaceNamesForSurfaceType</name><index>[<expr><name>aType</name></expr>]</index></name></expr>;</return>
}</block></function>

<comment type="block">/* Surface size memory reporting */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>nsIMemoryReporter</name> *</type><name><name>gSurfaceMemoryReporters</name><index>[<expr><name><name>gfxASurface</name>::<name>SurfaceTypeMax</name></name></expr>]</index></name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PRInt64</name></type> <name><name>gSurfaceMemoryUsed</name><index>[<expr><name><name>gfxASurface</name>::<name>SurfaceTypeMax</name></name></expr>]</index></name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

<class>class <name>SurfaceMemoryReporter</name> <super>:
    <specifier>public</specifier> <name>nsIMemoryReporter</name></super>
<block>{<private type="default">
</private><public>public:
    <constructor><name>SurfaceMemoryReporter</name><parameter_list>(<param><decl><type><name><name>gfxASurface</name>::<name>gfxSurfaceType</name></name></type> <name>aType</name></decl></param>)</parameter_list>
        <member_list>: <call><name>mType</name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call>
    </member_list><block>{ }</block></constructor>

    <function><type><name>NS_DECL_ISUPPORTS</name>

    <name>NS_IMETHOD</name></type> <name>GetPath</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>memoryPath</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr>*<name>memoryPath</name> = <call><name>strdup</name><argument_list>(<argument><expr><call><name>SurfaceMemoryReporterPathForType</name><argument_list>(<argument><expr><name>mType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></function>

    <function><type><name>NS_IMETHOD</name></type> <name>GetDescription</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>desc</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr>*<name>desc</name> = <call><name>strdup</name><argument_list>(<argument><expr>"Memory used by gfx surface of given type."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></function>

    <function><type><name>NS_IMETHOD</name></type> <name>GetMemoryUsed</name><parameter_list>(<param><decl><type><name>PRInt64</name> *</type><name>memoryUsed</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr>*<name>memoryUsed</name> = <name><name>gSurfaceMemoryUsed</name><index>[<expr><name>mType</name></expr>]</index></name></expr>;</expr_stmt>
        <return>return <expr><name>NS_OK</name></expr>;</return>
    }</block></function>

    <decl_stmt><decl><type><name><name>gfxASurface</name>::<name>gfxSurfaceType</name></name></type> <name>mType</name></decl>;</decl_stmt>
</public>}</block>;</class>

<macro><name>NS_IMPL_ISUPPORTS1</name><argument_list>(<argument>SurfaceMemoryReporter</argument>, <argument>nsIMemoryReporter</argument>)</argument_list></macro>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>RecordMemoryUsedForSurfaceType</name></name><parameter_list>(<param><decl><type><name><name>gfxASurface</name>::<name>gfxSurfaceType</name></name></type> <name>aType</name></decl></param>,
                                            <param><decl><type><name>PRInt32</name></type> <name>aBytes</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>aType</name> <argument_list>&lt; <argument><expr>0 || <name>aType</name></expr></argument> &gt;</argument_list></name>= <name>SurfaceTypeMax</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"Invalid type to RecordMemoryUsedForSurfaceType!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>gSurfaceMemoryReporters</name><index>[<expr><name>aType</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>gSurfaceMemoryReporters</name><index>[<expr><name>aType</name></expr>]</index></name> = new <call><name>SurfaceMemoryReporter</name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>NS_RegisterMemoryReporter</name><argument_list>(<argument><expr><name><name>gSurfaceMemoryReporters</name><index>[<expr><name>aType</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>gSurfaceMemoryUsed</name><index>[<expr><name>aType</name></expr>]</index></name> += <name>aBytes</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>RecordMemoryUsed</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aBytes</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>RecordMemoryUsedForSurfaceType</name><argument_list>(<argument><expr><call><name>GetType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mBytesRecorded</name> += <name>aBytes</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>gfxASurface</name>::<name>RecordMemoryFreed</name></name><parameter_list>()</parameter_list>
<block>{
    <if>if <condition>(<expr><name>mBytesRecorded</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>RecordMemoryUsedForSurfaceType</name><argument_list>(<argument><expr><call><name>GetType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>-<name>mBytesRecorded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mBytesRecorded</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
</unit>
