<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="00834d530f2bdb34836e4fe77eeef669dbd523aa.cpp"><comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * 
 * Copyright (c) 2008, Mozilla Corporation
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the Mozilla Corporation nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * Contributor(s):
 *   Josh Aas &lt;josh@mozilla.com&gt;
 *   Jim Mathies &lt;jmathies@mozilla.com&gt;
 * 
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nptest_platform.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windowsx.h&gt;</cpp:file></cpp:include>

 <using>using namespace <name>std</name>;</using>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> comment(lib, "msimg32.lib")</cpp:pragma>

<function_decl><type><name>void</name></type> <name>SetSubclass</name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>hWnd</name></decl></param>, <param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ClearSubclass</name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>hWnd</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>LRESULT</name> <name>CALLBACK</name></type> <name>PluginWndProc</name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>hWnd</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>uMsg</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>;</function_decl>

<struct>struct <name>_PlatformData</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>HWND</name></type> <name>childWindow</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><name>bool</name></type>
<name>pluginSupportsWindowMode</name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>bool</name></type>
<name>pluginSupportsWindowlessMode</name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr>true</expr>;</return>
}</block></function>

<function><type><name>NPError</name></type>
<name>pluginInstanceInit</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>instanceData</name>-&gt;<name>platformData</name></name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>PlatformData</name>*</expr></argument>&gt;</argument_list></name>
    <argument_list>(<argument><expr><call><name>NPN_MemAlloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlatformData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name><name>instanceData</name>-&gt;<name>platformData</name></name></expr>)</condition><then>
    <return>return <expr><name>NPERR_OUT_OF_MEMORY_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name><name>instanceData</name>-&gt;<name>platformData</name>-&gt;<name>childWindow</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>NPERR_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>pluginInstanceShutdown</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NPN_MemFree</name><argument_list>(<argument><expr><name><name>instanceData</name>-&gt;<name>platformData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>instanceData</name>-&gt;<name>platformData</name></name> = 0</expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>pluginDoSetWindow</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>, <param><decl><type><name>NPWindow</name>*</type> <name>newWindow</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>instanceData</name>-&gt;<name>window</name></name> = *<name>newWindow</name></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHILD_WIDGET_SIZE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>pluginWidgetInit</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>oldWindow</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>HWND</name></type> <name>hWnd</name> <init>= <expr>(<name>HWND</name>)<name><name>instanceData</name>-&gt;<name>window</name>.<name>window</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>oldWindow</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>HWND</name></type> <name>hWndOld</name> <init>= <expr>(<name>HWND</name>)<name>oldWindow</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ClearSubclass</name><argument_list>(<argument><expr><name>hWndOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>instanceData</name>-&gt;<name>platformData</name>-&gt;<name>childWindow</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>::<name>DestroyWindow</name></name><argument_list>(<argument><expr><name><name>instanceData</name>-&gt;<name>platformData</name>-&gt;<name>childWindow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>SetSubclass</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>instanceData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>instanceData</name>-&gt;<name>platformData</name>-&gt;<name>childWindow</name></name> =
    <call><name>::<name>CreateWindowW</name></name><argument_list>(<argument><expr>L"SCROLLBAR"</expr></argument>, <argument><expr>L"Dummy child window"</expr></argument>, 
                    <argument><expr><name>WS_CHILD</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>CHILD_WIDGET_SIZE</name></expr></argument>, <argument><expr><name>CHILD_WIDGET_SIZE</name></expr></argument>, <argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>drawToDC</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>, <param><decl><type><name>HDC</name></type> <name>dc</name></decl></param>,
         <param><decl><type><name>int</name></type> <name>x</name></decl></param>, <param><decl><type><name>int</name></type> <name>y</name></decl></param>, <param><decl><type><name>int</name></type> <name>width</name></decl></param>, <param><decl><type><name>int</name></type> <name>height</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>HBITMAP</name></type> <name>offscreenBitmap</name> <init>= <expr><call><name>::<name>CreateCompatibleBitmap</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>offscreenBitmap</name></expr>)</condition><then>
    <return>return;</return></then></if>
  <decl_stmt><decl><type><name>HDC</name></type> <name>offscreenDC</name> <init>= <expr><call><name>::<name>CreateCompatibleDC</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>offscreenDC</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>offscreenBitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>HBITMAP</name></type> <name>oldOffscreenBitmap</name> <init>=
    <expr>(<name>HBITMAP</name>)<call><name>::<name>SelectObject</name></name><argument_list>(<argument><expr><name>offscreenDC</name></expr></argument>, <argument><expr><name>offscreenBitmap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>SetBkMode</name></name><argument_list>(<argument><expr><name>offscreenDC</name></expr></argument>, <argument><expr><name>TRANSPARENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>BYTE</name></type> <name>alpha</name> <init>= <expr>255</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RECT</name></type> <name>fill</name> <init>= <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>width</name></expr>, <expr><name>height</name></expr> }</block></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name><name>instanceData</name>-&gt;<name>scriptableObject</name>-&gt;<name>drawMode</name></name></expr>)</condition> <block>{
    <case>case <expr><name>DM_DEFAULT</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>HBRUSH</name></type> <name>brush</name> <init>= <expr><call><name>::<name>CreateSolidBrush</name></name><argument_list>(<argument><expr><call><name>RGB</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>brush</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>::<name>FillRect</name></name><argument_list>(<argument><expr><name>offscreenDC</name></expr></argument>, <argument><expr>&amp;<name>fill</name></expr></argument>, <argument><expr><name>brush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>brush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><name>width</name> &gt; 6 &amp;&amp; <name>height</name> &gt; 6</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>brush</name> = <call><name>::<name>CreateSolidBrush</name></name><argument_list>(<argument><expr><call><name>RGB</name><argument_list>(<argument><expr>192</expr></argument>, <argument><expr>192</expr></argument>, <argument><expr>192</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>brush</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>RECT</name></type> <name>inset</name> <init>= <expr><block>{ <expr>3</expr>, <expr>3</expr>, <expr><name>width</name> - 3</expr>, <expr><name>height</name> - 3</expr> }</block></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>::<name>FillRect</name></name><argument_list>(<argument><expr><name>offscreenDC</name></expr></argument>, <argument><expr>&amp;<name>inset</name></expr></argument>, <argument><expr><name>brush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>brush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>

      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>uaString</name> <init>= <expr><call><name>NPN_UserAgent</name><argument_list>(<argument><expr><name><name>instanceData</name>-&gt;<name>npp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>uaString</name> &amp;&amp; <name>width</name> &gt; 10 &amp;&amp; <name>height</name> &gt; 10</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>HFONT</name></type> <name>font</name> <init>=
          <expr><call><name>::<name>CreateFontA</name></name><argument_list>(<argument><expr>20</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>400</expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                        <argument><expr><name>DEFAULT_CHARSET</name></expr></argument>, <argument><expr><name>OUT_DEFAULT_PRECIS</name></expr></argument>,
                        <argument><expr><name>CLIP_DEFAULT_PRECIS</name></expr></argument>, <argument><expr>5</expr></argument>, <comment type="line">// CLEARTYPE_QUALITY</comment>
                        <argument><expr><name>DEFAULT_PITCH</name></expr></argument>, <argument><expr>"Arial"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>font</name></expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>HFONT</name></type> <name>oldFont</name> <init>= <expr>(<name>HFONT</name>)<call><name>::<name>SelectObject</name></name><argument_list>(<argument><expr><name>offscreenDC</name></expr></argument>, <argument><expr><name>font</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>RECT</name></type> <name>inset</name> <init>= <expr><block>{ <expr>5</expr>, <expr>5</expr>, <expr><name>width</name> - 5</expr>, <expr><name>height</name> - 5</expr> }</block></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>::<name>DrawTextA</name></name><argument_list>(<argument><expr><name>offscreenDC</name></expr></argument>, <argument><expr><name>uaString</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>inset</name></expr></argument>,
                      <argument><expr><name>DT_LEFT</name> | <name>DT_TOP</name> | <name>DT_NOPREFIX</name> | <name>DT_WORDBREAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>::<name>SelectObject</name></name><argument_list>(<argument><expr><name>offscreenDC</name></expr></argument>, <argument><expr><name>oldFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>font</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block>
    <break>break;</break>

    </case><case>case <expr><name>DM_SOLID_COLOR</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>PRUint32</name></type> <name>rgba</name> <init>= <expr><name><name>instanceData</name>-&gt;<name>scriptableObject</name>-&gt;<name>drawColor</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BYTE</name></type> <name>r</name> <init>= <expr>((<name>rgba</name> &amp; 0xFF0000) &gt;&gt; 16)</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BYTE</name></type> <name>g</name> <init>= <expr>((<name>rgba</name> &amp; 0xFF00) &gt;&gt; 8)</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BYTE</name></type> <name>b</name> <init>= <expr>(<name>rgba</name> &amp; 0xFF)</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>alpha</name> = ((<name>rgba</name> &amp; 0xFF000000) &gt;&gt; 24)</expr>;</expr_stmt>

      <decl_stmt><decl><type><name>HBRUSH</name></type> <name>brush</name> <init>= <expr><call><name>::<name>CreateSolidBrush</name></name><argument_list>(<argument><expr><call><name>RGB</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>brush</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>::<name>FillRect</name></name><argument_list>(<argument><expr><name>offscreenDC</name></expr></argument>, <argument><expr>&amp;<name>fill</name></expr></argument>, <argument><expr><name>brush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>brush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block>
    <break>break;</break>
  </case>}</block></switch>

  <decl_stmt><decl><type><name>BLENDFUNCTION</name></type> <name>blendFunc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>blendFunc</name>.<name>BlendOp</name></name> = <name>AC_SRC_OVER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>blendFunc</name>.<name>BlendFlags</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>blendFunc</name>.<name>SourceConstantAlpha</name></name> = <name>alpha</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>blendFunc</name>.<name>AlphaFormat</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>AlphaBlend</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>, <argument><expr><name>offscreenDC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>,
               <argument><expr><name>blendFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>SelectObject</name></name><argument_list>(<argument><expr><name>offscreenDC</name></expr></argument>, <argument><expr><name>oldOffscreenBitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>offscreenDC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>offscreenBitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>pluginDraw</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>NPP</name></type> <name>npp</name> <init>= <expr><name><name>instanceData</name>-&gt;<name>npp</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>npp</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <decl_stmt><decl><type><name>HDC</name></type> <name>hdc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PAINTSTRUCT</name></type> <name>ps</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>instanceData</name>-&gt;<name>hasWidget</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>hdc</name> = <call><name>::<name>BeginPaint</name></name><argument_list>(<argument><expr>(<name>HWND</name>)<name><name>instanceData</name>-&gt;<name>window</name>.<name>window</name></name></expr></argument>, <argument><expr>&amp;<name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>hdc</name> = (<name>HDC</name>)<name><name>instanceData</name>-&gt;<name>window</name>.<name>window</name></name></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name>hdc</name> == <name>NULL</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="line">// Push the browser's hdc on the resource stack. If this test plugin is windowless,</comment>
  <comment type="line">// we share the drawing surface with the rest of the browser.</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>savedDCID</name> <init>= <expr><call><name>SaveDC</name><argument_list>(<argument><expr><name>hdc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// When we have a widget, window.x/y are meaningless since our widget</comment>
  <comment type="line">// is always positioned correctly and we just draw into it at 0,0.</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>instanceData</name>-&gt;<name>hasWidget</name></name> ? 0 : <name><name>instanceData</name>-&gt;<name>window</name>.<name>x</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><name><name>instanceData</name>-&gt;<name>hasWidget</name></name> ? 0 : <name><name>instanceData</name>-&gt;<name>window</name>.<name>y</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr><name><name>instanceData</name>-&gt;<name>window</name>.<name>width</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>height</name> <init>= <expr><name><name>instanceData</name>-&gt;<name>window</name>.<name>height</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>drawToDC</name><argument_list>(<argument><expr><name>instanceData</name></expr></argument>, <argument><expr><name>hdc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Pop our hdc changes off the resource stack</comment>
  <expr_stmt><expr><call><name>RestoreDC</name><argument_list>(<argument><expr><name>hdc</name></expr></argument>, <argument><expr><name>savedDCID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>instanceData</name>-&gt;<name>hasWidget</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>::<name>EndPaint</name></name><argument_list>(<argument><expr>(<name>HWND</name>)<name><name>instanceData</name>-&gt;<name>window</name>.<name>window</name></name></expr></argument>, <argument><expr>&amp;<name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr>++<name><name>instanceData</name>-&gt;<name>paintCount</name></name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* script interface */</comment>

<function><type><name>int32_t</name></type>
<name>pluginGetEdge</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>, <param><decl><type><name>RectEdge</name></type> <name>edge</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>instanceData</name> || !<name><name>instanceData</name>-&gt;<name>hasWidget</name></name></expr>)</condition><then>
    <return>return <expr><name>NPTEST_INT32_ERROR</name></expr>;</return></then></if>

  <comment type="line">// Get the plugin client rect in screen coordinates</comment>
  <decl_stmt><decl><type><name>RECT</name></type> <name>rect</name> <init>= <expr><block>{<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>::<name>GetClientRect</name></name><argument_list>(<argument><expr>(<name>HWND</name>)<name><name>instanceData</name>-&gt;<name>window</name>.<name>window</name></name></expr></argument>, <argument><expr>&amp;<name>rect</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NPTEST_INT32_ERROR</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>::<name>MapWindowPoints</name></name><argument_list>(<argument><expr>(<name>HWND</name>)<name><name>instanceData</name>-&gt;<name>window</name>.<name>window</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>(<name>LPPOINT</name>)&amp;<name>rect</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Get the toplevel window frame rect in screen coordinates</comment>
  <decl_stmt><decl><type><name>HWND</name></type> <name>rootWnd</name> <init>= <expr><call><name>::<name>GetAncestor</name></name><argument_list>(<argument><expr>(<name>HWND</name>)<name><name>instanceData</name>-&gt;<name>window</name>.<name>window</name></name></expr></argument>, <argument><expr><name>GA_ROOT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>rootWnd</name></expr>)</condition><then>
    <return>return <expr><name>NPTEST_INT32_ERROR</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>RECT</name></type> <name>rootRect</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>rootWnd</name></expr></argument>, <argument><expr>&amp;<name>rootRect</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NPTEST_INT32_ERROR</name></expr>;</return></then></if>

  <switch>switch <condition>(<expr><name>edge</name></expr>)</condition> <block>{
  <case>case <expr><name>EDGE_LEFT</name></expr>:
    <return>return <expr><name><name>rect</name>.<name>left</name></name> - <name><name>rootRect</name>.<name>left</name></name></expr>;</return>
  </case><case>case <expr><name>EDGE_TOP</name></expr>:
    <return>return <expr><name><name>rect</name>.<name>top</name></name> - <name><name>rootRect</name>.<name>top</name></name></expr>;</return>
  </case><case>case <expr><name>EDGE_RIGHT</name></expr>:
    <return>return <expr><name><name>rect</name>.<name>right</name></name> - <name><name>rootRect</name>.<name>left</name></name></expr>;</return>
  </case><case>case <expr><name>EDGE_BOTTOM</name></expr>:
    <return>return <expr><name><name>rect</name>.<name>bottom</name></name> - <name><name>rootRect</name>.<name>top</name></name></expr>;</return>
  </case>}</block></switch>

  <return>return <expr><name>NPTEST_INT32_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>getWindowRegion</name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>wnd</name></decl></param>, <param><decl><type><name>HRGN</name></type> <name>rgn</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>::<name>GetWindowRgn</name></name><argument_list>(<argument><expr><name>wnd</name></expr></argument>, <argument><expr><name>rgn</name></expr></argument>)</argument_list></call> != <name>ERROR</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>RECT</name></type> <name>clientRect</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>::<name>GetClientRect</name></name><argument_list>(<argument><expr><name>wnd</name></expr></argument>, <argument><expr>&amp;<name>clientRect</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>
  <return>return <expr><call><name>::<name>SetRectRgn</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>clientRect</name>.<name>right</name></name></expr></argument>, <argument><expr><name><name>clientRect</name>.<name>bottom</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>RGNDATA</name>*</type>
<name>computeClipRegion</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>HWND</name></type> <name>wnd</name> <init>= <expr>(<name>HWND</name>)<name><name>instanceData</name>-&gt;<name>window</name>.<name>window</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HRGN</name></type> <name>rgn</name> <init>= <expr><call><name>::<name>CreateRectRgn</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>rgn</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>
  <decl_stmt><decl><type><name>HRGN</name></type> <name>ancestorRgn</name> <init>= <expr><call><name>::<name>CreateRectRgn</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>ancestorRgn</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr>!<call><name>getWindowRegion</name><argument_list>(<argument><expr><name>wnd</name></expr></argument>, <argument><expr><name>rgn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>ancestorRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>HWND</name></type> <name>ancestor</name> <init>= <expr><name>wnd</name></expr></init></decl>;</decl_stmt>
  <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
    <expr_stmt><expr><name>ancestor</name> = <call><name>::<name>GetAncestor</name></name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>, <argument><expr><name>GA_PARENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ancestor</name> || <name>ancestor</name> == <call><name>::<name>GetDesktopWindow</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>ancestorRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>DWORD</name></type> <name>size</name> <init>= <expr><call><name>::<name>GetRegionData</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>size</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      }</block></then></if>

      <decl_stmt><decl><type><name>HANDLE</name></type> <name>heap</name> <init>= <expr><call><name>::<name>GetProcessHeap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>RGNDATA</name>*</type> <name>data</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>RGNDATA</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>::<name>HeapAlloc</name></name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>data</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      }</block></then></if>
      <decl_stmt><decl><type><name>DWORD</name></type> <name>result</name> <init>= <expr><call><name>::<name>GetRegionData</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>::<name>HeapFree</name></name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
      }</block></then></if>

      <return>return <expr><name>data</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>getWindowRegion</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>, <argument><expr><name>ancestorRgn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>ancestorRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>POINT</name></type> <name>pt</name> <init>= <expr><block>{ <expr>0</expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>::<name>MapWindowPoints</name></name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>, <argument><expr><name>wnd</name></expr></argument>, <argument><expr>&amp;<name>pt</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>::<name>OffsetRgn</name></name><argument_list>(<argument><expr><name>ancestorRgn</name></expr></argument>, <argument><expr><name><name>pt</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>pt</name>.<name>y</name></name></expr></argument>)</argument_list></call> == <name>ERROR</name> ||
        <call><name>::<name>CombineRgn</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>, <argument><expr><name>rgn</name></expr></argument>, <argument><expr><name>ancestorRgn</name></expr></argument>, <argument><expr><name>RGN_AND</name></expr></argument>)</argument_list></call> == <name>ERROR</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>ancestorRgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>::<name>DeleteObject</name></name><argument_list>(<argument><expr><name>rgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
  }</block></for>
}</block></function>

<function><type><name>int32_t</name></type>
<name>pluginGetClipRegionRectCount</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>RGNDATA</name>*</type> <name>data</name> <init>= <expr><call><name>computeClipRegion</name><argument_list>(<argument><expr><name>instanceData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>data</name></expr>)</condition><then>
    <return>return <expr><name>NPTEST_INT32_ERROR</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>result</name> <init>= <expr><name><name>data</name>-&gt;<name>rdh</name>.<name>nCount</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>HeapFree</name></name><argument_list>(<argument><expr><call><name>::<name>GetProcessHeap</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type>
<name>addOffset</name><parameter_list>(<param><decl><type><name>LONG</name></type> <name>coord</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>offset</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>offset</name> == <name>NPTEST_INT32_ERROR</name></expr>)</condition><then>
    <return>return <expr><name>NPTEST_INT32_ERROR</name></expr>;</return></then></if>
  <return>return <expr><name>coord</name> + <name>offset</name></expr>;</return>
}</block></function>

<function><type><name>int32_t</name></type>
<name>pluginGetClipRegionRectEdge</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>, 
    <param><decl><type><name>int32_t</name></type> <name>rectIndex</name></decl></param>, <param><decl><type><name>RectEdge</name></type> <name>edge</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>RGNDATA</name>*</type> <name>data</name> <init>= <expr><call><name>computeClipRegion</name><argument_list>(<argument><expr><name>instanceData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>data</name></expr>)</condition><then>
    <return>return <expr><name>NPTEST_INT32_ERROR</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>HANDLE</name></type> <name>heap</name> <init>= <expr><call><name>::<name>GetProcessHeap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>rectIndex</name> &gt;= <call><name>int32_t</name><argument_list>(<argument><expr><name><name>data</name>-&gt;<name>rdh</name>.<name>nCount</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>HeapFree</name></name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NPTEST_INT32_ERROR</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>RECT</name></type> <name>rect</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>RECT</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>data</name>-&gt;<name>Buffer</name></name></expr></argument>)</argument_list></call><index>[<expr><name>rectIndex</name></expr>]</index></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>::<name>HeapFree</name></name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>edge</name></expr>)</condition> <block>{
  <case>case <expr><name>EDGE_LEFT</name></expr>:
    <return>return <expr><call><name>addOffset</name><argument_list>(<argument><expr><name><name>rect</name>.<name>left</name></name></expr></argument>, <argument><expr><call><name>pluginGetEdge</name><argument_list>(<argument><expr><name>instanceData</name></expr></argument>, <argument><expr><name>EDGE_LEFT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>EDGE_TOP</name></expr>:
    <return>return <expr><call><name>addOffset</name><argument_list>(<argument><expr><name><name>rect</name>.<name>top</name></name></expr></argument>, <argument><expr><call><name>pluginGetEdge</name><argument_list>(<argument><expr><name>instanceData</name></expr></argument>, <argument><expr><name>EDGE_TOP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>EDGE_RIGHT</name></expr>:
    <return>return <expr><call><name>addOffset</name><argument_list>(<argument><expr><name><name>rect</name>.<name>right</name></name></expr></argument>, <argument><expr><call><name>pluginGetEdge</name><argument_list>(<argument><expr><name>instanceData</name></expr></argument>, <argument><expr><name>EDGE_LEFT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </case><case>case <expr><name>EDGE_BOTTOM</name></expr>:
    <return>return <expr><call><name>addOffset</name><argument_list>(<argument><expr><name><name>rect</name>.<name>bottom</name></name></expr></argument>, <argument><expr><call><name>pluginGetEdge</name><argument_list>(<argument><expr><name>instanceData</name></expr></argument>, <argument><expr><name>EDGE_TOP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </case>}</block></switch>

  <return>return <expr><name>NPTEST_INT32_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* windowless plugin events */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>handleEventInternal</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>, <param><decl><type><name>NPEvent</name>*</type> <name>pe</name></decl></param>, <param><decl><type><name>LRESULT</name>*</type> <name>result</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr>(<name>UINT</name>)<name><name>pe</name>-&gt;<name>event</name></name></expr>)</condition> <block>{
    <case>case <expr><name>WM_PAINT</name></expr>:
      <expr_stmt><expr><call><name>pluginDraw</name><argument_list>(<argument><expr><name>instanceData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>true</expr>;</return>

    </case><case>case <expr><name>WM_MOUSEACTIVATE</name></expr>:
      <if>if <condition>(<expr><name><name>instanceData</name>-&gt;<name>hasWidget</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>::<name>SetFocus</name></name><argument_list>(<argument><expr>(<name>HWND</name>)<name><name>instanceData</name>-&gt;<name>window</name>.<name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>result</name> = <name>MA_ACTIVATEANDEAT</name></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
      }</block></then></if>
      <return>return <expr>false</expr>;</return>

    </case><case>case <expr><name>WM_MOUSEWHEEL</name></expr>:
      <return>return <expr>true</expr>;</return>

    </case><case>case <expr><name>WM_MOUSEMOVE</name></expr>:
    </case><case>case <expr><name>WM_LBUTTONDOWN</name></expr>:
    </case><case>case <expr><name>WM_LBUTTONUP</name></expr>:
    </case><case>case <expr><name>WM_MBUTTONDOWN</name></expr>:
    </case><case>case <expr><name>WM_MBUTTONUP</name></expr>:
    </case><case>case <expr><name>WM_RBUTTONDOWN</name></expr>:
    </case><case>case <expr><name>WM_RBUTTONUP</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>instanceData</name>-&gt;<name>hasWidget</name></name> ? 0 : <name><name>instanceData</name>-&gt;<name>window</name>.<name>x</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><name><name>instanceData</name>-&gt;<name>hasWidget</name></name> ? 0 : <name><name>instanceData</name>-&gt;<name>window</name>.<name>y</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>instanceData</name>-&gt;<name>lastMouseX</name></name> = <call><name>GET_X_LPARAM</name><argument_list>(<argument><expr><name><name>pe</name>-&gt;<name>lParam</name></name></expr></argument>)</argument_list></call> - <name>x</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>instanceData</name>-&gt;<name>lastMouseY</name></name> = <call><name>GET_Y_LPARAM</name><argument_list>(<argument><expr><name><name>pe</name>-&gt;<name>lParam</name></name></expr></argument>)</argument_list></call> - <name>y</name></expr>;</expr_stmt>
      <return>return <expr>true</expr>;</return>
    }</block>

    </case><default>default:
      <return>return <expr>false</expr>;</return>
  </default>}</block></switch>
}</block></function>

<function><type><name>int16_t</name></type>
<name>pluginHandleEvent</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>event</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>NPEvent</name>*</type> <name>pe</name> <init>= <expr>(<name>NPEvent</name>*)<name>event</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>pe</name> == <name>NULL</name> || <name>instanceData</name> == <name>NULL</name> ||
      <name><name>instanceData</name>-&gt;<name>window</name>.<name>type</name></name> != <name>NPWindowTypeDrawable</name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>   

  <decl_stmt><decl><type><name>LRESULT</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>handleEventInternal</name><argument_list>(<argument><expr><name>instanceData</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* windowed plugin events */</comment>

<function><type><name>LRESULT</name> <name>CALLBACK</name></type> <name>PluginWndProc</name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>hWnd</name></decl></param>, <param><decl><type><name>UINT</name></type> <name>uMsg</name></decl></param>, <param><decl><type><name>WPARAM</name></type> <name>wParam</name></decl></param>, <param><decl><type><name>LPARAM</name></type> <name>lParam</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>WNDPROC</name></type> <name>wndProc</name> <init>= <expr>(<name>WNDPROC</name>)<call><name>GetProp</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>"MozillaWndProc"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>wndProc</name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>
  <decl_stmt><decl><type><name>InstanceData</name>*</type> <name>pInstance</name> <init>= <expr>(<name>InstanceData</name>*)<call><name>GetProp</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>"InstanceData"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>pInstance</name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <decl_stmt><decl><type><name>NPEvent</name></type> <name>event</name> <init>= <expr><block>{ <expr><name>uMsg</name></expr>, <expr><name>wParam</name></expr>, <expr><name>lParam</name></expr> }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>LRESULT</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>handleEventInternal</name><argument_list>(<argument><expr><name>pInstance</name></expr></argument>, <argument><expr>&amp;<name>event</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>result</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>uMsg</name> == <name>WM_CLOSE</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ClearSubclass</name><argument_list>(<argument><expr>(<name>HWND</name>)<name><name>pInstance</name>-&gt;<name>window</name>.<name>window</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><call><name>CallWindowProc</name><argument_list>(<argument><expr><name>wndProc</name></expr></argument>, <argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>uMsg</name></expr></argument>, <argument><expr><name>wParam</name></expr></argument>, <argument><expr><name>lParam</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>ClearSubclass</name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>hWnd</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>GetProp</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>"MozillaWndProc"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>::<name>SetWindowLongPtr</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>GWLP_WNDPROC</name></expr></argument>, <argument><expr>(<name>LONG_PTR</name>)<call><name>GetProp</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>"MozillaWndProc"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RemoveProp</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>"MozillaWndProc"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RemoveProp</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>"InstanceData"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>SetSubclass</name><parameter_list>(<param><decl><type><name>HWND</name></type> <name>hWnd</name></decl></param>, <param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Subclass the plugin window so we can handle our own windows events.</comment>
  <expr_stmt><expr><call><name>SetProp</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>"InstanceData"</expr></argument>, <argument><expr>(<name>HANDLE</name>)<name>instanceData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>WNDPROC</name></type> <name>origProc</name> <init>= <expr>(<name>WNDPROC</name>)<call><name>::<name>SetWindowLongPtr</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr><name>GWLP_WNDPROC</name></expr></argument>, <argument><expr>(<name>LONG_PTR</name>)<name>PluginWndProc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SetProp</name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>"MozillaWndProc"</expr></argument>, <argument><expr>(<name>HANDLE</name>)<name>origProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>checkEquals</name><parameter_list>(<param><decl><type><name>int</name></type> <name>a</name></decl></param>, <param><decl><type><name>int</name></type> <name>b</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>msg</name></decl></param>, <param><decl><type><name>string</name>&amp;</type> <name>error</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>error</name>.<name>append</name></name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>" (got %d, expected %d)\n"</expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>error</name>.<name>append</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>pluginDoInternalConsistencyCheck</name><parameter_list>(<param><decl><type><name>InstanceData</name>*</type> <name>instanceData</name></decl></param>, <param><decl><type><name>string</name>&amp;</type> <name>error</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>instanceData</name>-&gt;<name>platformData</name>-&gt;<name>childWindow</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>RECT</name></type> <name>childRect</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name><name>instanceData</name>-&gt;<name>platformData</name>-&gt;<name>childWindow</name></name></expr></argument>, <argument><expr>&amp;<name>childRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>RECT</name></type> <name>ourRect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HWND</name></type> <name>hWnd</name> <init>= <expr>(<name>HWND</name>)<name><name>instanceData</name>-&gt;<name>window</name>.<name>window</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>::<name>GetWindowRect</name></name><argument_list>(<argument><expr><name>hWnd</name></expr></argument>, <argument><expr>&amp;<name>ourRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkEquals</name><argument_list>(<argument><expr><name><name>childRect</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>ourRect</name>.<name>left</name></name></expr></argument>, <argument><expr>"Child widget left"</expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkEquals</name><argument_list>(<argument><expr><name><name>childRect</name>.<name>top</name></name></expr></argument>, <argument><expr><name><name>ourRect</name>.<name>top</name></name></expr></argument>, <argument><expr>"Child widget top"</expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkEquals</name><argument_list>(<argument><expr><name><name>childRect</name>.<name>right</name></name></expr></argument>, <argument><expr><name><name>childRect</name>.<name>left</name></name> + <name>CHILD_WIDGET_SIZE</name></expr></argument>, <argument><expr>"Child widget width"</expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkEquals</name><argument_list>(<argument><expr><name><name>childRect</name>.<name>bottom</name></name></expr></argument>, <argument><expr><name><name>childRect</name>.<name>top</name></name> + <name>CHILD_WIDGET_SIZE</name></expr></argument>, <argument><expr>"Child widget height"</expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
</unit>
