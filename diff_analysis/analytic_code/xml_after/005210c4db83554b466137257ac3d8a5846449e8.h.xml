<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="005210c4db83554b466137257ac3d8a5846449e8.h"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</comment>
<comment type="block">/* vim:set ts=2 sw=2 sts=2 et cindent: */</comment>
<comment type="block">/* ***** BEGIN LICENSE BLOCK *****
 * Version: ML 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla code.
 *
 * The Initial Developer of the Original Code is the Mozilla Foundation.
 * Portions created by the Initial Developer are Copyright (C) 2010
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *  Chris Double &lt;chris.double@double.co.nz&gt;
 *  Chris Pearce &lt;chris@pearce.org.nz&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>
<comment type="block">/*
Each video element for a media file has two additional threads beyond
those needed by nsBuiltinDecoder.

  1) The Audio thread writes the decoded audio data to the audio
     hardware.  This is done in a seperate thread to ensure that the
     audio hardware gets a constant stream of data without
     interruption due to decoding or display. At some point
     libsydneyaudio will be refactored to have a callback interface
     where it asks for data and an extra thread will no longer be
     needed.

  2) The decode thread. This thread reads from the media stream and
     decodes the Theora and Vorbis data. It places the decoded data in
     a queue for the other threads to pull from.

All file reads and seeks must occur on either the state machine thread
or the decode thread. Synchronisation is done via a monitor owned by
nsBuiltinDecoder.

The decode thread and the audio thread are created and destroyed in
the state machine thread. When playback needs to occur they are
created and events dispatched to them to start them. These events exit
when decoding is completed or no longer required (during seeking or
shutdown).
    
The decode thread has its own monitor to ensure that its internal
state is independent of the other threads, and to ensure that it's not
hogging the nsBuiltinDecoder monitor while decoding.

a/v synchronisation is handled by the state machine thread. It
examines the audio playback time and compares this to the next frame
in the queue of frames. If it is time to play the video frame it is
then displayed.

Frame skipping is done in the following ways:

  1) The state machine thread will skip all frames in the video queue whose
     display time is less than the current audio time. This ensures
     the correct frame for the current time is always displayed.

  2) The decode thread will stop decoding interframes and read to the
     next keyframe if it determines that decoding the remaining
     interframes will cause playback issues. It detects this by:
       a) If the amount of audio data in the audio queue drops
          below a threshold whereby audio may start to skip.
       b) If the video queue drops below a threshold where it
          will be decoding video data that won't be displayed due
          to the decode thread dropping the frame immediately.

YCbCr conversion is done on the decode thread when it is time to display
the video frame. This means frames that are skipped will not have the
YCbCr conversion done, improving playback.

The decode thread pushes decoded audio and videos frames into two
separate queues - one for audio and one for video. These are kept
separate to make it easy to constantly feed audio data to the sound
hardware while allowing frame skipping of video data. These queues are
threadsafe, and neither the decode, audio, or state machine thread should
be able to monopolize them, and cause starvation of the other threads.

Both queues are bounded by a maximum size. When this size is reached
the decode thread will no longer decode video or audio depending on the
queue that has reached the threshold.

During playback the audio thread will be idle (via a Wait() on the
monitor) if the audio queue is empty. Otherwise it constantly pops an
item off the queue and plays it with a blocking write to the audio
hardware (via nsAudioStream and libsydneyaudio).

The decode thread idles if the video queue is empty or if it is
not yet time to display the next frame.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>nsBuiltinDecoderStateMachine_h__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nsBuiltinDecoderStateMachine_h__</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsThreadUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBuiltinDecoder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsBuiltinDecoderReader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAudioAvailableEventManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHTMLMediaElement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mozilla/Monitor.h"</cpp:file></cpp:include>

<comment type="block">/*
  The playback state machine class. This manages the decoding in the
  nsBuiltinDecoderReader on the decode thread, seeking and in-sync-playback on the
  state machine thread, and controls the audio "push" thread.

  All internal state is synchronised via the decoder monitor. NotifyAll
  on the monitor is called when the state of the state machine is changed
  by the main thread. The following changes to state cause a notify:

    mState and data related to that state changed (mSeekTime, etc)
    Metadata Loaded
    First Frame Loaded
    Frame decoded
    data pushed or popped from the video and audio queues

  See nsBuiltinDecoder.h for more details.
*/</comment>
<expr_stmt><expr><name>class</name> <name>nsBuiltinDecoderStateMachine</name> : <name>public</name> <name>nsDecoderStateMachine</name>
<block>{
<expr><name>public</name>:</expr>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>Monitor</name> <name>Monitor</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>TimeStamp</name> <name>TimeStamp</name></expr>;</expr_stmt></typedef>
  <typedef>typedef <expr_stmt><expr><name>mozilla</name>::<name>TimeDuration</name> <name>TimeDuration</name></expr>;</expr_stmt></typedef>

  <expr_stmt><expr><call><name>nsBuiltinDecoderStateMachine</name><argument_list>(<argument><expr><name>nsBuiltinDecoder</name>* <name>aDecoder</name></expr></argument>, <argument><expr><name>nsBuiltinDecoderReader</name>* <name>aReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>~<call><name>nsBuiltinDecoderStateMachine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// nsDecoderStateMachine interface</comment>
  <function_decl><type><name>virtual</name> <name>nsresult</name></type> <name>Init</name><parameter_list>(<param><decl><type><name>nsDecoderStateMachine</name>*</type> <name>aCloneDonor</name></decl></param>)</parameter_list>;</function_decl>
  <function><type><name>State</name></type> <name>GetState</name><parameter_list>()</parameter_list>
  <block>{ 
    <expr_stmt><expr><call><name><name>mDecoder</name>-&gt;<name>GetMonitor</name></name><argument_list>()</argument_list></call>.<call><name>AssertCurrentThreadIn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>mState</name></expr>;</return> 
  }</block></function>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>SetVolume</name><parameter_list>(<param><decl><type><name>double</name></type> <name>aVolume</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>Shutdown</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>PRInt64</name></type> <name>GetDuration</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>SetDuration</name><parameter_list>(<param><decl><type><name>PRInt64</name></type> <name>aDuration</name></decl></param>)</parameter_list>;</function_decl>
  <function><type><name>virtual</name> <name>PRBool</name></type> <name>OnDecodeThread</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><call><name>IsCurrentThread</name><argument_list>(<argument><expr><name>mDecodeThread</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <expr_stmt><expr><name>virtual</name> <name>nsHTMLMediaElement</name>::<name>NextFrameStatus</name> <call><name>GetNextFrameStatus</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>Decode</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>Seek</name><parameter_list>(<param><decl><type><name>double</name></type> <name>aTime</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>double</name></type> <name>GetCurrentTime</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>ClearPositionChangeFlag</name><parameter_list>()</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>SetSeekable</name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aSeekable</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>UpdatePlaybackPosition</name><parameter_list>(<param><decl><type><name>PRInt64</name></type> <name>aTime</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>StartBuffering</name><parameter_list>()</parameter_list>;</function_decl>


  <comment type="line">// Load metadata Called on the state machine thread. The decoder monitor must be held with</comment>
  <comment type="line">// exactly one lock count.</comment>
  <function_decl><type><name>virtual</name> <name>void</name></type> <name>LoadMetadata</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// State machine thread run function. Polls the state, sends frames to be</comment>
  <comment type="line">// displayed at appropriate times, and generally manages the decode.</comment>
  <function_decl><type><name>NS_IMETHOD</name></type> <name>Run</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// This is called on the state machine thread and audio thread.</comment>
  <comment type="line">// The decoder monitor must be obtained before calling this.</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>HasAudio</name><argument_list>()</argument_list></macro> const <block>{
    <expr><call><name><name>mDecoder</name>-&gt;<name>GetMonitor</name></name><argument_list>()</argument_list></call>.<call><name>AssertCurrentThreadIn</name><argument_list>()</argument_list></call></expr>;
    <return>return <expr><call><name><name>mReader</name>-&gt;<name>GetInfo</name></name><argument_list>()</argument_list></call>.<name>mHasAudio</name></expr>;</return>
  }</block></expr></expr_stmt>

  <comment type="line">// This is called on the state machine thread and audio thread.</comment>
  <comment type="line">// The decoder monitor must be obtained before calling this.</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>HasVideo</name><argument_list>()</argument_list></macro> const <block>{
    <expr><call><name><name>mDecoder</name>-&gt;<name>GetMonitor</name></name><argument_list>()</argument_list></call>.<call><name>AssertCurrentThreadIn</name><argument_list>()</argument_list></call></expr>;
    <return>return <expr><call><name><name>mReader</name>-&gt;<name>GetInfo</name></name><argument_list>()</argument_list></call>.<name>mHasVideo</name></expr>;</return>
  }</block></expr></expr_stmt>

  <comment type="line">// Should be called by main thread.</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>HaveNextFrameData</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>

  <comment type="line">// Must be called with the decode monitor held.</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>IsBuffering</name><argument_list>()</argument_list></macro> const <block>{
    <expr><call><name><name>mDecoder</name>-&gt;<name>GetMonitor</name></name><argument_list>()</argument_list></call>.<call><name>AssertCurrentThreadIn</name><argument_list>()</argument_list></call></expr>;

    <return>return <expr><name>mState</name> == <name>nsBuiltinDecoderStateMachine</name>::<name>DECODER_STATE_BUFFERING</name></expr>;</return>
  }</block></expr></expr_stmt>

  <comment type="line">// Must be called with the decode monitor held.</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>IsSeeking</name><argument_list>()</argument_list></macro> const <block>{
    <expr><call><name><name>mDecoder</name>-&gt;<name>GetMonitor</name></name><argument_list>()</argument_list></call>.<call><name>AssertCurrentThreadIn</name><argument_list>()</argument_list></call></expr>;

    <return>return <expr><name>mState</name> == <name>nsBuiltinDecoderStateMachine</name>::<name>DECODER_STATE_SEEKING</name></expr>;</return>
  }</block></expr></expr_stmt>

  <comment type="line">// Functions used by assertions to ensure we're calling things</comment>
  <comment type="line">// on the appropriate threads.</comment>
  <function><type><name>PRBool</name></type> <name>OnAudioThread</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><call><name>IsCurrentThread</name><argument_list>(<argument><expr><name>mAudioThread</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <function><type><name>PRBool</name></type> <name>OnStateMachineThread</name><parameter_list>()</parameter_list> <block>{
    <return>return <expr><call><name><name>mDecoder</name>-&gt;<name>OnStateMachineThread</name></name><argument_list>()</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="line">// Decode loop, called on the decode thread.</comment>
  <function_decl><type><name>void</name></type> <name>DecodeLoop</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// The decoder object that created this state machine. The decoder</comment>
  <comment type="line">// always outlives us since it controls our lifetime. This is accessed</comment>
  <comment type="line">// read only on the AV, state machine, audio and main thread.</comment>
  <decl_stmt><decl><type><name>nsBuiltinDecoder</name>*</type> <name>mDecoder</name></decl>;</decl_stmt>

  <comment type="line">// The decoder monitor must be obtained before modifying this state.</comment>
  <comment type="line">// NotifyAll on the monitor must be called when the state is changed by</comment>
  <comment type="line">// the main thread so the decoder thread can wake up.</comment>
  <comment type="line">// Accessed on state machine, audio, main, and AV thread. </comment>
  <decl_stmt><decl><type><name>State</name></type> <name>mState</name></decl>;</decl_stmt>

  <function><type><name>nsresult</name></type> <name>GetBuffered</name><parameter_list>(<param><decl><type><name>nsTimeRanges</name>*</type> <name>aBuffered</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>NS_IsMainThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only call on main thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>mReader</name>-&gt;<name>GetBuffered</name></name><argument_list>(<argument><expr><name>aBuffered</name></expr></argument>, <argument><expr><name>mStartTime</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <function><type><name>void</name></type> <name>NotifyDataArrived</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>aBuffer</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aLength</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aOffset</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>NS_IsMainThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only call on main thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mReader</name>-&gt;<name>NotifyDataArrived</name></name><argument_list>(<argument><expr><name>aBuffer</name></expr></argument>, <argument><expr><name>aLength</name></expr></argument>, <argument><expr><name>aOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <expr_stmt><expr><name>PRInt64</name> <macro><name>GetEndMediaTime</name><argument_list>()</argument_list></macro> const <block>{
    <expr><call><name><name>mDecoder</name>-&gt;<name>GetMonitor</name></name><argument_list>()</argument_list></call>.<call><name>AssertCurrentThreadIn</name><argument_list>()</argument_list></call></expr>;
    <return>return <expr><name>mEndTime</name></expr>;</return>
  }</block></expr></expr_stmt>

  <function_decl><type><name>void</name></type> <name>NotifyDataExhausted</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>protected</name>:</label>

  <comment type="line">// Returns PR_TRUE if the decode is withing an estimated one tenth of a</comment>
  <comment type="line">// second's worth of data of the download, i.e. the decode has almost</comment>
  <comment type="line">// caught up with the download. If we can't estimate one tenth of a second's</comment>
  <comment type="line">// worth of data, we'll return PR_TRUE if the decode is within 100KB of</comment>
  <comment type="line">// the download.</comment>
  <function_decl><type><name>PRBool</name></type> <name>IsDecodeCloseToDownload</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Returns the number of unplayed ms of audio we've got decoded and/or</comment>
  <comment type="line">// pushed to the hardware waiting to play. This is how much audio we can</comment>
  <comment type="line">// play without having to run the audio decoder.</comment>
  <expr_stmt><expr><name>PRInt64</name> <macro><name>AudioDecodedMs</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>

  <comment type="line">// Returns PR_TRUE when there's decoded audio waiting to play.</comment>
  <comment type="line">// The decoder monitor must be held.</comment>
  <expr_stmt><expr><name>PRBool</name> <macro><name>HasFutureAudio</name><argument_list>()</argument_list></macro> const</expr>;</expr_stmt>

  <comment type="line">// Waits on the decoder Monitor for aMs. If the decoder monitor is awoken</comment>
  <comment type="line">// by a Notify() call, we'll continue waiting, unless we've moved into</comment>
  <comment type="line">// shutdown state. This enables us to ensure that we wait for a specified</comment>
  <comment type="line">// time, and that the myriad of Notify()s we do an the decoder monitor</comment>
  <comment type="line">// don't cause the audio thread to be starved. The decoder monitor must</comment>
  <comment type="line">// be locked.</comment>
  <function_decl><type><name>void</name></type> <name>Wait</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aMs</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Dispatches an asynchronous event to update the media element's ready state.</comment>
  <function_decl><type><name>void</name></type> <name>UpdateReadyState</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Resets playback timing data. Called when we seek, on the state machine</comment>
  <comment type="line">// thread.</comment>
  <function_decl><type><name>void</name></type> <name>ResetPlayback</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Returns the audio clock, if we have audio, or -1 if we don't.</comment>
  <comment type="line">// Called on the state machine thread.</comment>
  <function_decl><type><name>PRInt64</name></type> <name>GetAudioClock</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Returns the presentation time of the first sample or frame in the media.</comment>
  <comment type="line">// If the media has video, it returns the first video frame. The decoder</comment>
  <comment type="line">// monitor must be held with exactly one lock count. Called on the state</comment>
  <comment type="line">// machine thread.</comment>
  <function_decl><type><name>VideoData</name>*</type> <name>FindStartTime</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Finds the end time of the last frame of data in the file, storing the value</comment>
  <comment type="line">// in mEndTime if successful. The decoder must be held with exactly one lock</comment>
  <comment type="line">// count. Called on the state machine thread.</comment>
  <function_decl><type><name>void</name></type> <name>FindEndTime</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Performs YCbCr to RGB conversion, and pushes the image down the</comment>
  <comment type="line">// rendering pipeline. Called on the state machine thread.</comment>
  <function_decl><type><name>void</name></type> <name>RenderVideoFrame</name><parameter_list>(<param><decl><type><name>VideoData</name>*</type> <name>aData</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// If we have video, display a video frame if it's time for display has</comment>
  <comment type="line">// arrived, otherwise sleep until it's time for the next sample. Update</comment>
  <comment type="line">// the current frame time as appropriate, and trigger ready state update.</comment>
  <comment type="line">// The decoder monitor must be held with exactly one lock count. Called</comment>
  <comment type="line">// on the state machine thread.</comment>
  <function_decl><type><name>void</name></type> <name>AdvanceFrame</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Pushes up to aSamples samples of silence onto the audio hardware. Returns</comment>
  <comment type="line">// the number of samples acutally pushed to the hardware. This pushes up to</comment>
  <comment type="line">// 32KB worth of samples to the hardware before returning, so must be called</comment>
  <comment type="line">// in a loop to ensure that the desired number of samples are pushed to the</comment>
  <comment type="line">// hardware. This ensures that the playback position advances smoothly, and</comment>
  <comment type="line">// guarantees that we don't try to allocate an impossibly large chunk of</comment>
  <comment type="line">// memory in order to play back silence. Called on the audio thread.</comment>
  <function_decl><type><name>PRUint32</name></type> <name>PlaySilence</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aSamples</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aChannels</name></decl></param>,
                       <param><decl><type><name>PRUint64</name></type> <name>aSampleOffset</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Pops an audio chunk from the front of the audio queue, and pushes its</comment>
  <comment type="line">// sound data to the audio hardware. MozAudioAvailable sample data is also</comment>
  <comment type="line">// queued here. Called on the audio thread.</comment>
  <function_decl><type><name>PRUint32</name></type> <name>PlayFromAudioQueue</name><parameter_list>(<param><decl><type><name>PRUint64</name></type> <name>aSampleOffset</name></decl></param>, <param><decl><type><name>PRUint32</name></type> <name>aChannels</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Stops the decode threads. The decoder monitor must be held with exactly</comment>
  <comment type="line">// one lock count. Called on the state machine thread.</comment>
  <function_decl><type><name>void</name></type> <name>StopDecodeThreads</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Starts the decode threads. The decoder monitor must be held with exactly</comment>
  <comment type="line">// one lock count. Called on the state machine thread.</comment>
  <function_decl><type><name>nsresult</name></type> <name>StartDecodeThreads</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// The main loop for the audio thread. Sent to the thread as</comment>
  <comment type="line">// an nsRunnableMethod. This continually does blocking writes to</comment>
  <comment type="line">// to audio stream to play audio data.</comment>
  <function_decl><type><name>void</name></type> <name>AudioLoop</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Stop or pause playback of media. This has two modes, denoted by</comment>
  <comment type="line">// aMode being either AUDIO_PAUSE or AUDIO_SHUTDOWN.</comment>
  <comment type="line">//</comment>
  <comment type="line">// AUDIO_PAUSE: Suspends the audio stream to be resumed later.</comment>
  <comment type="line">// This does not close the OS based audio stream </comment>
  <comment type="line">//</comment>
  <comment type="line">// AUDIO_SHUTDOWN: Closes and destroys the audio stream and</comment>
  <comment type="line">// releases any OS resources.</comment>
  <comment type="line">//</comment>
  <comment type="line">// The decoder monitor must be held with exactly one lock count. Called</comment>
  <comment type="line">// on the state machine thread.</comment>
  <enum>enum <name>eStopMode</name> <block>{<decl><name>AUDIO_PAUSE</name></decl>, <decl><name>AUDIO_SHUTDOWN</name></decl>}</block>;</enum>
  <function_decl><type><name>void</name></type> <name>StopPlayback</name><parameter_list>(<param><decl><type><name>eStopMode</name></type> <name>aMode</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Resume playback of media. Must be called with the decode monitor held.</comment>
  <comment type="line">// This resumes a paused audio stream. The decoder monitor must be held with</comment>
  <comment type="line">// exactly one lock count. Called on the state machine thread.</comment>
  <function_decl><type><name>void</name></type> <name>StartPlayback</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Returns PR_TRUE if we're currently playing. The decoder monitor must</comment>
  <comment type="line">// be held.</comment>
  <function_decl><type><name>PRBool</name></type> <name>IsPlaying</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Returns the "media time". This is the absolute time which the media</comment>
  <comment type="line">// playback has reached. i.e. this returns values in the range</comment>
  <comment type="line">// [mStartTime, mEndTime], and mStartTime will not be 0 if the media does</comment>
  <comment type="line">// not start at 0. Note this is different to the value returned</comment>
  <comment type="line">// by GetCurrentTime(), which is in the range [0,duration].</comment>
  <expr_stmt><expr><name>PRInt64</name> <macro><name>GetMediaTime</name><argument_list>()</argument_list></macro> const <block>{
    <expr><call><name><name>mDecoder</name>-&gt;<name>GetMonitor</name></name><argument_list>()</argument_list></call>.<call><name>AssertCurrentThreadIn</name><argument_list>()</argument_list></call></expr>;
    <return>return <expr><name>mStartTime</name> + <name>mCurrentFrameTime</name></expr>;</return>
  }</block></expr></expr_stmt>

  <comment type="line">// Returns an upper bound on the number of milliseconds of audio that is</comment>
  <comment type="line">// decoded and playable. This is the sum of the number of ms of audio which</comment>
  <comment type="line">// is decoded and in the reader's audio queue, and the ms of unplayed audio</comment>
  <comment type="line">// which has been pushed to the audio hardware for playback. Note that after</comment>
  <comment type="line">// calling this, the audio hardware may play some of the audio pushed to</comment>
  <comment type="line">// hardware, so this can only be used as a upper bound. The decoder monitor</comment>
  <comment type="line">// must be held when calling this. Called on the decoder thread.</comment>
  <function_decl><type><name>PRInt64</name></type> <name>GetDecodedAudioDuration</name><parameter_list>()</parameter_list>;</function_decl>

  <comment type="line">// Monitor on mAudioStream. This monitor must be held in order to delete</comment>
  <comment type="line">// or use the audio stream. This stops us destroying the audio stream</comment>
  <comment type="line">// while it's being used on another thread (typically when it's being</comment>
  <comment type="line">// written to on the audio thread).</comment>
  <decl_stmt><decl><type><name>Monitor</name></type> <name>mAudioMonitor</name></decl>;</decl_stmt>

  <comment type="line">// The size of the decoded YCbCr frame.</comment>
  <comment type="line">// Accessed on state machine thread.</comment>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>mCbCrSize</name></decl>;</decl_stmt>

  <comment type="line">// Accessed on state machine thread.</comment>
  <expr_stmt><expr><name>nsAutoArrayPtr</name>&lt;<name>unsigned</name> <name>char</name>&gt; <name>mCbCrBuffer</name></expr>;</expr_stmt>

  <comment type="line">// Thread for pushing audio onto the audio hardware.</comment>
  <comment type="line">// The "audio push thread".</comment>
  <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIThread</name>&gt; <name>mAudioThread</name></expr>;</expr_stmt>

  <comment type="line">// Thread for decoding video in background. The "decode thread".</comment>
  <expr_stmt><expr><name>nsCOMPtr</name>&lt;<name>nsIThread</name>&gt; <name>mDecodeThread</name></expr>;</expr_stmt>

  <comment type="line">// The time that playback started from the system clock. This is used</comment>
  <comment type="line">// for timing the display of audio frames when there's no audio.</comment>
  <comment type="line">// Accessed only via the state machine thread.</comment>
  <decl_stmt><decl><type><name>TimeStamp</name></type> <name>mPlayStartTime</name></decl>;</decl_stmt>

  <comment type="line">// The amount of time we've spent playing already the media. The current</comment>
  <comment type="line">// playback position is therefore (mPlayDuration + (now - mPlayStartTime)).</comment>
  <comment type="line">// Accessed only via the state machine thread.</comment>
  <decl_stmt><decl><type><name>TimeDuration</name></type> <name>mPlayDuration</name></decl>;</decl_stmt>

  <comment type="line">// Time that buffering started. Used for buffering timeout and only</comment>
  <comment type="line">// accessed on the state machine thread. This is null while we're not</comment>
  <comment type="line">// buffering.</comment>
  <decl_stmt><decl><type><name>TimeStamp</name></type> <name>mBufferingStart</name></decl>;</decl_stmt>

  <comment type="line">// Download position where we should stop buffering. Only</comment>
  <comment type="line">// accessed on the state machine thread. This is -1 while we're not</comment>
  <comment type="line">// buffering.</comment>
  <decl_stmt><decl><type><name>PRInt64</name></type> <name>mBufferingEndOffset</name></decl>;</decl_stmt>

  <comment type="line">// Start time of the media, in milliseconds. This is the presentation</comment>
  <comment type="line">// time of the first sample decoded from the media, and is used to calculate</comment>
  <comment type="line">// duration and as a bounds for seeking. Accessed on state machine and</comment>
  <comment type="line">// main thread. Access controlled by decoder monitor.</comment>
  <decl_stmt><decl><type><name>PRInt64</name></type> <name>mStartTime</name></decl>;</decl_stmt>

  <comment type="line">// Time of the last page in the media, in milliseconds. This is the</comment>
  <comment type="line">// end time of the last sample in the media. Accessed on state</comment>
  <comment type="line">// machine and main thread. Access controlled by decoder monitor.</comment>
  <decl_stmt><decl><type><name>PRInt64</name></type> <name>mEndTime</name></decl>;</decl_stmt>

  <comment type="line">// Position to seek to in milliseconds when the seek state transition occurs.</comment>
  <comment type="line">// The decoder monitor lock must be obtained before reading or writing</comment>
  <comment type="line">// this value. Accessed on main and state machine thread.</comment>
  <decl_stmt><decl><type><name>PRInt64</name></type> <name>mSeekTime</name></decl>;</decl_stmt>

  <comment type="line">// The audio stream resource. Used on the state machine, audio, and main</comment>
  <comment type="line">// threads. You must hold the mAudioMonitor, and must NOT hold the decoder</comment>
  <comment type="line">// monitor when using the audio stream!</comment>
  <expr_stmt><expr><name>nsRefPtr</name>&lt;<name>nsAudioStream</name>&gt; <name>mAudioStream</name></expr>;</expr_stmt>

  <comment type="line">// The reader, don't call its methods with the decoder monitor held.</comment>
  <comment type="line">// This is created in the play state machine's constructor, and destroyed</comment>
  <comment type="line">// in the play state machine's destructor.</comment>
  <expr_stmt><expr><name>nsAutoPtr</name>&lt;<name>nsBuiltinDecoderReader</name>&gt; <name>mReader</name></expr>;</expr_stmt>

  <comment type="line">// The time of the current frame in milliseconds. This is referenced from</comment>
  <comment type="line">// 0 which is the initial playback position. Set by the state machine</comment>
  <comment type="line">// thread, and read-only from the main thread to get the current</comment>
  <comment type="line">// time value. Synchronised via decoder monitor.</comment>
  <decl_stmt><decl><type><name>PRInt64</name></type> <name>mCurrentFrameTime</name></decl>;</decl_stmt>

  <comment type="line">// The presentation time of the first audio sample that was played. We can</comment>
  <comment type="line">// add this to the audio stream position to determine the current audio time.</comment>
  <comment type="line">// Accessed on audio and state machine thread. Synchronized by decoder monitor.</comment>
  <decl_stmt><decl><type><name>PRInt64</name></type> <name>mAudioStartTime</name></decl>;</decl_stmt>

  <comment type="line">// The end time of the last audio sample that's been pushed onto the audio</comment>
  <comment type="line">// hardware. This will approximately be the end time of the audio stream,</comment>
  <comment type="line">// unless another sample is pushed to the hardware.</comment>
  <decl_stmt><decl><type><name>PRInt64</name></type> <name>mAudioEndTime</name></decl>;</decl_stmt>

  <comment type="line">// The presentation end time of the last video frame which has been displayed.</comment>
  <comment type="line">// Accessed from the state machine thread.</comment>
  <decl_stmt><decl><type><name>PRInt64</name></type> <name>mVideoFrameEndTime</name></decl>;</decl_stmt>
  
  <comment type="line">// Volume of playback. 0.0 = muted. 1.0 = full volume. Read/Written</comment>
  <comment type="line">// from the state machine and main threads. Synchronised via decoder</comment>
  <comment type="line">// monitor.</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>mVolume</name></decl>;</decl_stmt>

  <comment type="line">// PR_TRUE if the media resource can be seeked. Accessed from the state</comment>
  <comment type="line">// machine and main threads. Synchronised via decoder monitor.</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mSeekable</name></decl>;</decl_stmt>

  <comment type="line">// PR_TRUE if an event to notify about a change in the playback</comment>
  <comment type="line">// position has been queued, but not yet run. It is set to PR_FALSE when</comment>
  <comment type="line">// the event is run. This allows coalescing of these events as they can be</comment>
  <comment type="line">// produced many times per second. Synchronised via decoder monitor.</comment>
  <comment type="line">// Accessed on main and state machine threads.</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mPositionChangeQueued</name></decl>;</decl_stmt>

  <comment type="line">// PR_TRUE if the audio playback thread has finished. It is finished</comment>
  <comment type="line">// when either all the audio samples in the Vorbis bitstream have completed</comment>
  <comment type="line">// playing, or we've moved into shutdown state, and the threads are to be</comment>
  <comment type="line">// destroyed. Written by the audio playback thread and read and written by</comment>
  <comment type="line">// the state machine thread. Synchronised via decoder monitor.</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mAudioCompleted</name></decl>;</decl_stmt>

  <comment type="line">// PR_TRUE if mDuration has a value obtained from an HTTP header, or from</comment>
  <comment type="line">// the media index/metadata. Accessed on the state machine thread.</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mGotDurationFromMetaData</name></decl>;</decl_stmt>
    
  <comment type="line">// PR_FALSE while decode threads should be running. Accessed on audio, </comment>
  <comment type="line">// state machine and decode threads. Syncrhonised by decoder monitor.</comment>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mStopDecodeThreads</name></decl>;</decl_stmt>

<label><name>private</name>:</label>
  <comment type="line">// Manager for queuing and dispatching MozAudioAvailable events.  The</comment>
  <comment type="line">// event manager is accessed from the state machine and audio threads,</comment>
  <comment type="line">// and takes care of synchronizing access to its internal queue.</comment>
  <decl_stmt><decl><type><name>nsAudioAvailableEventManager</name></type> <name>mEventManager</name></decl>;</decl_stmt>
};

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
