<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="00172fa01676abbabf68571274e54db6e9cc37a9.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is
 * Netscape Communications Corporation.
 * Portions created by the Initial Developer are Copyright (C) 1998
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Brian Ryner &lt;bryner@brianryner.com&gt;
 *   Javier Delgadillo &lt;javi@netscape.com&gt;
 *   Kai Engert &lt;kengert@redhat.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNSSComponent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNSSIOLayer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNSSCallbacks.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prnetdb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPrompt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPrefService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIPrefBranch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIServiceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIWebProgressListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIChannel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNSSCertificate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIX509CertValidity.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIProxyObjectManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsProxiedService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDateTimeFormat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsDateTimeFormatCID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIClientAuthDialogs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsICertOverrideService.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIBadCertListener2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsRecentBadCerts.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsXPIDLString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsReadableUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsHashSets.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsCRT.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsPrintfCString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsAutoLock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSSLThread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNSSShutDown.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsSSLStatus.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNSSCertHelper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsNSSCleaner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsThreadUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIDocShell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsISecureBrowserUI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsProxyRelease.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ssl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"secerr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sslerr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"secder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"secasn1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"certdb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"keyhi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"secport.h"</cpp:file></cpp:include>


<comment type="line">//#define DEBUG_SSL_VERBOSE //Enable this define to get minimal </comment>
                            <comment type="line">//reports when doing SSL read/write</comment>
                            
<comment type="line">//#define DUMP_BUFFER  //Enable this define along with</comment>
                       <comment type="line">//DEBUG_SSL_VERBOSE to dump SSL</comment>
                       <comment type="line">//read/write buffer to a log.</comment>
                       <comment type="line">//Uses PR_LOG except on Mac where</comment>
                       <comment type="line">//we always write out to our own</comment>
                       <comment type="line">//file.</comment>

<macro><name>NSSCleanupAutoPtrClass</name><argument_list>(<argument>CERTCertificate</argument>, <argument>CERT_DestroyCertificate</argument>)</argument_list></macro>
<macro><name>NSSCleanupAutoPtrClass</name><argument_list>(<argument>char</argument>, <argument>PR_FREEIF</argument>)</argument_list></macro>
<macro><name>NSSCleanupAutoPtrClass_WithParam</name><argument_list>(<argument>PRArenaPool</argument>, <argument>PORT_FreeArena</argument>, <argument>FalseParam</argument>, <argument>PR_FALSE</argument>)</argument_list></macro>

<comment type="block">/* SSM_UserCertChoice: enum for cert choice info */</comment>
<typedef>typedef <type><enum>enum <block>{<decl><name>ASK</name></decl>, <decl><name>AUTO</name></decl>}</block></enum></type> <name>SSM_UserCertChoice</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>SECStatus</name> <name>PR_CALLBACK</name></type>
<name>nsNSS_SSLGetClientAuthData</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>PRFileDesc</name> *</type><name>socket</name></decl></param>,
						   <param><decl><type><name>CERTDistNames</name> *</type><name>caNames</name></decl></param>,
						   <param><decl><type><name>CERTCertificate</name> **</type><name>pRetCert</name></decl></param>,
						   <param><decl><type><name>SECKEYPrivateKey</name> **</type><name>pRetKey</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SECStatus</name> <name>PR_CALLBACK</name></type>
<name>nsNSS_SSLGetClientAuthData</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>PRFileDesc</name> *</type><name>socket</name></decl></param>,
						   <param><decl><type><name>CERTDistNames</name> *</type><name>caNames</name></decl></param>,
						   <param><decl><type><name>CERTCertificate</name> **</type><name>pRetCert</name></decl></param>,
						   <param><decl><type><name>SECKEYPrivateKey</name> **</type><name>pRetKey</name></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOGGING</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PRLogModuleInfo</name>*</type> <name>gPIPNSSLog</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SSL_VERBOSE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name> <argument_list>(<argument><expr><name>XP_MAC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PR_LOG</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PR_LOG</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>PRFileDesc</name> *</type><name>gMyLogFile</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAC_LOG_FILE</name></cpp:macro> <cpp:value>"MAC PIPNSS Log File"</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>MyLogFunction</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
  
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>gMyLogFile</name> == <name>nsnull</name></expr>)</condition><then>
    <expr_stmt><expr><name>gMyLogFile</name> = <call><name>PR_Open</name><argument_list>(<argument><expr><name>MAC_LOG_FILE</name></expr></argument>, <argument><expr><name>PR_WRONLY</name> | <name>PR_CREATE_FILE</name> | <name>PR_APPEND</name></expr></argument>,
                         <argument><expr>0600</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr>!<name>gMyLogFile</name></expr>)</condition><then>
      <return>return;</return></then></if>
  <expr_stmt><expr><call><name>PR_vfprintf</name><argument_list>(<argument><expr><name>gMyLogFile</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PR_LOG</name><parameter_list>(<param><type><name>module</name></type></param>,<param><type><name>level</name></type></param>,<param><type><name>args</name></type></param>)</parameter_list></cpp:macro> <cpp:value>MyLogFunction args</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<constructor><name><name>nsSSLSocketThreadData</name>::<name>nsSSLSocketThreadData</name></name><parameter_list>()</parameter_list>
<member_list>: <call><name>mSSLState</name><argument_list>(<argument><expr><name>ssl_idle</name></expr></argument>)</argument_list></call>
, <call><name>mPRErrorCode</name><argument_list>(<argument><expr><name>PR_SUCCESS</name></expr></argument>)</argument_list></call>
, <call><name>mSSLDataBuffer</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
, <call><name>mSSLDataBufferAllocatedSize</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
, <call><name>mSSLRequestedTransferAmount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
, <call><name>mSSLRemainingReadResultData</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
, <call><name>mSSLResultRemainingBytes</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
, <call><name>mReplacedSSLFileDesc</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
, <call><name>mOneBytePendingFromEarlierWrite</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
, <call><name>mThePendingByte</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
, <call><name>mOriginalRequestedTransferAmount</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
</member_list><block>{
}</block></constructor>

<destructor><name><name>nsSSLSocketThreadData</name>::~<name>nsSSLSocketThreadData</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mSSLState</name> != <name>ssl_pending_write</name>
               &amp;&amp;
               <name>mSSLState</name> != <name>ssl_pending_read</name></expr></argument>, 
               <argument><expr>"oops??? ssl socket is not idle at the time it is being destroyed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>PRBool</name></type> <name><name>nsSSLSocketThreadData</name>::<name>ensure_buffer_size</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>amount</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>amount</name> &gt; <name>mSSLDataBufferAllocatedSize</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>mSSLDataBuffer</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>mSSLDataBuffer</name> = (<name>char</name>*)<call><name><name>nsMemory</name>::<name>Realloc</name></name><argument_list>(<argument><expr><name>mSSLDataBuffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>mSSLDataBuffer</name> = (<name>char</name>*)<call><name><name>nsMemory</name>::<name>Alloc</name></name><argument_list>(<argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    
    <if>if <condition>(<expr>!<name>mSSLDataBuffer</name></expr>)</condition><then>
      <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

    <expr_stmt><expr><name>mSSLDataBufferAllocatedSize</name> = <name>amount</name></expr>;</expr_stmt>
  }</block></then></if>
  
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<constructor><name><name>nsNSSSocketInfo</name>::<name>nsNSSSocketInfo</name></name><parameter_list>()</parameter_list>
  <member_list>: <call><name>mFd</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>,
    <call><name>mBlockingState</name><argument_list>(<argument><expr><name>blocking_state_unknown</name></expr></argument>)</argument_list></call>,
    <call><name>mSecurityState</name><argument_list>(<argument><expr><name><name>nsIWebProgressListener</name>::<name>STATE_IS_INSECURE</name></name></expr></argument>)</argument_list></call>,
    <call><name>mExternalErrorReporting</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mForSTARTTLS</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mHandshakePending</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>,
    <call><name>mCanceled</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mHasCleartextPhase</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mHandshakeInProgress</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>,
    <call><name>mAllowTLSIntoleranceTimeout</name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call>,
    <call><name>mHandshakeStartTime</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
    <call><name>mPort</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>,
    <call><name>mCAChain</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><name>mThreadData</name> = new <name>nsSSLSocketThreadData</name></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>nsNSSSocketInfo</name>::~<name>nsNSSSocketInfo</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr>delete <name>mThreadData</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>isAlreadyShutDown</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>

  <expr_stmt><expr><call><name>destructorSafeDestroyNSSReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name>calledFromObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>void</name></type> <name><name>nsNSSSocketInfo</name>::<name>virtualDestroyNSSReference</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>destructorSafeDestroyNSSReference</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name><name>nsNSSSocketInfo</name>::<name>destructorSafeDestroyNSSReference</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>isAlreadyShutDown</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>

  <if>if <condition>(<expr><name>mCAChain</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>CERT_DestroyCertList</name><argument_list>(<argument><expr><name>mCAChain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCAChain</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<macro><name>NS_IMPL_THREADSAFE_ISUPPORTS5</name><argument_list>(<argument>nsNSSSocketInfo</argument>,
                              <argument>nsITransportSecurityInfo</argument>,
                              <argument>nsISSLSocketControl</argument>,
                              <argument>nsIInterfaceRequestor</argument>,
                              <argument>nsISSLStatusProvider</argument>,
                              <argument>nsIIdentityInfo</argument>)</argument_list></macro>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>GetHandshakePending</name></name><parameter_list>(<param><decl><type><name>PRBool</name> *</type><name>aHandshakePending</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aHandshakePending</name> = <name>mHandshakePending</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>SetHandshakePending</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aHandshakePending</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mHandshakePending</name> = <name>aHandshakePending</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>SetHostName</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>host</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>mHostName</name>.<name>Adopt</name></name><argument_list>(<argument><expr><name>host</name> ? <call><name><name>nsCRT</name>::<name>strdup</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call> : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>GetHostName</name></name><parameter_list>(<param><decl><type><name>char</name> **</type><name>host</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>host</name> = (<name>mHostName</name>) ? <call><name><name>nsCRT</name>::<name>strdup</name></name><argument_list>(<argument><expr><name>mHostName</name></expr></argument>)</argument_list></call> : <name>nsnull</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>SetPort</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>aPort</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mPort</name> = <name>aPort</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>GetPort</name></name><parameter_list>(<param><decl><type><name>PRInt32</name> *</type><name>aPort</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aPort</name> = <name>mPort</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsNSSSocketInfo</name>::<name>SetCanceled</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aCanceled</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mCanceled</name> = <name>aCanceled</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsNSSSocketInfo</name>::<name>GetCanceled</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><name>mCanceled</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsNSSSocketInfo</name>::<name>SetHasCleartextPhase</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aHasCleartextPhase</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mHasCleartextPhase</name> = <name>aHasCleartextPhase</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsNSSSocketInfo</name>::<name>GetHasCleartextPhase</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><name>mHasCleartextPhase</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsNSSSocketInfo</name>::<name>GetNotificationCallbacks</name></name><parameter_list>(<param><decl><type><name>nsIInterfaceRequestor</name>**</type> <name>aCallbacks</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aCallbacks</name> = <name>mCallbacks</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>aCallbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsNSSSocketInfo</name>::<name>SetNotificationCallbacks</name></name><parameter_list>(<param><decl><type><name>nsIInterfaceRequestor</name>*</type> <name>aCallbacks</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>aCallbacks</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mCallbacks</name> = <name>nsnull</name></expr>;</expr_stmt>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIInterfaceRequestor</name></expr></argument>&gt;</argument_list></name></type> <name>proxiedCallbacks</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_GetProxyForObject</name><argument_list>(<argument><expr><name>NS_PROXY_TO_MAIN_THREAD</name></expr></argument>,
                       <argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIInterfaceRequestor</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIInterfaceRequestor</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>aCallbacks</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>NS_PROXY_SYNC</name></expr></argument>,
                       <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>proxiedCallbacks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mCallbacks</name> = <name>proxiedCallbacks</name></expr>;</expr_stmt>

  <comment type="line">// Are we running within a context that wants external SSL error reporting?</comment>
  <comment type="line">// We'll look at the presence of a security UI object inside docshell.</comment>
  <comment type="line">// If the docshell wants the lock icon, you'll get the ssl error pages, too.</comment>
  <comment type="line">// This is helpful to distinguish from all other contexts, like mail windows,</comment>
  <comment type="line">// or any other SSL connections running in the background.</comment>
  <comment type="line">// We must query it now and remember, because fatal SSL errors will come </comment>
  <comment type="line">// with a socket close, and the socket transport might detach the callbacks </comment>
  <comment type="line">// instance prior to our error reporting.</comment>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShell</name></expr></argument>&gt;</argument_list></name></type> <name>docshell</name><argument_list>(<argument><expr><call><name>do_GetInterface</name><argument_list>(<argument><expr><name>mCallbacks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>docshell</name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIDocShell</name></expr></argument>&gt;</argument_list></name></type> <name>proxiedDocShell</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>NS_GetProxyForObject</name><argument_list>(<argument><expr><name>NS_PROXY_TO_MAIN_THREAD</name></expr></argument>,
                         <argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIDocShell</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name><name>docshell</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><name>NS_PROXY_SYNC</name></expr></argument>,
                         <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>proxiedDocShell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsISecureBrowserUI</name>*</type> <name>secureUI</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>proxiedDocShell</name>-&gt;<name>GetSecurityUI</name></name><argument_list>(<argument><expr>&amp;<name>secureUI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>secureUI</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIThread</name></expr></argument>&gt;</argument_list></name></type> <name>mainThread</name><argument_list>(<argument><expr><call><name>do_GetMainThread</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>NS_ProxyRelease</name><argument_list>(<argument><expr><name>mainThread</name></expr></argument>, <argument><expr><name>secureUI</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mExternalErrorReporting</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>GetExternalErrorReporting</name></name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>state</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>state</name> = <name>mExternalErrorReporting</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>SetExternalErrorReporting</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aState</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mExternalErrorReporting</name> = <name>aState</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsNSSSocketInfo</name>::<name>GetSecurityState</name></name><parameter_list>(<param><decl><type><name>PRUint32</name>*</type> <name>state</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>state</name> = <name>mSecurityState</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>SetSecurityState</name></name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aState</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mSecurityState</name> = <name>aState</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsNSSSocketInfo</name>::<name>GetShortSecurityDescription</name></name><parameter_list>(<param><decl><type><name>PRUnichar</name>**</type> <name>aText</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><call><name><name>mShortDesc</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr>*<name>aText</name> = <name>nsnull</name></expr>;</expr_stmt></then>
  <else>else <block>{
    <expr_stmt><expr>*<name>aText</name> = <call><name>ToNewUnicode</name><argument_list>(<argument><expr><name>mShortDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>*<name>aText</name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>SetShortSecurityDescription</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aText</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name><name>mShortDesc</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>aText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsNSSSocketInfo</name>::<name>GetErrorMessage</name></name><parameter_list>(<param><decl><type><name>PRUnichar</name>**</type> <name>aText</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><call><name><name>mErrorMessage</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr>*<name>aText</name> = <name>nsnull</name></expr>;</expr_stmt></then>
  <else>else <block>{
    <expr_stmt><expr>*<name>aText</name> = <call><name>ToNewUnicode</name><argument_list>(<argument><expr><name>mErrorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ENSURE_TRUE</name><argument_list>(<argument><expr>*<name>aText</name></expr></argument>, <argument><expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>SetErrorMessage</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>PRUnichar</name>*</type> <name>aText</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name><name>mErrorMessage</name>.<name>Assign</name></name><argument_list>(<argument><expr><name>aText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* void getInterface (in nsIIDRef uuid, [iid_is (uuid), retval] out nsQIResult result); */</comment>
<function><type><name>NS_IMETHODIMP</name></type> <name><name>nsNSSSocketInfo</name>::<name>GetInterface</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIID</name> &amp;</type> <name>uuid</name></decl></param>, <param><decl><type><name>void</name> * *</type><name>result</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>mCallbacks</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIInterfaceRequestor</name></expr></argument>&gt;</argument_list></name></type> <name>ir</name> <init>= <expr>new <call><name>PipUIContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>ir</name></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name><name>ir</name>-&gt;<name>GetInterface</name></name><argument_list>(<argument><expr><name>uuid</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <comment type="line">// Proxy of the channel callbacks should probably go here, rather</comment>
    <comment type="line">// than in the password callback code</comment>

    <expr_stmt><expr><name>rv</name> = <call><name><name>mCallbacks</name>-&gt;<name>GetInterface</name></name><argument_list>(<argument><expr><name>uuid</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsNSSSocketInfo</name>::<name>GetForceHandshake</name></name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>forceHandshake</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>forceHandshake</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsNSSSocketInfo</name>::<name>SetForceHandshake</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>forceHandshake</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>(<name>void</name>)<name>forceHandshake</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>GetForSTARTTLS</name></name><parameter_list>(<param><decl><type><name>PRBool</name>*</type> <name>aForSTARTTLS</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aForSTARTTLS</name> = <name>mForSTARTTLS</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name><name>nsNSSSocketInfo</name>::<name>SetForSTARTTLS</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aForSTARTTLS</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mForSTARTTLS</name> = <name>aForSTARTTLS</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsNSSSocketInfo</name>::<name>ProxyStartSSL</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><call><name>ActivateSSL</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>NS_IMETHODIMP</name></type>
<name><name>nsNSSSocketInfo</name>::<name>StartTLS</name></name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr><call><name>ActivateSSL</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsNSSSocketInfo</name>::<name>ActivateSSL</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>isAlreadyShutDown</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name><name>nsSSLThread</name>::<name>requestActivateSSL</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>rv</name></expr>;</return></then></if>

  <expr_stmt><expr><name>mHandshakePending</name> = <name>PR_TRUE</name></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsNSSSocketInfo</name>::<name>GetFileDescPtr</name></name><parameter_list>(<param><decl><type><name>PRFileDesc</name>**</type> <name>aFilePtr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>aFilePtr</name> = <name>mFd</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsNSSSocketInfo</name>::<name>SetFileDescPtr</name></name><parameter_list>(<param><decl><type><name>PRFileDesc</name>*</type> <name>aFilePtr</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mFd</name> = <name>aFilePtr</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsNSSSocketInfo</name>::<name>GetCert</name></name><parameter_list>(<param><decl><type><name>nsNSSCertificate</name>**</type> <name>_result</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>_result</name> = <name>mCert</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsNSSSocketInfo</name>::<name>SetCert</name></name><parameter_list>(<param><decl><type><name>nsNSSCertificate</name> *</type><name>aCert</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mCert</name> = <name>aCert</name></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsNSSSocketInfo</name>::<name>GetSSLStatus</name></name><parameter_list>(<param><decl><type><name>nsISupports</name>**</type> <name>_result</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>_result</name> = <name>mSSLStatus</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_IF_ADDREF</name><argument_list>(<argument><expr>*<name>_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsNSSSocketInfo</name>::<name>RememberCAChain</name></name><parameter_list>(<param><decl><type><name>CERTCertList</name> *</type><name>aCertList</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>isAlreadyShutDown</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NOT_AVAILABLE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>mCAChain</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>CERT_DestroyCertList</name><argument_list>(<argument><expr><name>mCAChain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>mCAChain</name> = <name>aCertList</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsNSSSocketInfo</name>::<name>SetSSLStatus</name></name><parameter_list>(<param><decl><type><name>nsISSLStatus</name> *</type><name>aSSLStatus</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mSSLStatus</name> = <name>aSSLStatus</name></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsNSSSocketInfo</name>::<name>SetHandshakeInProgress</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aIsIn</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mHandshakeInProgress</name> = <name>aIsIn</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mHandshakeInProgress</name> &amp;&amp; !<name>mHandshakeStartTime</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>mHandshakeStartTime</name> = <call><name>PR_IntervalNow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name><name>nsNSSSocketInfo</name>::<name>SetAllowTLSIntoleranceTimeout</name></name><parameter_list>(<param><decl><type><name>PRBool</name></type> <name>aAllow</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mAllowTLSIntoleranceTimeout</name> = <name>aAllow</name></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HANDSHAKE_TIMEOUT_SECONDS</name></cpp:macro> <cpp:value>25</cpp:value></cpp:define>

<function><type><name>PRBool</name></type> <name><name>nsNSSSocketInfo</name>::<name>HandshakeTimeout</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mHandshakeInProgress</name> || !<name>mAllowTLSIntoleranceTimeout</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <return>return <expr>(<call>(<name>PRIntervalTime</name>)<argument_list>(<argument><expr><call><name>PR_IntervalNow</name><argument_list>()</argument_list></call> - <name>mHandshakeStartTime</name></expr></argument>)</argument_list></call>
          &gt; <call><name>PR_SecondsToInterval</name><argument_list>(<argument><expr><name>HANDSHAKE_TIMEOUT_SECONDS</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsSSLIOLayerHelpers</name>::<name>Cleanup</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mTLSIntolerantSites</name></expr>)</condition><then> <block>{
    <expr_stmt><expr>delete <name>mTLSIntolerantSites</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mTLSIntolerantSites</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>mSharedPollableEvent</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>PR_DestroyPollableEvent</name><argument_list>(<argument><expr><name>mSharedPollableEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>mutex</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>PR_DestroyLock</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>getErrorMessage</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>err</name></decl></param>, 
                <param><decl><type><specifier>const</specifier> <name>nsString</name> &amp;</type><name>host</name></decl></param>,
                <param><decl><type><name>PRInt32</name></type> <name>port</name></decl></param>,
                <param><decl><type><name>PRBool</name></type> <name>externalErrorReporting</name></decl></param>,
                <param><decl><type><name>nsINSSComponent</name> *</type><name>component</name></decl></param>,
                <param><decl><type><name>nsString</name> &amp;</type><name>returnedMessage</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name><name>host</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>nsString</name></type> <name>hostWithPort</name></decl>;</decl_stmt>

    <comment type="line">// For now, hide port when it's 443 and we're reporting the error using</comment>
    <comment type="line">// external reporting. In the future a better mechanism should be used</comment>
    <comment type="line">// to make a decision about showing the port number, possibly by requiring</comment>
    <comment type="line">// the context object to implement a specific interface.</comment>
    <comment type="line">// The motivation is that Mozilla browser would like to hide the port number</comment>
    <comment type="line">// in error pages in the common case.</comment>

    <if>if <condition>(<expr><name>externalErrorReporting</name> &amp;&amp; <name>port</name> == 443</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>params</name><index>[<expr>0</expr>]</index></name> = <call><name><name>host</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>hostWithPort</name> = <name>host</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>hostWithPort</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>":"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>hostWithPort</name>.<name>AppendInt</name></name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>params</name><index>[<expr>0</expr>]</index></name> = <call><name><name>hostWithPort</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <decl_stmt><decl><type><name>nsString</name></type> <name>formattedString</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>component</name>-&gt;<name>PIPBundleFormatStringFromName</name></name><argument_list>(<argument><expr>"SSLConnectionErrorPrefix"</expr></argument>, 
                                                  <argument><expr><name>params</name></expr></argument>, <argument><expr>1</expr></argument>, 
                                                  <argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"\n\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsString</name></type> <name>explanation</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>nsNSSErrors</name>::<name>getErrorMessageFromCode</name></name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>explanation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><name>explanation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>getInvalidCertErrorMessage</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>multipleCollectedErrors</name></decl></param>, 
                           <param><decl><type><name>PRErrorCode</name></type> <name>errorCodeToReport</name></decl></param>, 
                           <param><decl><type><name>PRErrorCode</name></type> <name>errTrust</name></decl></param>, 
                           <param><decl><type><name>PRErrorCode</name></type> <name>errMismatch</name></decl></param>, 
                           <param><decl><type><name>PRErrorCode</name></type> <name>errExpired</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>nsString</name> &amp;</type><name>host</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>nsString</name> &amp;</type><name>hostWithPort</name></decl></param>,
                           <param><decl><type><name>PRInt32</name></type> <name>port</name></decl></param>,
                           <param><decl><type><name>nsIX509Cert</name>*</type> <name>ix509</name></decl></param>,
                           <param><decl><type><name>PRBool</name></type> <name>externalErrorReporting</name></decl></param>,
                           <param><decl><type><name>nsINSSComponent</name> *</type><name>component</name></decl></param>,
                           <param><decl><type><name>nsString</name> &amp;</type><name>returnedMessage</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>PRUnichar</name> *</type><name><name>params</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

  <comment type="line">// For now, hide port when it's 443 and we're reporting the error using</comment>
  <comment type="line">// external reporting. In the future a better mechanism should be used</comment>
  <comment type="line">// to make a decision about showing the port number, possibly by requiring</comment>
  <comment type="line">// the context object to implement a specific interface.</comment>
  <comment type="line">// The motivation is that Mozilla browser would like to hide the port number</comment>
  <comment type="line">// in error pages in the common case.</comment>
  
  <if>if <condition>(<expr><name>externalErrorReporting</name> &amp;&amp; <name>port</name> == 443</expr>)</condition><then>
    <expr_stmt><expr><name><name>params</name><index>[<expr>0</expr>]</index></name> = <call><name><name>host</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>params</name><index>[<expr>0</expr>]</index></name> = <call><name><name>hostWithPort</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if>

  <decl_stmt><decl><type><name>nsString</name></type> <name>formattedString</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name><name>component</name>-&gt;<name>PIPBundleFormatStringFromName</name></name><argument_list>(<argument><expr>"certErrorIntro"</expr></argument>, 
                                                <argument><expr><name>params</name></expr></argument>, <argument><expr>1</expr></argument>, 
                                                <argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"\n\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>multipleCollectedErrors</name> &amp; <name><name>nsICertOverrideService</name>::<name>ERROR_UNTRUSTED</name></name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name><name>params</name><index>[<expr>0</expr>]</index></name> = <call><name><name>host</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errorID</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIX509Cert3</name></expr></argument>&gt;</argument_list></name></type> <name>cert3</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>ix509</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>cert3</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>PRBool</name></type> <name>isSelfSigned</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><call><name><name>cert3</name>-&gt;<name>GetIsSelfSigned</name></name><argument_list>(<argument><expr>&amp;<name>isSelfSigned</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
          &amp;&amp; <name>isSelfSigned</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>errorID</name> = "certErrorTrust_SelfSigned"</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>errorID</name></expr>)</condition><then> <block>{
      <switch>switch <condition>(<expr><name>errTrust</name></expr>)</condition> <block>{
        <case>case <expr><name>SEC_ERROR_UNKNOWN_ISSUER</name></expr>:
          <expr_stmt><expr><name>errorID</name> = "certErrorTrust_UnknownIssuer"</expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name>SEC_ERROR_CA_CERT_INVALID</name></expr>:
          <expr_stmt><expr><name>errorID</name> = "certErrorTrust_CaInvalid"</expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name>SEC_ERROR_UNTRUSTED_ISSUER</name></expr>:
          <expr_stmt><expr><name>errorID</name> = "certErrorTrust_Issuer"</expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name>SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE</name></expr>:
          <expr_stmt><expr><name>errorID</name> = "certErrorTrust_ExpiredIssuer"</expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name>SEC_ERROR_UNTRUSTED_CERT</name></expr>:
        </case><default>default:
          <expr_stmt><expr><name>errorID</name> = "certErrorTrust_Untrusted"</expr>;</expr_stmt>
          <break>break;</break>
      </default>}</block></switch>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsString</name></type> <name>formattedString</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>component</name>-&gt;<name>GetPIPNSSBundleString</name></name><argument_list>(<argument><expr><name>errorID</name></expr></argument>, 
                                          <argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>multipleCollectedErrors</name> &amp; <name><name>nsICertOverrideService</name>::<name>ERROR_MISMATCH</name></name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>useSAN</name> <init>= <expr><name>PR_TRUE</name></expr></init></decl>;</decl_stmt> <comment type="line">// subject alt name extension</comment>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>multipleNames</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsString</name></type> <name>allNames</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>CERTCertificate</name> *</type><name>nssCert</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>CERTCertificateCleaner</name></type> <name>nssCertCleaner</name><parameter_list>(<param><decl><type><name>nssCert</name></type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIX509Cert2</name></expr></argument>&gt;</argument_list></name></type> <name>cert2</name> <init>= <expr><call><name>do_QueryInterface</name><argument_list>(<argument><expr><name>ix509</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>cert2</name></expr>)</condition><then>
      <expr_stmt><expr><name>nssCert</name> = <call><name><name>cert2</name>-&gt;<name>GetCert</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>!<name>nssCert</name></expr>)</condition><then>
      <expr_stmt><expr><name>useSAN</name> = <name>PR_FALSE</name></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>PRArenaPool</name> *</type><name>san_arena</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SECItem</name></type> <name>altNameExtension</name> <init>= <expr><block>{<expr><name>siBuffer</name></expr>, <expr><name>NULL</name></expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CERTGeneralName</name> *</type><name>sanNameList</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>useSAN</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <call><name>CERT_FindCertExtension</name><argument_list>(<argument><expr><name>nssCert</name></expr></argument>, <argument><expr><name>SEC_OID_X509_SUBJECT_ALT_NAME</name></expr></argument>,
                                  <argument><expr>&amp;<name>altNameExtension</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>rv</name> != <name>SECSuccess</name></expr>)</condition><then>
        <expr_stmt><expr><name>useSAN</name> = <name>PR_FALSE</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>useSAN</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>san_arena</name> = <call><name>PORT_NewArena</name><argument_list>(<argument><expr><name>DER_DEFAULT_CHUNKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>san_arena</name></expr>)</condition><then>
        <expr_stmt><expr><name>useSAN</name> = <name>PR_FALSE</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>useSAN</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>sanNameList</name> = <call><name>CERT_DecodeAltNameExtension</name><argument_list>(<argument><expr><name>san_arena</name></expr></argument>, <argument><expr>&amp;<name>altNameExtension</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>sanNameList</name></expr>)</condition><then>
        <expr_stmt><expr><name>useSAN</name> = <name>PR_FALSE</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>SECITEM_FreeItem</name><argument_list>(<argument><expr>&amp;<name>altNameExtension</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>useSAN</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>CERTGeneralName</name> *</type><name>current</name> <init>= <expr><name>sanNameList</name></expr></init></decl>;</decl_stmt>
      <do>do <block>{
        <decl_stmt><decl><type><name>nsAutoString</name></type> <name>name</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name><name>current</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
          <case>case <expr><name>certDNSName</name></expr>:
            <expr_stmt><expr><call><name><name>name</name>.<name>AssignASCII</name></name><argument_list>(<argument><expr>(<name>char</name>*)<name><name>current</name>-&gt;<name>name</name>.<name>other</name>.<name>data</name></name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>name</name>.<name>other</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>allNames</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
              <expr_stmt><expr><name>multipleNames</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name><name>allNames</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>" , "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>allNames</name>.<name>Append</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
  
          </case><case>case <expr><name>certIPAddress</name></expr>:
            <block>{
              <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>INET6_ADDRSTRLEN</name></expr>]</index></name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>PRNetAddr</name></type> <name>addr</name></decl>;</decl_stmt>
              <if>if <condition>(<expr><name><name>current</name>-&gt;<name>name</name>.<name>other</name>.<name>len</name></name> == 4</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>addr</name>.<name>inet</name>.<name>family</name></name> = <name>PR_AF_INET</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>addr</name>.<name>inet</name>.<name>ip</name></name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>name</name>.<name>other</name>.<name>data</name></name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>name</name>.<name>other</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PR_NetAddrToString</name><argument_list>(<argument><expr>&amp;<name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>name</name>.<name>AssignASCII</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then> <else>else <if>if <condition>(<expr><name><name>current</name>-&gt;<name>name</name>.<name>other</name>.<name>len</name></name> == 16</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>addr</name>.<name>ipv6</name>.<name>family</name></name> = <name>PR_AF_INET6</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>addr</name>.<name>ipv6</name>.<name>ip</name></name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>name</name>.<name>other</name>.<name>data</name></name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>name</name>.<name>other</name>.<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PR_NetAddrToString</name><argument_list>(<argument><expr>&amp;<name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>name</name>.<name>AssignASCII</name></name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then> <else>else <block>{
                <comment type="block">/* invalid IP address */</comment>
              }</block></else></if></else></if>
              <if>if <condition>(<expr>!<call><name><name>name</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name><name>allNames</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
                  <expr_stmt><expr><name>multipleNames</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name><name>allNames</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>" , "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>allNames</name>.<name>Append</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then></if>
              <break>break;</break>
            }</block>

          </case><default>default: <comment type="line">// all other types of names are ignored</comment>
            <break>break;</break>
        </default>}</block></switch>
        <expr_stmt><expr><name>current</name> = <call><name>CERT_GetNextGeneralName</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block> while <condition>(<expr><name>current</name> != <name>sanNameList</name></expr>)</condition>;</do> <comment type="line">// double linked</comment>
    }</block></then></if>
    <if>if <condition>(<expr><name>san_arena</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>PORT_FreeArena</name><argument_list>(<argument><expr><name>san_arena</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>!<name>useSAN</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>certName</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
      <comment type="line">// certName = CERT_FindNSStringExtension(nssCert, SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME);</comment>
      <if>if <condition>(<expr>!<name>certName</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>certName</name> = <call><name>CERT_GetCommonName</name><argument_list>(<argument><expr>&amp;<name><name>nssCert</name>-&gt;<name>subject</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>allNames</name>.<name>AssignASCII</name></name><argument_list>(<argument><expr><name>certName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PORT_Free</name><argument_list>(<argument><expr><name>certName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>multipleNames</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsString</name></type> <name>message</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rv</name> = <call><name><name>component</name>-&gt;<name>GetPIPNSSBundleString</name></name><argument_list>(<argument><expr>"certErrorMismatchMultiple"</expr></argument>, 
                                            <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"\n  "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><name>allNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"  \n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then>
    <else>else <block>{ <comment type="line">// !multipleNames</comment>
      <expr_stmt><expr><name><name>params</name><index>[<expr>0</expr>]</index></name> = <call><name><name>allNames</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name>nsString</name></type> <name>formattedString</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rv</name> = <call><name><name>component</name>-&gt;<name>PIPBundleFormatStringFromName</name></name><argument_list>(<argument><expr>"certErrorMismatchSingle"</expr></argument>, 
                                                    <argument><expr><name>params</name></expr></argument>, <argument><expr>1</expr></argument>, 
                                                    <argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>multipleCollectedErrors</name> &amp; <name><name>nsICertOverrideService</name>::<name>ERROR_TIME</name></name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>PRTime</name></type> <name>now</name> <init>= <expr><call><name>PR_Now</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRTime</name></type> <name>notAfter</name></decl>, <decl><type ref="prev"/><name>notBefore</name></decl>, <decl><type ref="prev"/><name>timeToUse</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIX509CertValidity</name></expr></argument>&gt;</argument_list></name></type> <name>validity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>
  
    <expr_stmt><expr><name>rv</name> = <call><name><name>ix509</name>-&gt;<name>GetValidity</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>validity</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>rv</name></expr>;</return></then></if>
  
    <expr_stmt><expr><name>rv</name> = <call><name><name>validity</name>-&gt;<name>GetNotAfter</name></name><argument_list>(<argument><expr>&amp;<name>notAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>rv</name></expr>;</return></then></if>
  
    <expr_stmt><expr><name>rv</name> = <call><name><name>validity</name>-&gt;<name>GetNotBefore</name></name><argument_list>(<argument><expr>&amp;<name>notBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>rv</name></expr>;</return></then></if>
  
    <if>if <condition>(<expr><call><name>LL_CMP</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr>&gt;</expr></argument>, <argument><expr><name>notAfter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>key</name>       = "certErrorExpired"</expr>;</expr_stmt> 
      <expr_stmt><expr><name>timeToUse</name> = <name>notAfter</name></expr>;</expr_stmt> 
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>key</name>       = "certErrorNotYetValid"</expr>;</expr_stmt>
      <expr_stmt><expr><name>timeToUse</name> = <name>notBefore</name></expr>;</expr_stmt>
    }</block></else></if>
  
    <decl_stmt><decl><type><name>nsAutoString</name></type> <name>formattedDate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsIDateTimeFormat</name>*</type> <name>aDateTimeFormat</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>CallCreateInstance</name><argument_list>(<argument><expr><name>NS_DATETIMEFORMAT_CONTRACTID</name></expr></argument>, <argument><expr>&amp;<name>aDateTimeFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>rv</name></expr>;</return></then></if>
  
    <expr_stmt><expr><call><name><name>aDateTimeFormat</name>-&gt;<name>FormatPRTime</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>kDateFormatShort</name></expr></argument>, 
                                  <argument><expr><name>kTimeFormatNoSeconds</name></expr></argument>, <argument><expr><name>timeToUse</name></expr></argument>, 
                                  <argument><expr><name>formattedDate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>aDateTimeFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>params</name><index>[<expr>0</expr>]</index></name> = <call><name><name>formattedDate</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

    <decl_stmt><decl><type><name>nsString</name></type> <name>formattedString</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>component</name>-&gt;<name>PIPBundleFormatStringFromName</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, 
                                                  <argument><expr>1</expr></argument>, <argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>codeName</name> <init>= <expr><call><name><name>nsNSSErrors</name>::<name>getDefaultErrorStringName</name></name><argument_list>(<argument><expr><name>errorCodeToReport</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>codeName</name></expr>)</condition><then>
  <block>{
    <function_decl><type><name>nsCString</name></type> <name>error_id</name><parameter_list>(<param><decl><type><name>codeName</name></type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>ToLowerCase</name><argument_list>(<argument><expr><name>error_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <function_decl><type><name>NS_ConvertASCIItoUTF16</name></type> <name>idU</name><parameter_list>(<param><decl><type><name>error_id</name></type></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name><name>params</name><index>[<expr>0</expr>]</index></name> = <call><name><name>idU</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>nsString</name></type> <name>formattedString</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name><name>component</name>-&gt;<name>PIPBundleFormatStringFromName</name></name><argument_list>(<argument><expr>"certErrorCodePrefix"</expr></argument>, 
                                                  <argument><expr><name>params</name></expr></argument>, <argument><expr>1</expr></argument>, 
                                                  <argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>" ("</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><name>idU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>returnedMessage</name>.<name>Append</name></name><argument_list>(<argument><expr><call><name>NS_LITERAL_STRING</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>displayAlert</name><parameter_list>(<param><decl><type><name>nsAFlatString</name> &amp;</type><name>formattedString</name></decl></param>, <param><decl><type><name>nsNSSSocketInfo</name> *</type><name>infoObject</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// The interface requestor object may not be safe, so proxy the call to get</comment>
  <comment type="line">// the nsIPrompt.</comment>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIInterfaceRequestor</name></expr></argument>&gt;</argument_list></name></type> <name>proxiedCallbacks</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_GetProxyForObject</name><argument_list>(<argument><expr><name>NS_PROXY_TO_MAIN_THREAD</name></expr></argument>,
                       <argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIInterfaceRequestor</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIInterfaceRequestor</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>NS_PROXY_SYNC</name></expr></argument>,
                       <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>proxiedCallbacks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrompt</name></expr></argument>&gt;</argument_list></name></type> <name>prompt</name> <argument_list>(<argument><expr><call><name>do_GetInterface</name><argument_list>(<argument><expr><name>proxiedCallbacks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>prompt</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_NO_INTERFACE</name></expr>;</return></then></if>

  <comment type="line">// Finally, get a proxy for the nsIPrompt</comment>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrompt</name></expr></argument>&gt;</argument_list></name></type> <name>proxyPrompt</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_GetProxyForObject</name><argument_list>(<argument><expr><name>NS_PROXY_TO_MAIN_THREAD</name></expr></argument>,
                       <argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIPrompt</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>prompt</name></expr></argument>,
                       <argument><expr><name>NS_PROXY_SYNC</name></expr></argument>,
                       <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>proxyPrompt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>proxyPrompt</name>-&gt;<name>Alert</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><call><name><name>formattedString</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>nsHandleSSLError</name><parameter_list>(<param><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>err</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>socketInfo</name>-&gt;<name>GetCanceled</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <comment type="line">// If the socket has been flagged as canceled,</comment>
    <comment type="line">// the code who did was responsible for showing</comment>
    <comment type="line">// an error message (if desired).</comment>
    <return>return <expr><name>NS_OK</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>nssComponentCID</name></expr></argument>, <argument><expr><name>NS_NSSCOMPONENT_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsINSSComponent</name></expr></argument>&gt;</argument_list></name></type> <name>nssComponent</name><argument_list>(<argument><expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>nssComponentCID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>rv</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsXPIDLCString</name></type> <name>hostName</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>GetHostName</name></name><argument_list>(<argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>hostName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <function_decl><type><name>NS_ConvertASCIItoUTF16</name></type> <name>hostNameU</name><parameter_list>(<param><decl><type><name>hostName</name></type></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>port</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>GetPort</name></name><argument_list>(<argument><expr>&amp;<name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>external</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>GetExternalErrorReporting</name></name><argument_list>(<argument><expr>&amp;<name>external</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>nsString</name></type> <name>formattedString</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name>getErrorMessage</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>hostNameU</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>external</name></expr></argument>, <argument><expr><name>nssComponent</name></expr></argument>, <argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>external</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>SetErrorMessage</name></name><argument_list>(<argument><expr><call><name><name>formattedString</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else
  <block>{
    <decl_stmt><decl><type><name>nsPSMUITracker</name></type> <name>tracker</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>tracker</name>.<name>isUIForbidden</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_NOT_AVAILABLE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>rv</name> = <call><name>displayAlert</name><argument_list>(<argument><expr><name>formattedString</name></expr></argument>, <argument><expr><name>socketInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>nsHandleInvalidCertError</name><parameter_list>(<param><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name></decl></param>, 
                         <param><decl><type><name>PRUint32</name></type> <name>multipleCollectedErrors</name></decl></param>, 
                         <param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>host</name></decl></param>, 
                         <param><decl><type><specifier>const</specifier> <name>nsACString</name> &amp;</type><name>hostWithPort</name></decl></param>,
                         <param><decl><type><name>PRInt32</name></type> <name>port</name></decl></param>,
                         <param><decl><type><name>PRErrorCode</name></type> <name>errorCodeToReport</name></decl></param>,
                         <param><decl><type><name>PRErrorCode</name></type> <name>errTrust</name></decl></param>, 
                         <param><decl><type><name>PRErrorCode</name></type> <name>errMismatch</name></decl></param>, 
                         <param><decl><type><name>PRErrorCode</name></type> <name>errExpired</name></decl></param>,
                         <param><decl><type><name>nsIX509Cert</name>*</type> <name>ix509</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_DEFINE_CID</name><argument_list>(<argument><expr><name>nssComponentCID</name></expr></argument>, <argument><expr><name>NS_NSSCOMPONENT_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsINSSComponent</name></expr></argument>&gt;</argument_list></name></type> <name>nssComponent</name><argument_list>(<argument><expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>nssComponentCID</name></expr></argument>, <argument><expr>&amp;<name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>rv</name></expr>;</return></then></if>

  <function_decl><type><name>NS_ConvertASCIItoUTF16</name></type> <name>hostU</name><parameter_list>(<param><decl><type><name>host</name></type></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>NS_ConvertASCIItoUTF16</name></type> <name>hostWithPortU</name><parameter_list>(<param><decl><type><name>hostWithPort</name></type></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// What mechanism is used to inform the user?</comment>
  <comment type="line">// The highest priority has the "external error reporting" feature,</comment>
  <comment type="line">// if set, we'll provide the strings to be used by the nsINSSErrorsService</comment>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>external</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>GetExternalErrorReporting</name></name><argument_list>(<argument><expr>&amp;<name>external</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>nsString</name></type> <name>formattedString</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name>getInvalidCertErrorMessage</name><argument_list>(<argument><expr><name>multipleCollectedErrors</name></expr></argument>, <argument><expr><name>errorCodeToReport</name></expr></argument>,
<argument><expr>+                                 <name>errTrust</name></expr></argument>, <argument><expr><name>errMismatch</name></expr></argument>, <argument><expr><name>errExpired</name></expr></argument>,
                                  <argument><expr><name>hostU</name></expr></argument>, <argument><expr><name>hostWithPortU</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, 
                                  <argument><expr><name>ix509</name></expr></argument>, <argument><expr><name>external</name></expr></argument>, <argument><expr><name>nssComponent</name></expr></argument>, <argument><expr><name>formattedString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>external</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>SetErrorMessage</name></name><argument_list>(<argument><expr><call><name><name>formattedString</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else
  <block>{
    <decl_stmt><decl><type><name>nsPSMUITracker</name></type> <name>tracker</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name><name>tracker</name>.<name>isUIForbidden</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_NOT_AVAILABLE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name>rv</name> = <call><name>displayAlert</name><argument_list>(<argument><expr><name>formattedString</name></expr></argument>, <argument><expr><name>socketInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
  <return>return <expr><name>rv</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>PRStatus</name> <name>PR_CALLBACK</name></type>
<name>nsSSLIOLayerConnect</name><parameter_list>(<param><decl><type><name>PRFileDesc</name>*</type> <name>fd</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>PRNetAddr</name>*</type> <name>addr</name></decl></param>,
                    <param><decl><type><name>PRIntervalTime</name></type> <name>timeout</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gPIPNSSLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>, <argument><expr>("[%p] connecting SSL socket\n", (<name>void</name>*)<name>fd</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>fd</name> || !<name><name>fd</name>-&gt;<name>lower</name></name></expr>)</condition><then>
    <return>return <expr><name>PR_FAILURE</name></expr>;</return></then></if>
  
  <decl_stmt><decl><type><name>PRStatus</name></type> <name>status</name> <init>= <expr><name>PR_SUCCESS</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_BEOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="line">// Due to BeOS net_server's lack of support for nonblocking sockets,</comment>
  <comment type="line">// we must execute this entire connect as a blocking operation - bug 70217</comment>
 
  <decl_stmt><decl><type><name>PRSocketOptionData</name></type> <name>sockopt</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>sockopt</name>.<name>option</name></name> = <name>PR_SockOpt_Nonblocking</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_GetSocketOption</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>sockopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>oldBlockVal</name> <init>= <expr><name><name>sockopt</name>.<name>value</name>.<name>non_blocking</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>sockopt</name>.<name>option</name></name> = <name>PR_SockOpt_Nonblocking</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sockopt</name>.<name>value</name>.<name>non_blocking</name></name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_SetSocketOption</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>sockopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><name>status</name> = <call><name><name>fd</name>-&gt;<name>lower</name>-&gt;<name>methods</name>-&gt;<name>connect</name></name><argument_list>(<argument><expr><name><name>fd</name>-&gt;<name>lower</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_BEOS</name></expr></argument>)</argument_list></call></expr></cpp:if>  <comment type="line">// bug 70217</comment>
                                       <argument><expr><name>PR_INTERVAL_NO_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                                       <expr_stmt><expr><name>timeout</name></expr></expr_stmt>)</block>;</function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if <condition>(<expr><name>status</name> != <name>PR_SUCCESS</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gPIPNSSLog</name></expr></argument>, <argument><expr><name>PR_LOG_ERROR</name></expr></argument>, <argument><expr>("[%p] Lower layer connect error: %d\n",
                                      (<name>void</name>*)<name>fd</name>, <call><name>PR_GetError</name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_BEOS</name></expr></argument>)</argument_list></call></expr></cpp:if>  <comment type="line">// bug 70217</comment>
    <goto>goto <name>loser</name>;</goto>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>status</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
  
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gPIPNSSLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>, <argument><expr>("[%p] Connect\n", (<name>void</name>*)<name>fd</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XP_BEOS</name></expr></argument>)</argument_list></call></expr></cpp:if>  <comment type="line">// bug 70217</comment>
 <label><name>loser</name>:</label>
  <comment type="line">// We put the Nonblocking bit back to the value it was when </comment>
  <comment type="line">// we entered this function.</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>sockopt</name>.<name>option</name></name> == <name>PR_SockOpt_Nonblocking</name></expr></argument>,
               <argument><expr>"sockopt.option was re-set to an unexpected value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sockopt</name>.<name>value</name>.<name>non_blocking</name></name> = <name>oldBlockVal</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PR_SetSocketOption</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>sockopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>status</name></expr>;</return>
}

<comment type="line">// Call this function to report a site that is possibly TLS intolerant.</comment>
<comment type="line">// This function will return true, if the given socket is currently using TLS.</comment>
PRBool
<macro><name>nsSSLIOLayerHelpers</name></macro><expr_stmt><expr><name>::<name>rememberPossibleTLSProblemSite</name></name>(<name>PRFileDesc</name>* <name>ssl_layer_fd</name>, <name>nsNSSSocketInfo</name> *<name>socketInfo</name>)
<block>{
  <expr><name>PRBool</name> <name>currentlyUsesTLS</name> = <name>PR_FALSE</name></expr>;

  <expr><call><name>SSL_OptionGet</name><argument_list>(<argument><expr><name>ssl_layer_fd</name></expr></argument>, <argument><expr><name>SSL_ENABLE_TLS</name></expr></argument>, <argument><expr>&amp;<name>currentlyUsesTLS</name></expr></argument>)</argument_list></call></expr>;
  <if>if <condition>(<expr><name>currentlyUsesTLS</name></expr>)</condition><then> <block>{
    <comment type="line">// Add this site to the list of TLS intolerant sites.</comment>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>nsXPIDLCString</name></type> <name>host</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>GetPort</name></name><argument_list>(<argument><expr>&amp;<name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>GetHostName</name></name><argument_list>(<argument><expr><call><name>getter_Copies</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>key</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>key</name> = <name>host</name> + <call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr>":"</expr></argument>)</argument_list></call> + <call><name>nsPrintfCString</name><argument_list>(<argument><expr>"%d"</expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>addIntolerantSite</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt/></block></then></if>}</block></expr></expr_stmt>
  
  <return>return <expr><name>currentlyUsesTLS</name></expr>;</return>
}

static <function><type><name>PRStatus</name> <name>PR_CALLBACK</name></type>
<name>nsSSLIOLayerClose</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>fd</name></expr>)</condition><then>
    <return>return <expr><name>PR_FAILURE</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gPIPNSSLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>, <argument><expr>("[%p] Shutting down socket\n", (<name>void</name>*)<name>fd</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <decl_stmt><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name> <init>= <expr>(<name>nsNSSSocketInfo</name>*)<name><name>fd</name>-&gt;<name>secret</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>,<argument><expr>"nsNSSSocketInfo was null for an fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>nsSSLThread</name>::<name>requestClose</name></name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>PRStatus</name></type> <name><name>nsNSSSocketInfo</name>::<name>CloseSocketAndDestroy</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>nsNSSShutDownList</name>::<name>trackSSLSocketClose</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRFileDesc</name>*</type> <name>popped</name> <init>= <expr><call><name>PR_PopIOLayer</name><argument_list>(<argument><expr><name>mFd</name></expr></argument>, <argument><expr><name>PR_TOP_IO_LAYER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>GetHandshakeInProgress</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>nsSSLIOLayerHelpers</name>::<name>rememberPossibleTLSProblemSite</name></name><argument_list>(<argument><expr><name><name>mFd</name>-&gt;<name>lower</name></name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name>PRStatus</name></type> <name>status</name> <init>= <expr><call><name><name>mFd</name>-&gt;<name>methods</name>-&gt;<name>close</name></name><argument_list>(<argument><expr><name>mFd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>status</name> != <name>PR_SUCCESS</name></expr>)</condition><then> <return>return <expr><name>status</name></expr>;</return></then></if>

  <expr_stmt><expr><name><name>popped</name>-&gt;<name>identity</name></name> = <name>PR_INVALID_IO_LAYER</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_RELEASE_THIS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>popped</name>-&gt;<name>dtor</name></name><argument_list>(<argument><expr><name>popped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>PR_SUCCESS</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SSL_VERBOSE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>DUMP_BUFFER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Dumps a (potentially binary) buffer using SSM_DEBUG. 
   (We could have used the version in ssltrace.c, but that's
   specifically tailored to SSLTRACE. Sigh. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPBUF_LINESIZE</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>nsDumpBuffer</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>PRIntn</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>hexbuf</name><index>[<expr><name>DUMPBUF_LINESIZE</name>*3+1</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>chrbuf</name><index>[<expr><name>DUMPBUF_LINESIZE</name>+1</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>hex</name> <init>= <expr>"0123456789abcdef"</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRIntn</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>l</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>, *<decl><type ref="prev"/><name>c</name></decl>, *<decl><type ref="prev"/><name>h</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
    <return>return;</return></then></if>
  <expr_stmt><expr><name><name>hexbuf</name><index>[<expr><name>DUMPBUF_LINESIZE</name>*3</expr>]</index></name> = '\0'</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>chrbuf</name><index>[<expr><name>DUMPBUF_LINESIZE</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
  <expr_stmt><expr>(<name>void</name>) <call><name>memset</name><argument_list>(<argument><expr><name>hexbuf</name></expr></argument>, <argument><expr>0x20</expr></argument>, <argument><expr><name>DUMPBUF_LINESIZE</name>*3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>(<name>void</name>) <call><name>memset</name><argument_list>(<argument><expr><name>chrbuf</name></expr></argument>, <argument><expr>0x20</expr></argument>, <argument><expr><name>DUMPBUF_LINESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> = <name>hexbuf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>c</name> = <name>chrbuf</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>i</name> &lt; <name>len</name></expr>)</condition>
  <block>{
    <expr_stmt><expr><name>ch</name> = <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>l</name> == <name>DUMPBUF_LINESIZE</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gPIPNSSLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>, <argument><expr>("%s%s\n", <name>hexbuf</name>, <name>chrbuf</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>(<name>void</name>) <call><name>memset</name><argument_list>(<argument><expr><name>hexbuf</name></expr></argument>, <argument><expr>0x20</expr></argument>, <argument><expr><name>DUMPBUF_LINESIZE</name>*3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>(<name>void</name>) <call><name>memset</name><argument_list>(<argument><expr><name>chrbuf</name></expr></argument>, <argument><expr>0x20</expr></argument>, <argument><expr><name>DUMPBUF_LINESIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>h</name> = <name>hexbuf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> = <name>chrbuf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>l</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Convert a character to hex. */</comment>
    <expr_stmt><expr>*<name>h</name>++ = <name><name>hex</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>h</name>++ = <name><name>hex</name><index>[<expr><name>ch</name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>h</name>++</expr>;</expr_stmt>
        
    <comment type="block">/* Put the character (if it's printable) into the character buffer. */</comment>
    <if>if <condition>(<expr>(<name>ch</name> &gt;= 0x20) &amp;&amp; (<name>ch</name> &lt;= 0x7e)</expr>)</condition><then>
      <expr_stmt><expr>*<name>c</name>++ = <name>ch</name></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr>*<name>c</name>++ = '.'</expr>;</expr_stmt></else></if>
    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt> <expr_stmt><expr><name>l</name>++</expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gPIPNSSLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>, <argument><expr>("%s%s\n", <name>hexbuf</name>, <name>chrbuf</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_BUFFER</name><parameter_list>(<param><type><name>buf</name></type></param>,<param><type><name>len</name></type></param>)</parameter_list></cpp:macro> <cpp:value>nsDumpBuffer(buf,len)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_DUMP_BUFFER</name><parameter_list>(<param><type><name>buf</name></type></param>,<param><type><name>len</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>isNonSSLErrorThatWeAllowToRetry</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>err</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>withInitialCleartext</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>err</name></expr>)</condition>
  <block>{
    <case>case <expr><name>PR_CONNECT_RESET_ERROR</name></expr>:
      <if>if <condition>(<expr>!<name>withInitialCleartext</name></expr>)</condition><then>
        <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>
      <break>break;</break>
    
    </case><case>case <expr><name>PR_END_OF_FILE_ERROR</name></expr>:
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
  </case>}</block></switch>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>isTLSIntoleranceError</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>err</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>withInitialCleartext</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// This function is supposed to decide, which error codes should</comment>
  <comment type="line">// be used to conclude server is TLS intolerant.</comment>
  <comment type="line">// Note this only happens during the initial SSL handshake.</comment>
  <comment type="line">// </comment>
  <comment type="line">// When not using a proxy we'll see a connection reset error.</comment>
  <comment type="line">// When using a proxy, we'll see an end of file error.</comment>
  <comment type="line">// In addition check for some error codes where it is reasonable</comment>
  <comment type="line">// to retry without TLS.</comment>

  <if>if <condition>(<expr><call><name>isNonSSLErrorThatWeAllowToRetry</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>withInitialCleartext</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <switch>switch <condition>(<expr><name>err</name></expr>)</condition>
  <block>{
    <case>case <expr><name>SSL_ERROR_BAD_MAC_ALERT</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_BAD_MAC_READ</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_HANDSHAKE_FAILURE_ALERT</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_HANDSHAKE_UNEXPECTED_ALERT</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_CLIENT_KEY_EXCHANGE_FAILURE</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_ILLEGAL_PARAMETER_ALERT</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_NO_CYPHER_OVERLAP</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_BAD_SERVER</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_BAD_BLOCK_PADDING</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_UNSUPPORTED_VERSION</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_PROTOCOL_VERSION_ALERT</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_RX_MALFORMED_FINISHED</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_DECODE_ERROR_ALERT</name></expr>:
    </case><case>case <expr><name>SSL_ERROR_RX_UNKNOWN_ALERT</name></expr>:
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
  </case>}</block></switch>
  
  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<function><type><name>PRInt32</name></type>
<name><name>nsSSLThread</name>::<name>checkHandshake</name></name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>bytesTransfered</name></decl></param>, 
                            <param><decl><type><name>PRBool</name></type> <name>wasReading</name></decl></param>,
                            <param><decl><type><name>PRFileDesc</name>*</type> <name>ssl_layer_fd</name></decl></param>, 
                            <param><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// This is where we work around all of those SSL servers that don't </comment>
  <comment type="line">// conform to the SSL spec and shutdown a connection when we request</comment>
  <comment type="line">// SSL v3.1 (aka TLS).  The spec says the client says what version</comment>
  <comment type="line">// of the protocol we're willing to perform, in our case SSL v3.1</comment>
  <comment type="line">// In its response, the server says which version it wants to perform.</comment>
  <comment type="line">// Many servers out there only know how to do v3.0.  Next, we're supposed</comment>
  <comment type="line">// to send back the version of the protocol we requested (ie v3.1).  At</comment>
  <comment type="line">// this point many servers's implementations are broken and they shut</comment>
  <comment type="line">// down the connection when they don't see the version they sent back.</comment>
  <comment type="line">// This is supposed to prevent a man in the middle from forcing one</comment>
  <comment type="line">// side to dumb down to a lower level of the protocol.  Unfortunately,</comment>
  <comment type="line">// there are enough broken servers out there that such a gross work-around</comment>
  <comment type="line">// is necessary.  :(</comment>

  <comment type="line">// Additional comment added in August 2006:</comment>
  <comment type="line">// When we begun to use TLS hello extensions, we encountered a new class of</comment>
  <comment type="line">// broken server, which simply stall for a very long time.</comment>
  <comment type="line">// We would like to shorten the timeout, but limit this shorter timeout </comment>
  <comment type="line">// to the handshake phase.</comment>
  <comment type="line">// When we arrive here for the first time (for a given socket),</comment>
  <comment type="line">// we know the connection is established, and the application code</comment>
  <comment type="line">// tried the first read or write. This triggers the beginning of the</comment>
  <comment type="line">// SSL handshake phase at the SSL FD level.</comment>
  <comment type="line">// We'll make a note of the current time,</comment>
  <comment type="line">// and use this to measure the elapsed time since handshake begin.</comment>

  <comment type="line">// Do NOT assume TLS intolerance on a closed connection after bad cert ui was shown.</comment>
  <comment type="line">// Simply retry.</comment>
  <comment type="line">// This depends on the fact that Cert UI will not be shown again,</comment>
  <comment type="line">// should the user override the bad cert.</comment>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>handleHandshakeResultNow</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>GetHandshakePending</name></name><argument_list>(<argument><expr>&amp;<name>handleHandshakeResultNow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>wantRetry</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>0 &gt; <name>bytesTransfered</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>err</name> <init>= <expr><call><name>PR_GetError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>handleHandshakeResultNow</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>PR_WOULD_BLOCK_ERROR</name> == <name>err</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>SetHandshakeInProgress</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>bytesTransfered</name></expr>;</return>
      }</block></then></if>

      <if>if <condition>(<expr>!<name>wantRetry</name> <comment type="line">// no decision yet</comment>
          &amp;&amp; <call><name>isTLSIntoleranceError</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name><name>socketInfo</name>-&gt;<name>GetHasCleartextPhase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>wantRetry</name> = <call><name><name>nsSSLIOLayerHelpers</name>::<name>rememberPossibleTLSProblemSite</name></name><argument_list>(<argument><expr><name>ssl_layer_fd</name></expr></argument>, <argument><expr><name>socketInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    
    <comment type="line">// This is the common place where we trigger an error message on a SSL socket.</comment>
    <comment type="line">// This might be reached at any time of the connection.</comment>
    <if>if <condition>(<expr>!<name>wantRetry</name> &amp;&amp; (<call><name>IS_SSL_ERROR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call> || <call><name>IS_SEC_ERROR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>nsHandleSSLError</name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>
  <else>else <if>if <condition>(<expr><name>wasReading</name> &amp;&amp; 0 == <name>bytesTransfered</name></expr>)</condition><then> <comment type="line">// zero bytes on reading, socket closed</comment>
  <block>{
    <if>if <condition>(<expr><name>handleHandshakeResultNow</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>!<name>wantRetry</name> <comment type="line">// no decision yet</comment>
          &amp;&amp; !<call><name><name>socketInfo</name>-&gt;<name>GetHasCleartextPhase</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <comment type="line">// mirror PR_CONNECT_RESET_ERROR treament</comment>
      <block>{
        <expr_stmt><expr><name>wantRetry</name> = 
          <call><name><name>nsSSLIOLayerHelpers</name>::<name>rememberPossibleTLSProblemSite</name></name><argument_list>(<argument><expr><name>ssl_layer_fd</name></expr></argument>, <argument><expr><name>socketInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if></else></if>

  <if>if <condition>(<expr><name>wantRetry</name></expr>)</condition><then> <block>{
    <comment type="line">// We want to cause the network layer to retry the connection.</comment>
    <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>PR_CONNECT_RESET_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>wasReading</name></expr>)</condition><then>
      <expr_stmt><expr><name>bytesTransfered</name> = -1</expr>;</expr_stmt></then></if>
  }</block></then></if>

  <comment type="line">// TLS intolerant servers only cause the first transfer to fail, so let's </comment>
  <comment type="line">// set the HandshakePending attribute to false so that we don't try the logic</comment>
  <comment type="line">// above again in a subsequent transfer.</comment>
  <if>if <condition>(<expr><name>handleHandshakeResultNow</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>SetHandshakePending</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>socketInfo</name>-&gt;<name>SetHandshakeInProgress</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  
  <return>return <expr><name>bytesTransfered</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRInt16</name> <name>PR_CALLBACK</name></type>
<name>nsSSLIOLayerPoll</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>, <param><decl><type><name>PRInt16</name></type> <name>in_flags</name></decl></param>, <param><decl><type><name>PRInt16</name> *</type><name>out_flags</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gPIPNSSLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>, <argument><expr>("[%p] polling SSL socket\n", (<name>void</name>*)<name>fd</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>out_flags</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"nsSSLIOLayerPoll called with null out_flags"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>out_flags</name> = 0</expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>fd</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"nsSSLIOLayerPoll called with null fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name> <init>= <expr>(<name>nsNSSSocketInfo</name>*)<name><name>fd</name>-&gt;<name>secret</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>,<argument><expr>"nsNSSSocketInfo was null for an fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>nsSSLThread</name>::<name>requestPoll</name></name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>, <argument><expr><name>in_flags</name></expr></argument>, <argument><expr><name>out_flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>PRDescIdentity</name></type> <name><name>nsSSLIOLayerHelpers</name>::<name>nsSSLIOLayerIdentity</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRIOMethods</name></type> <name><name>nsSSLIOLayerHelpers</name>::<name>nsSSLIOLayerMethods</name></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRLock</name> *</type><name><name>nsSSLIOLayerHelpers</name>::<name>mutex</name></name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nsCStringHashSet</name> *</type><name><name>nsSSLIOLayerHelpers</name>::<name>mTLSIntolerantSites</name></name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRFileDesc</name> *</type><name><name>nsSSLIOLayerHelpers</name>::<name>mSharedPollableEvent</name></name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nsNSSSocketInfo</name> *</type><name><name>nsSSLIOLayerHelpers</name>::<name>mSocketOwningPollableEvent</name></name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PRBool</name></type> <name><name>nsSSLIOLayerHelpers</name>::<name>mPollableEventCurrentlySet</name></name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PRIntn</name></type> <name>_PSM_InvalidInt</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PR_ASSERT</name><argument_list>(<argument><expr>!"I/O method is invalid"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>PR_INVALID_METHOD_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRInt64</name></type> <name>_PSM_InvalidInt64</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PR_ASSERT</name><argument_list>(<argument><expr>!"I/O method is invalid"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>PR_INVALID_METHOD_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRStatus</name></type> <name>_PSM_InvalidStatus</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PR_ASSERT</name><argument_list>(<argument><expr>!"I/O method is invalid"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>PR_INVALID_METHOD_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_FAILURE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRFileDesc</name> *</type><name>_PSM_InvalidDesc</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>PR_ASSERT</name><argument_list>(<argument><expr>!"I/O method is invalid"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>PR_INVALID_METHOD_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRStatus</name> <name>PR_CALLBACK</name></type> <name>PSMGetsockname</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>, <param><decl><type><name>PRNetAddr</name> *</type><name>addr</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>fd</name> || !<name><name>fd</name>-&gt;<name>lower</name></name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name> <init>= <expr>(<name>nsNSSSocketInfo</name>*)<name><name>fd</name>-&gt;<name>secret</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>,<argument><expr>"nsNSSSocketInfo was null for an fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>nsSSLThread</name>::<name>requestGetsockname</name></name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRStatus</name> <name>PR_CALLBACK</name></type> <name>PSMGetpeername</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>, <param><decl><type><name>PRNetAddr</name> *</type><name>addr</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>fd</name> || !<name><name>fd</name>-&gt;<name>lower</name></name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name> <init>= <expr>(<name>nsNSSSocketInfo</name>*)<name><name>fd</name>-&gt;<name>secret</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>,<argument><expr>"nsNSSSocketInfo was null for an fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>nsSSLThread</name>::<name>requestGetpeername</name></name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRStatus</name> <name>PR_CALLBACK</name></type> <name>PSMGetsocketoption</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>, 
                                        <param><decl><type><name>PRSocketOptionData</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>fd</name> || !<name><name>fd</name>-&gt;<name>lower</name></name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name> <init>= <expr>(<name>nsNSSSocketInfo</name>*)<name><name>fd</name>-&gt;<name>secret</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>,<argument><expr>"nsNSSSocketInfo was null for an fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>nsSSLThread</name>::<name>requestGetsocketoption</name></name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRStatus</name> <name>PR_CALLBACK</name></type> <name>PSMSetsocketoption</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>, 
                                        <param><decl><type><specifier>const</specifier> <name>PRSocketOptionData</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>fd</name> || !<name><name>fd</name>-&gt;<name>lower</name></name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name> <init>= <expr>(<name>nsNSSSocketInfo</name>*)<name><name>fd</name>-&gt;<name>secret</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>,<argument><expr>"nsNSSSocketInfo was null for an fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>nsSSLThread</name>::<name>requestSetsocketoption</name></name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRInt32</name> <name>PR_CALLBACK</name></type> <name>PSMRecv</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>amount</name></decl></param>,
    <param><decl><type><name>PRIntn</name></type> <name>flags</name></decl></param>, <param><decl><type><name>PRIntervalTime</name></type> <name>timeout</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>fd</name> || !<name><name>fd</name>-&gt;<name>lower</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>PR_BAD_DESCRIPTOR_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name> <init>= <expr>(<name>nsNSSSocketInfo</name>*)<name><name>fd</name>-&gt;<name>secret</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>,<argument><expr>"nsNSSSocketInfo was null for an fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>flags</name> == <name>PR_MSG_PEEK</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name><name>nsSSLThread</name>::<name>requestRecvMsgPeek</name></name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>flags</name> != 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>PR_INVALID_ARGUMENT_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
  }</block></then></if>

  <return>return <expr><call><name><name>nsSSLThread</name>::<name>requestRead</name></name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRInt32</name> <name>PR_CALLBACK</name></type> <name>PSMSend</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>amount</name></decl></param>,
    <param><decl><type><name>PRIntn</name></type> <name>flags</name></decl></param>, <param><decl><type><name>PRIntervalTime</name></type> <name>timeout</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>fd</name> || !<name><name>fd</name>-&gt;<name>lower</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>PR_BAD_DESCRIPTOR_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
  }</block></then></if>

  <if>if <condition>(<expr><name>flags</name> != 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>PR_INVALID_ARGUMENT_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name> <init>= <expr>(<name>nsNSSSocketInfo</name>*)<name><name>fd</name>-&gt;<name>secret</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>,<argument><expr>"nsNSSSocketInfo was null for an fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>nsSSLThread</name>::<name>requestWrite</name></name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRInt32</name> <name>PR_CALLBACK</name></type>
<name>nsSSLIOLayerRead</name><parameter_list>(<param><decl><type><name>PRFileDesc</name>*</type> <name>fd</name></decl></param>, <param><decl><type><name>void</name>*</type> <name>buf</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>amount</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>PSMRecv</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>PR_INTERVAL_NO_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRInt32</name> <name>PR_CALLBACK</name></type>
<name>nsSSLIOLayerWrite</name><parameter_list>(<param><decl><type><name>PRFileDesc</name>*</type> <name>fd</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name>*</type> <name>buf</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>amount</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>PSMSend</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>PR_INTERVAL_NO_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRStatus</name> <name>PR_CALLBACK</name></type> <name>PSMConnectcontinue</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>, <param><decl><type><name>PRInt16</name></type> <name>out_flags</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>fd</name> || !<name><name>fd</name>-&gt;<name>lower</name></name></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsNSSSocketInfo</name> *</type><name>socketInfo</name> <init>= <expr>(<name>nsNSSSocketInfo</name>*)<name><name>fd</name>-&gt;<name>secret</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>,<argument><expr>"nsNSSSocketInfo was null for an fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>nsSSLThread</name>::<name>requestConnectcontinue</name></name><argument_list>(<argument><expr><name>socketInfo</name></expr></argument>, <argument><expr><name>out_flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type> <name><name>nsSSLIOLayerHelpers</name>::<name>Init</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>nsSSLIOLayerIdentity</name> = <call><name>PR_GetUniqueIdentity</name><argument_list>(<argument><expr>"NSS layer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nsSSLIOLayerMethods</name>  = *<call><name>PR_GetDefaultIOMethods</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>available</name></name> = (<name>PRAvailableFN</name>)<name>_PSM_InvalidInt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>available64</name></name> = (<name>PRAvailable64FN</name>)<name>_PSM_InvalidInt64</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>fsync</name></name> = (<name>PRFsyncFN</name>)<name>_PSM_InvalidStatus</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>seek</name></name> = (<name>PRSeekFN</name>)<name>_PSM_InvalidInt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>seek64</name></name> = (<name>PRSeek64FN</name>)<name>_PSM_InvalidInt64</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>fileInfo</name></name> = (<name>PRFileInfoFN</name>)<name>_PSM_InvalidStatus</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>fileInfo64</name></name> = (<name>PRFileInfo64FN</name>)<name>_PSM_InvalidStatus</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>writev</name></name> = (<name>PRWritevFN</name>)<name>_PSM_InvalidInt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>accept</name></name> = (<name>PRAcceptFN</name>)<name>_PSM_InvalidDesc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>bind</name></name> = (<name>PRBindFN</name>)<name>_PSM_InvalidStatus</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>listen</name></name> = (<name>PRListenFN</name>)<name>_PSM_InvalidStatus</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>shutdown</name></name> = (<name>PRShutdownFN</name>)<name>_PSM_InvalidStatus</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>recvfrom</name></name> = (<name>PRRecvfromFN</name>)<name>_PSM_InvalidInt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>sendto</name></name> = (<name>PRSendtoFN</name>)<name>_PSM_InvalidInt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>acceptread</name></name> = (<name>PRAcceptreadFN</name>)<name>_PSM_InvalidInt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>transmitfile</name></name> = (<name>PRTransmitfileFN</name>)<name>_PSM_InvalidInt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>sendfile</name></name> = (<name>PRSendfileFN</name>)<name>_PSM_InvalidInt</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>getsockname</name></name> = <name>PSMGetsockname</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>getpeername</name></name> = <name>PSMGetpeername</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>getsocketoption</name></name> = <name>PSMGetsocketoption</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>setsocketoption</name></name> = <name>PSMSetsocketoption</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>recv</name></name> = <name>PSMRecv</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>send</name></name> = <name>PSMSend</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>connectcontinue</name></name> = <name>PSMConnectcontinue</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>connect</name></name> = <name>nsSSLIOLayerConnect</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>close</name></name> = <name>nsSSLIOLayerClose</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>write</name></name> = <name>nsSSLIOLayerWrite</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>read</name></name> = <name>nsSSLIOLayerRead</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nsSSLIOLayerMethods</name>.<name>poll</name></name> = <name>nsSSLIOLayerPoll</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>mutex</name> = <call><name>PR_NewLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>mutex</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

  <expr_stmt><expr><name>mSharedPollableEvent</name> = <call><name>PR_NewPollableEvent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// if we can not get a pollable event, we'll have to do busy waiting</comment>

  <expr_stmt><expr><name>mTLSIntolerantSites</name> = new <call><name>nsCStringHashSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>mTLSIntolerantSites</name></expr>)</condition><then>
    <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name><name>mTLSIntolerantSites</name>-&gt;<name>Init</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name><name>nsSSLIOLayerHelpers</name>::<name>addIntolerantSite</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCString</name> &amp;</type><name>str</name></decl></param>)</parameter_list>
<block>{
  <function_decl><type><name>nsAutoLock</name></type> <name>lock</name><parameter_list>(<param><decl><type><name>mutex</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>nsSSLIOLayerHelpers</name>::<name>mTLSIntolerantSites</name>-&gt;<name>Put</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>PRBool</name></type> <name><name>nsSSLIOLayerHelpers</name>::<name>isKnownAsIntolerantSite</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsCString</name> &amp;</type><name>str</name></decl></param>)</parameter_list>
<block>{
  <function_decl><type><name>nsAutoLock</name></type> <name>lock</name><parameter_list>(<param><decl><type><name>mutex</name></type></decl></param>)</parameter_list>;</function_decl>
  <return>return <expr><call><name><name>mTLSIntolerantSites</name>-&gt;<name>Contains</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name>nsSSLIOLayerNewSocket</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>family</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host</name></decl></param>,
                      <param><decl><type><name>PRInt32</name></type> <name>port</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proxyHost</name></decl></param>,
                      <param><decl><type><name>PRInt32</name></type> <name>proxyPort</name></decl></param>,
                      <param><decl><type><name>PRFileDesc</name> **</type><name>fd</name></decl></param>,
                      <param><decl><type><name>nsISupports</name>**</type> <name>info</name></decl></param>,
                      <param><decl><type><name>PRBool</name></type> <name>forSTARTTLS</name></decl></param>)</parameter_list>
<block>{

  <decl_stmt><decl><type><name>PRFileDesc</name>*</type> <name>sock</name> <init>= <expr><call><name>PR_OpenTCPSocket</name><argument_list>(<argument><expr><name>family</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>sock</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_OUT_OF_MEMORY</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name> <init>= <expr><call><name>nsSSLIOLayerAddToSocket</name><argument_list>(<argument><expr><name>family</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>proxyHost</name></expr></argument>, <argument><expr><name>proxyPort</name></expr></argument>,
                                        <argument><expr><name>sock</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>forSTARTTLS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_Close</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>fd</name> = <name>sock</name></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Function: SECStatus nsConvertCANamesToStrings()
 * Purpose: creates CA names strings from (CERTDistNames* caNames)
 *
 * Arguments and return values
 * - arena: arena to allocate strings on
 * - caNameStrings: filled with CA names strings on return
 * - caNames: CERTDistNames to extract strings from
 * - return: SECSuccess if successful; error code otherwise
 *
 * Note: copied in its entirety from Nova code
 */</comment>
<function><type><name>SECStatus</name></type> <name>nsConvertCANamesToStrings</name><parameter_list>(<param><decl><type><name>PRArenaPool</name>*</type> <name>arena</name></decl></param>, <param><decl><type><name>char</name>**</type> <name>caNameStrings</name></decl></param>,
                                      <param><decl><type><name>CERTDistNames</name>*</type> <name>caNames</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SECItem</name>*</type> <name>dername</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SECStatus</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>headerlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUint32</name></type> <name>contentlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SECItem</name></type> <name>newitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>namestring</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name><name>caNames</name>-&gt;<name>nnames</name></name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>newitem</name>.<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dername</name> = &amp;<name><name>caNames</name>-&gt;<name>names</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name>DER_Lengths</name><argument_list>(<argument><expr><name>dername</name></expr></argument>, <argument><expr>&amp;<name>headerlen</name></expr></argument>, <argument><expr>&amp;<name>contentlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rv</name> != <name>SECSuccess</name></expr>)</condition><then> <block>{
            <goto>goto <name>loser</name>;</goto>
        }</block></then></if>

        <if>if <condition>(<expr><name>headerlen</name> + <name>contentlen</name> != <name><name>dername</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* This must be from an enterprise 2.x server, which sent
             * incorrectly formatted der without the outer wrapper of
             * type and length.  Fix it up by adding the top level
             * header.
             */</comment>
            <if>if <condition>(<expr><name><name>dername</name>-&gt;<name>len</name></name> &lt;= 127</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name></name> = (<name>unsigned</name> <name>char</name> *) <call><name>PR_Malloc</name><argument_list>(<argument><expr><name><name>dername</name>-&gt;<name>len</name></name> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>newitem</name>.<name>data</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
                    <goto>goto <name>loser</name>;</goto>
                }</block></then></if>
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name><index>[<expr>0</expr>]</index></name> = (<name>unsigned</name> <name>char</name>)0x30</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name><index>[<expr>1</expr>]</index></name> = (<name>unsigned</name> <name>char</name>)<name><name>dername</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
                <expr_stmt><expr>(<name>void</name>)<call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>newitem</name>.<name>data</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name><name>dername</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>dername</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>dername</name>-&gt;<name>len</name></name> &lt;= 255</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name></name> = (<name>unsigned</name> <name>char</name> *) <call><name>PR_Malloc</name><argument_list>(<argument><expr><name><name>dername</name>-&gt;<name>len</name></name> + 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>newitem</name>.<name>data</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
                    <goto>goto <name>loser</name>;</goto>
                }</block></then></if>
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name><index>[<expr>0</expr>]</index></name> = (<name>unsigned</name> <name>char</name>)0x30</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name><index>[<expr>1</expr>]</index></name> = (<name>unsigned</name> <name>char</name>)0x81</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name><index>[<expr>2</expr>]</index></name> = (<name>unsigned</name> <name>char</name>)<name><name>dername</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
                <expr_stmt><expr>(<name>void</name>)<call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>newitem</name>.<name>data</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr><name><name>dername</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>dername</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* greater than 256, better be less than 64k */</comment>
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name></name> = (<name>unsigned</name> <name>char</name> *) <call><name>PR_Malloc</name><argument_list>(<argument><expr><name><name>dername</name>-&gt;<name>len</name></name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>newitem</name>.<name>data</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
                    <goto>goto <name>loser</name>;</goto>
                }</block></then></if>
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name><index>[<expr>0</expr>]</index></name> = (<name>unsigned</name> <name>char</name>)0x30</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name><index>[<expr>1</expr>]</index></name> = (<name>unsigned</name> <name>char</name>)0x82</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name><index>[<expr>2</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr>(<name><name>dername</name>-&gt;<name>len</name></name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newitem</name>.<name>data</name><index>[<expr>3</expr>]</index></name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name><name>dername</name>-&gt;<name>len</name></name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>newitem</name>.<name>data</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr><name><name>dername</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>dername</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
            <expr_stmt><expr><name>dername</name> = &amp;<name>newitem</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>namestring</name> = <call><name>CERT_DerNameToAscii</name><argument_list>(<argument><expr><name>dername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>namestring</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* XXX - keep going until we fail to convert the name */</comment>
            <expr_stmt><expr><name><name>caNameStrings</name><index>[<expr><name>n</name></expr>]</index></name> = ""</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>caNameStrings</name><index>[<expr><name>n</name></expr>]</index></name> = <call><name>PORT_ArenaStrdup</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>namestring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PR_Free</name><argument_list>(<argument><expr><name>namestring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>caNameStrings</name><index>[<expr><name>n</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <block>{
                <goto>goto <name>loser</name>;</goto>
            }</block></then></if>
        }</block></else></if>

        <if>if <condition>(<expr><name><name>newitem</name>.<name>data</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PR_Free</name><argument_list>(<argument><expr><name><name>newitem</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <return>return <expr><name>SECSuccess</name></expr>;</return>
<label><name>loser</name>:</label>
    <if>if <condition>(<expr><name><name>newitem</name>.<name>data</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PR_Free</name><argument_list>(<argument><expr><name><name>newitem</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>SECFailure</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * structs and ASN1 templates for the limited scope-of-use extension
 *
 * CertificateScopeEntry ::= SEQUENCE {
 *     name GeneralName, -- pattern, as for NameConstraints
 *     portNumber INTEGER OPTIONAL }
 *
 * CertificateScopeOfUse ::= SEQUENCE OF CertificateScopeEntry
 */</comment>
<comment type="block">/*
 * CERTCertificateScopeEntry: struct for scope entry that can be consumed by
 *                            the code
 * certCertificateScopeOfUse: struct that represents the decoded extension data
 */</comment>
<typedef>typedef <type><struct>struct <block>{<public type="default">
    <decl_stmt><decl><type><name>SECItem</name></type> <name>derConstraint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SECItem</name></type> <name>derPort</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CERTGeneralName</name>*</type> <name>constraint</name></decl>;</decl_stmt> <comment type="block">/* decoded constraint */</comment>
    <decl_stmt><decl><type><name>PRIntn</name></type> <name>port</name></decl>;</decl_stmt> <comment type="block">/* decoded port number */</comment>
</public>}</block></struct></type> <name>CERTCertificateScopeEntry</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{<public type="default">
    <decl_stmt><decl><type><name>CERTCertificateScopeEntry</name>**</type> <name>entries</name></decl>;</decl_stmt>
</public>}</block></struct></type> <name>certCertificateScopeOfUse</name>;</typedef>

<comment type="block">/* corresponding ASN1 templates */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>SEC_ASN1Template</name></type> <name><name>cert_CertificateScopeEntryTemplate</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><name>SEC_ASN1_SEQUENCE</name></expr>, 
      <expr>0</expr>, <expr><name>NULL</name></expr>, <expr>sizeof(<name>CERTCertificateScopeEntry</name>)</expr> }</block></expr>,
    <expr><block>{ <expr><name>SEC_ASN1_ANY</name></expr>,
      <macro><name>offsetof</name><argument_list>(<argument>CERTCertificateScopeEntry</argument>, <argument>derConstraint</argument>)</argument_list></macro> }</block></expr>,
    <expr><block>{ <expr><name>SEC_ASN1_OPTIONAL</name> | <name>SEC_ASN1_INTEGER</name></expr>,
      <macro><name>offsetof</name><argument_list>(<argument>CERTCertificateScopeEntry</argument>, <argument>derPort</argument>)</argument_list></macro> }</block></expr>,
    <expr><block>{ <expr>0</expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>SEC_ASN1Template</name></type> <name><name>cert_CertificateScopeOfUseTemplate</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><name>SEC_ASN1_SEQUENCE_OF</name></expr>, <expr>0</expr>, <expr><name>cert_CertificateScopeEntryTemplate</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<comment type="block">/* 
 * decodes the extension data and create CERTCertificateScopeEntry that can
 * be consumed by the code
 */</comment>
static
SECStatus cert_DecodeScopeOfUseEntries(PRArenaPool* arena, SECItem* extData,
                                       CERTCertificateScopeEntry*** entries,
                                       int* numEntries)
{
    certCertificateScopeOfUse* scope = NULL;
    SECStatus rv = SECSuccess;
    int i;

    *entries = NULL; <comment type="block">/* in case of failure */</comment>
    *numEntries = 0; <comment type="block">/* ditto */</comment>

    scope = (certCertificateScopeOfUse*)
        PORT_ArenaZAlloc(arena, sizeof(certCertificateScopeOfUse));
    if (scope == NULL) {
        goto loser;
    }

    rv = SEC_ASN1DecodeItem(arena, (void*)scope, 
                            cert_CertificateScopeOfUseTemplate, extData);
    if (rv != SECSuccess) {
        goto loser;
    }

    *entries = scope-&gt;entries;
    PR_ASSERT(*entries != NULL);

    <comment type="block">/* first, let's count 'em. */</comment>
    for (i = 0; (*entries)[i] != NULL; i++) ;
    *numEntries = i;

    <comment type="block">/* convert certCertificateScopeEntry sequence into what we can readily
     * use
     */</comment>
    for (i = 0; i &lt; *numEntries; i++) {
        (*entries)[i]-&gt;constraint = 
            CERT_DecodeGeneralName(arena, &amp;((*entries)[i]-&gt;derConstraint), 
                                   NULL);
        if ((*entries)[i]-&gt;derPort.data != NULL) {
            (*entries)[i]-&gt;port = 
                (int)DER_GetInteger(&amp;((*entries)[i]-&gt;derPort));
        }
        else {
            (*entries)[i]-&gt;port = 0;
        }
    }

    goto done;
loser:
    if (rv == SECSuccess) {
        rv = SECFailure;
    }
done:
    return rv;
}

static SECStatus cert_DecodeCertIPAddress(SECItem* genname, 
                                          PRUint32* constraint, PRUint32* mask)
{
    <comment type="block">/* in case of failure */</comment>
    *constraint = 0;
    *mask = 0;

    PR_ASSERT(genname-&gt;data != NULL);
    if (genname-&gt;data == NULL) {
        return SECFailure;
    }
    if (genname-&gt;len != 8) {
        <comment type="block">/* the length must be 4 byte IP address with 4 byte subnet mask */</comment>
        return SECFailure;
    }

    <comment type="block">/* get them in the right order */</comment>
    *constraint = PR_ntohl((PRUint32)(*genname-&gt;data));
    *mask = PR_ntohl((PRUint32)(*(genname-&gt;data + 4)));

    return SECSuccess;
}

static char* _str_to_lower(char* string)
{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XP_WIN</name></cpp:ifdef>
    return _strlwr(string);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    int i;
    for (i = 0; string[i] != '\0'; i++) {
        string[i] = tolower(string[i]);
    }
    return string;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}

<comment type="block">/*
 * Sees if the client certificate has a restriction in presenting the cert
 * to the host: returns PR_TRUE if there is no restriction or if the hostname
 * (and the port) satisfies the restriction, or PR_FALSE if the hostname (and
 * the port) does not satisfy the restriction
 */</comment>
static PRBool CERT_MatchesScopeOfUse(CERTCertificate* cert, char* hostname,
                                     char* hostIP, PRIntn port)
{
    PRBool rv = PR_TRUE; <comment type="block">/* whether the cert can be presented */</comment>
    SECStatus srv;
    SECItem extData;
    PRArenaPool* arena = NULL;
    CERTCertificateScopeEntry** entries = NULL;
    <comment type="block">/* arrays of decoded scope entries */</comment>
    int numEntries = 0;
    int i;
    char* hostLower = NULL;
    PRUint32 hostIPAddr = 0;

    PR_ASSERT((cert != NULL) &amp;&amp; (hostname != NULL) &amp;&amp; (hostIP != NULL));

    <comment type="block">/* find cert extension */</comment>
    srv = CERT_FindCertExtension(cert, SEC_OID_NS_CERT_EXT_SCOPE_OF_USE,
                                 &amp;extData);
    if (srv != SECSuccess) {
        <comment type="block">/* most of the time, this means the extension was not found: also,
         * since this is not a critical extension (as of now) we may simply
         * return PR_TRUE
         */</comment>
        goto done;
    }

    arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
    if (arena == NULL) {
        goto done;
    }

    <comment type="block">/* decode the scope of use entries into pairs of GeneralNames and
     * an optional port numbers
     */</comment>
    srv = cert_DecodeScopeOfUseEntries(arena, &amp;extData, &amp;entries, &amp;numEntries);
    if (srv != SECSuccess) {
        <comment type="block">/* XXX What should we do when we failed to decode the extension?  This
         *     may mean either the extension was malformed or some (unlikely)
         *     fatal error on our part: my argument is that if the extension 
         *     was malformed the extension "disqualifies" as a valid 
         *     constraint and we may present the cert
         */</comment>
        goto done;
    }

    <comment type="block">/* loop over these structures */</comment>
    for (i = 0; i &lt; numEntries; i++) {
        <comment type="block">/* determine whether the GeneralName is a DNS pattern, an IP address 
         * constraint, or else
         */</comment>
        CERTGeneralName* genname = entries[i]-&gt;constraint;

        <comment type="block">/* if constraint is NULL, don't bother looking */</comment>
        if (genname == NULL) {
            <comment type="block">/* this is not a failure: just continue */</comment>
            continue;
        }

        switch (genname-&gt;type) {
        case certDNSName: {
            <comment type="block">/* we have a DNS name constraint; we should use only the host name
             * information
             */</comment>
            char* pattern = NULL;
            char* substring = NULL;

            <comment type="block">/* null-terminate the string */</comment>
            genname-&gt;name.other.data[genname-&gt;name.other.len] = '\0';
            pattern = _str_to_lower((char*)genname-&gt;name.other.data);

            if (hostLower == NULL) {
                <comment type="block">/* so that it's done only if necessary and only once */</comment>
                hostLower = _str_to_lower(PL_strdup(hostname));
            }

            <comment type="block">/* the hostname satisfies the constraint */</comment>
            if (((substring = strstr(hostLower, pattern)) != NULL) &amp;&amp;
                <comment type="block">/* the hostname contains the pattern */</comment>
                (strlen(substring) == strlen(pattern)) &amp;&amp;
                <comment type="block">/* the hostname ends with the pattern */</comment>
                ((substring == hostLower) || (*(substring-1) == '.'))) {
                <comment type="block">/* the hostname either is identical to the pattern or
                 * belongs to a subdomain
                 */</comment>
                rv = PR_TRUE;
            }
            else {
                rv = PR_FALSE;
            }
            <comment type="block">/* clean up strings if necessary */</comment>
            break;
        }
        case certIPAddress: {
            PRUint32 constraint;
            PRUint32 mask;
            PRNetAddr addr;
            
            if (hostIPAddr == 0) {
                <comment type="block">/* so that it's done only if necessary and only once */</comment>
                PR_StringToNetAddr(hostIP, &amp;addr);
                hostIPAddr = addr.inet.ip;
            }

            if (cert_DecodeCertIPAddress(&amp;(genname-&gt;name.other), &amp;constraint, 
                                         &amp;mask) != SECSuccess) {
                continue;
            }
            if ((hostIPAddr &amp; mask) == (constraint &amp; mask)) {
                rv = PR_TRUE;
            }
            else {
                rv = PR_FALSE;
            }
            break;
        }
        default:
            <comment type="block">/* ill-formed entry: abort */</comment>
            continue; <comment type="block">/* go to the next entry */</comment>
        }

        if (!rv) {
            <comment type="block">/* we do not need to check the port: go to the next entry */</comment>
            continue;
        }

        <comment type="block">/* finally, check the optional port number */</comment>
        if ((entries[i]-&gt;port != 0) &amp;&amp; (port != entries[i]-&gt;port)) {
            <comment type="block">/* port number does not match */</comment>
            rv = PR_FALSE;
            continue;
        }

        <comment type="block">/* we have a match */</comment>
        PR_ASSERT(rv);
        break;
    }
done:
    <comment type="block">/* clean up entries */</comment>
    if (arena != NULL) {
        PORT_FreeArena(arena, PR_FALSE);
    }
    if (hostLower != NULL) {
        PR_Free(hostLower);
    }
    return rv;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Function: SSMStatus SSM_SetUserCertChoice()

 * Purpose: sets certChoice by reading the preference
 *
 * Arguments and return values
 * - conn: SSMSSLDataConnection
 * - returns: SSM_SUCCESS if successful; SSM_FAILURE otherwise
 *
 * Note: If done properly, this function will read the identifier strings
 *		 for ASK and AUTO modes, read the selected strings from the
 *		 preference, compare the strings, and determine in which mode it is
 *		 in.
 *       We currently use ASK mode for UI apps and AUTO mode for UI-less
 *       apps without really asking for preferences.
 */</comment>
<function><type><name>nsresult</name></type> <name>nsGetUserCertChoice</name><parameter_list>(<param><decl><type><name>SSM_UserCertChoice</name>*</type> <name>certChoice</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type><name>mode</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>nsresult</name></type> <name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NS_ENSURE_ARG_POINTER</name><argument_list>(<argument><expr><name>certChoice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIPrefBranch</name></expr></argument>&gt;</argument_list></name></type> <name>pref</name> <init>= <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_PREFSERVICE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> = <call><name><name>pref</name>-&gt;<name>GetCharPref</name></name><argument_list>(<argument><expr>"security.default_personal_cert"</expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<goto>goto <name>loser</name>;</goto>
	}</block></then></if>

    <if>if <condition>(<expr><call><name>PL_strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>"Select Automatically"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr>*<name>certChoice</name> = <name>AUTO</name></expr>;</expr_stmt>
	}</block></then>
    <else>else <if>if <condition>(<expr><call><name>PL_strcmp</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>"Ask Every Time"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>certChoice</name> = <name>ASK</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <comment type="line">// Most likely we see a nickname from a migrated cert.</comment>
      <comment type="line">// We do not currently support that, ask the user which cert to use.</comment>
		  <expr_stmt><expr>*<name>certChoice</name> = <name>ASK</name></expr>;</expr_stmt>
	}</block></else></if></else></if>

<label><name>loser</name>:</label>
	<if>if <condition>(<expr><name>mode</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name><name>nsMemory</name>::<name>Free</name></name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type> <name>hasExplicitKeyUsageNonRepudiation</name><parameter_list>(<param><decl><type><name>CERTCertificate</name> *</type><name>cert</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* There is no extension, v1 or v2 certificate */</comment>
  <if>if <condition>(<expr>!<name><name>cert</name>-&gt;<name>extensions</name></name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>SECStatus</name></type> <name>srv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SECItem</name></type> <name>keyUsageItem</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>keyUsageItem</name>.<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>srv</name> = <call><name>CERT_FindKeyUsageExtension</name><argument_list>(<argument><expr><name>cert</name></expr></argument>, <argument><expr>&amp;<name>keyUsageItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>srv</name> == <name>SECFailure</name></expr>)</condition><then>
    <return>return <expr><name>PR_FALSE</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>keyUsage</name> <init>= <expr><name><name>keyUsageItem</name>.<name>data</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PORT_Free</name> <argument_list>(<argument><expr><name><name>keyUsageItem</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr>(<name>keyUsage</name> &amp; <name>KU_NON_REPUDIATION</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
 * Function: SECStatus SSM_SSLGetClientAuthData()
 * Purpose: this callback function is used to pull client certificate
 *			information upon server request
 *
 * Arguments and return values
 * - arg: SSL data connection
 * - socket: SSL socket we're dealing with
 * - caNames: list of CA names
 * - pRetCert: returns a pointer to a pointer to a valid certificate if
 *			   successful; otherwise NULL
 * - pRetKey: returns a pointer to a pointer to the corresponding key if
 *			  successful; otherwise NULL
 * - returns: SECSuccess if successful; error code otherwise
 */</comment>
<function><type><name>SECStatus</name></type> <name>nsNSS_SSLGetClientAuthData</name><parameter_list>(<param><decl><type><name>void</name>*</type> <name>arg</name></decl></param>, <param><decl><type><name>PRFileDesc</name>*</type> <name>socket</name></decl></param>,
								   <param><decl><type><name>CERTDistNames</name>*</type> <name>caNames</name></decl></param>,
								   <param><decl><type><name>CERTCertificate</name>**</type> <name>pRetCert</name></decl></param>,
								   <param><decl><type><name>SECKEYPrivateKey</name>**</type> <name>pRetKey</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name>*</type> <name>wincx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SECStatus</name></type> <name>ret</name> <init>= <expr><name>SECFailure</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsNSSSocketInfo</name>*</type> <name>info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRArenaPool</name>*</type> <name>arena</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>**</type> <name>caNameStrings</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CERTCertificate</name>*</type> <name>cert</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CERTCertificate</name>*</type> <name>serverCert</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SECKEYPrivateKey</name>*</type> <name>privKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CERTCertList</name>*</type> <name>certList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CERTCertListNode</name>*</type> <name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CERTCertNicknames</name>*</type> <name>nicknames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>*</type> <name>extracted</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRIntn</name></type> <name>keyError</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* used for private key retrieval error */</comment>
  <decl_stmt><decl><type><name>SSM_UserCertChoice</name></type> <name>certChoice</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRInt32</name></type> <name>NumberOfCerts</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
	
  <comment type="block">/* do some argument checking */</comment>
  <if>if <condition>(<expr><name>socket</name> == <name>NULL</name> || <name>caNames</name> == <name>NULL</name> || <name>pRetCert</name> == <name>NULL</name> ||
      <name>pRetKey</name> == <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>PR_INVALID_ARGUMENT_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SECFailure</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* get PKCS11 pin argument */</comment>
  <expr_stmt><expr><name>wincx</name> = <call><name>SSL_RevealPinArg</name><argument_list>(<argument><expr><name>socket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>wincx</name> == <name>NULL</name></expr>)</condition><then> <block>{
    <return>return <expr><name>SECFailure</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* get the socket info */</comment>
  <expr_stmt><expr><name>info</name> = (<name>nsNSSSocketInfo</name>*)<name><name>socket</name>-&gt;<name>higher</name>-&gt;<name>secret</name></name></expr>;</expr_stmt>

  <comment type="block">/* create caNameStrings */</comment>
  <expr_stmt><expr><name>arena</name> = <call><name>PORT_NewArena</name><argument_list>(<argument><expr><name>DER_DEFAULT_CHUNKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>arena</name> == <name>NULL</name></expr>)</condition><then> <block>{
    <goto>goto <name>loser</name>;</goto>
  }</block></then></if>

  <expr_stmt><expr><name>caNameStrings</name> = (<name>char</name>**)<call><name>PORT_ArenaAlloc</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, 
                                          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></sizeof>*(<name><name>caNames</name>-&gt;<name>nnames</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>caNameStrings</name> == <name>NULL</name></expr>)</condition><then> <block>{
    <goto>goto <name>loser</name>;</goto>
  }</block></then></if>


  <expr_stmt><expr><name>ret</name> = <call><name>nsConvertCANamesToStrings</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>caNameStrings</name></expr></argument>, <argument><expr><name>caNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>ret</name> != <name>SECSuccess</name></expr>)</condition><then> <block>{
    <goto>goto <name>loser</name>;</goto>
  }</block></then></if>

  <comment type="block">/* get the preference */</comment>
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name>nsGetUserCertChoice</name><argument_list>(<argument><expr>&amp;<name>certChoice</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <goto>goto <name>loser</name>;</goto>
  }</block></then></if>

  <comment type="block">/* find valid user cert and key pair */</comment>	
  <if>if <condition>(<expr><name>certChoice</name> == <name>AUTO</name></expr>)</condition><then> <block>{
    <comment type="block">/* automatically find the right cert */</comment>

    <comment type="block">/* find all user certs that are valid and for SSL */</comment>
    <expr_stmt><expr><name>certList</name> = <call><name>CERT_FindUserCertsByUsage</name><argument_list>(<argument><expr><call><name>CERT_GetDefaultCertDB</name><argument_list>()</argument_list></call></expr></argument>, 
                                         <argument><expr><name>certUsageSSLClient</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>,
                                         <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>wincx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>certList</name> == <name>NULL</name></expr>)</condition><then> <block>{
      <goto>goto <name>noCert</name>;</goto>
    }</block></then></if>

    <comment type="block">/* filter the list to those issued by CAs supported by the server */</comment>
    <expr_stmt><expr><name>ret</name> = <call><name>CERT_FilterCertListByCANames</name><argument_list>(<argument><expr><name>certList</name></expr></argument>, <argument><expr><name><name>caNames</name>-&gt;<name>nnames</name></name></expr></argument>,
                                       <argument><expr><name>caNameStrings</name></expr></argument>, <argument><expr><name>certUsageSSLClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ret</name> != <name>SECSuccess</name></expr>)</condition><then> <block>{
      <goto>goto <name>noCert</name>;</goto>
    }</block></then></if>

    <comment type="block">/* make sure the list is not empty */</comment>
    <expr_stmt><expr><name>node</name> = <call><name>CERT_LIST_HEAD</name><argument_list>(<argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>CERT_LIST_END</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <goto>goto <name>noCert</name>;</goto>
    }</block></then></if>

    <decl_stmt><decl><type><name>CERTCertificate</name>*</type> <name>low_prio_nonrep_cert</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>CERTCertificateCleaner</name></type> <name>low_prio_cleaner</name><parameter_list>(<param><decl><type><name>low_prio_nonrep_cert</name></type></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* loop through the list until we find a cert with a key */</comment>
    <while>while <condition>(<expr>!<call><name>CERT_LIST_END</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
      <comment type="block">/* if the certificate has restriction and we do not satisfy it
       * we do not use it
       */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>		<comment type="block">/* XXX This must be re-enabled */</comment>
      if (!CERT_MatchesScopeOfUse(node-&gt;cert, info-&gt;GetHostName,
                                  info-&gt;GetHostIP, info-&gt;GetHostPort)) {
          node = CERT_LIST_NEXT(node);
          continue;
      }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>privKey</name> = <call><name>PK11_FindKeyByAnyCert</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>cert</name></name></expr></argument>, <argument><expr><name>wincx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>privKey</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>hasExplicitKeyUsageNonRepudiation</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>cert</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>SECKEY_DestroyPrivateKey</name><argument_list>(<argument><expr><name>privKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>privKey</name> = <name>NULL</name></expr>;</expr_stmt>
          <comment type="line">// Not a prefered cert</comment>
          <if>if <condition>(<expr>!<name>low_prio_nonrep_cert</name></expr>)</condition><then> <comment type="line">// did not yet find a low prio cert</comment>
            <expr_stmt><expr><name>low_prio_nonrep_cert</name> = <call><name>CERT_DupCertificate</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then>
        <else>else <block>{
          <comment type="line">// this is a good cert to present</comment>
          <expr_stmt><expr><name>cert</name> = <call><name>CERT_DupCertificate</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block></else></if>
      }</block></then></if>
      <expr_stmt><expr><name>keyError</name> = <call><name>PR_GetError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>keyError</name> == <name>SEC_ERROR_BAD_PASSWORD</name></expr>)</condition><then> <block>{
          <comment type="block">/* problem with password: bail */</comment>
          <goto>goto <name>loser</name>;</goto>
      }</block></then></if>

      <expr_stmt><expr><name>node</name> = <call><name>CERT_LIST_NEXT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr>!<name>cert</name> &amp;&amp; <name>low_prio_nonrep_cert</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>cert</name> = <name>low_prio_nonrep_cert</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>low_prio_nonrep_cert</name> = <name>NULL</name></expr>;</expr_stmt> <comment type="line">// take it away from the cleaner</comment>
      <expr_stmt><expr><name>privKey</name> = <call><name>PK11_FindKeyByAnyCert</name><argument_list>(<argument><expr><name>cert</name></expr></argument>, <argument><expr><name>wincx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>cert</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <goto>goto <name>noCert</name>;</goto>
    }</block></then></if>
  }</block></then>
  <else>else <block>{
    <comment type="block">/* user selects a cert to present */</comment>
    <decl_stmt><decl><type><name>nsIClientAuthDialogs</name> *</type><name>dialogs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRInt32</name></type> <name>selectedIndex</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUnichar</name> **</type><name>certNicknameList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRUnichar</name> **</type><name>certDetailsList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>canceled</name></decl>;</decl_stmt>

    <comment type="block">/* find all user certs that are for SSL */</comment>
    <comment type="block">/* note that we are allowing expired certs in this list */</comment>
    <expr_stmt><expr><name>certList</name> = <call><name>CERT_FindUserCertsByUsage</name><argument_list>(<argument><expr><call><name>CERT_GetDefaultCertDB</name><argument_list>()</argument_list></call></expr></argument>, 
                                         <argument><expr><name>certUsageSSLClient</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>, 
                                         <argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr><name>wincx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>certList</name> == <name>NULL</name></expr>)</condition><then> <block>{
      <goto>goto <name>noCert</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>caNames</name>-&gt;<name>nnames</name></name> != 0</expr>)</condition><then> <block>{
      <comment type="block">/* filter the list to those issued by CAs supported by the 
       * server 
       */</comment>
      <expr_stmt><expr><name>ret</name> = <call><name>CERT_FilterCertListByCANames</name><argument_list>(<argument><expr><name>certList</name></expr></argument>, <argument><expr><name><name>caNames</name>-&gt;<name>nnames</name></name></expr></argument>, 
                                        <argument><expr><name>caNameStrings</name></expr></argument>, 
                                        <argument><expr><name>certUsageSSLClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ret</name> != <name>SECSuccess</name></expr>)</condition><then> <block>{
        <goto>goto <name>loser</name>;</goto>
      }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>CERT_LIST_END</name><argument_list>(<argument><expr><call><name>CERT_LIST_HEAD</name><argument_list>(<argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="block">/* list is empty - no matching certs */</comment>
      <goto>goto <name>noCert</name>;</goto>
    }</block></then></if>

    <comment type="block">/* filter it further for hostname restriction */</comment>
    <expr_stmt><expr><name>node</name> = <call><name>CERT_LIST_HEAD</name><argument_list>(<argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr>!<call><name>CERT_LIST_END</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
      <expr_stmt><expr>++<name>NumberOfCerts</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if> <comment type="block">/* XXX Fix this */</comment>
      if (!CERT_MatchesScopeOfUse(node-&gt;cert, conn-&gt;hostName,
                                  conn-&gt;hostIP, conn-&gt;port)) {
        CERTCertListNode* removed = node;
        node = CERT_LIST_NEXT(removed);
        CERT_RemoveCertListNode(removed);
      }
      else {
        node = CERT_LIST_NEXT(node);
      }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>node</name> = <call><name>CERT_LIST_NEXT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr><call><name>CERT_LIST_END</name><argument_list>(<argument><expr><call><name>CERT_LIST_HEAD</name><argument_list>(<argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <goto>goto <name>noCert</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><name>nicknames</name> = <call><name>getNSSCertNicknamesFromCertList</name><argument_list>(<argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>nicknames</name> == <name>NULL</name></expr>)</condition><then> <block>{
      <goto>goto <name>loser</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>nicknames</name>-&gt;<name>numnicknames</name></name> == <name>NumberOfCerts</name></expr></argument>, <argument><expr>"nicknames-&gt;numnicknames != NumberOfCerts"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the SSL Certificate */</comment>
    <expr_stmt><expr><name>serverCert</name> = <call><name>SSL_PeerCertificate</name><argument_list>(<argument><expr><name>socket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>serverCert</name> == <name>NULL</name></expr>)</condition><then> <block>{
      <comment type="block">/* couldn't get the server cert: what do I do? */</comment>
      <goto>goto <name>loser</name>;</goto>
    }</block></then></if>

    <comment type="block">/* Get CN and O of the subject and O of the issuer */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>ccn</name> <init>= <expr><call><name>CERT_GetCommonName</name><argument_list>(<argument><expr>&amp;<name><name>serverCert</name>-&gt;<name>subject</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>NS_ConvertUTF8toUTF16</name></type> <name>cn</name><parameter_list>(<param><decl><type><name>ccn</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr><name>ccn</name></expr>)</condition><then> <expr_stmt><expr><call><name>PORT_Free</name><argument_list>(<argument><expr><name>ccn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>char</name> *</type><name>corg</name> <init>= <expr><call><name>CERT_GetOrgName</name><argument_list>(<argument><expr>&amp;<name><name>serverCert</name>-&gt;<name>subject</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>NS_ConvertUTF8toUTF16</name></type> <name>org</name><parameter_list>(<param><decl><type><name>corg</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr><name>corg</name></expr>)</condition><then> <expr_stmt><expr><call><name>PORT_Free</name><argument_list>(<argument><expr><name>corg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <decl_stmt><decl><type><name>char</name> *</type><name>cissuer</name> <init>= <expr><call><name>CERT_GetOrgName</name><argument_list>(<argument><expr>&amp;<name><name>serverCert</name>-&gt;<name>issuer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>NS_ConvertUTF8toUTF16</name></type> <name>issuer</name><parameter_list>(<param><decl><type><name>cissuer</name></type></decl></param>)</parameter_list>;</function_decl>
    <if>if <condition>(<expr><name>cissuer</name></expr>)</condition><then> <expr_stmt><expr><call><name>PORT_Free</name><argument_list>(<argument><expr><name>cissuer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>CERT_DestroyCertificate</name><argument_list>(<argument><expr><name>serverCert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>certNicknameList</name> = (<name>PRUnichar</name> **)<call><name><name>nsMemory</name>::<name>Alloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PRUnichar</name> *</expr></argument>)</argument_list></sizeof> * <name><name>nicknames</name>-&gt;<name>numnicknames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>certNicknameList</name></expr>)</condition><then>
      <goto>goto <name>loser</name>;</goto></then></if>
    <expr_stmt><expr><name>certDetailsList</name> = (<name>PRUnichar</name> **)<call><name><name>nsMemory</name>::<name>Alloc</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PRUnichar</name> *</expr></argument>)</argument_list></sizeof> * <name><name>nicknames</name>-&gt;<name>numnicknames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>certDetailsList</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>nsMemory</name>::<name>Free</name></name><argument_list>(<argument><expr><name>certNicknameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>loser</name>;</goto>
    }</block></then></if>

    <decl_stmt><decl><type><name>PRInt32</name></type> <name>CertsToUse</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>CertsToUse</name> = 0</expr>, <expr><name>node</name> = <call><name>CERT_LIST_HEAD</name><argument_list>(<argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr>!<call><name>CERT_LIST_END</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>certList</name></expr></argument>)</argument_list></call> &amp;&amp; <name>CertsToUse</name> &lt; <name><name>nicknames</name>-&gt;<name>numnicknames</name></name></expr>;</condition>
         <incr><expr><name>node</name> = <call><name>CERT_LIST_NEXT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></incr>
        )
    <block>{
      <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsNSSCertificate</name></expr></argument>&gt;</argument_list></name></type> <name>tempCert</name> <init>= <expr>new <call><name>nsNSSCertificate</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>cert</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>!<name>tempCert</name></expr>)</condition><then>
        <continue>continue;</continue></then></if>
      
      <function_decl><type><name>NS_ConvertUTF8toUTF16</name></type> <name>i_nickname</name><parameter_list>(<param><decl><type><name><name>nicknames</name>-&gt;<name>nicknames</name><index>[<expr><name>CertsToUse</name></expr>]</index></name></type></decl></param>)</parameter_list>;</function_decl>
      <decl_stmt><decl><type><name>nsAutoString</name></type> <name>nickWithSerial</name></decl>, <decl><type ref="prev"/><name>details</name></decl>;</decl_stmt>
      
      <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><call><name><name>tempCert</name>-&gt;<name>FormatUIStrings</name></name><argument_list>(<argument><expr><name>i_nickname</name></expr></argument>, <argument><expr><name>nickWithSerial</name></expr></argument>, <argument><expr><name>details</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <expr_stmt><expr><name><name>certNicknameList</name><index>[<expr><name>CertsToUse</name></expr>]</index></name> = <call><name>ToNewUnicode</name><argument_list>(<argument><expr><name>nickWithSerial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name><name>certNicknameList</name><index>[<expr><name>CertsToUse</name></expr>]</index></name></expr>)</condition><then>
        <continue>continue;</continue></then></if>
      <expr_stmt><expr><name><name>certDetailsList</name><index>[<expr><name>CertsToUse</name></expr>]</index></name> = <call><name>ToNewUnicode</name><argument_list>(<argument><expr><name>details</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name><name>certDetailsList</name><index>[<expr><name>CertsToUse</name></expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>nsMemory</name>::<name>Free</name></name><argument_list>(<argument><expr><name><name>certNicknameList</name><index>[<expr><name>CertsToUse</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      }</block></then></if>

      <expr_stmt><expr>++<name>CertsToUse</name></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* Throw up the client auth dialog and get back the index of the selected cert */</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>getNSSDialogs</name><argument_list>(<argument><expr>(<name>void</name>**)&amp;<name>dialogs</name></expr></argument>, 
                       <argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIClientAuthDialogs</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>NS_CLIENTAUTHDIALOGS_CONTRACTID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY</name><argument_list>(<argument><expr><name>CertsToUse</name></expr></argument>, <argument><expr><name>certNicknameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY</name><argument_list>(<argument><expr><name>CertsToUse</name></expr></argument>, <argument><expr><name>certDetailsList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>loser</name>;</goto>
    }</block></then></if>

    <block>{
      <decl_stmt><decl><type><name>nsPSMUITracker</name></type> <name>tracker</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name><name>tracker</name>.<name>isUIForbidden</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_NOT_AVAILABLE</name></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <call><name><name>dialogs</name>-&gt;<name>ChooseCertificate</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><call><name><name>cn</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>org</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>issuer</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>, 
          <argument><expr>(const <name>PRUnichar</name>**)<name>certNicknameList</name></expr></argument>, <argument><expr>(const <name>PRUnichar</name>**)<name>certDetailsList</name></expr></argument>,
          <argument><expr><name>CertsToUse</name></expr></argument>, <argument><expr>&amp;<name>selectedIndex</name></expr></argument>, <argument><expr>&amp;<name>canceled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block>

    <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>dialogs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY</name><argument_list>(<argument><expr><name>CertsToUse</name></expr></argument>, <argument><expr><name>certNicknameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY</name><argument_list>(<argument><expr><name>CertsToUse</name></expr></argument>, <argument><expr><name>certDetailsList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <goto>goto <name>loser</name>;</goto></then></if>

    <if>if <condition>(<expr><name>canceled</name></expr>)</condition><then> <block>{ <expr_stmt><expr><name>rv</name> = <name>NS_ERROR_NOT_AVAILABLE</name></expr>;</expr_stmt> <goto>goto <name>loser</name>;</goto> }</block></then></if>

    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>node</name> = <call><name>CERT_LIST_HEAD</name><argument_list>(<argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr>!<call><name>CERT_LIST_END</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr>++<name>i</name></expr>, <expr><name>node</name> = <call><name>CERT_LIST_NEXT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></incr>) <block>{

      <if>if <condition>(<expr><name>i</name> == <name>selectedIndex</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>cert</name> = <call><name>CERT_DupCertificate</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>cert</name> == <name>NULL</name></expr>)</condition><then> <block>{
      <goto>goto <name>loser</name>;</goto>
    }</block></then></if>

    <comment type="block">/* go get the private key */</comment>
    <expr_stmt><expr><name>privKey</name> = <call><name>PK11_FindKeyByAnyCert</name><argument_list>(<argument><expr><name>cert</name></expr></argument>, <argument><expr><name>wincx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>privKey</name> == <name>NULL</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>keyError</name> = <call><name>PR_GetError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>keyError</name> == <name>SEC_ERROR_BAD_PASSWORD</name></expr>)</condition><then> <block>{
          <comment type="block">/* problem with password: bail */</comment>
          <goto>goto <name>loser</name>;</goto>
      }</block></then>
      <else>else <block>{
          <goto>goto <name>noCert</name>;</goto>
      }</block></else></if>
    }</block></then></if>
  }</block></else></if>
  <goto>goto <name>done</name>;</goto>

<label><name>noCert</name>:</label>
<label><name>loser</name>:</label>
  <if>if <condition>(<expr><name>ret</name> == <name>SECSuccess</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>ret</name> = <name>SECFailure</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>cert</name> != <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>CERT_DestroyCertificate</name><argument_list>(<argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cert</name> = <name>NULL</name></expr>;</expr_stmt>
  }</block></then></if>
<label><name>done</name>:</label>
  <if>if <condition>(<expr><name>extracted</name> != <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_Free</name><argument_list>(<argument><expr><name>extracted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>nicknames</name> != <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>CERT_FreeNicknames</name><argument_list>(<argument><expr><name>nicknames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>certList</name> != <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>CERT_DestroyCertList</name><argument_list>(<argument><expr><name>certList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>(<expr><name>arena</name> != <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PORT_FreeArena</name><argument_list>(<argument><expr><name>arena</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr>*<name>pRetCert</name> = <name>cert</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pRetKey</name> = <name>privKey</name></expr>;</expr_stmt>

  <return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>SECStatus</name></type>
<name>cancel_and_failure</name><parameter_list>(<param><decl><type><name>nsNSSSocketInfo</name>*</type> <name>infoObject</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>SetCanceled</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SECFailure</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>SECStatus</name></type>
<name>nsNSSBadCertHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>arg</name></decl></param>, <param><decl><type><name>PRFileDesc</name> *</type><name>sslSocket</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsNSSSocketInfo</name>*</type> <name>infoObject</name> <init>= <expr>(<name>nsNSSSocketInfo</name> *)<name>arg</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>infoObject</name></expr>)</condition><then>
    <return>return <expr><name>SECFailure</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name>CERTCertificate</name> *</type><name>peerCert</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>CERTCertificateCleaner</name></type> <name>peerCertCleaner</name><parameter_list>(<param><decl><type><name>peerCert</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><name>peerCert</name> = <call><name>SSL_PeerCertificate</name><argument_list>(<argument><expr><name>sslSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>peerCert</name></expr>)</condition><then>
    <return>return <expr><call><name>cancel_and_failure</name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>nsNSSCertificate</name></expr></argument>&gt;</argument_list></name></type> <name>nssCert</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>nssCert</name> = new <call><name>nsNSSCertificate</name><argument_list>(<argument><expr><name>peerCert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>nssCert</name></expr>)</condition><then>
    <return>return <expr><call><name>cancel_and_failure</name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIX509Cert</name></expr></argument>&gt;</argument_list></name></type> <name>ix509</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIX509Cert</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>nssCert</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SECStatus</name></type> <name>srv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>nsrv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>collected_errors</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>remaining_display_errors</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRErrorCode</name></type> <name>errorCodeTrust</name> <init>= <expr><name>SECSuccess</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRErrorCode</name></type> <name>errorCodeMismatch</name> <init>= <expr><name>SECSuccess</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRErrorCode</name></type> <name>errorCodeExpired</name> <init>= <expr><name>SECSuccess</name></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>char</name> *</type><name>hostname</name> <init>= <expr><call><name>SSL_RevealURL</name><argument_list>(<argument><expr><name>sslSocket</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <function_decl><type><name>charCleaner</name></type> <name>hostnameCleaner</name><parameter_list>(<param><decl><type><name>hostname</name></type></decl></param>)</parameter_list>;</function_decl> 
  <function_decl><type><name>nsDependentCString</name></type> <name>hostString</name><parameter_list>(<param><decl><type><name>hostname</name></type></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>port</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>GetPort</name></name><argument_list>(<argument><expr>&amp;<name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>nsCString</name></type> <name>hostWithPortString</name> <init>= <expr><name>hostString</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>hostWithPortString</name>.<name>AppendLiteral</name></name><argument_list>(<argument><expr>":"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>hostWithPortString</name>.<name>AppendInt</name></name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <function_decl><type><name>NS_ConvertUTF8toUTF16</name></type> <name>hostWithPortStringUTF16</name><parameter_list>(<param><decl><type><name>hostWithPortString</name></type></decl></param>)</parameter_list>;</function_decl>

  <comment type="line">// Check the name field against the desired hostname.</comment>
  <if>if <condition>(<expr><name>hostname</name> &amp;&amp; <name><name>hostname</name><index>[<expr>0</expr>]</index></name> &amp;&amp;
      <call><name>CERT_VerifyCertName</name><argument_list>(<argument><expr><name>peerCert</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call> != <name>SECSuccess</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>collected_errors</name> |= <name><name>nsICertOverrideService</name>::<name>ERROR_MISMATCH</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>errorCodeMismatch</name> = <name>SSL_ERROR_BAD_CERT_DOMAIN</name></expr>;</expr_stmt>
  }</block></then></if>

  <block>{
    <decl_stmt><decl><type><name>PRArenaPool</name> *</type><name>log_arena</name> <init>= <expr><call><name>PORT_NewArena</name><argument_list>(<argument><expr><name>DER_DEFAULT_CHUNKSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>log_arena</name></expr>)</condition><then>    
      <return>return <expr><call><name>cancel_and_failure</name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <function_decl><type><name>PRArenaPoolCleanerFalseParam</name></type> <name>log_arena_cleaner</name><parameter_list>(<param><decl><type><name>log_arena</name></type></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>CERTVerifyLog</name> *</type><name>verify_log</name> <init>= <expr><call><name>PORT_ArenaZNew</name><argument_list>(<argument><expr><name>log_arena</name></expr></argument>, <argument><expr><name>CERTVerifyLog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>verify_log</name></expr>)</condition><then>
      <return>return <expr><call><name>cancel_and_failure</name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <function_decl><type><name>CERTVerifyLogContentsCleaner</name></type> <name>verify_log_cleaner</name><parameter_list>(<param><decl><type><name>verify_log</name></type></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><name><name>verify_log</name>-&gt;<name>arena</name></name> = <name>log_arena</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>srv</name> = <call><name>CERT_VerifyCertificate</name><argument_list>(<argument><expr><call><name>CERT_GetDefaultCertDB</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>peerCert</name></expr></argument>,
                                 <argument><expr><name>PR_TRUE</name></expr></argument>, <argument><expr><name>certificateUsageSSLServer</name></expr></argument>,
                                 <argument><expr><call><name>PR_Now</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>void</name>*)<name>infoObject</name></expr></argument>, 
                                 <argument><expr><name>verify_log</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We ignore the result code of the cert verification.</comment>
    <comment type="line">// Either it is a failure, which is expected, and we'll process the</comment>
    <comment type="line">//                         verify log below.</comment>
    <comment type="line">// Or it is a success, then a domain mismatch is the only </comment>
    <comment type="line">//                     possible failure. </comment>

    <decl_stmt><decl><type><name>CERTVerifyLogNode</name> *</type><name>i_node</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i_node</name> = <name><name>verify_log</name>-&gt;<name>head</name></name></expr>;</init> <condition><expr><name>i_node</name></expr>;</condition> <incr><expr><name>i_node</name> = <name><name>i_node</name>-&gt;<name>next</name></name></expr></incr>)
    <block>{
      <switch>switch <condition>(<expr><name><name>i_node</name>-&gt;<name>error</name></name></expr>)</condition>
      <block>{
        <case>case <expr><name>SEC_ERROR_UNKNOWN_ISSUER</name></expr>:
        </case><case>case <expr><name>SEC_ERROR_CA_CERT_INVALID</name></expr>:
        </case><case>case <expr><name>SEC_ERROR_UNTRUSTED_ISSUER</name></expr>:
        </case><case>case <expr><name>SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE</name></expr>:
        </case><case>case <expr><name>SEC_ERROR_UNTRUSTED_CERT</name></expr>:
          <comment type="line">// We group all these errors as "cert not trusted"</comment>
          <expr_stmt><expr><name>collected_errors</name> |= <name><name>nsICertOverrideService</name>::<name>ERROR_UNTRUSTED</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>errorCodeTrust</name> == <name>SECSuccess</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>errorCodeTrust</name> = <name><name>i_node</name>-&gt;<name>error</name></name></expr>;</expr_stmt>
          }</block></then></if>
          <break>break;</break>
        </case><case>case <expr><name>SSL_ERROR_BAD_CERT_DOMAIN</name></expr>:
          <expr_stmt><expr><name>collected_errors</name> |= <name><name>nsICertOverrideService</name>::<name>ERROR_MISMATCH</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>errorCodeMismatch</name> == <name>SECSuccess</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>errorCodeMismatch</name> = <name><name>i_node</name>-&gt;<name>error</name></name></expr>;</expr_stmt>
          }</block></then></if>
          <break>break;</break>
        </case><case>case <expr><name>SEC_ERROR_EXPIRED_CERTIFICATE</name></expr>:
          <expr_stmt><expr><name>collected_errors</name> |= <name><name>nsICertOverrideService</name>::<name>ERROR_TIME</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>errorCodeExpired</name> == <name>SECSuccess</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>errorCodeExpired</name> = <name><name>i_node</name>-&gt;<name>error</name></name></expr>;</expr_stmt>
          }</block></then></if>
          <break>break;</break>
        </case><default>default:
          <comment type="line">// we are not willing to continue on any other error</comment>
          <expr_stmt><expr><call><name>nsHandleSSLError</name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>, <argument><expr><name><name>i_node</name>-&gt;<name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>cancel_and_failure</name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</return>
      </default>}</block></switch>
    }</block></for>
  }</block>

  <if>if <condition>(<expr>!<name>collected_errors</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>NS_NOTREACHED</name><argument_list>(<argument><expr>"why did NSS call our bad cert handler if all looks good? Let's cancel the connection"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SECFailure</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsSSLStatus</name></expr></argument>&gt;</argument_list></name></type> <name>status</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>GetSSLStatus</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>status</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>status</name> = new <call><name>nsSSLStatus</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>SetSSLStatus</name></name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>status</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr>!<name><name>status</name>-&gt;<name>mServerCert</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>status</name>-&gt;<name>mServerCert</name></name> = <name>nssCert</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>status</name>-&gt;<name>mHaveCertStatus</name></name> = <name>PR_TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>status</name>-&gt;<name>mIsDomainMismatch</name></name> = <name>collected_errors</name> &amp; <name><name>nsICertOverrideService</name>::<name>ERROR_MISMATCH</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>status</name>-&gt;<name>mIsNotValidAtThisTime</name></name> = <name>collected_errors</name> &amp; <name><name>nsICertOverrideService</name>::<name>ERROR_TIME</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>status</name>-&gt;<name>mIsUntrusted</name></name> = <name>collected_errors</name> &amp; <name><name>nsICertOverrideService</name>::<name>ERROR_UNTRUSTED</name></name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>remaining_display_errors</name> = <name>collected_errors</name></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsICertOverrideService</name></expr></argument>&gt;</argument_list></name></type> <name>overrideService</name> <init>= 
    <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_CERTOVERRIDE_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// it is fine to continue without the nsICertOverrideService</comment>

  <decl_stmt><decl><type><name>PRUint32</name></type> <name>storedOverrideBits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> 

  <if>if <condition>(<expr><name>overrideService</name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>haveStoredOverride</name></decl>;</decl_stmt>
  
    <expr_stmt><expr><name>nsrv</name> = <call><name><name>overrideService</name>-&gt;<name>HasMatchingOverride</name></name><argument_list>(<argument><expr><name>hostWithPortStringUTF16</name></expr></argument>,
                                                <argument><expr><name>ix509</name></expr></argument>, 
                                                <argument><expr>&amp;<name>storedOverrideBits</name></expr></argument>, 
                                                <argument><expr>&amp;<name>haveStoredOverride</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>NS_SUCCEEDED</name><argument_list>(<argument><expr><name>nsrv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>haveStoredOverride</name></expr>)</condition><then> 
    <block>{
      <comment type="line">// remove the errors that are already overriden</comment>
      <expr_stmt><expr><name>remaining_display_errors</name> -= <name>storedOverrideBits</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if <condition>(<expr>!<name>remaining_display_errors</name></expr>)</condition><then> <block>{
    <comment type="line">// all errors are covered by override rules, so let's accept the cert</comment>
    <return>return <expr><name>SECSuccess</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Ok, this is a full stop.</comment>
  <comment type="line">// First, deliver the technical details of the broken SSL status,</comment>
  <comment type="line">// giving the caller a chance to suppress the error messages.</comment>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>suppressMessage</name> <init>= <expr><name>PR_FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

  <comment type="line">// Try to get a nsIBadCertListener2 implementation from the socket consumer.</comment>
  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIInterfaceRequestor</name></expr></argument>&gt;</argument_list></name></type> <name>callbacks</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>GetNotificationCallbacks</name></name><argument_list>(<argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>callbacks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>callbacks</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIBadCertListener2</name></expr></argument>&gt;</argument_list></name></type> <name>bcl</name> <init>= <expr><call><name>do_GetInterface</name><argument_list>(<argument><expr><name>callbacks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>bcl</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>nsIBadCertListener2</name> *</type><name>proxy_bcl</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>NS_GetProxyForObject</name><argument_list>(<argument><expr><name>NS_PROXY_TO_MAIN_THREAD</name></expr></argument>,
                           <argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsIBadCertListener2</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>bcl</name></expr></argument>,
                           <argument><expr><name>NS_PROXY_SYNC</name></expr></argument>,
                           <argument><expr>(<name>void</name>**)&amp;<name>proxy_bcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>proxy_bcl</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>nsIInterfaceRequestor</name> *</type><name>csi</name> <init>= <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>nsIInterfaceRequestor</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name><name>proxy_bcl</name>-&gt;<name>NotifyCertProblem</name></name><argument_list>(<argument><expr><name>csi</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>hostWithPortString</name></expr></argument>, 
                                          <argument><expr>&amp;<name>suppressMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsCOMPtr</name><argument_list>&lt;<argument><expr><name>nsIRecentBadCertsService</name></expr></argument>&gt;</argument_list></name></type> <name>recentBadCertsService</name> <init>= 
    <expr><call><name>do_GetService</name><argument_list>(<argument><expr><name>NS_RECENTBADCERTS_CONTRACTID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>recentBadCertsService</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>recentBadCertsService</name>-&gt;<name>AddBadCert</name></name><argument_list>(<argument><expr><name>hostWithPortStringUTF16</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// pick the error code to report by priority</comment>
  <decl_stmt><decl><type><name>PRErrorCode</name></type> <name>errorCodeToReport</name> <init>= <expr><name>SECSuccess</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>remaining_display_errors</name> &amp; <name><name>nsICertOverrideService</name>::<name>ERROR_UNTRUSTED</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>errorCodeToReport</name> = <name>errorCodeTrust</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>remaining_display_errors</name> &amp; <name><name>nsICertOverrideService</name>::<name>ERROR_MISMATCH</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>errorCodeToReport</name> = <name>errorCodeMismatch</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>remaining_display_errors</name> &amp; <name><name>nsICertOverrideService</name>::<name>ERROR_TIME</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>errorCodeToReport</name> = <name>errorCodeExpired</name></expr>;</expr_stmt></then></if></else></if></else></if>

  <expr_stmt><expr><call><name>PR_SetError</name><argument_list>(<argument><expr><name>errorCodeToReport</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>suppressMessage</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>nsHandleInvalidCertError</name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>,
                             <argument><expr><name>remaining_display_errors</name></expr></argument>,
                             <argument><expr><name>hostString</name></expr></argument>,
                             <argument><expr><name>hostWithPortString</name></expr></argument>,
                             <argument><expr><name>port</name></expr></argument>,
                             <argument><expr><name>errorCodeToReport</name></expr></argument>,
                             <argument><expr><name>errorCodeTrust</name></expr></argument>,
                             <argument><expr><name>errorCodeMismatch</name></expr></argument>,
                             <argument><expr><name>errorCodeExpired</name></expr></argument>,
                             <argument><expr><name>ix509</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><call><name>cancel_and_failure</name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>PRFileDesc</name>*</type>
<name>nsSSLIOLayerImportFD</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>,
                     <param><decl><type><name>nsNSSSocketInfo</name> *</type><name>infoObject</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRFileDesc</name>*</type> <name>sslSock</name> <init>= <expr><call><name>SSL_ImportFD</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>sslSock</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"NSS: Error importing socket"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>SSL_SetPKCS11PinArg</name><argument_list>(<argument><expr><name>sslSock</name></expr></argument>, <argument><expr>(<name>nsIInterfaceRequestor</name>*)<name>infoObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SSL_HandshakeCallback</name><argument_list>(<argument><expr><name>sslSock</name></expr></argument>, <argument><expr><name>HandshakeCallback</name></expr></argument>, <argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SSL_GetClientAuthDataHook</name><argument_list>(<argument><expr><name>sslSock</name></expr></argument>, 
                            <argument><expr>(<name>SSLGetClientAuthData</name>)<name>nsNSS_SSLGetClientAuthData</name></expr></argument>,
                            <argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SSL_AuthCertificateHook</name><argument_list>(<argument><expr><name>sslSock</name></expr></argument>, <argument><expr><name>AuthCertificateCallback</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRInt32</name></type> <name>ret</name> <init>= <expr><call><name>SSL_SetURL</name><argument_list>(<argument><expr><name>sslSock</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>ret</name> == -1</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"NSS: Error setting server name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>loser</name>;</goto>
  }</block></then></if>
  <return>return <expr><name>sslSock</name></expr>;</return>
<label><name>loser</name>:</label>
  <if>if <condition>(<expr><name>sslSock</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_Close</name><argument_list>(<argument><expr><name>sslSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>nsnull</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>nsresult</name></type>
<name>nsSSLIOLayerSetOptions</name><parameter_list>(<param><decl><type><name>PRFileDesc</name> *</type><name>fd</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>forSTARTTLS</name></decl></param>, 
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proxyHost</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host</name></decl></param>, <param><decl><type><name>PRInt32</name></type> <name>port</name></decl></param>,
                       <param><decl><type><name>nsNSSSocketInfo</name> *</type><name>infoObject</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>forSTARTTLS</name> || <name>proxyHost</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>SECSuccess</name> != <call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SSL_SECURITY</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>SetHasCleartextPhase</name></name><argument_list>(<argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>forSTARTTLS</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>SECSuccess</name> != <call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SSL_ENABLE_SSL2</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>SECSuccess</name> != <call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SSL_V2_COMPATIBLE_HELLO</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <comment type="line">// Let's see if we're trying to connect to a site we know is</comment>
  <comment type="line">// TLS intolerant.</comment>
  <decl_stmt><decl><type><name>nsCAutoString</name></type> <name>key</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>key</name> = <call><name>nsDependentCString</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call> + <call><name>NS_LITERAL_CSTRING</name><argument_list>(<argument><expr>":"</expr></argument>)</argument_list></call> + <call><name>nsPrintfCString</name><argument_list>(<argument><expr>"%d"</expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name><name>nsSSLIOLayerHelpers</name>::<name>isKnownAsIntolerantSite</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>SECSuccess</name> != <call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SSL_ENABLE_TLS</name></expr></argument>, <argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>SetAllowTLSIntoleranceTimeout</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
    <comment type="line">// We assume that protocols that use the STARTTLS mechanism should support</comment>
    <comment type="line">// modern hellos. For other protocols, if we suspect a site </comment>
    <comment type="line">// does not support TLS, let's also use V2 hellos.</comment>
    <comment type="line">// One advantage of this approach, if a site only supports the older</comment>
    <comment type="line">// hellos, it is more likely that we will get a reasonable error code</comment>
    <comment type="line">// on our single retry attempt.</comment>
    
    <if>if <condition>(<expr>!<name>forSTARTTLS</name> &amp;&amp;
        <name>SECSuccess</name> != <call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SSL_V2_COMPATIBLE_HELLO</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>SECSuccess</name> != <call><name>SSL_OptionSet</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SSL_HANDSHAKE_AS_CLIENT</name></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>
  <if>if <condition>(<expr><name>SECSuccess</name> != <call><name>SSL_BadCertHook</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>(<name>SSLBadCertHandler</name>) <name>nsNSSBadCertHandler</name></expr></argument>,
                                    <argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <comment type="line">// Set the Peer ID so that SSL proxy connections work properly.</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>peerId</name> <init>= <expr><call><name>PR_smprintf</name><argument_list>(<argument><expr>"%s:%d"</expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>SECSuccess</name> != <call><name>SSL_SetSockPeerID</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>peerId</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>PR_smprintf_free</name><argument_list>(<argument><expr><name>peerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>PR_smprintf_free</name><argument_list>(<argument><expr><name>peerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NS_OK</name></expr>;</return>
}</block></function>

<function><type><name>nsresult</name></type>
<name>nsSSLIOLayerAddToSocket</name><parameter_list>(<param><decl><type><name>PRInt32</name></type> <name>family</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>host</name></decl></param>,
                        <param><decl><type><name>PRInt32</name></type> <name>port</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>proxyHost</name></decl></param>,
                        <param><decl><type><name>PRInt32</name></type> <name>proxyPort</name></decl></param>,
                        <param><decl><type><name>PRFileDesc</name>*</type> <name>fd</name></decl></param>,
                        <param><decl><type><name>nsISupports</name>**</type> <name>info</name></decl></param>,
                        <param><decl><type><name>PRBool</name></type> <name>forSTARTTLS</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>nsNSSShutDownPreventionLock</name></type> <name>locker</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRFileDesc</name>*</type> <name>layer</name> <init>= <expr><name>nsnull</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsresult</name></type> <name>rv</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsNSSSocketInfo</name>*</type> <name>infoObject</name> <init>= <expr>new <call><name>nsNSSSocketInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>infoObject</name></expr>)</condition><then> <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return></then></if>
  
  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>SetForSTARTTLS</name></name><argument_list>(<argument><expr><name>forSTARTTLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>SetHostName</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>SetPort</name></name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>PRFileDesc</name> *</type><name>sslSock</name> <init>= <expr><call><name>nsSSLIOLayerImportFD</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>infoObject</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>sslSock</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>, <argument><expr>"NSS: Error importing socket"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>loser</name>;</goto>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>SetFileDescPtr</name></name><argument_list>(<argument><expr><name>sslSock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rv</name> = <call><name>nsSSLIOLayerSetOptions</name><argument_list>(<argument><expr><name>sslSock</name></expr></argument>, <argument><expr><name>forSTARTTLS</name></expr></argument>, <argument><expr><name>proxyHost</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>,
                              <argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <goto>goto <name>loser</name>;</goto></then></if>

  <comment type="block">/* Now, layer ourselves on top of the SSL socket... */</comment>
  <expr_stmt><expr><name>layer</name> = <call><name>PR_CreateIOLayerStub</name><argument_list>(<argument><expr><name><name>nsSSLIOLayerHelpers</name>::<name>nsSSLIOLayerIdentity</name></name></expr></argument>,
                               <argument><expr>&amp;<name><name>nsSSLIOLayerHelpers</name>::<name>nsSSLIOLayerMethods</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>layer</name></expr>)</condition><then>
    <goto>goto <name>loser</name>;</goto></then></if>
  
  <expr_stmt><expr><name><name>layer</name>-&gt;<name>secret</name></name> = (<name>PRFilePrivate</name>*) <name>infoObject</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rv</name> = <call><name>PR_PushIOLayer</name><argument_list>(<argument><expr><name>sslSock</name></expr></argument>, <argument><expr><call><name>PR_GetLayersIdentity</name><argument_list>(<argument><expr><name>sslSock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>layer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if>if <condition>(<expr><call><name>NS_FAILED</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <goto>goto <name>loser</name>;</goto>
  }</block></then></if>
  
  <expr_stmt><expr><call><name><name>nsNSSShutDownList</name>::<name>trackSSLSocketCreate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PR_LOG</name><argument_list>(<argument><expr><name>gPIPNSSLog</name></expr></argument>, <argument><expr><name>PR_LOG_DEBUG</name></expr></argument>, <argument><expr>("[%p] Socket set up\n", (<name>void</name>*)<name>sslSock</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>QueryInterface</name></name><argument_list>(<argument><expr><call><name>NS_GET_IID</name><argument_list>(<argument><expr><name>nsISupports</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>void</name>**) (<name>info</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// We are going use a clear connection first //</comment>
  <if>if <condition>(<expr><name>forSTARTTLS</name> || <name>proxyHost</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>infoObject</name>-&gt;<name>SetHandshakePending</name></name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>NS_OK</name></expr>;</return>
 <label><name>loser</name>:</label>
  <expr_stmt><expr><call><name>NS_IF_RELEASE</name><argument_list>(<argument><expr><name>infoObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>layer</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>layer</name>-&gt;<name>dtor</name></name><argument_list>(<argument><expr><name>layer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>NS_ERROR_FAILURE</name></expr>;</return>
}</block></function>
</unit>
