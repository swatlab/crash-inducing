<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="007a1f3523e4e5bc19815b69a5a27f993aedf1e5.cpp"><comment type="block">/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Mozilla Corporation code.
 *
 * The Initial Developer of the Original Code is Mozilla Foundation.
 * Portions created by the Initial Developer are Copyright (C) 2009
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Robert O'Callahan &lt;robert@ocallahan.org&gt;
 *   Chris Jones &lt;jones.chris.g@gmail.com&gt;
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"gfxSharedImageSurface.h"</cpp:file></cpp:include>

<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/layers/PLayerChild.h"</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/layers/PLayersChild.h"</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"mozilla/layers/PLayersParent.h"</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"ipc/ShadowLayerChild.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"BasicLayers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ImageLayers.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsTArray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsGUIEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIRenderingContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxImageSurface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxPattern.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxPlatform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gfxUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ThebesLayerBuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nsIWidget.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"GLContext.h"</cpp:file></cpp:include>

<namespace>namespace <name>mozilla</name> <block>{
<namespace>namespace <name>layers</name> <block>{

<class_decl>class <name>BasicContainerLayer</name>;</class_decl>
<class_decl>class <name>ShadowableLayer</name>;</class_decl>

<comment type="block" format="doxygen">/**
 * This is the ImplData for all Basic layers. It also exposes methods
 * private to the Basic implementation that are common to all Basic layer types.
 * In particular, there is an internal Paint() method that we can use
 * to paint the contents of non-Thebes layers.
 *
 * The class hierarchy for Basic layers is like this:
 *                                 BasicImplData
 * Layer                            |   |   |
 *  |                               |   |   |
 *  +-&gt; ContainerLayer              |   |   |
 *  |    |                          |   |   |
 *  |    +-&gt; BasicContainerLayer &lt;--+   |   |
 *  |                                   |   |
 *  +-&gt; ThebesLayer                     |   |
 *  |    |                              |   |
 *  |    +-&gt; BasicThebesLayer &lt;---------+   |
 *  |                                       |
 *  +-&gt; ImageLayer                          |
 *       |                                  |
 *       +-&gt; BasicImageLayer &lt;--------------+
 */</comment>
<class>class <name>BasicImplData</name> <block>{<private type="default">
</private><public>public:
  <constructor><name>BasicImplData</name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicImplData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicImplData</name></name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicImplData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <comment type="block" format="doxygen">/**
   * Layers that paint themselves, such as ImageLayers, should paint
   * in response to this method call. aContext will already have been
   * set up to account for all the properties of the layer (transform,
   * opacity, etc).
   */</comment>
  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                     <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                     <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list> <block>{}</block></function>

  <function><type><specifier>virtual</specifier> <name>ShadowableLayer</name>*</type> <name>AsShadowableLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>nsnull</name></expr>;</return> }</block></function>

  <comment type="block" format="doxygen">/**
   * Layers will get this call when their layer manager is destroyed, this
   * indicates they should clear resources they don't really need after their
   * LayerManager ceases to exist.
   */</comment>
  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>ClearCachedResources</name><parameter_list>()</parameter_list> <block>{}</block></function>
</public>}</block>;</class>

<function><type><specifier>static</specifier> <name>BasicImplData</name>*</type>
<name>ToData</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicImplData</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>aLayer</name>-&gt;<name>ImplData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<class>class <name>BasicContainerLayer</name> <super>: <specifier>public</specifier> <name>ContainerLayer</name>, <name>BasicImplData</name></super> <block>{<private type="default">
</private><public>public:
  <constructor><name>BasicContainerLayer</name><parameter_list>(<param><decl><type><name>BasicLayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>ContainerLayer</name><argument_list>(<argument><expr><name>aManager</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicImplData</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicContainerLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor_decl><specifier>virtual</specifier> <name>~<name>BasicContainerLayer</name></name><parameter_list>()</parameter_list>;</destructor_decl>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SetVisibleRegion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegion</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"Can only set properties in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ContainerLayer</name>::<name>SetVisibleRegion</name></name><argument_list>(<argument><expr><name>aRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>InsertAfter</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aChild</name></decl></param>, <param><decl><type><name>Layer</name>*</type> <name>aAfter</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>RemoveChild</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aChild</name></decl></param>)</parameter_list>;</function_decl>

</public><protected>protected:
  <function_decl><type><name>void</name></type> <name>RemoveChildInternal</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aChild</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><name>BasicLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>
</protected>}</block>;</class>

<destructor><name><name>BasicContainerLayer</name>::~<name>BasicContainerLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <while>while <condition>(<expr><name>mFirstChild</name></expr>)</condition> <block>{
    <expr_stmt><expr><call><name>RemoveChildInternal</name><argument_list>(<argument><expr><name>mFirstChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>

  <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicContainerLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>void</name></type>
<name><name>BasicContainerLayer</name>::<name>InsertAfter</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aChild</name></decl></param>, <param><decl><type><name>Layer</name>*</type> <name>aAfter</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Can only set properties in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aChild</name>-&gt;<name>Manager</name></name><argument_list>()</argument_list></call> == <call><name>Manager</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Child has wrong manager"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name><name>aChild</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"aChild already in the tree"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name><name>aChild</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>aChild</name>-&gt;<name>GetPrevSibling</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"aChild already has siblings?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<name>aAfter</name> ||
               (<call><name><name>aAfter</name>-&gt;<name>Manager</name></name><argument_list>()</argument_list></call> == <call><name>Manager</name><argument_list>()</argument_list></call> &amp;&amp;
                <call><name><name>aAfter</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call> == <name>this</name>)</expr></argument>,
               <argument><expr>"aAfter is not our child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ADDREF</name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>aChild</name>-&gt;<name>SetParent</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>aAfter</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>mFirstChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>mFirstChild</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mFirstChild</name>-&gt;<name>SetPrevSibling</name></name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>mFirstChild</name> = <name>aChild</name></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>Layer</name>*</type> <name>next</name> <init>= <expr><call><name><name>aAfter</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aChild</name>-&gt;<name>SetPrevSibling</name></name><argument_list>(<argument><expr><name>aAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>next</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>next</name>-&gt;<name>SetPrevSibling</name></name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>aAfter</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicContainerLayer</name>::<name>RemoveChild</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aChild</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Can only set properties in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>RemoveChildInternal</name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicContainerLayer</name>::<name>RemoveChildInternal</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aChild</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aChild</name>-&gt;<name>Manager</name></name><argument_list>()</argument_list></call> == <call><name>Manager</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Child has wrong manager"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aChild</name>-&gt;<name>GetParent</name></name><argument_list>()</argument_list></call> == <name>this</name></expr></argument>,
               <argument><expr>"aChild not our child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>Layer</name>*</type> <name>prev</name> <init>= <expr><call><name><name>aChild</name>-&gt;<name>GetPrevSibling</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Layer</name>*</type> <name>next</name> <init>= <expr><call><name><name>aChild</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>prev</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>prev</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>mFirstChild</name> = <name>next</name></expr>;</expr_stmt>
  }</block></else></if>
  <if>if <condition>(<expr><name>next</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>next</name>-&gt;<name>SetPrevSibling</name></name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>aChild</name>-&gt;<name>SetNextSibling</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aChild</name>-&gt;<name>SetPrevSibling</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aChild</name>-&gt;<name>SetParent</name></name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_RELEASE</name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<class_decl>class <name>BasicThebesLayer</name>;</class_decl>
<class>class <name>BasicThebesLayerBuffer</name> <super>: <specifier>public</specifier> <name>ThebesLayerBuffer</name></super> <block>{<private type="default">
  <typedef>typedef <type><name>ThebesLayerBuffer</name></type> <name>Base</name>;</typedef>

</private><public>public:
  <constructor><name>BasicThebesLayerBuffer</name><parameter_list>(<param><decl><type><name>BasicThebesLayer</name>*</type> <name>aLayer</name></decl></param>)</parameter_list>
    <member_list>: <call><name>Base</name><argument_list>(<argument><expr><name>ContainsVisibleBounds</name></expr></argument>)</argument_list></call>
    , <call><name>mLayer</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call>
  </member_list><block>{}</block></constructor>

  <destructor><specifier>virtual</specifier> <name>~<name>BasicThebesLayerBuffer</name></name><parameter_list>()</parameter_list>
  <block>{}</block></destructor>

  <using>using <name><name>Base</name>::<name>BufferRect</name></name>;</using>
  <using>using <name><name>Base</name>::<name>BufferRotation</name></name>;</using>

  <comment type="block" format="doxygen">/**
   * Complete the drawing operation. The region to draw must have been
   * drawn before this is called. The contents of the buffer are drawn
   * to aTarget.
   */</comment>
  <function_decl><type><name>void</name></type> <name>DrawTo</name><parameter_list>(<param><decl><type><name>ThebesLayer</name>*</type> <name>aLayer</name></decl></param>, <param><decl><type><name>PRBool</name></type> <name>aIsOpaqueContent</name></decl></param>,
              <param><decl><type><name>gfxContext</name>*</type> <name>aTarget</name></decl></param>, <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>virtual</specifier> <name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
  <name>CreateBuffer</name><parameter_list>(<param><decl><type><name>ContentType</name></type> <name>aType</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsIntSize</name>&amp;</type> <name>aSize</name></decl></param>)</parameter_list>;</function_decl>

</public><private>private:
  <decl_stmt><decl><type><name>BasicThebesLayer</name>*</type> <name>mLayer</name></decl>;</decl_stmt>
</private>}</block>;</class>

<class>class <name>BasicThebesLayer</name> <super>: <specifier>public</specifier> <name>ThebesLayer</name>, <name>BasicImplData</name></super> <block>{<private type="default">
</private><public>public:
  <typedef>typedef <type><name>BasicThebesLayerBuffer</name></type> <name>Buffer</name>;</typedef>

  <constructor><name>BasicThebesLayer</name><parameter_list>(<param><decl><type><name>BasicLayerManager</name>*</type> <name>aLayerManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>ThebesLayer</name><argument_list>(<argument><expr><name>aLayerManager</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicImplData</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>,
    <call><name>mBuffer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicThebesLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicThebesLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicThebesLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SetVisibleRegion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegion</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"Can only set properties in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ThebesLayer</name>::<name>SetVisibleRegion</name></name><argument_list>(<argument><expr><name>aRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>
  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>InvalidateRegion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegion</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"Can only set properties in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mValidRegion</name>.<name>Sub</name></name><argument_list>(<argument><expr><name>mValidRegion</name></expr></argument>, <argument><expr><name>aRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                     <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                     <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>ClearCachedResources</name><parameter_list>()</parameter_list> <block>{ <expr_stmt><expr><call><name><name>mBuffer</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name><name>mValidRegion</name>.<name>SetEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
  
  <function><type><specifier>virtual</specifier> <name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
  <name>CreateBuffer</name><parameter_list>(<param><decl><type><name><name>Buffer</name>::<name>ContentType</name></name></type> <name>aType</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsIntSize</name>&amp;</type> <name>aSize</name></decl></param>)</parameter_list>
  <block>{
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>referenceSurface</name> <init>= <expr><call><name><name>mBuffer</name>.<name>GetBuffer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>referenceSurface</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>gfxContext</name>*</type> <name>defaultTarget</name> <init>= <expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetDefaultTarget</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>defaultTarget</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>referenceSurface</name> = <call><name><name>defaultTarget</name>-&gt;<name>CurrentSurface</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <decl_stmt><decl><type><name>nsIWidget</name>*</type> <name>widget</name> <init>= <expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetRetainerWidget</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>widget</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>referenceSurface</name> = <call><name><name>widget</name>-&gt;<name>GetThebesSurface</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><name>referenceSurface</name> = <call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetTarget</name><argument_list>()</argument_list></call>-&gt;<call><name>CurrentSurface</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></else></if>
    }</block></then></if>
    <return>return <expr><call><name><name>referenceSurface</name>-&gt;<name>CreateSimilarSurface</name></name><argument_list>(
      <argument><expr><name>aType</name></expr></argument>, <argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name><name>aSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

</public><protected>protected:
  <function><type><name>BasicLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <function><type><specifier>virtual</specifier> <name>void</name></type>
  <name>PaintBuffer</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegionToDraw</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegionToInvalidate</name></decl></param>,
              <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
              <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>aCallback</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>aContext</name></expr></argument>, <argument><expr><name>aRegionToDraw</name></expr></argument>, <argument><expr><name>aRegionToInvalidate</name></expr></argument>,
              <argument><expr><name>aCallbackData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mValidRegion</name>.<name>Or</name></name><argument_list>(<argument><expr><name>mValidRegion</name></expr></argument>, <argument><expr><name>aRegionToDraw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <decl_stmt><decl><type><name>Buffer</name></type> <name>mBuffer</name></decl>;</decl_stmt>
</protected>}</block>;</class>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ClipToContain</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>gfxRect</name></type> <name>deviceRect</name> <init>=
    <expr><call><name><name>aContext</name>-&gt;<name>UserToDevice</name></name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr><name><name>aRect</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>aRect</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>aRect</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aRect</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>deviceRect</name>.<name>RoundOut</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>currentMatrix</name> <init>= <expr><call><name><name>aContext</name>-&gt;<name>CurrentMatrix</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>IdentityMatrix</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Rectangle</name></name><argument_list>(<argument><expr><name>deviceRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Clip</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>SetMatrix</name></name><argument_list>(<argument><expr><name>currentMatrix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>InheritContextFlags</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aSource</name></decl></param>, <param><decl><type><name>gfxContext</name>*</type> <name>aDest</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name><name>aSource</name>-&gt;<name>GetFlags</name></name><argument_list>()</argument_list></call> &amp; <name><name>gfxContext</name>::<name>FLAG_DESTINED_FOR_SCREEN</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aDest</name>-&gt;<name>SetFlag</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>FLAG_DESTINED_FOR_SCREEN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name><name>aDest</name>-&gt;<name>ClearFlag</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>FLAG_DESTINED_FOR_SCREEN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>ShouldRetainTransparentSurface</name><parameter_list>(<param><decl><type><name>PRUint32</name></type> <name>aContentFlags</name></decl></param>,
                               <param><decl><type><name>gfxASurface</name>*</type> <name>aTargetSurface</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>aContentFlags</name> &amp; <name><name>Layer</name>::<name>CONTENT_NO_TEXT</name></name></expr>)</condition><then>
    <return>return <expr><name>PR_TRUE</name></expr>;</return></then></if>

  <switch>switch <condition>(<expr><call><name><name>aTargetSurface</name>-&gt;<name>GetTextQualityInTransparentSurfaces</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
  <case>case <expr><name><name>gfxASurface</name>::<name>TEXT_QUALITY_OK</name></name></expr>:
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  </case><case>case <expr><name><name>gfxASurface</name>::<name>TEXT_QUALITY_OK_OVER_OPAQUE_PIXELS</name></name></expr>:
    <return>return <expr>(<name>aContentFlags</name> &amp; <name><name>Layer</name>::<name>CONTENT_NO_TEXT_OVER_TRANSPARENT</name></name>) != 0</expr>;</return>
  </case><default>default:
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  </default>}</block></switch>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicThebesLayer</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                        <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                        <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                        <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InDrawing</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Can only draw in drawing phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>gfxContext</name>*</type> <name>target</name> <init>= <expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetTarget</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr>"We shouldn't be called if there's no target"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>targetSurface</name> <init>= <expr><call><name><name>aContext</name>-&gt;<name>CurrentSurface</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRBool</name></type> <name>canUseOpaqueSurface</name> <init>= <expr><call><name>CanUseOpaqueSurface</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>IsRetained</name><argument_list>()</argument_list></call> ||
      (<name>aOpacity</name> == 1.0 &amp;&amp; !<name>canUseOpaqueSurface</name> &amp;&amp;
       !<call><name>ShouldRetainTransparentSurface</name><argument_list>(<argument><expr><name>mContentFlags</name></expr></argument>, <argument><expr><name>targetSurface</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mValidRegion</name>.<name>SetEmpty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mBuffer</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>aOpacity</name> != 1.0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>target</name>-&gt;<name>Save</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ClipToContain</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><call><name><name>mVisibleRegion</name>.<name>GetBounds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>target</name>-&gt;<name>PushGroup</name></name><argument_list>(<argument><expr><name><name>gfxASurface</name>::<name>CONTENT_COLOR_ALPHA</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>aCallback</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>mVisibleRegion</name></expr></argument>, <argument><expr><call><name>nsIntRegion</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aCallbackData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>aOpacity</name> != 1.0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>target</name>-&gt;<name>PopGroupToSource</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>target</name>-&gt;<name>Paint</name></name><argument_list>(<argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>target</name>-&gt;<name>Restore</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
  }</block></then></if>

  <block>{
    <decl_stmt><decl><type><name>PRBool</name></type> <name>opaqueBuffer</name> <init>= <expr><name>canUseOpaqueSurface</name> &amp;&amp;
      <call><name><name>targetSurface</name>-&gt;<name>AreSimilarSurfacesSensitiveToContentType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Buffer</name>::<name>ContentType</name></name></type> <name>contentType</name> <init>=
      <expr><name>opaqueBuffer</name> ? <name><name>gfxASurface</name>::<name>CONTENT_COLOR</name></name> :
                     <name><name>gfxASurface</name>::<name>CONTENT_COLOR_ALPHA</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Buffer</name>::<name>PaintState</name></name></type> <name>state</name> <init>= <expr><call><name><name>mBuffer</name>.<name>BeginPaint</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>contentType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>mValidRegion</name>.<name>Sub</name></name><argument_list>(<argument><expr><name>mValidRegion</name></expr></argument>, <argument><expr><name><name>state</name>.<name>mRegionToInvalidate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>state</name>.<name>mContext</name></name></expr>)</condition><then> <block>{
      <comment type="line">// The area that became invalid and is visible needs to be repainted</comment>
      <comment type="line">// (this could be the whole visible area if our buffer switched</comment>
      <comment type="line">// from RGB to RGBA, because we might need to repaint with</comment>
      <comment type="line">// subpixel AA)</comment>
      <expr_stmt><expr><call><name><name>state</name>.<name>mRegionToInvalidate</name>.<name>And</name></name><argument_list>(<argument><expr><name><name>state</name>.<name>mRegionToInvalidate</name></name></expr></argument>, <argument><expr><name>mVisibleRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>InheritContextFlags</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>state</name>.<name>mContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PaintBuffer</name><argument_list>(<argument><expr><name><name>state</name>.<name>mContext</name></name></expr></argument>,
                  <argument><expr><name><name>state</name>.<name>mRegionToDraw</name></name></expr></argument>, <argument><expr><name><name>state</name>.<name>mRegionToInvalidate</name></name></expr></argument>,
                  <argument><expr><name>aCallback</name></expr></argument>, <argument><expr><name>aCallbackData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <comment type="line">// It's possible that state.mRegionToInvalidate is nonempty here,</comment>
      <comment type="line">// if we are shrinking the valid region to nothing.</comment>
      <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>state</name>.<name>mRegionToDraw</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></argument>,
                   <argument><expr>"If we need to draw, we should have a context"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block>

  <expr_stmt><expr><call><name><name>mBuffer</name>.<name>DrawTo</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>canUseOpaqueSurface</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicThebesLayerBuffer</name>::<name>DrawTo</name></name><parameter_list>(<param><decl><type><name>ThebesLayer</name>*</type> <name>aLayer</name></decl></param>,
                               <param><decl><type><name>PRBool</name></type> <name>aIsOpaqueContent</name></decl></param>,
                               <param><decl><type><name>gfxContext</name>*</type> <name>aTarget</name></decl></param>,
                               <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aTarget</name>-&gt;<name>Save</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ClipToRegion</name><argument_list>(<argument><expr><name>aTarget</name></expr></argument>, <argument><expr><call><name><name>aLayer</name>-&gt;<name>GetVisibleRegion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aIsOpaqueContent</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aTarget</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>DrawBufferWithRotation</name><argument_list>(<argument><expr><name>aTarget</name></expr></argument>, <argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aTarget</name>-&gt;<name>Restore</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicThebesLayerBuffer</name>::<name>CreateBuffer</name></name><parameter_list>(<param><decl><type><name>ContentType</name></type> <name>aType</name></decl></param>, 
                                     <param><decl><type><specifier>const</specifier> <name>nsIntSize</name>&amp;</type> <name>aSize</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>mLayer</name>-&gt;<name>CreateBuffer</name></name><argument_list>(<argument><expr><name>aType</name></expr></argument>, <argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<class>class <name>BasicImageLayer</name> <super>: <specifier>public</specifier> <name>ImageLayer</name>, <name>BasicImplData</name></super> <block>{<private type="default">
</private><public>public:
  <constructor><name>BasicImageLayer</name><parameter_list>(<param><decl><type><name>BasicLayerManager</name>*</type> <name>aLayerManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>ImageLayer</name><argument_list>(<argument><expr><name>aLayerManager</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicImplData</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicImageLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicImageLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicImageLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SetVisibleRegion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegion</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"Can only set properties in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ImageLayer</name>::<name>SetVisibleRegion</name></name><argument_list>(<argument><expr><name>aRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                     <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                     <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PaintContext</name><parameter_list>(<param><decl><type><name>gfxPattern</name>*</type> <name>aPattern</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>gfxIntSize</name>&amp;</type> <name>aSize</name></decl></param>,
                           <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>,
                           <param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>)</parameter_list>;</function_decl>

</public><protected>protected:
  <function><type><name>BasicLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <function_decl><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type>
  <name>GetAndPaintCurrentImage</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                          <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>gfxIntSize</name></type> <name>mSize</name></decl>;</decl_stmt>
</protected>}</block>;</class>

<function><type><name>void</name></type>
<name><name>BasicImageLayer</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                       <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                       <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                       <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>dontcare</name> <init>= <expr><call><name>GetAndPaintCurrentImage</name><argument_list>(<argument><expr><name>aContext</name></expr></argument>, <argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicImageLayer</name>::<name>GetAndPaintCurrentImage</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                                         <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mContainer</name></expr>)</condition><then>
    <return>return <expr><name>nsnull</name></expr>;</return></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>surface</name> <init>= <expr><call><name><name>mContainer</name>-&gt;<name>GetCurrentAsSurface</name></name><argument_list>(<argument><expr>&amp;<name>mSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>surface</name></expr>)</condition><then> <block>{
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>pat</name> <init>= <expr>new <call><name>gfxPattern</name><argument_list>(<argument><expr><name>surface</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>pat</name></expr>)</condition><then> <block>{
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>pat</name>-&gt;<name>SetFilter</name></name><argument_list>(<argument><expr><name>mFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PaintContext</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>mSize</name></expr></argument>, <argument><expr><name>aOpacity</name></expr></argument>, <argument><expr><name>aContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <return>return <expr><call><name><name>pat</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*static*/</comment> <function><type><name>void</name></type>
<name><name>BasicImageLayer</name>::<name>PaintContext</name></name><parameter_list>(<param><decl><type><name>gfxPattern</name>*</type> <name>aPattern</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>gfxIntSize</name>&amp;</type> <name>aSize</name></decl></param>,
                              <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>,
                              <param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Set PAD mode so that when the video is being scaled, we do not sample</comment>
  <comment type="line">// outside the bounds of the video image.</comment>
  <decl_stmt><decl><type><name><name>gfxPattern</name>::<name>GraphicsExtend</name></name></type> <name>extend</name> <init>= <expr><name><name>gfxPattern</name>::<name>EXTEND_PAD</name></name></expr></init></decl>;</decl_stmt>

  <comment type="line">// PAD is slow with X11 and Quartz surfaces, so prefer speed over correctness</comment>
  <comment type="line">// and use NONE.</comment>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>target</name> <init>= <expr><call><name><name>aContext</name>-&gt;<name>CurrentSurface</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>gfxASurface</name>::<name>gfxSurfaceType</name></name></type> <name>type</name> <init>= <expr><call><name><name>target</name>-&gt;<name>GetType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>type</name> == <name><name>gfxASurface</name>::<name>SurfaceTypeXlib</name></name> ||
      <name>type</name> == <name><name>gfxASurface</name>::<name>SurfaceTypeXcb</name></name> ||
      <name>type</name> == <name><name>gfxASurface</name>::<name>SurfaceTypeQuartz</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>extend</name> = <name><name>gfxPattern</name>::<name>EXTEND_NONE</name></name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>aPattern</name>-&gt;<name>SetExtend</name></name><argument_list>(<argument><expr><name>extend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Draw RGB surface onto frame */</comment>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>PixelSnappedRectangleAndSetPattern</name></name><argument_list>(
      <argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>aSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aOpacity</name> != 1.0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Save</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Clip</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Paint</name></name><argument_list>(<argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Restore</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<class>class <name>BasicColorLayer</name> <super>: <specifier>public</specifier> <name>ColorLayer</name>, <name>BasicImplData</name></super> <block>{<private type="default">
</private><public>public:
  <constructor><name>BasicColorLayer</name><parameter_list>(<param><decl><type><name>BasicLayerManager</name>*</type> <name>aLayerManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>ColorLayer</name><argument_list>(<argument><expr><name>aLayerManager</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicImplData</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicColorLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicColorLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicColorLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SetVisibleRegion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegion</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"Can only set properties in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ColorLayer</name>::<name>SetVisibleRegion</name></name><argument_list>(<argument><expr><name>aRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                     <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                     <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

</public><protected>protected:
  <function><type><name>BasicLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>
</protected>}</block>;</class>

<function><type><name>void</name></type>
<name><name>BasicColorLayer</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                       <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                       <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                       <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>SetColor</name></name><argument_list>(<argument><expr><name>mColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Paint</name></name><argument_list>(<argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<class>class <name>BasicCanvasLayer</name> <super>: <specifier>public</specifier> <name>CanvasLayer</name>,
                         <name>BasicImplData</name></super>
<block>{<private type="default">
</private><public>public:
  <constructor><name>BasicCanvasLayer</name><parameter_list>(<param><decl><type><name>BasicLayerManager</name>*</type> <name>aLayerManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>CanvasLayer</name><argument_list>(<argument><expr><name>aLayerManager</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicImplData</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicCanvasLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicCanvasLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicCanvasLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SetVisibleRegion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegion</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"Can only set properties in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>CanvasLayer</name>::<name>SetVisibleRegion</name></name><argument_list>(<argument><expr><name>aRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Initialize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Data</name>&amp;</type> <name>aData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Updated</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                     <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                     <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

</public><protected>protected:
  <function><type><name>BasicLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>mSurface</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name><name>mozilla</name>::<name>gl</name>::<name>GLContext</name></name></expr></argument>&gt;</argument_list></name></type> <name>mGLContext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRUint32</name></type> <name>mCanvasFramebuffer</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>mBounds</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>mUpdatedRect</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mGLBufferIsPremultiplied</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRPackedBool</name></type> <name>mNeedsYFlip</name></decl>;</decl_stmt>
</protected>}</block>;</class>

<function><type><name>void</name></type>
<name><name>BasicCanvasLayer</name>::<name>Initialize</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Data</name>&amp;</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mSurface</name> == <name>nsnull</name></expr></argument>, <argument><expr>"BasicCanvasLayer::Initialize called twice!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>mUpdatedRect</name>.<name>Empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>aData</name>.<name>mSurface</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>mSurface</name> = <name><name>aData</name>.<name>mSurface</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>aData</name>.<name>mGLContext</name></name> == <name>nsnull</name></expr></argument>,
                 <argument><expr>"CanvasLayer can't have both surface and GLContext"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mNeedsYFlip</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
  }</block></then> <else>else <if>if <condition>(<expr><name><name>aData</name>.<name>mGLContext</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aData</name>.<name>mGLContext</name>-&gt;<name>IsOffscreen</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"canvas gl context isn't offscreen"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mGLContext</name> = <name><name>aData</name>.<name>mGLContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mGLBufferIsPremultiplied</name> = <name><name>aData</name>.<name>mGLBufferIsPremultiplied</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mCanvasFramebuffer</name> = <call><name><name>mGLContext</name>-&gt;<name>GetOffscreenFBO</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mNeedsYFlip</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>NS_ERROR</name><argument_list>(<argument><expr>"CanvasLayer created without mSurface or mGLContext?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>

  <expr_stmt><expr><call><name><name>mBounds</name>.<name>SetRect</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>aData</name>.<name>mSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aData</name>.<name>mSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicCanvasLayer</name>::<name>Updated</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mUpdatedRect</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"CanvasLayer::Updated called more than once in a transaction!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>mUpdatedRect</name>.<name>UnionRect</name></name><argument_list>(<argument><expr><name>mUpdatedRect</name></expr></argument>, <argument><expr><name>aRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>mGLContext</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>isurf</name> <init>=
      <expr>new <call><name>gfxImageSurface</name><argument_list>(<argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name><name>mBounds</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mBounds</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr>(<call><name>GetContentFlags</name><argument_list>()</argument_list></call> &amp; <name>CONTENT_OPAQUE</name>)
                            ? <name><name>gfxASurface</name>::<name>ImageFormatRGB24</name></name>
                            : <name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>isurf</name> || <call><name><name>isurf</name>-&gt;<name>CairoStatus</name></name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
      <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>isurf</name>-&gt;<name>Stride</name></name><argument_list>()</argument_list></call> == <name><name>mBounds</name>.<name>width</name></name> * 4</expr></argument>, <argument><expr>"gfxImageSurface stride isn't what we expect!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We need to read from the GLContext</comment>
    <expr_stmt><expr><call><name><name>mGLContext</name>-&gt;<name>MakeCurrent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// We have to flush to ensure that any buffered GL operations are</comment>
    <comment type="line">// in the framebuffer before we read.</comment>
    <expr_stmt><expr><call><name><name>mGLContext</name>-&gt;<name>fFlush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>PRUint32</name></type> <name>currentFramebuffer</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name><name>mGLContext</name>-&gt;<name>fGetIntegerv</name></name><argument_list>(<argument><expr><name>LOCAL_GL_FRAMEBUFFER_BINDING</name></expr></argument>, <argument><expr>(<name>GLint</name>*)&amp;<name>currentFramebuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Make sure that we read pixels from the correct framebuffer, regardless</comment>
    <comment type="line">// of what's currently bound.</comment>
    <if>if <condition>(<expr><name>currentFramebuffer</name> != <name>mCanvasFramebuffer</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>mGLContext</name>-&gt;<name>fBindFramebuffer</name></name><argument_list>(<argument><expr><name>LOCAL_GL_FRAMEBUFFER</name></expr></argument>, <argument><expr><name>mCanvasFramebuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// For simplicity, we read the entire framebuffer for now -- in</comment>
    <comment type="line">// the future we should use mUpdatedRect, though with WebGL we don't</comment>
    <comment type="line">// have an easy way to generate one.</comment>
    <expr_stmt><expr><call><name><name>mGLContext</name>-&gt;<name>ReadPixelsIntoImageSurface</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                           <argument><expr><name><name>mBounds</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mBounds</name>.<name>height</name></name></expr></argument>,
                                           <argument><expr><name>isurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Put back the previous framebuffer binding.</comment>
    <if>if <condition>(<expr><name>currentFramebuffer</name> != <name>mCanvasFramebuffer</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>mGLContext</name>-&gt;<name>fBindFramebuffer</name></name><argument_list>(<argument><expr><name>LOCAL_GL_FRAMEBUFFER</name></expr></argument>, <argument><expr><name>currentFramebuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// If the underlying GLContext doesn't have a framebuffer into which</comment>
    <comment type="line">// premultiplied values were written, we have to do this ourselves here.</comment>
    <comment type="line">// Note that this is a WebGL attribute; GL itself has no knowledge of</comment>
    <comment type="line">// premultiplied or unpremultiplied alpha.</comment>
    <if>if <condition>(<expr>!<name>mGLBufferIsPremultiplied</name></expr>)</condition><then>
      <expr_stmt><expr><call><name><name>gfxUtils</name>::<name>PremultiplyImageSurface</name></name><argument_list>(<argument><expr><name>isurf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="line">// stick our surface into mSurface, so that the Paint() path is the same</comment>
    <expr_stmt><expr><name>mSurface</name> = <name>isurf</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="line">// sanity</comment>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>mUpdatedRect</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call> || <call><name><name>mBounds</name>.<name>Contains</name></name><argument_list>(<argument><expr><name>mUpdatedRect</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr>"CanvasLayer: Updated rect bigger than bounds!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicCanvasLayer</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                        <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                        <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                        <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InDrawing</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Can only draw in drawing phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>pat</name> <init>= <expr>new <call><name>gfxPattern</name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>pat</name>-&gt;<name>SetFilter</name></name><argument_list>(<argument><expr><name>mFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>pat</name>-&gt;<name>SetExtend</name></name><argument_list>(<argument><expr><name><name>gfxPattern</name>::<name>EXTEND_PAD</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>gfxRect</name></type> <name>r</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>mBounds</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mBounds</name>.<name>height</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>m</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>mNeedsYFlip</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>m</name> = <call><name><name>aContext</name>-&gt;<name>CurrentMatrix</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr><call><name>gfxPoint</name><argument_list>(<argument><expr>0.0</expr></argument>, <argument><expr><name><name>mBounds</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Scale</name></name><argument_list>(<argument><expr>1.0</expr></argument>, <argument><expr>-1.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>PixelSnappedRectangleAndSetPattern</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>aOpacity</name> != 1.0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Save</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Clip</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Paint</name></name><argument_list>(<argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Restore</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <if>if <condition>(<expr><name>mNeedsYFlip</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>SetMatrix</name></name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mUpdatedRect</name>.<name>Empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>nsIntRect</name></type>
<name>ToOutsideIntRect</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>gfxRect</name> &amp;</type><name>aRect</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>gfxRect</name></type> <name>r</name> <init>= <expr><name>aRect</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>r</name>.<name>RoundOut</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>nsIntRect</name><argument_list>(<argument><expr><name><name>r</name>.<name>pos</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>r</name>.<name>pos</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>r</name>.<name>size</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>r</name>.<name>size</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block" format="doxygen">/**
 * Returns false if there is at most one leaf layer overlapping aBounds
 * and that layer is opaque.
 * aDirtyVisibleRegionInContainer is filled in only if we return false.
 * It contains the union of the visible regions of leaf layers under aLayer.
 */</comment>
<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>MayHaveOverlappingOrTransparentLayers</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>aBounds</name></decl></param>,
                                      <param><decl><type><name>nsIntRegion</name>*</type> <name>aDirtyVisibleRegionInContainer</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!(<call><name><name>aLayer</name>-&gt;<name>GetContentFlags</name></name><argument_list>()</argument_list></call> &amp; <name><name>Layer</name>::<name>CONTENT_OPAQUE</name></name>)</expr>)</condition><then> <block>{
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>matrix</name></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<call><name><name>aLayer</name>-&gt;<name>GetTransform</name></name><argument_list>()</argument_list></call>.<call><name>Is2D</name><argument_list>(<argument><expr>&amp;<name>matrix</name></expr></argument>)</argument_list></call> ||
      <call><name><name>matrix</name>.<name>HasNonIntegerTranslation</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_TRUE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIntPoint</name></type> <name>translation</name> <init>= <expr><call><name>nsIntPoint</name><argument_list>(<argument><expr><call><name>PRInt32</name><argument_list>(<argument><expr><name><name>matrix</name>.<name>x0</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PRInt32</name><argument_list>(<argument><expr><name><name>matrix</name>.<name>y0</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>bounds</name> <init>= <expr><name>aBounds</name> - <name>translation</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>clippedDirtyRect</name> <init>= <expr><name>bounds</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>nsIntRect</name>*</type> <name>clipRect</name> <init>= <expr><call><name><name>aLayer</name>-&gt;<name>GetClipRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>clipRect</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>clippedDirtyRect</name>.<name>IntersectRect</name></name><argument_list>(<argument><expr><name>clippedDirtyRect</name></expr></argument>, <argument><expr>*<name>clipRect</name> - <name>translation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>aDirtyVisibleRegionInContainer</name>-&gt;<name>And</name></name><argument_list>(<argument><expr><call><name><name>aLayer</name>-&gt;<name>GetVisibleRegion</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>clippedDirtyRect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aDirtyVisibleRegionInContainer</name>-&gt;<name>MoveBy</name></name><argument_list>(<argument><expr><name>translation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Ignore layers outside the clip rect */</comment>
  <if>if <condition>(<expr><call><name><name>aDirtyVisibleRegionInContainer</name>-&gt;<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return <expr><name>PR_FALSE</name></expr>;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>nsIntRegion</name></type> <name>region</name></decl>;</decl_stmt>

  <for>for (<init><decl><type><name>Layer</name>*</type> <name>child</name> <init>= <expr><call><name><name>aLayer</name>-&gt;<name>GetFirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>child</name></expr>;</condition>
       <incr><expr><name>child</name> = <call><name><name>child</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <decl_stmt><decl><type><name>nsIntRegion</name></type> <name>childRegion</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>MayHaveOverlappingOrTransparentLayers</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>bounds</name></expr></argument>, <argument><expr>&amp;<name>childRegion</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>

    <decl_stmt><decl><type><name>nsIntRegion</name></type> <name>tmp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>tmp</name>.<name>And</name></name><argument_list>(<argument><expr><name>region</name></expr></argument>, <argument><expr><name>childRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name><name>tmp</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <return>return <expr><name>PR_TRUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>region</name>.<name>Or</name></name><argument_list>(<argument><expr><name>region</name></expr></argument>, <argument><expr><name>childRegion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <return>return <expr><name>PR_FALSE</name></expr>;</return>
}</block></function>

<constructor><name><name>BasicLayerManager</name>::<name>BasicLayerManager</name></name><parameter_list>(<param><decl><type><name>nsIWidget</name>*</type> <name>aWidget</name></decl></param>)</parameter_list> <member_list>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <call><name>mPhase</name><argument_list>(<argument><expr><name>PHASE_NONE</name></expr></argument>)</argument_list></call>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <call><name>mWidget</name><argument_list>(<argument><expr><name>aWidget</name></expr></argument>)</argument_list></call>
  , <call><name>mDoubleBuffering</name><argument_list>(<argument><expr><name>BUFFER_NONE</name></expr></argument>)</argument_list></call>, <call><name>mUsingDefaultTarget</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicLayerManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aWidget</name></expr></argument>, <argument><expr>"Must provide a widget"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<constructor><name><name>BasicLayerManager</name>::<name>BasicLayerManager</name></name><parameter_list>()</parameter_list> <member_list>:
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <call><name>mPhase</name><argument_list>(<argument><expr><name>PHASE_NONE</name></expr></argument>)</argument_list></call>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <call><name>mWidget</name><argument_list>(<argument><expr><name>nsnull</name></expr></argument>)</argument_list></call>
  , <call><name>mDoubleBuffering</name><argument_list>(<argument><expr><name>BUFFER_NONE</name></expr></argument>)</argument_list></call>, <call><name>mUsingDefaultTarget</name><argument_list>(<argument><expr><name>PR_FALSE</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicLayerManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>BasicLayerManager</name>::~<name>BasicLayerManager</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>InTransaction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Died during transaction?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ClearCachedResources</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mRoot</name> = <name>nsnull</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicLayerManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>void</name></type>
<name><name>BasicLayerManager</name>::<name>SetDefaultTarget</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                                    <param><decl><type><name>BufferMode</name></type> <name>aDoubleBuffering</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>InTransaction</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Must set default target outside transaction"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mDefaultTarget</name> = <name>aContext</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mDoubleBuffering</name> = <name>aDoubleBuffering</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicLayerManager</name>::<name>BeginTransaction</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>mUsingDefaultTarget</name> = <name>PR_TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BeginTransactionWithTarget</name><argument_list>(<argument><expr><name>mDefaultTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxContext</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicLayerManager</name>::<name>PushGroupWithCachedSurface</name></name><parameter_list>(<param><decl><type><name>gfxContext</name> *</type><name>aTarget</name></decl></param>,
                                              <param><decl><type><name><name>gfxASurface</name>::<name>gfxContentType</name></name></type> <name>aContent</name></decl></param>,
                                              <param><decl><type><name>gfxPoint</name> *</type><name>aSavedOffset</name></decl></param>)</parameter_list>
<block>{
  <function_decl><type><name>gfxContextMatrixAutoSaveRestore</name></type> <name>saveMatrix</name><parameter_list>(<param><decl><type><name>aTarget</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>aTarget</name>-&gt;<name>IdentityMatrix</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>currentSurf</name> <init>= <expr><call><name><name>aTarget</name>-&gt;<name>CurrentSurface</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>gfxRect</name></type> <name>clip</name> <init>= <expr><call><name><name>aTarget</name>-&gt;<name>GetClipExtents</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>clip</name>.<name>RoundOut</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxContext</name></expr></argument>&gt;</argument_list></name></type> <name>ctx</name> <init>=
    <expr><call><name><name>mCachedSurface</name>.<name>Get</name></name><argument_list>(<argument><expr><name>aContent</name></expr></argument>,
                       <argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name><name>clip</name>.<name>size</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>clip</name>.<name>size</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>currentSurf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>InheritContextFlags</name><argument_list>(<argument><expr><name>aTarget</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Align our buffer for the original surface */</comment>
  <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>Translate</name></name><argument_list>(<argument><expr>-<name><name>clip</name>.<name>pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>aSavedOffset</name> = <name><name>clip</name>.<name>pos</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>Multiply</name></name><argument_list>(<argument><expr><call><name><name>saveMatrix</name>.<name>Matrix</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>ctx</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicLayerManager</name>::<name>PopGroupWithCachedSurface</name></name><parameter_list>(<param><decl><type><name>gfxContext</name> *</type><name>aTarget</name></decl></param>,
                                             <param><decl><type><specifier>const</specifier> <name>gfxPoint</name>&amp;</type> <name>aSavedOffset</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<name>mTarget</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <function_decl><type><name>gfxContextMatrixAutoSaveRestore</name></type> <name>saveMatrix</name><parameter_list>(<param><decl><type><name>aTarget</name></type></decl></param>)</parameter_list>;</function_decl>
  <expr_stmt><expr><call><name><name>aTarget</name>-&gt;<name>IdentityMatrix</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>aTarget</name>-&gt;<name>SetSource</name></name><argument_list>(<argument><expr><call><name><name>mTarget</name>-&gt;<name>OriginalSurface</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>aSavedOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aTarget</name>-&gt;<name>Paint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicLayerManager</name>::<name>BeginTransactionWithTarget</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aTarget</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_LAYERS_HAVE_LOG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>MOZ_LAYERS_LOG</name><argument_list>(<argument><expr>("[----- BeginTransaction")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Log</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr>!<call><name>InTransaction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Nested transactions not allowed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>mPhase</name> = <name>PHASE_CONSTRUCTION</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>mTarget</name> = <name>aTarget</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicLayerManager</name>::<name>EndTransaction</name></name><parameter_list>(<param><decl><type><name>DrawThebesLayerCallback</name></type> <name>aCallback</name></decl></param>,
                                  <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_LAYERS_HAVE_LOG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>MOZ_LAYERS_LOG</name><argument_list>(<argument><expr>("  ----- (beginning paint)")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Log</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Should be in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>mPhase</name> = <name>PHASE_DRAWING</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><name>mTarget</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mRoot</name></expr></argument>, <argument><expr>"Root not set"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxContext</name></expr></argument>&gt;</argument_list></name></type> <name>finalTarget</name> <init>= <expr><name>mTarget</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gfxPoint</name></type> <name>cachedSurfaceOffset</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>nsIntRegion</name></type> <name>rootRegion</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PRBool</name></type> <name>useDoubleBuffering</name> <init>= <expr><name>mUsingDefaultTarget</name> &amp;&amp;
      <name>mDoubleBuffering</name> != <name>BUFFER_NONE</name> &amp;&amp;
      <call><name>MayHaveOverlappingOrTransparentLayers</name><argument_list>(<argument><expr><name>mRoot</name></expr></argument>,
                                            <argument><expr><call><name>ToOutsideIntRect</name><argument_list>(<argument><expr><call><name><name>mTarget</name>-&gt;<name>GetClipExtents</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr>&amp;<name>rootRegion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>useDoubleBuffering</name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>targetSurface</name> <init>= <expr><call><name><name>mTarget</name>-&gt;<name>CurrentSurface</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>mTarget</name> = <call><name>PushGroupWithCachedSurface</name><argument_list>(<argument><expr><name>mTarget</name></expr></argument>, <argument><expr><call><name><name>targetSurface</name>-&gt;<name>GetContentType</name></name><argument_list>()</argument_list></call></expr></argument>,
                                           <argument><expr>&amp;<name>cachedSurfaceOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>PaintLayer</name><argument_list>(<argument><expr><name>mRoot</name></expr></argument>, <argument><expr><name>aCallback</name></expr></argument>, <argument><expr><name>aCallbackData</name></expr></argument>, <argument><expr><call><name><name>mRoot</name>-&gt;<name>GetOpacity</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name>useDoubleBuffering</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>finalTarget</name>-&gt;<name>SetOperator</name></name><argument_list>(<argument><expr><name><name>gfxContext</name>::<name>OPERATOR_SOURCE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PopGroupWithCachedSurface</name><argument_list>(<argument><expr><name>finalTarget</name></expr></argument>, <argument><expr><name>cachedSurfaceOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>mTarget</name> = <name>nsnull</name></expr>;</expr_stmt>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_LAYERS_HAVE_LOG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>Log</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MOZ_LAYERS_LOG</name><argument_list>(<argument><expr>("]----- EndTransaction")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>mPhase</name> = <name>PHASE_NONE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>mUsingDefaultTarget</name> = <name>PR_FALSE</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicLayerManager</name>::<name>SetRoot</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>, <argument><expr>"Root can't be null"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aLayer</name>-&gt;<name>Manager</name></name><argument_list>()</argument_list></call> == <name>this</name></expr></argument>, <argument><expr>"Wrong manager"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mRoot</name> = <name>aLayer</name></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Returns true if we need to save the state of the gfxContext when</comment>
<comment type="line">// we start painting aLayer (and restore the state when we've finished</comment>
<comment type="line">// painting aLayer)</comment>
<function><type><specifier>static</specifier> <name>PRBool</name></type>
<name>NeedsState</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>aLayer</name>-&gt;<name>GetClipRect</name></name><argument_list>()</argument_list></call> != <name>nsnull</name> ||
         !<call><name><name>aLayer</name>-&gt;<name>GetTransform</name></name><argument_list>()</argument_list></call>.<call><name>IsIdentity</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>GetChildCount</name><parameter_list>(<param><decl><type><name>Layer</name> *</type><name>aLayer</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>Layer</name>*</type> <name>child</name> <init>= <expr><call><name><name>aLayer</name>-&gt;<name>GetFirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>child</name></expr>;</condition>
       <incr><expr><name>child</name> = <call><name><name>child</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>count</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicLayerManager</name>::<name>PaintLayer</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>,
                              <param><decl><type><name>DrawThebesLayerCallback</name></type> <name>aCallback</name></decl></param>,
                              <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                              <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>PRBool</name></type> <name>needsGroup</name> <init>= <expr><name>aOpacity</name> != 1.0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>needsSaveRestore</name> <init>= <expr><name>needsGroup</name> || <call><name>NeedsState</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>children</name> <init>= <expr><call><name>GetChildCount</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

 <if>if <condition>(<expr><name>needsSaveRestore</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>mTarget</name>-&gt;<name>Save</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name><name>aLayer</name>-&gt;<name>GetClipRect</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>r</name> <init>= <expr>*<call><name><name>aLayer</name>-&gt;<name>GetClipRect</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>mTarget</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>mTarget</name>-&gt;<name>Rectangle</name></name><argument_list>(<argument><expr><call><name>gfxRect</name><argument_list>(<argument><expr><name><name>r</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>r</name>.<name>y</name></name></expr></argument>, <argument><expr><name><name>r</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>r</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PR_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>mTarget</name>-&gt;<name>Clip</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <decl_stmt><decl><type><name>gfxMatrix</name></type> <name>transform</name></decl>;</decl_stmt>
    <comment type="line">// XXX we need to add some kind of 3D transform support, possibly</comment>
    <comment type="line">// using pixman?</comment>
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name><name>aLayer</name>-&gt;<name>GetTransform</name></name><argument_list>()</argument_list></call>.<call><name>Is2D</name><argument_list>()</argument_list></call></expr></argument>,
                 <argument><expr>"Only 2D transforms supported currently"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>aLayer</name>-&gt;<name>GetTransform</name></name><argument_list>()</argument_list></call>.<call><name>Is2D</name><argument_list>(<argument><expr>&amp;<name>transform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>mTarget</name>-&gt;<name>Multiply</name></name><argument_list>(<argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>needsGroup</name> &amp;&amp; <name>children</name> &gt; 1</expr>)</condition><then> <block>{
      <comment type="line">// If we need to call PushGroup, we should clip to the smallest possible</comment>
      <comment type="line">// area first to minimize the size of the temporary surface.</comment>
      <expr_stmt><expr><call><name>ClipToContain</name><argument_list>(<argument><expr><name>mTarget</name></expr></argument>, <argument><expr><call><name><name>aLayer</name>-&gt;<name>GetVisibleRegion</name></name><argument_list>()</argument_list></call>.<call><name>GetBounds</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <decl_stmt><decl><type><name><name>gfxASurface</name>::<name>gfxContentType</name></name></type> <name>type</name> <init>= <expr><call><name><name>aLayer</name>-&gt;<name>CanUseOpaqueSurface</name></name><argument_list>()</argument_list></call>
          ? <name><name>gfxASurface</name>::<name>CONTENT_COLOR</name></name> : <name><name>gfxASurface</name>::<name>CONTENT_COLOR_ALPHA</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name><name>mTarget</name>-&gt;<name>PushGroup</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="block">/* Only paint ourself, or our children - This optimization relies on this! */</comment>
  <if>if <condition>(<expr>!<name>children</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ToData</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call>-&gt;<call><name>Paint</name><argument_list>(<argument><expr><name>mTarget</name></expr></argument>, <argument><expr><name>aCallback</name></expr></argument>, <argument><expr><name>aCallbackData</name></expr></argument>, <argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <for>for (<init><decl><type><name>Layer</name>*</type> <name>child</name> <init>= <expr><call><name><name>aLayer</name>-&gt;<name>GetFirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>child</name></expr>;</condition>
         <incr><expr><name>child</name> = <call><name><name>child</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
      <comment type="block">/* If we have a single child, we can pass the aOpacity down, otherwise we will have double buffered */</comment>
      <if>if <condition>(<expr><name>needsGroup</name> &amp;&amp; <name>children</name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PaintLayer</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>aCallback</name></expr></argument>, <argument><expr><name>aCallbackData</name></expr></argument>, <argument><expr><call><name><name>child</name>-&gt;<name>GetOpacity</name></name><argument_list>()</argument_list></call> * <name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>PaintLayer</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>aCallback</name></expr></argument>, <argument><expr><name>aCallbackData</name></expr></argument>, <argument><expr><call><name><name>child</name>-&gt;<name>GetOpacity</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
  }</block></else></if>

  <if>if <condition>(<expr><name>needsSaveRestore</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>needsGroup</name> &amp;&amp; <name>children</name> &gt; 1</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>mTarget</name>-&gt;<name>PopGroupToSource</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>mTarget</name>-&gt;<name>Paint</name></name><argument_list>(<argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name><name>mTarget</name>-&gt;<name>Restore</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicLayerManager</name>::<name>ClearCachedResources</name></name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mRoot</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ClearLayer</name><argument_list>(<argument><expr><name>mRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name><name>mCachedSurface</name>.<name>Expire</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type>
<name><name>BasicLayerManager</name>::<name>ClearLayer</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>ToData</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call>-&gt;<call><name>ClearCachedResources</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><decl><type><name>Layer</name>*</type> <name>child</name> <init>= <expr><call><name><name>aLayer</name>-&gt;<name>GetFirstChild</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>child</name></expr>;</condition>
       <incr><expr><name>child</name> = <call><name><name>child</name>-&gt;<name>GetNextSibling</name></name><argument_list>()</argument_list></call></expr></incr>) <block>{
    <expr_stmt><expr><call><name>ClearLayer</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ThebesLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicLayerManager</name>::<name>CreateThebesLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>ThebesLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>= <expr>new <call><name>BasicThebesLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ContainerLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicLayerManager</name>::<name>CreateContainerLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>ContainerLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>= <expr>new <call><name>BasicContainerLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ImageLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicLayerManager</name>::<name>CreateImageLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>ImageLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>= <expr>new <call><name>BasicImageLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ColorLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicLayerManager</name>::<name>CreateColorLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>ColorLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>= <expr>new <call><name>BasicColorLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>CanvasLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicLayerManager</name>::<name>CreateCanvasLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>CanvasLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>= <expr>new <call><name>BasicCanvasLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOZ_IPC</name></cpp:ifdef>

<class>class <name>BasicShadowableLayer</name> <super>: <specifier>public</specifier> <name>ShadowableLayer</name></super>
<block>{<private type="default">
</private><public>public:
  <constructor><name>BasicShadowableLayer</name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicShadowableLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>

  <destructor><name>~<name>BasicShadowableLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <if>if <condition>(<expr><call><name>HasShadow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>PLayerChild</name>::<name>Send__delete__</name></name><argument_list>(<argument><expr><call><name>GetShadow</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicShadowableLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function><type><name>void</name></type> <name>SetShadow</name><parameter_list>(<param><decl><type><name>PLayerChild</name>*</type> <name>aShadow</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr>!<name>mShadow</name></expr></argument>, <argument><expr>"can't have two shadows (yet)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mShadow</name> = <name>aShadow</name></expr>;</expr_stmt>
  }</block></function>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SetBackBuffer</name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>aBuffer</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_RUNTIMEABORT</name><argument_list>(<argument><expr>"if this default impl is called, |aBuffer| leaks"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>
</public>}</block>;</class>

<function><type><specifier>static</specifier> <name>ShadowableLayer</name>*</type>
<name>ToShadowable</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>ToData</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call>-&gt;<call><name>AsShadowableLayer</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<template>template<parameter_list>&lt;<param><type><name>class</name></type> <name>OpT</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>BasicShadowableLayer</name>*</type>
<name>GetBasicShadowable</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>OpT</name>&amp;</type> <name>op</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicShadowableLayer</name>*</expr></argument>&gt;</argument_list></name><argument_list>(
    <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><specifier>const</specifier> <name>ShadowLayerChild</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>op</name>.<name>layerChild</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>-&gt;<call><name>layer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function></template>

<class>class <name>BasicShadowableContainerLayer</name> <super>: <specifier>public</specifier> <name>BasicContainerLayer</name>,
                                      <specifier>public</specifier> <name>BasicShadowableLayer</name></super> <block>{<private type="default">
</private><public>public:
  <constructor><name>BasicShadowableContainerLayer</name><parameter_list>(<param><decl><type><name>BasicShadowLayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>BasicContainerLayer</name><argument_list>(<argument><expr><name>aManager</name></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicShadowableContainerLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicShadowableContainerLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicShadowableContainerLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>InsertAfter</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aChild</name></decl></param>, <param><decl><type><name>Layer</name>*</type> <name>aAfter</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>RemoveChild</name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aChild</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><specifier>virtual</specifier> <name>Layer</name>*</type> <name>AsLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></function>
  <function><type><specifier>virtual</specifier> <name>ShadowableLayer</name>*</type> <name>AsShadowableLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></function>

</public><private>private:
  <function><type><name>BasicShadowLayerManager</name>*</type> <name>ShadowManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicShadowLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>
</private>}</block>;</class>

<function><type><name>void</name></type>
<name><name>BasicShadowableContainerLayer</name>::<name>InsertAfter</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aChild</name></decl></param>, <param><decl><type><name>Layer</name>*</type> <name>aAfter</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>HasShadow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ShadowManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InsertAfter</name><argument_list>(<argument><expr><call><name>ShadowManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>ShadowManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>aAfter</name> ? <call><name>ShadowManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>aAfter</name></expr></argument>)</argument_list></call> : <name>nsnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>BasicContainerLayer</name>::<name>InsertAfter</name></name><argument_list>(<argument><expr><name>aChild</name></expr></argument>, <argument><expr><name>aAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicShadowableContainerLayer</name>::<name>RemoveChild</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aChild</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>HasShadow</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>ShadowManager</name><argument_list>()</argument_list></call>-&gt;<call><name>RemoveChild</name><argument_list>(<argument><expr><call><name>ShadowManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>ShadowManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>BasicContainerLayer</name>::<name>RemoveChild</name></name><argument_list>(<argument><expr><name>aChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<class>class <name>BasicShadowableThebesLayer</name> <super>: <specifier>public</specifier> <name>BasicThebesLayer</name>,
                                   <specifier>public</specifier> <name>BasicShadowableLayer</name></super>
<block>{<private type="default">
  <typedef>typedef <type><name>BasicThebesLayer</name></type> <name>Base</name>;</typedef>

</private><public>public:
  <constructor><name>BasicShadowableThebesLayer</name><parameter_list>(<param><decl><type><name>BasicShadowLayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>BasicThebesLayer</name><argument_list>(<argument><expr><name>aManager</name></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicShadowableThebesLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicShadowableThebesLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <if>if <condition>(<expr><name>mBackBuffer</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name><name>ShadowLayerForwarder</name>::<name>DestroySharedSurface</name></name><argument_list>(<argument><expr><name>mBackBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicShadowableThebesLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>FillSpecificAttributes</name><parameter_list>(<param><decl><type><name>SpecificLayerAttributes</name>&amp;</type> <name>aAttrs</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><name>aAttrs</name> = <call><name>ThebesLayerAttributes</name><argument_list>(<argument><expr><call><name>GetValidRegion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function><type><specifier>virtual</specifier> <name>Layer</name>*</type> <name>AsLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></function>
  <function><type><specifier>virtual</specifier> <name>ShadowableLayer</name>*</type> <name>AsShadowableLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></function>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SetBackBuffer</name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>aBuffer</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><name>mBackBuffer</name> = <name>aBuffer</name></expr>;</expr_stmt>
  }</block></function>

</public><private>private:
  <function><type><name>BasicShadowLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicShadowLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <function_decl><type><name>NS_OVERRIDE</name> <specifier>virtual</specifier> <name>void</name></type>
  <name>PaintBuffer</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegionToDraw</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegionToInvalidate</name></decl></param>,
              <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
              <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>NS_OVERRIDE</name> <specifier>virtual</specifier> <name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
  <name>CreateBuffer</name><parameter_list>(<param><decl><type><name><name>Buffer</name>::<name>ContentType</name></name></type> <name>aType</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsIntSize</name>&amp;</type> <name>aSize</name></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>mBackBuffer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIntSize</name></type> <name>mBufferSize</name></decl>;</decl_stmt>
</private>}</block>;</class>
 
<function><type><name>void</name></type>
<name><name>BasicShadowableThebesLayer</name>::<name>PaintBuffer</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegionToDraw</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>nsIntRegion</name>&amp;</type> <name>aRegionToInvalidate</name></decl></param>,
                                        <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                                        <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr>!!<name>mBackBuffer</name></expr></argument>, <argument><expr>"should have a back buffer by now"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>Base</name>::<name>PaintBuffer</name></name><argument_list>(<argument><expr><name>aContext</name></expr></argument>, <argument><expr><name>aRegionToDraw</name></expr></argument>, <argument><expr><name>aRegionToInvalidate</name></expr></argument>,
                    <argument><expr><name>aCallback</name></expr></argument>, <argument><expr><name>aCallbackData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxContext</name></expr></argument>&gt;</argument_list></name></type> <name>tmpCtx</name> <init>= <expr>new <call><name>gfxContext</name><argument_list>(<argument><expr><name>mBackBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>tmpCtx</name>-&gt;<name>DrawSurface</name></name><argument_list>(<argument><expr><call><name><name>aContext</name>-&gt;<name>OriginalSurface</name></name><argument_list>()</argument_list></call></expr></argument>,
                      <argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name><name>mBufferSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mBufferSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>PaintedThebesBuffer</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name><name>mBuffer</name>.<name>BufferRect</name></name><argument_list>()</argument_list></call></expr></argument>,
                                      <argument><expr><call><name><name>mBuffer</name>.<name>BufferRotation</name></name><argument_list>()</argument_list></call></expr></argument>,
                                      <argument><expr><name>mBackBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowableThebesLayer</name>::<name>CreateBuffer</name></name><parameter_list>(<param><decl><type><name><name>Buffer</name>::<name>ContentType</name></name></type> <name>aType</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>nsIntSize</name>&amp;</type> <name>aSize</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>tmpFront</name></decl>;</decl_stmt>
  <comment type="line">// XXX error handling</comment>
  <if>if <condition>(<expr>!<call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>AllocDoubleBuffer</name><argument_list>(<argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name><name>aSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name></expr></argument>,
                                         <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>tmpFront</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mBackBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>NS_RUNTIMEABORT</name><argument_list>(<argument><expr>"creating ThebesLayer 'back buffer' failed!"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>mBufferSize</name> = <name>aSize</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>CreatedThebesBuffer</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <comment type="line">// only |aSize| really matters</comment>
                                      <comment type="line">// here, since Painted() soon</comment>
                                      <comment type="line">// follows</comment>
                                      <argument><expr><call><name>nsIntRect</name><argument_list>(<argument><expr><call><name>nsIntPoint</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>tmpFront</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name><name>Base</name>::<name>CreateBuffer</name></name><argument_list>(<argument><expr><name>aType</name></expr></argument>, <argument><expr><name>aSize</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<class>class <name>BasicShadowableImageLayer</name> <super>: <specifier>public</specifier> <name>BasicImageLayer</name>,
                                  <specifier>public</specifier> <name>BasicShadowableLayer</name></super>
<block>{<private type="default">
</private><public>public:
  <constructor><name>BasicShadowableImageLayer</name><parameter_list>(<param><decl><type><name>BasicShadowLayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>BasicImageLayer</name><argument_list>(<argument><expr><name>aManager</name></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicShadowableImageLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicShadowableImageLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <if>if <condition>(<expr><name>mBackSurface</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name><name>ShadowLayerForwarder</name>::<name>DestroySharedSurface</name></name><argument_list>(<argument><expr><name>mBackSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicShadowableImageLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                     <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                     <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>FillSpecificAttributes</name><parameter_list>(<param><decl><type><name>SpecificLayerAttributes</name>&amp;</type> <name>aAttrs</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><name>aAttrs</name> = <call><name>ImageLayerAttributes</name><argument_list>(<argument><expr><name>mFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function><type><specifier>virtual</specifier> <name>Layer</name>*</type> <name>AsLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></function>
  <function><type><specifier>virtual</specifier> <name>ShadowableLayer</name>*</type> <name>AsShadowableLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></function>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SetBackBuffer</name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>aBuffer</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><name>mBackSurface</name> = <name>aBuffer</name></expr>;</expr_stmt>
  }</block></function>

</public><private>private:
  <function><type><name>BasicShadowLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicShadowLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>mBackSurface</name></decl>;</decl_stmt>
</private>}</block>;</class>
 
<function><type><name>void</name></type>
<name><name>BasicShadowableImageLayer</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                                 <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                                 <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                                 <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>gfxIntSize</name></type> <name>oldSize</name> <init>= <expr><name>mSize</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>pat</name> <init>= <expr><call><name>GetAndPaintCurrentImage</name><argument_list>(<argument><expr><name>aContext</name></expr></argument>, <argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>!<name>pat</name> || !<call><name>HasShadow</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>

  <if>if <condition>(<expr><name>oldSize</name> != <name>mSize</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>oldSize</name> == <call><name>gfxIntSize</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"video changed size?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>tmpFrontSurface</name></decl>;</decl_stmt>
    <comment type="line">// XXX error handling?</comment>
    <if>if <condition>(<expr>!<call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>AllocDoubleBuffer</name><argument_list>(
          <argument><expr><name>mSize</name></expr></argument>, <argument><expr><name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name></expr></argument>,
          <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>tmpFrontSurface</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mBackSurface</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
      <expr_stmt><expr><call><name>NS_RUNTIMEABORT</name><argument_list>(<argument><expr>"creating ImageLayer 'front buffer' failed!"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>CreatedImageBuffer</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>nsIntSize</name><argument_list>(<argument><expr><name><name>mSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>tmpFrontSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxContext</name></expr></argument>&gt;</argument_list></name></type> <name>tmpCtx</name> <init>= <expr>new <call><name>gfxContext</name><argument_list>(<argument><expr><name>mBackSurface</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PaintContext</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>mSize</name></expr></argument>, <argument><expr>1.0</expr></argument>, <argument><expr><name>tmpCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>PaintedImage</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>mBackSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<class>class <name>BasicShadowableColorLayer</name> <super>: <specifier>public</specifier> <name>BasicColorLayer</name>,
                                  <specifier>public</specifier> <name>BasicShadowableLayer</name></super>
<block>{<private type="default">
</private><public>public:
  <constructor><name>BasicShadowableColorLayer</name><parameter_list>(<param><decl><type><name>BasicShadowLayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>BasicColorLayer</name><argument_list>(<argument><expr><name>aManager</name></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicShadowableColorLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicShadowableColorLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicShadowableColorLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>FillSpecificAttributes</name><parameter_list>(<param><decl><type><name>SpecificLayerAttributes</name>&amp;</type> <name>aAttrs</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><name>aAttrs</name> = <call><name>ColorLayerAttributes</name><argument_list>(<argument><expr><call><name>GetColor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function><type><specifier>virtual</specifier> <name>Layer</name>*</type> <name>AsLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></function>
  <function><type><specifier>virtual</specifier> <name>ShadowableLayer</name>*</type> <name>AsShadowableLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></function>
</public>}</block>;</class>

<class>class <name>BasicShadowableCanvasLayer</name> <super>: <specifier>public</specifier> <name>BasicCanvasLayer</name>,
                                   <specifier>public</specifier> <name>BasicShadowableLayer</name></super>
<block>{<private type="default">
</private><public>public:
  <constructor><name>BasicShadowableCanvasLayer</name><parameter_list>(<param><decl><type><name>BasicShadowLayerManager</name>*</type> <name>aManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>BasicCanvasLayer</name><argument_list>(<argument><expr><name>aManager</name></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicShadowableCanvasLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicShadowableCanvasLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <if>if <condition>(<expr><name>mBackBuffer</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name><name>ShadowLayerForwarder</name>::<name>DestroySharedSurface</name></name><argument_list>(<argument><expr><name>mBackBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicShadowableCanvasLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Initialize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Data</name>&amp;</type> <name>aData</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                     <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                     <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>FillSpecificAttributes</name><parameter_list>(<param><decl><type><name>SpecificLayerAttributes</name>&amp;</type> <name>aAttrs</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><name>aAttrs</name> = <call><name>CanvasLayerAttributes</name><argument_list>(<argument><expr><name>mFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></function>

  <function><type><specifier>virtual</specifier> <name>Layer</name>*</type> <name>AsLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></function>
  <function><type><specifier>virtual</specifier> <name>ShadowableLayer</name>*</type> <name>AsShadowableLayer</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></function>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>SetBackBuffer</name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>aBuffer</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><name>mBackBuffer</name> = <name>aBuffer</name></expr>;</expr_stmt>
  }</block></function>

</public><private>private:
  <function><type><name>BasicShadowLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicShadowLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>mBackBuffer</name></decl>;</decl_stmt>
</private>}</block>;</class>

<function><type><name>void</name></type>
<name><name>BasicShadowableCanvasLayer</name>::<name>Initialize</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Data</name>&amp;</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>BasicCanvasLayer</name>::<name>Initialize</name></name><argument_list>(<argument><expr><name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name>HasShadow</name><argument_list>()</argument_list></call></expr>)</condition><then>
      <return>return;</return></then></if>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>tmpFrontBuffer</name></decl>;</decl_stmt>
  <comment type="line">// XXX error handling?</comment>
  <if>if <condition>(<expr>!<call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>AllocDoubleBuffer</name><argument_list>(
        <argument><expr><call><name>gfxIntSize</name><argument_list>(<argument><expr><name><name>aData</name>.<name>mSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aData</name>.<name>mSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name><name>gfxASurface</name>::<name>ImageFormatARGB32</name></name></expr></argument>,
        <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>tmpFrontBuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getter_AddRefs</name><argument_list>(<argument><expr><name>mBackBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>NS_RUNTIMEABORT</name><argument_list>(<argument><expr>"creating CanvasLayer back buffer failed!"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>CreatedCanvasBuffer</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name><name>aData</name>.<name>mSize</name></name></expr></argument>,
                                      <argument><expr><name>tmpFrontBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicShadowableCanvasLayer</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                                  <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                                  <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                                  <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>BasicCanvasLayer</name>::<name>Paint</name></name><argument_list>(<argument><expr><name>aContext</name></expr></argument>, <argument><expr><name>aCallback</name></expr></argument>, <argument><expr><name>aCallbackData</name></expr></argument>, <argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name>HasShadow</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="line">// XXX this is yucky and slow.  It'd be nice to draw directly into</comment>
  <comment type="line">// the shmem back buffer</comment>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxContext</name></expr></argument>&gt;</argument_list></name></type> <name>tmpCtx</name> <init>= <expr>new <call><name>gfxContext</name><argument_list>(<argument><expr><name>mBackBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>tmpCtx</name>-&gt;<name>DrawSurface</name></name><argument_list>(<argument><expr><name>mSurface</name></expr></argument>, <argument><expr><call><name>gfxSize</name><argument_list>(<argument><expr><name><name>mBounds</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mBounds</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>PaintedCanvas</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>Hold</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>mBackBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<class>class <name>ShadowThebesLayerBuffer</name> <super>: <specifier>public</specifier> <name>BasicThebesLayerBuffer</name></super>
<block>{<private type="default">
  <typedef>typedef <type><name>BasicThebesLayerBuffer</name></type> <name>Base</name>;</typedef>

</private><public>public:
  <constructor><name>ShadowThebesLayerBuffer</name><parameter_list>()</parameter_list>
    <member_list>: <call><name>Base</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>ShadowThebesLayerBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>

  <destructor><name>~<name>ShadowThebesLayerBuffer</name></name><parameter_list>()</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>ShadowThebesLayerBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type>
  <name>Swap</name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>aNewFrontBuffer</name></decl></param>,
       <param><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>aBufferRect</name></decl></param>,
       <param><decl><type><specifier>const</specifier> <name>nsIntPoint</name>&amp;</type> <name>aRotation</name><init>=<expr><call><name>nsIntPoint</name><argument_list>(<argument><expr>0</expr></argument>, 0)</argument_list></call></expr></init></decl></param>)</parameter_list>
  <block>{
    <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>newBackBuffer</name> <init>= <expr><call><name>SetBuffer</name><argument_list>(<argument><expr><name>aNewFrontBuffer</name></expr></argument>,
                                                    <argument><expr><name>aBufferRect</name></expr></argument>, <argument><expr><name>aRotation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>newBackBuffer</name>.<name>forget</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

</public><protected>protected:
  <function><type><specifier>virtual</specifier> <name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type>
  <name>CreateBuffer</name><parameter_list>(<param><decl><type><name>ContentType</name></type> <name>aType</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsIntSize</name>&amp;</type> <name>aSize</name></decl></param>)</parameter_list>
  <block>{
    <expr_stmt><expr><call><name>NS_RUNTIMEABORT</name><argument_list>(<argument><expr>"ShadowThebesLayer can't paint content"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>nsnull</name></expr>;</return>
  }</block></function>
</protected>}</block>;</class>

<class>class <name>BasicShadowThebesLayer</name> <super>: <specifier>public</specifier> <name>ShadowThebesLayer</name>, <name>BasicImplData</name></super> <block>{<private type="default">
</private><public>public:
  <constructor><name>BasicShadowThebesLayer</name><parameter_list>(<param><decl><type><name>BasicShadowLayerManager</name>*</type> <name>aLayerManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>ShadowThebesLayer</name><argument_list>(<argument><expr><name>aLayerManager</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicImplData</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicShadowThebesLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor_decl><specifier>virtual</specifier> <name>~<name>BasicShadowThebesLayer</name></name><parameter_list>()</parameter_list>;</destructor_decl>

  <function><type><specifier>virtual</specifier> <name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type>
  <name>Swap</name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>aNewFront</name></decl></param>,
       <param><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>aBufferRect</name></decl></param>,
       <param><decl><type><specifier>const</specifier> <name>nsIntPoint</name>&amp;</type> <name>aRotation</name></decl></param>)</parameter_list>
  <block>{
    <return>return <expr><call><name><name>mFrontBuffer</name>.<name>Swap</name></name><argument_list>(<argument><expr><name>aNewFront</name></expr></argument>, <argument><expr><name>aBufferRect</name></expr></argument>, <argument><expr><name>aRotation</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                     <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                     <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <macro><name>MOZ_LAYER_DECL_NAME</name><argument_list>(<argument>"BasicShadowThebesLayer"</argument>, <argument>TYPE_SHADOW</argument>)</argument_list></macro>

</public><private>private:
  <function><type><name>BasicShadowLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicShadowLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <decl_stmt><decl><type><name>ShadowThebesLayerBuffer</name></type> <name>mFrontBuffer</name></decl>;</decl_stmt>
</private>}</block>;</class>

<destructor><name><name>BasicShadowThebesLayer</name>::~<name>BasicShadowThebesLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>frontBuffer</name> <init>=
    <expr><call><name><name>mFrontBuffer</name>.<name>Swap</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>nsIntRect</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>frontBuffer</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name><name>ShadowLayerManager</name>::<name>DestroySharedSurface</name></name><argument_list>(<argument><expr><name>frontBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicShadowThebesLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>void</name></type>
<name><name>BasicShadowThebesLayer</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                              <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                              <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                              <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InDrawing</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Can only draw in drawing phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>IsRetained</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"ShadowThebesLayer makes no sense without retained mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>gfxContext</name>*</type> <name>target</name> <init>= <expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>GetTarget</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr>"We shouldn't be called if there's no target"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxASurface</name></expr></argument>&gt;</argument_list></name></type> <name>targetSurface</name> <init>= <expr><call><name><name>aContext</name>-&gt;<name>CurrentSurface</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PRBool</name></type> <name>isOpaqueContent</name> <init>=
    <expr>(<call><name><name>targetSurface</name>-&gt;<name>AreSimilarSurfacesSensitiveToContentType</name></name><argument_list>()</argument_list></call> &amp;&amp;
     <name>aOpacity</name> == 1.0 &amp;&amp;
     <call><name>CanUseOpaqueSurface</name><argument_list>()</argument_list></call>)</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>mFrontBuffer</name>.<name>DrawTo</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>isOpaqueContent</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>aOpacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<class>class <name>BasicShadowImageLayer</name> <super>: <specifier>public</specifier> <name>ShadowImageLayer</name>, <name>BasicImplData</name></super> <block>{<private type="default">
</private><public>public:
  <constructor><name>BasicShadowImageLayer</name><parameter_list>(<param><decl><type><name>BasicShadowLayerManager</name>*</type> <name>aLayerManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>ShadowImageLayer</name><argument_list>(<argument><expr><name>aLayerManager</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicImplData</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicShadowImageLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicShadowImageLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <if>if <condition>(<expr><name>mFrontSurface</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name><name>ShadowLayerManager</name>::<name>DestroySharedSurface</name></name><argument_list>(<argument><expr><name>mFrontSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicShadowImageLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function_decl><type><specifier>virtual</specifier> <name>PRBool</name></type> <name>Init</name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>front</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>nsIntSize</name>&amp;</type> <name>size</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>virtual</specifier> <name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type>
  <name>Swap</name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>newFront</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                     <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                     <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <macro><name>MOZ_LAYER_DECL_NAME</name><argument_list>(<argument>"BasicShadowImageLayer"</argument>, <argument>TYPE_SHADOW</argument>)</argument_list></macro>

</public><protected>protected:
  <function><type><name>BasicShadowLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicShadowLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <comment type="line">// XXX ShmemImage?</comment>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>mFrontSurface</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>gfxIntSize</name></type> <name>mSize</name></decl>;</decl_stmt>
</protected>}</block>;</class>

<function><type><name>PRBool</name></type>
<name><name>BasicShadowImageLayer</name>::<name>Init</name></name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>front</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>nsIntSize</name>&amp;</type> <name>size</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>mFrontSurface</name> = <name>front</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mSize</name> = <call><name>gfxIntSize</name><argument_list>(<argument><expr><name><name>size</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>size</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_TRUE</name></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowImageLayer</name>::<name>Swap</name></name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>newFront</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>tmp</name> <init>= <expr><call><name><name>mFrontSurface</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>mFrontSurface</name> = <name>newFront</name></expr>;</expr_stmt>
  <return>return <expr><name>tmp</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicShadowImageLayer</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                             <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                             <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                             <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>pat</name> <init>= <expr>new <call><name>gfxPattern</name><argument_list>(<argument><expr><name>mFrontSurface</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>pat</name>-&gt;<name>SetFilter</name></name><argument_list>(<argument><expr><name>mFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>BasicImageLayer</name>::<name>PaintContext</name></name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>mSize</name></expr></argument>, <argument><expr><name>aOpacity</name></expr></argument>, <argument><expr><name>aContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<class>class <name>BasicShadowCanvasLayer</name> <super>: <specifier>public</specifier> <name>ShadowCanvasLayer</name>,
                               <name>BasicImplData</name></super>
<block>{<private type="default">
</private><public>public:
  <constructor><name>BasicShadowCanvasLayer</name><parameter_list>(<param><decl><type><name>BasicShadowLayerManager</name>*</type> <name>aLayerManager</name></decl></param>)</parameter_list> <member_list>:
    <call><name>ShadowCanvasLayer</name><argument_list>(<argument><expr><name>aLayerManager</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicImplData</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
  </member_list><block>{
    <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicShadowCanvasLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></constructor>
  <destructor><specifier>virtual</specifier> <name>~<name>BasicShadowCanvasLayer</name></name><parameter_list>()</parameter_list>
  <block>{
    <if>if <condition>(<expr><name>mFrontSurface</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name><name>ShadowLayerManager</name>::<name>DestroySharedSurface</name></name><argument_list>(<argument><expr><name>mFrontSurface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicShadowCanvasLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></destructor>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Initialize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Data</name>&amp;</type> <name>aData</name></decl></param>)</parameter_list>;</function_decl>

  <function><type><specifier>virtual</specifier> <name>void</name></type> <name>Updated</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nsIntRect</name>&amp;</type> <name>aRect</name></decl></param>)</parameter_list>
  <block>{}</block></function>

  <function_decl><type><specifier>virtual</specifier> <name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type>
  <name>Swap</name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>newFront</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>Paint</name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                     <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                     <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                     <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>;</function_decl>

  <macro><name>MOZ_LAYER_DECL_NAME</name><argument_list>(<argument>"BasicShadowCanvasLayer"</argument>, <argument>TYPE_SHADOW</argument>)</argument_list></macro>

</public><private>private:
  <function><type><name>BasicShadowLayerManager</name>*</type> <name>BasicManager</name><parameter_list>()</parameter_list>
  <block>{
    <return>return <expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>BasicShadowLayerManager</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>mManager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></function>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>mFrontSurface</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>nsIntRect</name></type> <name>mBounds</name></decl>;</decl_stmt>
</private>}</block>;</class>

<function><type><name>void</name></type>
<name><name>BasicShadowCanvasLayer</name>::<name>Initialize</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Data</name>&amp;</type> <name>aData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name>mFrontSurface</name> == <name>nsnull</name></expr></argument>,
               <argument><expr>"BasicCanvasLayer::Initialize called twice!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><name><name>aData</name>.<name>mSurface</name></name> &amp;&amp; !<name><name>aData</name>.<name>mGLContext</name></name></expr></argument>, <argument><expr>"no comprende OpenGL!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mFrontSurface</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name>*</expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>aData</name>.<name>mSurface</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mBounds</name>.<name>SetRect</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>aData</name>.<name>mSize</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>aData</name>.<name>mSize</name>.<name>height</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowCanvasLayer</name>::<name>Swap</name></name><parameter_list>(<param><decl><type><name>gfxSharedImageSurface</name>*</type> <name>newFront</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>gfxSharedImageSurface</name></expr></argument>&gt;</argument_list></name></type> <name>tmp</name> <init>= <expr><call><name><name>mFrontSurface</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>mFrontSurface</name> = <name>newFront</name></expr>;</expr_stmt>
  <return>return <expr><name>tmp</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicShadowCanvasLayer</name>::<name>Paint</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aContext</name></decl></param>,
                              <param><decl><type><name><name>LayerManager</name>::<name>DrawThebesLayerCallback</name></name></type> <name>aCallback</name></decl></param>,
                              <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>,
                              <param><decl><type><name>float</name></type> <name>aOpacity</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>MOZ_LAYERS_LOG</name><argument_list>(<argument><expr>("[ShadowLayersChild] %s()", <name>__FUNCTION__</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>BasicManager</name><argument_list>()</argument_list></call>-&gt;<call><name>InDrawing</name><argument_list>()</argument_list></call></expr></argument>,
               <argument><expr>"Can only draw in drawing phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>gfxPattern</name></expr></argument>&gt;</argument_list></name></type> <name>pat</name> <init>= <expr>new <call><name>gfxPattern</name><argument_list>(<argument><expr><name>mFrontSurface</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name><name>pat</name>-&gt;<name>SetFilter</name></name><argument_list>(<argument><expr><name>mFilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>pat</name>-&gt;<name>SetExtend</name></name><argument_list>(<argument><expr><name><name>gfxPattern</name>::<name>EXTEND_PAD</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>gfxRect</name></type> <name>r</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>mBounds</name>.<name>width</name></name></expr></argument>, <argument><expr><name><name>mBounds</name>.<name>height</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>NewPath</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>PixelSnappedRectangleAndSetPattern</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>aContext</name>-&gt;<name>Fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Create a shadow layer (PLayerChild) for aLayer, if we're forwarding</comment>
<comment type="line">// our layer tree to a parent process.  Record the new layer creation</comment>
<comment type="line">// in the current open transaction as a side effect.</comment>
<template>template<parameter_list>&lt;<param><type><typename>typename</typename></type> <name>CreatedMethod</name></param>&gt;</parameter_list>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MaybeCreateShadowFor</name><parameter_list>(<param><decl><type><name>BasicShadowableLayer</name>*</type> <name>aLayer</name></decl></param>,
                     <param><decl><type><name>BasicShadowLayerManager</name>*</type> <name>aMgr</name></decl></param>,
                     <param><decl><type><name>CreatedMethod</name></type> <name>aMethod</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name><name>aMgr</name>-&gt;<name>HasShadowManager</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>

  <decl_stmt><decl><type><name>PLayerChild</name>*</type> <name>shadow</name> <init>= <expr><call><name><name>aMgr</name>-&gt;<name>ConstructShadowFor</name></name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// XXX error handling</comment>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>shadow</name></expr></argument>, <argument><expr>"failed to create shadow"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>aLayer</name>-&gt;<name>SetShadow</name></name><argument_list>(<argument><expr><name>shadow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call>(<name><name>aMgr</name>-&gt;*<name>aMethod</name></name>)<argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function></template>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAYBE_CREATE_SHADOW</name><parameter_list>(<param><type><name>_type</name></type></param>)</parameter_list></cpp:macro>                                      \
  <cpp:value>MaybeCreateShadowFor(layer, this,                                     \
                       &amp;ShadowLayerForwarder::Created ## _type ## Layer)</cpp:value></cpp:define>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ThebesLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowLayerManager</name>::<name>CreateThebesLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>BasicShadowableThebesLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>=
    <expr>new <call><name>BasicShadowableThebesLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>MAYBE_CREATE_SHADOW</name><argument_list>(<argument><expr><name>Thebes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ContainerLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowLayerManager</name>::<name>CreateContainerLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>BasicShadowableContainerLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>=
    <expr>new <call><name>BasicShadowableContainerLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>MAYBE_CREATE_SHADOW</name><argument_list>(<argument><expr><name>Container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ImageLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowLayerManager</name>::<name>CreateImageLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>BasicShadowableImageLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>=
    <expr>new <call><name>BasicShadowableImageLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>MAYBE_CREATE_SHADOW</name><argument_list>(<argument><expr><name>Image</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ColorLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowLayerManager</name>::<name>CreateColorLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>BasicShadowableColorLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>=
    <expr>new <call><name>BasicShadowableColorLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>MAYBE_CREATE_SHADOW</name><argument_list>(<argument><expr><name>Color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>CanvasLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowLayerManager</name>::<name>CreateCanvasLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>BasicShadowableCanvasLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>=
    <expr>new <call><name>BasicShadowableCanvasLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>MAYBE_CREATE_SHADOW</name><argument_list>(<argument><expr><name>Canvas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ShadowThebesLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowLayerManager</name>::<name>CreateShadowThebesLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>ShadowThebesLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>= <expr>new <call><name>BasicShadowThebesLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ShadowImageLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowLayerManager</name>::<name>CreateShadowImageLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>ShadowImageLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>= <expr>new <call><name>BasicShadowImageLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<function><type><name><name>already_AddRefed</name><argument_list>&lt;<argument><expr><name>ShadowCanvasLayer</name></expr></argument>&gt;</argument_list></name></type>
<name><name>BasicShadowLayerManager</name>::<name>CreateShadowCanvasLayer</name></name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"Only allowed in construction phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name><name>nsRefPtr</name><argument_list>&lt;<argument><expr><name>ShadowCanvasLayer</name></expr></argument>&gt;</argument_list></name></type> <name>layer</name> <init>= <expr>new <call><name>BasicShadowCanvasLayer</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name><name>layer</name>.<name>forget</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>

<constructor><name><name>BasicShadowLayerManager</name>::<name>BasicShadowLayerManager</name></name><parameter_list>(<param><decl><type><name>nsIWidget</name>*</type> <name>aWidget</name></decl></param>)</parameter_list> <member_list>:
  <call><name>BasicLayerManager</name><argument_list>(<argument><expr><name>aWidget</name></expr></argument>)</argument_list></call>
</member_list><block>{
  <expr_stmt><expr><call><name>MOZ_COUNT_CTOR</name><argument_list>(<argument><expr><name>BasicShadowLayerManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name>BasicShadowLayerManager</name>::~<name>BasicShadowLayerManager</name></name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">// FIXME/bug 570294: shadow forwarders don't have __delete__ until</comment>
  <comment type="line">// they have manager protocols</comment>
  <comment type="line">//</comment>
  <comment type="line">//if (HasShadowManager())</comment>
  <comment type="line">//  PLayersChild::Send__delete__(mShadow);</comment>
  <expr_stmt><expr><call><name>MOZ_COUNT_DTOR</name><argument_list>(<argument><expr><name>BasicShadowLayerManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name>void</name></type>
<name><name>BasicShadowLayerManager</name>::<name>SetRoot</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>mRoot</name> != <name>aLayer</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><call><name>HasShadowManager</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name><name>ShadowLayerForwarder</name>::<name>SetRoot</name></name><argument_list>(<argument><expr><call><name>Hold</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name><name>BasicLayerManager</name>::<name>SetRoot</name></name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicShadowLayerManager</name>::<name>Mutated</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ASSERTION</name><argument_list>(<argument><expr><call><name>InConstruction</name><argument_list>()</argument_list></call> || <call><name>InDrawing</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"wrong phase"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>HasShadowManager</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>ShadowLayerForwarder</name>::<name>Mutated</name></name><argument_list>(<argument><expr><call><name>Hold</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicShadowLayerManager</name>::<name>BeginTransactionWithTarget</name></name><parameter_list>(<param><decl><type><name>gfxContext</name>*</type> <name>aTarget</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name><name>mKeepAlive</name>.<name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>"uncommitted txn?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>HasShadowManager</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name><name>ShadowLayerForwarder</name>::<name>BeginTransaction</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name><name>BasicLayerManager</name>::<name>BeginTransactionWithTarget</name></name><argument_list>(<argument><expr><name>aTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name><name>BasicShadowLayerManager</name>::<name>EndTransaction</name></name><parameter_list>(<param><decl><type><name>DrawThebesLayerCallback</name></type> <name>aCallback</name></decl></param>,
                                        <param><decl><type><name>void</name>*</type> <name>aCallbackData</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name><name>BasicLayerManager</name>::<name>EndTransaction</name></name><argument_list>(<argument><expr><name>aCallback</name></expr></argument>, <argument><expr><name>aCallbackData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>mPhase</name> = <name>PHASE_FORWARD</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// forward this transaction's changeset to our ShadowLayerManager</comment>
  <decl_stmt><decl><type><name><name>nsAutoTArray</name><argument_list>&lt;<argument><expr><name>EditReply</name></expr></argument>, <argument><expr>10</expr></argument>&gt;</argument_list></name></type> <name>replies</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><call><name>HasShadowManager</name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>ShadowLayerForwarder</name>::<name>EndTransaction</name></name><argument_list>(<argument><expr>&amp;<name>replies</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <for>for (<init><decl><type><name><name><name>nsTArray</name><argument_list>&lt;<argument><expr><name>EditReply</name></expr></argument>&gt;</argument_list></name>::<name>size_type</name></name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>replies</name>.<name>Length</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>EditReply</name>&amp;</type> <name>reply</name> <init>= <expr><name><name>replies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <switch>switch <condition>(<expr><call><name><name>reply</name>.<name>type</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{
      <case>case <expr><name><name>EditReply</name>::<name>TOpBufferSwap</name></name></expr>: <block>{
        <expr_stmt><expr><call><name>MOZ_LAYERS_LOG</name><argument_list>(<argument><expr>("[LayersForwarder] BufferSwap")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>const</specifier> <name>OpBufferSwap</name>&amp;</type> <name>obs</name> <init>= <expr><call><name><name>reply</name>.<name>get_OpBufferSwap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GetBasicShadowable</name><argument_list>(<argument><expr><name>obs</name></expr></argument>)</argument_list></call>-&gt;<call><name>SetBackBuffer</name><argument_list>(
          <argument><expr>new <call><name>gfxSharedImageSurface</name><argument_list>(<argument><expr><call><name><name>obs</name>.<name>newBackBuffer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block>

      </case><default>default:
        <expr_stmt><expr><call><name>NS_RUNTIMEABORT</name><argument_list>(<argument><expr>"not reached"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </default>}</block></switch>
    }</block></for>
  }</block></then> <else>else <if>if <condition>(<expr><call><name>HasShadowManager</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>NS_WARNING</name><argument_list>(<argument><expr>"failed to forward Layers transaction"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>

  <comment type="line">// this may result in Layers being deleted, which results in</comment>
  <comment type="line">// PLayer::Send__delete__() and DeallocShmem()</comment>
  <expr_stmt><expr><call><name><name>mKeepAlive</name>.<name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>mPhase</name> = <name>PHASE_NONE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>ShadowableLayer</name>*</type>
<name><name>BasicShadowLayerManager</name>::<name>Hold</name></name><parameter_list>(<param><decl><type><name>Layer</name>*</type> <name>aLayer</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><call><name>HasShadowManager</name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr>"top-level tree, no shadow tree to remote to"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>ShadowableLayer</name>*</type> <name>shadowable</name> <init>= <expr><call><name>ToShadowable</name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>NS_ABORT_IF_FALSE</name><argument_list>(<argument><expr><name>shadowable</name></expr></argument>, <argument><expr>"trying to remote an unshadowable layer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name><name>mKeepAlive</name>.<name>AppendElement</name></name><argument_list>(<argument><expr><name>aLayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>shadowable</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="line">// MOZ_IPC</comment>

}</block></namespace>
}</block></namespace>
</unit>
